package stdgo;
/**
    Package time provides functionality for measuring and displaying time.
    
    The calendrical calculations always assume a Gregorian calendar, with
    no leap seconds.
    
    # Monotonic Clocks
    
    Operating systems provide both a “wall clock,” which is subject to
    changes for clock synchronization, and a “monotonic clock,” which is
    not. The general rule is that the wall clock is for telling time and
    the monotonic clock is for measuring time. Rather than split the API,
    in this package the Time returned by time.Now contains both a wall
    clock reading and a monotonic clock reading; later time-telling
    operations use the wall clock reading, but later time-measuring
    operations, specifically comparisons and subtractions, use the
    monotonic clock reading.
    
    For example, this code always computes a positive elapsed time of
    approximately 20 milliseconds, even if the wall clock is changed during
    the operation being timed:
    
    	start := time.Now()
    	... operation that takes 20 milliseconds ...
    	t := time.Now()
    	elapsed := t.Sub(start)
    
    Other idioms, such as time.Since(start), time.Until(deadline), and
    time.Now().Before(deadline), are similarly robust against wall clock
    resets.
    
    The rest of this section gives the precise details of how operations
    use monotonic clocks, but understanding those details is not required
    to use this package.
    
    The Time returned by time.Now contains a monotonic clock reading.
    If Time t has a monotonic clock reading, t.Add adds the same duration to
    both the wall clock and monotonic clock readings to compute the result.
    Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time
    computations, they always strip any monotonic clock reading from their results.
    Because t.In, t.Local, and t.UTC are used for their effect on the interpretation
    of the wall time, they also strip any monotonic clock reading from their results.
    The canonical way to strip a monotonic clock reading is to use t = t.Round(0).
    
    If Times t and u both contain monotonic clock readings, the operations
    t.After(u), t.Before(u), t.Equal(u), t.Compare(u), and t.Sub(u) are carried out
    using the monotonic clock readings alone, ignoring the wall clock
    readings. If either t or u contains no monotonic clock reading, these
    operations fall back to using the wall clock readings.
    
    On some systems the monotonic clock will stop if the computer goes to sleep.
    On such a system, t.Sub(u) may not accurately reflect the actual
    time that passed between t and u.
    
    Because the monotonic clock reading has no meaning outside
    the current process, the serialized forms generated by t.GobEncode,
    t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic
    clock reading, and t.Format provides no format for it. Similarly, the
    constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix,
    as well as the unmarshalers t.GobDecode, t.UnmarshalBinary.
    t.UnmarshalJSON, and t.UnmarshalText always create times with
    no monotonic clock reading.
    
    The monotonic clock reading exists only in Time values. It is not
    a part of Duration values or the Unix times returned by t.Unix and
    friends.
    
    Note that the Go == operator compares not just the time instant but
    also the Location and the monotonic clock reading. See the
    documentation for the Time type for a discussion of equality
    testing for Time values.
    
    For debugging, the result of t.String does include the monotonic
    clock reading if present. If t != u because of different monotonic clock readings,
    that difference will be visible when printing t.String() and u.String().
**/
private var __go2hxdoc__package : Bool;
final ruleJulian : stdgo._internal.time.Time.RuleKind = stdgo._internal.time.Time.ruleJulian;
final ruleDOY : stdgo._internal.time.Time.RuleKind = stdgo._internal.time.Time.ruleDOY;
final ruleMonthWeekDay : stdgo._internal.time.Time.RuleKind = stdgo._internal.time.Time.ruleMonthWeekDay;
final unixToInternal : haxe.Int64 = stdgo._internal.time.Time.unixToInternal;
final layout : String = stdgo._internal.time.Time.layout;
final ansic : String = stdgo._internal.time.Time.ansic;
final unixDate : String = stdgo._internal.time.Time.unixDate;
final rubyDate : String = stdgo._internal.time.Time.rubyDate;
final rfc822 : String = stdgo._internal.time.Time.rfc822;
final rfc822z : String = stdgo._internal.time.Time.rfc822z;
final rfc850 : String = stdgo._internal.time.Time.rfc850;
final rfc1123 : String = stdgo._internal.time.Time.rfc1123;
final rfc1123z : String = stdgo._internal.time.Time.rfc1123z;
final rfc3339 : String = stdgo._internal.time.Time.rfc3339;
final rfc3339nano : String = stdgo._internal.time.Time.rfc3339nano;
final kitchen : String = stdgo._internal.time.Time.kitchen;
final stamp : String = stdgo._internal.time.Time.stamp;
final stampMilli : String = stdgo._internal.time.Time.stampMilli;
final stampMicro : String = stdgo._internal.time.Time.stampMicro;
final stampNano : String = stdgo._internal.time.Time.stampNano;
final dateTime : String = stdgo._internal.time.Time.dateTime;
final dateOnly : String = stdgo._internal.time.Time.dateOnly;
final timeOnly : String = stdgo._internal.time.Time.timeOnly;
final january : stdgo._internal.time.Time.Month = stdgo._internal.time.Time.january;
final february = stdgo._internal.time.Time.february;
final march = stdgo._internal.time.Time.march;
final april = stdgo._internal.time.Time.april;
final may = stdgo._internal.time.Time.may;
final june = stdgo._internal.time.Time.june;
final july = stdgo._internal.time.Time.july;
final august = stdgo._internal.time.Time.august;
final september = stdgo._internal.time.Time.september;
final october = stdgo._internal.time.Time.october;
final november = stdgo._internal.time.Time.november;
final december = stdgo._internal.time.Time.december;
final sunday : stdgo._internal.time.Time.Weekday = stdgo._internal.time.Time.sunday;
final monday = stdgo._internal.time.Time.monday;
final tuesday = stdgo._internal.time.Time.tuesday;
final wednesday = stdgo._internal.time.Time.wednesday;
final thursday = stdgo._internal.time.Time.thursday;
final friday = stdgo._internal.time.Time.friday;
final saturday = stdgo._internal.time.Time.saturday;
final nanosecond : stdgo._internal.time.Time.Duration = stdgo._internal.time.Time.nanosecond;
final microsecond : stdgo._internal.time.Time.Duration = stdgo._internal.time.Time.microsecond;
final millisecond : stdgo._internal.time.Time.Duration = stdgo._internal.time.Time.millisecond;
final second : stdgo._internal.time.Time.Duration = stdgo._internal.time.Time.second;
final minute : stdgo._internal.time.Time.Duration = stdgo._internal.time.Time.minute;
final hour : stdgo._internal.time.Time.Duration = stdgo._internal.time.Time.hour;
var utc(get, set) : stdgo._internal.time.Time.Location;
private function get_utc():stdgo._internal.time.Time.Location return stdgo._internal.time.Time.utc;
private function set_utc(v:stdgo._internal.time.Time.Location):stdgo._internal.time.Time.Location return stdgo._internal.time.Time.utc = v;
var local(get, set) : stdgo._internal.time.Time.Location;
private function get_local():stdgo._internal.time.Time.Location return stdgo._internal.time.Time.local;
private function set_local(v:stdgo._internal.time.Time.Location):stdgo._internal.time.Time.Location return stdgo._internal.time.Time.local = v;
var gorootZoneSource(get, set) : stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : Bool; };
private function get_gorootZoneSource():stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : Bool; } return stdgo._internal.time.Time.gorootZoneSource;
private function set_gorootZoneSource(v:stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : Bool; }):stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : Bool; } return stdgo._internal.time.Time.gorootZoneSource = v;
var parseTimeZone(get, set) : stdgo.GoString -> { var _0 : stdgo.GoInt; var _1 : Bool; };
private function get_parseTimeZone():stdgo.GoString -> { var _0 : stdgo.GoInt; var _1 : Bool; } return stdgo._internal.time.Time.parseTimeZone;
private function set_parseTimeZone(v:stdgo.GoString -> { var _0 : stdgo.GoInt; var _1 : Bool; }):stdgo.GoString -> { var _0 : stdgo.GoInt; var _1 : Bool; } return stdgo._internal.time.Time.parseTimeZone = v;
var setMono(get, set) : (stdgo.Ref<stdgo._internal.time.Time.Time>, stdgo.GoInt64) -> Void;
private function get_setMono():(stdgo.Ref<stdgo._internal.time.Time.Time>, stdgo.GoInt64) -> Void return stdgo._internal.time.Time.setMono;
private function set_setMono(v:(stdgo.Ref<stdgo._internal.time.Time.Time>, stdgo.GoInt64) -> Void):(stdgo.Ref<stdgo._internal.time.Time.Time>, stdgo.GoInt64) -> Void return stdgo._internal.time.Time.setMono = v;
var getMono(get, set) : stdgo.Ref<stdgo._internal.time.Time.Time> -> stdgo.GoInt64;
private function get_getMono():stdgo.Ref<stdgo._internal.time.Time.Time> -> stdgo.GoInt64 return stdgo._internal.time.Time.getMono;
private function set_getMono(v:stdgo.Ref<stdgo._internal.time.Time.Time> -> stdgo.GoInt64):stdgo.Ref<stdgo._internal.time.Time.Time> -> stdgo.GoInt64 return stdgo._internal.time.Time.getMono = v;
var errLocation(get, set) : stdgo.Error;
private function get_errLocation():stdgo.Error return stdgo._internal.time.Time.errLocation;
private function set_errLocation(v:stdgo.Error):stdgo.Error return stdgo._internal.time.Time.errLocation = v;
var readFile(get, set) : stdgo.GoString -> { var _0 : stdgo.Slice<stdgo.GoUInt8>; var _1 : stdgo.Error; };
private function get_readFile():stdgo.GoString -> { var _0 : stdgo.Slice<stdgo.GoUInt8>; var _1 : stdgo.Error; } return stdgo._internal.time.Time.readFile;
private function set_readFile(v:stdgo.GoString -> { var _0 : stdgo.Slice<stdgo.GoUInt8>; var _1 : stdgo.Error; }):stdgo.GoString -> { var _0 : stdgo.Slice<stdgo.GoUInt8>; var _1 : stdgo.Error; } return stdgo._internal.time.Time.readFile = v;
var loadTzinfo(get, set) : (stdgo.GoString, stdgo.GoString) -> { var _0 : stdgo.Slice<stdgo.GoUInt8>; var _1 : stdgo.Error; };
private function get_loadTzinfo():(stdgo.GoString, stdgo.GoString) -> { var _0 : stdgo.Slice<stdgo.GoUInt8>; var _1 : stdgo.Error; } return stdgo._internal.time.Time.loadTzinfo;
private function set_loadTzinfo(v:(stdgo.GoString, stdgo.GoString) -> { var _0 : stdgo.Slice<stdgo.GoUInt8>; var _1 : stdgo.Error; }):(stdgo.GoString, stdgo.GoString) -> { var _0 : stdgo.Slice<stdgo.GoUInt8>; var _1 : stdgo.Error; } return stdgo._internal.time.Time.loadTzinfo = v;
var nextStdChunk(get, set) : stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoString; };
private function get_nextStdChunk():stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoString; } return stdgo._internal.time.Time.nextStdChunk;
private function set_nextStdChunk(v:stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoString; }):stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoString; } return stdgo._internal.time.Time.nextStdChunk = v;
var tzset(get, set) : (stdgo.GoString, stdgo.GoInt64, stdgo.GoInt64) -> { var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoInt64; var _3 : stdgo.GoInt64; var _4 : Bool; var _5 : Bool; };
private function get_tzset():(stdgo.GoString, stdgo.GoInt64, stdgo.GoInt64) -> { var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoInt64; var _3 : stdgo.GoInt64; var _4 : Bool; var _5 : Bool; } return stdgo._internal.time.Time.tzset;
private function set_tzset(v:(stdgo.GoString, stdgo.GoInt64, stdgo.GoInt64) -> { var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoInt64; var _3 : stdgo.GoInt64; var _4 : Bool; var _5 : Bool; }):(stdgo.GoString, stdgo.GoInt64, stdgo.GoInt64) -> { var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoInt64; var _3 : stdgo.GoInt64; var _4 : Bool; var _5 : Bool; } return stdgo._internal.time.Time.tzset = v;
var tzsetName(get, set) : stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : stdgo.GoString; var _2 : Bool; };
private function get_tzsetName():stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : stdgo.GoString; var _2 : Bool; } return stdgo._internal.time.Time.tzsetName;
private function set_tzsetName(v:stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : stdgo.GoString; var _2 : Bool; }):stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : stdgo.GoString; var _2 : Bool; } return stdgo._internal.time.Time.tzsetName = v;
var tzsetOffset(get, set) : stdgo.GoString -> { var _0 : stdgo.GoInt; var _1 : stdgo.GoString; var _2 : Bool; };
private function get_tzsetOffset():stdgo.GoString -> { var _0 : stdgo.GoInt; var _1 : stdgo.GoString; var _2 : Bool; } return stdgo._internal.time.Time.tzsetOffset;
private function set_tzsetOffset(v:stdgo.GoString -> { var _0 : stdgo.GoInt; var _1 : stdgo.GoString; var _2 : Bool; }):stdgo.GoString -> { var _0 : stdgo.GoInt; var _1 : stdgo.GoString; var _2 : Bool; } return stdgo._internal.time.Time.tzsetOffset = v;
var stdChunkNames(get, set) : stdgo.GoMap<stdgo.GoInt, stdgo.GoString>;
private function get_stdChunkNames():stdgo.GoMap<stdgo.GoInt, stdgo.GoString> return stdgo._internal.time.Time.stdChunkNames;
private function set_stdChunkNames(v:stdgo.GoMap<stdgo.GoInt, stdgo.GoString>):stdgo.GoMap<stdgo.GoInt, stdgo.GoString> return stdgo._internal.time.Time.stdChunkNames = v;
var quote(get, set) : stdgo.GoString -> stdgo.GoString;
private function get_quote():stdgo.GoString -> stdgo.GoString return stdgo._internal.time.Time.quote;
private function set_quote(v:stdgo.GoString -> stdgo.GoString):stdgo.GoString -> stdgo.GoString return stdgo._internal.time.Time.quote = v;
var appendInt(get, set) : (stdgo.Slice<stdgo.GoUInt8>, stdgo.GoInt, stdgo.GoInt) -> stdgo.Slice<stdgo.GoUInt8>;
private function get_appendInt():(stdgo.Slice<stdgo.GoUInt8>, stdgo.GoInt, stdgo.GoInt) -> stdgo.Slice<stdgo.GoUInt8> return stdgo._internal.time.Time.appendInt;
private function set_appendInt(v:(stdgo.Slice<stdgo.GoUInt8>, stdgo.GoInt, stdgo.GoInt) -> stdgo.Slice<stdgo.GoUInt8>):(stdgo.Slice<stdgo.GoUInt8>, stdgo.GoInt, stdgo.GoInt) -> stdgo.Slice<stdgo.GoUInt8> return stdgo._internal.time.Time.appendInt = v;
var appendFormatAny(get, set) : (stdgo._internal.time.Time.Time, stdgo.Slice<stdgo.GoUInt8>, stdgo.GoString) -> stdgo.Slice<stdgo.GoUInt8>;
private function get_appendFormatAny():(stdgo._internal.time.Time.Time, stdgo.Slice<stdgo.GoUInt8>, stdgo.GoString) -> stdgo.Slice<stdgo.GoUInt8> return stdgo._internal.time.Time.appendFormatAny;
private function set_appendFormatAny(v:(stdgo._internal.time.Time.Time, stdgo.Slice<stdgo.GoUInt8>, stdgo.GoString) -> stdgo.Slice<stdgo.GoUInt8>):(stdgo._internal.time.Time.Time, stdgo.Slice<stdgo.GoUInt8>, stdgo.GoString) -> stdgo.Slice<stdgo.GoUInt8> return stdgo._internal.time.Time.appendFormatAny = v;
var appendFormatRFC3339(get, set) : (stdgo._internal.time.Time.Time, stdgo.Slice<stdgo.GoUInt8>, Bool) -> stdgo.Slice<stdgo.GoUInt8>;
private function get_appendFormatRFC3339():(stdgo._internal.time.Time.Time, stdgo.Slice<stdgo.GoUInt8>, Bool) -> stdgo.Slice<stdgo.GoUInt8> return stdgo._internal.time.Time.appendFormatRFC3339;
private function set_appendFormatRFC3339(v:(stdgo._internal.time.Time.Time, stdgo.Slice<stdgo.GoUInt8>, Bool) -> stdgo.Slice<stdgo.GoUInt8>):(stdgo._internal.time.Time.Time, stdgo.Slice<stdgo.GoUInt8>, Bool) -> stdgo.Slice<stdgo.GoUInt8> return stdgo._internal.time.Time.appendFormatRFC3339 = v;
var parseAny(get, set) : (stdgo.GoString, stdgo.GoString, stdgo.Ref<stdgo._internal.time.Time.Location>, stdgo.Ref<stdgo._internal.time.Time.Location>) -> { var _0 : stdgo._internal.time.Time.Time; var _1 : stdgo.Error; };
private function get_parseAny():(stdgo.GoString, stdgo.GoString, stdgo.Ref<stdgo._internal.time.Time.Location>, stdgo.Ref<stdgo._internal.time.Time.Location>) -> { var _0 : stdgo._internal.time.Time.Time; var _1 : stdgo.Error; } return stdgo._internal.time.Time.parseAny;
private function set_parseAny(v:(stdgo.GoString, stdgo.GoString, stdgo.Ref<stdgo._internal.time.Time.Location>, stdgo.Ref<stdgo._internal.time.Time.Location>) -> { var _0 : stdgo._internal.time.Time.Time; var _1 : stdgo.Error; }):(stdgo.GoString, stdgo.GoString, stdgo.Ref<stdgo._internal.time.Time.Location>, stdgo.Ref<stdgo._internal.time.Time.Location>) -> { var _0 : stdgo._internal.time.Time.Time; var _1 : stdgo.Error; } return stdgo._internal.time.Time.parseAny = v;
var parseRFC3339(get, set) : (stdgo.GoString, stdgo.Ref<stdgo._internal.time.Time.Location>) -> { var _0 : stdgo._internal.time.Time.Time; var _1 : Bool; };
private function get_parseRFC3339():(stdgo.GoString, stdgo.Ref<stdgo._internal.time.Time.Location>) -> { var _0 : stdgo._internal.time.Time.Time; var _1 : Bool; } return stdgo._internal.time.Time.parseRFC3339;
private function set_parseRFC3339(v:(stdgo.GoString, stdgo.Ref<stdgo._internal.time.Time.Location>) -> { var _0 : stdgo._internal.time.Time.Time; var _1 : Bool; }):(stdgo.GoString, stdgo.Ref<stdgo._internal.time.Time.Location>) -> { var _0 : stdgo._internal.time.Time.Time; var _1 : Bool; } return stdgo._internal.time.Time.parseRFC3339 = v;
var disablePlatformSources(get, set) : () -> (() -> Void);
private function get_disablePlatformSources():() -> (() -> Void) return stdgo._internal.time.Time.disablePlatformSources;
private function set_disablePlatformSources(v:() -> (() -> Void)):() -> (() -> Void) return stdgo._internal.time.Time.disablePlatformSources = v;
var interrupt(get, set) : () -> Void;
private function get_interrupt():() -> Void return stdgo._internal.time.Time.interrupt;
private function set_interrupt(v:() -> Void):() -> Void return stdgo._internal.time.Time.interrupt = v;
var daysIn(get, set) : (stdgo._internal.time.Time.Month, stdgo.GoInt) -> stdgo.GoInt;
private function get_daysIn():(stdgo._internal.time.Time.Month, stdgo.GoInt) -> stdgo.GoInt return stdgo._internal.time.Time.daysIn;
private function set_daysIn(v:(stdgo._internal.time.Time.Month, stdgo.GoInt) -> stdgo.GoInt):(stdgo._internal.time.Time.Month, stdgo.GoInt) -> stdgo.GoInt return stdgo._internal.time.Time.daysIn = v;
var minMonoTime(get, set) : stdgo._internal.time.Time.Time;
private function get_minMonoTime():stdgo._internal.time.Time.Time return stdgo._internal.time.Time.minMonoTime;
private function set_minMonoTime(v:stdgo._internal.time.Time.Time):stdgo._internal.time.Time.Time return stdgo._internal.time.Time.minMonoTime = v;
var maxMonoTime(get, set) : stdgo._internal.time.Time.Time;
private function get_maxMonoTime():stdgo._internal.time.Time.Time return stdgo._internal.time.Time.maxMonoTime;
private function set_maxMonoTime(v:stdgo._internal.time.Time.Time):stdgo._internal.time.Time.Time return stdgo._internal.time.Time.maxMonoTime = v;
var notMonoNegativeTime(get, set) : stdgo._internal.time.Time.Time;
private function get_notMonoNegativeTime():stdgo._internal.time.Time.Time return stdgo._internal.time.Time.notMonoNegativeTime;
private function set_notMonoNegativeTime(v:stdgo._internal.time.Time.Time):stdgo._internal.time.Time.Time return stdgo._internal.time.Time.notMonoNegativeTime = v;
@:forward @:forward.new abstract Rule(stdgo._internal.time.Time.Rule) from stdgo._internal.time.Time.Rule to stdgo._internal.time.Time.Rule {

}
@:forward @:forward.new abstract ParseError(stdgo._internal.time.Time.ParseError) from stdgo._internal.time.Time.ParseError to stdgo._internal.time.Time.ParseError {

}
@:forward @:forward.new abstract T_runtimeTimer(stdgo._internal.time.Time.T_runtimeTimer) from stdgo._internal.time.Time.T_runtimeTimer to stdgo._internal.time.Time.T_runtimeTimer {

}
@:forward @:forward.new abstract Timer(stdgo._internal.time.Time.Timer) from stdgo._internal.time.Time.Timer to stdgo._internal.time.Time.Timer {

}
@:forward @:forward.new abstract Ticker(stdgo._internal.time.Time.Ticker) from stdgo._internal.time.Time.Ticker to stdgo._internal.time.Time.Ticker {

}
@:forward @:forward.new abstract Time(stdgo._internal.time.Time.Time) from stdgo._internal.time.Time.Time to stdgo._internal.time.Time.Time {

}
@:forward @:forward.new abstract Location(stdgo._internal.time.Time.Location) from stdgo._internal.time.Time.Location to stdgo._internal.time.Time.Location {

}
@:forward @:forward.new abstract T_zone(stdgo._internal.time.Time.T_zone) from stdgo._internal.time.Time.T_zone to stdgo._internal.time.Time.T_zone {

}
@:forward @:forward.new abstract T_zoneTrans(stdgo._internal.time.Time.T_zoneTrans) from stdgo._internal.time.Time.T_zoneTrans to stdgo._internal.time.Time.T_zoneTrans {

}
@:forward @:forward.new abstract T_rule(stdgo._internal.time.Time.T_rule) from stdgo._internal.time.Time.T_rule to stdgo._internal.time.Time.T_rule {

}
@:forward @:forward.new abstract T_dataIO(stdgo._internal.time.Time.T_dataIO) from stdgo._internal.time.Time.T_dataIO to stdgo._internal.time.Time.T_dataIO {

}
typedef RuleKind = stdgo._internal.time.Time.RuleKind;
typedef Month = stdgo._internal.time.Time.Month;
typedef Weekday = stdgo._internal.time.Time.Weekday;
typedef Duration = stdgo._internal.time.Time.Duration;
typedef T_ruleKind = stdgo._internal.time.Time.T_ruleKind;
typedef T_fileSizeError = stdgo._internal.time.Time.T_fileSizeError;
function resetLocalOnceForTest():Void {
        stdgo._internal.time.Time.resetLocalOnceForTest();
    }
function forceUSPacificForTesting():Void {
        stdgo._internal.time.Time.forceUSPacificForTesting();
    }
function zoneinfoForTesting():stdgo.Pointer<String> {
        return stdgo._internal.time.Time.zoneinfoForTesting();
    }
function resetZoneinfoForTesting():Void {
        stdgo._internal.time.Time.resetZoneinfoForTesting();
    }
function loadFromEmbeddedTZData(zone:String):stdgo.Tuple<String, stdgo.Error> {
        return {
            final obj = stdgo._internal.time.Time.loadFromEmbeddedTZData(zone);
            { _0 : obj._0, _1 : obj._1 };
        };
    }
function tzsetRule(s:String):stdgo.Tuple.Tuple3<Rule, String, Bool> {
        return {
            final obj = stdgo._internal.time.Time.tzsetRule(s);
            { _0 : obj._0, _1 : obj._1, _2 : obj._2 };
        };
    }
/**
    Parse parses a formatted string and returns the time value it represents.
    See the documentation for the constant called Layout to see how to
    represent the format. The second argument must be parseable using
    the format string (layout) provided as the first argument.
    
    The example for Time.Format demonstrates the working of the layout string
    in detail and is a good reference.
    
    When parsing (only), the input may contain a fractional second
    field immediately after the seconds field, even if the layout does not
    signify its presence. In that case either a comma or a decimal point
    followed by a maximal series of digits is parsed as a fractional second.
    Fractional seconds are truncated to nanosecond precision.
    
    Elements omitted from the layout are assumed to be zero or, when
    zero is impossible, one, so parsing "3:04pm" returns the time
    corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is
    0, this time is before the zero Time).
    Years must be in the range 0000..9999. The day of the week is checked
    for syntax but it is otherwise ignored.
    
    For layouts specifying the two-digit year 06, a value NN >= 69 will be treated
    as 19NN and a value NN < 69 will be treated as 20NN.
    
    The remainder of this comment describes the handling of time zones.
    
    In the absence of a time zone indicator, Parse returns a time in UTC.
    
    When parsing a time with a zone offset like -0700, if the offset corresponds
    to a time zone used by the current location (Local), then Parse uses that
    location and zone in the returned time. Otherwise it records the time as
    being in a fabricated location with time fixed at the given zone offset.
    
    When parsing a time with a zone abbreviation like MST, if the zone abbreviation
    has a defined offset in the current location, then that offset is used.
    The zone abbreviation "UTC" is recognized as UTC regardless of location.
    If the zone abbreviation is unknown, Parse records the time as being
    in a fabricated location with the given zone abbreviation and a zero offset.
    This choice means that such a time can be parsed and reformatted with the
    same layout losslessly, but the exact instant used in the representation will
    differ by the actual zone offset. To avoid such problems, prefer time layouts
    that use a numeric zone offset, or use ParseInLocation.
**/
function parse(layout:String, value:String):stdgo.Tuple<Time, stdgo.Error> {
        return {
            final obj = stdgo._internal.time.Time.parse(layout, value);
            { _0 : obj._0, _1 : obj._1 };
        };
    }
/**
    ParseInLocation is like Parse but differs in two important ways.
    First, in the absence of time zone information, Parse interprets a time as UTC;
    ParseInLocation interprets the time as in the given location.
    Second, when given a zone offset or abbreviation, Parse tries to match it
    against the Local location; ParseInLocation uses the given location.
**/
function parseInLocation(layout:String, value:String, loc:Location):stdgo.Tuple<Time, stdgo.Error> {
        return {
            final obj = stdgo._internal.time.Time.parseInLocation(layout, value, loc);
            { _0 : obj._0, _1 : obj._1 };
        };
    }
/**
    ParseDuration parses a duration string.
    A duration string is a possibly signed sequence of
    decimal numbers, each with optional fraction and a unit suffix,
    such as "300ms", "-1.5h" or "2h45m".
    Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
**/
function parseDuration(s:String):stdgo.Tuple<Duration, stdgo.Error> {
        return {
            final obj = stdgo._internal.time.Time.parseDuration(s);
            { _0 : obj._0, _1 : obj._1 };
        };
    }
/**
    Test that a runtimeTimer with a period that would overflow when on
    expiration does not throw or cause other timers to hang.
    
    This test has to be in internal_test.go since it fiddles with
    unexported data structures.
**/
function checkRuntimeTimerPeriodOverflow():Void {
        stdgo._internal.time.Time.checkRuntimeTimerPeriodOverflow();
    }
/**
    Sleep pauses the current goroutine for at least the duration d.
    A negative or zero duration causes Sleep to return immediately.
**/
function sleep(d:Duration):Void {
        stdgo._internal.time.Time.sleep(d);
    }
/**
    NewTimer creates a new Timer that will send
    the current time on its channel after at least duration d.
**/
function newTimer(d:Duration):Timer {
        return stdgo._internal.time.Time.newTimer(d);
    }
/**
    After waits for the duration to elapse and then sends the current time
    on the returned channel.
    It is equivalent to NewTimer(d).C.
    The underlying Timer is not recovered by the garbage collector
    until the timer fires. If efficiency is a concern, use NewTimer
    instead and call Timer.Stop if the timer is no longer needed.
**/
function after(d:Duration):stdgo.Chan<Time> {
        return stdgo._internal.time.Time.after(d);
    }
/**
    AfterFunc waits for the duration to elapse and then calls f
    in its own goroutine. It returns a Timer that can
    be used to cancel the call using its Stop method.
**/
function afterFunc(d:Duration, f:() -> Void):Timer {
        final f = f;
        return stdgo._internal.time.Time.afterFunc(d, f);
    }
/**
    NewTicker returns a new Ticker containing a channel that will send
    the current time on the channel after each tick. The period of the
    ticks is specified by the duration argument. The ticker will adjust
    the time interval or drop ticks to make up for slow receivers.
    The duration d must be greater than zero; if not, NewTicker will
    panic. Stop the ticker to release associated resources.
**/
function newTicker(d:Duration):Ticker {
        return stdgo._internal.time.Time.newTicker(d);
    }
/**
    Tick is a convenience wrapper for NewTicker providing access to the ticking
    channel only. While Tick is useful for clients that have no need to shut down
    the Ticker, be aware that without a way to shut it down the underlying
    Ticker cannot be recovered by the garbage collector; it "leaks".
    Unlike NewTicker, Tick will return nil if d <= 0.
**/
function tick(d:Duration):stdgo.Chan<Time> {
        return stdgo._internal.time.Time.tick(d);
    }
/**
    Since returns the time elapsed since t.
    It is shorthand for time.Now().Sub(t).
**/
function since(t:Time):Duration {
        return stdgo._internal.time.Time.since(t);
    }
/**
    Until returns the duration until t.
    It is shorthand for t.Sub(time.Now()).
**/
function until(t:Time):Duration {
        return stdgo._internal.time.Time.until(t);
    }
/**
    Now returns the current local time.
**/
function now():Time {
        return stdgo._internal.time.Time.now();
    }
/**
    Unix returns the local Time corresponding to the given Unix time,
    sec seconds and nsec nanoseconds since January 1, 1970 UTC.
    It is valid to pass nsec outside the range [0, 999999999].
    Not all sec values have a corresponding time value. One such
    value is 1<<63-1 (the largest int64 value).
**/
function unix(sec:haxe.Int64, nsec:haxe.Int64):Time {
        return stdgo._internal.time.Time.unix(sec, nsec);
    }
/**
    UnixMilli returns the local Time corresponding to the given Unix time,
    msec milliseconds since January 1, 1970 UTC.
**/
function unixMilli(msec:haxe.Int64):Time {
        return stdgo._internal.time.Time.unixMilli(msec);
    }
/**
    UnixMicro returns the local Time corresponding to the given Unix time,
    usec microseconds since January 1, 1970 UTC.
**/
function unixMicro(usec:haxe.Int64):Time {
        return stdgo._internal.time.Time.unixMicro(usec);
    }
/**
    Date returns the Time corresponding to
    
    	yyyy-mm-dd hh:mm:ss + nsec nanoseconds
    
    in the appropriate zone for that time in the given location.
    
    The month, day, hour, min, sec, and nsec values may be outside
    their usual ranges and will be normalized during the conversion.
    For example, October 32 converts to November 1.
    
    A daylight savings time transition skips or repeats times.
    For example, in the United States, March 13, 2011 2:15am never occurred,
    while November 6, 2011 1:15am occurred twice. In such cases, the
    choice of time zone, and therefore the time, is not well-defined.
    Date returns a time that is correct in one of the two zones involved
    in the transition, but it does not guarantee which.
    
    Date panics if loc is nil.
**/
function date(year:StdTypes.Int, month:Month, day:StdTypes.Int, hour:StdTypes.Int, min:StdTypes.Int, sec:StdTypes.Int, nsec:StdTypes.Int, loc:Location):Time {
        return stdgo._internal.time.Time.date(year, month, day, hour, min, sec, nsec, loc);
    }
/**
    FixedZone returns a Location that always uses
    the given zone name and offset (seconds east of UTC).
**/
function fixedZone(name:String, offset:StdTypes.Int):Location {
        return stdgo._internal.time.Time.fixedZone(name, offset);
    }
/**
    LoadLocation returns the Location with the given name.
    
    If the name is "" or "UTC", LoadLocation returns UTC.
    If the name is "Local", LoadLocation returns Local.
    
    Otherwise, the name is taken to be a location name corresponding to a file
    in the IANA Time Zone database, such as "America/New_York".
    
    LoadLocation looks for the IANA Time Zone database in the following
    locations in order:
    
      - the directory or uncompressed zip file named by the ZONEINFO environment variable
      - on a Unix system, the system standard installation location
      - $GOROOT/lib/time/zoneinfo.zip
      - the time/tzdata package, if it was imported
**/
function loadLocation(name:String):stdgo.Tuple<Location, stdgo.Error> {
        return {
            final obj = stdgo._internal.time.Time.loadLocation(name);
            { _0 : obj._0, _1 : obj._1 };
        };
    }
/**
    LoadLocationFromTZData returns a Location with the given name
    initialized from the IANA Time Zone database-formatted data.
    The data should be in the format of a standard IANA time zone file
    (for example, the content of /etc/localtime on Unix systems).
**/
function loadLocationFromTZData(name:String, data:Array<StdTypes.Int>):stdgo.Tuple<Location, stdgo.Error> {
        final data = ([for (i in data) i] : stdgo.Slice<stdgo.GoByte>);
        return {
            final obj = stdgo._internal.time.Time.loadLocationFromTZData(name, data);
            { _0 : obj._0, _1 : obj._1 };
        };
    }
@:forward @:forward.new abstract ParseError_asInterface(stdgo._internal.time.Time.ParseError_asInterface) from stdgo._internal.time.Time.ParseError_asInterface to stdgo._internal.time.Time.ParseError_asInterface {

}
@:forward @:forward.new abstract ParseError_static_extension(stdgo._internal.time.Time.ParseError_static_extension) from stdgo._internal.time.Time.ParseError_static_extension to stdgo._internal.time.Time.ParseError_static_extension {

}
@:forward @:forward.new abstract Timer_asInterface(stdgo._internal.time.Time.Timer_asInterface) from stdgo._internal.time.Time.Timer_asInterface to stdgo._internal.time.Time.Timer_asInterface {

}
@:forward @:forward.new abstract Timer_static_extension(stdgo._internal.time.Time.Timer_static_extension) from stdgo._internal.time.Time.Timer_static_extension to stdgo._internal.time.Time.Timer_static_extension {

}
@:forward @:forward.new abstract Ticker_asInterface(stdgo._internal.time.Time.Ticker_asInterface) from stdgo._internal.time.Time.Ticker_asInterface to stdgo._internal.time.Time.Ticker_asInterface {

}
@:forward @:forward.new abstract Ticker_static_extension(stdgo._internal.time.Time.Ticker_static_extension) from stdgo._internal.time.Time.Ticker_static_extension to stdgo._internal.time.Time.Ticker_static_extension {

}
@:forward @:forward.new abstract Time_asInterface(stdgo._internal.time.Time.Time_asInterface) from stdgo._internal.time.Time.Time_asInterface to stdgo._internal.time.Time.Time_asInterface {

}
@:forward @:forward.new abstract Time_static_extension(stdgo._internal.time.Time.Time_static_extension) from stdgo._internal.time.Time.Time_static_extension to stdgo._internal.time.Time.Time_static_extension {

}
@:forward @:forward.new abstract Location_asInterface(stdgo._internal.time.Time.Location_asInterface) from stdgo._internal.time.Time.Location_asInterface to stdgo._internal.time.Time.Location_asInterface {

}
@:forward @:forward.new abstract Location_static_extension(stdgo._internal.time.Time.Location_static_extension) from stdgo._internal.time.Time.Location_static_extension to stdgo._internal.time.Time.Location_static_extension {

}
@:forward @:forward.new abstract T_dataIO_asInterface(stdgo._internal.time.Time.T_dataIO_asInterface) from stdgo._internal.time.Time.T_dataIO_asInterface to stdgo._internal.time.Time.T_dataIO_asInterface {

}
@:forward @:forward.new abstract T_dataIO_static_extension(stdgo._internal.time.Time.T_dataIO_static_extension) from stdgo._internal.time.Time.T_dataIO_static_extension to stdgo._internal.time.Time.T_dataIO_static_extension {

}
@:forward @:forward.new abstract Month_asInterface(stdgo._internal.time.Time.Month_asInterface) from stdgo._internal.time.Time.Month_asInterface to stdgo._internal.time.Time.Month_asInterface {

}
@:forward @:forward.new abstract Month_static_extension(stdgo._internal.time.Time.Month_static_extension) from stdgo._internal.time.Time.Month_static_extension to stdgo._internal.time.Time.Month_static_extension {

}
@:forward @:forward.new abstract Weekday_asInterface(stdgo._internal.time.Time.Weekday_asInterface) from stdgo._internal.time.Time.Weekday_asInterface to stdgo._internal.time.Time.Weekday_asInterface {

}
@:forward @:forward.new abstract Weekday_static_extension(stdgo._internal.time.Time.Weekday_static_extension) from stdgo._internal.time.Time.Weekday_static_extension to stdgo._internal.time.Time.Weekday_static_extension {

}
@:forward @:forward.new abstract Duration_asInterface(stdgo._internal.time.Time.Duration_asInterface) from stdgo._internal.time.Time.Duration_asInterface to stdgo._internal.time.Time.Duration_asInterface {

}
@:forward @:forward.new abstract Duration_static_extension(stdgo._internal.time.Time.Duration_static_extension) from stdgo._internal.time.Time.Duration_static_extension to stdgo._internal.time.Time.Duration_static_extension {

}
@:forward @:forward.new abstract T_fileSizeError_asInterface(stdgo._internal.time.Time.T_fileSizeError_asInterface) from stdgo._internal.time.Time.T_fileSizeError_asInterface to stdgo._internal.time.Time.T_fileSizeError_asInterface {

}
@:forward @:forward.new abstract T_fileSizeError_static_extension(stdgo._internal.time.Time.T_fileSizeError_static_extension) from stdgo._internal.time.Time.T_fileSizeError_static_extension to stdgo._internal.time.Time.T_fileSizeError_static_extension {

}
