package stdgo._internal.math.big;
function testFloatSqrtSpecial(_t:stdgo.Ref<stdgo._internal.testing.Testing_T_.T_>):Void {
        for (__8 => _test in (new stdgo.Slice<stdgo._internal.math.big.Big_T__struct_69.T__struct_69>(3, 3, ...[({ _x : stdgo._internal.math.big.Big_newFloat.newFloat((0 : stdgo.GoFloat64)), _want : stdgo._internal.math.big.Big_newFloat.newFloat((0 : stdgo.GoFloat64)) } : stdgo._internal.math.big.Big_T__struct_69.T__struct_69), ({ _x : stdgo._internal.math.big.Big_newFloat.newFloat((0 : stdgo.GoFloat64)), _want : stdgo._internal.math.big.Big_newFloat.newFloat((0 : stdgo.GoFloat64)) } : stdgo._internal.math.big.Big_T__struct_69.T__struct_69), ({ _x : stdgo._internal.math.big.Big_newFloat.newFloat(stdgo._internal.math.Math_inf.inf((1 : stdgo.GoInt))), _want : stdgo._internal.math.big.Big_newFloat.newFloat(stdgo._internal.math.Math_inf.inf((1 : stdgo.GoInt))) } : stdgo._internal.math.big.Big_T__struct_69.T__struct_69)].concat([for (i in 3 ... (3 > 3 ? 3 : 3 : stdgo.GoInt).toBasic()) ({ _x : (null : stdgo.Ref<stdgo._internal.math.big.Big_Float_.Float_>), _want : (null : stdgo.Ref<stdgo._internal.math.big.Big_Float_.Float_>) } : stdgo._internal.math.big.Big_T__struct_69.T__struct_69)])) : stdgo.Slice<stdgo._internal.math.big.Big_T__struct_69.T__struct_69>)) {
            var _got = (stdgo.Go.setRef(({} : stdgo._internal.math.big.Big_Float_.Float_)) : stdgo.Ref<stdgo._internal.math.big.Big_Float_.Float_>).sqrt(_test._x);
            if (((_got._neg != _test._want._neg) || (_got._form != _test._want._form) : Bool)) {
                _t.errorf(("Sqrt(%v) = %v (neg: %v); want %v (neg: %v)" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_test._x)), stdgo.Go.toInterface(stdgo.Go.asInterface(_got)), stdgo.Go.toInterface(_got._neg), stdgo.Go.toInterface(stdgo.Go.asInterface(_test._want)), stdgo.Go.toInterface(_test._want._neg));
            };
        };
    }
