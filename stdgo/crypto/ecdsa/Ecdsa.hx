package stdgo.crypto.ecdsa;
typedef PublicKey = stdgo._internal.crypto.ecdsa.Ecdsa_publickey.PublicKey;
typedef PrivateKey = stdgo._internal.crypto.ecdsa.Ecdsa_privatekey.PrivateKey;
typedef PublicKeyPointer = stdgo._internal.crypto.ecdsa.Ecdsa_publickeypointer.PublicKeyPointer;
typedef PrivateKeyPointer = stdgo._internal.crypto.ecdsa.Ecdsa_privatekeypointer.PrivateKeyPointer;
/**
    * Package ecdsa implements the Elliptic Curve Digital Signature Algorithm, as
    * defined in FIPS 186-4 and SEC 1, Version 2.0.
    * 
    * Signatures generated by this package are not deterministic, but entropy is
    * mixed with the private key and the message, achieving the same level of
    * security in case of randomness source failure.
**/
class Ecdsa {
    /**
        * GenerateKey generates a new ECDSA private key for the specified curve.
        * 
        * Most applications should use [crypto/rand.Reader] as rand. Note that the
        * returned key does not depend deterministically on the bytes read from rand,
        * and may change between calls and/or between versions.
    **/
    static public inline function generateKey(_c:stdgo._internal.crypto.elliptic.Elliptic_curve.Curve, _rand:stdgo._internal.io.Io_reader.Reader):{ var _0 : stdgo.Ref<stdgo._internal.crypto.ecdsa.Ecdsa_privatekey.PrivateKey>; var _1 : stdgo.Error; } return stdgo._internal.crypto.ecdsa.Ecdsa_generatekey.generateKey(_c, _rand);
    /**
        * SignASN1 signs a hash (which should be the result of hashing a larger message)
        * using the private key, priv. If the hash is longer than the bit-length of the
        * private key's curve order, the hash will be truncated to that length. It
        * returns the ASN.1 encoded signature.
        * 
        * The signature is randomized. Most applications should use [crypto/rand.Reader]
        * as rand. Note that the returned signature does not depend deterministically on
        * the bytes read from rand, and may change between calls and/or between versions.
    **/
    static public inline function signASN1(_rand:stdgo._internal.io.Io_reader.Reader, _priv:stdgo.Ref<stdgo._internal.crypto.ecdsa.Ecdsa_privatekey.PrivateKey>, _hash:stdgo.Slice<stdgo.GoUInt8>):{ var _0 : stdgo.Slice<stdgo.GoUInt8>; var _1 : stdgo.Error; } return stdgo._internal.crypto.ecdsa.Ecdsa_signasn1.signASN1(_rand, _priv, _hash);
    /**
        * VerifyASN1 verifies the ASN.1 encoded signature, sig, of hash using the
        * public key, pub. Its return value records whether the signature is valid.
    **/
    static public inline function verifyASN1(_pub:stdgo.Ref<stdgo._internal.crypto.ecdsa.Ecdsa_publickey.PublicKey>, _hash:stdgo.Slice<stdgo.GoUInt8>, _sig:stdgo.Slice<stdgo.GoUInt8>):Bool return stdgo._internal.crypto.ecdsa.Ecdsa_verifyasn1.verifyASN1(_pub, _hash, _sig);
    /**
        * Sign signs a hash (which should be the result of hashing a larger message)
        * using the private key, priv. If the hash is longer than the bit-length of the
        * private key's curve order, the hash will be truncated to that length. It
        * returns the signature as a pair of integers. Most applications should use
        * SignASN1 instead of dealing directly with r, s.
    **/
    static public inline function sign(_rand:stdgo._internal.io.Io_reader.Reader, _priv:stdgo.Ref<stdgo._internal.crypto.ecdsa.Ecdsa_privatekey.PrivateKey>, _hash:stdgo.Slice<stdgo.GoUInt8>):{ var _0 : stdgo.Ref<stdgo._internal.math.big.Big_int_.Int_>; var _1 : stdgo.Ref<stdgo._internal.math.big.Big_int_.Int_>; var _2 : stdgo.Error; } return stdgo._internal.crypto.ecdsa.Ecdsa_sign.sign(_rand, _priv, _hash);
    /**
        * Verify verifies the signature in r, s of hash using the public key, pub. Its
        * return value records whether the signature is valid. Most applications should
        * use VerifyASN1 instead of dealing directly with r, s.
    **/
    static public inline function verify(_pub:stdgo.Ref<stdgo._internal.crypto.ecdsa.Ecdsa_publickey.PublicKey>, _hash:stdgo.Slice<stdgo.GoUInt8>, _r:stdgo.Ref<stdgo._internal.math.big.Big_int_.Int_>, _s:stdgo.Ref<stdgo._internal.math.big.Big_int_.Int_>):Bool return stdgo._internal.crypto.ecdsa.Ecdsa_verify.verify(_pub, _hash, _r, _s);
}
