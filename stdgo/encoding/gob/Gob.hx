package stdgo.encoding.gob;
typedef Squarer = stdgo._internal.encoding.gob.Gob_squarer.Squarer;
typedef GobEncoder = stdgo._internal.encoding.gob.Gob_gobencoder.GobEncoder;
typedef GobDecoder = stdgo._internal.encoding.gob.Gob_gobdecoder.GobDecoder;
typedef EncodeT = stdgo._internal.encoding.gob.Gob_encodet.EncodeT;
typedef T0 = stdgo._internal.encoding.gob.Gob_t0.T0;
typedef T1 = stdgo._internal.encoding.gob.Gob_t1.T1;
typedef T2 = stdgo._internal.encoding.gob.Gob_t2.T2;
typedef RT0 = stdgo._internal.encoding.gob.Gob_rt0.RT0;
typedef RT1 = stdgo._internal.encoding.gob.Gob_rt1.RT1;
typedef IT0 = stdgo._internal.encoding.gob.Gob_it0.IT0;
typedef Indirect = stdgo._internal.encoding.gob.Gob_indirect.Indirect;
typedef Direct = stdgo._internal.encoding.gob.Gob_direct.Direct;
typedef Point = stdgo._internal.encoding.gob.Gob_point.Point;
typedef InterfaceItem = stdgo._internal.encoding.gob.Gob_interfaceitem.InterfaceItem;
typedef NoInterfaceItem = stdgo._internal.encoding.gob.Gob_nointerfaceitem.NoInterfaceItem;
typedef BasicInterfaceItem = stdgo._internal.encoding.gob.Gob_basicinterfaceitem.BasicInterfaceItem;
typedef PtrInterfaceItem = stdgo._internal.encoding.gob.Gob_ptrinterfaceitem.PtrInterfaceItem;
typedef U = stdgo._internal.encoding.gob.Gob_u.U;
typedef OnTheFly = stdgo._internal.encoding.gob.Gob_onthefly.OnTheFly;
typedef DT = stdgo._internal.encoding.gob.Gob_dt.DT;
typedef LargeSliceByte = stdgo._internal.encoding.gob.Gob_largeslicebyte.LargeSliceByte;
typedef LargeSliceInt8 = stdgo._internal.encoding.gob.Gob_largesliceint8.LargeSliceInt8;
typedef StringPair = stdgo._internal.encoding.gob.Gob_stringpair.StringPair;
typedef LargeSliceStruct = stdgo._internal.encoding.gob.Gob_largeslicestruct.LargeSliceStruct;
typedef LargeSliceString = stdgo._internal.encoding.gob.Gob_largeslicestring.LargeSliceString;
typedef Decoder = stdgo._internal.encoding.gob.Gob_decoder.Decoder;
typedef Encoder = stdgo._internal.encoding.gob.Gob_encoder.Encoder;
typedef ET0 = stdgo._internal.encoding.gob.Gob_et0.ET0;
typedef ET2 = stdgo._internal.encoding.gob.Gob_et2.ET2;
typedef ET1 = stdgo._internal.encoding.gob.Gob_et1.ET1;
typedef ET3 = stdgo._internal.encoding.gob.Gob_et3.ET3;
typedef ET4 = stdgo._internal.encoding.gob.Gob_et4.ET4;
typedef SingleTest = stdgo._internal.encoding.gob.Gob_singletest.SingleTest;
typedef Struct0 = stdgo._internal.encoding.gob.Gob_struct0.Struct0;
typedef NewType0 = stdgo._internal.encoding.gob.Gob_newtype0.NewType0;
typedef Bug0Outer = stdgo._internal.encoding.gob.Gob_bug0outer.Bug0Outer;
typedef Bug0Inner = stdgo._internal.encoding.gob.Gob_bug0inner.Bug0Inner;
typedef Bug1Elem = stdgo._internal.encoding.gob.Gob_bug1elem.Bug1Elem;
typedef Bug2 = stdgo._internal.encoding.gob.Gob_bug2.Bug2;
typedef Bug3 = stdgo._internal.encoding.gob.Gob_bug3.Bug3;
typedef Bug4Public = stdgo._internal.encoding.gob.Gob_bug4public.Bug4Public;
typedef Bug4Secret = stdgo._internal.encoding.gob.Gob_bug4secret.Bug4Secret;
typedef Z = stdgo._internal.encoding.gob.Gob_z.Z;
typedef ByteStruct = stdgo._internal.encoding.gob.Gob_bytestruct.ByteStruct;
typedef StringStruct = stdgo._internal.encoding.gob.Gob_stringstruct.StringStruct;
typedef ArrayStruct = stdgo._internal.encoding.gob.Gob_arraystruct.ArrayStruct;
typedef GobTest0 = stdgo._internal.encoding.gob.Gob_gobtest0.GobTest0;
typedef GobTest1 = stdgo._internal.encoding.gob.Gob_gobtest1.GobTest1;
typedef GobTest2 = stdgo._internal.encoding.gob.Gob_gobtest2.GobTest2;
typedef GobTest3 = stdgo._internal.encoding.gob.Gob_gobtest3.GobTest3;
typedef GobTest4 = stdgo._internal.encoding.gob.Gob_gobtest4.GobTest4;
typedef GobTest5 = stdgo._internal.encoding.gob.Gob_gobtest5.GobTest5;
typedef GobTest6 = stdgo._internal.encoding.gob.Gob_gobtest6.GobTest6;
typedef GobTest7 = stdgo._internal.encoding.gob.Gob_gobtest7.GobTest7;
typedef GobTestIgnoreEncoder = stdgo._internal.encoding.gob.Gob_gobtestignoreencoder.GobTestIgnoreEncoder;
typedef GobTestValueEncDec = stdgo._internal.encoding.gob.Gob_gobtestvalueencdec.GobTestValueEncDec;
typedef GobTestIndirectEncDec = stdgo._internal.encoding.gob.Gob_gobtestindirectencdec.GobTestIndirectEncDec;
typedef GobTestArrayEncDec = stdgo._internal.encoding.gob.Gob_gobtestarrayencdec.GobTestArrayEncDec;
typedef GobTestIndirectArrayEncDec = stdgo._internal.encoding.gob.Gob_gobtestindirectarrayencdec.GobTestIndirectArrayEncDec;
typedef Bench = stdgo._internal.encoding.gob.Gob_bench.Bench;
typedef CommonType = stdgo._internal.encoding.gob.Gob_commontype.CommonType;
typedef Bar = stdgo._internal.encoding.gob.Gob_bar.Bar;
typedef Foo = stdgo._internal.encoding.gob.Gob_foo.Foo;
typedef N1 = stdgo._internal.encoding.gob.Gob_n1.N1;
typedef N2 = stdgo._internal.encoding.gob.Gob_n2.N2;
typedef Int_ = stdgo._internal.encoding.gob.Gob_int_.Int_;
typedef Float_ = stdgo._internal.encoding.gob.Gob_float_.Float_;
typedef Vector = stdgo._internal.encoding.gob.Gob_vector.Vector;
typedef String_ = stdgo._internal.encoding.gob.Gob_string_.String_;
typedef Bug1StructMap = stdgo._internal.encoding.gob.Gob_bug1structmap.Bug1StructMap;
typedef Gobber = stdgo._internal.encoding.gob.Gob_gobber.Gobber;
typedef ValueGobber = stdgo._internal.encoding.gob.Gob_valuegobber.ValueGobber;
typedef BinaryGobber = stdgo._internal.encoding.gob.Gob_binarygobber.BinaryGobber;
typedef BinaryValueGobber = stdgo._internal.encoding.gob.Gob_binaryvaluegobber.BinaryValueGobber;
typedef TextGobber = stdgo._internal.encoding.gob.Gob_textgobber.TextGobber;
typedef TextValueGobber = stdgo._internal.encoding.gob.Gob_textvaluegobber.TextValueGobber;
typedef EncodeTPointer = stdgo._internal.encoding.gob.Gob_encodetpointer.EncodeTPointer;
typedef T0Pointer = stdgo._internal.encoding.gob.Gob_t0pointer.T0Pointer;
typedef T1Pointer = stdgo._internal.encoding.gob.Gob_t1pointer.T1Pointer;
typedef T2Pointer = stdgo._internal.encoding.gob.Gob_t2pointer.T2Pointer;
typedef RT0Pointer = stdgo._internal.encoding.gob.Gob_rt0pointer.RT0Pointer;
typedef RT1Pointer = stdgo._internal.encoding.gob.Gob_rt1pointer.RT1Pointer;
typedef IT0Pointer = stdgo._internal.encoding.gob.Gob_it0pointer.IT0Pointer;
typedef IndirectPointer = stdgo._internal.encoding.gob.Gob_indirectpointer.IndirectPointer;
typedef DirectPointer = stdgo._internal.encoding.gob.Gob_directpointer.DirectPointer;
typedef PointPointer = stdgo._internal.encoding.gob.Gob_pointpointer.PointPointer;
typedef InterfaceItemPointer = stdgo._internal.encoding.gob.Gob_interfaceitempointer.InterfaceItemPointer;
typedef NoInterfaceItemPointer = stdgo._internal.encoding.gob.Gob_nointerfaceitempointer.NoInterfaceItemPointer;
typedef BasicInterfaceItemPointer = stdgo._internal.encoding.gob.Gob_basicinterfaceitempointer.BasicInterfaceItemPointer;
typedef PtrInterfaceItemPointer = stdgo._internal.encoding.gob.Gob_ptrinterfaceitempointer.PtrInterfaceItemPointer;
typedef UPointer = stdgo._internal.encoding.gob.Gob_upointer.UPointer;
typedef OnTheFlyPointer = stdgo._internal.encoding.gob.Gob_ontheflypointer.OnTheFlyPointer;
typedef DTPointer = stdgo._internal.encoding.gob.Gob_dtpointer.DTPointer;
typedef LargeSliceBytePointer = stdgo._internal.encoding.gob.Gob_largeslicebytepointer.LargeSliceBytePointer;
typedef LargeSliceInt8Pointer = stdgo._internal.encoding.gob.Gob_largesliceint8pointer.LargeSliceInt8Pointer;
typedef StringPairPointer = stdgo._internal.encoding.gob.Gob_stringpairpointer.StringPairPointer;
typedef LargeSliceStructPointer = stdgo._internal.encoding.gob.Gob_largeslicestructpointer.LargeSliceStructPointer;
typedef LargeSliceStringPointer = stdgo._internal.encoding.gob.Gob_largeslicestringpointer.LargeSliceStringPointer;
typedef DecoderPointer = stdgo._internal.encoding.gob.Gob_decoderpointer.DecoderPointer;
typedef EncoderPointer = stdgo._internal.encoding.gob.Gob_encoderpointer.EncoderPointer;
typedef ET0Pointer = stdgo._internal.encoding.gob.Gob_et0pointer.ET0Pointer;
typedef ET2Pointer = stdgo._internal.encoding.gob.Gob_et2pointer.ET2Pointer;
typedef ET1Pointer = stdgo._internal.encoding.gob.Gob_et1pointer.ET1Pointer;
typedef ET3Pointer = stdgo._internal.encoding.gob.Gob_et3pointer.ET3Pointer;
typedef ET4Pointer = stdgo._internal.encoding.gob.Gob_et4pointer.ET4Pointer;
typedef SingleTestPointer = stdgo._internal.encoding.gob.Gob_singletestpointer.SingleTestPointer;
typedef Struct0Pointer = stdgo._internal.encoding.gob.Gob_struct0pointer.Struct0Pointer;
typedef NewType0Pointer = stdgo._internal.encoding.gob.Gob_newtype0pointer.NewType0Pointer;
typedef Bug0OuterPointer = stdgo._internal.encoding.gob.Gob_bug0outerpointer.Bug0OuterPointer;
typedef Bug0InnerPointer = stdgo._internal.encoding.gob.Gob_bug0innerpointer.Bug0InnerPointer;
typedef Bug1ElemPointer = stdgo._internal.encoding.gob.Gob_bug1elempointer.Bug1ElemPointer;
typedef Bug2Pointer = stdgo._internal.encoding.gob.Gob_bug2pointer.Bug2Pointer;
typedef Bug3Pointer = stdgo._internal.encoding.gob.Gob_bug3pointer.Bug3Pointer;
typedef Bug4PublicPointer = stdgo._internal.encoding.gob.Gob_bug4publicpointer.Bug4PublicPointer;
typedef Bug4SecretPointer = stdgo._internal.encoding.gob.Gob_bug4secretpointer.Bug4SecretPointer;
typedef ZPointer = stdgo._internal.encoding.gob.Gob_zpointer.ZPointer;
typedef ByteStructPointer = stdgo._internal.encoding.gob.Gob_bytestructpointer.ByteStructPointer;
typedef StringStructPointer = stdgo._internal.encoding.gob.Gob_stringstructpointer.StringStructPointer;
typedef ArrayStructPointer = stdgo._internal.encoding.gob.Gob_arraystructpointer.ArrayStructPointer;
typedef GobTest0Pointer = stdgo._internal.encoding.gob.Gob_gobtest0pointer.GobTest0Pointer;
typedef GobTest1Pointer = stdgo._internal.encoding.gob.Gob_gobtest1pointer.GobTest1Pointer;
typedef GobTest2Pointer = stdgo._internal.encoding.gob.Gob_gobtest2pointer.GobTest2Pointer;
typedef GobTest3Pointer = stdgo._internal.encoding.gob.Gob_gobtest3pointer.GobTest3Pointer;
typedef GobTest4Pointer = stdgo._internal.encoding.gob.Gob_gobtest4pointer.GobTest4Pointer;
typedef GobTest5Pointer = stdgo._internal.encoding.gob.Gob_gobtest5pointer.GobTest5Pointer;
typedef GobTest6Pointer = stdgo._internal.encoding.gob.Gob_gobtest6pointer.GobTest6Pointer;
typedef GobTest7Pointer = stdgo._internal.encoding.gob.Gob_gobtest7pointer.GobTest7Pointer;
typedef GobTestIgnoreEncoderPointer = stdgo._internal.encoding.gob.Gob_gobtestignoreencoderpointer.GobTestIgnoreEncoderPointer;
typedef GobTestValueEncDecPointer = stdgo._internal.encoding.gob.Gob_gobtestvalueencdecpointer.GobTestValueEncDecPointer;
typedef GobTestIndirectEncDecPointer = stdgo._internal.encoding.gob.Gob_gobtestindirectencdecpointer.GobTestIndirectEncDecPointer;
typedef GobTestArrayEncDecPointer = stdgo._internal.encoding.gob.Gob_gobtestarrayencdecpointer.GobTestArrayEncDecPointer;
typedef GobTestIndirectArrayEncDecPointer = stdgo._internal.encoding.gob.Gob_gobtestindirectarrayencdecpointer.GobTestIndirectArrayEncDecPointer;
typedef BenchPointer = stdgo._internal.encoding.gob.Gob_benchpointer.BenchPointer;
typedef CommonTypePointer = stdgo._internal.encoding.gob.Gob_commontypepointer.CommonTypePointer;
typedef BarPointer = stdgo._internal.encoding.gob.Gob_barpointer.BarPointer;
typedef FooPointer = stdgo._internal.encoding.gob.Gob_foopointer.FooPointer;
typedef N1Pointer = stdgo._internal.encoding.gob.Gob_n1pointer.N1Pointer;
typedef N2Pointer = stdgo._internal.encoding.gob.Gob_n2pointer.N2Pointer;
typedef Int_Pointer = stdgo._internal.encoding.gob.Gob_int_pointer.Int_Pointer;
typedef Float_Pointer = stdgo._internal.encoding.gob.Gob_float_pointer.Float_Pointer;
typedef VectorPointer = stdgo._internal.encoding.gob.Gob_vectorpointer.VectorPointer;
typedef String_Pointer = stdgo._internal.encoding.gob.Gob_string_pointer.String_Pointer;
typedef Bug1StructMapPointer = stdgo._internal.encoding.gob.Gob_bug1structmappointer.Bug1StructMapPointer;
typedef GobberPointer = stdgo._internal.encoding.gob.Gob_gobberpointer.GobberPointer;
typedef ValueGobberPointer = stdgo._internal.encoding.gob.Gob_valuegobberpointer.ValueGobberPointer;
typedef BinaryGobberPointer = stdgo._internal.encoding.gob.Gob_binarygobberpointer.BinaryGobberPointer;
typedef BinaryValueGobberPointer = stdgo._internal.encoding.gob.Gob_binaryvaluegobberpointer.BinaryValueGobberPointer;
typedef TextGobberPointer = stdgo._internal.encoding.gob.Gob_textgobberpointer.TextGobberPointer;
typedef TextValueGobberPointer = stdgo._internal.encoding.gob.Gob_textvaluegobberpointer.TextValueGobberPointer;
/**
    * 
    * Package gob manages streams of gobs - binary values exchanged between an
    * Encoder (transmitter) and a Decoder (receiver). A typical use is transporting
    * arguments and results of remote procedure calls (RPCs) such as those provided by
    * [net/rpc].
    * 
    * The implementation compiles a custom codec for each data type in the stream and
    * is most efficient when a single Encoder is used to transmit a stream of values,
    * amortizing the cost of compilation.
    * 
    * # Basics
    * 
    * A stream of gobs is self-describing. Each data item in the stream is preceded by
    * a specification of its type, expressed in terms of a small set of predefined
    * types. Pointers are not transmitted, but the things they point to are
    * transmitted; that is, the values are flattened. Nil pointers are not permitted,
    * as they have no value. Recursive types work fine, but
    * recursive values (data with cycles) are problematic. This may change.
    * 
    * To use gobs, create an Encoder and present it with a series of data items as
    * values or addresses that can be dereferenced to values. The Encoder makes sure
    * all type information is sent before it is needed. At the receive side, a
    * Decoder retrieves values from the encoded stream and unpacks them into local
    * variables.
    * 
    * # Types and Values
    * 
    * The source and destination values/types need not correspond exactly. For structs,
    * fields (identified by name) that are in the source but absent from the receiving
    * variable will be ignored. Fields that are in the receiving variable but missing
    * from the transmitted type or value will be ignored in the destination. If a field
    * with the same name is present in both, their types must be compatible. Both the
    * receiver and transmitter will do all necessary indirection and dereferencing to
    * convert between gobs and actual Go values. For instance, a gob type that is
    * schematically,
    * 
    * 	struct { A, B int }
    * 
    * can be sent from or received into any of these Go types:
    * 
    * 	struct { A, B int }	// the same
    * 	*struct { A, B int }	// extra indirection of the struct
    * 	struct { *A, **B int }	// extra indirection of the fields
    * 	struct { A, B int64 }	// different concrete value type; see below
    * 
    * It may also be received into any of these:
    * 
    * 	struct { A, B int }	// the same
    * 	struct { B, A int }	// ordering doesn't matter; matching is by name
    * 	struct { A, B, C int }	// extra field (C) ignored
    * 	struct { B int }	// missing field (A) ignored; data will be dropped
    * 	struct { B, C int }	// missing field (A) ignored; extra field (C) ignored.
    * 
    * Attempting to receive into these types will draw a decode error:
    * 
    * 	struct { A int; B uint }	// change of signedness for B
    * 	struct { A int; B float }	// change of type for B
    * 	struct { }			// no field names in common
    * 	struct { C, D int }		// no field names in common
    * 
    * Integers are transmitted two ways: arbitrary precision signed integers or
    * arbitrary precision unsigned integers. There is no int8, int16 etc.
    * discrimination in the gob format; there are only signed and unsigned integers. As
    * described below, the transmitter sends the value in a variable-length encoding;
    * the receiver accepts the value and stores it in the destination variable.
    * Floating-point numbers are always sent using IEEE-754 64-bit precision (see
    * below).
    * 
    * Signed integers may be received into any signed integer variable: int, int16, etc.;
    * unsigned integers may be received into any unsigned integer variable; and floating
    * point values may be received into any floating point variable. However,
    * the destination variable must be able to represent the value or the decode
    * operation will fail.
    * 
    * Structs, arrays and slices are also supported. Structs encode and decode only
    * exported fields. Strings and arrays of bytes are supported with a special,
    * efficient representation (see below). When a slice is decoded, if the existing
    * slice has capacity the slice will be extended in place; if not, a new array is
    * allocated. Regardless, the length of the resulting slice reports the number of
    * elements decoded.
    * 
    * In general, if allocation is required, the decoder will allocate memory. If not,
    * it will update the destination variables with values read from the stream. It does
    * not initialize them first, so if the destination is a compound value such as a
    * map, struct, or slice, the decoded values will be merged elementwise into the
    * existing variables.
    * 
    * Functions and channels will not be sent in a gob. Attempting to encode such a value
    * at the top level will fail. A struct field of chan or func type is treated exactly
    * like an unexported field and is ignored.
    * 
    * Gob can encode a value of any type implementing the GobEncoder or
    * encoding.BinaryMarshaler interfaces by calling the corresponding method,
    * in that order of preference.
    * 
    * Gob can decode a value of any type implementing the GobDecoder or
    * encoding.BinaryUnmarshaler interfaces by calling the corresponding method,
    * again in that order of preference.
    * 
    * # Encoding Details
    * 
    * This section documents the encoding, details that are not important for most
    * users. Details are presented bottom-up.
    * 
    * An unsigned integer is sent one of two ways. If it is less than 128, it is sent
    * as a byte with that value. Otherwise it is sent as a minimal-length big-endian
    * (high byte first) byte stream holding the value, preceded by one byte holding the
    * byte count, negated. Thus 0 is transmitted as (00), 7 is transmitted as (07) and
    * 256 is transmitted as (FE 01 00).
    * 
    * A boolean is encoded within an unsigned integer: 0 for false, 1 for true.
    * 
    * A signed integer, i, is encoded within an unsigned integer, u. Within u, bits 1
    * upward contain the value; bit 0 says whether they should be complemented upon
    * receipt. The encode algorithm looks like this:
    * 
    * 	var u uint
    * 	if i < 0 {
    * 		u = (^uint(i) << 1) | 1 // complement i, bit 0 is 1
    * 	} else {
    * 		u = (uint(i) << 1) // do not complement i, bit 0 is 0
    * 	}
    * 	encodeUnsigned(u)
    * 
    * The low bit is therefore analogous to a sign bit, but making it the complement bit
    * instead guarantees that the largest negative integer is not a special case. For
    * example, -129=^128=(^256>>1) encodes as (FE 01 01).
    * 
    * Floating-point numbers are always sent as a representation of a float64 value.
    * That value is converted to a uint64 using math.Float64bits. The uint64 is then
    * byte-reversed and sent as a regular unsigned integer. The byte-reversal means the
    * exponent and high-precision part of the mantissa go first. Since the low bits are
    * often zero, this can save encoding bytes. For instance, 17.0 is encoded in only
    * three bytes (FE 31 40).
    * 
    * Strings and slices of bytes are sent as an unsigned count followed by that many
    * uninterpreted bytes of the value.
    * 
    * All other slices and arrays are sent as an unsigned count followed by that many
    * elements using the standard gob encoding for their type, recursively.
    * 
    * Maps are sent as an unsigned count followed by that many key, element
    * pairs. Empty but non-nil maps are sent, so if the receiver has not allocated
    * one already, one will always be allocated on receipt unless the transmitted map
    * is nil and not at the top level.
    * 
    * In slices and arrays, as well as maps, all elements, even zero-valued elements,
    * are transmitted, even if all the elements are zero.
    * 
    * Structs are sent as a sequence of (field number, field value) pairs. The field
    * value is sent using the standard gob encoding for its type, recursively. If a
    * field has the zero value for its type (except for arrays; see above), it is omitted
    * from the transmission. The field number is defined by the type of the encoded
    * struct: the first field of the encoded type is field 0, the second is field 1,
    * etc. When encoding a value, the field numbers are delta encoded for efficiency
    * and the fields are always sent in order of increasing field number; the deltas are
    * therefore unsigned. The initialization for the delta encoding sets the field
    * number to -1, so an unsigned integer field 0 with value 7 is transmitted as unsigned
    * delta = 1, unsigned value = 7 or (01 07). Finally, after all the fields have been
    * sent a terminating mark denotes the end of the struct. That mark is a delta=0
    * value, which has representation (00).
    * 
    * Interface types are not checked for compatibility; all interface types are
    * treated, for transmission, as members of a single "interface" type, analogous to
    * int or []byte - in effect they're all treated as interface{}. Interface values
    * are transmitted as a string identifying the concrete type being sent (a name
    * that must be pre-defined by calling Register), followed by a byte count of the
    * length of the following data (so the value can be skipped if it cannot be
    * stored), followed by the usual encoding of concrete (dynamic) value stored in
    * the interface value. (A nil interface value is identified by the empty string
    * and transmits no value.) Upon receipt, the decoder verifies that the unpacked
    * concrete item satisfies the interface of the receiving variable.
    * 
    * If a value is passed to Encode and the type is not a struct (or pointer to struct,
    * etc.), for simplicity of processing it is represented as a struct of one field.
    * The only visible effect of this is to encode a zero byte after the value, just as
    * after the last field of an encoded struct, so that the decode algorithm knows when
    * the top-level value is complete.
    * 
    * The representation of types is described below. When a type is defined on a given
    * connection between an Encoder and Decoder, it is assigned a signed integer type
    * id. When Encoder.Encode(v) is called, it makes sure there is an id assigned for
    * the type of v and all its elements and then it sends the pair (typeid, encoded-v)
    * where typeid is the type id of the encoded type of v and encoded-v is the gob
    * encoding of the value v.
    * 
    * To define a type, the encoder chooses an unused, positive type id and sends the
    * pair (-type id, encoded-type) where encoded-type is the gob encoding of a wireType
    * description, constructed from these types:
    * 
    * 	type wireType struct {
    * 		ArrayT           *ArrayType
    * 		SliceT           *SliceType
    * 		StructT          *StructType
    * 		MapT             *MapType
    * 		GobEncoderT      *gobEncoderType
    * 		BinaryMarshalerT *gobEncoderType
    * 		TextMarshalerT   *gobEncoderType
    * 
    * 	}
    * 	type arrayType struct {
    * 		CommonType
    * 		Elem typeId
    * 		Len  int
    * 	}
    * 	type CommonType struct {
    * 		Name string // the name of the struct type
    * 		Id  int    // the id of the type, repeated so it's inside the type
    * 	}
    * 	type sliceType struct {
    * 		CommonType
    * 		Elem typeId
    * 	}
    * 	type structType struct {
    * 		CommonType
    * 		Field []*fieldType // the fields of the struct.
    * 	}
    * 	type fieldType struct {
    * 		Name string // the name of the field.
    * 		Id   int    // the type id of the field, which must be already defined
    * 	}
    * 	type mapType struct {
    * 		CommonType
    * 		Key  typeId
    * 		Elem typeId
    * 	}
    * 	type gobEncoderType struct {
    * 		CommonType
    * 	}
    * 
    * If there are nested type ids, the types for all inner type ids must be defined
    * before the top-level type id is used to describe an encoded-v.
    * 
    * For simplicity in setup, the connection is defined to understand these types a
    * priori, as well as the basic gob types int, uint, etc. Their ids are:
    * 
    * 	bool        1
    * 	int         2
    * 	uint        3
    * 	float       4
    * 	[]byte      5
    * 	string      6
    * 	complex     7
    * 	interface   8
    * 	// gap for reserved ids.
    * 	WireType    16
    * 	ArrayType   17
    * 	CommonType  18
    * 	SliceType   19
    * 	StructType  20
    * 	FieldType   21
    * 	// 22 is slice of fieldType.
    * 	MapType     23
    * 
    * Finally, each message created by a call to Encode is preceded by an encoded
    * unsigned integer count of the number of bytes remaining in the message. After
    * the initial type name, interface values are wrapped the same way; in effect, the
    * interface value acts like a recursive invocation of Encode.
    * 
    * In summary, a gob stream looks like
    * 
    * 	(byteCount (-type id, encoding of a wireType)* (type id, encoding of a value))*
    * 
    * where * signifies zero or more repetitions and the type id of a value must
    * be predefined or be defined before the value in the stream.
    * 
    * Compatibility: Any future changes to the package will endeavor to maintain
    * compatibility with streams encoded using previous versions. That is, any released
    * version of this package should be able to decode data written with any previously
    * released version, subject to issues such as security fixes. See the Go compatibility
    * document for background: https://golang.org/doc/go1compat
    * 
    * See "Gobs of data" for a design discussion of the gob wire format:
    * https://blog.golang.org/gobs-of-data
    * 
    * # Security
    * 
    * This package is not designed to be hardened against adversarial inputs, and is
    * outside the scope of https://go.dev/security/policy. In particular, the Decoder
    * does only basic sanity checking on decoded input sizes, and its limits are not
    * configurable. Care should be taken when decoding gob data from untrusted
    * sources, which may consume significant resources.
    * 
**/
class Gob {
    /**
        * Test basic encode/decode routines for unsigned integers
    **/
    static public inline function testUintCodec(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testuintcodec.testUintCodec(_t);
    /**
        * Test basic encode/decode routines for signed integers
    **/
    static public inline function testIntCodec(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testintcodec.testIntCodec(_t);
    /**
        * Test instruction execution for encoding.
        * Do not run the machine yet; instead do individual instructions crafted by hand.
    **/
    static public inline function testScalarEncInstructions(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testscalarencinstructions.testScalarEncInstructions(_t);
    /**
        * Test instruction execution for decoding.
        * Do not run the machine yet; instead do individual instructions crafted by hand.
    **/
    static public inline function testScalarDecInstructions(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testscalardecinstructions.testScalarDecInstructions(_t);
    static public inline function testEndToEnd(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testendtoend.testEndToEnd(_t);
    static public inline function testOverflow(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testoverflow.testOverflow(_t);
    static public inline function testNesting(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testnesting.testNesting(_t);
    static public inline function testAutoIndirection(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testautoindirection.testAutoIndirection(_t);
    static public inline function testReorderedFields(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testreorderedfields.testReorderedFields(_t);
    static public inline function testIgnoredFields(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testignoredfields.testIgnoredFields(_t);
    static public inline function testBadRecursiveType(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testbadrecursivetype.testBadRecursiveType(_t);
    static public inline function testIndirectSliceMapArray(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testindirectslicemaparray.testIndirectSliceMapArray(_t);
    static public inline function testInterface(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testinterface.testInterface(_t);
    static public inline function testInterfaceBasic(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testinterfacebasic.testInterfaceBasic(_t);
    /**
        * We'll send pointers; should receive values.
        * Also check that we can register T but send *T.
    **/
    static public inline function testInterfacePointer(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testinterfacepointer.testInterfacePointer(_t);
    static public inline function testIgnoreInterface(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testignoreinterface.testIgnoreInterface(_t);
    static public inline function testUnexportedFields(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testunexportedfields.testUnexportedFields(_t);
    static public inline function testDebugSingleton(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testdebugsingleton.testDebugSingleton(_t);
    static public inline function testDebugStruct(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testdebugstruct.testDebugStruct(_t);
    /**
        * This does some "fuzz testing" by attempting to decode a sequence of random bytes.
    **/
    static public inline function testFuzz(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testfuzz.testFuzz(_t);
    static public inline function testFuzzRegressions(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testfuzzregressions.testFuzzRegressions(_t);
    /**
        * TestFuzzOneByte tries to decode corrupted input sequences
        * and checks that no panic occurs.
    **/
    static public inline function testFuzzOneByte(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testfuzzonebyte.testFuzzOneByte(_t);
    /**
        * Don't crash, just give error with invalid type id.
        * Issue 9649.
    **/
    static public inline function testErrorInvalidTypeId(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testerrorinvalidtypeid.testErrorInvalidTypeId(_t);
    static public inline function testLargeSlice(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testlargeslice.testLargeSlice(_t);
    static public inline function testLocalRemoteTypesMismatch(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testlocalremotetypesmismatch.testLocalRemoteTypesMismatch(_t);
    /**
        * NewDecoder returns a new decoder that reads from the io.Reader.
        * If r does not also implement io.ByteReader, it will be wrapped in a
        * bufio.Reader.
    **/
    static public inline function newDecoder(_r:stdgo._internal.io.Io_reader.Reader):stdgo.Ref<stdgo._internal.encoding.gob.Gob_decoder.Decoder> return stdgo._internal.encoding.gob.Gob_newdecoder.newDecoder(_r);
    /**
        * NewEncoder returns a new encoder that will transmit on the io.Writer.
    **/
    static public inline function newEncoder(_w:stdgo._internal.io.Io_writer.Writer):stdgo.Ref<stdgo._internal.encoding.gob.Gob_encoder.Encoder> return stdgo._internal.encoding.gob.Gob_newencoder.newEncoder(_w);
    /**
        * Test basic operations in a safe manner.
    **/
    static public inline function testBasicEncoderDecoder(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testbasicencoderdecoder.testBasicEncoderDecoder(_t);
    static public inline function testEncodeIntSlice(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testencodeintslice.testEncodeIntSlice(_t);
    static public inline function testEncoderDecoder(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testencoderdecoder.testEncoderDecoder(_t);
    /**
        * Test that we recognize a bad type the first time.
    **/
    static public inline function testWrongTypeDecoder(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testwrongtypedecoder.testWrongTypeDecoder(_t);
    static public inline function testUnsupported(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testunsupported.testUnsupported(_t);
    static public inline function testTypeToPtrType(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testtypetoptrtype.testTypeToPtrType(_t);
    static public inline function testPtrTypeToType(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testptrtypetotype.testPtrTypeToType(_t);
    static public inline function testTypeToPtrPtrPtrPtrType(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testtypetoptrptrptrptrtype.testTypeToPtrPtrPtrPtrType(_t);
    static public inline function testSlice(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testslice.testSlice(_t);
    static public inline function testValueError(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testvalueerror.testValueError(_t);
    static public inline function testArray(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testarray.testArray(_t);
    static public inline function testRecursiveMapType(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testrecursivemaptype.testRecursiveMapType(_t);
    static public inline function testRecursiveSliceType(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testrecursiveslicetype.testRecursiveSliceType(_t);
    /**
        * Regression test for bug: must send zero values inside arrays
    **/
    static public inline function testDefaultsInArray(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testdefaultsinarray.testDefaultsInArray(_t);
    static public inline function testSingletons(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testsingletons.testSingletons(_t);
    static public inline function testStructNonStruct(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_teststructnonstruct.testStructNonStruct(_t);
    /**
        * A version of a bug reported on golang-nuts. Also tests top-level
        * slice of interfaces. The issue was registering *T caused T to be
        * stored as the concrete type.
    **/
    static public inline function testInterfaceIndirect(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testinterfaceindirect.testInterfaceIndirect(_t);
    static public inline function testDecodeIntoNothing(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testdecodeintonothing.testDecodeIntoNothing(_t);
    static public inline function testIgnoreRecursiveType(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testignorerecursivetype.testIgnoreRecursiveType(_t);
    static public inline function testNestedInterfaces(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testnestedinterfaces.testNestedInterfaces(_t);
    static public inline function testMapBug1(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testmapbug1.testMapBug1(_t);
    static public inline function testGobMapInterfaceEncode(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testgobmapinterfaceencode.testGobMapInterfaceEncode(_t);
    static public inline function testSliceReusesMemory(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testslicereusesmemory.testSliceReusesMemory(_t);
    /**
        * Used to crash: negative count in recvMessage.
    **/
    static public inline function testBadCount(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testbadcount.testBadCount(_t);
    /**
        * Verify that sequential Decoders built on a single input will
        * succeed if the input implements ReadByte and there is no
        * type information in the stream.
    **/
    static public inline function testSequentialDecoder(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testsequentialdecoder.testSequentialDecoder(_t);
    static public inline function testChanFuncIgnored(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testchanfuncignored.testChanFuncIgnored(_t);
    static public inline function testSliceIncompatibility(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testsliceincompatibility.testSliceIncompatibility(_t);
    static public inline function testGobPtrSlices(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testgobptrslices.testGobPtrSlices(_t);
    /**
        * getDecEnginePtr cached engine for ut.base instead of ut.user so we passed
        * a *map and then tried to reuse its engine to decode the inner map.
    **/
    static public inline function testPtrToMapOfMap(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testptrtomapofmap.testPtrToMapOfMap(_t);
    /**
        * Test that untyped nils generate an error, not a panic.
        * See Issue 16204.
    **/
    static public inline function testCatchInvalidNilValue(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testcatchinvalidnilvalue.testCatchInvalidNilValue(_t);
    /**
        * A top-level nil pointer generates a panic with a helpful string-valued message.
    **/
    static public inline function testTopLevelNilPointer(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testtoplevelnilpointer.testTopLevelNilPointer(_t);
    static public inline function testNilPointerPanics(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testnilpointerpanics.testNilPointerPanics(_t);
    static public inline function testNilPointerInsideInterface(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testnilpointerinsideinterface.testNilPointerInsideInterface(_t);
    /**
        * Test that a failed compilation doesn't leave around an executable encoder.
        * Issue 3723.
    **/
    static public inline function testMutipleEncodingsOfBadType(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testmutipleencodingsofbadtype.testMutipleEncodingsOfBadType(_t);
    static public inline function test29ElementSlice(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_test29elementslice.test29ElementSlice(_t);
    /**
        * Don't crash, just give error when allocating a huge slice.
        * Issue 8084.
    **/
    static public inline function testErrorForHugeSlice(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testerrorforhugeslice.testErrorForHugeSlice(_t);
    /**
        * TestBadData tests that various problems caused by malformed input
        * are caught as errors and do not cause panics.
    **/
    static public inline function testBadData(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testbaddata.testBadData(_t);
    static public inline function testDecodeErrorMultipleTypes(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testdecodeerrormultipletypes.testDecodeErrorMultipleTypes(_t);
    /**
        * Issue 24075
    **/
    static public inline function testMarshalFloatMap(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testmarshalfloatmap.testMarshalFloatMap(_t);
    static public inline function testDecodePartial(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testdecodepartial.testDecodePartial(_t);
    static public inline function testDecoderOverflow(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testdecoderoverflow.testDecoderOverflow(_t);
    static public inline function testGobEncoderField(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testgobencoderfield.testGobEncoderField(_t);
    /**
        * Even though the field is a value, we can still take its address
        * and should be able to call the methods.
    **/
    static public inline function testGobEncoderValueField(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testgobencodervaluefield.testGobEncoderValueField(_t);
    /**
        * GobEncode/Decode should work even if the value is
        * more indirect than the receiver.
    **/
    static public inline function testGobEncoderIndirectField(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testgobencoderindirectfield.testGobEncoderIndirectField(_t);
    /**
        * Test with a large field with methods.
    **/
    static public inline function testGobEncoderArrayField(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testgobencoderarrayfield.testGobEncoderArrayField(_t);
    /**
        * Test an indirection to a large field with methods.
    **/
    static public inline function testGobEncoderIndirectArrayField(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testgobencoderindirectarrayfield.testGobEncoderIndirectArrayField(_t);
    /**
        * As long as the fields have the same name and implement the
        * interface, we can cross-connect them. Not sure it's useful
        * and may even be bad but it works and it's hard to prevent
        * without exposing the contents of the object, which would
        * defeat the purpose.
    **/
    static public inline function testGobEncoderFieldsOfDifferentType(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testgobencoderfieldsofdifferenttype.testGobEncoderFieldsOfDifferentType(_t);
    /**
        * Test that we can encode a value and decode into a pointer.
    **/
    static public inline function testGobEncoderValueEncoder(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testgobencodervalueencoder.testGobEncoderValueEncoder(_t);
    /**
        * Test that we can use a value then a pointer type of a GobEncoder
        * in the same encoded value. Bug 4647.
    **/
    static public inline function testGobEncoderValueThenPointer(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testgobencodervaluethenpointer.testGobEncoderValueThenPointer(_t);
    /**
        * Test that we can use a pointer then a value type of a GobEncoder
        * in the same encoded value.
    **/
    static public inline function testGobEncoderPointerThenValue(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testgobencoderpointerthenvalue.testGobEncoderPointerThenValue(_t);
    static public inline function testGobEncoderFieldTypeError(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testgobencoderfieldtypeerror.testGobEncoderFieldTypeError(_t);
    /**
        * Even though ByteStruct is a struct, it's treated as a singleton at the top level.
    **/
    static public inline function testGobEncoderStructSingleton(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testgobencoderstructsingleton.testGobEncoderStructSingleton(_t);
    static public inline function testGobEncoderNonStructSingleton(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testgobencodernonstructsingleton.testGobEncoderNonStructSingleton(_t);
    static public inline function testGobEncoderIgnoreStructField(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testgobencoderignorestructfield.testGobEncoderIgnoreStructField(_t);
    static public inline function testGobEncoderIgnoreNonStructField(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testgobencoderignorenonstructfield.testGobEncoderIgnoreNonStructField(_t);
    static public inline function testGobEncoderIgnoreNilEncoder(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testgobencoderignorenilencoder.testGobEncoderIgnoreNilEncoder(_t);
    /**
        * This was a bug: the receiver has a different indirection level
        * than the variable.
    **/
    static public inline function testGobEncoderExtraIndirect(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testgobencoderextraindirect.testGobEncoderExtraIndirect(_t);
    static public inline function testGobEncodeIsZero(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testgobencodeiszero.testGobEncodeIsZero(_t);
    static public inline function testGobEncodePtrError(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testgobencodeptrerror.testGobEncodePtrError(_t);
    static public inline function testNetIP(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testnetip.testNetIP(_t);
    static public inline function testIgnoreDepthLimit(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testignoredepthlimit.testIgnoreDepthLimit(_t);
    static public inline function benchmarkEndToEndPipe(_b:stdgo.Ref<stdgo._internal.testing.Testing_b.B>):Void stdgo._internal.encoding.gob.Gob_benchmarkendtoendpipe.benchmarkEndToEndPipe(_b);
    static public inline function benchmarkEndToEndByteBuffer(_b:stdgo.Ref<stdgo._internal.testing.Testing_b.B>):Void stdgo._internal.encoding.gob.Gob_benchmarkendtoendbytebuffer.benchmarkEndToEndByteBuffer(_b);
    static public inline function benchmarkEndToEndSliceByteBuffer(_b:stdgo.Ref<stdgo._internal.testing.Testing_b.B>):Void stdgo._internal.encoding.gob.Gob_benchmarkendtoendslicebytebuffer.benchmarkEndToEndSliceByteBuffer(_b);
    static public inline function testCountEncodeMallocs(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testcountencodemallocs.testCountEncodeMallocs(_t);
    static public inline function testCountDecodeMallocs(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testcountdecodemallocs.testCountDecodeMallocs(_t);
    static public inline function benchmarkEncodeComplex128Slice(_b:stdgo.Ref<stdgo._internal.testing.Testing_b.B>):Void stdgo._internal.encoding.gob.Gob_benchmarkencodecomplex128slice.benchmarkEncodeComplex128Slice(_b);
    static public inline function benchmarkEncodeFloat64Slice(_b:stdgo.Ref<stdgo._internal.testing.Testing_b.B>):Void stdgo._internal.encoding.gob.Gob_benchmarkencodefloat64slice.benchmarkEncodeFloat64Slice(_b);
    static public inline function benchmarkEncodeInt32Slice(_b:stdgo.Ref<stdgo._internal.testing.Testing_b.B>):Void stdgo._internal.encoding.gob.Gob_benchmarkencodeint32slice.benchmarkEncodeInt32Slice(_b);
    static public inline function benchmarkEncodeStringSlice(_b:stdgo.Ref<stdgo._internal.testing.Testing_b.B>):Void stdgo._internal.encoding.gob.Gob_benchmarkencodestringslice.benchmarkEncodeStringSlice(_b);
    static public inline function benchmarkEncodeInterfaceSlice(_b:stdgo.Ref<stdgo._internal.testing.Testing_b.B>):Void stdgo._internal.encoding.gob.Gob_benchmarkencodeinterfaceslice.benchmarkEncodeInterfaceSlice(_b);
    static public inline function benchmarkDecodeComplex128Slice(_b:stdgo.Ref<stdgo._internal.testing.Testing_b.B>):Void stdgo._internal.encoding.gob.Gob_benchmarkdecodecomplex128slice.benchmarkDecodeComplex128Slice(_b);
    static public inline function benchmarkDecodeFloat64Slice(_b:stdgo.Ref<stdgo._internal.testing.Testing_b.B>):Void stdgo._internal.encoding.gob.Gob_benchmarkdecodefloat64slice.benchmarkDecodeFloat64Slice(_b);
    static public inline function benchmarkDecodeInt32Slice(_b:stdgo.Ref<stdgo._internal.testing.Testing_b.B>):Void stdgo._internal.encoding.gob.Gob_benchmarkdecodeint32slice.benchmarkDecodeInt32Slice(_b);
    static public inline function benchmarkDecodeStringSlice(_b:stdgo.Ref<stdgo._internal.testing.Testing_b.B>):Void stdgo._internal.encoding.gob.Gob_benchmarkdecodestringslice.benchmarkDecodeStringSlice(_b);
    static public inline function benchmarkDecodeStringsSlice(_b:stdgo.Ref<stdgo._internal.testing.Testing_b.B>):Void stdgo._internal.encoding.gob.Gob_benchmarkdecodestringsslice.benchmarkDecodeStringsSlice(_b);
    static public inline function benchmarkDecodeBytesSlice(_b:stdgo.Ref<stdgo._internal.testing.Testing_b.B>):Void stdgo._internal.encoding.gob.Gob_benchmarkdecodebytesslice.benchmarkDecodeBytesSlice(_b);
    static public inline function benchmarkDecodeInterfaceSlice(_b:stdgo.Ref<stdgo._internal.testing.Testing_b.B>):Void stdgo._internal.encoding.gob.Gob_benchmarkdecodeinterfaceslice.benchmarkDecodeInterfaceSlice(_b);
    static public inline function benchmarkDecodeMap(_b:stdgo.Ref<stdgo._internal.testing.Testing_b.B>):Void stdgo._internal.encoding.gob.Gob_benchmarkdecodemap.benchmarkDecodeMap(_b);
    /**
        * RegisterName is like Register but uses the provided name rather than the
        * type's default.
    **/
    static public inline function registerName(_name:stdgo.GoString, _value:stdgo.AnyInterface):Void stdgo._internal.encoding.gob.Gob_registername.registerName(_name, _value);
    /**
        * Register records a type, identified by a value for that type, under its
        * internal type name. That name will identify the concrete type of a value
        * sent or received as an interface variable. Only types that will be
        * transferred as implementations of interface values need to be registered.
        * Expecting to be used only during initialization, it panics if the mapping
        * between types and names is not a bijection.
    **/
    static public inline function register(_value:stdgo.AnyInterface):Void stdgo._internal.encoding.gob.Gob_register.register(_value);
    /**
        * Sanity checks
    **/
    static public inline function testBasic(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testbasic.testBasic(_t);
    /**
        * Reregister some basic types to check registration is idempotent.
    **/
    static public inline function testReregistration(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testreregistration.testReregistration(_t);
    static public inline function testArrayType(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testarraytype.testArrayType(_t);
    static public inline function testSliceType(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testslicetype.testSliceType(_t);
    static public inline function testMapType(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testmaptype.testMapType(_t);
    static public inline function testStructType(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_teststructtype.testStructType(_t);
    /**
        * Should be OK to register the same type multiple times, as long as they're
        * at the same level of indirection.
    **/
    static public inline function testRegistration(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testregistration.testRegistration(_t);
    /**
        * See comment in type.go/Register.
    **/
    static public inline function testRegistrationNaming(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testregistrationnaming.testRegistrationNaming(_t);
    static public inline function testStressParallel(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_teststressparallel.testStressParallel(_t);
    /**
        * Issue 23328. Note that this test name is known to cmd/dist/test.go.
    **/
    static public inline function testTypeRace(_t:stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>):Void stdgo._internal.encoding.gob.Gob_testtyperace.testTypeRace(_t);
}
