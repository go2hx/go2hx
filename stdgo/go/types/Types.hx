package stdgo.go.types;

import stdgo.StdGoTypes;
import stdgo.Error;
import stdgo.Go;
import stdgo.GoString;
import stdgo.Pointer;
import stdgo.Slice;
import stdgo.GoArray;
import stdgo.GoMap;
import stdgo.Chan;

/**
	// Package types declares the data types and implements
	// the algorithms for type-checking of Go packages. Use
	// Config.Check to invoke the type checker for a package.
	// Alternatively, create a new type checker with NewChecker
	// and invoke it incrementally by calling Checker.Files.
	//
	// Type-checking consists of several interdependent phases:
	//
	// Name resolution maps each identifier (ast.Ident) in the program to the
	// language object (Object) it denotes.
	// Use Info.{Defs,Uses,Implicits} for the results of name resolution.
	//
	// Constant folding computes the exact constant value (constant.Value)
	// for every expression (ast.Expr) that is a compile-time constant.
	// Use Info.Types[expr].Value for the results of constant folding.
	//
	// Type inference computes the type (Type) of every expression (ast.Expr)
	// and checks for compliance with the language specification.
	// Use Info.Types[expr].Type for the results of type inference.
	//
	// For a tutorial, see https://golang.org/s/types-tutorial.
**/
private var __go2hxdoc__package:Bool;

private var _cgoPrefixes:GoArray<GoString> = (new GoArray<GoString>(("_Ciconst_" : GoString), ("_Cfconst_" : GoString), ("_Csconst_" : GoString),
	("_Ctype_" : GoString), ("_Cvar_" : GoString), ("_Cfpvar_fp_" : GoString), ("_Cfunc_" : GoString), ("_Cmacro_" : GoString)) : GoArray<GoString>);

private var _errBadCgo:Error = stdgo.errors.Errors.new_(("cannot use FakeImportC and go115UsesCgo together" : GoString));

private var _op2str1:GoArray<GoString> = {
	var s:GoArray<GoString> = new GoArray<GoString>(...[for (i in 0...20) ""]);
	s[19] = ("bitwise complement" : GoString);
	s;
};

/**
	// This is only used for operations that may cause overflow.
**/
private var _op2str2:GoArray<GoString> = {
	var s:GoArray<GoString> = new GoArray<GoString>(...[for (i in 0...21) ""]);
	s[12] = ("addition" : GoString);
	s[13] = ("subtraction" : GoString);
	s[19] = ("bitwise XOR" : GoString);
	s[14] = ("multiplication" : GoString);
	s[20] = ("shift" : GoString);
	s;
};

private var _gccgoArchSizes:GoMap<GoString, Ref<StdSizes>> = ({
	final x = new stdgo.GoMap.GoObjectMap<GoString,
		Ref<StdSizes>>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
			stdgo.internal.reflect.Reflect.GoType.basic(string_kind)},
		{get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("StdSizes", [], null, false,
			{get: () -> null})})})));
	@:privateAccess x._keys = [
		("386" : GoString), ("alpha" : GoString), ("amd64" : GoString), ("amd64p32" : GoString), ("arm" : GoString), ("armbe" : GoString),
		("arm64" : GoString), ("arm64be" : GoString), ("ia64" : GoString), ("loong64" : GoString), ("m68k" : GoString), ("mips" : GoString),
		("mipsle" : GoString), ("mips64" : GoString), ("mips64le" : GoString), ("mips64p32" : GoString), ("mips64p32le" : GoString), ("nios2" : GoString),
		("ppc" : GoString), ("ppc64" : GoString), ("ppc64le" : GoString), ("riscv" : GoString), ("riscv64" : GoString), ("s390" : GoString),
		("s390x" : GoString), ("sh" : GoString), ("shbe" : GoString), ("sparc" : GoString), ("sparc64" : GoString), ("wasm" : GoString)];
	@:privateAccess x._values = [
		(null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>),
		(null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>),
		(null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>),
		(null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>),
		(null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>)];
	x;
} : stdgo.GoMap<GoString, Ref<StdSizes>>);

private var _operandModeString:GoArray<GoString> = {
	var s:GoArray<GoString> = new GoArray<GoString>(...[for (i in 0...11) ""]);
	s[0] = ("invalid operand" : GoString);
	s[1] = ("no value" : GoString);
	s[2] = ("built-in" : GoString);
	s[3] = ("type" : GoString);
	s[4] = ("constant" : GoString);
	s[5] = ("variable" : GoString);
	s[6] = ("map index expression" : GoString);
	s[7] = ("value" : GoString);
	s[8] = ("comma, ok expression" : GoString);
	s[9] = ("comma, error expression" : GoString);
	s[10] = ("cgo function" : GoString);
	s;
};

private var _basicSizes:GoArray<GoUInt8> = {
	var s:GoArray<GoUInt8> = new GoArray<GoUInt8>(...[for (i in 0...17) 0]);
	s[1] = (1 : GoUInt8);
	s[3] = (1 : GoUInt8);
	s[4] = (2 : GoUInt8);
	s[5] = (4 : GoUInt8);
	s[6] = (8 : GoUInt8);
	s[8] = (1 : GoUInt8);
	s[9] = (2 : GoUInt8);
	s[10] = (4 : GoUInt8);
	s[11] = (8 : GoUInt8);
	s[13] = (4 : GoUInt8);
	s[14] = (8 : GoUInt8);
	s[15] = (8 : GoUInt8);
	s[16] = (16 : GoUInt8);
	s;
};

/**
	// common architecture word sizes and alignments
**/
private var _gcArchSizes:GoMap<GoString, Ref<StdSizes>> = ({
	final x = new stdgo.GoMap.GoObjectMap<GoString,
		Ref<StdSizes>>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
			stdgo.internal.reflect.Reflect.GoType.basic(string_kind)},
		{get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("StdSizes", [], null, false,
			{get: () -> null})})})));
	@:privateAccess x._keys = [
		("386" : GoString), ("amd64" : GoString), ("amd64p32" : GoString), ("arm" : GoString), ("arm64" : GoString), ("loong64" : GoString),
		("mips" : GoString), ("mipsle" : GoString), ("mips64" : GoString), ("mips64le" : GoString), ("ppc64" : GoString), ("ppc64le" : GoString),
		("riscv64" : GoString), ("s390x" : GoString), ("sparc64" : GoString), ("wasm" : GoString)];
	@:privateAccess x._values = [
		(null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>),
		(null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>),
		(null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>), (null : Ref<StdSizes>)];
	x;
} : stdgo.GoMap<GoString, Ref<StdSizes>>);

/**
	// stdSizes is used if Config.Sizes == nil.
**/
private var _stdSizes:Sizes = sizesFor(("gc" : GoString), ("amd64" : GoString));

/**
	// allTermlist represents the set of all types.
	// It is in normal form.
**/
private var _allTermlist:T_termlist = (new Slice<Ref<T_term>>(0, 0, ({} : T_term)) : T_termlist);

/**
	// topTypeSet may be used as type set for the empty interface.
**/
private var _topTypeSet:T__TypeSet = ({_terms: _allTermlist} : T__TypeSet);

/**
	// emptyInterface represents the empty (completed) interface
**/
private var _emptyInterface:Interface = ({_complete: true, _tset: (_topTypeSet : Ref<T__TypeSet>)} : Interface);

/**
	// Typ contains the predeclared *Basic types indexed by their
	// corresponding BasicKind.
	//
	// The *Basic type for Typ[Byte] will have the name "uint8".
	// Use Universe.Lookup("byte").Type() to obtain the specific
	// alias basic type named "byte" (and analogous for "rune").
**/
var typ:Slice<Ref<Basic>> = {
	var s:Slice<Ref<Basic>> = new Slice<Ref<Basic>>(0, 0, ...([for (i in 0...26) (null : Ref<Basic>)]));
	s[0] = (new Basic((0 : BasicKind), (0 : BasicInfo), ("invalid type" : GoString)) : Basic);
	s[1] = (new Basic((1 : BasicKind), (1 : BasicInfo), ("bool" : GoString)) : Basic);
	s[2] = (new Basic((2 : BasicKind), (2 : BasicInfo), ("int" : GoString)) : Basic);
	s[3] = (new Basic((3 : BasicKind), (2 : BasicInfo), ("int8" : GoString)) : Basic);
	s[4] = (new Basic((4 : BasicKind), (2 : BasicInfo), ("int16" : GoString)) : Basic);
	s[5] = (new Basic((5 : BasicKind), (2 : BasicInfo), ("int32" : GoString)) : Basic);
	s[6] = (new Basic((6 : BasicKind), (2 : BasicInfo), ("int64" : GoString)) : Basic);
	s[7] = (new Basic((7 : BasicKind), (6 : BasicInfo), ("uint" : GoString)) : Basic);
	s[8] = (new Basic((8 : BasicKind), (6 : BasicInfo), ("uint8" : GoString)) : Basic);
	s[9] = (new Basic((9 : BasicKind), (6 : BasicInfo), ("uint16" : GoString)) : Basic);
	s[10] = (new Basic((10 : BasicKind), (6 : BasicInfo), ("uint32" : GoString)) : Basic);
	s[11] = (new Basic((11 : BasicKind), (6 : BasicInfo), ("uint64" : GoString)) : Basic);
	s[12] = (new Basic((12 : BasicKind), (6 : BasicInfo), ("uintptr" : GoString)) : Basic);
	s[13] = (new Basic((13 : BasicKind), (8 : BasicInfo), ("float32" : GoString)) : Basic);
	s[14] = (new Basic((14 : BasicKind), (8 : BasicInfo), ("float64" : GoString)) : Basic);
	s[15] = (new Basic((15 : BasicKind), (16 : BasicInfo), ("complex64" : GoString)) : Basic);
	s[16] = (new Basic((16 : BasicKind), (16 : BasicInfo), ("complex128" : GoString)) : Basic);
	s[17] = (new Basic((17 : BasicKind), (32 : BasicInfo), ("string" : GoString)) : Basic);
	s[18] = (new Basic((18 : BasicKind), (0 : BasicInfo), ("Pointer" : GoString)) : Basic);
	s[19] = (new Basic((19 : BasicKind), (65 : BasicInfo), ("untyped bool" : GoString)) : Basic);
	s[20] = (new Basic((20 : BasicKind), (66 : BasicInfo), ("untyped int" : GoString)) : Basic);
	s[21] = (new Basic((21 : BasicKind), (66 : BasicInfo), ("untyped rune" : GoString)) : Basic);
	s[22] = (new Basic((22 : BasicKind), (72 : BasicInfo), ("untyped float" : GoString)) : Basic);
	s[23] = (new Basic((23 : BasicKind), (80 : BasicInfo), ("untyped complex" : GoString)) : Basic);
	s[24] = (new Basic((24 : BasicKind), (96 : BasicInfo), ("untyped string" : GoString)) : Basic);
	s[25] = (new Basic((25 : BasicKind), (64 : BasicInfo), ("untyped nil" : GoString)) : Basic);
	s;
};

private var _aliases:GoArray<Ref<Basic>> = (new GoArray<Ref<Basic>>((new Basic((8 : BasicKind), (6 : BasicInfo), ("byte" : GoString)) : Basic),
	(new Basic((5 : BasicKind), (2 : BasicInfo), ("rune" : GoString)) : Basic)) : GoArray<Ref<Basic>>);

private var _predeclaredConsts:GoArray<T__struct_6> = (new GoArray<T__struct_6>(({_name: ("true" : GoString), _kind: (19 : BasicKind),
	_val: stdgo.go.constant.Constant.makeBool(true)} : T__struct_6),
	({_name: ("false" : GoString), _kind: (19 : BasicKind), _val: stdgo.go.constant.Constant.makeBool(false)} : T__struct_6),
	({_name: ("iota" : GoString), _kind: (20 : BasicKind), _val: stdgo.go.constant.Constant.makeInt64(("0" : GoInt64))} : T__struct_6)) : GoArray<T__struct_6>);

private var _predeclaredFuncs:GoArray<T__struct_7> = {
	var s:GoArray<T__struct_7> = new GoArray<T__struct_7>(...[
		for (i in 0...22) ({
			_name:("" : GoString), _nargs:(0 : GoInt), _variadic:false, _kind:((0 : GoInt) : T_exprKind)
		} : T__struct_7)
	]);
	s[0] = ({
		_name: ("append" : GoString),
		_nargs: (1 : GoInt),
		_variadic: true,
		_kind: (1 : T_exprKind)
	} : T__struct_7);
	s[1] = ({
		_name: ("cap" : GoString),
		_nargs: (1 : GoInt),
		_variadic: false,
		_kind: (1 : T_exprKind)
	} : T__struct_7);
	s[2] = ({
		_name: ("close" : GoString),
		_nargs: (1 : GoInt),
		_variadic: false,
		_kind: (2 : T_exprKind)
	} : T__struct_7);
	s[3] = ({
		_name: ("complex" : GoString),
		_nargs: (2 : GoInt),
		_variadic: false,
		_kind: (1 : T_exprKind)
	} : T__struct_7);
	s[4] = ({
		_name: ("copy" : GoString),
		_nargs: (2 : GoInt),
		_variadic: false,
		_kind: (2 : T_exprKind)
	} : T__struct_7);
	s[5] = ({
		_name: ("delete" : GoString),
		_nargs: (2 : GoInt),
		_variadic: false,
		_kind: (2 : T_exprKind)
	} : T__struct_7);
	s[6] = ({
		_name: ("imag" : GoString),
		_nargs: (1 : GoInt),
		_variadic: false,
		_kind: (1 : T_exprKind)
	} : T__struct_7);
	s[7] = ({
		_name: ("len" : GoString),
		_nargs: (1 : GoInt),
		_variadic: false,
		_kind: (1 : T_exprKind)
	} : T__struct_7);
	s[8] = ({
		_name: ("make" : GoString),
		_nargs: (1 : GoInt),
		_variadic: true,
		_kind: (1 : T_exprKind)
	} : T__struct_7);
	s[9] = ({
		_name: ("new" : GoString),
		_nargs: (1 : GoInt),
		_variadic: false,
		_kind: (1 : T_exprKind)
	} : T__struct_7);
	s[10] = ({
		_name: ("panic" : GoString),
		_nargs: (1 : GoInt),
		_variadic: false,
		_kind: (2 : T_exprKind)
	} : T__struct_7);
	s[11] = ({
		_name: ("print" : GoString),
		_nargs: (0 : GoInt),
		_variadic: true,
		_kind: (2 : T_exprKind)
	} : T__struct_7);
	s[12] = ({
		_name: ("println" : GoString),
		_nargs: (0 : GoInt),
		_variadic: true,
		_kind: (2 : T_exprKind)
	} : T__struct_7);
	s[13] = ({
		_name: ("real" : GoString),
		_nargs: (1 : GoInt),
		_variadic: false,
		_kind: (1 : T_exprKind)
	} : T__struct_7);
	s[14] = ({
		_name: ("recover" : GoString),
		_nargs: (0 : GoInt),
		_variadic: false,
		_kind: (2 : T_exprKind)
	} : T__struct_7);
	s[15] = ({
		_name: ("Add" : GoString),
		_nargs: (2 : GoInt),
		_variadic: false,
		_kind: (1 : T_exprKind)
	} : T__struct_7);
	s[16] = ({
		_name: ("Alignof" : GoString),
		_nargs: (1 : GoInt),
		_variadic: false,
		_kind: (1 : T_exprKind)
	} : T__struct_7);
	s[17] = ({
		_name: ("Offsetof" : GoString),
		_nargs: (1 : GoInt),
		_variadic: false,
		_kind: (1 : T_exprKind)
	} : T__struct_7);
	s[18] = ({
		_name: ("Sizeof" : GoString),
		_nargs: (1 : GoInt),
		_variadic: false,
		_kind: (1 : T_exprKind)
	} : T__struct_7);
	s[19] = ({
		_name: ("Slice" : GoString),
		_nargs: (2 : GoInt),
		_variadic: false,
		_kind: (1 : T_exprKind)
	} : T__struct_7);
	s[20] = ({
		_name: ("assert" : GoString),
		_nargs: (1 : GoInt),
		_variadic: false,
		_kind: (2 : T_exprKind)
	} : T__struct_7);
	s[21] = ({
		_name: ("trace" : GoString),
		_nargs: (0 : GoInt),
		_variadic: true,
		_kind: (2 : T_exprKind)
	} : T__struct_7);
	s;
};

/**
	// goVersionRx matches a Go version string, e.g. "go1.12".
**/
private var _goVersionRx:Ref<stdgo.regexp.Regexp.Regexp> = stdgo.regexp.Regexp.mustCompile(("^go([1-9][0-9]*)\\.(0|[1-9][0-9]*)$$" : GoString));

private var _assignOps:GoMap<stdgo.go.token.Token.Token, stdgo.go.token.Token.Token> = ({
	final x = new stdgo.GoMap.GoObjectMap<stdgo.go.token.Token.Token,
		stdgo.go.token.Token.Token>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({
		get: () -> stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.token.Token.Token", [], null, false, {get: () -> null})
	},
		{get: () -> stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.token.Token.Token", [], null, false, {get: () -> null})})));
	@:privateAccess x._keys = [
		(23 : stdgo.go.token.Token.Token),
		(24 : stdgo.go.token.Token.Token),
		(25 : stdgo.go.token.Token.Token),
		(26 : stdgo.go.token.Token.Token),
		(27 : stdgo.go.token.Token.Token),
		(28 : stdgo.go.token.Token.Token),
		(29 : stdgo.go.token.Token.Token),
		(30 : stdgo.go.token.Token.Token),
		(31 : stdgo.go.token.Token.Token),
		(32 : stdgo.go.token.Token.Token),
		(33 : stdgo.go.token.Token.Token)
	];
	@:privateAccess x._values = [
		(12 : stdgo.go.token.Token.Token),
		(13 : stdgo.go.token.Token.Token),
		(14 : stdgo.go.token.Token.Token),
		(15 : stdgo.go.token.Token.Token),
		(16 : stdgo.go.token.Token.Token),
		(17 : stdgo.go.token.Token.Token),
		(18 : stdgo.go.token.Token.Token),
		(19 : stdgo.go.token.Token.Token),
		(20 : stdgo.go.token.Token.Token),
		(21 : stdgo.go.token.Token.Token),
		(22 : stdgo.go.token.Token.Token)
	];
	x;
} : stdgo.GoMap<stdgo.go.token.Token.Token, stdgo.go.token.Token.Token>);

private var _myInt:Type = {
	var a = function():Type {
		var _tname = newTypeName((0 : stdgo.go.token.Token.Pos), null, ("myInt" : GoString), (null : Type));
		return Go.asInterface(newNamed(_tname, Go.asInterface(typ[((2 : BasicKind) : GoInt)]), (null : Slice<Ref<Func>>)));
	};
	a();
};

private var _testTerms:GoMap<GoString, Ref<T_term>> = ({
	final x = new stdgo.GoMap.GoObjectMap<GoString,
		Ref<T_term>>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
			stdgo.internal.reflect.Reflect.GoType.basic(string_kind)},
		{get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("T_term", [], null, false,
			{get: () -> null})})})));
	@:privateAccess x._keys = [
		("∅" : GoString),
		("𝓤" : GoString),
		("int" : GoString),
		("~int" : GoString),
		("string" : GoString),
		("~string" : GoString),
		("myInt" : GoString)
	];
	@:privateAccess x._values = [
		(null : Ref<T_term>),
		(null : Ref<T_term>),
		(null : Ref<T_term>),
		(null : Ref<T_term>),
		(null : Ref<T_term>),
		(null : Ref<T_term>),
		(null : Ref<T_term>)
	];
	x;
} : stdgo.GoMap<GoString, Ref<T_term>>);

/**
	// type is invalid
**/
final invalid:BasicKind = (25 : BasicKind);

/**
	// predeclared types
**/
final bool_:BasicKind = (25 : BasicKind);

final int_:BasicKind = (25 : BasicKind);
final int8:BasicKind = (25 : BasicKind);
final int16:BasicKind = (25 : BasicKind);
final int32:BasicKind = (25 : BasicKind);
final int64:BasicKind = (25 : BasicKind);
final uint:BasicKind = (25 : BasicKind);
final uint8:BasicKind = (25 : BasicKind);
final uint16:BasicKind = (25 : BasicKind);
final uint32:BasicKind = (25 : BasicKind);
final uint64:BasicKind = (25 : BasicKind);
final uintptr:BasicKind = (25 : BasicKind);
final float32:BasicKind = (25 : BasicKind);
final float64:BasicKind = (25 : BasicKind);
final complex64:BasicKind = (25 : BasicKind);
final complex128:BasicKind = (25 : BasicKind);
final string:BasicKind = (25 : BasicKind);
final unsafePointer:BasicKind = (25 : BasicKind);

/**
	// types for untyped values
**/
final untypedBool:BasicKind = (25 : BasicKind);

final untypedInt:BasicKind = (25 : BasicKind);
final untypedRune:BasicKind = (25 : BasicKind);
final untypedFloat:BasicKind = (25 : BasicKind);
final untypedComplex:BasicKind = (25 : BasicKind);
final untypedString:BasicKind = (25 : BasicKind);
final untypedNil:BasicKind = (25 : BasicKind);

/**
	// aliases
**/
final byte:BasicKind = (8 : BasicKind);

final rune:BasicKind = (5 : BasicKind);

/**
	// Properties of basic types.
**/
final isBoolean:BasicInfo = (64 : BasicInfo);

/**
	// Properties of basic types.
**/
final isInteger:BasicInfo = (64 : BasicInfo);

/**
	// Properties of basic types.
**/
final isUnsigned:BasicInfo = (64 : BasicInfo);

/**
	// Properties of basic types.
**/
final isFloat:BasicInfo = (64 : BasicInfo);

/**
	// Properties of basic types.
**/
final isComplex:BasicInfo = (64 : BasicInfo);

/**
	// Properties of basic types.
**/
final isString:BasicInfo = (64 : BasicInfo);

/**
	// Properties of basic types.
**/
final isUntyped:BasicInfo = (64 : BasicInfo);

/**
	// Properties of basic types.
**/
final isOrdered:BasicInfo = (42 : BasicInfo);

/**
	// Properties of basic types.
**/
final isNumeric:BasicInfo = (26 : BasicInfo);

/**
	// Properties of basic types.
**/
final isConstType:BasicInfo = (59 : BasicInfo);

/**
	// The direction of a channel is indicated by one of these constants.
**/
final sendRecv:ChanDir = (2 : ChanDir);

/**
	// The direction of a channel is indicated by one of these constants.
**/
final sendOnly:ChanDir = (2 : ChanDir);

/**
	// The direction of a channel is indicated by one of these constants.
**/
final recvOnly:ChanDir = (2 : ChanDir);

/**
	// leave on during development// debugging/development support
**/
private final _debug:InvalidType = false;

/**
	// turn on for detailed type resolution traces// debugging/development support
**/
private final _trace:InvalidType = false;

/**
	// match compiler error messages// TODO(rfindley): add compiler error message handling from types2, guarded
	// behind this flag, so that we can keep the code in sync.
**/
private final _compilerErrorMessages:InvalidType = false;

private final _0:T_errorCode = (144 : T_errorCode);

/**
	// _Test is reserved for errors that only apply while in self-test mode.
**/
private final __Test:T_errorCode = (144 : T_errorCode);

/**
	// _BlankPkgName occurs when a package name is the blank identifier "_".
	//
	// Per the spec:
	//  "The PackageName must not be the blank identifier."
**/
private final __BlankPkgName:T_errorCode = (144 : T_errorCode);

/**
	// _MismatchedPkgName occurs when a file's package name doesn't match the
	// package name already established by other files.
**/
private final __MismatchedPkgName:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidPkgUse occurs when a package identifier is used outside of a
	// selector expression.
	//
	// Example:
	//  import "fmt"
	//
	//  var _ = fmt
**/
private final __InvalidPkgUse:T_errorCode = (144 : T_errorCode);

/**
	// _BadImportPath occurs when an import path is not valid.
**/
private final __BadImportPath:T_errorCode = (144 : T_errorCode);

/**
	// _BrokenImport occurs when importing a package fails.
	//
	// Example:
	//  import "amissingpackage"
**/
private final __BrokenImport:T_errorCode = (144 : T_errorCode);

/**
	// _ImportCRenamed occurs when the special import "C" is renamed. "C" is a
	// pseudo-package, and must not be renamed.
	//
	// Example:
	//  import _ "C"
**/
private final __ImportCRenamed:T_errorCode = (144 : T_errorCode);

/**
	// _UnusedImport occurs when an import is unused.
	//
	// Example:
	//  import "fmt"
	//
	//  func main() {}
**/
private final __UnusedImport:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidInitCycle occurs when an invalid cycle is detected within the
	// initialization graph.
	//
	// Example:
	//  var x int = f()
	//
	//  func f() int { return x }
**/
private final __InvalidInitCycle:T_errorCode = (144 : T_errorCode);

/**
	// _DuplicateDecl occurs when an identifier is declared multiple times.
	//
	// Example:
	//  var x = 1
	//  var x = 2
**/
private final __DuplicateDecl:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidDeclCycle occurs when a declaration cycle is not valid.
	//
	// Example:
	//  type S struct {
	//  	S
	//  }
	//
**/
private final __InvalidDeclCycle:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidTypeCycle occurs when a cycle in type definitions results in a
	// type that is not well-defined.
	//
	// Example:
	//  import "unsafe"
	//
	//  type T [unsafe.Sizeof(T{})]int
**/
private final __InvalidTypeCycle:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidConstInit occurs when a const declaration has a non-constant
	// initializer.
	//
	// Example:
	//  var x int
	//  const _ = x
**/
private final __InvalidConstInit:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidConstVal occurs when a const value cannot be converted to its
	// target type.
	//
	// TODO(findleyr): this error code and example are not very clear. Consider
	// removing it.
	//
	// Example:
	//  const _ = 1 << "hello"
**/
private final __InvalidConstVal:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidConstType occurs when the underlying type in a const declaration
	// is not a valid constant type.
	//
	// Example:
	//  const c *int = 4
**/
private final __InvalidConstType:T_errorCode = (144 : T_errorCode);

/**
	// _UntypedNil occurs when the predeclared (untyped) value nil is used to
	// initialize a variable declared without an explicit type.
	//
	// Example:
	//  var x = nil
**/
private final __UntypedNil:T_errorCode = (144 : T_errorCode);

/**
	// _WrongAssignCount occurs when the number of values on the right-hand side
	// of an assignment or initialization expression does not match the number
	// of variables on the left-hand side.
	//
	// Example:
	//  var x = 1, 2
**/
private final __WrongAssignCount:T_errorCode = (144 : T_errorCode);

/**
	// _UnassignableOperand occurs when the left-hand side of an assignment is
	// not assignable.
	//
	// Example:
	//  func f() {
	//  	const c = 1
	//  	c = 2
	//  }
**/
private final __UnassignableOperand:T_errorCode = (144 : T_errorCode);

/**
	// _NoNewVar occurs when a short variable declaration (':=') does not declare
	// new variables.
	//
	// Example:
	//  func f() {
	//  	x := 1
	//  	x := 2
	//  }
**/
private final __NoNewVar:T_errorCode = (144 : T_errorCode);

/**
	// _MultiValAssignOp occurs when an assignment operation (+=, *=, etc) does
	// not have single-valued left-hand or right-hand side.
	//
	// Per the spec:
	//  "In assignment operations, both the left- and right-hand expression lists
	//  must contain exactly one single-valued expression"
	//
	// Example:
	//  func f() int {
	//  	x, y := 1, 2
	//  	x, y += 1
	//  	return x + y
	//  }
**/
private final __MultiValAssignOp:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidIfaceAssign occurs when a value of type T is used as an
	// interface, but T does not implement a method of the expected interface.
	//
	// Example:
	//  type I interface {
	//  	f()
	//  }
	//
	//  type T int
	//
	//  var x I = T(1)
**/
private final __InvalidIfaceAssign:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidChanAssign occurs when a chan assignment is invalid.
	//
	// Per the spec, a value x is assignable to a channel type T if:
	//  "x is a bidirectional channel value, T is a channel type, x's type V and
	//  T have identical element types, and at least one of V or T is not a
	//  defined type."
	//
	// Example:
	//  type T1 chan int
	//  type T2 chan int
	//
	//  var x T1
	//  // Invalid assignment because both types are named
	//  var _ T2 = x
**/
private final __InvalidChanAssign:T_errorCode = (144 : T_errorCode);

/**
	// _IncompatibleAssign occurs when the type of the right-hand side expression
	// in an assignment cannot be assigned to the type of the variable being
	// assigned.
	//
	// Example:
	//  var x []int
	//  var _ int = x
**/
private final __IncompatibleAssign:T_errorCode = (144 : T_errorCode);

/**
	// _UnaddressableFieldAssign occurs when trying to assign to a struct field
	// in a map value.
	//
	// Example:
	//  func f() {
	//  	m := make(map[string]struct{i int})
	//  	m["foo"].i = 42
	//  }
**/
private final __UnaddressableFieldAssign:T_errorCode = (144 : T_errorCode);

/**
	// _NotAType occurs when the identifier used as the underlying type in a type
	// declaration or the right-hand side of a type alias does not denote a type.
	//
	// Example:
	//  var S = 2
	//
	//  type T S
**/
private final __NotAType:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidArrayLen occurs when an array length is not a constant value.
	//
	// Example:
	//  var n = 3
	//  var _ = [n]int{}
**/
private final __InvalidArrayLen:T_errorCode = (144 : T_errorCode);

/**
	// _BlankIfaceMethod occurs when a method name is '_'.
	//
	// Per the spec:
	//  "The name of each explicitly specified method must be unique and not
	//  blank."
	//
	// Example:
	//  type T interface {
	//  	_(int)
	//  }
**/
private final __BlankIfaceMethod:T_errorCode = (144 : T_errorCode);

/**
	// _IncomparableMapKey occurs when a map key type does not support the == and
	// != operators.
	//
	// Per the spec:
	//  "The comparison operators == and != must be fully defined for operands of
	//  the key type; thus the key type must not be a function, map, or slice."
	//
	// Example:
	//  var x map[T]int
	//
	//  type T []int
**/
private final __IncomparableMapKey:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidIfaceEmbed occurs when a non-interface type is embedded in an
	// interface (for go 1.17 or earlier).
**/
private final __InvalidIfaceEmbed:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidPtrEmbed occurs when an embedded field is of the pointer form *T,
	// and T itself is itself a pointer, an unsafe.Pointer, or an interface.
	//
	// Per the spec:
	//  "An embedded field must be specified as a type name T or as a pointer to
	//  a non-interface type name *T, and T itself may not be a pointer type."
	//
	// Example:
	//  type T *int
	//
	//  type S struct {
	//  	*T
	//  }
**/
private final __InvalidPtrEmbed:T_errorCode = (144 : T_errorCode);

/**
	// _BadRecv occurs when a method declaration does not have exactly one
	// receiver parameter.
	//
	// Example:
	//  func () _() {}
**/
private final __BadRecv:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidRecv occurs when a receiver type expression is not of the form T
	// or *T, or T is a pointer type.
	//
	// Example:
	//  type T struct {}
	//
	//  func (**T) m() {}
**/
private final __InvalidRecv:T_errorCode = (144 : T_errorCode);

/**
	// _DuplicateFieldAndMethod occurs when an identifier appears as both a field
	// and method name.
	//
	// Example:
	//  type T struct {
	//  	m int
	//  }
	//
	//  func (T) m() {}
**/
private final __DuplicateFieldAndMethod:T_errorCode = (144 : T_errorCode);

/**
	// _DuplicateMethod occurs when two methods on the same receiver type have
	// the same name.
	//
	// Example:
	//  type T struct {}
	//  func (T) m() {}
	//  func (T) m(i int) int { return i }
**/
private final __DuplicateMethod:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidBlank occurs when a blank identifier is used as a value or type.
	//
	// Per the spec:
	//  "The blank identifier may appear as an operand only on the left-hand side
	//  of an assignment."
	//
	// Example:
	//  var x = _
**/
private final __InvalidBlank:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidIota occurs when the predeclared identifier iota is used outside
	// of a constant declaration.
	//
	// Example:
	//  var x = iota
**/
private final __InvalidIota:T_errorCode = (144 : T_errorCode);

/**
	// _MissingInitBody occurs when an init function is missing its body.
	//
	// Example:
	//  func init()
**/
private final __MissingInitBody:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidInitSig occurs when an init function declares parameters or
	// results.
	//
	// Deprecated: no longer emitted by the type checker. _InvalidInitDecl is
	// used instead.
**/
private final __InvalidInitSig:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidInitDecl occurs when init is declared as anything other than a
	// function.
	//
	// Example:
	//  var init = 1
	//
	// Example:
	//  func init() int { return 1 }
**/
private final __InvalidInitDecl:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidMainDecl occurs when main is declared as anything other than a
	// function, in a main package.
**/
private final __InvalidMainDecl:T_errorCode = (144 : T_errorCode);

/**
	// _TooManyValues occurs when a function returns too many values for the
	// expression context in which it is used.
	//
	// Example:
	//  func ReturnTwo() (int, int) {
	//  	return 1, 2
	//  }
	//
	//  var x = ReturnTwo()
**/
private final __TooManyValues:T_errorCode = (144 : T_errorCode);

/**
	// _NotAnExpr occurs when a type expression is used where a value expression
	// is expected.
	//
	// Example:
	//  type T struct {}
	//
	//  func f() {
	//  	T
	//  }
**/
private final __NotAnExpr:T_errorCode = (144 : T_errorCode);

/**
	// _TruncatedFloat occurs when a float constant is truncated to an integer
	// value.
	//
	// Example:
	//  var _ int = 98.6
**/
private final __TruncatedFloat:T_errorCode = (144 : T_errorCode);

/**
	// _NumericOverflow occurs when a numeric constant overflows its target type.
	//
	// Example:
	//  var x int8 = 1000
**/
private final __NumericOverflow:T_errorCode = (144 : T_errorCode);

/**
	// _UndefinedOp occurs when an operator is not defined for the type(s) used
	// in an operation.
	//
	// Example:
	//  var c = "a" - "b"
**/
private final __UndefinedOp:T_errorCode = (144 : T_errorCode);

/**
	// _MismatchedTypes occurs when operand types are incompatible in a binary
	// operation.
	//
	// Example:
	//  var a = "hello"
	//  var b = 1
	//  var c = a - b
**/
private final __MismatchedTypes:T_errorCode = (144 : T_errorCode);

/**
	// _DivByZero occurs when a division operation is provable at compile
	// time to be a division by zero.
	//
	// Example:
	//  const divisor = 0
	//  var x int = 1/divisor
**/
private final __DivByZero:T_errorCode = (144 : T_errorCode);

/**
	// _NonNumericIncDec occurs when an increment or decrement operator is
	// applied to a non-numeric value.
	//
	// Example:
	//  func f() {
	//  	var c = "c"
	//  	c++
	//  }
**/
private final __NonNumericIncDec:T_errorCode = (144 : T_errorCode);

/**
	// _UnaddressableOperand occurs when the & operator is applied to an
	// unaddressable expression.
	//
	// Example:
	//  var x = &1
**/
private final __UnaddressableOperand:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidIndirection occurs when a non-pointer value is indirected via the
	// '*' operator.
	//
	// Example:
	//  var x int
	//  var y = *x
**/
private final __InvalidIndirection:T_errorCode = (144 : T_errorCode);

/**
	// _NonIndexableOperand occurs when an index operation is applied to a value
	// that cannot be indexed.
	//
	// Example:
	//  var x = 1
	//  var y = x[1]
**/
private final __NonIndexableOperand:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidIndex occurs when an index argument is not of integer type,
	// negative, or out-of-bounds.
	//
	// Example:
	//  var s = [...]int{1,2,3}
	//  var x = s[5]
	//
	// Example:
	//  var s = []int{1,2,3}
	//  var _ = s[-1]
	//
	// Example:
	//  var s = []int{1,2,3}
	//  var i string
	//  var _ = s[i]
**/
private final __InvalidIndex:T_errorCode = (144 : T_errorCode);

/**
	// _SwappedSliceIndices occurs when constant indices in a slice expression
	// are decreasing in value.
	//
	// Example:
	//  var _ = []int{1,2,3}[2:1]
**/
private final __SwappedSliceIndices:T_errorCode = (144 : T_errorCode);

/**
	// _NonSliceableOperand occurs when a slice operation is applied to a value
	// whose type is not sliceable, or is unaddressable.
	//
	// Example:
	//  var x = [...]int{1, 2, 3}[:1]
	//
	// Example:
	//  var x = 1
	//  var y = 1[:1]
**/
private final __NonSliceableOperand:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidSliceExpr occurs when a three-index slice expression (a[x:y:z]) is
	// applied to a string.
	//
	// Example:
	//  var s = "hello"
	//  var x = s[1:2:3]
**/
private final __InvalidSliceExpr:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidShiftCount occurs when the right-hand side of a shift operation is
	// either non-integer, negative, or too large.
	//
	// Example:
	//  var (
	//  	x string
	//  	y int = 1 << x
	//  )
**/
private final __InvalidShiftCount:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidShiftOperand occurs when the shifted operand is not an integer.
	//
	// Example:
	//  var s = "hello"
	//  var x = s << 2
**/
private final __InvalidShiftOperand:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidReceive occurs when there is a channel receive from a value that
	// is either not a channel, or is a send-only channel.
	//
	// Example:
	//  func f() {
	//  	var x = 1
	//  	<-x
	//  }
**/
private final __InvalidReceive:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidSend occurs when there is a channel send to a value that is not a
	// channel, or is a receive-only channel.
	//
	// Example:
	//  func f() {
	//  	var x = 1
	//  	x <- "hello!"
	//  }
**/
private final __InvalidSend:T_errorCode = (144 : T_errorCode);

/**
	// _DuplicateLitKey occurs when an index is duplicated in a slice, array, or
	// map literal.
	//
	// Example:
	//  var _ = []int{0:1, 0:2}
	//
	// Example:
	//  var _ = map[string]int{"a": 1, "a": 2}
**/
private final __DuplicateLitKey:T_errorCode = (144 : T_errorCode);

/**
	// _MissingLitKey occurs when a map literal is missing a key expression.
	//
	// Example:
	//  var _ = map[string]int{1}
**/
private final __MissingLitKey:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidLitIndex occurs when the key in a key-value element of a slice or
	// array literal is not an integer constant.
	//
	// Example:
	//  var i = 0
	//  var x = []string{i: "world"}
**/
private final __InvalidLitIndex:T_errorCode = (144 : T_errorCode);

/**
	// _OversizeArrayLit occurs when an array literal exceeds its length.
	//
	// Example:
	//  var _ = [2]int{1,2,3}
**/
private final __OversizeArrayLit:T_errorCode = (144 : T_errorCode);

/**
	// _MixedStructLit occurs when a struct literal contains a mix of positional
	// and named elements.
	//
	// Example:
	//  var _ = struct{i, j int}{i: 1, 2}
**/
private final __MixedStructLit:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidStructLit occurs when a positional struct literal has an incorrect
	// number of values.
	//
	// Example:
	//  var _ = struct{i, j int}{1,2,3}
**/
private final __InvalidStructLit:T_errorCode = (144 : T_errorCode);

/**
	// _MissingLitField occurs when a struct literal refers to a field that does
	// not exist on the struct type.
	//
	// Example:
	//  var _ = struct{i int}{j: 2}
**/
private final __MissingLitField:T_errorCode = (144 : T_errorCode);

/**
	// _DuplicateLitField occurs when a struct literal contains duplicated
	// fields.
	//
	// Example:
	//  var _ = struct{i int}{i: 1, i: 2}
**/
private final __DuplicateLitField:T_errorCode = (144 : T_errorCode);

/**
	// _UnexportedLitField occurs when a positional struct literal implicitly
	// assigns an unexported field of an imported type.
**/
private final __UnexportedLitField:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidLitField occurs when a field name is not a valid identifier.
	//
	// Example:
	//  var _ = struct{i int}{1: 1}
**/
private final __InvalidLitField:T_errorCode = (144 : T_errorCode);

/**
	// _UntypedLit occurs when a composite literal omits a required type
	// identifier.
	//
	// Example:
	//  type outer struct{
	//  	inner struct { i int }
	//  }
	//
	//  var _ = outer{inner: {1}}
**/
private final __UntypedLit:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidLit occurs when a composite literal expression does not match its
	// type.
	//
	// Example:
	//  type P *struct{
	//  	x int
	//  }
	//  var _ = P {}
**/
private final __InvalidLit:T_errorCode = (144 : T_errorCode);

/**
	// _AmbiguousSelector occurs when a selector is ambiguous.
	//
	// Example:
	//  type E1 struct { i int }
	//  type E2 struct { i int }
	//  type T struct { E1; E2 }
	//
	//  var x T
	//  var _ = x.i
**/
private final __AmbiguousSelector:T_errorCode = (144 : T_errorCode);

/**
	// _UndeclaredImportedName occurs when a package-qualified identifier is
	// undeclared by the imported package.
	//
	// Example:
	//  import "go/types"
	//
	//  var _ = types.NotAnActualIdentifier
**/
private final __UndeclaredImportedName:T_errorCode = (144 : T_errorCode);

/**
	// _UnexportedName occurs when a selector refers to an unexported identifier
	// of an imported package.
	//
	// Example:
	//  import "reflect"
	//
	//  type _ reflect.flag
**/
private final __UnexportedName:T_errorCode = (144 : T_errorCode);

/**
	// _UndeclaredName occurs when an identifier is not declared in the current
	// scope.
	//
	// Example:
	//  var x T
**/
private final __UndeclaredName:T_errorCode = (144 : T_errorCode);

/**
	// _MissingFieldOrMethod occurs when a selector references a field or method
	// that does not exist.
	//
	// Example:
	//  type T struct {}
	//
	//  var x = T{}.f
**/
private final __MissingFieldOrMethod:T_errorCode = (144 : T_errorCode);

/**
	// _BadDotDotDotSyntax occurs when a "..." occurs in a context where it is
	// not valid.
	//
	// Example:
	//  var _ = map[int][...]int{0: {}}
**/
private final __BadDotDotDotSyntax:T_errorCode = (144 : T_errorCode);

/**
	// _NonVariadicDotDotDot occurs when a "..." is used on the final argument to
	// a non-variadic function.
	//
	// Example:
	//  func printArgs(s []string) {
	//  	for _, a := range s {
	//  		println(a)
	//  	}
	//  }
	//
	//  func f() {
	//  	s := []string{"a", "b", "c"}
	//  	printArgs(s...)
	//  }
**/
private final __NonVariadicDotDotDot:T_errorCode = (144 : T_errorCode);

/**
	// _MisplacedDotDotDot occurs when a "..." is used somewhere other than the
	// final argument in a function declaration.
	//
	// Example:
	// 	func f(...int, int)
**/
private final __MisplacedDotDotDot:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidDotDotDotOperand was removed.
**/
private final _1:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidDotDotDot occurs when a "..." is used in a non-variadic built-in
	// function.
	//
	// Example:
	//  var s = []int{1, 2, 3}
	//  var l = len(s...)
**/
private final __InvalidDotDotDot:T_errorCode = (144 : T_errorCode);

/**
	// _UncalledBuiltin occurs when a built-in function is used as a
	// function-valued expression, instead of being called.
	//
	// Per the spec:
	//  "The built-in functions do not have standard Go types, so they can only
	//  appear in call expressions; they cannot be used as function values."
	//
	// Example:
	//  var _ = copy
**/
private final __UncalledBuiltin:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidAppend occurs when append is called with a first argument that is
	// not a slice.
	//
	// Example:
	//  var _ = append(1, 2)
**/
private final __InvalidAppend:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidCap occurs when an argument to the cap built-in function is not of
	// supported type.
	//
	// See https://golang.org/ref/spec#Length_and_capacity for information on
	// which underlying types are supported as arguments to cap and len.
	//
	// Example:
	//  var s = 2
	//  var x = cap(s)
**/
private final __InvalidCap:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidClose occurs when close(...) is called with an argument that is
	// not of channel type, or that is a receive-only channel.
	//
	// Example:
	//  func f() {
	//  	var x int
	//  	close(x)
	//  }
**/
private final __InvalidClose:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidCopy occurs when the arguments are not of slice type or do not
	// have compatible type.
	//
	// See https://golang.org/ref/spec#Appending_and_copying_slices for more
	// information on the type requirements for the copy built-in.
	//
	// Example:
	//  func f() {
	//  	var x []int
	//  	y := []int64{1,2,3}
	//  	copy(x, y)
	//  }
**/
private final __InvalidCopy:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidComplex occurs when the complex built-in function is called with
	// arguments with incompatible types.
	//
	// Example:
	//  var _ = complex(float32(1), float64(2))
**/
private final __InvalidComplex:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidDelete occurs when the delete built-in function is called with a
	// first argument that is not a map.
	//
	// Example:
	//  func f() {
	//  	m := "hello"
	//  	delete(m, "e")
	//  }
**/
private final __InvalidDelete:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidImag occurs when the imag built-in function is called with an
	// argument that does not have complex type.
	//
	// Example:
	//  var _ = imag(int(1))
**/
private final __InvalidImag:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidLen occurs when an argument to the len built-in function is not of
	// supported type.
	//
	// See https://golang.org/ref/spec#Length_and_capacity for information on
	// which underlying types are supported as arguments to cap and len.
	//
	// Example:
	//  var s = 2
	//  var x = len(s)
**/
private final __InvalidLen:T_errorCode = (144 : T_errorCode);

/**
	// _SwappedMakeArgs occurs when make is called with three arguments, and its
	// length argument is larger than its capacity argument.
	//
	// Example:
	//  var x = make([]int, 3, 2)
**/
private final __SwappedMakeArgs:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidMake occurs when make is called with an unsupported type argument.
	//
	// See https://golang.org/ref/spec#Making_slices_maps_and_channels for
	// information on the types that may be created using make.
	//
	// Example:
	//  var x = make(int)
**/
private final __InvalidMake:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidReal occurs when the real built-in function is called with an
	// argument that does not have complex type.
	//
	// Example:
	//  var _ = real(int(1))
**/
private final __InvalidReal:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidAssert occurs when a type assertion is applied to a
	// value that is not of interface type.
	//
	// Example:
	//  var x = 1
	//  var _ = x.(float64)
**/
private final __InvalidAssert:T_errorCode = (144 : T_errorCode);

/**
	// _ImpossibleAssert occurs for a type assertion x.(T) when the value x of
	// interface cannot have dynamic type T, due to a missing or mismatching
	// method on T.
	//
	// Example:
	//  type T int
	//
	//  func (t *T) m() int { return int(*t) }
	//
	//  type I interface { m() int }
	//
	//  var x I
	//  var _ = x.(T)
**/
private final __ImpossibleAssert:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidConversion occurs when the argument type cannot be converted to the
	// target.
	//
	// See https://golang.org/ref/spec#Conversions for the rules of
	// convertibility.
	//
	// Example:
	//  var x float64
	//  var _ = string(x)
**/
private final __InvalidConversion:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidUntypedConversion occurs when an there is no valid implicit
	// conversion from an untyped value satisfying the type constraints of the
	// context in which it is used.
	//
	// Example:
	//  var _ = 1 + new(int)
**/
private final __InvalidUntypedConversion:T_errorCode = (144 : T_errorCode);

/**
	// _BadOffsetofSyntax occurs when unsafe.Offsetof is called with an argument
	// that is not a selector expression.
	//
	// Example:
	//  import "unsafe"
	//
	//  var x int
	//  var _ = unsafe.Offsetof(x)
**/
private final __BadOffsetofSyntax:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidOffsetof occurs when unsafe.Offsetof is called with a method
	// selector, rather than a field selector, or when the field is embedded via
	// a pointer.
	//
	// Per the spec:
	//
	//  "If f is an embedded field, it must be reachable without pointer
	//  indirections through fields of the struct. "
	//
	// Example:
	//  import "unsafe"
	//
	//  type T struct { f int }
	//  type S struct { *T }
	//  var s S
	//  var _ = unsafe.Offsetof(s.f)
	//
	// Example:
	//  import "unsafe"
	//
	//  type S struct{}
	//
	//  func (S) m() {}
	//
	//  var s S
	//  var _ = unsafe.Offsetof(s.m)
**/
private final __InvalidOffsetof:T_errorCode = (144 : T_errorCode);

/**
	// _UnusedExpr occurs when a side-effect free expression is used as a
	// statement. Such a statement has no effect.
	//
	// Example:
	//  func f(i int) {
	//  	i*i
	//  }
**/
private final __UnusedExpr:T_errorCode = (144 : T_errorCode);

/**
	// _UnusedVar occurs when a variable is declared but unused.
	//
	// Example:
	//  func f() {
	//  	x := 1
	//  }
**/
private final __UnusedVar:T_errorCode = (144 : T_errorCode);

/**
	// _MissingReturn occurs when a function with results is missing a return
	// statement.
	//
	// Example:
	//  func f() int {}
**/
private final __MissingReturn:T_errorCode = (144 : T_errorCode);

/**
	// _WrongResultCount occurs when a return statement returns an incorrect
	// number of values.
	//
	// Example:
	//  func ReturnOne() int {
	//  	return 1, 2
	//  }
**/
private final __WrongResultCount:T_errorCode = (144 : T_errorCode);

/**
	// _OutOfScopeResult occurs when the name of a value implicitly returned by
	// an empty return statement is shadowed in a nested scope.
	//
	// Example:
	//  func factor(n int) (i int) {
	//  	for i := 2; i < n; i++ {
	//  		if n%i == 0 {
	//  			return
	//  		}
	//  	}
	//  	return 0
	//  }
**/
private final __OutOfScopeResult:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidCond occurs when an if condition is not a boolean expression.
	//
	// Example:
	//  func checkReturn(i int) {
	//  	if i {
	//  		panic("non-zero return")
	//  	}
	//  }
**/
private final __InvalidCond:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidPostDecl occurs when there is a declaration in a for-loop post
	// statement.
	//
	// Example:
	//  func f() {
	//  	for i := 0; i < 10; j := 0 {}
	//  }
**/
private final __InvalidPostDecl:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidChanRange was removed.
**/
private final _2:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidIterVar occurs when two iteration variables are used while ranging
	// over a channel.
	//
	// Example:
	//  func f(c chan int) {
	//  	for k, v := range c {
	//  		println(k, v)
	//  	}
	//  }
**/
private final __InvalidIterVar:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidRangeExpr occurs when the type of a range expression is not array,
	// slice, string, map, or channel.
	//
	// Example:
	//  func f(i int) {
	//  	for j := range i {
	//  		println(j)
	//  	}
	//  }
**/
private final __InvalidRangeExpr:T_errorCode = (144 : T_errorCode);

/**
	// _MisplacedBreak occurs when a break statement is not within a for, switch,
	// or select statement of the innermost function definition.
	//
	// Example:
	//  func f() {
	//  	break
	//  }
**/
private final __MisplacedBreak:T_errorCode = (144 : T_errorCode);

/**
	// _MisplacedContinue occurs when a continue statement is not within a for
	// loop of the innermost function definition.
	//
	// Example:
	//  func sumeven(n int) int {
	//  	proceed := func() {
	//  		continue
	//  	}
	//  	sum := 0
	//  	for i := 1; i <= n; i++ {
	//  		if i % 2 != 0 {
	//  			proceed()
	//  		}
	//  		sum += i
	//  	}
	//  	return sum
	//  }
**/
private final __MisplacedContinue:T_errorCode = (144 : T_errorCode);

/**
	// _MisplacedFallthrough occurs when a fallthrough statement is not within an
	// expression switch.
	//
	// Example:
	//  func typename(i interface{}) string {
	//  	switch i.(type) {
	//  	case int64:
	//  		fallthrough
	//  	case int:
	//  		return "int"
	//  	}
	//  	return "unsupported"
	//  }
**/
private final __MisplacedFallthrough:T_errorCode = (144 : T_errorCode);

/**
	// _DuplicateCase occurs when a type or expression switch has duplicate
	// cases.
	//
	// Example:
	//  func printInt(i int) {
	//  	switch i {
	//  	case 1:
	//  		println("one")
	//  	case 1:
	//  		println("One")
	//  	}
	//  }
**/
private final __DuplicateCase:T_errorCode = (144 : T_errorCode);

/**
	// _DuplicateDefault occurs when a type or expression switch has multiple
	// default clauses.
	//
	// Example:
	//  func printInt(i int) {
	//  	switch i {
	//  	case 1:
	//  		println("one")
	//  	default:
	//  		println("One")
	//  	default:
	//  		println("1")
	//  	}
	//  }
**/
private final __DuplicateDefault:T_errorCode = (144 : T_errorCode);

/**
	// _BadTypeKeyword occurs when a .(type) expression is used anywhere other
	// than a type switch.
	//
	// Example:
	//  type I interface {
	//  	m()
	//  }
	//  var t I
	//  var _ = t.(type)
**/
private final __BadTypeKeyword:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidTypeSwitch occurs when .(type) is used on an expression that is
	// not of interface type.
	//
	// Example:
	//  func f(i int) {
	//  	switch x := i.(type) {}
	//  }
**/
private final __InvalidTypeSwitch:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidExprSwitch occurs when a switch expression is not comparable.
	//
	// Example:
	//  func _() {
	//  	var a struct{ _ func() }
	//  	switch a /|* ERROR cannot switch on a *|/ {
	//  	}
	//  }
**/
private final __InvalidExprSwitch:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidSelectCase occurs when a select case is not a channel send or
	// receive.
	//
	// Example:
	//  func checkChan(c <-chan int) bool {
	//  	select {
	//  	case c:
	//  		return true
	//  	default:
	//  		return false
	//  	}
	//  }
**/
private final __InvalidSelectCase:T_errorCode = (144 : T_errorCode);

/**
	// _UndeclaredLabel occurs when an undeclared label is jumped to.
	//
	// Example:
	//  func f() {
	//  	goto L
	//  }
**/
private final __UndeclaredLabel:T_errorCode = (144 : T_errorCode);

/**
	// _DuplicateLabel occurs when a label is declared more than once.
	//
	// Example:
	//  func f() int {
	//  L:
	//  L:
	//  	return 1
	//  }
**/
private final __DuplicateLabel:T_errorCode = (144 : T_errorCode);

/**
	// _MisplacedLabel occurs when a break or continue label is not on a for,
	// switch, or select statement.
	//
	// Example:
	//  func f() {
	//  L:
	//  	a := []int{1,2,3}
	//  	for _, e := range a {
	//  		if e > 10 {
	//  			break L
	//  		}
	//  		println(a)
	//  	}
	//  }
**/
private final __MisplacedLabel:T_errorCode = (144 : T_errorCode);

/**
	// _UnusedLabel occurs when a label is declared but not used.
	//
	// Example:
	//  func f() {
	//  L:
	//  }
**/
private final __UnusedLabel:T_errorCode = (144 : T_errorCode);

/**
	// _JumpOverDecl occurs when a label jumps over a variable declaration.
	//
	// Example:
	//  func f() int {
	//  	goto L
	//  	x := 2
	//  L:
	//  	x++
	//  	return x
	//  }
**/
private final __JumpOverDecl:T_errorCode = (144 : T_errorCode);

/**
	// _JumpIntoBlock occurs when a forward jump goes to a label inside a nested
	// block.
	//
	// Example:
	//  func f(x int) {
	//  	goto L
	//  	if x > 0 {
	//  	L:
	//  		print("inside block")
	//  	}
	// }
**/
private final __JumpIntoBlock:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidMethodExpr occurs when a pointer method is called but the argument
	// is not addressable.
	//
	// Example:
	//  type T struct {}
	//
	//  func (*T) m() int { return 1 }
	//
	//  var _ = T.m(T{})
**/
private final __InvalidMethodExpr:T_errorCode = (144 : T_errorCode);

/**
	// _WrongArgCount occurs when too few or too many arguments are passed by a
	// function call.
	//
	// Example:
	//  func f(i int) {}
	//  var x = f()
**/
private final __WrongArgCount:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidCall occurs when an expression is called that is not of function
	// type.
	//
	// Example:
	//  var x = "x"
	//  var y = x()
**/
private final __InvalidCall:T_errorCode = (144 : T_errorCode);

/**
	// _UnusedResults occurs when a restricted expression-only built-in function
	// is suspended via go or defer. Such a suspension discards the results of
	// these side-effect free built-in functions, and therefore is ineffectual.
	//
	// Example:
	//  func f(a []int) int {
	//  	defer len(a)
	//  	return i
	//  }
**/
private final __UnusedResults:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidDefer occurs when a deferred expression is not a function call,
	// for example if the expression is a type conversion.
	//
	// Example:
	//  func f(i int) int {
	//  	defer int32(i)
	//  	return i
	//  }
**/
private final __InvalidDefer:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidGo occurs when a go expression is not a function call, for example
	// if the expression is a type conversion.
	//
	// Example:
	//  func f(i int) int {
	//  	go int32(i)
	//  	return i
	//  }
**/
private final __InvalidGo:T_errorCode = (144 : T_errorCode);

/**
	// _BadDecl occurs when a declaration has invalid syntax.
**/
private final __BadDecl:T_errorCode = (144 : T_errorCode);

/**
	// _RepeatedDecl occurs when an identifier occurs more than once on the left
	// hand side of a short variable declaration.
	//
	// Example:
	//  func _() {
	//  	x, y, y := 1, 2, 3
	//  }
**/
private final __RepeatedDecl:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidUnsafeAdd occurs when unsafe.Add is called with a
	// length argument that is not of integer type.
	//
	// Example:
	//  import "unsafe"
	//
	//  var p unsafe.Pointer
	//  var _ = unsafe.Add(p, float64(1))
**/
private final __InvalidUnsafeAdd:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidUnsafeSlice occurs when unsafe.Slice is called with a
	// pointer argument that is not of pointer type or a length argument
	// that is not of integer type, negative, or out of bounds.
	//
	// Example:
	//  import "unsafe"
	//
	//  var x int
	//  var _ = unsafe.Slice(x, 1)
	//
	// Example:
	//  import "unsafe"
	//
	//  var x int
	//  var _ = unsafe.Slice(&x, float64(1))
	//
	// Example:
	//  import "unsafe"
	//
	//  var x int
	//  var _ = unsafe.Slice(&x, -1)
	//
	// Example:
	//  import "unsafe"
	//
	//  var x int
	//  var _ = unsafe.Slice(&x, uint64(1) << 63)
**/
private final __InvalidUnsafeSlice:T_errorCode = (144 : T_errorCode);

/**
	// _UnsupportedFeature occurs when a language feature is used that is not
	// supported at this Go version.
**/
private final __UnsupportedFeature:T_errorCode = (144 : T_errorCode);

/**
	// _NotAGenericType occurs when a non-generic type is used where a generic
	// type is expected: in type or function instantiation.
	//
	// Example:
	//  type T int
	//
	//  var _ T[int]
**/
private final __NotAGenericType:T_errorCode = (144 : T_errorCode);

/**
	// _WrongTypeArgCount occurs when a type or function is instantiated with an
	// incorrent number of type arguments, including when a generic type or
	// function is used without instantiation.
	//
	// Errors inolving failed type inference are assigned other error codes.
	//
	// Example:
	//  type T[p any] int
	//
	//  var _ T[int, string]
	//
	// Example:
	//  func f[T any]() {}
	//
	//  var x = f
**/
private final __WrongTypeArgCount:T_errorCode = (144 : T_errorCode);

/**
	// _CannotInferTypeArgs occurs when type or function type argument inference
	// fails to infer all type arguments.
	//
	// Example:
	//  func f[T any]() {}
	//
	//  func _() {
	//  	f()
	//  }
**/
private final __CannotInferTypeArgs:T_errorCode = (144 : T_errorCode);

/**
	// arguments? InferenceFailed// _InvalidTypeArg occurs when a type argument does not satisfy its
	// corresponding type parameter constraints.
	//
	// Example:
	//  type T[P ~int] struct{}
	//
	//  var _ T[string]
**/
private final __InvalidTypeArg:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidInstanceCycle occurs when an invalid cycle is detected
	// within the instantiation graph.
	//
	// Example:
	//  func f[T any]() { f[*T]() }
**/
private final __InvalidInstanceCycle:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidUnion occurs when an embedded union or approximation element is
	// not valid.
	//
	// Example:
	//  type _ interface {
	//   	~int | interface{ m() }
	//  }
**/
private final __InvalidUnion:T_errorCode = (144 : T_errorCode);

/**
	// _MisplacedConstraintIface occurs when a constraint-type interface is used
	// outside of constraint position.
	//
	// Example:
	//   type I interface { ~int }
	//
	//   var _ I
**/
private final __MisplacedConstraintIface:T_errorCode = (144 : T_errorCode);

/**
	// _InvalidMethodTypeParams occurs when methods have type parameters.
	//
	// It cannot be encountered with an AST parsed using go/parser.
**/
private final __InvalidMethodTypeParams:T_errorCode = (144 : T_errorCode);

/**
	// _MisplacedTypeParam occurs when a type parameter is used in a place where
	// it is not permitted.
	//
	// Example:
	//  type T[P any] P
	//
	// Example:
	//  type T[P any] struct{ *P }
**/
private final __MisplacedTypeParam:T_errorCode = (144 : T_errorCode);

private var _unaryOpPredicates:T_opPredicates = (null : T_opPredicates);
private var _binaryOpPredicates:T_opPredicates = (null : T_opPredicates);
private final _conversion:T_exprKind = (2 : T_exprKind);
private final _expression:T_exprKind = (2 : T_exprKind);
private final _statement:T_exprKind = (2 : T_exprKind);

/**
	// Shared empty method set.
**/
private var _emptyMethodSet:MethodSet = ({} : MethodSet);

/**
	// tparams, underlying type and methods might be unavailable
**/
private final _unresolved:T_namedState = (("2" : GoUInt32) : T_namedState);

/**
	// resolve has run; methods might be incomplete (for instances)
**/
private final _resolved:T_namedState = (("2" : GoUInt32) : T_namedState);

/**
	// all data is known
**/
private final _complete:T_namedState = (("2" : GoUInt32) : T_namedState);

/**
	// An object may be painted in one of three colors.
	// Color values other than white or black are considered grey.
**/
private final _white:T_color = (("2" : GoUInt32) : T_color);

/**
	// An object may be painted in one of three colors.
	// Color values other than white or black are considered grey.
**/
private final _black:T_color = (("2" : GoUInt32) : T_color);

/**
	// must be > white and black// An object may be painted in one of three colors.
	// Color values other than white or black are considered grey.
**/
private final _grey:T_color = (("2" : GoUInt32) : T_color);

/**
	// operand is invalid
**/
private final _invalid:T_operandMode = (10 : T_operandMode);

/**
	// operand represents no value (result of a function call w/o result)
**/
private final _novalue:T_operandMode = (10 : T_operandMode);

/**
	// operand is a built-in function
**/
private final _builtin:T_operandMode = (10 : T_operandMode);

/**
	// operand is a type
**/
private final _typexpr:T_operandMode = (10 : T_operandMode);

/**
	// operand is a constant; the operand's typ is a Basic type
**/
private final _constant_:T_operandMode = (10 : T_operandMode);

/**
	// operand is an addressable variable
**/
private final _variable:T_operandMode = (10 : T_operandMode);

/**
	// operand is a map index expression (acts like a variable on lhs, commaok on rhs of an assignment)
**/
private final _mapindex:T_operandMode = (10 : T_operandMode);

/**
	// operand is a computed value
**/
private final _value:T_operandMode = (10 : T_operandMode);

/**
	// like value, but operand may be used in a comma,ok expression
**/
private final _commaok:T_operandMode = (10 : T_operandMode);

/**
	// like commaok, but second value is error, not boolean
**/
private final _commaerr:T_operandMode = (10 : T_operandMode);

/**
	// operand is a cgo function
**/
private final _cgofunc:T_operandMode = (10 : T_operandMode);

/**
	// x.f is a struct field selector
**/
final fieldVal:SelectionKind = (2 : SelectionKind);

/**
	// x.f is a method selector
**/
final methodVal:SelectionKind = (2 : SelectionKind);

/**
	// x.f is a method expression
**/
final methodExpr:SelectionKind = (2 : SelectionKind);

/**
	// permissible control-flow statements
**/
private final _breakOk:T_stmtContext = (("16" : GoUInt) : T_stmtContext);

private final _continueOk:T_stmtContext = (("16" : GoUInt) : T_stmtContext);
private final _fallthroughOk:T_stmtContext = (("16" : GoUInt) : T_stmtContext);

/**
	// additional context information
**/
private final _finalSwitchCase:T_stmtContext = (("16" : GoUInt) : T_stmtContext);

private final _inTypeSwitch:T_stmtContext = (("16" : GoUInt) : T_stmtContext);

/**
	// Note: This is a uint32 rather than a uint64 because the
	// respective 64 bit atomic instructions are not available
	// on all platforms.
**/
private var _lastID:GoUInt32 = (0 : GoUInt32);

/**
	// invalidTypeSet is a singleton type set to signal an invalid type set
	// due to an error. It's also a valid empty type set, so consumers of
	// type sets may choose to ignore it.
**/
private var _invalidTypeSet:T__TypeSet = ({} : T__TypeSet);

/**
	// Upper limit for recursion depth. Used to catch infinite recursions
	// due to implementation issues (e.g., see issues #48619, #48656).
**/
private final _unificationDepthLimit:GoUInt64 = ("50" : GoUInt64);

/**
	// Whether to panic when unificationDepthLimit is reached.
	// If disabled, a recursion depth overflow results in a (quiet)
	// unification failure.
**/
private final _panicAtUnificationDepthLimit:InvalidType = true;

/**
	// If enableCoreTypeUnification is set, unification will consider
	// the core types, if any, of non-local (unbound) type parameters.
**/
private final _enableCoreTypeUnification:InvalidType = true;

/**
	// If traceInference is set, unification will print a trace of its operation.
	// Interpretation of trace:
	//   x ≡ y    attempt to unify types x and y
	//   p ➞ y    type parameter p is set to type y (p is inferred to be y)
	//   p ⇄ q    type parameters p and q match (p is inferred to be q and vice versa)
	//   x ≢ y    types x and y cannot be unified
	//   [p, q, ...] ➞ [x, y, ...]    mapping from type parameters to types
**/
private final _traceInference:InvalidType = false;

/**
	// Avoid excessive type-checking times due to quadratic termlist operations.
**/
private final _maxTermCount:GoUInt64 = ("100" : GoUInt64);

/**
	// The Universe scope contains all predeclared objects of Go.
	// It is the outermost scope of any chain of nested scopes.
**/
var universe:Ref<Scope> = (null : Ref<Scope>);

/**
	// The Unsafe package is the package returned by an importer
	// for the import path "unsafe".
**/
var unsafe:Ref<Package> = (null : Ref<Package>);

private var _universeIota:Object = (null : Object);

/**
	// uint8 alias, but has name "byte"
**/
private var _universeByte:Type = (null : Type);

/**
	// int32 alias, but has name "rune"
**/
private var _universeRune:Type = (null : Type);

private var _universeAny:Object = (null : Object);
private var _universeError:Type = (null : Type);
private var _universeComparable:Object = (null : Object);

/**
	// universe scope
**/
private final __Append:T_builtinId = (21 : T_builtinId);

private final __Cap:T_builtinId = (21 : T_builtinId);
private final __Close:T_builtinId = (21 : T_builtinId);
private final __Complex:T_builtinId = (21 : T_builtinId);
private final __Copy:T_builtinId = (21 : T_builtinId);
private final __Delete:T_builtinId = (21 : T_builtinId);
private final __Imag:T_builtinId = (21 : T_builtinId);
private final __Len:T_builtinId = (21 : T_builtinId);
private final __Make:T_builtinId = (21 : T_builtinId);
private final __New:T_builtinId = (21 : T_builtinId);
private final __Panic:T_builtinId = (21 : T_builtinId);
private final __Print:T_builtinId = (21 : T_builtinId);
private final __Println:T_builtinId = (21 : T_builtinId);
private final __Real:T_builtinId = (21 : T_builtinId);
private final __Recover:T_builtinId = (21 : T_builtinId);

/**
	// package unsafe
**/
private final __Add:T_builtinId = (21 : T_builtinId);

private final __Alignof:T_builtinId = (21 : T_builtinId);
private final __Offsetof:T_builtinId = (21 : T_builtinId);
private final __Sizeof:T_builtinId = (21 : T_builtinId);
private final __Slice:T_builtinId = (21 : T_builtinId);

/**
	// testing support
**/
private final __Assert:T_builtinId = (21 : T_builtinId);

private final __Trace:T_builtinId = (21 : T_builtinId);

/**
	// An Importer resolves import paths to Packages.
	//
	// CAUTION: This interface does not support the import of locally
	// vendored packages. See https://golang.org/s/go15vendor.
	// If possible, external implementations should implement ImporterFrom.
**/
typedef Importer = StructType & {
	/**
		// Import returns the imported package for the given import path.
		// The semantics is like for ImporterFrom.ImportFrom except that
		// dir and mode are ignored (since they are not present).
	**/
	public function import_(_path:GoString):{var _0:Ref<Package>; var _1:Error;};
};

/**
	// An ImporterFrom resolves import paths to packages; it
	// supports vendoring per https://golang.org/s/go15vendor.
	// Use go/importer to obtain an ImporterFrom implementation.
**/
typedef ImporterFrom = StructType & {
	> Importer,

	/**
		// ImportFrom returns the imported package for the given import
		// path when imported by a package file located in dir.
		// If the import failed, besides returning an error, ImportFrom
		// is encouraged to cache and return a package anyway, if one
		// was created. This will reduce package inconsistencies and
		// follow-on type checker errors due to the missing package.
		// The mode value must be 0; it is reserved for future use.
		// Two calls to ImportFrom with the same path and dir must
		// return the same package.
	**/
	public function importFrom(_path:GoString, _dir:GoString, _mode:ImportMode):{var _0:Ref<Package>; var _1:Error;};
};

private typedef T_cleaner = StructType & {
	public function _cleanup():Void;
};

private typedef T_decl = StructType & {
	public function _node():stdgo.go.ast.Ast.Node;
};

/**
	// The positioner interface is used to extract the position of type-checker
	// errors.
**/
private typedef T_positioner = StructType & {
	public function pos():stdgo.go.token.Token.Pos;
};

/**
	// A dependency is an object that may be a dependency in an initialization
	// expression. Only constants, variables, and functions can be dependencies.
	// Constants are here because constant expression cycles are reported during
	// initialization order computation.
**/
private typedef T_dependency = StructType & {
	> Object,
	public function _isDependency():Void;
};

/**
	// An Object describes a named language entity such as a package,
	// constant, type, variable, function (incl. methods), or label.
	// All objects implement the Object interface.
**/
typedef Object = StructType & {
	/**
		// scope in which this object is declared; nil for methods and struct fields
	**/
	public function parent():Ref<Scope>;

	/**
		// position of object identifier in declaration
	**/
	public function pos():stdgo.go.token.Token.Pos;

	/**
		// package to which this object belongs; nil for labels and objects in the Universe scope
	**/
	public function pkg():Ref<Package>;

	/**
		// package local object name
	**/
	public function name():GoString;

	/**
		// object type
	**/
	public function type():Type;

	/**
		// reports whether the name starts with a capital letter
	**/
	public function exported():Bool;

	/**
		// object name if exported, qualified name if not exported (see func Id)
	**/
	public function id():GoString;

	/**
		// String returns a human-readable string of the object.
	**/
	public function string():GoString;

	/**
		// order reflects a package-level object's source order: if object
		// a is before object b in the source, then a.order() < b.order().
		// order returns a value > 0 for package-level objects; it returns
		// 0 for all other objects (including objects in file scopes).
	**/
	public function _order():GoUInt32;

	/**
		// color returns the object's color.
	**/
	public function _color():T_color;

	/**
		// setType sets the type of the object.
	**/
	public function _setType(_0:Type):Void;

	/**
		// setOrder sets the order number of the object. It must be > 0.
	**/
	public function _setOrder(_0:GoUInt32):Void;

	/**
		// setColor sets the object's color. It must not be white.
	**/
	public function _setColor(_color:T_color):Void;

	/**
		// setParent sets the parent scope of the object.
	**/
	public function _setParent(_0:Ref<Scope>):Void;

	/**
		// sameId reports whether obj.Id() and Id(pkg, name) are the same.
	**/
	public function _sameId(_pkg:Ref<Package>, _name:GoString):Bool;

	/**
		// scopePos returns the start position of the scope of this Object
	**/
	public function _scopePos():stdgo.go.token.Token.Pos;

	/**
		// setScopePos sets the start position of the scope for this Object.
	**/
	public function _setScopePos(_pos:stdgo.go.token.Token.Pos):Void;
};

/**
	// Sizes defines the sizing functions for package unsafe.
**/
typedef Sizes = StructType & {
	/**
		// Alignof returns the alignment of a variable of type T.
		// Alignof must implement the alignment guarantees required by the spec.
	**/
	public function alignof_(t:Type):GoInt64;

	/**
		// Offsetsof returns the offsets of the given struct fields, in bytes.
		// Offsetsof must implement the offset guarantees required by the spec.
	**/
	public function offsetsof(_fields:Slice<Ref<Var>>):Slice<GoInt64>;

	/**
		// Sizeof returns the size of a variable of type T.
		// Sizeof must implement the size guarantees required by the spec.
	**/
	public function sizeof(t:Type):GoInt64;
};

/**
	// A Type represents a type of Go.
	// All types implement the Type interface.
**/
typedef Type = StructType & {
	/**
		// Underlying returns the underlying type of a type.
	**/
	public function underlying():Type;

	/**
		// String returns a string representation of a type.
	**/
	public function string():GoString;
};

/**
	// An Error describes a type-checking error; it implements the error interface.
	// A "soft" error is an error that still permits a valid interpretation of a
	// package (such as "unused variable"); "hard" errors may lead to unpredictable
	// behavior if ignored.
**/
@:structInit @:using(stdgo.go.types.Types.T_error_static_extension) class T_error {
	public var fset:Ref<stdgo.go.token.Token.FileSet> = (null : Ref<stdgo.go.token.Token.FileSet>);
	public var pos:stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
	public var msg:GoString = "";
	public var soft:Bool = false;

	/**
		// go116code is a future API, unexported as the set of error codes is large
		// and likely to change significantly during experimentation. Tools wishing
		// to preview this feature may read go116code using reflection (see
		// errorcodes_test.go), but beware that there is no guarantee of future
		// compatibility.
	**/
	public var _go116code:T_errorCode = ((0 : GoInt) : T_errorCode);

	public var _go116start:stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
	public var _go116end:stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);

	public function new(?fset:Ref<stdgo.go.token.Token.FileSet>, ?pos:stdgo.go.token.Token.Pos, ?msg:GoString, ?soft:Bool, ?_go116code:T_errorCode,
			?_go116start:stdgo.go.token.Token.Pos, ?_go116end:stdgo.go.token.Token.Pos) {
		if (fset != null)
			this.fset = fset;
		if (pos != null)
			this.pos = pos;
		if (msg != null)
			this.msg = msg;
		if (soft != null)
			this.soft = soft;
		if (_go116code != null)
			this._go116code = _go116code;
		if (_go116start != null)
			this._go116start = _go116start;
		if (_go116end != null)
			this._go116end = _go116end;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_error(fset, pos, msg, soft, _go116code, _go116start, _go116end);
	}
}

/**
	// An ArgumentError holds an error associated with an argument index.
**/
@:structInit @:using(stdgo.go.types.Types.ArgumentError_static_extension) class ArgumentError {
	public var index:GoInt = 0;
	public var err:Error = (null : Error);

	public function new(?index:GoInt, ?err:Error) {
		if (index != null)
			this.index = index;
		if (err != null)
			this.err = err;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new ArgumentError(index, err);
	}
}

/**
	// A Config specifies the configuration for type checking.
	// The zero value for Config is a ready-to-use default configuration.
**/
@:structInit @:using(stdgo.go.types.Types.Config_static_extension) class Config {
	/**
		// Context is the context used for resolving global identifiers. If nil, the
		// type checker will initialize this field with a newly created context.
	**/
	public var context:Ref<Context> = (null : Ref<Context>);

	/**
		// GoVersion describes the accepted Go language version. The string
		// must follow the format "go%d.%d" (e.g. "go1.12") or it must be
		// empty; an empty string indicates the latest language version.
		// If the format is invalid, invoking the type checker will cause a
		// panic.
	**/
	public var goVersion:GoString = "";

	/**
		// If IgnoreFuncBodies is set, function bodies are not
		// type-checked.
	**/
	public var ignoreFuncBodies:Bool = false;

	/**
		// If FakeImportC is set, `import "C"` (for packages requiring Cgo)
		// declares an empty "C" package and errors are omitted for qualified
		// identifiers referring to package C (which won't find an object).
		// This feature is intended for the standard library cmd/api tool.
		//
		// Caution: Effects may be unpredictable due to follow-on errors.
		//          Do not use casually!
	**/
	public var fakeImportC:Bool = false;

	/**
		// If go115UsesCgo is set, the type checker expects the
		// _cgo_gotypes.go file generated by running cmd/cgo to be
		// provided as a package source file. Qualified identifiers
		// referring to package C will be resolved to cgo-provided
		// declarations within _cgo_gotypes.go.
		//
		// It is an error to set both FakeImportC and go115UsesCgo.
	**/
	public var _go115UsesCgo:Bool = false;

	/**
		// If Error != nil, it is called with each error found
		// during type checking; err has dynamic type Error.
		// Secondary errors (for instance, to enumerate all types
		// involved in an invalid recursive type declaration) have
		// error strings that start with a '\t' character.
		// If Error == nil, type-checking stops with the first
		// error found.
	**/
	public var error:Error->Void = null;

	/**
		// An importer is used to import packages referred to from
		// import declarations.
		// If the installed importer implements ImporterFrom, the type
		// checker calls ImportFrom instead of Import.
		// The type checker reports an error if an importer is needed
		// but none was installed.
	**/
	public var importer:Importer = (null : Importer);

	/**
		// If Sizes != nil, it provides the sizing functions for package unsafe.
		// Otherwise SizesFor("gc", "amd64") is used instead.
	**/
	public var sizes:Sizes = (null : Sizes);

	/**
		// If DisableUnusedImportCheck is set, packages are not checked
		// for unused imports.
	**/
	public var disableUnusedImportCheck:Bool = false;

	public function new(?context:Ref<Context>, ?goVersion:GoString, ?ignoreFuncBodies:Bool, ?fakeImportC:Bool, ?_go115UsesCgo:Bool, ?error:Error->Void,
			?importer:Importer, ?sizes:Sizes, ?disableUnusedImportCheck:Bool) {
		if (context != null)
			this.context = context;
		if (goVersion != null)
			this.goVersion = goVersion;
		if (ignoreFuncBodies != null)
			this.ignoreFuncBodies = ignoreFuncBodies;
		if (fakeImportC != null)
			this.fakeImportC = fakeImportC;
		if (_go115UsesCgo != null)
			this._go115UsesCgo = _go115UsesCgo;
		if (error != null)
			this.error = error;
		if (importer != null)
			this.importer = importer;
		if (sizes != null)
			this.sizes = sizes;
		if (disableUnusedImportCheck != null)
			this.disableUnusedImportCheck = disableUnusedImportCheck;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new Config(context, goVersion, ignoreFuncBodies, fakeImportC, _go115UsesCgo, error, importer, sizes, disableUnusedImportCheck);
	}
}

/**
	// Info holds result type information for a type-checked package.
	// Only the information for which a map is provided is collected.
	// If the package has type errors, the collected information may
	// be incomplete.
**/
@:structInit @:using(stdgo.go.types.Types.Info_static_extension) class Info {
	/**
		// Types maps expressions to their types, and for constant
		// expressions, also their values. Invalid expressions are
		// omitted.
		//
		// For (possibly parenthesized) identifiers denoting built-in
		// functions, the recorded signatures are call-site specific:
		// if the call result is not a constant, the recorded type is
		// an argument-specific signature. Otherwise, the recorded type
		// is invalid.
		//
		// The Types map does not record the type of every identifier,
		// only those that appear where an arbitrary expression is
		// permitted. For instance, the identifier f in a selector
		// expression x.f is found only in the Selections map, the
		// identifier z in a variable declaration 'var z int' is found
		// only in the Defs map, and identifiers denoting packages in
		// qualified identifiers are collected in the Uses map.
	**/
	public var types:GoMap<stdgo.go.ast.Ast.Expr, TypeAndValue> = (null : GoMap<stdgo.go.ast.Ast.Expr, TypeAndValue>);

	/**
		// Instances maps identifiers denoting generic types or functions to their
		// type arguments and instantiated type.
		//
		// For example, Instances will map the identifier for 'T' in the type
		// instantiation T[int, string] to the type arguments [int, string] and
		// resulting instantiated *Named type. Given a generic function
		// func F[A any](A), Instances will map the identifier for 'F' in the call
		// expression F(int(1)) to the inferred type arguments [int], and resulting
		// instantiated *Signature.
		//
		// Invariant: Instantiating Uses[id].Type() with Instances[id].TypeArgs
		// results in an equivalent of Instances[id].Type.
	**/
	public var instances:GoMap<Ref<stdgo.go.ast.Ast.Ident>, Instance> = (null : GoMap<Ref<stdgo.go.ast.Ast.Ident>, Instance>);

	/**
		// Defs maps identifiers to the objects they define (including
		// package names, dots "." of dot-imports, and blank "_" identifiers).
		// For identifiers that do not denote objects (e.g., the package name
		// in package clauses, or symbolic variables t in t := x.(type) of
		// type switch headers), the corresponding objects are nil.
		//
		// For an embedded field, Defs returns the field *Var it defines.
		//
		// Invariant: Defs[id] == nil || Defs[id].Pos() == id.Pos()
	**/
	public var defs:GoMap<Ref<stdgo.go.ast.Ast.Ident>, Object> = (null : GoMap<Ref<stdgo.go.ast.Ast.Ident>, Object>);

	/**
		// Uses maps identifiers to the objects they denote.
		//
		// For an embedded field, Uses returns the *TypeName it denotes.
		//
		// Invariant: Uses[id].Pos() != id.Pos()
	**/
	public var uses:GoMap<Ref<stdgo.go.ast.Ast.Ident>, Object> = (null : GoMap<Ref<stdgo.go.ast.Ast.Ident>, Object>);

	/**
		// Implicits maps nodes to their implicitly declared objects, if any.
		// The following node and object types may appear:
		//
		//     node               declared object
		//
		//     *ast.ImportSpec    *PkgName for imports without renames
		//     *ast.CaseClause    type-specific *Var for each type switch case clause (incl. default)
		//     *ast.Field         anonymous parameter *Var (incl. unnamed results)
		//
	**/
	public var implicits:GoMap<stdgo.go.ast.Ast.Node, Object> = (null : GoMap<stdgo.go.ast.Ast.Node, Object>);

	/**
		// Selections maps selector expressions (excluding qualified identifiers)
		// to their corresponding selections.
	**/
	public var selections:GoMap<Ref<stdgo.go.ast.Ast.SelectorExpr>, Ref<Selection>> = (null : GoMap<Ref<stdgo.go.ast.Ast.SelectorExpr>, Ref<Selection>>);

	/**
		// Scopes maps ast.Nodes to the scopes they define. Package scopes are not
		// associated with a specific node but with all files belonging to a package.
		// Thus, the package scope can be found in the type-checked Package object.
		// Scopes nest, with the Universe scope being the outermost scope, enclosing
		// the package scope, which contains (one or more) files scopes, which enclose
		// function scopes which in turn enclose statement and function literal scopes.
		// Note that even though package-level functions are declared in the package
		// scope, the function scopes are embedded in the file scope of the file
		// containing the function declaration.
		//
		// The following node types may appear in Scopes:
		//
		//     *ast.File
		//     *ast.FuncType
		//     *ast.TypeSpec
		//     *ast.BlockStmt
		//     *ast.IfStmt
		//     *ast.SwitchStmt
		//     *ast.TypeSwitchStmt
		//     *ast.CaseClause
		//     *ast.CommClause
		//     *ast.ForStmt
		//     *ast.RangeStmt
		//
	**/
	public var scopes:GoMap<stdgo.go.ast.Ast.Node, Ref<Scope>> = (null : GoMap<stdgo.go.ast.Ast.Node, Ref<Scope>>);

	/**
		// InitOrder is the list of package-level initializers in the order in which
		// they must be executed. Initializers referring to variables related by an
		// initialization dependency appear in topological order, the others appear
		// in source order. Variables without an initialization expression do not
		// appear in this list.
	**/
	public var initOrder:Slice<Ref<Initializer>> = (null : Slice<Ref<Initializer>>);

	public function new(?types:GoMap<stdgo.go.ast.Ast.Expr, TypeAndValue>, ?instances:GoMap<Ref<stdgo.go.ast.Ast.Ident>, Instance>,
			?defs:GoMap<Ref<stdgo.go.ast.Ast.Ident>, Object>, ?uses:GoMap<Ref<stdgo.go.ast.Ast.Ident>, Object>,
			?implicits:GoMap<stdgo.go.ast.Ast.Node, Object>, ?selections:GoMap<Ref<stdgo.go.ast.Ast.SelectorExpr>, Ref<Selection>>,
			?scopes:GoMap<stdgo.go.ast.Ast.Node, Ref<Scope>>, ?initOrder:Slice<Ref<Initializer>>) {
		if (types != null)
			this.types = types;
		if (instances != null)
			this.instances = instances;
		if (defs != null)
			this.defs = defs;
		if (uses != null)
			this.uses = uses;
		if (implicits != null)
			this.implicits = implicits;
		if (selections != null)
			this.selections = selections;
		if (scopes != null)
			this.scopes = scopes;
		if (initOrder != null)
			this.initOrder = initOrder;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new Info(types, instances, defs, uses, implicits, selections, scopes, initOrder);
	}
}

/**
	// TypeAndValue reports the type and value (for constants)
	// of the corresponding expression.
**/
@:structInit @:using(stdgo.go.types.Types.TypeAndValue_static_extension) class TypeAndValue {
	public var _mode:T_operandMode = ((0 : GoUInt8) : T_operandMode);
	public var type:Type = (null : Type);
	public var value:stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);

	public function new(?_mode:T_operandMode, ?type:Type, ?value:stdgo.go.constant.Constant.Value) {
		if (_mode != null)
			this._mode = _mode;
		if (type != null)
			this.type = type;
		if (value != null)
			this.value = value;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new TypeAndValue(_mode, type, value);
	}
}

/**
	// Instance reports the type arguments and instantiated type for type and
	// function instantiations. For type instantiations, Type will be of dynamic
	// type *Named. For function instantiations, Type will be of dynamic type
	// *Signature.
**/
@:structInit class Instance {
	public var typeArgs:Ref<TypeList> = (null : Ref<TypeList>);
	public var type:Type = (null : Type);

	public function new(?typeArgs:Ref<TypeList>, ?type:Type) {
		if (typeArgs != null)
			this.typeArgs = typeArgs;
		if (type != null)
			this.type = type;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new Instance(typeArgs, type);
	}
}

/**
	// An Initializer describes a package-level variable, or a list of variables in case
	// of a multi-valued initialization expression, and the corresponding initialization
	// expression.
**/
@:structInit @:using(stdgo.go.types.Types.Initializer_static_extension) class Initializer {
	public var lhs:Slice<Ref<Var>> = (null : Slice<Ref<Var>>);
	public var rhs:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);

	public function new(?lhs:Slice<Ref<Var>>, ?rhs:stdgo.go.ast.Ast.Expr) {
		if (lhs != null)
			this.lhs = lhs;
		if (rhs != null)
			this.rhs = rhs;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new Initializer(lhs, rhs);
	}
}

/**
	// An Array represents an array type.
**/
@:structInit @:using(stdgo.go.types.Types.Array__static_extension) class Array_ {
	public var _len:GoInt64 = 0;
	public var _elem:Type = (null : Type);

	public function new(?_len:GoInt64, ?_elem:Type) {
		if (_len != null)
			this._len = _len;
		if (_elem != null)
			this._elem = _elem;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new Array_(_len, _elem);
	}
}

/**
	// A Basic represents a basic type.
**/
@:structInit @:using(stdgo.go.types.Types.Basic_static_extension) class Basic {
	public var _kind:BasicKind = ((0 : GoInt) : BasicKind);
	public var _info:BasicInfo = ((0 : GoInt) : BasicInfo);
	public var _name:GoString = "";

	public function new(?_kind:BasicKind, ?_info:BasicInfo, ?_name:GoString) {
		if (_kind != null)
			this._kind = _kind;
		if (_info != null)
			this._info = _info;
		if (_name != null)
			this._name = _name;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new Basic(_kind, _info, _name);
	}
}

/**
	// A Chan represents a channel type.
**/
@:structInit @:using(stdgo.go.types.Types.Chan_static_extension) class Chan {
	public var _dir:ChanDir = ((0 : GoInt) : ChanDir);
	public var _elem:Type = (null : Type);

	public function new(?_dir:ChanDir, ?_elem:Type) {
		if (_dir != null)
			this._dir = _dir;
		if (_elem != null)
			this._elem = _elem;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new Chan(_dir, _elem);
	}
}

/**
	// exprInfo stores information about an untyped expression.
**/
@:structInit private class T_exprInfo {
	public var _isLhs:Bool = false;
	public var _mode:T_operandMode = ((0 : GoUInt8) : T_operandMode);
	public var _typ:Ref<Basic> = (null : Ref<Basic>);
	public var _val:stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);

	public function new(?_isLhs:Bool, ?_mode:T_operandMode, ?_typ:Ref<Basic>, ?_val:stdgo.go.constant.Constant.Value) {
		if (_isLhs != null)
			this._isLhs = _isLhs;
		if (_mode != null)
			this._mode = _mode;
		if (_typ != null)
			this._typ = _typ;
		if (_val != null)
			this._val = _val;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_exprInfo(_isLhs, _mode, _typ, _val);
	}
}

/**
	// An environment represents the environment within which an object is
	// type-checked.
**/
@:structInit @:using(stdgo.go.types.Types.T_environment_static_extension) private class T_environment {
	public var _decl:Ref<T_declInfo> = (null : Ref<T_declInfo>);
	public var _scope:Ref<Scope> = (null : Ref<Scope>);
	public var _pos:stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
	public var _iota:stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
	public var _errpos:T_positioner = (null : T_positioner);
	public var _inTParamList:Bool = false;
	public var _sig:Ref<Signature> = (null : Ref<Signature>);
	public var _isPanic:GoMap<Ref<stdgo.go.ast.Ast.CallExpr>, Bool> = (null : GoMap<Ref<stdgo.go.ast.Ast.CallExpr>, Bool>);
	public var _hasLabel:Bool = false;
	public var _hasCallOrRecv:Bool = false;

	public function new(?_decl:Ref<T_declInfo>, ?_scope:Ref<Scope>, ?_pos:stdgo.go.token.Token.Pos, ?_iota:stdgo.go.constant.Constant.Value,
			?_errpos:T_positioner, ?_inTParamList:Bool, ?_sig:Ref<Signature>, ?_isPanic:GoMap<Ref<stdgo.go.ast.Ast.CallExpr>, Bool>, ?_hasLabel:Bool,
			?_hasCallOrRecv:Bool) {
		if (_decl != null)
			this._decl = _decl;
		if (_scope != null)
			this._scope = _scope;
		if (_pos != null)
			this._pos = _pos;
		if (_iota != null)
			this._iota = _iota;
		if (_errpos != null)
			this._errpos = _errpos;
		if (_inTParamList != null)
			this._inTParamList = _inTParamList;
		if (_sig != null)
			this._sig = _sig;
		if (_isPanic != null)
			this._isPanic = _isPanic;
		if (_hasLabel != null)
			this._hasLabel = _hasLabel;
		if (_hasCallOrRecv != null)
			this._hasCallOrRecv = _hasCallOrRecv;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_environment(_decl, _scope, _pos, _iota, _errpos, _inTParamList, _sig, _isPanic, _hasLabel, _hasCallOrRecv);
	}
}

/**
	// An importKey identifies an imported package by import path and source directory
	// (directory containing the file containing the import). In practice, the directory
	// may always be the same, or may not matter. Given an (import path, directory), an
	// importer must always return the same package (but given two different import paths,
	// an importer may still return the same package by mapping them to the same package
	// paths).
**/
@:structInit private class T_importKey {
	public var _path:GoString = "";
	public var _dir:GoString = "";

	public function new(?_path:GoString, ?_dir:GoString) {
		if (_path != null)
			this._path = _path;
		if (_dir != null)
			this._dir = _dir;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_importKey(_path, _dir);
	}
}

/**
	// A dotImportKey describes a dot-imported object in the given scope.
**/
@:structInit private class T_dotImportKey {
	public var _scope:Ref<Scope> = (null : Ref<Scope>);
	public var _name:GoString = "";

	public function new(?_scope:Ref<Scope>, ?_name:GoString) {
		if (_scope != null)
			this._scope = _scope;
		if (_name != null)
			this._name = _name;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_dotImportKey(_scope, _name);
	}
}

/**
	// An action describes a (delayed) action.
**/
@:structInit @:using(stdgo.go.types.Types.T_action_static_extension) private class T_action {
	public var _f:() -> Void = null;
	public var _desc:Ref<T_actionDesc> = (null : Ref<T_actionDesc>);

	public function new(?_f:() -> Void, ?_desc:Ref<T_actionDesc>) {
		if (_f != null)
			this._f = _f;
		if (_desc != null)
			this._desc = _desc;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_action(_f, _desc);
	}
}

/**
	// An actionDesc provides information on an action.
	// For debugging only.
**/
@:structInit private class T_actionDesc {
	public var _pos:T_positioner = (null : T_positioner);
	public var _format:GoString = "";
	public var _args:Slice<AnyInterface> = (null : Slice<AnyInterface>);

	public function new(?_pos:T_positioner, ?_format:GoString, ?_args:Slice<AnyInterface>) {
		if (_pos != null)
			this._pos = _pos;
		if (_format != null)
			this._format = _format;
		if (_args != null)
			this._args = _args;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_actionDesc(_pos, _format, _args);
	}
}

/**
	// A Checker maintains the state of the type checker.
	// It must be created with NewChecker.
**/
@:structInit @:using(stdgo.go.types.Types.Checker_static_extension) class Checker {
	/**
		// package information
		// (initialized by NewChecker, valid for the life-time of checker)
	**/
	public var _conf:Ref<Config> = (null : Ref<Config>);

	public var _ctxt:Ref<Context> = (null : Ref<Context>);
	public var _fset:Ref<stdgo.go.token.Token.FileSet> = (null : Ref<stdgo.go.token.Token.FileSet>);
	public var _pkg:Ref<Package> = (null : Ref<Package>);
	@:embedded
	public var info:Ref<Info> = (null : Ref<Info>);
	public var _version:T_version = ({} : T_version);
	public var _nextID:GoUInt64 = 0;
	public var _objMap:GoMap<Object, Ref<T_declInfo>> = (null : GoMap<Object, Ref<T_declInfo>>);
	public var _impMap:GoMap<T_importKey, Ref<Package>> = (null : GoMap<T_importKey, Ref<Package>>);
	public var _valids:T_instanceLookup = ({} : T_instanceLookup);

	/**
		// pkgPathMap maps package names to the set of distinct import paths we've
		// seen for that name, anywhere in the import graph. It is used for
		// disambiguating package names in error messages.
		//
		// pkgPathMap is allocated lazily, so that we don't pay the price of building
		// it on the happy path. seenPkgMap tracks the packages that we've already
		// walked.
	**/
	public var _pkgPathMap:GoMap<GoString, GoMap<GoString, Bool>> = (null : GoMap<GoString, GoMap<GoString, Bool>>);

	public var _seenPkgMap:GoMap<Ref<Package>, Bool> = (null : GoMap<Ref<Package>, Bool>);

	/**
		// information collected during type-checking of a set of package files
		// (initialized by Files, valid only for the duration of check.Files;
		// maps and lists are allocated on demand)
	**/
	public var _files:Slice<Ref<stdgo.go.ast.Ast.File>> = (null : Slice<Ref<stdgo.go.ast.Ast.File>>);

	public var _imports:Slice<Ref<PkgName>> = (null : Slice<Ref<PkgName>>);
	public var _dotImportMap:GoMap<T_dotImportKey, Ref<PkgName>> = (null : GoMap<T_dotImportKey, Ref<PkgName>>);
	public var _recvTParamMap:GoMap<Ref<stdgo.go.ast.Ast.Ident>, Ref<TypeParam>> = (null : GoMap<Ref<stdgo.go.ast.Ast.Ident>, Ref<TypeParam>>);
	public var _brokenAliases:GoMap<Ref<TypeName>, Bool> = (null : GoMap<Ref<TypeName>, Bool>);
	public var _unionTypeSets:GoMap<Ref<Union>, Ref<T__TypeSet>> = (null : GoMap<Ref<Union>, Ref<T__TypeSet>>);
	public var _mono:T_monoGraph = ({} : T_monoGraph);
	public var _firstErr:Error = (null : Error);
	public var _methods:GoMap<Ref<TypeName>, Slice<Ref<Func>>> = (null : GoMap<Ref<TypeName>, Slice<Ref<Func>>>);
	public var _untyped:GoMap<stdgo.go.ast.Ast.Expr, T_exprInfo> = (null : GoMap<stdgo.go.ast.Ast.Expr, T_exprInfo>);
	public var _delayed:Slice<T_action> = (null : Slice<T_action>);
	public var _objPath:Slice<Object> = (null : Slice<Object>);
	public var _cleaners:Slice<T_cleaner> = (null : Slice<T_cleaner>);

	/**
		// environment within which the current object is type-checked (valid only
		// for the duration of type-checking a specific object)
	**/
	@:embedded
	public var _environment:T_environment = ({} : T_environment);

	/**
		// debugging
	**/
	public var _indent:GoInt = 0;

	public function new(?_conf:Ref<Config>, ?_ctxt:Ref<Context>, ?_fset:Ref<stdgo.go.token.Token.FileSet>, ?_pkg:Ref<Package>, ?info:Ref<Info>,
			?_version:T_version, ?_nextID:GoUInt64, ?_objMap:GoMap<Object, Ref<T_declInfo>>, ?_impMap:GoMap<T_importKey, Ref<Package>>,
			?_valids:T_instanceLookup, ?_pkgPathMap:GoMap<GoString, GoMap<GoString, Bool>>, ?_seenPkgMap:GoMap<Ref<Package>, Bool>,
			?_files:Slice<Ref<stdgo.go.ast.Ast.File>>, ?_imports:Slice<Ref<PkgName>>, ?_dotImportMap:GoMap<T_dotImportKey, Ref<PkgName>>,
			?_recvTParamMap:GoMap<Ref<stdgo.go.ast.Ast.Ident>, Ref<TypeParam>>, ?_brokenAliases:GoMap<Ref<TypeName>, Bool>,
			?_unionTypeSets:GoMap<Ref<Union>, Ref<T__TypeSet>>, ?_mono:T_monoGraph, ?_firstErr:Error, ?_methods:GoMap<Ref<TypeName>, Slice<Ref<Func>>>,
			?_untyped:GoMap<stdgo.go.ast.Ast.Expr, T_exprInfo>, ?_delayed:Slice<T_action>, ?_objPath:Slice<Object>, ?_cleaners:Slice<T_cleaner>,
			?_environment:T_environment, ?_indent:GoInt) {
		if (_conf != null)
			this._conf = _conf;
		if (_ctxt != null)
			this._ctxt = _ctxt;
		if (_fset != null)
			this._fset = _fset;
		if (_pkg != null)
			this._pkg = _pkg;
		if (info != null)
			this.info = info;
		if (_version != null)
			this._version = _version;
		if (_nextID != null)
			this._nextID = _nextID;
		if (_objMap != null)
			this._objMap = _objMap;
		if (_impMap != null)
			this._impMap = _impMap;
		if (_valids != null)
			this._valids = _valids;
		if (_pkgPathMap != null)
			this._pkgPathMap = _pkgPathMap;
		if (_seenPkgMap != null)
			this._seenPkgMap = _seenPkgMap;
		if (_files != null)
			this._files = _files;
		if (_imports != null)
			this._imports = _imports;
		if (_dotImportMap != null)
			this._dotImportMap = _dotImportMap;
		if (_recvTParamMap != null)
			this._recvTParamMap = _recvTParamMap;
		if (_brokenAliases != null)
			this._brokenAliases = _brokenAliases;
		if (_unionTypeSets != null)
			this._unionTypeSets = _unionTypeSets;
		if (_mono != null)
			this._mono = _mono;
		if (_firstErr != null)
			this._firstErr = _firstErr;
		if (_methods != null)
			this._methods = _methods;
		if (_untyped != null)
			this._untyped = _untyped;
		if (_delayed != null)
			this._delayed = _delayed;
		if (_objPath != null)
			this._objPath = _objPath;
		if (_cleaners != null)
			this._cleaners = _cleaners;
		if (_environment != null)
			this._environment = _environment;
		if (_indent != null)
			this._indent = _indent;
	}

	public function __underlying__()
		return Go.toInterface(this);

	@:embedded
	public function objectOf(_id:Ref<stdgo.go.ast.Ast.Ident>):Object
		return info.objectOf(_id);

	@:embedded
	public function typeOf(_e:stdgo.go.ast.Ast.Expr):Type
		return info.typeOf(_e);

	@:embedded
	public function _lookup(__0:GoString):Object
		return _environment._lookup(__0);

	public function __copy__() {
		return new Checker(_conf, _ctxt, _fset, _pkg, info, _version, _nextID, _objMap, _impMap, _valids, _pkgPathMap, _seenPkgMap, _files, _imports,
			_dotImportMap, _recvTParamMap, _brokenAliases, _unionTypeSets, _mono, _firstErr, _methods, _untyped, _delayed, _objPath, _cleaners, _environment,
			_indent);
	}
}

/**
	// A bailout panic is used for early termination.
**/
@:structInit private class T_bailout {
	public function new() {}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_bailout();
	}
}

/**
	// A Context is an opaque type checking context. It may be used to share
	// identical type instances across type-checked packages or calls to
	// Instantiate. Contexts are safe for concurrent use.
	//
	// The use of a shared context does not guarantee that identical instances are
	// deduplicated in all cases.
**/
@:structInit @:using(stdgo.go.types.Types.Context_static_extension) class Context {
	public var _mu:stdgo.sync.Sync.Mutex = ({} : stdgo.sync.Sync.Mutex);
	public var _typeMap:GoMap<GoString, Slice<T_ctxtEntry>> = (null : GoMap<GoString, Slice<T_ctxtEntry>>);
	public var _nextID:GoInt = 0;
	public var _originIDs:GoMap<Type, GoInt> = (null : GoMap<Type, GoInt>);

	public function new(?_mu:stdgo.sync.Sync.Mutex, ?_typeMap:GoMap<GoString, Slice<T_ctxtEntry>>, ?_nextID:GoInt, ?_originIDs:GoMap<Type, GoInt>) {
		if (_mu != null)
			this._mu = _mu;
		if (_typeMap != null)
			this._typeMap = _typeMap;
		if (_nextID != null)
			this._nextID = _nextID;
		if (_originIDs != null)
			this._originIDs = _originIDs;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new Context(_mu, _typeMap, _nextID, _originIDs);
	}
}

@:structInit private class T_ctxtEntry {
	public var _orig:Type = (null : Type);
	public var _targs:Slice<Type> = (null : Slice<Type>);
	public var _instance:Type = (null : Type);

	public function new(?_orig:Type, ?_targs:Slice<Type>, ?_instance:Type) {
		if (_orig != null)
			this._orig = _orig;
		if (_targs != null)
			this._targs = _targs;
		if (_instance != null)
			this._instance = _instance;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_ctxtEntry(_orig, _targs, _instance);
	}
}

@:structInit @:using(stdgo.go.types.Types.T_importDecl_static_extension) private class T_importDecl {
	public var _spec:Ref<stdgo.go.ast.Ast.ImportSpec> = (null : Ref<stdgo.go.ast.Ast.ImportSpec>);

	public function new(?_spec:Ref<stdgo.go.ast.Ast.ImportSpec>) {
		if (_spec != null)
			this._spec = _spec;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_importDecl(_spec);
	}
}

@:structInit @:using(stdgo.go.types.Types.T_constDecl_static_extension) private class T_constDecl {
	public var _spec:Ref<stdgo.go.ast.Ast.ValueSpec> = (null : Ref<stdgo.go.ast.Ast.ValueSpec>);
	public var _iota:GoInt = 0;
	public var _typ:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
	public var _init:Slice<stdgo.go.ast.Ast.Expr> = (null : Slice<stdgo.go.ast.Ast.Expr>);
	public var _inherited:Bool = false;

	public function new(?_spec:Ref<stdgo.go.ast.Ast.ValueSpec>, ?_iota:GoInt, ?_typ:stdgo.go.ast.Ast.Expr, ?_init:Slice<stdgo.go.ast.Ast.Expr>,
			?_inherited:Bool) {
		if (_spec != null)
			this._spec = _spec;
		if (_iota != null)
			this._iota = _iota;
		if (_typ != null)
			this._typ = _typ;
		if (_init != null)
			this._init = _init;
		if (_inherited != null)
			this._inherited = _inherited;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_constDecl(_spec, _iota, _typ, _init, _inherited);
	}
}

@:structInit @:using(stdgo.go.types.Types.T_varDecl_static_extension) private class T_varDecl {
	public var _spec:Ref<stdgo.go.ast.Ast.ValueSpec> = (null : Ref<stdgo.go.ast.Ast.ValueSpec>);

	public function new(?_spec:Ref<stdgo.go.ast.Ast.ValueSpec>) {
		if (_spec != null)
			this._spec = _spec;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_varDecl(_spec);
	}
}

@:structInit @:using(stdgo.go.types.Types.T_typeDecl_static_extension) private class T_typeDecl {
	public var _spec:Ref<stdgo.go.ast.Ast.TypeSpec> = (null : Ref<stdgo.go.ast.Ast.TypeSpec>);

	public function new(?_spec:Ref<stdgo.go.ast.Ast.TypeSpec>) {
		if (_spec != null)
			this._spec = _spec;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_typeDecl(_spec);
	}
}

@:structInit @:using(stdgo.go.types.Types.T_funcDecl_static_extension) private class T_funcDecl {
	public var _decl:Ref<stdgo.go.ast.Ast.FuncDecl> = (null : Ref<stdgo.go.ast.Ast.FuncDecl>);

	public function new(?_decl:Ref<stdgo.go.ast.Ast.FuncDecl>) {
		if (_decl != null)
			this._decl = _decl;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_funcDecl(_decl);
	}
}

/**
	// An error_ represents a type-checking error.
	// To report an error_, call Checker.report.
**/
@:structInit @:using(stdgo.go.types.Types.T_error__static_extension) private class T_error_ {
	public var _desc:Slice<T_errorDesc> = (null : Slice<T_errorDesc>);
	public var _code:T_errorCode = ((0 : GoInt) : T_errorCode);
	public var _soft:Bool = false;

	public function new(?_desc:Slice<T_errorDesc>, ?_code:T_errorCode, ?_soft:Bool) {
		if (_desc != null)
			this._desc = _desc;
		if (_code != null)
			this._code = _code;
		if (_soft != null)
			this._soft = _soft;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_error_(_desc, _code, _soft);
	}
}

/**
	// An errorDesc describes part of a type-checking error.
**/
@:structInit private class T_errorDesc {
	public var _posn:T_positioner = (null : T_positioner);
	public var _format:GoString = "";
	public var _args:Slice<AnyInterface> = (null : Slice<AnyInterface>);

	public function new(?_posn:T_positioner, ?_format:GoString, ?_args:Slice<AnyInterface>) {
		if (_posn != null)
			this._posn = _posn;
		if (_format != null)
			this._format = _format;
		if (_args != null)
			this._args = _args;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_errorDesc(_posn, _format, _args);
	}
}

/**
	// posSpan holds a position range along with a highlighted position within that
	// range. This is used for positioning errors, with pos by convention being the
	// first position in the source where the error is known to exist, and start
	// and end defining the full span of syntax being considered when the error was
	// detected. Invariant: start <= pos < end || start == pos == end.
**/
@:structInit @:using(stdgo.go.types.Types.T_posSpan_static_extension) private class T_posSpan {
	public var _start:stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
	public var _pos:stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
	public var _end:stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);

	public function new(?_start:stdgo.go.token.Token.Pos, ?_pos:stdgo.go.token.Token.Pos, ?_end:stdgo.go.token.Token.Pos) {
		if (_start != null)
			this._start = _start;
		if (_pos != null)
			this._pos = _pos;
		if (_end != null)
			this._end = _end;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_posSpan(_start, _pos, _end);
	}
}

@:structInit @:using(stdgo.go.types.Types.T_tpWalker_static_extension) private class T_tpWalker {
	public var _seen:GoMap<Type, Bool> = (null : GoMap<Type, Bool>);
	public var _tparams:Slice<Ref<TypeParam>> = (null : Slice<Ref<TypeParam>>);

	public function new(?_seen:GoMap<Type, Bool>, ?_tparams:Slice<Ref<TypeParam>>) {
		if (_seen != null)
			this._seen = _seen;
		if (_tparams != null)
			this._tparams = _tparams;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_tpWalker(_seen, _tparams);
	}
}

@:structInit @:using(stdgo.go.types.Types.T_cycleFinder_static_extension) private class T_cycleFinder {
	public var _tparams:Slice<Ref<TypeParam>> = (null : Slice<Ref<TypeParam>>);
	public var _types:Slice<Type> = (null : Slice<Type>);
	public var _seen:GoMap<Type, Bool> = (null : GoMap<Type, Bool>);

	public function new(?_tparams:Slice<Ref<TypeParam>>, ?_types:Slice<Type>, ?_seen:GoMap<Type, Bool>) {
		if (_tparams != null)
			this._tparams = _tparams;
		if (_types != null)
			this._types = _types;
		if (_seen != null)
			this._seen = _seen;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_cycleFinder(_tparams, _types, _seen);
	}
}

/**
	// A graphNode represents a node in the object dependency graph.
	// Each node p in n.pred represents an edge p->n, and each node
	// s in n.succ represents an edge n->s; with a->b indicating that
	// a depends on b.
**/
@:structInit @:using(stdgo.go.types.Types.T_graphNode_static_extension) private class T_graphNode {
	public var _obj:T_dependency = (null : T_dependency);
	public var _pred:T_nodeSet = (null : T_nodeSet);
	public var _succ:T_nodeSet = (null : T_nodeSet);
	public var _index:GoInt = 0;
	public var _ndeps:GoInt = 0;

	public function new(?_obj:T_dependency, ?_pred:T_nodeSet, ?_succ:T_nodeSet, ?_index:GoInt, ?_ndeps:GoInt) {
		if (_obj != null)
			this._obj = _obj;
		if (_pred != null)
			this._pred = _pred;
		if (_succ != null)
			this._succ = _succ;
		if (_index != null)
			this._index = _index;
		if (_ndeps != null)
			this._ndeps = _ndeps;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_graphNode(_obj, _pred, _succ, _index, _ndeps);
	}
}

/**
	// An Interface represents an interface type.
**/
@:structInit @:using(stdgo.go.types.Types.Interface_static_extension) class Interface {
	public var _check:Ref<Checker> = (null : Ref<Checker>);
	public var _methods:Slice<Ref<Func>> = (null : Slice<Ref<Func>>);
	public var _embeddeds:Slice<Type> = (null : Slice<Type>);
	public var _embedPos:Ref<Slice<stdgo.go.token.Token.Pos>> = null;
	public var _implicit:Bool = false;
	public var _complete:Bool = false;
	public var _tset:Ref<T__TypeSet> = (null : Ref<T__TypeSet>);

	public function new(?_check:Ref<Checker>, ?_methods:Slice<Ref<Func>>, ?_embeddeds:Slice<Type>, ?_embedPos:Ref<Slice<stdgo.go.token.Token.Pos>>,
			?_implicit:Bool, ?_complete:Bool, ?_tset:Ref<T__TypeSet>) {
		if (_check != null)
			this._check = _check;
		if (_methods != null)
			this._methods = _methods;
		if (_embeddeds != null)
			this._embeddeds = _embeddeds;
		if (_embedPos != null)
			this._embedPos = _embedPos;
		if (_implicit != null)
			this._implicit = _implicit;
		if (_complete != null)
			this._complete = _complete;
		if (_tset != null)
			this._tset = _tset;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new Interface(_check, _methods, _embeddeds, _embedPos, _implicit, _complete, _tset);
	}
}

/**
	// A block tracks label declarations in a block and its enclosing blocks.
**/
@:structInit @:using(stdgo.go.types.Types.T_block_static_extension) private class T_block {
	public var _parent:Ref<T_block> = (null : Ref<T_block>);
	public var _lstmt:Ref<stdgo.go.ast.Ast.LabeledStmt> = (null : Ref<stdgo.go.ast.Ast.LabeledStmt>);
	public var _labels:GoMap<GoString, Ref<stdgo.go.ast.Ast.LabeledStmt>> = (null : GoMap<GoString, Ref<stdgo.go.ast.Ast.LabeledStmt>>);

	public function new(?_parent:Ref<T_block>, ?_lstmt:Ref<stdgo.go.ast.Ast.LabeledStmt>, ?_labels:GoMap<GoString, Ref<stdgo.go.ast.Ast.LabeledStmt>>) {
		if (_parent != null)
			this._parent = _parent;
		if (_lstmt != null)
			this._lstmt = _lstmt;
		if (_labels != null)
			this._labels = _labels;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_block(_parent, _lstmt, _labels);
	}
}

/**
	// embeddedType represents an embedded type
**/
@:structInit private class T_embeddedType {
	public var _typ:Type = (null : Type);
	public var _index:Slice<GoInt> = (null : Slice<GoInt>);
	public var _indirect:Bool = false;
	public var _multiples:Bool = false;

	public function new(?_typ:Type, ?_index:Slice<GoInt>, ?_indirect:Bool, ?_multiples:Bool) {
		if (_typ != null)
			this._typ = _typ;
		if (_index != null)
			this._index = _index;
		if (_indirect != null)
			this._indirect = _indirect;
		if (_multiples != null)
			this._multiples = _multiples;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_embeddedType(_typ, _index, _indirect, _multiples);
	}
}

@:structInit @:using(stdgo.go.types.Types.T_instanceLookup_static_extension) private class T_instanceLookup {
	public var _m:GoMap<Ref<Named>, Slice<Ref<Named>>> = (null : GoMap<Ref<Named>, Slice<Ref<Named>>>);

	public function new(?_m:GoMap<Ref<Named>, Slice<Ref<Named>>>) {
		if (_m != null)
			this._m = _m;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_instanceLookup(_m);
	}
}

/**
	// A Map represents a map type.
**/
@:structInit @:using(stdgo.go.types.Types.Map__static_extension) class Map_ {
	public var _key:Type = (null : Type);
	public var _elem:Type = (null : Type);

	public function new(?_key:Type, ?_elem:Type) {
		if (_key != null)
			this._key = _key;
		if (_elem != null)
			this._elem = _elem;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new Map_(_key, _elem);
	}
}

/**
	// A MethodSet is an ordered set of concrete or abstract (interface) methods;
	// a method is a MethodVal selection, and they are ordered by ascending m.Obj().Id().
	// The zero value for a MethodSet is a ready-to-use empty method set.
**/
@:structInit @:using(stdgo.go.types.Types.MethodSet_static_extension) class MethodSet {
	public var _list:Slice<Ref<Selection>> = (null : Slice<Ref<Selection>>);

	public function new(?_list:Slice<Ref<Selection>>) {
		if (_list != null)
			this._list = _list;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new MethodSet(_list);
	}
}

@:structInit @:using(stdgo.go.types.Types.T_monoGraph_static_extension) private class T_monoGraph {
	public var _vertices:Slice<T_monoVertex> = (null : Slice<T_monoVertex>);
	public var _edges:Slice<T_monoEdge> = (null : Slice<T_monoEdge>);

	/**
		// canon maps method receiver type parameters to their respective
		// receiver type's type parameters.
	**/
	public var _canon:GoMap<Ref<TypeParam>, Ref<TypeParam>> = (null : GoMap<Ref<TypeParam>, Ref<TypeParam>>);

	/**
		// nameIdx maps a defined type or (canonical) type parameter to its
		// vertex index.
	**/
	public var _nameIdx:GoMap<Ref<TypeName>, GoInt> = (null : GoMap<Ref<TypeName>, GoInt>);

	public function new(?_vertices:Slice<T_monoVertex>, ?_edges:Slice<T_monoEdge>, ?_canon:GoMap<Ref<TypeParam>, Ref<TypeParam>>,
			?_nameIdx:GoMap<Ref<TypeName>, GoInt>) {
		if (_vertices != null)
			this._vertices = _vertices;
		if (_edges != null)
			this._edges = _edges;
		if (_canon != null)
			this._canon = _canon;
		if (_nameIdx != null)
			this._nameIdx = _nameIdx;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_monoGraph(_vertices, _edges, _canon, _nameIdx);
	}
}

@:structInit private class T_monoVertex {
	public var _weight:GoInt = 0;
	public var _pre:GoInt = 0;
	public var _len:GoInt = 0;

	/**
		// obj is the defined type or type parameter represented by this
		// vertex.
	**/
	public var _obj:Ref<TypeName> = (null : Ref<TypeName>);

	public function new(?_weight:GoInt, ?_pre:GoInt, ?_len:GoInt, ?_obj:Ref<TypeName>) {
		if (_weight != null)
			this._weight = _weight;
		if (_pre != null)
			this._pre = _pre;
		if (_len != null)
			this._len = _len;
		if (_obj != null)
			this._obj = _obj;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_monoVertex(_weight, _pre, _len, _obj);
	}
}

@:structInit private class T_monoEdge {
	public var _dst:GoInt = 0;
	public var _src:GoInt = 0;
	public var _weight:GoInt = 0;
	public var _pos:stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
	public var _typ:Type = (null : Type);

	public function new(?_dst:GoInt, ?_src:GoInt, ?_weight:GoInt, ?_pos:stdgo.go.token.Token.Pos, ?_typ:Type) {
		if (_dst != null)
			this._dst = _dst;
		if (_src != null)
			this._src = _src;
		if (_weight != null)
			this._weight = _weight;
		if (_pos != null)
			this._pos = _pos;
		if (_typ != null)
			this._typ = _typ;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_monoEdge(_dst, _src, _weight, _pos, _typ);
	}
}

/**
	// A Named represents a named (defined) type.
**/
@:structInit @:using(stdgo.go.types.Types.Named_static_extension) class Named {
	public var _check:Ref<Checker> = (null : Ref<Checker>);
	public var _obj:Ref<TypeName> = (null : Ref<TypeName>);

	/**
		// fromRHS holds the type (on RHS of declaration) this *Named type is derived
		// from (for cycle reporting). Only used by validType, and therefore does not
		// require synchronization.
	**/
	public var _fromRHS:Type = (null : Type);

	/**
		// information for instantiated types; nil otherwise
	**/
	public var _inst:Ref<T_instance> = (null : Ref<T_instance>);

	public var _mu:stdgo.sync.Sync.Mutex = ({} : stdgo.sync.Sync.Mutex);
	public var _state_:GoUInt32 = 0;
	public var _underlying:Type = (null : Type);
	public var _tparams:Ref<TypeParamList> = (null : Ref<TypeParamList>);

	/**
		// methods declared for this type (not the method set of this type)
		// Signatures are type-checked lazily.
		// For non-instantiated types, this is a fully populated list of methods. For
		// instantiated types, methods are individually expanded when they are first
		// accessed.
	**/
	public var _methods:Slice<Ref<Func>> = (null : Slice<Ref<Func>>);

	/**
		// loader may be provided to lazily load type parameters, underlying type, and methods.
	**/
	public var _loader:Ref<Named> -> {
		var _0:Slice<Ref<TypeParam>>;
		var _1:Type;
		var _2:Slice<Ref<Func>>;
	} = null;

	public function new(?_check:Ref<Checker>, ?_obj:Ref<TypeName>, ?_fromRHS:Type, ?_inst:Ref<T_instance>, ?_mu:stdgo.sync.Sync.Mutex, ?_state_:GoUInt32,
			?_underlying:Type, ?_tparams:Ref<TypeParamList>, ?_methods:Slice<Ref<Func>>, ?_loader:Ref<Named> -> {
			var _0:Slice<Ref<TypeParam>>;
			var _1:Type;
			var _2:Slice<Ref<Func>>;
		}) {
		if (_check != null)
			this._check = _check;
		if (_obj != null)
			this._obj = _obj;
		if (_fromRHS != null)
			this._fromRHS = _fromRHS;
		if (_inst != null)
			this._inst = _inst;
		if (_mu != null)
			this._mu = _mu;
		if (_state_ != null)
			this._state_ = _state_;
		if (_underlying != null)
			this._underlying = _underlying;
		if (_tparams != null)
			this._tparams = _tparams;
		if (_methods != null)
			this._methods = _methods;
		if (_loader != null)
			this._loader = _loader;
		}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new Named(_check, _obj, _fromRHS, _inst, _mu, _state_, _underlying, _tparams, _methods, _loader);
	}
}

/**
	// instance holds information that is only necessary for instantiated named
	// types.
**/
@:structInit private class T_instance {
	public var _orig:Ref<Named> = (null : Ref<Named>);
	public var _targs:Ref<TypeList> = (null : Ref<TypeList>);
	public var _expandedMethods:GoInt = 0;
	public var _ctxt:Ref<Context> = (null : Ref<Context>);

	public function new(?_orig:Ref<Named>, ?_targs:Ref<TypeList>, ?_expandedMethods:GoInt, ?_ctxt:Ref<Context>) {
		if (_orig != null)
			this._orig = _orig;
		if (_targs != null)
			this._targs = _targs;
		if (_expandedMethods != null)
			this._expandedMethods = _expandedMethods;
		if (_ctxt != null)
			this._ctxt = _ctxt;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_instance(_orig, _targs, _expandedMethods, _ctxt);
	}
}

/**
	// An object implements the common parts of an Object.
**/
@:structInit @:using(stdgo.go.types.Types.T_object_static_extension) private class T_object {
	public var _parent:Ref<Scope> = (null : Ref<Scope>);
	public var _pos:stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
	public var _pkg:Ref<Package> = (null : Ref<Package>);
	public var _name:GoString = "";
	public var _typ:Type = (null : Type);
	public var _order_:GoUInt32 = 0;
	public var _color_:T_color = ((0 : GoUInt32) : T_color);
	public var _scopePos_:stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);

	public function new(?_parent:Ref<Scope>, ?_pos:stdgo.go.token.Token.Pos, ?_pkg:Ref<Package>, ?_name:GoString, ?_typ:Type, ?_order_:GoUInt32,
			?_color_:T_color, ?_scopePos_:stdgo.go.token.Token.Pos) {
		if (_parent != null)
			this._parent = _parent;
		if (_pos != null)
			this._pos = _pos;
		if (_pkg != null)
			this._pkg = _pkg;
		if (_name != null)
			this._name = _name;
		if (_typ != null)
			this._typ = _typ;
		if (_order_ != null)
			this._order_ = _order_;
		if (_color_ != null)
			this._color_ = _color_;
		if (_scopePos_ != null)
			this._scopePos_ = _scopePos_;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_object(_parent, _pos, _pkg, _name, _typ, _order_, _color_, _scopePos_);
	}
}

/**
	// A PkgName represents an imported Go package.
	// PkgNames don't have a type.
**/
@:structInit @:using(stdgo.go.types.Types.PkgName_static_extension) class PkgName {
	@:embedded
	public var _object:T_object = ({} : T_object);
	public var _imported:Ref<Package> = (null : Ref<Package>);
	public var _used:Bool = false;

	public function new(?_object:T_object, ?_imported:Ref<Package>, ?_used:Bool) {
		if (_object != null)
			this._object = _object;
		if (_imported != null)
			this._imported = _imported;
		if (_used != null)
			this._used = _used;
	}

	public function __underlying__()
		return Go.toInterface(this);

	@:embedded
	public function exported():Bool
		return _object.exported();

	@:embedded
	public function id():GoString
		return _object.id();

	@:embedded
	public function name():GoString
		return _object.name();

	@:embedded
	public function parent():Ref<Scope>
		return _object.parent();

	@:embedded
	public function pkg():Ref<Package>
		return _object.pkg();

	@:embedded
	public function pos():stdgo.go.token.Token.Pos
		return _object.pos();

	@:embedded
	public function type():Type
		return _object.type();

	@:embedded
	public function _color():T_color
		return _object._color();

	@:embedded
	public function _order():GoUInt32
		return _object._order();

	@:embedded
	public function _sameId(_pkg_:Ref<Package>, _name_:GoString):Bool
		return _object._sameId(_pkg_, _name_);

	@:embedded
	public function _scopePos():stdgo.go.token.Token.Pos
		return _object._scopePos();

	@:embedded
	public function _setColor(__0:T_color)
		_object._setColor(__0);

	@:embedded
	public function _setOrder(__0:GoUInt32)
		_object._setOrder(__0);

	@:embedded
	public function _setParent(__0:Ref<Scope>)
		_object._setParent(__0);

	@:embedded
	public function _setScopePos(_p:stdgo.go.token.Token.Pos)
		_object._setScopePos(_p);

	@:embedded
	public function _setType(__0:Type)
		_object._setType(__0);

	public function __copy__() {
		return new PkgName(_object, _imported, _used);
	}
}

/**
	// A Const represents a declared constant.
**/
@:structInit @:using(stdgo.go.types.Types.Const_static_extension) class Const {
	@:embedded
	public var _object:T_object = ({} : T_object);
	public var _val:stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);

	public function new(?_object:T_object, ?_val:stdgo.go.constant.Constant.Value) {
		if (_object != null)
			this._object = _object;
		if (_val != null)
			this._val = _val;
	}

	public function __underlying__()
		return Go.toInterface(this);

	@:embedded
	public function exported():Bool
		return _object.exported();

	@:embedded
	public function id():GoString
		return _object.id();

	@:embedded
	public function name():GoString
		return _object.name();

	@:embedded
	public function parent():Ref<Scope>
		return _object.parent();

	@:embedded
	public function pkg():Ref<Package>
		return _object.pkg();

	@:embedded
	public function pos():stdgo.go.token.Token.Pos
		return _object.pos();

	@:embedded
	public function type():Type
		return _object.type();

	@:embedded
	public function _color():T_color
		return _object._color();

	@:embedded
	public function _order():GoUInt32
		return _object._order();

	@:embedded
	public function _sameId(_pkg_:Ref<Package>, _name_:GoString):Bool
		return _object._sameId(_pkg_, _name_);

	@:embedded
	public function _scopePos():stdgo.go.token.Token.Pos
		return _object._scopePos();

	@:embedded
	public function _setColor(__0:T_color)
		_object._setColor(__0);

	@:embedded
	public function _setOrder(__0:GoUInt32)
		_object._setOrder(__0);

	@:embedded
	public function _setParent(__0:Ref<Scope>)
		_object._setParent(__0);

	@:embedded
	public function _setScopePos(_p:stdgo.go.token.Token.Pos)
		_object._setScopePos(_p);

	@:embedded
	public function _setType(__0:Type)
		_object._setType(__0);

	public function __copy__() {
		return new Const(_object, _val);
	}
}

/**
	// A TypeName represents a name for a (defined or alias) type.
**/
@:structInit @:using(stdgo.go.types.Types.TypeName_static_extension) class TypeName {
	@:embedded
	public var _object:T_object = ({} : T_object);

	public function new(?_object:T_object) {
		if (_object != null)
			this._object = _object;
	}

	public function __underlying__()
		return Go.toInterface(this);

	@:embedded
	public function exported():Bool
		return _object.exported();

	@:embedded
	public function id():GoString
		return _object.id();

	@:embedded
	public function name():GoString
		return _object.name();

	@:embedded
	public function parent():Ref<Scope>
		return _object.parent();

	@:embedded
	public function pkg():Ref<Package>
		return _object.pkg();

	@:embedded
	public function pos():stdgo.go.token.Token.Pos
		return _object.pos();

	@:embedded
	public function type():Type
		return _object.type();

	@:embedded
	public function _color():T_color
		return _object._color();

	@:embedded
	public function _order():GoUInt32
		return _object._order();

	@:embedded
	public function _sameId(_pkg_:Ref<Package>, _name_:GoString):Bool
		return _object._sameId(_pkg_, _name_);

	@:embedded
	public function _scopePos():stdgo.go.token.Token.Pos
		return _object._scopePos();

	@:embedded
	public function _setColor(__0:T_color)
		_object._setColor(__0);

	@:embedded
	public function _setOrder(__0:GoUInt32)
		_object._setOrder(__0);

	@:embedded
	public function _setParent(__0:Ref<Scope>)
		_object._setParent(__0);

	@:embedded
	public function _setScopePos(_p:stdgo.go.token.Token.Pos)
		_object._setScopePos(_p);

	@:embedded
	public function _setType(__0:Type)
		_object._setType(__0);

	public function __copy__() {
		return new TypeName(_object);
	}
}

/**
	// A Variable represents a declared variable (including function parameters and results, and struct fields).
**/
@:structInit @:using(stdgo.go.types.Types.Var_static_extension) class Var {
	@:embedded
	public var _object:T_object = ({} : T_object);
	public var _embedded:Bool = false;
	public var _isField:Bool = false;
	public var _used:Bool = false;
	public var _origin:Ref<Var> = (null : Ref<Var>);

	public function new(?_object:T_object, ?_embedded:Bool, ?_isField:Bool, ?_used:Bool, ?_origin:Ref<Var>) {
		if (_object != null)
			this._object = _object;
		if (_embedded != null)
			this._embedded = _embedded;
		if (_isField != null)
			this._isField = _isField;
		if (_used != null)
			this._used = _used;
		if (_origin != null)
			this._origin = _origin;
	}

	public function __underlying__()
		return Go.toInterface(this);

	@:embedded
	public function exported():Bool
		return _object.exported();

	@:embedded
	public function id():GoString
		return _object.id();

	@:embedded
	public function name():GoString
		return _object.name();

	@:embedded
	public function parent():Ref<Scope>
		return _object.parent();

	@:embedded
	public function pkg():Ref<Package>
		return _object.pkg();

	@:embedded
	public function pos():stdgo.go.token.Token.Pos
		return _object.pos();

	@:embedded
	public function type():Type
		return _object.type();

	@:embedded
	public function _color():T_color
		return _object._color();

	@:embedded
	public function _order():GoUInt32
		return _object._order();

	@:embedded
	public function _sameId(_pkg_:Ref<Package>, _name_:GoString):Bool
		return _object._sameId(_pkg_, _name_);

	@:embedded
	public function _scopePos():stdgo.go.token.Token.Pos
		return _object._scopePos();

	@:embedded
	public function _setColor(__0:T_color)
		_object._setColor(__0);

	@:embedded
	public function _setOrder(__0:GoUInt32)
		_object._setOrder(__0);

	@:embedded
	public function _setParent(__0:Ref<Scope>)
		_object._setParent(__0);

	@:embedded
	public function _setScopePos(_p:stdgo.go.token.Token.Pos)
		_object._setScopePos(_p);

	@:embedded
	public function _setType(__0:Type)
		_object._setType(__0);

	public function __copy__() {
		return new Var(_object, _embedded, _isField, _used, _origin);
	}
}

/**
	// A Func represents a declared function, concrete method, or abstract
	// (interface) method. Its Type() is always a *Signature.
	// An abstract method may belong to many interfaces due to embedding.
**/
@:structInit @:using(stdgo.go.types.Types.Func_static_extension) class Func {
	@:embedded
	public var _object:T_object = ({} : T_object);
	public var _hasPtrRecv_:Bool = false;
	public var _origin:Ref<Func> = (null : Ref<Func>);

	public function new(?_object:T_object, ?_hasPtrRecv_:Bool, ?_origin:Ref<Func>) {
		if (_object != null)
			this._object = _object;
		if (_hasPtrRecv_ != null)
			this._hasPtrRecv_ = _hasPtrRecv_;
		if (_origin != null)
			this._origin = _origin;
	}

	public function __underlying__()
		return Go.toInterface(this);

	@:embedded
	public function exported():Bool
		return _object.exported();

	@:embedded
	public function id():GoString
		return _object.id();

	@:embedded
	public function name():GoString
		return _object.name();

	@:embedded
	public function parent():Ref<Scope>
		return _object.parent();

	@:embedded
	public function pkg():Ref<Package>
		return _object.pkg();

	@:embedded
	public function pos():stdgo.go.token.Token.Pos
		return _object.pos();

	@:embedded
	public function type():Type
		return _object.type();

	@:embedded
	public function _color():T_color
		return _object._color();

	@:embedded
	public function _order():GoUInt32
		return _object._order();

	@:embedded
	public function _sameId(_pkg_:Ref<Package>, _name_:GoString):Bool
		return _object._sameId(_pkg_, _name_);

	@:embedded
	public function _scopePos():stdgo.go.token.Token.Pos
		return _object._scopePos();

	@:embedded
	public function _setColor(__0:T_color)
		_object._setColor(__0);

	@:embedded
	public function _setOrder(__0:GoUInt32)
		_object._setOrder(__0);

	@:embedded
	public function _setParent(__0:Ref<Scope>)
		_object._setParent(__0);

	@:embedded
	public function _setScopePos(_p:stdgo.go.token.Token.Pos)
		_object._setScopePos(_p);

	@:embedded
	public function _setType(__0:Type)
		_object._setType(__0);

	public function __copy__() {
		return new Func(_object, _hasPtrRecv_, _origin);
	}
}

/**
	// A Label represents a declared label.
	// Labels don't have a type.
**/
@:structInit @:using(stdgo.go.types.Types.Label_static_extension) class Label {
	@:embedded
	public var _object:T_object = ({} : T_object);
	public var _used:Bool = false;

	public function new(?_object:T_object, ?_used:Bool) {
		if (_object != null)
			this._object = _object;
		if (_used != null)
			this._used = _used;
	}

	public function __underlying__()
		return Go.toInterface(this);

	@:embedded
	public function exported():Bool
		return _object.exported();

	@:embedded
	public function id():GoString
		return _object.id();

	@:embedded
	public function name():GoString
		return _object.name();

	@:embedded
	public function parent():Ref<Scope>
		return _object.parent();

	@:embedded
	public function pkg():Ref<Package>
		return _object.pkg();

	@:embedded
	public function pos():stdgo.go.token.Token.Pos
		return _object.pos();

	@:embedded
	public function type():Type
		return _object.type();

	@:embedded
	public function _color():T_color
		return _object._color();

	@:embedded
	public function _order():GoUInt32
		return _object._order();

	@:embedded
	public function _sameId(_pkg_:Ref<Package>, _name_:GoString):Bool
		return _object._sameId(_pkg_, _name_);

	@:embedded
	public function _scopePos():stdgo.go.token.Token.Pos
		return _object._scopePos();

	@:embedded
	public function _setColor(__0:T_color)
		_object._setColor(__0);

	@:embedded
	public function _setOrder(__0:GoUInt32)
		_object._setOrder(__0);

	@:embedded
	public function _setParent(__0:Ref<Scope>)
		_object._setParent(__0);

	@:embedded
	public function _setScopePos(_p:stdgo.go.token.Token.Pos)
		_object._setScopePos(_p);

	@:embedded
	public function _setType(__0:Type)
		_object._setType(__0);

	public function __copy__() {
		return new Label(_object, _used);
	}
}

/**
	// A Builtin represents a built-in function.
	// Builtins don't have a valid type.
**/
@:structInit @:using(stdgo.go.types.Types.Builtin_static_extension) class Builtin {
	@:embedded
	public var _object:T_object = ({} : T_object);
	public var _id:T_builtinId = ((0 : GoInt) : T_builtinId);

	public function new(?_object:T_object, ?_id:T_builtinId) {
		if (_object != null)
			this._object = _object;
		if (_id != null)
			this._id = _id;
	}

	public function __underlying__()
		return Go.toInterface(this);

	@:embedded
	public function exported():Bool
		return _object.exported();

	@:embedded
	public function id():GoString
		return _object.id();

	@:embedded
	public function name():GoString
		return _object.name();

	@:embedded
	public function parent():Ref<Scope>
		return _object.parent();

	@:embedded
	public function pkg():Ref<Package>
		return _object.pkg();

	@:embedded
	public function pos():stdgo.go.token.Token.Pos
		return _object.pos();

	@:embedded
	public function type():Type
		return _object.type();

	@:embedded
	public function _color():T_color
		return _object._color();

	@:embedded
	public function _order():GoUInt32
		return _object._order();

	@:embedded
	public function _sameId(_pkg_:Ref<Package>, _name_:GoString):Bool
		return _object._sameId(_pkg_, _name_);

	@:embedded
	public function _scopePos():stdgo.go.token.Token.Pos
		return _object._scopePos();

	@:embedded
	public function _setColor(__0:T_color)
		_object._setColor(__0);

	@:embedded
	public function _setOrder(__0:GoUInt32)
		_object._setOrder(__0);

	@:embedded
	public function _setParent(__0:Ref<Scope>)
		_object._setParent(__0);

	@:embedded
	public function _setScopePos(_p:stdgo.go.token.Token.Pos)
		_object._setScopePos(_p);

	@:embedded
	public function _setType(__0:Type)
		_object._setType(__0);

	public function __copy__() {
		return new Builtin(_object, _id);
	}
}

/**
	// Nil represents the predeclared value nil.
**/
@:structInit @:using(stdgo.go.types.Types.Nil_static_extension) class Nil {
	@:embedded
	public var _object:T_object = ({} : T_object);

	public function new(?_object:T_object) {
		if (_object != null)
			this._object = _object;
	}

	public function __underlying__()
		return Go.toInterface(this);

	@:embedded
	public function exported():Bool
		return _object.exported();

	@:embedded
	public function id():GoString
		return _object.id();

	@:embedded
	public function name():GoString
		return _object.name();

	@:embedded
	public function parent():Ref<Scope>
		return _object.parent();

	@:embedded
	public function pkg():Ref<Package>
		return _object.pkg();

	@:embedded
	public function pos():stdgo.go.token.Token.Pos
		return _object.pos();

	@:embedded
	public function type():Type
		return _object.type();

	@:embedded
	public function _color():T_color
		return _object._color();

	@:embedded
	public function _order():GoUInt32
		return _object._order();

	@:embedded
	public function _sameId(_pkg_:Ref<Package>, _name_:GoString):Bool
		return _object._sameId(_pkg_, _name_);

	@:embedded
	public function _scopePos():stdgo.go.token.Token.Pos
		return _object._scopePos();

	@:embedded
	public function _setColor(__0:T_color)
		_object._setColor(__0);

	@:embedded
	public function _setOrder(__0:GoUInt32)
		_object._setOrder(__0);

	@:embedded
	public function _setParent(__0:Ref<Scope>)
		_object._setParent(__0);

	@:embedded
	public function _setScopePos(_p:stdgo.go.token.Token.Pos)
		_object._setScopePos(_p);

	@:embedded
	public function _setType(__0:Type)
		_object._setType(__0);

	public function __copy__() {
		return new Nil(_object);
	}
}

/**
	// An operand represents an intermediate value during type checking.
	// Operands have an (addressing) mode, the expression evaluating to
	// the operand, the operand's type, a value for constants, and an id
	// for built-in functions.
	// The zero value of operand is a ready to use invalid operand.
**/
@:structInit @:using(stdgo.go.types.Types.T_operand_static_extension) private class T_operand {
	public var _mode:T_operandMode = ((0 : GoUInt8) : T_operandMode);
	public var _expr:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
	public var _typ:Type = (null : Type);
	public var _val:stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
	public var _id:T_builtinId = ((0 : GoInt) : T_builtinId);

	public function new(?_mode:T_operandMode, ?_expr:stdgo.go.ast.Ast.Expr, ?_typ:Type, ?_val:stdgo.go.constant.Constant.Value, ?_id:T_builtinId) {
		if (_mode != null)
			this._mode = _mode;
		if (_expr != null)
			this._expr = _expr;
		if (_typ != null)
			this._typ = _typ;
		if (_val != null)
			this._val = _val;
		if (_id != null)
			this._id = _id;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_operand(_mode, _expr, _typ, _val, _id);
	}
}

/**
	// A Package describes a Go package.
**/
@:structInit @:using(stdgo.go.types.Types.Package_static_extension) class Package {
	public var _path:GoString = "";
	public var _name:GoString = "";
	public var _scope:Ref<Scope> = (null : Ref<Scope>);
	public var _complete:Bool = false;
	public var _imports:Slice<Ref<Package>> = (null : Slice<Ref<Package>>);
	public var _fake:Bool = false;
	public var _cgo:Bool = false;

	public function new(?_path:GoString, ?_name:GoString, ?_scope:Ref<Scope>, ?_complete:Bool, ?_imports:Slice<Ref<Package>>, ?_fake:Bool, ?_cgo:Bool) {
		if (_path != null)
			this._path = _path;
		if (_name != null)
			this._name = _name;
		if (_scope != null)
			this._scope = _scope;
		if (_complete != null)
			this._complete = _complete;
		if (_imports != null)
			this._imports = _imports;
		if (_fake != null)
			this._fake = _fake;
		if (_cgo != null)
			this._cgo = _cgo;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new Package(_path, _name, _scope, _complete, _imports, _fake, _cgo);
	}
}

/**
	// A Pointer represents a pointer type.
**/
@:structInit @:using(stdgo.go.types.Types.Pointer__static_extension) class Pointer_ {
	public var _base:Type = (null : Type);

	public function new(?_base:Type) {
		if (_base != null)
			this._base = _base;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new Pointer_(_base);
	}
}

/**
	// An ifacePair is a node in a stack of interface type pairs compared for identity.
**/
@:structInit @:using(stdgo.go.types.Types.T_ifacePair_static_extension) private class T_ifacePair {
	public var _x:Ref<Interface> = (null : Ref<Interface>);
	public var _y:Ref<Interface> = (null : Ref<Interface>);
	public var _prev:Ref<T_ifacePair> = (null : Ref<T_ifacePair>);

	public function new(?_x:Ref<Interface>, ?_y:Ref<Interface>, ?_prev:Ref<T_ifacePair>) {
		if (_x != null)
			this._x = _x;
		if (_y != null)
			this._y = _y;
		if (_prev != null)
			this._prev = _prev;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_ifacePair(_x, _y, _prev);
	}
}

/**
	// A declInfo describes a package-level const, type, var, or func declaration.
**/
@:structInit @:using(stdgo.go.types.Types.T_declInfo_static_extension) private class T_declInfo {
	public var _file:Ref<Scope> = (null : Ref<Scope>);
	public var _lhs:Slice<Ref<Var>> = (null : Slice<Ref<Var>>);
	public var _vtyp:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
	public var _init:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
	public var _inherited:Bool = false;
	public var _tdecl:Ref<stdgo.go.ast.Ast.TypeSpec> = (null : Ref<stdgo.go.ast.Ast.TypeSpec>);
	public var _fdecl:Ref<stdgo.go.ast.Ast.FuncDecl> = (null : Ref<stdgo.go.ast.Ast.FuncDecl>);

	/**
		// The deps field tracks initialization expression dependencies.
	**/
	public var _deps:GoMap<Object, Bool> = (null : GoMap<Object, Bool>);

	public function new(?_file:Ref<Scope>, ?_lhs:Slice<Ref<Var>>, ?_vtyp:stdgo.go.ast.Ast.Expr, ?_init:stdgo.go.ast.Ast.Expr, ?_inherited:Bool,
			?_tdecl:Ref<stdgo.go.ast.Ast.TypeSpec>, ?_fdecl:Ref<stdgo.go.ast.Ast.FuncDecl>, ?_deps:GoMap<Object, Bool>) {
		if (_file != null)
			this._file = _file;
		if (_lhs != null)
			this._lhs = _lhs;
		if (_vtyp != null)
			this._vtyp = _vtyp;
		if (_init != null)
			this._init = _init;
		if (_inherited != null)
			this._inherited = _inherited;
		if (_tdecl != null)
			this._tdecl = _tdecl;
		if (_fdecl != null)
			this._fdecl = _fdecl;
		if (_deps != null)
			this._deps = _deps;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_declInfo(_file, _lhs, _vtyp, _init, _inherited, _tdecl, _fdecl, _deps);
	}
}

/**
	// A Scope maintains a set of objects and links to its containing
	// (parent) and contained (children) scopes. Objects may be inserted
	// and looked up by name. The zero value for Scope is a ready-to-use
	// empty scope.
**/
@:structInit @:using(stdgo.go.types.Types.Scope_static_extension) class Scope {
	public var _parent:Ref<Scope> = (null : Ref<Scope>);
	public var _children:Slice<Ref<Scope>> = (null : Slice<Ref<Scope>>);
	public var _number:GoInt = 0;
	public var _elems:GoMap<GoString, Object> = (null : GoMap<GoString, Object>);
	public var _pos:stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
	public var _end:stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
	public var _comment:GoString = "";
	public var _isFunc:Bool = false;

	public function new(?_parent:Ref<Scope>, ?_children:Slice<Ref<Scope>>, ?_number:GoInt, ?_elems:GoMap<GoString, Object>, ?_pos:stdgo.go.token.Token.Pos,
			?_end:stdgo.go.token.Token.Pos, ?_comment:GoString, ?_isFunc:Bool) {
		if (_parent != null)
			this._parent = _parent;
		if (_children != null)
			this._children = _children;
		if (_number != null)
			this._number = _number;
		if (_elems != null)
			this._elems = _elems;
		if (_pos != null)
			this._pos = _pos;
		if (_end != null)
			this._end = _end;
		if (_comment != null)
			this._comment = _comment;
		if (_isFunc != null)
			this._isFunc = _isFunc;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new Scope(_parent, _children, _number, _elems, _pos, _end, _comment, _isFunc);
	}
}

/**
	// A lazyObject represents an imported Object that has not been fully
	// resolved yet by its importer.
**/
@:structInit @:using(stdgo.go.types.Types.T_lazyObject_static_extension) private class T_lazyObject {
	public var _parent:Ref<Scope> = (null : Ref<Scope>);
	public var _resolve:() -> Object = null;
	public var _obj:Object = (null : Object);
	public var _once:stdgo.sync.Sync.Once = ({} : stdgo.sync.Sync.Once);

	public function new(?_parent:Ref<Scope>, ?_resolve:() -> Object, ?_obj:Object, ?_once:stdgo.sync.Sync.Once) {
		if (_parent != null)
			this._parent = _parent;
		if (_resolve != null)
			this._resolve = _resolve;
		if (_obj != null)
			this._obj = _obj;
		if (_once != null)
			this._once = _once;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_lazyObject(_parent, _resolve, _obj, _once);
	}
}

/**
	// A Selection describes a selector expression x.f.
	// For the declarations:
	//
	//	type T struct{ x int; E }
	//	type E struct{}
	//	func (e E) m() {}
	//	var p *T
	//
	// the following relations exist:
	//
	//	Selector    Kind          Recv    Obj    Type       Index     Indirect
	//
	//	p.x         FieldVal      T       x      int        {0}       true
	//	p.m         MethodVal     *T      m      func()     {1, 0}    true
	//	T.m         MethodExpr    T       m      func(T)    {1, 0}    false
**/
@:structInit @:using(stdgo.go.types.Types.Selection_static_extension) class Selection {
	public var _kind:SelectionKind = ((0 : GoInt) : SelectionKind);
	public var _recv:Type = (null : Type);
	public var _obj:Object = (null : Object);
	public var _index:Slice<GoInt> = (null : Slice<GoInt>);
	public var _indirect:Bool = false;

	public function new(?_kind:SelectionKind, ?_recv:Type, ?_obj:Object, ?_index:Slice<GoInt>, ?_indirect:Bool) {
		if (_kind != null)
			this._kind = _kind;
		if (_recv != null)
			this._recv = _recv;
		if (_obj != null)
			this._obj = _obj;
		if (_index != null)
			this._index = _index;
		if (_indirect != null)
			this._indirect = _indirect;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new Selection(_kind, _recv, _obj, _index, _indirect);
	}
}

/**
	// A Signature represents a (non-builtin) function or method type.
	// The receiver is ignored when comparing signatures for identity.
**/
@:structInit @:using(stdgo.go.types.Types.Signature_static_extension) class Signature {
	/**
		// We need to keep the scope in Signature (rather than passing it around
		// and store it in the Func Object) because when type-checking a function
		// literal we call the general type checker which returns a general Type.
		// We then unpack the *Signature and use the scope for the literal body.
	**/
	public var _rparams:Ref<TypeParamList> = (null : Ref<TypeParamList>);

	public var _tparams:Ref<TypeParamList> = (null : Ref<TypeParamList>);
	public var _scope:Ref<Scope> = (null : Ref<Scope>);
	public var _recv:Ref<Var> = (null : Ref<Var>);
	public var _params:Ref<Tuple> = (null : Ref<Tuple>);
	public var _results:Ref<Tuple> = (null : Ref<Tuple>);
	public var _variadic:Bool = false;

	public function new(?_rparams:Ref<TypeParamList>, ?_tparams:Ref<TypeParamList>, ?_scope:Ref<Scope>, ?_recv:Ref<Var>, ?_params:Ref<Tuple>,
			?_results:Ref<Tuple>, ?_variadic:Bool) {
		if (_rparams != null)
			this._rparams = _rparams;
		if (_tparams != null)
			this._tparams = _tparams;
		if (_scope != null)
			this._scope = _scope;
		if (_recv != null)
			this._recv = _recv;
		if (_params != null)
			this._params = _params;
		if (_results != null)
			this._results = _results;
		if (_variadic != null)
			this._variadic = _variadic;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new Signature(_rparams, _tparams, _scope, _recv, _params, _results, _variadic);
	}
}

/**
	// StdSizes is a convenience type for creating commonly used Sizes.
	// It makes the following simplifying assumptions:
	//
	//   - The size of explicitly sized basic types (int16, etc.) is the
	//     specified size.
	//   - The size of strings and interfaces is 2*WordSize.
	//   - The size of slices is 3*WordSize.
	//   - The size of an array of n elements corresponds to the size of
	//     a struct of n consecutive fields of the array's element type.
	//   - The size of a struct is the offset of the last field plus that
	//     field's size. As with all element types, if the struct is used
	//     in an array its size must first be aligned to a multiple of the
	//     struct's alignment.
	//   - All other types have size WordSize.
	//   - Arrays and structs are aligned per spec definition; all other
	//     types are naturally aligned with a maximum alignment MaxAlign.
	//
	// *StdSizes implements Sizes.
**/
@:structInit @:using(stdgo.go.types.Types.StdSizes_static_extension) class StdSizes {
	public var wordSize:GoInt64 = 0;
	public var maxAlign:GoInt64 = 0;

	public function new(?wordSize:GoInt64, ?maxAlign:GoInt64) {
		if (wordSize != null)
			this.wordSize = wordSize;
		if (maxAlign != null)
			this.maxAlign = maxAlign;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new StdSizes(wordSize, maxAlign);
	}
}

/**
	// A Slice represents a slice type.
**/
@:structInit @:using(stdgo.go.types.Types.Slice__static_extension) class Slice_ {
	public var _elem:Type = (null : Type);

	public function new(?_elem:Type) {
		if (_elem != null)
			this._elem = _elem;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new Slice_(_elem);
	}
}

/**
	// A valueMap maps a case value (of a basic Go type) to a list of positions
	// where the same case value appeared, together with the corresponding case
	// types.
	// Since two case values may have the same "underlying" value but different
	// types we need to also check the value's types (e.g., byte(1) vs myByte(1))
	// when the switch expression is of interface type.
**/
@:structInit private class T_valueType {
	public var _pos:stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
	public var _typ:Type = (null : Type);

	public function new(?_pos:stdgo.go.token.Token.Pos, ?_typ:Type) {
		if (_pos != null)
			this._pos = _pos;
		if (_typ != null)
			this._typ = _typ;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_valueType(_pos, _typ);
	}
}

/**
	// A Struct represents a struct type.
**/
@:structInit @:using(stdgo.go.types.Types.Struct_static_extension) class Struct {
	public var _fields:Slice<Ref<Var>> = (null : Slice<Ref<Var>>);
	public var _tags:Slice<GoString> = (null : Slice<GoString>);

	public function new(?_fields:Slice<Ref<Var>>, ?_tags:Slice<GoString>) {
		if (_fields != null)
			this._fields = _fields;
		if (_tags != null)
			this._tags = _tags;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new Struct(_fields, _tags);
	}
}

@:structInit @:using(stdgo.go.types.Types.T_subster_static_extension) private class T_subster {
	public var _pos:stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
	public var _smap:T_substMap = (null : T_substMap);
	public var _check:Ref<Checker> = (null : Ref<Checker>);
	public var _expanding:Ref<Named> = (null : Ref<Named>);
	public var _ctxt:Ref<Context> = (null : Ref<Context>);

	public function new(?_pos:stdgo.go.token.Token.Pos, ?_smap:T_substMap, ?_check:Ref<Checker>, ?_expanding:Ref<Named>, ?_ctxt:Ref<Context>) {
		if (_pos != null)
			this._pos = _pos;
		if (_smap != null)
			this._smap = _smap;
		if (_check != null)
			this._check = _check;
		if (_expanding != null)
			this._expanding = _expanding;
		if (_ctxt != null)
			this._ctxt = _ctxt;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_subster(_pos, _smap, _check, _expanding, _ctxt);
	}
}

/**
	// A Tuple represents an ordered list of variables; a nil *Tuple is a valid (empty) tuple.
	// Tuples are used as components of signatures and to represent the type of multiple
	// assignments; they are not first class types of Go.
**/
@:structInit @:using(stdgo.go.types.Types.Tuple_static_extension) class Tuple {
	public var _vars:Slice<Ref<Var>> = (null : Slice<Ref<Var>>);

	public function new(?_vars:Slice<Ref<Var>>) {
		if (_vars != null)
			this._vars = _vars;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new Tuple(_vars);
	}
}

/**
	// TypeParamList holds a list of type parameters.
**/
@:structInit @:using(stdgo.go.types.Types.TypeParamList_static_extension) class TypeParamList {
	public var _tparams:Slice<Ref<TypeParam>> = (null : Slice<Ref<TypeParam>>);

	public function new(?_tparams:Slice<Ref<TypeParam>>) {
		if (_tparams != null)
			this._tparams = _tparams;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new TypeParamList(_tparams);
	}
}

/**
	// TypeList holds a list of types.
**/
@:structInit @:using(stdgo.go.types.Types.TypeList_static_extension) class TypeList {
	public var _types:Slice<Type> = (null : Slice<Type>);

	public function new(?_types:Slice<Type>) {
		if (_types != null)
			this._types = _types;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new TypeList(_types);
	}
}

/**
	// A TypeParam represents a type parameter type.
**/
@:structInit @:using(stdgo.go.types.Types.TypeParam_static_extension) class TypeParam {
	public var _check:Ref<Checker> = (null : Ref<Checker>);
	public var _id:GoUInt64 = 0;
	public var _obj:Ref<TypeName> = (null : Ref<TypeName>);
	public var _index:GoInt = 0;
	public var _bound:Type = (null : Type);

	public function new(?_check:Ref<Checker>, ?_id:GoUInt64, ?_obj:Ref<TypeName>, ?_index:GoInt, ?_bound:Type) {
		if (_check != null)
			this._check = _check;
		if (_id != null)
			this._id = _id;
		if (_obj != null)
			this._obj = _obj;
		if (_index != null)
			this._index = _index;
		if (_bound != null)
			this._bound = _bound;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new TypeParam(_check, _id, _obj, _index, _bound);
	}
}

/**
	// A _TypeSet represents the type set of an interface.
	// Because of existing language restrictions, methods can be "factored out"
	// from the terms. The actual type set is the intersection of the type set
	// implied by the methods and the type set described by the terms and the
	// comparable bit. To test whether a type is included in a type set
	// ("implements" relation), the type must implement all methods _and_ be
	// an element of the type set described by the terms and the comparable bit.
	// If the term list describes the set of all types and comparable is true,
	// only comparable types are meant; in all other cases comparable is false.
**/
@:structInit @:using(stdgo.go.types.Types.T__TypeSet_static_extension) private class T__TypeSet {
	public var _methods:Slice<Ref<Func>> = (null : Slice<Ref<Func>>);
	public var _terms:T_termlist = new T_termlist(0, 0);
	public var _comparable:Bool = false;

	public function new(?_methods:Slice<Ref<Func>>, ?_terms:T_termlist, ?_comparable:Bool) {
		if (_methods != null)
			this._methods = _methods;
		if (_terms != null)
			this._terms = _terms;
		if (_comparable != null)
			this._comparable = _comparable;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T__TypeSet(_methods, _terms, _comparable);
	}
}

@:structInit @:using(stdgo.go.types.Types.T_typeWriter_static_extension) private class T_typeWriter {
	public var _buf:Ref<stdgo.bytes.Bytes.Buffer> = (null : Ref<stdgo.bytes.Bytes.Buffer>);
	public var _seen:GoMap<Type, Bool> = (null : GoMap<Type, Bool>);
	public var _qf:Qualifier = (null : Qualifier);
	public var _ctxt:Ref<Context> = (null : Ref<Context>);
	public var _tparams:Ref<TypeParamList> = (null : Ref<TypeParamList>);
	public var _debug:Bool = false;

	public function new(?_buf:Ref<stdgo.bytes.Bytes.Buffer>, ?_seen:GoMap<Type, Bool>, ?_qf:Qualifier, ?_ctxt:Ref<Context>, ?_tparams:Ref<TypeParamList>,
			?_debug:Bool) {
		if (_buf != null)
			this._buf = _buf;
		if (_seen != null)
			this._seen = _seen;
		if (_qf != null)
			this._qf = _qf;
		if (_ctxt != null)
			this._ctxt = _ctxt;
		if (_tparams != null)
			this._tparams = _tparams;
		if (_debug != null)
			this._debug = _debug;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_typeWriter(_buf, _seen, _qf, _ctxt, _tparams, _debug);
	}
}

/**
	// A term describes elementary type sets:
	//
	//	 ∅:  (*term)(nil)     == ∅                      // set of no types (empty set)
	//	 𝓤:  &term{}          == 𝓤                      // set of all types (𝓤niverse)
	//	 T:  &term{false, T}  == {T}                    // set of type T
	//	~t:  &term{true, t}   == {t' | under(t') == t}  // set of types with underlying type t
**/
@:structInit @:using(stdgo.go.types.Types.T_term_static_extension) private class T_term {
	public var _tilde:Bool = false;
	public var _typ:Type = (null : Type);

	public function new(?_tilde:Bool, ?_typ:Type) {
		if (_tilde != null)
			this._tilde = _tilde;
		if (_typ != null)
			this._typ = _typ;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_term(_tilde, _typ);
	}
}

/**
	// A unifier maintains the current type parameters for x and y
	// and the respective types inferred for each type parameter.
	// A unifier is created by calling newUnifier.
**/
@:structInit @:using(stdgo.go.types.Types.T_unifier_static_extension) private class T_unifier {
	public var _exact:Bool = false;
	public var _x:T_tparamsList = ({} : T_tparamsList);
	public var _y:T_tparamsList = ({} : T_tparamsList);
	public var _types:Slice<Type> = (null : Slice<Type>);
	public var _depth:GoInt = 0;

	public function new(?_exact:Bool, ?_x:T_tparamsList, ?_y:T_tparamsList, ?_types:Slice<Type>, ?_depth:GoInt) {
		if (_exact != null)
			this._exact = _exact;
		if (_x != null)
			this._x = _x;
		if (_y != null)
			this._y = _y;
		if (_types != null)
			this._types = _types;
		if (_depth != null)
			this._depth = _depth;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_unifier(_exact, _x, _y, _types, _depth);
	}
}

/**
	// A tparamsList describes a list of type parameters and the types inferred for them.
**/
@:structInit @:using(stdgo.go.types.Types.T_tparamsList_static_extension) private class T_tparamsList {
	public var _unifier:Ref<T_unifier> = (null : Ref<T_unifier>);
	public var _tparams:Slice<Ref<TypeParam>> = (null : Slice<Ref<TypeParam>>);

	/**
		// For each tparams element, there is a corresponding type slot index in indices.
		// index  < 0: unifier.types[-index-1] == nil
		// index == 0: no type slot allocated yet
		// index  > 0: unifier.types[index-1] == typ
		// Joined tparams elements share the same type slot and thus have the same index.
		// By using a negative index for nil types we don't need to check unifier.types
		// to see if we have a type or not.
	**/
	public var _indices:Slice<GoInt> = (null : Slice<GoInt>);

	public function new(?_unifier:Ref<T_unifier>, ?_tparams:Slice<Ref<TypeParam>>, ?_indices:Slice<GoInt>) {
		if (_unifier != null)
			this._unifier = _unifier;
		if (_tparams != null)
			this._tparams = _tparams;
		if (_indices != null)
			this._indices = _indices;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_tparamsList(_unifier, _tparams, _indices);
	}
}

/**
	// A Union represents a union of terms embedded in an interface.
**/
@:structInit @:using(stdgo.go.types.Types.Union_static_extension) class Union {
	public var _terms:Slice<Ref<Term>> = (null : Slice<Ref<Term>>);

	public function new(?_terms:Slice<Ref<Term>>) {
		if (_terms != null)
			this._terms = _terms;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new Union(_terms);
	}
}

@:structInit private class T_version {
	public var _major:GoInt = 0;
	public var _minor:GoInt = 0;

	public function new(?_major:GoInt, ?_minor:GoInt) {
		if (_major != null)
			this._major = _major;
		if (_minor != null)
			this._minor = _minor;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_version(_major, _minor);
	}
}

class T__struct_0_asInterface {
	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T__struct_0>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T__struct_0_asInterface) class T__struct_0_static_extension {}

@:local @:using(stdgo.go.types.Types.T__struct_0_static_extension) private typedef T__struct_0 = {
	public var _in:GoString;
	public var _want:GoString;
};

class T__struct_1_asInterface {
	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T__struct_1>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T__struct_1_asInterface) class T__struct_1_static_extension {}

@:local @:using(stdgo.go.types.Types.T__struct_1_static_extension) private typedef T__struct_1 = {
	public var _val:AnyInterface;
	public var __32bit:GoUIntptr;
	public var __64bit:GoUIntptr;
};

class T__struct_2_asInterface {
	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T__struct_2>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T__struct_2_asInterface) class T__struct_2_static_extension {}

@:local @:using(stdgo.go.types.Types.T__struct_2_static_extension) private typedef T__struct_2 = {
	public var _xl:GoString;
	public var _want:GoString;
};

class T__struct_3_asInterface {
	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T__struct_3>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T__struct_3_asInterface) class T__struct_3_static_extension {}

@:local @:using(stdgo.go.types.Types.T__struct_3_static_extension) private typedef T__struct_3 = {
	public var _xl:GoString;
	public var _yl:GoString;
	public var _want:GoString;
};

class T__struct_4_asInterface {
	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T__struct_4>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T__struct_4_asInterface) class T__struct_4_static_extension {}

@:local @:using(stdgo.go.types.Types.T__struct_4_static_extension) private typedef T__struct_4 = {
	public var _xl:GoString;
	public var _yl:GoString;
	public var _want:Bool;
};

class T__struct_5_asInterface {
	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T__struct_5>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T__struct_5_asInterface) class T__struct_5_static_extension {}

@:local @:using(stdgo.go.types.Types.T__struct_5_static_extension) private typedef T__struct_5 = {
	public var _xl:GoString;
	public var _typ:GoString;
	public var _want:Bool;
};

class T__struct_6_asInterface {
	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T__struct_6>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T__struct_6_asInterface) class T__struct_6_static_extension {}

@:local @:using(stdgo.go.types.Types.T__struct_6_static_extension) private typedef T__struct_6 = {
	public var _name:GoString;
	public var _kind:BasicKind;
	public var _val:stdgo.go.constant.Constant.Value;
};

class T__struct_7_asInterface {
	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T__struct_7>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T__struct_7_asInterface) class T__struct_7_static_extension {}

@:local @:using(stdgo.go.types.Types.T__struct_7_static_extension) private typedef T__struct_7 = {
	public var _name:GoString;
	public var _nargs:GoInt;
	public var _variadic:Bool;
	public var _kind:T_exprKind;
};

/**
	// ImportMode is reserved for future use.
**/
@:named typedef ImportMode = GoInt;

/**
	// BasicKind describes the kind of basic type.
**/
@:named typedef BasicKind = GoInt;

/**
	// BasicInfo is a set of flags describing properties of a basic type.
**/
@:named typedef BasicInfo = GoInt;

/**
	// A ChanDir value indicates a channel direction.
**/
@:named typedef ChanDir = GoInt;

@:named private typedef T_errorCode = GoInt;

/**
	// atPos wraps a token.Pos to implement the positioner interface.
**/
@:named @:using(stdgo.go.types.Types.T_atPos_static_extension) private typedef T_atPos = stdgo.go.token.Token.Pos;

@:named private typedef T_opPredicates = GoMap<stdgo.go.token.Token.Token, Type->Bool>;

/**
	// exprKind describes the kind of an expression; the kind
	// determines if an expression is valid in 'statement context'.
**/
@:named private typedef T_exprKind = GoInt;

@:named @:using(stdgo.go.types.Types.T_nodeSet_static_extension) private typedef T_nodeSet = GoMap<Ref<T_graphNode>, Bool>;

/**
	// nodeQueue implements the container/heap interface;
	// a nodeQueue may be used as a priority queue.
**/
@:named @:using(stdgo.go.types.Types.T_nodeQueue_static_extension) private typedef T_nodeQueue = Slice<Ref<T_graphNode>>;

/**
	// A methodSet is a set of methods and name collisions.
	// A collision indicates that multiple methods with the
	// same unique id, or a field with that id appeared.
**/
@:named @:using(stdgo.go.types.Types.T_methodSet_static_extension) private typedef T_methodSet = GoMap<GoString, Ref<Selection>>;

/**
	// namedState represents the possible states that a named type may assume.
**/
@:named private typedef T_namedState = GoUInt32;

/**
	// color encodes the color of an object (see Checker.objDecl for details).
**/
@:named @:using(stdgo.go.types.Types.T_color_static_extension) private typedef T_color = GoUInt32;

/**
	// An objset is a set of objects identified by their unique id.
	// The zero value for objset is a ready-to-use empty objset.
**/
@:named @:using(stdgo.go.types.Types.T_objset_static_extension) private typedef T_objset = GoMap<GoString, Object>;

/**
	// An operandMode specifies the (addressing) mode of an operand.
**/
@:named private typedef T_operandMode = GoUInt8;

/**
	// inSourceOrder implements the sort.Sort interface.
**/
@:named @:using(stdgo.go.types.Types.T_inSourceOrder_static_extension) private typedef T_inSourceOrder = Slice<Object>;

/**
	// SelectionKind describes the kind of a selector expression x.f
	// (excluding qualified identifiers).
**/
@:named typedef SelectionKind = GoInt;

/**
	// stmtContext is a bitset describing which
	// control-flow statements are permissible,
	// and provides additional context information
	// for better error messages.
**/
@:named private typedef T_stmtContext = GoUInt;

/**
	// A valueMap maps a case value (of a basic Go type) to a list of positions
	// where the same case value appeared, together with the corresponding case
	// types.
	// Since two case values may have the same "underlying" value but different
	// types we need to also check the value's types (e.g., byte(1) vs myByte(1))
	// when the switch expression is of interface type.
**/
@:named private typedef T_valueMap = GoMap<AnyInterface, Slice<T_valueType>>;

@:named @:using(stdgo.go.types.Types.T_substMap_static_extension) private typedef T_substMap = GoMap<Ref<TypeParam>, Type>;

/**
	// A termlist represents the type set represented by the union
	// t1 ∪ y2 ∪ ... tn of the type sets of the terms t1 to tn.
	// A termlist is in normal form if all terms are disjoint.
	// termlist operations don't require the operands to be in
	// normal form.
**/
@:named @:using(stdgo.go.types.Types.T_termlist_static_extension) private typedef T_termlist = Slice<Ref<T_term>>;

/**
	// byUniqueMethodName method lists can be sorted by their unique method names.
**/
@:named @:using(stdgo.go.types.Types.T_byUniqueMethodName_static_extension) private typedef T_byUniqueMethodName = Slice<Ref<Func>>;

/**
	// A Qualifier controls how named package-level objects are printed in
	// calls to TypeString, ObjectString, and SelectionString.
	//
	// These three formatting routines call the Qualifier for each
	// package-level object O, and if the Qualifier returns a non-empty
	// string p, the object is printed in the form p.O.
	// If it returns an empty string, only the object name O is printed.
	//
	// Using a nil Qualifier is equivalent to using (*Package).Path: the
	// object is qualified by the import path, e.g., "encoding/json.Marshal".
**/
@:named typedef Qualifier = Ref<Package>->GoString;

/**
	// A Term represents a term in a Union.
**/
@:named @:using(stdgo.go.types.Types.Term_static_extension) typedef Term = T_term;

/**
	// A builtinId is the id of a builtin function.
**/
@:named private typedef T_builtinId = GoInt;

private function _srcimporter_setUsesCgo(_conf:Ref<Config>):Void {
	_conf._go115UsesCgo = true;
}

/**
	// AssertableTo reports whether a value of type V can be asserted to have type T.
	//
	// The behavior of AssertableTo is unspecified in three cases:
	//   - if T is Typ[Invalid]
	//   - if V is a generalized interface; i.e., an interface that may only be used
	//     as a type constraint in Go code
	//   - if T is an uninstantiated generic type
**/
function assertableTo(v:Ref<Interface>, t:Type):Bool {
	if (Go.toInterface(t.underlying()) == (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
		return false;
	};
	return (null : Ref<Checker>)._newAssertableTo(v, t) == null;
}

/**
	// AssignableTo reports whether a value of type V is assignable to a variable
	// of type T.
	//
	// The behavior of AssignableTo is unspecified if V or T is Typ[Invalid] or an
	// uninstantiated generic type.
**/
function assignableTo(v:Type, t:Type):Bool {
	var _x:T_operand = ({_mode: (7 : T_operandMode), _typ: v} : T_operand);
	var __tmp__ = _x._assignableTo(null, t, (null : Pointer<GoString>)),
		_ok:Bool = __tmp__._0,
		_0:T_errorCode = __tmp__._1;
	return _ok;
}

/**
	// ConvertibleTo reports whether a value of type V is convertible to a value of
	// type T.
	//
	// The behavior of ConvertibleTo is unspecified if V or T is Typ[Invalid] or an
	// uninstantiated generic type.
**/
function convertibleTo(v:Type, t:Type):Bool {
	var _x:T_operand = ({_mode: (7 : T_operandMode), _typ: v} : T_operand);
	return _x._convertibleTo(null, t, (null : Pointer<GoString>));
}

/**
	// Implements reports whether type V implements interface T.
	//
	// The behavior of Implements is unspecified if V is Typ[Invalid] or an uninstantiated
	// generic type.
**/
function implements_(v:Type, t:Ref<Interface>):Bool {
	if (t.empty()) {
		return true;
	};
	if (Go.toInterface(v.underlying()) == (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
		return false;
	};
	return (null : Ref<Checker>)._implements(v, Go.asInterface(t)) == null;
}

/**
	// Identical reports whether x and y are identical types.
	// Receivers of Signature types are ignored.
**/
function identical(_x:Type, _y:Type):Bool {
	return _identical(_x, _y, true, null);
}

/**
	// IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored.
	// Receivers of Signature types are ignored.
**/
function identicalIgnoreTags(_x:Type, _y:Type):Bool {
	return _identical(_x, _y, false, null);
}

/**
	// NewArray returns a new array type for the given element type and length.
	// A negative length indicates an unknown length.
**/
function newArray(_elem:Type, _len:GoInt64):Ref<Array_> {
	return (({_len: _len, _elem: _elem} : Array_) : Ref<Array_>);
}

/**
	// operandTypes returns the list of types for the given operands.
**/
private function _operandTypes(_list:Slice<Ref<T_operand>>):Slice<Type> {
	var _res:Slice<Type> = (null : Slice<Type>);
	for (_0 => _x in _list) {
		_res = _res.__appendref__(_x._typ);
	};
	return _res;
}

/**
	// varTypes returns the list of types for the given variables.
**/
private function _varTypes(_list:Slice<Ref<Var>>):Slice<Type> {
	var _res:Slice<Type> = (null : Slice<Type>);
	for (_0 => _x in _list) {
		_res = _res.__appendref__(_x._object._typ);
	};
	return _res;
}

private function _measure(_x:GoInt, _unit:GoString):GoString {
	if (_x != ((1 : GoInt))) {
		_unit = _unit + (("s" : GoString));
	};
	return stdgo.fmt.Fmt.sprintf(("%d %s" : GoString), Go.toInterface(_x), Go.toInterface(_unit));
}

/**
	// hasVarSize reports if the size of type t is variable due to type parameters
	// or if the type is infinitely-sized due to a cycle for which the type has not
	// yet been checked.
**/
private function _hasVarSize(_t:Type, _seen:GoMap<Ref<Named>, Bool>):Bool {
	var __deferstack__:Array<Void->Void> = [];
	var _varSized:Bool = false;
	{
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_t) : Ref<Named>)) : Ref<Named>), ok: true};
		} catch (_) {
			{value: (null : Ref<Named>), ok: false};
		}, _named = __tmp__.value, _0 = __tmp__.ok;
		if (_named != null) {
			{
				var __tmp__ = (_seen != null && _seen.__exists__(_named) ? {value: _seen[_named], ok: true} : {value: false, ok: false}),
					_v:Bool = __tmp__.value,
					_ok:Bool = __tmp__.ok;
				if (_ok) {
					return _v;
				};
			};
			if (_seen == null) {
				_seen = (new GoObjectMap<Ref<Named>, Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
					stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("Named", [], null, false, {get: () ->
						null})})},
					{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind)}))) : GoMap<Ref<Named>, Bool>);
			};
			_seen[_named] = true;
			__deferstack__.unshift(() -> {
				var a = function():Void {
					_seen[_named] = _varSized;
				};
				a();
			});
		};
	};
	try {
		{
			final __type__ = _under(_t);
			if (Go.typeEquals((__type__ : Ref<Array_>))) {
				var _u:Ref<Array_> = __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__() == null ? (null : Ref<Array_>) : __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__()
					.value;
				{
					for (defer in __deferstack__) {
						defer();
					};
					return _hasVarSize(_u._elem, _seen);
				};
			} else if (Go.typeEquals((__type__ : Ref<Struct>))) {
				var _u:Ref<Struct> = __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__() == null ? (null : Ref<Struct>) : __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__()
					.value;
				for (_1 => _f in _u._fields) {
					if (_hasVarSize(_f._object._typ, _seen)) {
						{
							for (defer in __deferstack__) {
								defer();
							};
							return true;
						};
					};
				};
			} else if (Go.typeEquals((__type__ : Ref<Interface>))) {
				var _u:Ref<Interface> = __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__() == null ? (null : Ref<Interface>) : __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__()
					.value;
				{
					for (defer in __deferstack__) {
						defer();
					};
					return _isTypeParam(_t);
				};
			} else if (Go.typeEquals((__type__ : Ref<Named>)) || Go.typeEquals((__type__ : Ref<Union>))) {
				var _u:Type = __type__ == null ? (null : Type) : cast __type__;
				_unreachable();
			};
		};
		{
			for (defer in __deferstack__) {
				defer();
			};
			return false;
		};
		for (defer in __deferstack__) {
			defer();
		};
		{
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return _varSized;
		};
	} catch (__exception__) {
		if (!(__exception__.native is AnyInterfaceData))
			throw __exception__;
		Go.recover_exception = __exception__.native;
		for (defer in __deferstack__) {
			defer();
		};
		if (Go.recover_exception != null)
			throw Go.recover_exception;
		return _varSized;
	};
}

/**
	// makeSig makes a signature for the given argument and result types.
	// Default types are used for untyped arguments, and res may be nil.
**/
private function _makeSig(_res:Type, _args:haxe.Rest<Type>):Ref<Signature> {
	var _args = new Slice<Type>(0, 0, ..._args);
	var _list = new Slice<Ref<Var>>((_args.length : GoInt).toBasic(), 0, ...[for (i in 0...(_args.length : GoInt).toBasic()) (null : Ref<Var>)]);
	for (_i => _param in _args) {
		_list[(_i : GoInt)] = newVar((0 : stdgo.go.token.Token.Pos), null, Go.str(), default_(_param));
	};
	var _params = newTuple(..._list.__toArray__());
	var _result:Ref<Tuple> = (null : Ref<Tuple>);
	if (_res != null) {
		_assert(!_isUntyped(_res));
		_result = newTuple(newVar((0 : stdgo.go.token.Token.Pos), null, Go.str(), _res));
	};
	return (({_params: _params, _results: _result} : Signature) : Ref<Signature>);
}

/**
	// arrayPtrDeref returns A if typ is of the form *A and A is an array;
	// otherwise it returns typ.
**/
private function _arrayPtrDeref(_typ:Type):Type {
	{
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_typ) : Ref<Pointer_>)) : Ref<Pointer_>), ok: true};
		} catch (_) {
			{value: (null : Ref<Pointer_>), ok: false};
		}, _p = __tmp__.value, _ok = __tmp__.ok;
		if (_ok) {
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_under(_p._base)) : Ref<Array_>)) : Ref<Array_>), ok: true};
				} catch (_) {
					{value: (null : Ref<Array_>), ok: false};
				}, _a = __tmp__.value, _0 = __tmp__.ok;
				if (_a != null) {
					return Go.asInterface(_a);
				};
			};
		};
	};
	return _typ;
}

/**
	// unparen returns e with any enclosing parentheses stripped.
**/
private function _unparen(_e:stdgo.go.ast.Ast.Expr):stdgo.go.ast.Ast.Expr {
	while (true) {
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_e) : Ref<stdgo.go.ast.Ast.ParenExpr>)) : Ref<stdgo.go.ast.Ast.ParenExpr>), ok: true};
		} catch (_) {
			{value: (null : Ref<stdgo.go.ast.Ast.ParenExpr>), ok: false};
		}, _p = __tmp__.value, _ok = __tmp__.ok;
		if (!_ok) {
			return _e;
		};
		_e = _p.x;
	};
}

/**
	// NewChan returns a new channel type for the given direction and element type.
**/
function newChan(_dir:ChanDir, _elem:Type):Ref<Chan> {
	return (({_dir: _dir, _elem: _elem} : Chan) : Ref<Chan>);
}

/**
	// NewChecker returns a new Checker instance for a given package.
	// Package files may be added incrementally via checker.Files.
**/
function newChecker(_conf:Ref<Config>, _fset:Ref<stdgo.go.token.Token.FileSet>, _pkg:Ref<Package>, _info:Ref<Info>):Ref<Checker> {
	if (_conf == null) {
		_conf = ({} : Config);
	};
	if (_info == null) {
		_info = ({} : Info);
	};
	var __tmp__ = _parseGoVersion(_conf.goVersion),
		_version:T_version = __tmp__._0,
		_err:Error = __tmp__._1;
	if (_err != null) {
		throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("invalid Go version %q (%v)" : GoString), Go.toInterface(_conf.goVersion), Go.toInterface(_err)));
	};
	return (({
		_conf: _conf,
		_ctxt: _conf.context,
		_fset: _fset,
		_pkg: _pkg,
		info: _info,
		_version: (_version == null ? null : _version.__copy__()),
		_objMap: (new GoObjectMap<Object, Ref<T_declInfo>>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({
			get: () -> stdgo.internal.reflect.Reflect.GoType.named("Object", [], null, false, {get: () -> null})
		},
			{get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("T_declInfo", [], null, false,
				{get: () -> null})})}))) : GoMap<Object, Ref<T_declInfo>>),
		_impMap: (new GoObjectMap<T_importKey, Ref<Package>>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({
			get: () -> stdgo.internal.reflect.Reflect.GoType.named("T_importKey", [], null, false, {get: () -> null})
		},
			{get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("Package", [], null, false,
				{get: () -> null})})}))) : GoMap<T_importKey, Ref<Package>>)
	} : Checker) : Ref<Checker>);
}

private function _instantiatedIdent(_expr:stdgo.go.ast.Ast.Expr):Ref<stdgo.go.ast.Ast.Ident> {
	var _selOrIdent:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
	{
		final __type__ = _expr;
		if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexExpr>))) {
			var _e:Ref<stdgo.go.ast.Ast.IndexExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IndexExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.IndexExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IndexExpr>) : __type__.__underlying__()
				.value;
			_selOrIdent = _e.x;
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexListExpr>))) {
			var _e:Ref<stdgo.go.ast.Ast.IndexListExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IndexListExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.IndexListExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IndexListExpr>) : __type__.__underlying__()
				.value;
			_selOrIdent = _e.x;
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectorExpr>))
			|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ident>))) {
			var _e:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
			_selOrIdent = _e;
		};
	};
	{
		final __type__ = _selOrIdent;
		if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ident>))) {
			var _x:Ref<stdgo.go.ast.Ast.Ident> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__()
				.value;
			return _x;
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectorExpr>))) {
			var _x:Ref<stdgo.go.ast.Ast.SelectorExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__()
				.value;
			return _x.sel;
		};
	};
	throw Go.toInterface(("instantiated ident not found" : GoString));
}

/**
	// NewContext creates a new Context.
**/
function newContext():Ref<Context> {
	return (({_typeMap: (new GoObjectMap<GoString,
		Slice<T_ctxtEntry>>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
			stdgo.internal.reflect.Reflect.GoType.basic(string_kind)},
		{get: () -> stdgo.internal.reflect.Reflect.GoType.sliceType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("T_ctxtEntry", [], null, false,
			{get: () -> null})})}))) : GoMap<GoString, Slice<T_ctxtEntry>>), _originIDs: (new GoObjectMap<Type,
			GoInt>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({
			get: () -> stdgo.internal.reflect.Reflect.GoType.named("Type", [], null, false, {get: () -> null})
		},
			{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(int_kind)}))) : GoMap<Type, GoInt>)} : Context) : Ref<Context>);
}

function testContextHashCollisions(_t:Ref<stdgo.testing.Testing.T>):Void {
	if (false) {
		_t.skip(Go.toInterface(("hash collisions are expected, and would fail debug assertions" : GoString)));
	};
	var _0:Type = (null : Type),
		_1:Type = (null : Type),
		_2:Type = (null : Type),
		_unaryP:Type = _2,
		_nullaryQ:Type = _1,
		_nullaryP:Type = _0;
	{
		var _tparam = newTypeParam(newTypeName((0 : stdgo.go.token.Token.Pos), null, ("P" : GoString), (null : Type)),
			Go.asInterface((_emptyInterface : Ref<Interface>)));
		_nullaryP = Go.asInterface(newSignatureType(null, (null : Slice<Ref<TypeParam>>), (new Slice<Ref<TypeParam>>(0, 0, _tparam) : Slice<Ref<TypeParam>>),
			null, null, false));
	};
	{
		var _tparam = newTypeParam(newTypeName((0 : stdgo.go.token.Token.Pos), null, ("Q" : GoString), (null : Type)),
			Go.asInterface((_emptyInterface : Ref<Interface>)));
		_nullaryQ = Go.asInterface(newSignatureType(null, (null : Slice<Ref<TypeParam>>), (new Slice<Ref<TypeParam>>(0, 0, _tparam) : Slice<Ref<TypeParam>>),
			null, null, false));
	};
	{
		var _tparam = newTypeParam(newTypeName((0 : stdgo.go.token.Token.Pos), null, ("P" : GoString), (null : Type)),
			Go.asInterface((_emptyInterface : Ref<Interface>)));
		var _params = newTuple(newVar((0 : stdgo.go.token.Token.Pos), null, ("_" : GoString), Go.asInterface(_tparam)));
		_unaryP = Go.asInterface(newSignatureType(null, (null : Slice<Ref<TypeParam>>), (new Slice<Ref<TypeParam>>(0, 0, _tparam) : Slice<Ref<TypeParam>>),
			_params, null, false));
	};
	var _ctxt = newContext();
	var _inst = newSignatureType(null, (null : Slice<Ref<TypeParam>>), (null : Slice<Ref<TypeParam>>), null, null, false);
	{
		var _got:Type = _ctxt._update(Go.str(), _nullaryP, (new Slice<Type>(0, 0, Go.asInterface(typ[((2 : BasicKind) : GoInt)])) : Slice<Type>),
			Go.asInterface(_inst));
		if (Go.toInterface(_got) != (Go.toInterface(Go.asInterface(_inst)))) {
			_t.error(Go.toInterface(("bad" : GoString)));
		};
	};
	{
		var _got:Type = _ctxt._lookup(Go.str(), _unaryP, (new Slice<Type>(0, 0, Go.asInterface(typ[((2 : BasicKind) : GoInt)])) : Slice<Type>));
		if (_got != null) {
			_t.error(Go.toInterface(("bad" : GoString)));
		};
	};
	{
		var _got:Type = _ctxt._lookup(Go.str(), _nullaryQ, (new Slice<Type>(0, 0, Go.asInterface(typ[((2 : BasicKind) : GoInt)])) : Slice<Type>));
		if (Go.toInterface(_got) != (Go.toInterface(Go.asInterface(_inst)))) {
			_t.error(Go.toInterface(("bad" : GoString)));
		};
	};
	{
		var _got:Type = _ctxt._lookup(Go.str(), _nullaryQ, (new Slice<Type>(0, 0, Go.asInterface(typ[((17 : BasicKind) : GoInt)])) : Slice<Type>));
		if (_got != null) {
			_t.error(Go.toInterface(("bad" : GoString)));
		};
	};
}

private function _isUintptr(_typ:Type):Bool {
	var __tmp__ = try {
		{value: (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Basic>)) : Ref<Basic>), ok: true};
	} catch (_) {
		{value: (null : Ref<Basic>), ok: false};
	}, _t = __tmp__.value, _0 = __tmp__.ok;
	return (_t != null) && (_t._kind == (12 : BasicKind));
}

private function _isUnsafePointer(_typ:Type):Bool {
	var __tmp__ = try {
		{value: (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Basic>)) : Ref<Basic>), ok: true};
	} catch (_) {
		{value: (null : Ref<Basic>), ok: false};
	}, _t = __tmp__.value, _0 = __tmp__.ok;
	return (_t != null) && (_t._kind == (18 : BasicKind));
}

private function _isPointer(_typ:Type):Bool {
	var __tmp__ = try {
		{value: (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Pointer_>)) : Ref<Pointer_>), ok: true};
	} catch (_) {
		{value: (null : Ref<Pointer_>), ok: false};
	}, _0 = __tmp__.value, _ok = __tmp__.ok;
	return _ok;
}

private function _isBytesOrRunes(_typ:Type):Bool {
	{
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Slice_>)) : Ref<Slice_>), ok: true};
		} catch (_) {
			{value: (null : Ref<Slice_>), ok: false};
		}, _s = __tmp__.value, _0 = __tmp__.ok;
		if (_s != null) {
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_under(_s._elem)) : Ref<Basic>)) : Ref<Basic>), ok: true};
			} catch (_) {
				{value: (null : Ref<Basic>), ok: false};
			}, _t = __tmp__.value, _1 = __tmp__.ok;
			return (_t != null) && ((_t._kind == (8 : BasicKind)) || (_t._kind == (5 : BasicKind)));
		};
	};
	return false;
}

/**
	// pathString returns a string of the form a->b-> ... ->g for a path [a, b, ... g].
**/
private function _pathString(_path:Slice<Object>):GoString {
	var _s:GoString = ("" : GoString);
	for (_i => _p in _path) {
		if (_i > (0 : GoInt)) {
			_s = _s + (("->" : GoString));
		};
		_s = _s + (_p.name());
	};
	return _s;
}

/**
	// firstInSrc reports the index of the object with the "smallest"
	// source position in path. path must not be empty.
**/
private function _firstInSrc(_path:Slice<Object>):GoInt {
	var _0:GoInt = (0 : GoInt),
		_1:stdgo.go.token.Token.Pos = _path[(0 : GoInt)].pos(),
		_pos:stdgo.go.token.Token.Pos = _1,
		_fst:GoInt = _0;
	for (_i => _t in (_path.__slice__((1 : GoInt)) : Slice<Object>)) {
		if (_t.pos() < _pos) {
			{
				final __tmp__0 = _i + (1 : GoInt);
				final __tmp__1 = _t.pos();
				_fst = __tmp__0;
				_pos = __tmp__1;
			};
		};
	};
	return _fst;
}

private function _assert(_p:Bool):Void {
	if (!_p) {
		var _msg:GoString = ("assertion failed" : GoString);
		{
			var __tmp__ = stdgo.runtime.Runtime.caller((1 : GoInt)),
				_0:GoUIntptr = __tmp__._0,
				_file:GoString = __tmp__._1,
				_line:GoInt = __tmp__._2,
				_ok:Bool = __tmp__._3;
			if (_ok) {
				_msg = stdgo.fmt.Fmt.sprintf(("%s:%d: %s" : GoString), Go.toInterface(_file), Go.toInterface(_line), Go.toInterface(_msg));
			};
		};
		throw Go.toInterface(_msg);
	};
}

private function _unreachable():Void {
	throw Go.toInterface(("unreachable" : GoString));
}

private function _sprintf(_fset:Ref<stdgo.go.token.Token.FileSet>, _qf:Qualifier, _debug:Bool, _format:GoString, _args:haxe.Rest<AnyInterface>):GoString {
	var _args = new Slice<AnyInterface>(0, 0, ..._args);
	for (_i => _arg in _args) {
		{
			final __type__ = _arg;
			if (__type__ == null) {
				var _a:AnyInterface = __type__ == null ? (null : AnyInterface) : __type__.__underlying__();
				_arg = Go.toInterface(("<nil>" : GoString));
			} else if (Go.typeEquals((__type__ : T_operand))) {
				var _a:T_operand = __type__ == null ? ({} : T_operand) : __type__.__underlying__() == null ? ({} : T_operand) : __type__ == null ? ({} : T_operand) : __type__.__underlying__()
					.value;
				throw Go.toInterface(("got operand instead of *operand" : GoString));
			} else if (Go.typeEquals((__type__ : Ref<T_operand>))) {
				var _a:Ref<T_operand> = __type__ == null ? (null : Ref<T_operand>) : __type__.__underlying__() == null ? (null : Ref<T_operand>) : __type__ == null ? (null : Ref<T_operand>) : __type__.__underlying__()
					.value;
				_arg = Go.toInterface(_operandString(_a, _qf));
			} else if (Go.typeEquals((__type__ : stdgo.go.token.Token.Pos))) {
				var _a:stdgo.go.token.Token.Pos = __type__ == null ? ((0 : GoInt) : stdgo.go.token.Token.Pos) : __type__.__underlying__() == null ? ((0 : GoInt) : stdgo.go.token.Token.Pos) : __type__ == null ? ((0 : GoInt) : stdgo.go.token.Token.Pos) : __type__.__underlying__()
					.value;
				if (_fset != null) {
					_arg = Go.toInterface((_fset.position(_a).string() : GoString));
				};
			} else if (Go.typeEquals((__type__ : stdgo.go.ast.Ast.Expr))) {
				var _a:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : __type__.__underlying__() == null ? (null : stdgo.go.ast.Ast.Expr) : __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : __type__.__underlying__()
					.value;
				_arg = Go.toInterface(exprString(_a));
			} else if (Go.typeEquals((__type__ : Slice<stdgo.go.ast.Ast.Expr>))) {
				var _a:Slice<stdgo.go.ast.Ast.Expr> = __type__ == null ? (null : Slice<stdgo.go.ast.Ast.Expr>) : __type__.__underlying__() == null ? (null : Slice<stdgo.go.ast.Ast.Expr>) : __type__ == null ? (null : Slice<stdgo.go.ast.Ast.Expr>) : __type__.__underlying__()
					.value;
				var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
				_buf.writeByte((91 : GoUInt8));
				_writeExprList((_buf : Ref<stdgo.bytes.Bytes.Buffer>), _a);
				_buf.writeByte((93 : GoUInt8));
				_arg = Go.toInterface((_buf.string() : GoString));
			} else if (Go.typeEquals((__type__ : Object))) {
				var _a:Object = __type__ == null ? (null : Object) : __type__.__underlying__() == null ? (null : Object) : __type__ == null ? (null : Object) : __type__.__underlying__()
					.value;
				_arg = Go.toInterface(objectString(_a, _qf));
			} else if (Go.typeEquals((__type__ : Type))) {
				var _a:Type = __type__ == null ? (null : Type) : __type__.__underlying__() == null ? (null : Type) : __type__ == null ? (null : Type) : __type__.__underlying__()
					.value;
				_arg = Go.toInterface(_typeString(_a, _qf, _debug));
			} else if (Go.typeEquals((__type__ : Slice<Type>))) {
				var _a:Slice<Type> = __type__ == null ? (null : Slice<Type>) : __type__.__underlying__() == null ? (null : Slice<Type>) : __type__ == null ? (null : Slice<Type>) : __type__.__underlying__()
					.value;
				var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
				_buf.writeByte((91 : GoUInt8));
				for (_i => _x in _a) {
					if (_i > (0 : GoInt)) {
						_buf.writeString((", " : GoString));
					};
					_buf.writeString(_typeString(_x, _qf, _debug));
				};
				_buf.writeByte((93 : GoUInt8));
				_arg = Go.toInterface((_buf.string() : GoString));
			} else if (Go.typeEquals((__type__ : Slice<Ref<TypeParam>>))) {
				var _a:Slice<Ref<TypeParam>> = __type__ == null ? (null : Slice<Ref<TypeParam>>) : __type__.__underlying__() == null ? (null : Slice<Ref<TypeParam>>) : __type__ == null ? (null : Slice<Ref<TypeParam>>) : __type__.__underlying__()
					.value;
				var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
				_buf.writeByte((91 : GoUInt8));
				for (_i => _x in _a) {
					if (_i > (0 : GoInt)) {
						_buf.writeString((", " : GoString));
					};
					_buf.writeString(_typeString(Go.asInterface(_x), _qf, _debug));
				};
				_buf.writeByte((93 : GoUInt8));
				_arg = Go.toInterface((_buf.string() : GoString));
			};
		};
		_args[(_i : GoInt)] = _arg;
	};
	return stdgo.fmt.Fmt.sprintf(_format, ..._args.__toArray__());
}

/**
	// newErrorf creates a new error_ for later reporting with check.report.
**/
private function _newErrorf(_at:T_positioner, _code:T_errorCode, _format:GoString, _args:haxe.Rest<AnyInterface>):Ref<T_error_> {
	var _args = new Slice<AnyInterface>(0, 0, ..._args);
	return (({_desc: (new Slice<T_errorDesc>(0, 0,
		(new T_errorDesc(_at, _format, _args) : T_errorDesc)) : Slice<T_errorDesc>), _code: _code} : T_error_) : Ref<T_error_>);
}

/**
	// inNode creates a posSpan for the given node.
	// Invariant: node.Pos() <= pos < node.End() (node.End() is the position of the
	// first byte after node within the source).
**/
private function _inNode(_node:stdgo.go.ast.Ast.Node, _pos:stdgo.go.token.Token.Pos):T_posSpan {
	var _0:stdgo.go.token.Token.Pos = _node.pos(),
		_1:stdgo.go.token.Token.Pos = _node.end(),
		_end:stdgo.go.token.Token.Pos = _1,
		_start:stdgo.go.token.Token.Pos = _0;
	if (false) {
		_assert((_start <= _pos) && (_pos < _end));
	};
	return (new T_posSpan(_start, _pos, _end) : T_posSpan);
}

/**
	// spanOf extracts an error span from the given positioner. By default this is
	// the trivial span starting and ending at pos, but this span is expanded when
	// the argument naturally corresponds to a span of source code.
**/
private function _spanOf(_at:T_positioner):T_posSpan {
	{
		final __type__ = _at;
		if (__type__ == null) {
			var _x:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
			throw Go.toInterface(("nil positioner" : GoString));
		} else if (Go.typeEquals((__type__ : T_posSpan))) {
			var _x:T_posSpan = __type__ == null ? ({} : T_posSpan) : __type__.__underlying__() == null ? ({} : T_posSpan) : __type__ == null ? ({} : T_posSpan) : __type__.__underlying__()
				.value;
			return (_x == null ? null : _x.__copy__());
		} else if (Go.typeEquals((__type__ : stdgo.go.ast.Ast.Node))) {
			var _x:stdgo.go.ast.Ast.Node = __type__ == null ? (null : stdgo.go.ast.Ast.Node) : cast __type__;
			var _pos:stdgo.go.token.Token.Pos = _x.pos();
			return (new T_posSpan(_pos, _pos, _x.end()) : T_posSpan);
		} else if (Go.typeEquals((__type__ : Ref<T_operand>))) {
			var _x:Ref<T_operand> = __type__ == null ? (null : Ref<T_operand>) : __type__.__underlying__() == null ? (null : Ref<T_operand>) : __type__ == null ? (null : Ref<T_operand>) : __type__.__underlying__()
				.value;
			if (_x._expr != null) {
				var _pos:stdgo.go.token.Token.Pos = _x.pos();
				return (new T_posSpan(_pos, _pos, _x._expr.end()) : T_posSpan);
			};
			return (new T_posSpan((0 : stdgo.go.token.Token.Pos), (0 : stdgo.go.token.Token.Pos), (0 : stdgo.go.token.Token.Pos)) : T_posSpan);
		} else {
			var _x:T_positioner = __type__ == null ? (null : T_positioner) : cast __type__;
			var _pos:stdgo.go.token.Token.Pos = _at.pos();
			return (new T_posSpan(_pos, _pos, _pos) : T_posSpan);
		};
	};
}

/**
	// stripAnnotations removes internal (type) annotations from s.
**/
private function _stripAnnotations(_s:GoString):GoString {
	var _b:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
	for (_0 => _r in _s) {
		if ((_r < (8320:GoInt32)) || ((8330 : GoInt32) <= _r)) {
			_b.writeRune(_r);
		};
	};
	if (_b.len() < (_s.length)) {
		return (_b.string() : GoString);
	};
	return _s;
}

function testError(_t:Ref<stdgo.testing.Testing.T>):Void {
	var _err:T_error_ = ({} : T_error_);
	var _want:GoString = ("no error" : GoString);
	{
		var _got:GoString = (_err.string() : GoString);
		if (_got != (_want)) {
			_t.errorf(("empty error: got %q, want %q" : GoString), Go.toInterface(_got), Go.toInterface(_want));
		};
	};
	_want = ("0: foo 42" : GoString);
	_err._errorf((0 : stdgo.go.token.Token.Pos), ("foo %d" : GoString), Go.toInterface((42 : GoInt)));
	{
		var _got:GoString = (_err.string() : GoString);
		if (_got != (_want)) {
			_t.errorf(("simple error: got %q, want %q" : GoString), Go.toInterface(_got), Go.toInterface(_want));
		};
	};
	_want = ("0: foo 42\n\tbar 43" : GoString);
	_err._errorf((0 : stdgo.go.token.Token.Pos), ("bar %d" : GoString), Go.toInterface((43 : GoInt)));
	{
		var _got:GoString = (_err.string() : GoString);
		if (_got != (_want)) {
			_t.errorf(("simple error: got %q, want %q" : GoString), Go.toInterface(_got), Go.toInterface(_want));
		};
	};
}

function testStripAnnotations(_t:Ref<stdgo.testing.Testing.T>):Void {
	for (_0 => _test in (new Slice<T__struct_0>(0, 0, ({_in: Go.str(), _want: Go.str()} : T__struct_0),
		({_in: ("   " : GoString), _want: ("   " : GoString)} : T__struct_0), ({_in: ("foo" : GoString), _want: ("foo" : GoString)} : T__struct_0),
		({_in: ("foo₀" : GoString), _want: ("foo" : GoString)} : T__struct_0),
		({_in: ("foo(T₀)" : GoString), _want: ("foo(T)" : GoString)} : T__struct_0)) : Slice<T__struct_0>)) {
		var _got:GoString = _stripAnnotations(_test._in);
		if (_got != (_test._want)) {
			_t.errorf(("%q: got %q; want %q" : GoString), Go.toInterface(_test._in), Go.toInterface(_got), Go.toInterface(_test._want));
		};
	};
}

/**
	// Eval returns the type and, if constant, the value for the
	// expression expr, evaluated at position pos of package pkg,
	// which must have been derived from type-checking an AST with
	// complete position information relative to the provided file
	// set.
	//
	// The meaning of the parameters fset, pkg, and pos is the
	// same as in CheckExpr. An error is returned if expr cannot
	// be parsed successfully, or the resulting expr AST cannot be
	// type-checked.
**/
function eval(_fset:Ref<stdgo.go.token.Token.FileSet>, _pkg:Ref<Package>, _pos:stdgo.go.token.Token.Pos, _expr:GoString):{var _0:TypeAndValue; var _1:Error;} {
	var _0:TypeAndValue = ({} : TypeAndValue), _err:Error = (null : Error);
	var __tmp__ = stdgo.go.parser.Parser.parseExprFrom(_fset, ("eval" : GoString), Go.toInterface(_expr), (("0" : GoUInt) : stdgo.go.parser.Parser.Mode)),
		_node:stdgo.go.ast.Ast.Expr = __tmp__._0,
		_err:Error = __tmp__._1;
	if (_err != null) {
		return {_0: (new TypeAndValue() : TypeAndValue), _1: _err};
	};
	var _info = (({types: (new GoObjectMap<stdgo.go.ast.Ast.Expr,
		TypeAndValue>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
			stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.ast.Ast.Expr", [], null, false, {get: () -> null})},
		{get: () -> stdgo.internal.reflect.Reflect.GoType.named("TypeAndValue", [], null, false,
			{get: () -> null})}))) : GoMap<stdgo.go.ast.Ast.Expr, TypeAndValue>)} : Info) : Ref<Info>);
	_err = checkExpr(_fset, _pkg, _pos, _node, _info);
	return {_0: (_info.types[_node] == null ? null : _info.types[_node].__copy__()), _1: _err};
}

/**
	// CheckExpr type checks the expression expr as if it had appeared at position
	// pos of package pkg. Type information about the expression is recorded in
	// info. The expression may be an identifier denoting an uninstantiated generic
	// function or type.
	//
	// If pkg == nil, the Universe scope is used and the provided
	// position pos is ignored. If pkg != nil, and pos is invalid,
	// the package scope is used. Otherwise, pos must belong to the
	// package.
	//
	// An error is returned if pos is not within the package or
	// if the node cannot be type-checked.
	//
	// Note: Eval and CheckExpr should not be used instead of running Check
	// to compute types and values, but in addition to Check, as these
	// functions ignore the context in which an expression is used (e.g., an
	// assignment). Thus, top-level untyped constants will return an
	// untyped type rather then the respective context-specific type.
**/
function checkExpr(_fset:Ref<stdgo.go.token.Token.FileSet>, _pkg:Ref<Package>, _pos:stdgo.go.token.Token.Pos, _expr:stdgo.go.ast.Ast.Expr,
		_info:Ref<Info>):Error {
	var __deferstack__:Array<Void->Void> = [];
	var _err:Error = (null : Error);
	var _scope:Ref<Scope> = (null : Ref<Scope>);
	try {
		if (_pkg == null) {
			_scope = universe;
			_pos = (0 : stdgo.go.token.Token.Pos);
		} else if (!_pos.isValid()) {
			_scope = _pkg._scope;
		} else {
			for (_0 => _fscope in _pkg._scope._children) {
				{
					_scope = _fscope.innermost(_pos);
					if (_scope != null) {
						break;
					};
				};
			};
			if ((_scope == null) || false) {
				var _s = _scope;
				while ((_s != null) && (_s != _pkg._scope)) {
					_s = _s._parent;
				};
				if (_s == null) {
					return stdgo.fmt.Fmt.errorf(("no position %s found in package %s" : GoString), Go.toInterface(Go.asInterface(_fset.position(_pos))),
						Go.toInterface(_pkg._name));
				};
			};
		};
		var _check = newChecker(null, _fset, _pkg, _info);
		_check._pkg._scope = _scope;
		_check._pkg._scope._pos = _pos;
		{
			var _a0 = (_err : Ref<Error>);
			__deferstack__.unshift(() -> _check._handleBailout(_a0));
		};
		var _x:T_operand = ({} : T_operand);
		_check._rawExpr((_x : Ref<T_operand>), _expr, (null : Type), true);
		_check._processDelayed((0 : GoInt));
		_check._recordUntyped();
		{
			for (defer in __deferstack__) {
				defer();
			};
			return (null : Error);
		};
		for (defer in __deferstack__) {
			defer();
		};
		{
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return _err;
		};
	} catch (__exception__) {
		if (!(__exception__.native is AnyInterfaceData))
			throw __exception__;
		Go.recover_exception = __exception__.native;
		for (defer in __deferstack__) {
			defer();
		};
		if (Go.recover_exception != null)
			throw Go.recover_exception;
		return _err;
	};
}

/**
	// opName returns the name of the operation if x is an operation
	// that might overflow; otherwise it returns the empty string.
**/
private function _opName(_e:stdgo.go.ast.Ast.Expr):GoString {
	{
		final __type__ = _e;
		if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BinaryExpr>))) {
			var _e:Ref<stdgo.go.ast.Ast.BinaryExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__()
				.value;
			if ((_e.op : GoInt) < (_op2str2.length)) {
				return _op2str2[(_e.op : GoInt)];
			};
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.UnaryExpr>))) {
			var _e:Ref<stdgo.go.ast.Ast.UnaryExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__()
				.value;
			if ((_e.op : GoInt) < (_op2str1.length)) {
				return _op2str1[(_e.op : GoInt)];
			};
		};
	};
	return Go.str();
}

/**
	// If typ is a type parameter, underIs returns the result of typ.underIs(f).
	// Otherwise, underIs returns the result of f(under(typ)).
**/
private function _underIs(_typ:Type, _f:Type->Bool):Bool {
	{
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_typ) : Ref<TypeParam>)) : Ref<TypeParam>), ok: true};
		} catch (_) {
			{value: (null : Ref<TypeParam>), ok: false};
		}, _tpar = __tmp__.value, _0 = __tmp__.ok;
		if (_tpar != null) {
			return _tpar._underIs(_f);
		};
	};
	return _f(_under(_typ));
}

private function _isShift(_op:stdgo.go.token.Token.Token):Bool {
	return (_op == (20 : stdgo.go.token.Token.Token)) || (_op == (21 : stdgo.go.token.Token.Token));
}

private function _isComparison(_op:stdgo.go.token.Token.Token):Bool {
	if (_op == ((39 : stdgo.go.token.Token.Token))
		|| _op == ((44 : stdgo.go.token.Token.Token))
		|| _op == ((40 : stdgo.go.token.Token.Token))
		|| _op == ((45 : stdgo.go.token.Token.Token))
		|| _op == ((41 : stdgo.go.token.Token.Token))
		|| _op == ((46 : stdgo.go.token.Token.Token))) {
		return true;
	};
	return false;
}

private function _fitsFloat32(_x:stdgo.go.constant.Constant.Value):Bool {
	var __tmp__ = stdgo.go.constant.Constant.float32Val(_x),
		_f32:GoFloat32 = __tmp__._0,
		_0:Bool = __tmp__._1;
	var _f:GoFloat64 = (_f32 : GoFloat64);
	return !stdgo.math.Math.isInf(_f, (0 : GoInt));
}

private function _roundFloat32(_x:stdgo.go.constant.Constant.Value):stdgo.go.constant.Constant.Value {
	var __tmp__ = stdgo.go.constant.Constant.float32Val(_x),
		_f32:GoFloat32 = __tmp__._0,
		_0:Bool = __tmp__._1;
	var _f:GoFloat64 = (_f32 : GoFloat64);
	if (!stdgo.math.Math.isInf(_f, (0 : GoInt))) {
		return stdgo.go.constant.Constant.makeFloat64(_f);
	};
	return (null : stdgo.go.constant.Constant.Value);
}

private function _fitsFloat64(_x:stdgo.go.constant.Constant.Value):Bool {
	var __tmp__ = stdgo.go.constant.Constant.float64Val(_x),
		_f:GoFloat64 = __tmp__._0,
		_0:Bool = __tmp__._1;
	return !stdgo.math.Math.isInf(_f, (0 : GoInt));
}

private function _roundFloat64(_x:stdgo.go.constant.Constant.Value):stdgo.go.constant.Constant.Value {
	var __tmp__ = stdgo.go.constant.Constant.float64Val(_x),
		_f:GoFloat64 = __tmp__._0,
		_0:Bool = __tmp__._1;
	if (!stdgo.math.Math.isInf(_f, (0 : GoInt))) {
		return stdgo.go.constant.Constant.makeFloat64(_f);
	};
	return (null : stdgo.go.constant.Constant.Value);
}

/**
	// representableConst reports whether x can be represented as
	// value of the given basic type and for the configuration
	// provided (only needed for int/uint sizes).
	//
	// If rounded != nil, *rounded is set to the rounded value of x for
	// representable floating-point and complex values, and to an Int
	// value for integer values; it is left alone otherwise.
	// It is ok to provide the addressof the first argument for rounded.
	//
	// The check parameter may be nil if representableConst is invoked
	// (indirectly) through an exported API call (AssignableTo, ConvertibleTo)
	// because we don't need the Checker's config for those calls.
**/
private function _representableConst(_x:stdgo.go.constant.Constant.Value, _check:Ref<Checker>, _typ:Ref<Basic>,
		_rounded:Ref<stdgo.go.constant.Constant.Value>):Bool {
	if (_x.kind() == ((0 : stdgo.go.constant.Constant.Kind))) {
		return true;
	};
	var _conf:Ref<Config> = (null : Ref<Config>);
	if (_check != null) {
		_conf = _check._conf;
	};
	if (_isInteger(Go.asInterface(_typ))) {
		var _x:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.toInt(_x);
		if (_x.kind() != ((3 : stdgo.go.constant.Constant.Kind))) {
			return false;
		};
		if (_rounded != null) {
			_rounded = _x;
		};
		{
			var __tmp__ = stdgo.go.constant.Constant.int64Val(_x),
				_x:GoInt64 = __tmp__._0,
				_ok:Bool = __tmp__._1;
			if (_ok) {
				if (_typ._kind == ((2 : BasicKind))) {
					var _s:GoUInt = (_conf._sizeof(Go.asInterface(_typ)) : GoUInt) * ("8" : GoUInt);
					return ((((("-1" : GoInt64) : GoInt64) : GoInt64) << (_s - (("1" : GoUInt) : GoUInt))) <= _x)
						&& (_x <= ((((("1" : GoInt64) : GoInt64) : GoInt64) << (_s - (("1" : GoUInt) : GoUInt))) - (("1" : GoInt64) : GoInt64)));
				} else if (_typ._kind == ((3 : BasicKind))) {
					{};
					return ((("-128" : GoInt64) : GoInt64) <= _x) && (_x <= (("127" : GoInt64) : GoInt64));
				} else if (_typ._kind == ((4 : BasicKind))) {
					{};
					return ((("-32768" : GoInt64) : GoInt64) <= _x) && (_x <= (("32767" : GoInt64) : GoInt64));
				} else if (_typ._kind == ((5 : BasicKind))) {
					{};
					return ((("-2147483648" : GoInt64) : GoInt64) <= _x) && (_x <= (("2147483647" : GoInt64) : GoInt64));
				} else if (_typ._kind == ((6 : BasicKind)) || _typ._kind == ((20 : BasicKind))) {
					return true;
				} else if (_typ._kind == ((7 : BasicKind)) || _typ._kind == ((12 : BasicKind))) {
					{
						var _s:GoUInt = (_conf._sizeof(Go.asInterface(_typ)) : GoUInt) * ("8" : GoUInt);
						if (_s < ("64":GoUInt)) {
							return ((("0" : GoInt64) : GoInt64) <= _x)
								&& (_x <= ((((("1" : GoInt64) : GoInt64) : GoInt64) << _s) - (("1" : GoInt64) : GoInt64)));
						};
					};
					return ("0" : GoInt64) <= _x;
				} else if (_typ._kind == ((8 : BasicKind))) {
					{};
					return ((("0" : GoInt64) : GoInt64) <= _x) && (_x <= (("255" : GoInt64) : GoInt64));
				} else if (_typ._kind == ((9 : BasicKind))) {
					{};
					return ((("0" : GoInt64) : GoInt64) <= _x) && (_x <= (("65535" : GoInt64) : GoInt64));
				} else if (_typ._kind == ((10 : BasicKind))) {
					{};
					return ((("0" : GoInt64) : GoInt64) <= _x) && (_x <= (("4294967295" : GoInt64) : GoInt64));
				} else if (_typ._kind == ((11 : BasicKind))) {
					return ("0" : GoInt64) <= _x;
				} else {
					_unreachable();
				};
			};
		};
		{
			var _n:GoInt = stdgo.go.constant.Constant.bitLen(_x);
			if (_typ._kind == ((7 : BasicKind)) || _typ._kind == ((12 : BasicKind))) {
				var _s:GoUInt = (_conf._sizeof(Go.asInterface(_typ)) : GoUInt) * ("8" : GoUInt);
				return (stdgo.go.constant.Constant.sign(_x) >= (0 : GoInt)) && (_n <= (_s : GoInt));
			} else if (_typ._kind == ((11 : BasicKind))) {
				return (stdgo.go.constant.Constant.sign(_x) >= (0 : GoInt)) && (_n <= (64 : GoInt));
			} else if (_typ._kind == ((20 : BasicKind))) {
				return true;
			};
		};
	} else if (_isFloat(Go.asInterface(_typ))) {
		var _x:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.toFloat(_x);
		if (_x.kind() != ((4 : stdgo.go.constant.Constant.Kind))) {
			return false;
		};
		if (_typ._kind == ((13 : BasicKind))) {
			if (_rounded == null) {
				return _fitsFloat32(_x);
			};
			var _r:stdgo.go.constant.Constant.Value = _roundFloat32(_x);
			if (_r != null) {
				_rounded = _r;
				return true;
			};
		} else if (_typ._kind == ((14 : BasicKind))) {
			if (_rounded == null) {
				return _fitsFloat64(_x);
			};
			var _r:stdgo.go.constant.Constant.Value = _roundFloat64(_x);
			if (_r != null) {
				_rounded = _r;
				return true;
			};
		} else if (_typ._kind == ((22 : BasicKind))) {
			return true;
		} else {
			_unreachable();
		};
	} else if (_isComplex(Go.asInterface(_typ))) {
		var _x:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.toComplex(_x);
		if (_x.kind() != ((5 : stdgo.go.constant.Constant.Kind))) {
			return false;
		};
		if (_typ._kind == ((15 : BasicKind))) {
			if (_rounded == null) {
				return _fitsFloat32(stdgo.go.constant.Constant.real(_x)) && _fitsFloat32(stdgo.go.constant.Constant.imag(_x));
			};
			var _re:stdgo.go.constant.Constant.Value = _roundFloat32(stdgo.go.constant.Constant.real(_x));
			var _im:stdgo.go.constant.Constant.Value = _roundFloat32(stdgo.go.constant.Constant.imag(_x));
			if ((_re != null) && (_im != null)) {
				_rounded = stdgo.go.constant.Constant.binaryOp(_re, (12 : stdgo.go.token.Token.Token), stdgo.go.constant.Constant.makeImag(_im));
				return true;
			};
		} else if (_typ._kind == ((16 : BasicKind))) {
			if (_rounded == null) {
				return _fitsFloat64(stdgo.go.constant.Constant.real(_x)) && _fitsFloat64(stdgo.go.constant.Constant.imag(_x));
			};
			var _re:stdgo.go.constant.Constant.Value = _roundFloat64(stdgo.go.constant.Constant.real(_x));
			var _im:stdgo.go.constant.Constant.Value = _roundFloat64(stdgo.go.constant.Constant.imag(_x));
			if ((_re != null) && (_im != null)) {
				_rounded = stdgo.go.constant.Constant.binaryOp(_re, (12 : stdgo.go.token.Token.Token), stdgo.go.constant.Constant.makeImag(_im));
				return true;
			};
		} else if (_typ._kind == ((23 : BasicKind))) {
			return true;
		} else {
			_unreachable();
		};
	} else if (_isString(Go.asInterface(_typ))) {
		return _x.kind() == ((2 : stdgo.go.constant.Constant.Kind));
	} else if (_isBoolean(Go.asInterface(_typ))) {
		return _x.kind() == ((1 : stdgo.go.constant.Constant.Kind));
	};
	return false;
}

/**
	// keyVal maps a complex, float, integer, string or boolean constant value
	// to the corresponding complex128, float64, int64, uint64, string, or bool
	// Go value if possible; otherwise it returns x.
	// A complex constant that can be represented as a float (such as 1.2 + 0i)
	// is returned as a floating point value; if a floating point value can be
	// represented as an integer (such as 1.0) it is returned as an integer value.
	// This ensures that constants of different kind but equal value (such as
	// 1.0 + 0i, 1.0, 1) result in the same value.
**/
private function _keyVal(_x:stdgo.go.constant.Constant.Value):AnyInterface {
	{
		var __switchIndex__ = -1;
		while (true) {
			if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (_x.kind() == (5 : stdgo.go.constant.Constant.Kind)))) {
				var _f:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.toFloat(_x);
				if (_f.kind() != ((4 : stdgo.go.constant.Constant.Kind))) {
					var __tmp__ = stdgo.go.constant.Constant.float64Val(stdgo.go.constant.Constant.real(_x)),
						_r:GoFloat64 = __tmp__._0,
						_0:Bool = __tmp__._1;
					var __tmp__ = stdgo.go.constant.Constant.float64Val(stdgo.go.constant.Constant.imag(_x)),
						_i:GoFloat64 = __tmp__._0,
						_1:Bool = __tmp__._1;
					return Go.toInterface(new GoComplex128(_r, _i));
				};
				_x = _f;
				@:fallthrough {
					__switchIndex__ = 1;
					continue;
				};
				break;
			} else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && (_x.kind() == (4 : stdgo.go.constant.Constant.Kind)))) {
				var _i:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.toInt(_x);
				if (_i.kind() != ((3 : stdgo.go.constant.Constant.Kind))) {
					var __tmp__ = stdgo.go.constant.Constant.float64Val(_x),
						_v:GoFloat64 = __tmp__._0,
						_2:Bool = __tmp__._1;
					return Go.toInterface(_v);
				};
				_x = _i;
				@:fallthrough {
					__switchIndex__ = 2;
					continue;
				};
				break;
			} else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && (_x.kind() == (3 : stdgo.go.constant.Constant.Kind)))) {
				{
					var __tmp__ = stdgo.go.constant.Constant.int64Val(_x),
						_v:GoInt64 = __tmp__._0,
						_ok:Bool = __tmp__._1;
					if (_ok) {
						return Go.toInterface(_v);
					};
				};
				{
					var __tmp__ = stdgo.go.constant.Constant.uint64Val(_x),
						_v:GoUInt64 = __tmp__._0,
						_ok:Bool = __tmp__._1;
					if (_ok) {
						return Go.toInterface(_v);
					};
				};
				break;
				break;
			} else if (__switchIndex__ == 3 || (__switchIndex__ == -1 && (_x.kind() == (2 : stdgo.go.constant.Constant.Kind)))) {
				return Go.toInterface(stdgo.go.constant.Constant.stringVal(_x));
				break;
				break;
			} else if (__switchIndex__ == 4 || (__switchIndex__ == -1 && (_x.kind() == (1 : stdgo.go.constant.Constant.Kind)))) {
				return Go.toInterface(stdgo.go.constant.Constant.boolVal(_x));
				break;
				break;
			};
			break;
		};
	};
	return Go.toInterface(_x);
}

/**
	// ExprString returns the (possibly shortened) string representation for x.
	// Shortened representations are suitable for user interfaces but may not
	// necessarily follow Go syntax.
**/
function exprString(_x:stdgo.go.ast.Ast.Expr):GoString {
	var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
	writeExpr((_buf : Ref<stdgo.bytes.Bytes.Buffer>), _x);
	return (_buf.string() : GoString);
}

/**
	// WriteExpr writes the (possibly shortened) string representation for x to buf.
	// Shortened representations are suitable for user interfaces but may not
	// necessarily follow Go syntax.
**/
function writeExpr(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _x:stdgo.go.ast.Ast.Expr):Void {
	{
		final __type__ = _x;
		if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ident>))) {
			var _x:Ref<stdgo.go.ast.Ast.Ident> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__()
				.value;
			_buf.writeString(_x.name);
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ellipsis>))) {
			var _x:Ref<stdgo.go.ast.Ast.Ellipsis> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__.__underlying__()
				.value;
			_buf.writeString(("..." : GoString));
			if (_x.elt != null) {
				writeExpr(_buf, _x.elt);
			};
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BasicLit>))) {
			var _x:Ref<stdgo.go.ast.Ast.BasicLit> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BasicLit>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BasicLit>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BasicLit>) : __type__.__underlying__()
				.value;
			_buf.writeString(_x.value);
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.FuncLit>))) {
			var _x:Ref<stdgo.go.ast.Ast.FuncLit> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.FuncLit>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.FuncLit>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.FuncLit>) : __type__.__underlying__()
				.value;
			_buf.writeByte((40 : GoUInt8));
			writeExpr(_buf, Go.asInterface(_x.type));
			_buf.writeString((" literal)" : GoString));
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CompositeLit>))) {
			var _x:Ref<stdgo.go.ast.Ast.CompositeLit> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CompositeLit>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.CompositeLit>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CompositeLit>) : __type__.__underlying__()
				.value;
			_buf.writeByte((40 : GoUInt8));
			writeExpr(_buf, _x.type);
			_buf.writeString((" literal)" : GoString));
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ParenExpr>))) {
			var _x:Ref<stdgo.go.ast.Ast.ParenExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__()
				.value;
			_buf.writeByte((40 : GoUInt8));
			writeExpr(_buf, _x.x);
			_buf.writeByte((41 : GoUInt8));
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectorExpr>))) {
			var _x:Ref<stdgo.go.ast.Ast.SelectorExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__()
				.value;
			writeExpr(_buf, _x.x);
			_buf.writeByte((46 : GoUInt8));
			_buf.writeString(_x.sel.name);
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexExpr>))
			|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexListExpr>))) {
			var _x:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
			var _ix = go.internal.typeparams.Typeparams.unpackIndexExpr(_x);
			writeExpr(_buf, _ix.indexListExpr.x);
			_buf.writeByte((91 : GoUInt8));
			_writeExprList(_buf, _ix.indexListExpr.indices);
			_buf.writeByte((93 : GoUInt8));
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SliceExpr>))) {
			var _x:Ref<stdgo.go.ast.Ast.SliceExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SliceExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SliceExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SliceExpr>) : __type__.__underlying__()
				.value;
			writeExpr(_buf, _x.x);
			_buf.writeByte((91 : GoUInt8));
			if (_x.low != null) {
				writeExpr(_buf, _x.low);
			};
			_buf.writeByte((58 : GoUInt8));
			if (_x.high != null) {
				writeExpr(_buf, _x.high);
			};
			if (_x.slice3) {
				_buf.writeByte((58 : GoUInt8));
				if (_x.max != null) {
					writeExpr(_buf, _x.max);
				};
			};
			_buf.writeByte((93 : GoUInt8));
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.TypeAssertExpr>))) {
			var _x:Ref<stdgo.go.ast.Ast.TypeAssertExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeAssertExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.TypeAssertExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeAssertExpr>) : __type__.__underlying__()
				.value;
			writeExpr(_buf, _x.x);
			_buf.writeString((".(" : GoString));
			writeExpr(_buf, _x.type);
			_buf.writeByte((41 : GoUInt8));
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CallExpr>))) {
			var _x:Ref<stdgo.go.ast.Ast.CallExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CallExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.CallExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CallExpr>) : __type__.__underlying__()
				.value;
			writeExpr(_buf, _x.fun);
			_buf.writeByte((40 : GoUInt8));
			_writeExprList(_buf, _x.args);
			if (_x.ellipsis.isValid()) {
				_buf.writeString(("..." : GoString));
			};
			_buf.writeByte((41 : GoUInt8));
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.StarExpr>))) {
			var _x:Ref<stdgo.go.ast.Ast.StarExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__()
				.value;
			_buf.writeByte((42 : GoUInt8));
			writeExpr(_buf, _x.x);
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.UnaryExpr>))) {
			var _x:Ref<stdgo.go.ast.Ast.UnaryExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__()
				.value;
			_buf.writeString((_x.op.string() : GoString));
			writeExpr(_buf, _x.x);
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BinaryExpr>))) {
			var _x:Ref<stdgo.go.ast.Ast.BinaryExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__()
				.value;
			writeExpr(_buf, _x.x);
			_buf.writeByte((32 : GoUInt8));
			_buf.writeString((_x.op.string() : GoString));
			_buf.writeByte((32 : GoUInt8));
			writeExpr(_buf, _x.y);
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ArrayType>))) {
			var _x:Ref<stdgo.go.ast.Ast.ArrayType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ArrayType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ArrayType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ArrayType>) : __type__.__underlying__()
				.value;
			_buf.writeByte((91 : GoUInt8));
			if (_x.len != null) {
				writeExpr(_buf, _x.len);
			};
			_buf.writeByte((93 : GoUInt8));
			writeExpr(_buf, _x.elt);
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.StructType>))) {
			var _x:Ref<stdgo.go.ast.Ast.StructType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StructType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.StructType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StructType>) : __type__.__underlying__()
				.value;
			_buf.writeString(("struct{" : GoString));
			_writeFieldList(_buf, _x.fields.list, ("; " : GoString), false);
			_buf.writeByte((125 : GoUInt8));
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.FuncType>))) {
			var _x:Ref<stdgo.go.ast.Ast.FuncType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.FuncType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.FuncType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.FuncType>) : __type__.__underlying__()
				.value;
			_buf.writeString(("func" : GoString));
			_writeSigExpr(_buf, _x);
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.InterfaceType>))) {
			var _x:Ref<stdgo.go.ast.Ast.InterfaceType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.InterfaceType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.InterfaceType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.InterfaceType>) : __type__.__underlying__()
				.value;
			_buf.writeString(("interface{" : GoString));
			_writeFieldList(_buf, _x.methods.list, ("; " : GoString), true);
			_buf.writeByte((125 : GoUInt8));
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.MapType>))) {
			var _x:Ref<stdgo.go.ast.Ast.MapType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.MapType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.MapType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.MapType>) : __type__.__underlying__()
				.value;
			_buf.writeString(("map[" : GoString));
			writeExpr(_buf, _x.key);
			_buf.writeByte((93 : GoUInt8));
			writeExpr(_buf, _x.value);
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ChanType>))) {
			var _x:Ref<stdgo.go.ast.Ast.ChanType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ChanType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ChanType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ChanType>) : __type__.__underlying__()
				.value;
			var _s:GoString = ("" : GoString);
			if (_x.dir == ((1 : stdgo.go.ast.Ast.ChanDir))) {
				_s = ("chan<- " : GoString);
			} else if (_x.dir == ((2 : stdgo.go.ast.Ast.ChanDir))) {
				_s = ("<-chan " : GoString);
			} else {
				_s = ("chan " : GoString);
			};
			_buf.writeString(_s);
			writeExpr(_buf, _x.value);
		} else {
			var _x:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
			_buf.writeString(stdgo.fmt.Fmt.sprintf(("(ast: %T)" : GoString), Go.toInterface(_x)));
		};
	};
}

private function _writeSigExpr(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _sig:Ref<stdgo.go.ast.Ast.FuncType>):Void {
	_buf.writeByte((40 : GoUInt8));
	_writeFieldList(_buf, _sig.params.list, (", " : GoString), false);
	_buf.writeByte((41 : GoUInt8));
	var _res = _sig.results;
	var _n:GoInt = _res.numFields();
	if (_n == ((0 : GoInt))) {
		return;
	};
	_buf.writeByte((32 : GoUInt8));
	if ((_n == (1 : GoInt)) && (_res.list[(0 : GoInt)].names.length == (0 : GoInt))) {
		writeExpr(_buf, _res.list[(0 : GoInt)].type);
		return;
	};
	_buf.writeByte((40 : GoUInt8));
	_writeFieldList(_buf, _res.list, (", " : GoString), false);
	_buf.writeByte((41 : GoUInt8));
}

private function _writeFieldList(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _list:Slice<Ref<stdgo.go.ast.Ast.Field>>, _sep:GoString, _iface:Bool):Void {
	for (_i => _f in _list) {
		if (_i > (0 : GoInt)) {
			_buf.writeString(_sep);
		};
		_writeIdentList(_buf, _f.names);
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_f.type) : Ref<stdgo.go.ast.Ast.FuncType>)) : Ref<stdgo.go.ast.Ast.FuncType>), ok: true};
			} catch (_) {
				{value: (null : Ref<stdgo.go.ast.Ast.FuncType>), ok: false};
			}, _sig = __tmp__.value, _0 = __tmp__.ok;
			if ((_sig != null) && _iface) {
				_writeSigExpr(_buf, _sig);
				continue;
			};
		};
		if ((_f.names.length) > (0 : GoInt)) {
			_buf.writeByte((32 : GoUInt8));
		};
		writeExpr(_buf, _f.type);
	};
}

private function _writeIdentList(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _list:Slice<Ref<stdgo.go.ast.Ast.Ident>>):Void {
	for (_i => _x in _list) {
		if (_i > (0 : GoInt)) {
			_buf.writeString((", " : GoString));
		};
		_buf.writeString(_x.name);
	};
}

private function _writeExprList(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _list:Slice<stdgo.go.ast.Ast.Expr>):Void {
	for (_i => _x in _list) {
		if (_i > (0 : GoInt)) {
			_buf.writeString((", " : GoString));
		};
		writeExpr(_buf, _x);
	};
}

/**
	// typeParamsString produces a string containing all the type parameter names
	// in list suitable for human consumption.
**/
private function _typeParamsString(_list:Slice<Ref<TypeParam>>):GoString {
	var _n:GoInt = (_list.length);
	if (_n == ((0 : GoInt))) {
		return Go.str();
	} else if (_n == ((1 : GoInt))) {
		return _list[(0 : GoInt)]._obj._object._name;
	} else if (_n == ((2 : GoInt))) {
		return (_list[(0 : GoInt)]._obj._object._name + (" and " : GoString)) + _list[(1 : GoInt)]._obj._object._name;
	};
	var _b:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
	for (_i => _tname in (_list.__slice__(0, _n - (1 : GoInt)) : Slice<Ref<TypeParam>>)) {
		if (_i > (0 : GoInt)) {
			_b.writeString((", " : GoString));
		};
		_b.writeString(_tname._obj._object._name);
	};
	_b.writeString((", and " : GoString));
	_b.writeString(_list[(_n - (1 : GoInt) : GoInt)]._obj._object._name);
	return (_b.string() : GoString);
}

/**
	// isParameterized reports whether typ contains any of the type parameters of tparams.
**/
private function _isParameterized(_tparams:Slice<Ref<TypeParam>>, _typ:Type):Bool {
	var _w:T_tpWalker = ({_seen: (new GoObjectMap<Type,
		Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
			stdgo.internal.reflect.Reflect.GoType.named("Type", [], null, false, {get: () -> null})},
		{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind)}))) : GoMap<Type, Bool>), _tparams: _tparams} : T_tpWalker);
	return _w._isParameterized(_typ);
}

/**
	// If the type parameter has a single specific type S, coreTerm returns (S, true).
	// Otherwise, if tpar has a core type T, it returns a term corresponding to that
	// core type and false. In that case, if any term of tpar has a tilde, the core
	// term has a tilde. In all other cases coreTerm returns (nil, false).
**/
private function _coreTerm(_tpar:Ref<TypeParam>):{var _0:Ref<T_term>; var _1:Bool;} {
	var _n:GoInt = (0 : GoInt);
	var _single:Ref<T_term> = (null : Ref<T_term>);
	var _tilde:Bool = false;
	_tpar._is(function(_t:Ref<T_term>):Bool {
		if (_t == null) {
			_assert(_n == ((0 : GoInt)));
			return false;
		};
		_n++;
		_single = _t;
		if (_t._tilde) {
			_tilde = true;
		};
		return true;
	});
	if (_n == ((1 : GoInt))) {
		if (false) {
			_assert(false && (Go.toInterface(_under(_single._typ)) == Go.toInterface(_coreType(Go.asInterface(_tpar)))));
		};
		return {_0: _single, _1: true};
	};
	{
		var _typ:Type = _coreType(Go.asInterface(_tpar));
		if (_typ != null) {
			return {_0: ((new T_term(_tilde, _typ) : T_term) : Ref<T_term>), _1: false};
		};
	};
	return {_0: (null : Ref<T_term>), _1: false};
}

/**
	// findPath returns the (reversed) list of objects []Object{to, ... from}
	// such that there is a path of object dependencies from 'from' to 'to'.
	// If there is no such path, the result is nil.
**/
private function _findPath(_objMap:GoMap<Object, Ref<T_declInfo>>, _from:Object, _to:Object, _seen:GoMap<Object, Bool>):Slice<Object> {
	if (_seen[_from]) {
		return (null : Slice<Object>);
	};
	_seen[_from] = true;
	for (_d => _ in _objMap[_from]._deps) {
		if (Go.toInterface(_d) == (Go.toInterface(_to))) {
			return (new Slice<Object>(0, 0, _d) : Slice<Object>);
		};
		{
			var p = _findPath(_objMap, _d, _to, _seen);
			if (p != null) {
				return (p.__append__(_d));
			};
		};
	};
	return (null : Slice<Object>);
}

/**
	// dependencyGraph computes the object dependency graph from the given objMap,
	// with any function nodes removed. The resulting graph contains only constants
	// and variables.
**/
private function _dependencyGraph(_objMap:GoMap<Object, Ref<T_declInfo>>):Slice<Ref<T_graphNode>> {
	var m = (new GoObjectMap<T_dependency, Ref<T_graphNode>>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
		stdgo.internal.reflect.Reflect.GoType.named("T_dependency", [], null, false, {get: () -> null})},
		{get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("T_graphNode", [], null, false,
			{get: () -> null})})}))) : GoMap<T_dependency, Ref<T_graphNode>>);
	for (_obj => _ in _objMap) {
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_obj) : T_dependency)) : T_dependency), ok: true};
			} catch (_) {
				{value: (null : T_dependency), ok: false};
			}, _obj = __tmp__.value, _0 = __tmp__.ok;
			if (_obj != null) {
				m[_obj] = (({_obj: _obj} : T_graphNode) : Ref<T_graphNode>);
			};
		};
	};
	for (_obj => _n in m) {
		for (_d => _ in _objMap[_obj]._deps) {
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_d) : T_dependency)) : T_dependency), ok: true};
				} catch (_) {
					{value: (null : T_dependency), ok: false};
				}, _d = __tmp__.value, _1 = __tmp__.ok;
				if (_d != null) {
					var _d = m[_d];
					_n._succ._add(_d);
					_d._pred._add(_n);
				};
			};
		};
	};
	var _0:Slice<Ref<T_graphNode>> = (null : Slice<Ref<T_graphNode>>),
		_1:Slice<Ref<T_graphNode>> = (null : Slice<Ref<T_graphNode>>),
		_funcG:Slice<Ref<T_graphNode>> = _1,
		g:Slice<Ref<T_graphNode>> = _0;
	for (_2 => _n in m) {
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_n._obj) : Ref<Func>)) : Ref<Func>), ok: true};
			} catch (_) {
				{value: (null : Ref<Func>), ok: false};
			}, _3 = __tmp__.value, _ok = __tmp__.ok;
			if (_ok) {
				_funcG = _funcG.__appendref__(_n);
			} else {
				g = g.__appendref__(_n);
			};
		};
	};
	stdgo.sort.Sort.slice(Go.toInterface(_funcG), function(_i:GoInt, _j:GoInt):Bool {
		return _funcG[(_i : GoInt)]._cost() < _funcG[(_j : GoInt)]._cost();
	});
	for (_4 => _n in _funcG) {
		for (_p => _ in _n._pred) {
			if (_p != (_n)) {
				for (_s => _ in _n._succ) {
					if (_s != (_n)) {
						_p._succ._add(_s);
						_s._pred._add(_p);
					};
				};
				if (_p._succ != null)
					_p._succ.__remove__(_n);
			};
		};
		for (_s => _ in _n._succ) {
			if (_s._pred != null)
				_s._pred.__remove__(_n);
		};
	};
	for (_i => _n in g) {
		_n._index = _i;
		_n._ndeps = (_n._succ.length);
	};
	return g;
}

/**
	// Instantiate instantiates the type orig with the given type arguments targs.
	// orig must be a *Named or a *Signature type. If there is no error, the
	// resulting Type is an instantiated type of the same kind (either a *Named or
	// a *Signature). Methods attached to a *Named type are also instantiated, and
	// associated with a new *Func that has the same position as the original
	// method, but nil function scope.
	//
	// If ctxt is non-nil, it may be used to de-duplicate the instance against
	// previous instances with the same identity. As a special case, generic
	// *Signature origin types are only considered identical if they are pointer
	// equivalent, so that instantiating distinct (but possibly identical)
	// signatures will yield different instances. The use of a shared context does
	// not guarantee that identical instances are deduplicated in all cases.
	//
	// If validate is set, Instantiate verifies that the number of type arguments
	// and parameters match, and that the type arguments satisfy their
	// corresponding type constraints. If verification fails, the resulting error
	// may wrap an *ArgumentError indicating which type argument did not satisfy
	// its corresponding type parameter constraint, and why.
	//
	// If validate is not set, Instantiate does not verify the type argument count
	// or whether the type arguments satisfy their constraints. Instantiate is
	// guaranteed to not return an error, but may panic. Specifically, for
	// *Signature types, Instantiate will panic immediately if the type argument
	// count is incorrect; for *Named types, a panic may occur later inside the
	// *Named API.
**/
function instantiate(_ctxt:Ref<Context>, _orig:Type, _targs:Slice<Type>, _validate:Bool):{var _0:Type; var _1:Error;} {
	if (_ctxt == null) {
		_ctxt = newContext();
	};
	if (_validate) {
		var _tparams:Slice<Ref<TypeParam>> = (null : Slice<Ref<TypeParam>>);
		{
			final __type__ = _orig;
			if (Go.typeEquals((__type__ : Ref<Named>))) {
				var _t:Ref<Named> = __type__ == null ? (null : Ref<Named>) : __type__.__underlying__() == null ? (null : Ref<Named>) : __type__ == null ? (null : Ref<Named>) : __type__.__underlying__()
					.value;
				_tparams = _t.typeParams()._list();
			} else if (Go.typeEquals((__type__ : Ref<Signature>))) {
				var _t:Ref<Signature> = __type__ == null ? (null : Ref<Signature>) : __type__.__underlying__() == null ? (null : Ref<Signature>) : __type__ == null ? (null : Ref<Signature>) : __type__.__underlying__()
					.value;
				_tparams = _t.typeParams()._list();
			};
		};
		if ((_targs.length) != ((_tparams.length))) {
			return {_0: (null : Type), _1: stdgo.fmt.Fmt.errorf(("got %d type arguments but %s has %d type parameters" : GoString),
				Go.toInterface((_targs.length)), Go.toInterface(_orig), Go.toInterface((_tparams.length)))};
		};
		{
			var __tmp__ = (null : Ref<Checker>)._verify((0 : stdgo.go.token.Token.Pos), _tparams, _targs, _ctxt),
				_i:GoInt = __tmp__._0,
				_err:Error = __tmp__._1;
			if (_err != null) {
				return {_0: (null : Type), _1: Go.asInterface(((new ArgumentError(_i, _err) : ArgumentError) : Ref<ArgumentError>))};
			};
		};
	};
	var _inst:Type = (null : Ref<Checker>)._instance((0 : stdgo.go.token.Token.Pos), _orig, _targs, null, _ctxt);
	return {_0: _inst, _1: (null : Error)};
}

/**
	// NewInterface returns a new interface for the given methods and embedded types.
	// NewInterface takes ownership of the provided methods and may modify their types
	// by setting missing receivers.
	//
	// Deprecated: Use NewInterfaceType instead which allows arbitrary embedded types.
**/
function newInterface(_methods:Slice<Ref<Func>>, _embeddeds:Slice<Ref<Named>>):Ref<Interface> {
	var _tnames = new Slice<Type>((_embeddeds.length : GoInt).toBasic(), 0, ...[for (i in 0...(_embeddeds.length : GoInt).toBasic()) (null : Type)]);
	for (_i => _t in _embeddeds) {
		_tnames[(_i : GoInt)] = Go.asInterface(_t);
	};
	return newInterfaceType(_methods, _tnames);
}

/**
	// NewInterfaceType returns a new interface for the given methods and embedded
	// types. NewInterfaceType takes ownership of the provided methods and may
	// modify their types by setting missing receivers.
	//
	// To avoid race conditions, the interface's type set should be computed before
	// concurrent use of the interface, by explicitly calling Complete.
**/
function newInterfaceType(_methods:Slice<Ref<Func>>, _embeddeds:Slice<Type>):Ref<Interface> {
	if ((_methods.length == (0 : GoInt)) && (_embeddeds.length == (0 : GoInt))) {
		return (_emptyInterface : Ref<Interface>);
	};
	var _typ = (null : Ref<Checker>)._newInterface();
	for (_0 => _m in _methods) {
		{
			var _sig = (Go.typeAssert((Go.toInterface(_m._object._typ) : Ref<Signature>)) : Ref<Signature>);
			if (_sig._recv == null) {
				_sig._recv = newVar(_m._object._pos, _m._object._pkg, Go.str(), Go.asInterface(_typ));
			};
		};
	};
	_sortMethods(_methods);
	_typ._methods = _methods;
	_typ._embeddeds = _embeddeds;
	_typ._complete = true;
	return _typ;
}

/**
	// LookupFieldOrMethod looks up a field or method with given package and name
	// in T and returns the corresponding *Var or *Func, an index sequence, and a
	// bool indicating if there were any pointer indirections on the path to the
	// field or method. If addressable is set, T is the type of an addressable
	// variable (only matters for method lookups). T must not be nil.
	//
	// The last index entry is the field or method index in the (possibly embedded)
	// type where the entry was found, either:
	//
	//  1. the list of declared methods of a named type; or
	//  2. the list of all methods (method set) of an interface type; or
	//  3. the list of fields of a struct type.
	//
	// The earlier index entries are the indices of the embedded struct fields
	// traversed to get to the found entry, starting at depth 0.
	//
	// If no entry is found, a nil object is returned. In this case, the returned
	// index and indirect values have the following meaning:
	//
	//   - If index != nil, the index sequence points to an ambiguous entry
	//     (the same name appeared more than once at the same embedding level).
	//
	//   - If indirect is set, a method with a pointer receiver type was found
	//     but there was no pointer on the path from the actual receiver type to
	//     the method's formal receiver base type, nor was the receiver addressable.
**/
function lookupFieldOrMethod(t:Type, _addressable:Bool, _pkg:Ref<Package>, _name:GoString):{var _0:Object; var _1:Slice<GoInt>; var _2:Bool;} {
	var _obj:Object = (null : Object),
		_index:Slice<GoInt> = (null : Slice<GoInt>),
		_indirect:Bool = false;
	if (t == null) {
		throw Go.toInterface(("LookupFieldOrMethod on nil type" : GoString));
	};
	{
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(t) : Ref<Named>)) : Ref<Named>), ok: true};
		} catch (_) {
			{value: (null : Ref<Named>), ok: false};
		}, _t = __tmp__.value, _0 = __tmp__.ok;
		if (_t != null) {
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_t.underlying()) : Ref<Pointer_>)) : Ref<Pointer_>), ok: true};
				} catch (_) {
					{value: (null : Ref<Pointer_>), ok: false};
				}, _p = __tmp__.value, _1 = __tmp__.ok;
				if (_p != null) {
					{
						var __tmp__ = _lookupFieldOrMethod(Go.asInterface(_p), false, _pkg, _name, false);
						_obj = __tmp__._0;
						_index = __tmp__._1;
						_indirect = __tmp__._2;
					};
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_obj) : Ref<Func>)) : Ref<Func>), ok: true};
						} catch (_) {
							{value: (null : Ref<Func>), ok: false};
						}, _2 = __tmp__.value, _ok = __tmp__.ok;
						if (_ok) {
							return {_0: (null : Object), _1: (null : Slice<GoInt>), _2: false};
						};
					};
					return {_0: _obj, _1: _index, _2: _indirect};
				};
			};
		};
	};
	{
		var __tmp__ = _lookupFieldOrMethod(t, _addressable, _pkg, _name, false);
		_obj = __tmp__._0;
		_index = __tmp__._1;
		_indirect = __tmp__._2;
	};
	{};
	if ((false && (_obj == null)) && _isTypeParam(t)) {
		{
			var _t:Type = _coreType(t);
			if (_t != null) {
				{
					var __tmp__ = _lookupFieldOrMethod(_t, _addressable, _pkg, _name, false);
					_obj = __tmp__._0;
					_index = __tmp__._1;
					_indirect = __tmp__._2;
				};
				{
					var __tmp__ = try {
						{value: (Go.typeAssert((Go.toInterface(_obj) : Ref<Var>)) : Ref<Var>), ok: true};
					} catch (_) {
						{value: (null : Ref<Var>), ok: false};
					}, _3 = __tmp__.value, _ok = __tmp__.ok;
					if (!_ok) {
						{
							final __tmp__0 = (null : Object);
							final __tmp__1 = (null : Slice<GoInt>);
							final __tmp__2 = false;
							_obj = __tmp__0;
							_index = __tmp__1;
							_indirect = __tmp__2;
						};
					};
				};
			};
		};
	};
	return {_0: _obj, _1: _index, _2: _indirect};
}

/**
	// lookupFieldOrMethod should only be called by LookupFieldOrMethod and missingMethod.
	// If foldCase is true, the lookup for methods will include looking for any method
	// which case-folds to the same as 'name' (used for giving helpful error messages).
	//
	// The resulting object may not be fully type-checked.
**/
private function _lookupFieldOrMethod(t:Type, _addressable:Bool, _pkg:Ref<Package>, _name:GoString,
		_foldCase:Bool):{var _0:Object; var _1:Slice<GoInt>; var _2:Bool;} {
	var _obj:Object = (null : Object),
		_index:Slice<GoInt> = (null : Slice<GoInt>),
		_indirect:Bool = false;
	if (_name == (("_" : GoString))) {
		return {_0: _obj, _1: _index, _2: _indirect};
	};
	var __tmp__ = _deref(t), _typ:Type = __tmp__._0, _isPtr:Bool = __tmp__._1;
	if (_isPtr) {
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Interface>)) : Ref<Interface>), ok: true};
			} catch (_) {
				{value: (null : Ref<Interface>), ok: false};
			}, _0 = __tmp__.value, _ok = __tmp__.ok;
			if (_ok) {
				return {_0: _obj, _1: _index, _2: _indirect};
			};
		};
	};
	var _current = (new Slice<T_embeddedType>(0, 0,
		(new T_embeddedType(_typ, (null : Slice<GoInt>), _isPtr, false) : T_embeddedType)) : Slice<T_embeddedType>);
	var _seen:T_instanceLookup = ({} : T_instanceLookup);
	while ((_current.length) > (0 : GoInt)) {
		var _next:Slice<T_embeddedType> = (null : Slice<T_embeddedType>);
		for (_1 => _e in _current) {
			var _typ:Type = _e._typ;
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_typ) : Ref<Named>)) : Ref<Named>), ok: true};
				} catch (_) {
					{value: (null : Ref<Named>), ok: false};
				}, _named = __tmp__.value, _2 = __tmp__.ok;
				if (_named != null) {
					{
						var _alt = _seen._lookup(_named);
						if (_alt != null) {
							continue;
						};
					};
					_seen._add(_named);
					{
						var __tmp__ = _named._lookupMethod(_pkg, _name, _foldCase),
							_i:GoInt = __tmp__._0,
							_m:Ref<Func> = __tmp__._1;
						if (_m != null) {
							_index = _concat(_e._index, _i);
							if ((_obj != null) || _e._multiples) {
								return {_0: (null : Object), _1: _index, _2: false};
							};
							_obj = Go.asInterface(_m);
							_indirect = _e._indirect;
							continue;
						};
					};
				};
			};
			{
				final __type__ = _under(_typ);
				if (Go.typeEquals((__type__ : Ref<Struct>))) {
					var _t:Ref<Struct> = __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__() == null ? (null : Ref<Struct>) : __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__()
						.value;
					for (_i => _f in _t._fields) {
						if (_f._sameId(_pkg, _name)) {
							_assert(_f._object._typ != null);
							_index = _concat(_e._index, _i);
							if ((_obj != null) || _e._multiples) {
								return {_0: (null : Object), _1: _index, _2: false};
							};
							_obj = Go.asInterface(_f);
							_indirect = _e._indirect;
							continue;
						};
						if ((_obj == null) && _f._embedded) {
							var __tmp__ = _deref(_f._object._typ),
								_typ:Type = __tmp__._0,
								_isPtr:Bool = __tmp__._1;
							_next = _next.__appendref__((new T_embeddedType(_typ, _concat(_e._index, _i), _e._indirect || _isPtr,
								_e._multiples) : T_embeddedType));
						};
					};
				} else if (Go.typeEquals((__type__ : Ref<Interface>))) {
					var _t:Ref<Interface> = __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__() == null ? (null : Ref<Interface>) : __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__()
						.value;
					{
						var __tmp__ = _t._typeSet().lookupMethod(_pkg, _name, _foldCase),
							_i:GoInt = __tmp__._0,
							_m:Ref<Func> = __tmp__._1;
						if (_m != null) {
							_assert(_m._object._typ != null);
							_index = _concat(_e._index, _i);
							if ((_obj != null) || _e._multiples) {
								return {_0: (null : Object), _1: _index, _2: false};
							};
							_obj = Go.asInterface(_m);
							_indirect = _e._indirect;
						};
					};
				};
			};
		};
		if (_obj != null) {
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_obj) : Ref<Func>)) : Ref<Func>), ok: true};
				} catch (_) {
					{value: (null : Ref<Func>), ok: false};
				}, _f = __tmp__.value, _3 = __tmp__.ok;
				if (_f != null) {
					if ((_f._hasPtrRecv() && !_indirect) && !_addressable) {
						return {_0: (null : Object), _1: (null : Slice<GoInt>), _2: true};
					};
				};
			};
			return {_0: _obj, _1: _index, _2: _indirect};
		};
		_current = _consolidateMultiples(_next);
	};
	return {_0: (null : Object), _1: (null : Slice<GoInt>), _2: false};
}

/**
	// consolidateMultiples collects multiple list entries with the same type
	// into a single entry marked as containing multiples. The result is the
	// consolidated list.
**/
private function _consolidateMultiples(_list:Slice<T_embeddedType>):Slice<T_embeddedType> {
	if ((_list.length) <= (1 : GoInt)) {
		return _list;
	};
	var _n:GoInt = (0 : GoInt);
	var _prev = (new GoObjectMap<Type, GoInt>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
		stdgo.internal.reflect.Reflect.GoType.named("Type", [], null, false, {get: () -> null})},
		{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(int_kind)}))) : GoMap<Type, GoInt>);
	for (_0 => _e in _list) {
		{
			var __tmp__ = _lookupType(_prev, _e._typ),
				_i:GoInt = __tmp__._0,
				_found:Bool = __tmp__._1;
			if (_found) {
				_list[(_i : GoInt)]._multiples = true;
			} else {
				_prev[_e._typ] = _n;
				_list[(_n : GoInt)] = (_e == null ? null : _e.__copy__());
				_n++;
			};
		};
	};
	return (_list.__slice__(0, _n) : Slice<T_embeddedType>);
}

private function _lookupType(_m:GoMap<Type, GoInt>, _typ:Type):{var _0:GoInt; var _1:Bool;} {
	{
		var __tmp__ = (_m != null && _m.__exists__(_typ) ? {value: _m[_typ], ok: true} : {value: (0 : GoInt), ok: false}),
			_i:GoInt = __tmp__.value,
			_found:Bool = __tmp__.ok;
		if (_found) {
			return {_0: _i, _1: true};
		};
	};
	for (_t => _i in _m) {
		if (identical(_t, _typ)) {
			return {_0: _i, _1: true};
		};
	};
	return {_0: (0 : GoInt), _1: false};
}

/**
	// MissingMethod returns (nil, false) if V implements T, otherwise it
	// returns a missing method required by T and whether it is missing or
	// just has the wrong type.
	//
	// For non-interface types V, or if static is set, V implements T if all
	// methods of T are present in V. Otherwise (V is an interface and static
	// is not set), MissingMethod only checks that methods of T which are also
	// present in V have matching types (e.g., for a type assertion x.(T) where
	// x is of interface type V).
**/
function missingMethod(v:Type, t:Ref<Interface>, _static:Bool):{var _0:Ref<Func>; var _1:Bool;} {
	var _method:Ref<Func> = (null : Ref<Func>), _wrongType:Bool = false;
	var __tmp__ = (null : Ref<Checker>)._missingMethod(v, t, _static),
		_m:Ref<Func> = __tmp__._0,
		_alt:Ref<Func> = __tmp__._1;
	return {_0: _m, _1: (_alt != null) && (_alt._object._name == _m._object._name)};
}

private function _isInterfacePtr(t:Type):Bool {
	var __tmp__ = try {
		{value: (Go.typeAssert((Go.toInterface(_under(t)) : Ref<Pointer_>)) : Ref<Pointer_>), ok: true};
	} catch (_) {
		{value: (null : Ref<Pointer_>), ok: false};
	}, _p = __tmp__.value, _0 = __tmp__.ok;
	return (_p != null) && isInterface(_p._base);
}

/**
	// deref dereferences typ if it is a *Pointer and returns its base and true.
	// Otherwise it returns (typ, false).
**/
private function _deref(_typ:Type):{var _0:Type; var _1:Bool;} {
	{
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_typ) : Ref<Pointer_>)) : Ref<Pointer_>), ok: true};
		} catch (_) {
			{value: (null : Ref<Pointer_>), ok: false};
		}, _p = __tmp__.value, _0 = __tmp__.ok;
		if (_p != null) {
			if (_p._base == null) {
				if (false) {
					throw Go.toInterface(("pointer with nil base type (possibly due to an invalid cyclic declaration)" : GoString));
				};
				return {_0: Go.asInterface(typ[((0 : BasicKind) : GoInt)]), _1: true};
			};
			return {_0: _p._base, _1: true};
		};
	};
	return {_0: _typ, _1: false};
}

/**
	// derefStructPtr dereferences typ if it is a (named or unnamed) pointer to a
	// (named or unnamed) struct and returns its base. Otherwise it returns typ.
**/
private function _derefStructPtr(_typ:Type):Type {
	{
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Pointer_>)) : Ref<Pointer_>), ok: true};
		} catch (_) {
			{value: (null : Ref<Pointer_>), ok: false};
		}, _p = __tmp__.value, _0 = __tmp__.ok;
		if (_p != null) {
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_under(_p._base)) : Ref<Struct>)) : Ref<Struct>), ok: true};
				} catch (_) {
					{value: (null : Ref<Struct>), ok: false};
				}, _1 = __tmp__.value, _ok = __tmp__.ok;
				if (_ok) {
					return _p._base;
				};
			};
		};
	};
	return _typ;
}

/**
	// concat returns the result of concatenating list and i.
	// The result does not share its underlying array with list.
**/
private function _concat(_list:Slice<GoInt>, _i:GoInt):Slice<GoInt> {
	var _t:Slice<GoInt> = (null : Slice<GoInt>);
	_t = _t.__appendref__(..._list.__toArray__());
	return (_t.__append__(_i));
}

/**
	// fieldIndex returns the index for the field with matching package and name, or a value < 0.
**/
private function _fieldIndex(_fields:Slice<Ref<Var>>, _pkg:Ref<Package>, _name:GoString):GoInt {
	if (_name != (("_" : GoString))) {
		for (_i => _f in _fields) {
			if (_f._sameId(_pkg, _name)) {
				return _i;
			};
		};
	};
	return (-1 : GoInt);
}

/**
	// lookupMethod returns the index of and method with matching package and name, or (-1, nil).
	// If foldCase is true, method names are considered equal if they are equal with case folding.
**/
private function _lookupMethod(_methods:Slice<Ref<Func>>, _pkg:Ref<Package>, _name:GoString, _foldCase:Bool):{var _0:GoInt; var _1:Ref<Func>;} {
	if (_name != (("_" : GoString))) {
		for (_i => _m in _methods) {
			if (((_m._object._name == _name) || (_foldCase && stdgo.strings.Strings.equalFold(_m._object._name, _name)))
				&& _m._sameId(_pkg, _m._object._name)) {
				return {_0: _i, _1: _m};
			};
		};
	};
	return {_0: (-1 : GoInt), _1: null};
}

/**
	// NewMap returns a new map for the given key and element types.
**/
function newMap(_key:Type, _elem:Type):Ref<Map_> {
	return (({_key: _key, _elem: _elem} : Map_) : Ref<Map_>);
}

/**
	// NewMethodSet returns the method set for the given type T.
	// It always returns a non-nil method set, even if it is empty.
**/
function newMethodSet(t:Type):Ref<MethodSet> {
	var _base:T_methodSet = (null : T_methodSet);
	var __tmp__ = _deref(t), _typ:Type = __tmp__._0, _isPtr:Bool = __tmp__._1;
	if (_isPtr && isInterface(_typ)) {
		return (_emptyMethodSet : Ref<MethodSet>);
	};
	var _current = (new Slice<T_embeddedType>(0, 0,
		(new T_embeddedType(_typ, (null : Slice<GoInt>), _isPtr, false) : T_embeddedType)) : Slice<T_embeddedType>);
	var _seen:T_instanceLookup = ({} : T_instanceLookup);
	while ((_current.length) > (0 : GoInt)) {
		var _next:Slice<T_embeddedType> = (null : Slice<T_embeddedType>);
		var _fset:GoMap<GoString, Bool> = (null : GoMap<GoString, Bool>);
		var _mset:T_methodSet = (null : T_methodSet);
		for (_0 => _e in _current) {
			var _typ:Type = _e._typ;
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_typ) : Ref<Named>)) : Ref<Named>), ok: true};
				} catch (_) {
					{value: (null : Ref<Named>), ok: false};
				}, _named = __tmp__.value, _1 = __tmp__.ok;
				if (_named != null) {
					{
						var _alt = _seen._lookup(_named);
						if (_alt != null) {
							continue;
						};
					};
					_seen._add(_named);
					{
						var _i:GoInt = (0 : GoInt);
						Go.cfor(_i < _named.numMethods(), _i++, {
							_mset = _mset._addOne(_named.method(_i), _concat(_e._index, _i), _e._indirect, _e._multiples);
						});
					};
				};
			};
			{
				final __type__ = _under(_typ);
				if (Go.typeEquals((__type__ : Ref<Struct>))) {
					var _t:Ref<Struct> = __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__() == null ? (null : Ref<Struct>) : __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__()
						.value;
					for (_i => _f in _t._fields) {
						if (_fset == null) {
							_fset = (new GoObjectMap<GoString,
								Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
									stdgo.internal.reflect.Reflect.GoType.basic(string_kind)},
								{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind)}))) : GoMap<GoString, Bool>);
						};
						_fset[_f.id()] = true;
						if (_f._embedded) {
							var __tmp__ = _deref(_f._object._typ),
								_typ:Type = __tmp__._0,
								_isPtr:Bool = __tmp__._1;
							_next = _next.__appendref__((new T_embeddedType(_typ, _concat(_e._index, _i), _e._indirect || _isPtr,
								_e._multiples) : T_embeddedType));
						};
					};
				} else if (Go.typeEquals((__type__ : Ref<Interface>))) {
					var _t:Ref<Interface> = __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__() == null ? (null : Ref<Interface>) : __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__()
						.value;
					_mset = _mset._add(_t._typeSet()._methods, _e._index, true, _e._multiples);
				};
			};
		};
		for (_k => _m in _mset) {
			{
				var __tmp__ = (_base != null
					&& _base.__exists__(_k) ? {value: _base[_k], ok: true} : {value: (null : Ref<Selection>), ok: false}),
					_2:Ref<Selection> = __tmp__.value,
					_found:Bool = __tmp__.ok;
				if (!_found) {
					if (_fset[_k]) {
						_m = null;
					};
					if (_base == null) {
						_base = (new GoObjectMap<GoString,
							Ref<Selection>>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("T_methodSet", [], null,
								false, {
							get: () -> null
						}))) : T_methodSet);
					};
					_base[_k] = _m;
				};
			};
		};
		for (_k => _ in _fset) {
			{
				var __tmp__ = (_base != null
					&& _base.__exists__(_k) ? {value: _base[_k], ok: true} : {value: (null : Ref<Selection>), ok: false}),
					_3:Ref<Selection> = __tmp__.value,
					_found:Bool = __tmp__.ok;
				if (!_found) {
					if (_base == null) {
						_base = (new GoObjectMap<GoString,
							Ref<Selection>>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("T_methodSet", [], null,
								false, {
							get: () -> null
						}))) : T_methodSet);
					};
					_base[_k] = null;
				};
			};
		};
		_current = _consolidateMultiples(_next);
	};
	if ((_base.length) == ((0 : GoInt))) {
		return (_emptyMethodSet : Ref<MethodSet>);
	};
	var _list:Slice<Ref<Selection>> = (null : Slice<Ref<Selection>>);
	for (_4 => _m in _base) {
		if (_m != null) {
			_m._recv = t;
			_list = _list.__appendref__(_m);
		};
	};
	stdgo.sort.Sort.slice(Go.toInterface(_list), function(_i:GoInt, _j:GoInt):Bool {
		return _list[(_i : GoInt)]._obj.id() < _list[(_j : GoInt)]._obj.id();
	});
	return ((new MethodSet(_list) : MethodSet) : Ref<MethodSet>);
}

/**
	// NewNamed returns a new named type for the given type name, underlying type, and associated methods.
	// If the given type name obj doesn't have a type yet, its type is set to the returned named type.
	// The underlying type must not be a *Named.
**/
function newNamed(_obj:Ref<TypeName>, _underlying:Type, _methods:Slice<Ref<Func>>):Ref<Named> {
	{
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_underlying) : Ref<Named>)) : Ref<Named>), ok: true};
		} catch (_) {
			{value: (null : Ref<Named>), ok: false};
		}, _0 = __tmp__.value, _ok = __tmp__.ok;
		if (_ok) {
			throw Go.toInterface(("underlying type must not be *Named" : GoString));
		};
	};
	return (null : Ref<Checker>)._newNamed(_obj, _underlying, _methods);
}

/**
	// safeUnderlying returns the underlying type of typ without expanding
	// instances, to avoid infinite recursion.
	//
	// TODO(rfindley): eliminate this function or give it a better name.
**/
private function _safeUnderlying(_typ:Type):Type {
	{
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_typ) : Ref<Named>)) : Ref<Named>), ok: true};
		} catch (_) {
			{value: (null : Ref<Named>), ok: false};
		}, _t = __tmp__.value, _0 = __tmp__.ok;
		if (_t != null) {
			return _t._underlying;
		};
	};
	return _typ.underlying();
}

/**
	// Id returns name if it is exported, otherwise it
	// returns the name qualified with the package path.
**/
function id(_pkg:Ref<Package>, _name:GoString):GoString {
	if (stdgo.go.token.Token.isExported(_name)) {
		return _name;
	};
	var _path:GoString = ("_" : GoString);
	if ((_pkg != null) && (_pkg._path != Go.str())) {
		_path = _pkg._path;
	};
	return (_path + ("." : GoString)) + _name;
}

/**
	// colorFor returns the (initial) color for an object depending on
	// whether its type t is known or not.
**/
private function _colorFor(_t:Type):T_color {
	if (_t != null) {
		return (("1" : GoUInt32) : T_color);
	};
	return (("0" : GoUInt32) : T_color);
}

/**
	// NewPkgName returns a new PkgName object representing an imported package.
	// The remaining arguments set the attributes found with all Objects.
**/
function newPkgName(_pos:stdgo.go.token.Token.Pos, _pkg:Ref<Package>, _name:GoString, _imported:Ref<Package>):Ref<PkgName> {
	return ((new PkgName((new T_object(null, _pos, _pkg, _name, Go.asInterface(typ[((0 : BasicKind) : GoInt)]), ("0" : GoUInt32),
		(("1" : GoUInt32) : T_color), (0 : stdgo.go.token.Token.Pos)) : T_object),
		_imported, false) : PkgName) : Ref<PkgName>);
}

/**
	// NewConst returns a new constant with value val.
	// The remaining arguments set the attributes found with all Objects.
**/
function newConst(_pos:stdgo.go.token.Token.Pos, _pkg:Ref<Package>, _name:GoString, _typ:Type, _val:stdgo.go.constant.Constant.Value):Ref<Const> {
	return ((new Const((new T_object(null, _pos, _pkg, _name, _typ, ("0" : GoUInt32), _colorFor(_typ), (0 : stdgo.go.token.Token.Pos)) : T_object),
		_val) : Const) : Ref<Const>);
}

/**
	// NewTypeName returns a new type name denoting the given typ.
	// The remaining arguments set the attributes found with all Objects.
	//
	// The typ argument may be a defined (Named) type or an alias type.
	// It may also be nil such that the returned TypeName can be used as
	// argument for NewNamed, which will set the TypeName's type as a side-
	// effect.
**/
function newTypeName(_pos:stdgo.go.token.Token.Pos, _pkg:Ref<Package>, _name:GoString, _typ:Type):Ref<TypeName> {
	return ((new TypeName((new T_object(null, _pos, _pkg, _name, _typ, ("0" : GoUInt32), _colorFor(_typ),
		(0 : stdgo.go.token.Token.Pos)) : T_object)) : TypeName) : Ref<TypeName>);
}

/**
	// _NewTypeNameLazy returns a new defined type like NewTypeName, but it
	// lazily calls resolve to finish constructing the Named object.
**/
private function __NewTypeNameLazy(_pos:stdgo.go.token.Token.Pos, _pkg:Ref<Package>, _name:GoString, _load:(_named:Ref<Named>) -> {
	var _0:Slice<Ref<TypeParam>>;
	var _1:Type;
	var _2:Slice<Ref<Func>>;
}):Ref<TypeName> {
	var _obj = newTypeName(_pos, _pkg, _name, (null : Type));
	newNamed(_obj, (null : Type), (null : Slice<Ref<Func>>))._loader = _load;
	return _obj;
}

/**
	// NewVar returns a new variable.
	// The arguments set the attributes found with all Objects.
**/
function newVar(_pos:stdgo.go.token.Token.Pos, _pkg:Ref<Package>, _name:GoString, _typ:Type):Ref<Var> {
	return (({_object: (new T_object(null, _pos, _pkg, _name, _typ, ("0" : GoUInt32), _colorFor(_typ),
		(0 : stdgo.go.token.Token.Pos)) : T_object)} : Var) : Ref<Var>);
}

/**
	// NewParam returns a new variable representing a function parameter.
**/
function newParam(_pos:stdgo.go.token.Token.Pos, _pkg:Ref<Package>, _name:GoString, _typ:Type):Ref<Var> {
	return (({_object: (new T_object(null, _pos, _pkg, _name, _typ, ("0" : GoUInt32), _colorFor(_typ),
		(0 : stdgo.go.token.Token.Pos)) : T_object), _used: true} : Var) : Ref<Var>);
}

/**
	// NewField returns a new variable representing a struct field.
	// For embedded fields, the name is the unqualified type name
	// under which the field is accessible.
**/
function newField(_pos:stdgo.go.token.Token.Pos, _pkg:Ref<Package>, _name:GoString, _typ:Type, _embedded:Bool):Ref<Var> {
	return (({_object: (new T_object(null, _pos, _pkg, _name, _typ, ("0" : GoUInt32), _colorFor(_typ),
		(0 : stdgo.go.token.Token.Pos)) : T_object), _embedded: _embedded, _isField: true} : Var) : Ref<Var>);
}

/**
	// NewFunc returns a new function with the given signature, representing
	// the function's type.
**/
function newFunc(_pos:stdgo.go.token.Token.Pos, _pkg:Ref<Package>, _name:GoString, _sig:Ref<Signature>):Ref<Func> {
	var _typ:Type = (null : Type);
	if (_sig != null) {
		_typ = Go.asInterface(_sig);
	};
	return ((new Func((new T_object(null, _pos, _pkg, _name, _typ, ("0" : GoUInt32), _colorFor(_typ), (0 : stdgo.go.token.Token.Pos)) : T_object), false,
		null) : Func) : Ref<Func>);
}

/**
	// NewLabel returns a new label.
**/
function newLabel(_pos:stdgo.go.token.Token.Pos, _pkg:Ref<Package>, _name:GoString):Ref<Label> {
	return ((new Label(({
		_pos: _pos,
		_pkg: _pkg,
		_name: _name,
		_typ: Go.asInterface(typ[((0 : BasicKind) : GoInt)]),
		_color_: (("1" : GoUInt32) : T_color)
	} : T_object), false) : Label) : Ref<Label>);
}

private function _newBuiltin(_id:T_builtinId):Ref<Builtin> {
	return ((new Builtin(({_name: _predeclaredFuncs[(_id : GoInt)]._name, _typ: Go.asInterface(typ[((0 : BasicKind) : GoInt)]),
		_color_: (("1" : GoUInt32) : T_color)} : T_object),
		_id) : Builtin) : Ref<Builtin>);
}

private function _writeObject(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _obj:Object, _qf:Qualifier):Void {
	var _tname:Ref<TypeName> = (null : Ref<TypeName>);
	var _typ:Type = _obj.type();
	{
		final __type__ = _obj;
		if (Go.typeEquals((__type__ : Ref<PkgName>))) {
			var _obj:Ref<PkgName> = __type__ == null ? (null : Ref<PkgName>) : __type__.__underlying__() == null ? (null : Ref<PkgName>) : __type__ == null ? (null : Ref<PkgName>) : __type__.__underlying__()
				.value;
			stdgo.fmt.Fmt.fprintf(Go.asInterface(_buf), ("package %s" : GoString), Go.toInterface(_obj.name()));
			{
				var _path:GoString = _obj._imported._path;
				if ((_path != Go.str()) && (_path != _obj._object._name)) {
					stdgo.fmt.Fmt.fprintf(Go.asInterface(_buf), (" (%q)" : GoString), Go.toInterface(_path));
				};
			};
			return;
		} else if (Go.typeEquals((__type__ : Ref<Const>))) {
			var _obj:Ref<Const> = __type__ == null ? (null : Ref<Const>) : __type__.__underlying__() == null ? (null : Ref<Const>) : __type__ == null ? (null : Ref<Const>) : __type__.__underlying__()
				.value;
			_buf.writeString(("const" : GoString));
		} else if (Go.typeEquals((__type__ : Ref<TypeName>))) {
			var _obj:Ref<TypeName> = __type__ == null ? (null : Ref<TypeName>) : __type__.__underlying__() == null ? (null : Ref<TypeName>) : __type__ == null ? (null : Ref<TypeName>) : __type__.__underlying__()
				.value;
			_tname = _obj;
			_buf.writeString(("type" : GoString));
			if (_isTypeParam(_typ)) {
				_buf.writeString((" parameter" : GoString));
			};
		} else if (Go.typeEquals((__type__ : Ref<Var>))) {
			var _obj:Ref<Var> = __type__ == null ? (null : Ref<Var>) : __type__.__underlying__() == null ? (null : Ref<Var>) : __type__ == null ? (null : Ref<Var>) : __type__.__underlying__()
				.value;
			if (_obj._isField) {
				_buf.writeString(("field" : GoString));
			} else {
				_buf.writeString(("var" : GoString));
			};
		} else if (Go.typeEquals((__type__ : Ref<Func>))) {
			var _obj:Ref<Func> = __type__ == null ? (null : Ref<Func>) : __type__.__underlying__() == null ? (null : Ref<Func>) : __type__ == null ? (null : Ref<Func>) : __type__.__underlying__()
				.value;
			_buf.writeString(("func " : GoString));
			_writeFuncName(_buf, _obj, _qf);
			if (_typ != null) {
				writeSignature(_buf, (Go.typeAssert((Go.toInterface(_typ) : Ref<Signature>)) : Ref<Signature>), _qf);
			};
			return;
		} else if (Go.typeEquals((__type__ : Ref<Label>))) {
			var _obj:Ref<Label> = __type__ == null ? (null : Ref<Label>) : __type__.__underlying__() == null ? (null : Ref<Label>) : __type__ == null ? (null : Ref<Label>) : __type__.__underlying__()
				.value;
			_buf.writeString(("label" : GoString));
			_typ = (null : Type);
		} else if (Go.typeEquals((__type__ : Ref<Builtin>))) {
			var _obj:Ref<Builtin> = __type__ == null ? (null : Ref<Builtin>) : __type__.__underlying__() == null ? (null : Ref<Builtin>) : __type__ == null ? (null : Ref<Builtin>) : __type__.__underlying__()
				.value;
			_buf.writeString(("builtin" : GoString));
			_typ = (null : Type);
		} else if (Go.typeEquals((__type__ : Ref<Nil>))) {
			var _obj:Ref<Nil> = __type__ == null ? (null : Ref<Nil>) : __type__.__underlying__() == null ? (null : Ref<Nil>) : __type__ == null ? (null : Ref<Nil>) : __type__.__underlying__()
				.value;
			_buf.writeString(("nil" : GoString));
			return;
		} else {
			var _obj:Object = __type__ == null ? (null : Object) : cast __type__;
			throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("writeObject(%T)" : GoString), Go.toInterface(_obj)));
		};
	};
	_buf.writeByte((32 : GoUInt8));
	if ((_obj.pkg() != null) && (Go.toInterface(_obj.pkg()._scope.lookup(_obj.name())) == Go.toInterface(_obj))) {
		_writePackage(_buf, _obj.pkg(), _qf);
	};
	_buf.writeString(_obj.name());
	if (_typ == null) {
		return;
	};
	if (_tname != null) {
		{
			final __type__ = _typ;
			if (Go.typeEquals((__type__ : Ref<Basic>))) {
				var _t:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
					.value;
				return;
			} else if (Go.typeEquals((__type__ : Ref<Named>))) {
				var _t:Ref<Named> = __type__ == null ? (null : Ref<Named>) : __type__.__underlying__() == null ? (null : Ref<Named>) : __type__ == null ? (null : Ref<Named>) : __type__.__underlying__()
					.value;
				if (_t.typeParams().len() > (0 : GoInt)) {
					_newTypeWriter(_buf, _qf)._tParamList(_t.typeParams()._list());
				};
			};
		};
		if (_tname.isAlias()) {
			_buf.writeString((" =" : GoString));
		} else {
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_typ) : Ref<TypeParam>)) : Ref<TypeParam>), ok: true};
			} catch (_) {
				{value: (null : Ref<TypeParam>), ok: false};
			}, _t = __tmp__.value, _0 = __tmp__.ok;
			if (_t != null) {
				_typ = _t._bound;
			} else {
				_typ = _under(_typ);
			};
		};
	};
	if (Go.toInterface(_obj) == (Go.toInterface(_universeAny))) {
		_assert(identical(_typ, Go.asInterface((_emptyInterface : Ref<Interface>))));
		_typ = Go.asInterface((_emptyInterface : Ref<Interface>));
	};
	_buf.writeByte((32 : GoUInt8));
	writeType(_buf, _typ, _qf);
}

private function _writePackage(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _pkg:Ref<Package>, _qf:Qualifier):Void {
	if (_pkg == null) {
		return;
	};
	var _s:GoString = ("" : GoString);
	if (_qf != null) {
		_s = _qf(_pkg);
	} else {
		_s = _pkg.path();
	};
	if (_s != (Go.str())) {
		_buf.writeString(_s);
		_buf.writeByte((46 : GoUInt8));
	};
}

/**
	// ObjectString returns the string form of obj.
	// The Qualifier controls the printing of
	// package-level objects, and may be nil.
**/
function objectString(_obj:Object, _qf:Qualifier):GoString {
	var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
	_writeObject((_buf : Ref<stdgo.bytes.Bytes.Buffer>), _obj, _qf);
	return (_buf.string() : GoString);
}

private function _writeFuncName(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _f:Ref<Func>, _qf:Qualifier):Void {
	if (_f._object._typ != null) {
		var _sig = (Go.typeAssert((Go.toInterface(_f._object._typ) : Ref<Signature>)) : Ref<Signature>);
		{
			var _recv = _sig.recv();
			if (_recv != null) {
				_buf.writeByte((40 : GoUInt8));
				{
					var __tmp__ = try {
						{value: (Go.typeAssert((Go.toInterface(_recv.type()) : Ref<Interface>)) : Ref<Interface>), ok: true};
					} catch (_) {
						{value: (null : Ref<Interface>), ok: false};
					}, _0 = __tmp__.value, _ok = __tmp__.ok;
					if (_ok) {
						_buf.writeString(("interface" : GoString));
					} else {
						writeType(_buf, _recv.type(), _qf);
					};
				};
				_buf.writeByte((41 : GoUInt8));
				_buf.writeByte((46 : GoUInt8));
			} else if (_f._object._pkg != null) {
				_writePackage(_buf, _f._object._pkg, _qf);
			};
		};
	};
	_buf.writeString(_f._object._name);
}

/**
	// Operand string formats
	// (not all "untyped" cases can appear due to the type system,
	// but they fall out naturally here)
	//
	// mode       format
	//
	// invalid    <expr> (               <mode>                    )
	// novalue    <expr> (               <mode>                    )
	// builtin    <expr> (               <mode>                    )
	// typexpr    <expr> (               <mode>                    )
	//
	// constant   <expr> (<untyped kind> <mode>                    )
	// constant   <expr> (               <mode>       of type <typ>)
	// constant   <expr> (<untyped kind> <mode> <val>              )
	// constant   <expr> (               <mode> <val> of type <typ>)
	//
	// variable   <expr> (<untyped kind> <mode>                    )
	// variable   <expr> (               <mode>       of type <typ>)
	//
	// mapindex   <expr> (<untyped kind> <mode>                    )
	// mapindex   <expr> (               <mode>       of type <typ>)
	//
	// value      <expr> (<untyped kind> <mode>                    )
	// value      <expr> (               <mode>       of type <typ>)
	//
	// commaok    <expr> (<untyped kind> <mode>                    )
	// commaok    <expr> (               <mode>       of type <typ>)
	//
	// commaerr   <expr> (<untyped kind> <mode>                    )
	// commaerr   <expr> (               <mode>       of type <typ>)
	//
	// cgofunc    <expr> (<untyped kind> <mode>                    )
	// cgofunc    <expr> (               <mode>       of type <typ>)
**/
private function _operandString(_x:Ref<T_operand>, _qf:Qualifier):GoString {
	if ((_x._mode == (7 : T_operandMode))
		&& (Go.toInterface(_x._typ) == Go.toInterface(Go.asInterface(typ[((25 : BasicKind) : GoInt)])))) {
		return ("nil" : GoString);
	};
	var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
	var _expr:GoString = ("" : GoString);
	if (_x._expr != null) {
		_expr = exprString(_x._expr);
	} else {
		if (_x._mode == ((2 : T_operandMode))) {
			_expr = _predeclaredFuncs[(_x._id : GoInt)]._name;
		} else if (_x._mode == ((3 : T_operandMode))) {
			_expr = typeString(_x._typ, _qf);
		} else if (_x._mode == ((4 : T_operandMode))) {
			_expr = (_x._val.string() : GoString);
		};
	};
	if (_expr != (Go.str())) {
		_buf.writeString(_expr);
		_buf.writeString((" (" : GoString));
	};
	var _hasType:Bool = false;
	{
		var __switchIndex__ = -1;
		while (true) {
			if (_x._mode == ((0 : T_operandMode)) || _x._mode == ((1 : T_operandMode)) || _x._mode == ((2 : T_operandMode))
				|| _x._mode == ((3 : T_operandMode))) {
				break;
			} else {
				if (_x._typ != null) {
					if (_isUntyped(_x._typ)) {
						_buf.writeString((Go.typeAssert((Go.toInterface(_x._typ) : Ref<Basic>)) : Ref<Basic>)._name);
						_buf.writeByte((32 : GoUInt8));
						break;
					};
					_hasType = true;
				};
			};
			break;
		};
	};
	_buf.writeString(_operandModeString[(_x._mode : GoInt)]);
	if (_x._mode == ((4 : T_operandMode))) {
		{
			var _s:GoString = (_x._val.string() : GoString);
			if (_s != (_expr)) {
				_buf.writeByte((32 : GoUInt8));
				_buf.writeString(_s);
			};
		};
	};
	if (_hasType) {
		if (Go.toInterface(_x._typ) != (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
			var _intro:GoString = ("" : GoString);
			if (_isGeneric(_x._typ)) {
				_intro = (" of parameterized type " : GoString);
			} else {
				_intro = (" of type " : GoString);
			};
			_buf.writeString(_intro);
			writeType((_buf : Ref<stdgo.bytes.Bytes.Buffer>), _x._typ, _qf);
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_x._typ) : Ref<TypeParam>)) : Ref<TypeParam>), ok: true};
				} catch (_) {
					{value: (null : Ref<TypeParam>), ok: false};
				}, _tpar = __tmp__.value, _0 = __tmp__.ok;
				if (_tpar != null) {
					_buf.writeString((" constrained by " : GoString));
					writeType((_buf : Ref<stdgo.bytes.Bytes.Buffer>), _tpar._bound, _qf);
				};
			};
		} else {
			_buf.writeString((" with invalid type" : GoString));
		};
	};
	if (_expr != (Go.str())) {
		_buf.writeByte((41 : GoUInt8));
	};
	return (_buf.string() : GoString);
}

/**
	// NewPackage returns a new Package for the given package path and name.
	// The package is not complete and contains no explicit imports.
**/
function newPackage(_path:GoString, _name:GoString):Ref<Package> {
	var _scope = newScope(universe, (0 : stdgo.go.token.Token.Pos), (0 : stdgo.go.token.Token.Pos),
		stdgo.fmt.Fmt.sprintf(("package %q" : GoString), Go.toInterface(_path)));
	return (({_path: _path, _name: _name, _scope: _scope} : Package) : Ref<Package>);
}

/**
	// NewPointer returns a new pointer type for the given element (base) type.
**/
function newPointer(_elem:Type):Ref<Pointer_> {
	return (({_base: _elem} : Pointer_) : Ref<Pointer_>);
}

private function _isBoolean(_t:Type):Bool {
	return _isBasic(_t, (1 : BasicInfo));
}

private function _isInteger(_t:Type):Bool {
	return _isBasic(_t, (2 : BasicInfo));
}

private function _isUnsigned(_t:Type):Bool {
	return _isBasic(_t, (4 : BasicInfo));
}

private function _isFloat(_t:Type):Bool {
	return _isBasic(_t, (8 : BasicInfo));
}

private function _isComplex(_t:Type):Bool {
	return _isBasic(_t, (16 : BasicInfo));
}

private function _isNumeric(_t:Type):Bool {
	return _isBasic(_t, (26 : BasicInfo));
}

private function _isString(_t:Type):Bool {
	return _isBasic(_t, (32 : BasicInfo));
}

private function _isIntegerOrFloat(_t:Type):Bool {
	return _isBasic(_t, (10 : BasicInfo));
}

private function _isConstType(_t:Type):Bool {
	return _isBasic(_t, (59 : BasicInfo));
}

/**
	// isBasic reports whether under(t) is a basic type with the specified info.
	// If t is a type parameter the result is false; i.e.,
	// isBasic does not look inside a type parameter.
**/
private function _isBasic(_t:Type, _info:BasicInfo):Bool {
	var __tmp__ = try {
		{value: (Go.typeAssert((Go.toInterface(_under(_t)) : Ref<Basic>)) : Ref<Basic>), ok: true};
	} catch (_) {
		{value: (null : Ref<Basic>), ok: false};
	}, _u = __tmp__.value, _0 = __tmp__.ok;
	return (_u != null) && ((_u._info & _info) != (0 : BasicInfo));
}

private function _allBoolean(_typ:Type):Bool {
	return _allBasic(_typ, (1 : BasicInfo));
}

private function _allInteger(_typ:Type):Bool {
	return _allBasic(_typ, (2 : BasicInfo));
}

private function _allUnsigned(_typ:Type):Bool {
	return _allBasic(_typ, (4 : BasicInfo));
}

private function _allNumeric(_typ:Type):Bool {
	return _allBasic(_typ, (26 : BasicInfo));
}

private function _allString(_typ:Type):Bool {
	return _allBasic(_typ, (32 : BasicInfo));
}

private function _allOrdered(_typ:Type):Bool {
	return _allBasic(_typ, (42 : BasicInfo));
}

private function _allNumericOrString(_typ:Type):Bool {
	return _allBasic(_typ, (58 : BasicInfo));
}

/**
	// allBasic reports whether under(t) is a basic type with the specified info.
	// If t is a type parameter, the result is true if isBasic(t, info) is true
	// for all specific types of the type parameter's type set.
	// allBasic(t, info) is an optimized version of isBasic(coreType(t), info).
**/
private function _allBasic(_t:Type, _info:BasicInfo):Bool {
	{
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_t) : Ref<TypeParam>)) : Ref<TypeParam>), ok: true};
		} catch (_) {
			{value: (null : Ref<TypeParam>), ok: false};
		}, _tpar = __tmp__.value, _0 = __tmp__.ok;
		if (_tpar != null) {
			return _tpar._is(function(_t:Ref<T_term>):Bool {
				return (_t != null) && _isBasic(_t._typ, _info);
			});
		};
	};
	return _isBasic(_t, _info);
}

/**
	// hasName reports whether t has a name. This includes
	// predeclared types, defined types, and type parameters.
	// hasName may be called with types that are not fully set up.
**/
private function _hasName(_t:Type):Bool {
	{
		final __type__ = _t;
		if (Go.typeEquals((__type__ : Ref<Basic>))
			|| Go.typeEquals((__type__ : Ref<Named>))
			|| Go.typeEquals((__type__ : Ref<TypeParam>))) {
			return true;
		};
	};
	return false;
}

/**
	// isTyped reports whether t is typed; i.e., not an untyped
	// constant or boolean. isTyped may be called with types that
	// are not fully set up.
**/
private function _isTyped(_t:Type):Bool {
	var __tmp__ = try {
		{value: (Go.typeAssert((Go.toInterface(_t) : Ref<Basic>)) : Ref<Basic>), ok: true};
	} catch (_) {
		{value: (null : Ref<Basic>), ok: false};
	}, _b = __tmp__.value, _0 = __tmp__.ok;
	return (_b == null) || ((_b._info & (64 : BasicInfo)) == (0 : BasicInfo));
}

/**
	// isUntyped(t) is the same as !isTyped(t).
**/
private function _isUntyped(_t:Type):Bool {
	return !_isTyped(_t);
}

/**
	// IsInterface reports whether t is an interface type.
**/
function isInterface(_t:Type):Bool {
	var __tmp__ = try {
		{value: (Go.typeAssert((Go.toInterface(_under(_t)) : Ref<Interface>)) : Ref<Interface>), ok: true};
	} catch (_) {
		{value: (null : Ref<Interface>), ok: false};
	}, _0 = __tmp__.value, _ok = __tmp__.ok;
	return _ok;
}

/**
	// isNonTypeParamInterface reports whether t is an interface type but not a type parameter.
**/
private function _isNonTypeParamInterface(_t:Type):Bool {
	return !_isTypeParam(_t) && isInterface(_t);
}

/**
	// isTypeParam reports whether t is a type parameter.
**/
private function _isTypeParam(_t:Type):Bool {
	var __tmp__ = try {
		{value: (Go.typeAssert((Go.toInterface(_t) : Ref<TypeParam>)) : Ref<TypeParam>), ok: true};
	} catch (_) {
		{value: (null : Ref<TypeParam>), ok: false};
	}, _0 = __tmp__.value, _ok = __tmp__.ok;
	return _ok;
}

/**
	// isGeneric reports whether a type is a generic, uninstantiated type
	// (generic signatures are not included).
	// TODO(gri) should we include signatures or assert that they are not present?
**/
private function _isGeneric(_t:Type):Bool {
	var __tmp__ = try {
		{value: (Go.typeAssert((Go.toInterface(_t) : Ref<Named>)) : Ref<Named>), ok: true};
	} catch (_) {
		{value: (null : Ref<Named>), ok: false};
	}, _named = __tmp__.value, _0 = __tmp__.ok;
	return (((_named != null) && (_named._obj != null)) && (_named._inst == null)) && (_named.typeParams().len() > (0 : GoInt));
}

/**
	// Comparable reports whether values of type T are comparable.
**/
function comparable(t:Type):Bool {
	return _comparable(t, true, (null : GoMap<Type, Bool>), null);
}

/**
	// If dynamic is set, non-type parameter interfaces are always comparable.
	// If reportf != nil, it may be used to report why T is not comparable.
**/
private function _comparable(t:Type, _dynamic:Bool, _seen:GoMap<Type, Bool>, _reportf:(GoString, haxe.Rest<AnyInterface>) -> Void):Bool {
	if (_seen[t]) {
		return true;
	};
	if (_seen == null) {
		_seen = (new GoObjectMap<Type, Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
			stdgo.internal.reflect.Reflect.GoType.named("Type", [], null, false, {get: () -> null})},
			{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind)}))) : GoMap<Type, Bool>);
	};
	_seen[t] = true;
	{
		final __type__ = _under(t);
		if (Go.typeEquals((__type__ : Ref<Basic>))) {
			var _t:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
				.value;
			return _t._kind != ((25 : BasicKind));
		} else if (Go.typeEquals((__type__ : Ref<Pointer_>)) || Go.typeEquals((__type__ : Ref<Chan>))) {
			var _t:Type = __type__ == null ? (null : Type) : cast __type__;
			return true;
		} else if (Go.typeEquals((__type__ : Ref<Struct>))) {
			var _t:Ref<Struct> = __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__() == null ? (null : Ref<Struct>) : __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__()
				.value;
			for (_0 => _f in _t._fields) {
				if (!_comparable(_f._object._typ, _dynamic, _seen, null)) {
					if (_reportf != null) {
						_reportf(("struct containing %s cannot be compared" : GoString), Go.toInterface(_f._object._typ));
					};
					return false;
				};
			};
			return true;
		} else if (Go.typeEquals((__type__ : Ref<Array_>))) {
			var _t:Ref<Array_> = __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__() == null ? (null : Ref<Array_>) : __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__()
				.value;
			if (!_comparable(_t._elem, _dynamic, _seen, null)) {
				if (_reportf != null) {
					_reportf(("%s cannot be compared" : GoString), Go.toInterface(Go.asInterface(_t)));
				};
				return false;
			};
			return true;
		} else if (Go.typeEquals((__type__ : Ref<Interface>))) {
			var _t:Ref<Interface> = __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__() == null ? (null : Ref<Interface>) : __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__()
				.value;
			if ((_dynamic && !_isTypeParam(t)) || _t._typeSet().isComparable(_seen)) {
				return true;
			};
			if (_reportf != null) {
				if (_t._typeSet().isEmpty()) {
					_reportf(("empty type set" : GoString));
				} else {
					_reportf(("incomparable types in type set" : GoString));
				};
			};
		};
	};
	return false;
}

/**
	// hasNil reports whether type t includes the nil value.
**/
private function _hasNil(_t:Type):Bool {
	{
		final __type__ = _under(_t);
		if (Go.typeEquals((__type__ : Ref<Basic>))) {
			var _u:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
				.value;
			return _u._kind == ((18 : BasicKind));
		} else if (Go.typeEquals((__type__ : Ref<Slice_>))
			|| Go.typeEquals((__type__ : Ref<Pointer_>))
			|| Go.typeEquals((__type__ : Ref<Signature>))
			|| Go.typeEquals((__type__ : Ref<Map_>))
			|| Go.typeEquals((__type__ : Ref<Chan>))) {
			var _u:Type = __type__ == null ? (null : Type) : cast __type__;
			return true;
		} else if (Go.typeEquals((__type__ : Ref<Interface>))) {
			var _u:Ref<Interface> = __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__() == null ? (null : Ref<Interface>) : __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__()
				.value;
			return !_isTypeParam(_t) || _u._typeSet()._underIs(function(_u:Type):Bool {
				return (_u != null) && _hasNil(_u);
			});
		};
	};
	return false;
}

/**
	// For changes to this code the corresponding changes should be made to unifier.nify.
**/
private function _identical(_x:Type, _y:Type, _cmpTags:Bool, _p:Ref<T_ifacePair>):Bool {
	if (Go.toInterface(_x) == (Go.toInterface(_y))) {
		return true;
	};
	{
		final __type__ = _x;
		if (Go.typeEquals((__type__ : Ref<Basic>))) {
			var _x:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
				.value;
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Basic>)) : Ref<Basic>), ok: true};
				} catch (_) {
					{value: (null : Ref<Basic>), ok: false};
				}, _y = __tmp__.value, _ok = __tmp__.ok;
				if (_ok) {
					return _x._kind == (_y._kind);
				};
			};
		} else if (Go.typeEquals((__type__ : Ref<Array_>))) {
			var _x:Ref<Array_> = __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__() == null ? (null : Ref<Array_>) : __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__()
				.value;
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Array_>)) : Ref<Array_>), ok: true};
				} catch (_) {
					{value: (null : Ref<Array_>), ok: false};
				}, _y = __tmp__.value, _ok = __tmp__.ok;
				if (_ok) {
					return (((_x._len < (("0" : GoInt64) : GoInt64)) || (_y._len < (("0" : GoInt64) : GoInt64)))
						|| (_x._len == _y._len))
						&& _identical(_x._elem, _y._elem, _cmpTags, _p);
				};
			};
		} else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
			var _x:Ref<Slice_> = __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__() == null ? (null : Ref<Slice_>) : __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__()
				.value;
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Slice_>)) : Ref<Slice_>), ok: true};
				} catch (_) {
					{value: (null : Ref<Slice_>), ok: false};
				}, _y = __tmp__.value, _ok = __tmp__.ok;
				if (_ok) {
					return _identical(_x._elem, _y._elem, _cmpTags, _p);
				};
			};
		} else if (Go.typeEquals((__type__ : Ref<Struct>))) {
			var _x:Ref<Struct> = __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__() == null ? (null : Ref<Struct>) : __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__()
				.value;
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Struct>)) : Ref<Struct>), ok: true};
				} catch (_) {
					{value: (null : Ref<Struct>), ok: false};
				}, _y = __tmp__.value, _ok = __tmp__.ok;
				if (_ok) {
					if (_x.numFields() == (_y.numFields())) {
						for (_i => _f in _x._fields) {
							var _g = _y._fields[(_i : GoInt)];
							if ((((_f._embedded != _g._embedded) || (_cmpTags && (_x.tag(_i) != _y.tag(_i))))
								|| !_f._sameId(_g._object._pkg, _g._object._name))
								|| !_identical(_f._object._typ, _g._object._typ, _cmpTags, _p)) {
								return false;
							};
						};
						return true;
					};
				};
			};
		} else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
			var _x:Ref<Pointer_> = __type__ == null ? (null : Ref<Pointer_>) : __type__.__underlying__() == null ? (null : Ref<Pointer_>) : __type__ == null ? (null : Ref<Pointer_>) : __type__.__underlying__()
				.value;
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Pointer_>)) : Ref<Pointer_>), ok: true};
				} catch (_) {
					{value: (null : Ref<Pointer_>), ok: false};
				}, _y = __tmp__.value, _ok = __tmp__.ok;
				if (_ok) {
					return _identical(_x._base, _y._base, _cmpTags, _p);
				};
			};
		} else if (Go.typeEquals((__type__ : Ref<Tuple>))) {
			var _x:Ref<Tuple> = __type__ == null ? (null : Ref<Tuple>) : __type__.__underlying__() == null ? (null : Ref<Tuple>) : __type__ == null ? (null : Ref<Tuple>) : __type__.__underlying__()
				.value;
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Tuple>)) : Ref<Tuple>), ok: true};
				} catch (_) {
					{value: (null : Ref<Tuple>), ok: false};
				}, _y = __tmp__.value, _ok = __tmp__.ok;
				if (_ok) {
					if (_x.len() == (_y.len())) {
						if (_x != null) {
							for (_i => _v in _x._vars) {
								var _w = _y._vars[(_i : GoInt)];
								if (!_identical(_v._object._typ, _w._object._typ, _cmpTags, _p)) {
									return false;
								};
							};
						};
						return true;
					};
				};
			};
		} else if (Go.typeEquals((__type__ : Ref<Signature>))) {
			var _x:Ref<Signature> = __type__ == null ? (null : Ref<Signature>) : __type__.__underlying__() == null ? (null : Ref<Signature>) : __type__ == null ? (null : Ref<Signature>) : __type__.__underlying__()
				.value;
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Signature>)) : Ref<Signature>), ok: true};
			} catch (_) {
				{value: (null : Ref<Signature>), ok: false};
			}, _y = __tmp__.value, _0 = __tmp__.ok;
			if (_y == null) {
				return false;
			};
			if (_x.typeParams().len() != (_y.typeParams().len())) {
				return false;
			};
			var _yparams = _y._params;
			var _yresults = _y._results;
			if (_x.typeParams().len() > (0 : GoInt)) {
				var _xtparams = _x.typeParams()._list();
				var _ytparams = _y.typeParams()._list();
				var _targs:Slice<Type> = (null : Slice<Type>);
				for (_i in 0..._xtparams.length.toBasic()) {
					_targs = _targs.__appendref__(Go.asInterface(_x.typeParams().at(_i)));
				};
				var _smap:T_substMap = _makeSubstMap(_ytparams, _targs);
				var _check:Ref<Checker> = (null : Ref<Checker>);
				var _ctxt = newContext();
				for (_i => _xtparam in _xtparams) {
					var _ybound:Type = _check._subst((0 : stdgo.go.token.Token.Pos), _ytparams[(_i : GoInt)]._bound, _smap, null, _ctxt);
					if (!_identical(_xtparam._bound, _ybound, _cmpTags, _p)) {
						return false;
					};
				};
				_yparams = (Go.typeAssert((Go.toInterface(_check._subst((0 : stdgo.go.token.Token.Pos), Go.asInterface(_y._params), _smap, null,
					_ctxt)) : Ref<Tuple>)) : Ref<Tuple>);
				_yresults = (Go.typeAssert((Go.toInterface(_check._subst((0 : stdgo.go.token.Token.Pos), Go.asInterface(_y._results), _smap, null,
					_ctxt)) : Ref<Tuple>)) : Ref<Tuple>);
			};
			return ((_x._variadic == _y._variadic)
				&& _identical(Go.asInterface(_x._params), Go.asInterface(_yparams), _cmpTags, _p))
				&& _identical(Go.asInterface(_x._results), Go.asInterface(_yresults), _cmpTags, _p);
		} else if (Go.typeEquals((__type__ : Ref<Union>))) {
			var _x:Ref<Union> = __type__ == null ? (null : Ref<Union>) : __type__.__underlying__() == null ? (null : Ref<Union>) : __type__ == null ? (null : Ref<Union>) : __type__.__underlying__()
				.value;
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Union>)) : Ref<Union>), ok: true};
				} catch (_) {
					{value: (null : Ref<Union>), ok: false};
				}, _y = __tmp__.value, _5 = __tmp__.ok;
				if (_y != null) {
					var _unionSets = (new GoObjectMap<Ref<Union>,
						Ref<T__TypeSet>>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({
						get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("Union", [], null,
							false, {get: () -> null})})
					},
						{get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("T__TypeSet", [],
							null, false, {get: () -> null})})}))) : GoMap<Ref<Union>, Ref<T__TypeSet>>);
					var _xset = _computeUnionTypeSet(null, _unionSets, (0 : stdgo.go.token.Token.Pos), _x);
					var _yset = _computeUnionTypeSet(null, _unionSets, (0 : stdgo.go.token.Token.Pos), _y);
					return _xset._terms._equal(_yset._terms);
				};
			};
		} else if (Go.typeEquals((__type__ : Ref<Interface>))) {
			var _x:Ref<Interface> = __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__() == null ? (null : Ref<Interface>) : __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__()
				.value;
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Interface>)) : Ref<Interface>), ok: true};
				} catch (_) {
					{value: (null : Ref<Interface>), ok: false};
				}, _y = __tmp__.value, _ok = __tmp__.ok;
				if (_ok) {
					var _xset = _x._typeSet();
					var _yset = _y._typeSet();
					if (_xset._comparable != (_yset._comparable)) {
						return false;
					};
					if (!_xset._terms._equal(_yset._terms)) {
						return false;
					};
					var _a = _xset._methods;
					var _b = _yset._methods;
					if ((_a.length) == ((_b.length))) {
						var _q = ((new T_ifacePair(_x, _y, _p) : T_ifacePair) : Ref<T_ifacePair>);
						while (_p != null) {
							if (_p._identical(_q)) {
								return true;
							};
							_p = _p._prev;
						};
						if (false) {
							_assertSortedMethods(_a);
							_assertSortedMethods(_b);
						};
						for (_i => _f in _a) {
							var _g = _b[(_i : GoInt)];
							if ((_f.id() != _g.id()) || !_identical(_f._object._typ, _g._object._typ, _cmpTags, _q)) {
								return false;
							};
						};
						return true;
					};
				};
			};
		} else if (Go.typeEquals((__type__ : Ref<Map_>))) {
			var _x:Ref<Map_> = __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__() == null ? (null : Ref<Map_>) : __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__()
				.value;
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Map_>)) : Ref<Map_>), ok: true};
				} catch (_) {
					{value: (null : Ref<Map_>), ok: false};
				}, _y = __tmp__.value, _ok = __tmp__.ok;
				if (_ok) {
					return _identical(_x._key, _y._key, _cmpTags, _p) && _identical(_x._elem, _y._elem, _cmpTags, _p);
				};
			};
		} else if (Go.typeEquals((__type__ : Ref<Chan>))) {
			var _x:Ref<Chan> = __type__ == null ? (null : Ref<Chan>) : __type__.__underlying__() == null ? (null : Ref<Chan>) : __type__ == null ? (null : Ref<Chan>) : __type__.__underlying__()
				.value;
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Chan>)) : Ref<Chan>), ok: true};
				} catch (_) {
					{value: (null : Ref<Chan>), ok: false};
				}, _y = __tmp__.value, _ok = __tmp__.ok;
				if (_ok) {
					return (_x._dir == _y._dir) && _identical(_x._elem, _y._elem, _cmpTags, _p);
				};
			};
		} else if (Go.typeEquals((__type__ : Ref<Named>))) {
			var _x:Ref<Named> = __type__ == null ? (null : Ref<Named>) : __type__.__underlying__() == null ? (null : Ref<Named>) : __type__ == null ? (null : Ref<Named>) : __type__.__underlying__()
				.value;
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Named>)) : Ref<Named>), ok: true};
				} catch (_) {
					{value: (null : Ref<Named>), ok: false};
				}, _y = __tmp__.value, _ok = __tmp__.ok;
				if (_ok) {
					var _xargs = _x.typeArgs()._list();
					var _yargs = _y.typeArgs()._list();
					if ((_xargs.length) != ((_yargs.length))) {
						return false;
					};
					if ((_xargs.length) > (0 : GoInt)) {
						if (!identical(Go.asInterface(_x.origin()), Go.asInterface(_y.origin()))) {
							return false;
						};
						for (_i => _xa in _xargs) {
							if (!identical(_xa, _yargs[(_i : GoInt)])) {
								return false;
							};
						};
						return true;
					};
					return _x._obj == (_y._obj);
				};
			};
		} else if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
			var _x:Ref<TypeParam> = __type__ == null ? (null : Ref<TypeParam>) : __type__.__underlying__() == null ? (null : Ref<TypeParam>) : __type__ == null ? (null : Ref<TypeParam>) : __type__.__underlying__()
				.value;
		} else if (__type__ == null) {
			var _x:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
		} else {
			var _x:Type = __type__ == null ? (null : Type) : cast __type__;
			_unreachable();
		};
	};
	return false;
}

/**
	// identicalInstance reports if two type instantiations are identical.
	// Instantiations are identical if their origin and type arguments are
	// identical.
**/
private function _identicalInstance(_xorig:Type, _xargs:Slice<Type>, _yorig:Type, _yargs:Slice<Type>):Bool {
	if ((_xargs.length) != ((_yargs.length))) {
		return false;
	};
	for (_i => _xa in _xargs) {
		if (!identical(_xa, _yargs[(_i : GoInt)])) {
			return false;
		};
	};
	return identical(_xorig, _yorig);
}

/**
	// Default returns the default "typed" type for an "untyped" type;
	// it returns the incoming type for all other types. The default type
	// for untyped nil is untyped nil.
**/
function default_(_t:Type):Type {
	{
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_t) : Ref<Basic>)) : Ref<Basic>), ok: true};
		} catch (_) {
			{value: (null : Ref<Basic>), ok: false};
		}, _t = __tmp__.value, _ok = __tmp__.ok;
		if (_ok) {
			if (_t._kind == ((19 : BasicKind))) {
				return Go.asInterface(typ[((1 : BasicKind) : GoInt)]);
			} else if (_t._kind == ((20 : BasicKind))) {
				return Go.asInterface(typ[((2 : BasicKind) : GoInt)]);
			} else if (_t._kind == ((21 : BasicKind))) {
				return _universeRune;
			} else if (_t._kind == ((22 : BasicKind))) {
				return Go.asInterface(typ[((14 : BasicKind) : GoInt)]);
			} else if (_t._kind == ((23 : BasicKind))) {
				return Go.asInterface(typ[((16 : BasicKind) : GoInt)]);
			} else if (_t._kind == ((24 : BasicKind))) {
				return Go.asInterface(typ[((17 : BasicKind) : GoInt)]);
			};
		};
	};
	return _t;
}

private function _validatedImportPath(_path:GoString):{var _0:GoString; var _1:Error;} {
	var __tmp__ = stdgo.strconv.Strconv.unquote(_path),
		_s:GoString = __tmp__._0,
		_err:Error = __tmp__._1;
	if (_err != null) {
		return {_0: Go.str(), _1: _err};
	};
	if (_s == (Go.str())) {
		return {_0: Go.str(), _1: stdgo.fmt.Fmt.errorf(("empty string" : GoString))};
	};
	{};
	for (_0 => _r in _s) {
		if ((!stdgo.unicode.Unicode.isGraphic(_r) || stdgo.unicode.Unicode.isSpace(_r))
			|| stdgo.strings.Strings.containsRune(("!\"#$$%&\'()*,:;<=>?[\\]^{|}`�" : GoString), _r)) {
			return {_0: _s, _1: stdgo.fmt.Fmt.errorf(("invalid character %#U" : GoString), Go.toInterface(_r))};
		};
	};
	return {_0: _s, _1: (null : Error)};
}

/**
	// dir makes a good-faith attempt to return the directory
	// portion of path. If path is empty, the result is ".".
	// (Per the go/build package dependency tests, we cannot import
	// path/filepath and simply use filepath.Dir.)
**/
private function _dir(_path:GoString):GoString {
	{
		var _i:GoInt = stdgo.strings.Strings.lastIndexAny(_path, ("/\\" : GoString));
		if (_i > (0 : GoInt)) {
			return (_path.__slice__(0, _i) : GoString);
		};
	};
	return ("." : GoString);
}

/**
	// hasBreak reports if s is or contains a break statement
	// referring to the label-ed statement or implicit-ly the
	// closest outer breakable statement.
**/
private function _hasBreak(_s:stdgo.go.ast.Ast.Stmt, _label:GoString, _implicit:Bool):Bool {
	{
		final __type__ = _s;
		if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BadStmt>))
			|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.DeclStmt>))
			|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.EmptyStmt>))
			|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ExprStmt>))
			|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SendStmt>))
			|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IncDecStmt>))
			|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.AssignStmt>))
			|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.GoStmt>))
			|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.DeferStmt>))
			|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ReturnStmt>))) {
			var _s:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.LabeledStmt>))) {
			var _s:Ref<stdgo.go.ast.Ast.LabeledStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__()
				.value;
			return _hasBreak(_s.stmt, _label, _implicit);
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BranchStmt>))) {
			var _s:Ref<stdgo.go.ast.Ast.BranchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__()
				.value;
			if (_s.tok == ((61 : stdgo.go.token.Token.Token))) {
				if (_s.label == null) {
					return _implicit;
				};
				if (_s.label.name == (_label)) {
					return true;
				};
			};
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BlockStmt>))) {
			var _s:Ref<stdgo.go.ast.Ast.BlockStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__()
				.value;
			return _hasBreakList(_s.list, _label, _implicit);
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IfStmt>))) {
			var _s:Ref<stdgo.go.ast.Ast.IfStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__()
				.value;
			if (_hasBreak(Go.asInterface(_s.body), _label, _implicit) || ((_s.else_ != null) && _hasBreak(_s.else_, _label, _implicit))) {
				return true;
			};
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CaseClause>))) {
			var _s:Ref<stdgo.go.ast.Ast.CaseClause> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CaseClause>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.CaseClause>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CaseClause>) : __type__.__underlying__()
				.value;
			return _hasBreakList(_s.body, _label, _implicit);
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SwitchStmt>))) {
			var _s:Ref<stdgo.go.ast.Ast.SwitchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__()
				.value;
			if ((_label != Go.str()) && _hasBreak(Go.asInterface(_s.body), _label, false)) {
				return true;
			};
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>))) {
			var _s:Ref<stdgo.go.ast.Ast.TypeSwitchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__()
				.value;
			if ((_label != Go.str()) && _hasBreak(Go.asInterface(_s.body), _label, false)) {
				return true;
			};
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CommClause>))) {
			var _s:Ref<stdgo.go.ast.Ast.CommClause> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CommClause>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.CommClause>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CommClause>) : __type__.__underlying__()
				.value;
			return _hasBreakList(_s.body, _label, _implicit);
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectStmt>))) {
			var _s:Ref<stdgo.go.ast.Ast.SelectStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__()
				.value;
			if ((_label != Go.str()) && _hasBreak(Go.asInterface(_s.body), _label, false)) {
				return true;
			};
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ForStmt>))) {
			var _s:Ref<stdgo.go.ast.Ast.ForStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__()
				.value;
			if ((_label != Go.str()) && _hasBreak(Go.asInterface(_s.body), _label, false)) {
				return true;
			};
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.RangeStmt>))) {
			var _s:Ref<stdgo.go.ast.Ast.RangeStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__.__underlying__()
				.value;
			if ((_label != Go.str()) && _hasBreak(Go.asInterface(_s.body), _label, false)) {
				return true;
			};
		} else {
			var _s:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
			_unreachable();
		};
	};
	return false;
}

private function _hasBreakList(_list:Slice<stdgo.go.ast.Ast.Stmt>, _label:GoString, _implicit:Bool):Bool {
	for (_0 => _s in _list) {
		if (_hasBreak(_s, _label, _implicit)) {
			return true;
		};
	};
	return false;
}

/**
	// NewScope returns a new, empty scope contained in the given parent
	// scope, if any. The comment is for debugging only.
**/
function newScope(_parent:Ref<Scope>, _pos:stdgo.go.token.Token.Pos, _end:stdgo.go.token.Token.Pos, _comment:GoString):Ref<Scope> {
	var _s = ((new Scope(_parent, (null : Slice<Ref<Scope>>), (0 : GoInt), (null : GoMap<GoString, Object>), _pos, _end, _comment,
		false) : Scope) : Ref<Scope>);
	if ((_parent != null) && (_parent != universe)) {
		_parent._children = _parent._children.__appendref__(_s);
		_s._number = (_parent._children.length);
	};
	return _s;
}

/**
	// resolve returns the Object represented by obj, resolving lazy
	// objects as appropriate.
**/
private function _resolve(_name:GoString, _obj:Object):Object {
	{
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_obj) : Ref<T_lazyObject>)) : Ref<T_lazyObject>), ok: true};
		} catch (_) {
			{value: (null : Ref<T_lazyObject>), ok: false};
		}, _lazy = __tmp__.value, _ok = __tmp__.ok;
		if (_ok) {
			_lazy._once.do_(function():Void {
				var _obj:Object = _lazy._resolve();
				{
					var __tmp__ = try {
						{value: (Go.typeAssert((Go.toInterface(_obj) : Ref<T_lazyObject>)) : Ref<T_lazyObject>), ok: true};
					} catch (_) {
						{value: (null : Ref<T_lazyObject>), ok: false};
					}, _0 = __tmp__.value, _ok = __tmp__.ok;
					if (_ok) {
						throw Go.toInterface(("recursive lazy object" : GoString));
					};
				};
				if (_obj.name() != (_name)) {
					throw Go.toInterface(("lazy object has unexpected name" : GoString));
				};
				if (_obj.parent() == null) {
					_obj._setParent(_lazy._parent);
				};
				_lazy._obj = _obj;
			});
			_obj = _lazy._obj;
		};
	};
	return _obj;
}

/**
	// SelectionString returns the string form of s.
	// The Qualifier controls the printing of
	// package-level objects, and may be nil.
	//
	// Examples:
	//
	//	"field (T) f int"
	//	"method (T) f(X) Y"
	//	"method expr (T) f(X) Y"
**/
function selectionString(_s:Ref<Selection>, _qf:Qualifier):GoString {
	var _k:GoString = ("" : GoString);
	if (_s._kind == ((0 : SelectionKind))) {
		_k = ("field " : GoString);
	} else if (_s._kind == ((1 : SelectionKind))) {
		_k = ("method " : GoString);
	} else if (_s._kind == ((2 : SelectionKind))) {
		_k = ("method expr " : GoString);
	} else {
		_unreachable();
	};
	var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
	_buf.writeString(_k);
	_buf.writeByte((40 : GoUInt8));
	writeType((_buf : Ref<stdgo.bytes.Bytes.Buffer>), _s.recv(), _qf);
	stdgo.fmt.Fmt.fprintf(Go.asInterface((_buf : Ref<stdgo.bytes.Bytes.Buffer>)), (") %s" : GoString), Go.toInterface(_s._obj.name()));
	{
		var t:Type = _s.type();
		if (_s._kind == ((0 : SelectionKind))) {
			_buf.writeByte((32 : GoUInt8));
			writeType((_buf : Ref<stdgo.bytes.Bytes.Buffer>), t, _qf);
		} else {
			writeSignature((_buf : Ref<stdgo.bytes.Bytes.Buffer>), (Go.typeAssert((Go.toInterface(t) : Ref<Signature>)) : Ref<Signature>), _qf);
		};
	};
	return (_buf.string() : GoString);
}

/**
	// NewSignature returns a new function type for the given receiver, parameters,
	// and results, either of which may be nil. If variadic is set, the function
	// is variadic, it must have at least one parameter, and the last parameter
	// must be of unnamed slice type.
	//
	// Deprecated: Use NewSignatureType instead which allows for type parameters.
**/
function newSignature(_recv:Ref<Var>, _params:Ref<Tuple>, _results:Ref<Tuple>, _variadic:Bool):Ref<Signature> {
	return newSignatureType(_recv, (null : Slice<Ref<TypeParam>>), (null : Slice<Ref<TypeParam>>), _params, _results, _variadic);
}

/**
	// NewSignatureType creates a new function type for the given receiver,
	// receiver type parameters, type parameters, parameters, and results. If
	// variadic is set, params must hold at least one parameter and the last
	// parameter must be of unnamed slice type. If recv is non-nil, typeParams must
	// be empty. If recvTypeParams is non-empty, recv must be non-nil.
**/
function newSignatureType(_recv:Ref<Var>, _recvTypeParams:Slice<Ref<TypeParam>>, _typeParams:Slice<Ref<TypeParam>>, _params:Ref<Tuple>, _results:Ref<Tuple>,
		_variadic:Bool):Ref<Signature> {
	if (_variadic) {
		var _n:GoInt = _params.len();
		if (_n == ((0 : GoInt))) {
			throw Go.toInterface(("variadic function must have at least one parameter" : GoString));
		};
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_params.at(_n - (1 : GoInt))._object._typ) : Ref<Slice_>)) : Ref<Slice_>), ok: true};
			} catch (_) {
				{value: (null : Ref<Slice_>), ok: false};
			}, _0 = __tmp__.value, _ok = __tmp__.ok;
			if (!_ok) {
				throw Go.toInterface(("variadic parameter must be of unnamed slice type" : GoString));
			};
		};
	};
	var _sig = (({
		_recv: _recv,
		_params: _params,
		_results: _results,
		_variadic: _variadic
	} : Signature) : Ref<Signature>);
	if ((_recvTypeParams.length) != ((0 : GoInt))) {
		if (_recv == null) {
			throw Go.toInterface(("function with receiver type parameters must have a receiver" : GoString));
		};
		_sig._rparams = _bindTParams(_recvTypeParams);
	};
	if ((_typeParams.length) != ((0 : GoInt))) {
		if (_recv != null) {
			throw Go.toInterface(("function with type parameters cannot have a receiver" : GoString));
		};
		_sig._tparams = _bindTParams(_typeParams);
	};
	return _sig;
}

/**
	// Signal size changes of important structures.
**/
function testSizeof(_t:Ref<stdgo.testing.Testing.T>):Void {
	{};
	var _tests:Slice<T__struct_1> = (new Slice<T__struct_1>(0, 0,
		({_val: Go.toInterface(Go.asInterface((new Basic() : Basic))), __32bit: (16 : GoUIntptr), __64bit: (32 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new Array_() : Array_))), __32bit: (16 : GoUIntptr), __64bit: (24 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new Slice_() : Slice_))), __32bit: (8 : GoUIntptr), __64bit: (16 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new Struct() : Struct))), __32bit: (24 : GoUIntptr), __64bit: (48 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new Pointer_() : Pointer_))), __32bit: (8 : GoUIntptr), __64bit: (16 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new Tuple() : Tuple))), __32bit: (12 : GoUIntptr), __64bit: (24 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new Signature() : Signature))), __32bit: (28 : GoUIntptr), __64bit: (56 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new Union() : Union))), __32bit: (12 : GoUIntptr), __64bit: (24 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new Interface() : Interface))), __32bit: (40 : GoUIntptr), __64bit: (80 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new Map_() : Map_))), __32bit: (16 : GoUIntptr), __64bit: (32 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new Chan() : Chan))), __32bit: (12 : GoUIntptr), __64bit: (24 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new Named() : Named))), __32bit: (60 : GoUIntptr), __64bit: (112 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new TypeParam() : TypeParam))), __32bit: (28 : GoUIntptr), __64bit: (48 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new T_term() : T_term))), __32bit: (12 : GoUIntptr), __64bit: (24 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new PkgName() : PkgName))), __32bit: (48 : GoUIntptr), __64bit: (88 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new Const() : Const))), __32bit: (48 : GoUIntptr), __64bit: (88 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new TypeName() : TypeName))), __32bit: (40 : GoUIntptr), __64bit: (72 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new Var() : Var))), __32bit: (48 : GoUIntptr), __64bit: (88 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new Func() : Func))), __32bit: (48 : GoUIntptr), __64bit: (88 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new Label() : Label))), __32bit: (44 : GoUIntptr), __64bit: (80 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new Builtin() : Builtin))), __32bit: (44 : GoUIntptr), __64bit: (80 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new Nil() : Nil))), __32bit: (40 : GoUIntptr), __64bit: (72 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new Scope() : Scope))), __32bit: (44 : GoUIntptr), __64bit: (88 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new Package() : Package))), __32bit: (40 : GoUIntptr), __64bit: (80 : GoUIntptr)} : T__struct_1),
		({_val: Go.toInterface(Go.asInterface((new T__TypeSet() : T__TypeSet))), __32bit: (28 : GoUIntptr),
			__64bit: (56 : GoUIntptr)} : T__struct_1)) : Slice<T__struct_1>);
	for (_0 => _test in _tests) {
		var _got:GoUIntptr = stdgo.reflect.Reflect.typeOf(_test._val).size();
		var _want:GoUIntptr = _test.__32bit;
		if (false) {
			_want = _test.__64bit;
		};
		if (_got != (_want)) {
			_t.errorf(("unsafe.Sizeof(%T) = %d, want %d" : GoString), _test._val, Go.toInterface(_got), Go.toInterface(_want));
		};
	};
}

private function _isSyncAtomicAlign64(t:Type):Bool {
	var __tmp__ = try {
		{value: (Go.typeAssert((Go.toInterface(t) : Ref<Named>)) : Ref<Named>), ok: true};
	} catch (_) {
		{value: (null : Ref<Named>), ok: false};
	}, _named = __tmp__.value, _ok = __tmp__.ok;
	if (!_ok) {
		return false;
	};
	var _obj = _named.obj();
	return ((_obj.name() == ("align64" : GoString))
		&& (_obj.pkg() != null))
		&& ((_obj.pkg().path() == ("sync/atomic" : GoString)) || (_obj.pkg().path() == ("runtime/internal/atomic" : GoString)));
}

/**
	// SizesFor returns the Sizes used by a compiler for an architecture.
	// The result is nil if a compiler/architecture pair is not known.
	//
	// Supported architectures for compiler "gc":
	// "386", "amd64", "amd64p32", "arm", "arm64", "loong64", "mips", "mipsle",
	// "mips64", "mips64le", "ppc64", "ppc64le", "riscv64", "s390x", "sparc64", "wasm".
**/
function sizesFor(_compiler:GoString, _arch:GoString):Sizes {
	var _m:GoMap<GoString, Ref<StdSizes>> = (null : GoMap<GoString, Ref<StdSizes>>);
	if (_compiler == (("gc" : GoString))) {
		_m = _gcArchSizes;
	} else if (_compiler == (("gccgo" : GoString))) {
		_m = _gccgoArchSizes;
	} else {
		return (null : Sizes);
	};
	var __tmp__ = (_m != null && _m.__exists__(_arch) ? {value: _m[_arch], ok: true} : {value: (null : Ref<StdSizes>), ok: false}),
		_s:Ref<StdSizes> = __tmp__.value,
		_ok:Bool = __tmp__.ok;
	if (!_ok) {
		return (null : Sizes);
	};
	return Go.asInterface(_s);
}

/**
	// align returns the smallest y >= x such that y % a == 0.
**/
private function _align(_x:GoInt64, _a:GoInt64):GoInt64 {
	var _y:GoInt64 = (_x + _a) - ("1" : GoInt64);
	return _y - (_y % _a);
}

/**
	// NewSlice returns a new slice type for the given element type.
**/
function newSlice(_elem:Type):Ref<Slice_> {
	return (({_elem: _elem} : Slice_) : Ref<Slice_>);
}

private function _trimTrailingEmptyStmts(_list:Slice<stdgo.go.ast.Ast.Stmt>):Slice<stdgo.go.ast.Ast.Stmt> {
	{
		var _i:GoInt = (_list.length);
		Go.cfor(_i > (0 : GoInt), _i--, {
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_list[(_i - (1 : GoInt) : GoInt)]) : Ref<stdgo.go.ast.Ast.EmptyStmt>)) : Ref<stdgo.go.ast.Ast.EmptyStmt>),
						ok: true};
				} catch (_) {
					{value: (null : Ref<stdgo.go.ast.Ast.EmptyStmt>), ok: false};
				}, _0 = __tmp__.value, _ok = __tmp__.ok;
				if (!_ok) {
					return (_list.__slice__(0, _i) : Slice<stdgo.go.ast.Ast.Stmt>);
				};
			};
		});
	};
	return (null : Slice<stdgo.go.ast.Ast.Stmt>);
}

private function _assignOp(_op:stdgo.go.token.Token.Token):stdgo.go.token.Token.Token {
	if (((23 : stdgo.go.token.Token.Token) <= _op) && (_op <= (33 : stdgo.go.token.Token.Token))) {
		return _op + (-11 : stdgo.go.token.Token.Token);
	};
	return (0 : stdgo.go.token.Token.Token);
}

/**
	// goVal returns the Go value for val, or nil.
**/
private function _goVal(_val:stdgo.go.constant.Constant.Value):AnyInterface {
	if (_val == null) {
		return (null : AnyInterface);
	};
	if (_val.kind() == ((3 : stdgo.go.constant.Constant.Kind))) {
		{
			var __tmp__ = stdgo.go.constant.Constant.int64Val(_val),
				_x:GoInt64 = __tmp__._0,
				_ok:Bool = __tmp__._1;
			if (_ok) {
				return Go.toInterface(_x);
			};
		};
		{
			var __tmp__ = stdgo.go.constant.Constant.uint64Val(_val),
				_x:GoUInt64 = __tmp__._0,
				_ok:Bool = __tmp__._1;
			if (_ok) {
				return Go.toInterface(_x);
			};
		};
	} else if (_val.kind() == ((4 : stdgo.go.constant.Constant.Kind))) {
		{
			var __tmp__ = stdgo.go.constant.Constant.float64Val(_val),
				_x:GoFloat64 = __tmp__._0,
				_ok:Bool = __tmp__._1;
			if (_ok) {
				return Go.toInterface(_x);
			};
		};
	} else if (_val.kind() == ((2 : stdgo.go.constant.Constant.Kind))) {
		return Go.toInterface(stdgo.go.constant.Constant.stringVal(_val));
	};
	return (null : AnyInterface);
}

/**
	// rangeKeyVal returns the key and value type produced by a range clause
	// over an expression of type typ. If the range clause is not permitted
	// the results are nil.
**/
private function _rangeKeyVal(_typ:Type):{var _0:Type; var _1:Type;} {
	var _key:Type = (null : Type), _val:Type = (null : Type);
	{
		final __type__ = _arrayPtrDeref(_typ);
		if (Go.typeEquals((__type__ : Ref<Basic>))) {
			var _typ:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
				.value;
			if (_isString(Go.asInterface(_typ))) {
				return {_0: Go.asInterface(typ[((2 : BasicKind) : GoInt)]), _1: _universeRune};
			};
		} else if (Go.typeEquals((__type__ : Ref<Array_>))) {
			var _typ:Ref<Array_> = __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__() == null ? (null : Ref<Array_>) : __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__()
				.value;
			return {_0: Go.asInterface(typ[((2 : BasicKind) : GoInt)]), _1: _typ._elem};
		} else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
			var _typ:Ref<Slice_> = __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__() == null ? (null : Ref<Slice_>) : __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__()
				.value;
			return {_0: Go.asInterface(typ[((2 : BasicKind) : GoInt)]), _1: _typ._elem};
		} else if (Go.typeEquals((__type__ : Ref<Map_>))) {
			var _typ:Ref<Map_> = __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__() == null ? (null : Ref<Map_>) : __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__()
				.value;
			return {_0: _typ._key, _1: _typ._elem};
		} else if (Go.typeEquals((__type__ : Ref<Chan>))) {
			var _typ:Ref<Chan> = __type__ == null ? (null : Ref<Chan>) : __type__.__underlying__() == null ? (null : Ref<Chan>) : __type__ == null ? (null : Ref<Chan>) : __type__.__underlying__()
				.value;
			return {_0: _typ._elem, _1: Go.asInterface(typ[((0 : BasicKind) : GoInt)])};
		};
	};
	return {_0: _key, _1: _val};
}

/**
	// NewStruct returns a new struct with the given fields and corresponding field tags.
	// If a field with index i has a tag, tags[i] must be that tag, but len(tags) may be
	// only as long as required to hold the tag with the largest index i. Consequently,
	// if no field has a tag, tags may be nil.
**/
function newStruct(_fields:Slice<Ref<Var>>, _tags:Slice<GoString>):Ref<Struct> {
	var _fset:T_objset = (null : T_objset);
	for (_0 => _f in _fields) {
		if ((_f._object._name != ("_" : GoString)) && (_fset._insert(Go.asInterface(_f)) != null)) {
			throw Go.toInterface(("multiple fields with the same name" : GoString));
		};
	};
	if ((_tags.length) > (_fields.length)) {
		throw Go.toInterface(("more tags than fields" : GoString));
	};
	var _s = (({_fields: _fields, _tags: _tags} : Struct) : Ref<Struct>);
	_s._markComplete();
	return _s;
}

private function _embeddedFieldIdent(_e:stdgo.go.ast.Ast.Expr):Ref<stdgo.go.ast.Ast.Ident> {
	{
		final __type__ = _e;
		if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ident>))) {
			var _e:Ref<stdgo.go.ast.Ast.Ident> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__()
				.value;
			return _e;
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.StarExpr>))) {
			var _e:Ref<stdgo.go.ast.Ast.StarExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__()
				.value;
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_e.x) : Ref<stdgo.go.ast.Ast.StarExpr>)) : Ref<stdgo.go.ast.Ast.StarExpr>), ok: true};
				} catch (_) {
					{value: (null : Ref<stdgo.go.ast.Ast.StarExpr>), ok: false};
				}, _0 = __tmp__.value, _ok = __tmp__.ok;
				if (!_ok) {
					return _embeddedFieldIdent(_e.x);
				};
			};
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectorExpr>))) {
			var _e:Ref<stdgo.go.ast.Ast.SelectorExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__()
				.value;
			return _e.sel;
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexExpr>))) {
			var _e:Ref<stdgo.go.ast.Ast.IndexExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IndexExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.IndexExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IndexExpr>) : __type__.__underlying__()
				.value;
			return _embeddedFieldIdent(_e.x);
		} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexListExpr>))) {
			var _e:Ref<stdgo.go.ast.Ast.IndexListExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IndexListExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.IndexListExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IndexListExpr>) : __type__.__underlying__()
				.value;
			return _embeddedFieldIdent(_e.x);
		};
	};
	return null;
}

/**
	// makeSubstMap creates a new substitution map mapping tpars[i] to targs[i].
	// If targs[i] is nil, tpars[i] is not substituted.
**/
private function _makeSubstMap(_tpars:Slice<Ref<TypeParam>>, _targs:Slice<Type>):T_substMap {
	_assert((_tpars.length) == ((_targs.length)));
	var _proj:T_substMap = (new GoObjectMap<Ref<TypeParam>,
		Type>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("T_substMap", [], null, false, {
		get: () -> null
	}))) : T_substMap);
	for (_i => _tpar in _tpars) {
		_proj[_tpar] = _targs[(_i : GoInt)];
	};
	return _proj;
}

/**
	// makeRenameMap is like makeSubstMap, but creates a map used to rename type
	// parameters in from with the type parameters in to.
**/
private function _makeRenameMap(_from:Slice<Ref<TypeParam>>, _to:Slice<Ref<TypeParam>>):T_substMap {
	_assert((_from.length) == ((_to.length)));
	var _proj:T_substMap = (new GoObjectMap<Ref<TypeParam>,
		Type>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("T_substMap", [], null, false, {
		get: () -> null
	}))) : T_substMap);
	for (_i => _tpar in _from) {
		_proj[_tpar] = Go.asInterface(_to[(_i : GoInt)]);
	};
	return _proj;
}

private function _substVar(_v:Ref<Var>, _typ:Type):Ref<Var> {
	var _copy:Var = (_v == null ? null : _v.__copy__());
	_copy._object._typ = _typ;
	_copy._origin = _v.origin();
	return (_copy : Ref<Var>);
}

private function _substFunc(_f:Ref<Func>, _typ:Type):Ref<Func> {
	var _copy:Func = (_f == null ? null : _f.__copy__());
	_copy._object._typ = _typ;
	_copy._origin = _f.origin();
	return (_copy : Ref<Func>);
}

/**
	// replaceRecvType updates any function receivers that have type old to have
	// type new. It does not modify the input slice; if modifications are required,
	// the input slice and any affected signatures will be copied before mutating.
	//
	// The resulting out slice contains the updated functions, and copied reports
	// if anything was modified.
**/
private function _replaceRecvType(_in:Slice<Ref<Func>>, _old:Type, _new:Type):{var _0:Slice<Ref<Func>>; var _1:Bool;} {
	var _out:Slice<Ref<Func>> = (null : Slice<Ref<Func>>),
		_copied:Bool = false;
	_out = _in;
	for (_i => _method in _in) {
		var _sig = (Go.typeAssert((Go.toInterface(_method.type()) : Ref<Signature>)) : Ref<Signature>);
		if ((_sig._recv != null) && (Go.toInterface(_sig._recv.type()) == Go.toInterface(_old))) {
			if (!_copied) {
				_out = new Slice<Ref<Func>>((_in.length : GoInt).toBasic(), 0, ...[for (i in 0...(_in.length : GoInt).toBasic()) (null : Ref<Func>)]);
				Go.copySlice(_out, _in);
				_copied = true;
			};
			var _newsig:Signature = (_sig == null ? null : _sig.__copy__());
			_newsig._recv = _substVar(_sig._recv, _new);
			_out[(_i : GoInt)] = _substFunc(_method, Go.asInterface((_newsig : Ref<Signature>)));
		};
	};
	return {_0: _out, _1: _copied};
}

/**
	// maketl makes a term list from a string of the term list.
**/
private function _maketl(_s:GoString):T_termlist {
	_s = stdgo.strings.Strings.replaceAll(_s, (" " : GoString), Go.str());
	var _names = stdgo.strings.Strings.split(_s, ("|" : GoString));
	var _r:T_termlist = new T_termlist((_names.length : GoInt).toBasic(), 0, ...[for (i in 0...(_names.length : GoInt).toBasic()) (null : Ref<T_term>)]);
	for (_i => _n in _names) {
		_r[(_i : GoInt)] = _testTerm(_n);
	};
	return _r;
}

function testTermlistAll(_t:Ref<stdgo.testing.Testing.T>):Void {
	if (!_allTermlist._isAll()) {
		_t.errorf(("allTermlist is not the set of all types" : GoString));
	};
}

function testTermlistString(_t:Ref<stdgo.testing.Testing.T>):Void {
	for (_0 => _want in (new Slice<GoString>(0, 0, ("∅" : GoString), ("𝓤" : GoString), ("int" : GoString), ("~int" : GoString), ("myInt" : GoString),
		("∅ | ∅" : GoString), ("𝓤 | 𝓤" : GoString), ("∅ | 𝓤 | int" : GoString), ("∅ | 𝓤 | int | myInt" : GoString)) : Slice<GoString>)) {
		{
			var _got:GoString = (_maketl(_want).string() : GoString);
			if (_got != (_want)) {
				_t.errorf(("(%v).String() == %v" : GoString), Go.toInterface(_want), Go.toInterface(_got));
			};
		};
	};
}

function testTermlistIsEmpty(_t:Ref<stdgo.testing.Testing.T>):Void {
	for (_test => _want in ({
		final x = new stdgo.GoMap.GoObjectMap<GoString,
			Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
				stdgo.internal.reflect.Reflect.GoType.basic(string_kind)}, {get: () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind)})));
		@:privateAccess x._keys = [
			("∅" : GoString),
			("∅ | ∅" : GoString),
			("∅ | ∅ | 𝓤" : GoString),
			("∅ | ∅ | myInt" : GoString),
			("𝓤" : GoString),
			("𝓤 | int" : GoString),
			("𝓤 | myInt | ∅" : GoString)
		];
		@:privateAccess x._values = [false, false, false, false, false, false, false];
		x;
	} : stdgo.GoMap<GoString, Bool>)) {
		var _xl:T_termlist = _maketl(_test);
		var _got:Bool = _xl._isEmpty();
		if (_got != (_want)) {
			_t.errorf(("(%v).isEmpty() == %v; want %v" : GoString), Go.toInterface(_test), Go.toInterface(_got), Go.toInterface(_want));
		};
	};
}

function testTermlistIsAll(_t:Ref<stdgo.testing.Testing.T>):Void {
	for (_test => _want in ({
		final x = new stdgo.GoMap.GoObjectMap<GoString,
			Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
				stdgo.internal.reflect.Reflect.GoType.basic(string_kind)}, {get: () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind)})));
		@:privateAccess x._keys = [
			("∅" : GoString),
			("∅ | ∅" : GoString),
			("int | ~string" : GoString),
			("~int | myInt" : GoString),
			("∅ | ∅ | 𝓤" : GoString),
			("𝓤" : GoString),
			("𝓤 | int" : GoString),
			("myInt | 𝓤" : GoString)
		];
		@:privateAccess x._values = [false, false, false, false, false, false, false, false];
		x;
	} : stdgo.GoMap<GoString, Bool>)) {
		var _xl:T_termlist = _maketl(_test);
		var _got:Bool = _xl._isAll();
		if (_got != (_want)) {
			_t.errorf(("(%v).isAll() == %v; want %v" : GoString), Go.toInterface(_test), Go.toInterface(_got), Go.toInterface(_want));
		};
	};
}

function testTermlistNorm(_t:Ref<stdgo.testing.Testing.T>):Void {
	for (_0 => _test in (new Slice<T__struct_2>(0, 0, ({_xl: ("∅" : GoString), _want: ("∅" : GoString)} : T__struct_2),
		({_xl: ("∅ | ∅" : GoString), _want: ("∅" : GoString)} : T__struct_2), ({_xl: ("∅ | int" : GoString), _want: ("int" : GoString)} : T__struct_2),
		({_xl: ("∅ | myInt" : GoString), _want: ("myInt" : GoString)} : T__struct_2),
		({_xl: ("𝓤 | int" : GoString), _want: ("𝓤" : GoString)} : T__struct_2), ({_xl: ("𝓤 | myInt" : GoString), _want: ("𝓤" : GoString)} : T__struct_2),
		({_xl: ("int | myInt" : GoString), _want: ("int | myInt" : GoString)} : T__struct_2),
		({_xl: ("~int | int" : GoString), _want: ("~int" : GoString)} : T__struct_2),
		({_xl: ("~int | myInt" : GoString), _want: ("~int" : GoString)} : T__struct_2),
		({_xl: ("int | ~string | int" : GoString), _want: ("int | ~string" : GoString)} : T__struct_2),
		({_xl: ("~int | string | 𝓤 | ~string | int" : GoString), _want: ("𝓤" : GoString)} : T__struct_2),
		({_xl: ("~int | string | myInt | ~string | int" : GoString), _want: ("~int | ~string" : GoString)} : T__struct_2)) : Slice<T__struct_2>)) {
		var _xl:T_termlist = _maketl(_test._xl);
		var _got:T_termlist = _maketl(_test._xl)._norm();
		if ((_got.string() : GoString) != (_test._want)) {
			_t.errorf(("(%v).norm() = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_xl)), Go.toInterface(Go.asInterface(_got)),
				Go.toInterface(_test._want));
		};
	};
}

function testTermlistUnion(_t:Ref<stdgo.testing.Testing.T>):Void {
	for (_0 => _test in (new Slice<T__struct_3>(0, 0, ({_xl: ("∅" : GoString), _yl: ("∅" : GoString), _want: ("∅" : GoString)} : T__struct_3),
		({_xl: ("∅" : GoString), _yl: ("𝓤" : GoString), _want: ("𝓤" : GoString)} : T__struct_3),
		({_xl: ("∅" : GoString), _yl: ("int" : GoString), _want: ("int" : GoString)} : T__struct_3),
		({_xl: ("𝓤" : GoString), _yl: ("~int" : GoString), _want: ("𝓤" : GoString)} : T__struct_3),
		({_xl: ("int" : GoString), _yl: ("~int" : GoString), _want: ("~int" : GoString)} : T__struct_3),
		({_xl: ("int" : GoString), _yl: ("string" : GoString), _want: ("int | string" : GoString)} : T__struct_3),
		({_xl: ("int" : GoString), _yl: ("myInt" : GoString), _want: ("int | myInt" : GoString)} : T__struct_3),
		({_xl: ("~int" : GoString), _yl: ("myInt" : GoString), _want: ("~int" : GoString)} : T__struct_3),
		({_xl: ("int | string" : GoString), _yl: ("~string" : GoString), _want: ("int | ~string" : GoString)} : T__struct_3),
		({_xl: ("~int | string" : GoString), _yl: ("~string | int" : GoString), _want: ("~int | ~string" : GoString)} : T__struct_3),
		({_xl: ("~int | string | ∅" : GoString), _yl: ("~string | int" : GoString), _want: ("~int | ~string" : GoString)} : T__struct_3),
		({_xl: ("~int | myInt | ∅" : GoString), _yl: ("~string | int" : GoString), _want: ("~int | ~string" : GoString)} : T__struct_3),
		({_xl: ("~int | string | 𝓤" : GoString), _yl: ("~string | int" : GoString), _want: ("𝓤" : GoString)} : T__struct_3),
		({_xl: ("~int | string | myInt" : GoString), _yl: ("~string | int" : GoString),
			_want: ("~int | ~string" : GoString)} : T__struct_3)) : Slice<T__struct_3>)) {
		var _xl:T_termlist = _maketl(_test._xl);
		var _yl:T_termlist = _maketl(_test._yl);
		var _got:GoString = (_xl._union(_yl).string() : GoString);
		if (_got != (_test._want)) {
			_t.errorf(("(%v).union(%v) = %v; want %v" : GoString), Go.toInterface(_test._xl), Go.toInterface(_test._yl), Go.toInterface(_got),
				Go.toInterface(_test._want));
		};
	};
}

function testTermlistIntersect(_t:Ref<stdgo.testing.Testing.T>):Void {
	for (_0 => _test in (new Slice<T__struct_3>(0, 0, ({_xl: ("∅" : GoString), _yl: ("∅" : GoString), _want: ("∅" : GoString)} : T__struct_3),
		({_xl: ("∅" : GoString), _yl: ("𝓤" : GoString), _want: ("∅" : GoString)} : T__struct_3),
		({_xl: ("∅" : GoString), _yl: ("int" : GoString), _want: ("∅" : GoString)} : T__struct_3),
		({_xl: ("∅" : GoString), _yl: ("myInt" : GoString), _want: ("∅" : GoString)} : T__struct_3),
		({_xl: ("𝓤" : GoString), _yl: ("~int" : GoString), _want: ("~int" : GoString)} : T__struct_3),
		({_xl: ("𝓤" : GoString), _yl: ("myInt" : GoString), _want: ("myInt" : GoString)} : T__struct_3),
		({_xl: ("int" : GoString), _yl: ("~int" : GoString), _want: ("int" : GoString)} : T__struct_3),
		({_xl: ("int" : GoString), _yl: ("string" : GoString), _want: ("∅" : GoString)} : T__struct_3),
		({_xl: ("int" : GoString), _yl: ("myInt" : GoString), _want: ("∅" : GoString)} : T__struct_3),
		({_xl: ("~int" : GoString), _yl: ("myInt" : GoString), _want: ("myInt" : GoString)} : T__struct_3),
		({_xl: ("int | string" : GoString), _yl: ("~string" : GoString), _want: ("string" : GoString)} : T__struct_3),
		({_xl: ("~int | string" : GoString), _yl: ("~string | int" : GoString), _want: ("int | string" : GoString)} : T__struct_3),
		({_xl: ("~int | string | ∅" : GoString), _yl: ("~string | int" : GoString), _want: ("int | string" : GoString)} : T__struct_3),
		({_xl: ("~int | myInt | ∅" : GoString), _yl: ("~string | int" : GoString), _want: ("int" : GoString)} : T__struct_3),
		({_xl: ("~int | string | 𝓤" : GoString), _yl: ("~string | int" : GoString), _want: ("int | ~string" : GoString)} : T__struct_3),
		({_xl: ("~int | string | myInt" : GoString), _yl: ("~string | int" : GoString),
			_want: ("int | string" : GoString)} : T__struct_3)) : Slice<T__struct_3>)) {
		var _xl:T_termlist = _maketl(_test._xl);
		var _yl:T_termlist = _maketl(_test._yl);
		var _got:GoString = (_xl._intersect(_yl).string() : GoString);
		if (_got != (_test._want)) {
			_t.errorf(("(%v).intersect(%v) = %v; want %v" : GoString), Go.toInterface(_test._xl), Go.toInterface(_test._yl), Go.toInterface(_got),
				Go.toInterface(_test._want));
		};
	};
}

function testTermlistEqual(_t:Ref<stdgo.testing.Testing.T>):Void {
	for (_0 => _test in (new Slice<T__struct_4>(0, 0, ({_xl: ("∅" : GoString), _yl: ("∅" : GoString), _want: true} : T__struct_4),
		({_xl: ("∅" : GoString), _yl: ("𝓤" : GoString), _want: false} : T__struct_4),
		({_xl: ("𝓤" : GoString), _yl: ("𝓤" : GoString), _want: true} : T__struct_4),
		({_xl: ("𝓤 | int" : GoString), _yl: ("𝓤" : GoString), _want: true} : T__struct_4),
		({_xl: ("𝓤 | int" : GoString), _yl: ("string | 𝓤" : GoString), _want: true} : T__struct_4),
		({_xl: ("𝓤 | myInt" : GoString), _yl: ("string | 𝓤" : GoString), _want: true} : T__struct_4),
		({_xl: ("int | ~string" : GoString), _yl: ("string | int" : GoString), _want: false} : T__struct_4),
		({_xl: ("~int | string" : GoString), _yl: ("string | myInt" : GoString), _want: false} : T__struct_4),
		({_xl: ("int | ~string | ∅" : GoString), _yl: ("string | int | ~string" : GoString), _want: true} : T__struct_4)) : Slice<T__struct_4>)) {
		var _xl:T_termlist = _maketl(_test._xl);
		var _yl:T_termlist = _maketl(_test._yl);
		var _got:Bool = _xl._equal(_yl);
		if (_got != (_test._want)) {
			_t.errorf(("(%v).equal(%v) = %v; want %v" : GoString), Go.toInterface(_test._xl), Go.toInterface(_test._yl), Go.toInterface(_got),
				Go.toInterface(_test._want));
		};
	};
}

function testTermlistIncludes(_t:Ref<stdgo.testing.Testing.T>):Void {
	for (_0 => _test in (new Slice<T__struct_5>(0, 0, ({_xl: ("∅" : GoString), _typ: ("int" : GoString), _want: false} : T__struct_5),
		({_xl: ("𝓤" : GoString), _typ: ("int" : GoString), _want: true} : T__struct_5),
		({_xl: ("~int" : GoString), _typ: ("int" : GoString), _want: true} : T__struct_5),
		({_xl: ("int" : GoString), _typ: ("string" : GoString), _want: false} : T__struct_5),
		({_xl: ("~int" : GoString), _typ: ("string" : GoString), _want: false} : T__struct_5),
		({_xl: ("~int" : GoString), _typ: ("myInt" : GoString), _want: true} : T__struct_5),
		({_xl: ("int | string" : GoString), _typ: ("string" : GoString), _want: true} : T__struct_5),
		({_xl: ("~int | string" : GoString), _typ: ("int" : GoString), _want: true} : T__struct_5),
		({_xl: ("~int | string" : GoString), _typ: ("myInt" : GoString), _want: true} : T__struct_5),
		({_xl: ("~int | myInt | ∅" : GoString), _typ: ("myInt" : GoString), _want: true} : T__struct_5),
		({_xl: ("myInt | ∅ | 𝓤" : GoString), _typ: ("int" : GoString), _want: true} : T__struct_5)) : Slice<T__struct_5>)) {
		var _xl:T_termlist = _maketl(_test._xl);
		var _yl:Type = _testTerm(_test._typ)._typ;
		var _got:Bool = _xl._includes(_yl);
		if (_got != (_test._want)) {
			_t.errorf(("(%v).includes(%v) = %v; want %v" : GoString), Go.toInterface(_test._xl), Go.toInterface(_yl), Go.toInterface(_got),
				Go.toInterface(_test._want));
		};
	};
}

function testTermlistSupersetOf(_t:Ref<stdgo.testing.Testing.T>):Void {
	for (_0 => _test in (new Slice<T__struct_5>(0, 0, ({_xl: ("∅" : GoString), _typ: ("∅" : GoString), _want: true} : T__struct_5),
		({_xl: ("∅" : GoString), _typ: ("𝓤" : GoString), _want: false} : T__struct_5),
		({_xl: ("∅" : GoString), _typ: ("int" : GoString), _want: false} : T__struct_5),
		({_xl: ("𝓤" : GoString), _typ: ("∅" : GoString), _want: true} : T__struct_5),
		({_xl: ("𝓤" : GoString), _typ: ("𝓤" : GoString), _want: true} : T__struct_5),
		({_xl: ("𝓤" : GoString), _typ: ("int" : GoString), _want: true} : T__struct_5),
		({_xl: ("𝓤" : GoString), _typ: ("~int" : GoString), _want: true} : T__struct_5),
		({_xl: ("𝓤" : GoString), _typ: ("myInt" : GoString), _want: true} : T__struct_5),
		({_xl: ("~int" : GoString), _typ: ("int" : GoString), _want: true} : T__struct_5),
		({_xl: ("~int" : GoString), _typ: ("~int" : GoString), _want: true} : T__struct_5),
		({_xl: ("~int" : GoString), _typ: ("myInt" : GoString), _want: true} : T__struct_5),
		({_xl: ("int" : GoString), _typ: ("~int" : GoString), _want: false} : T__struct_5),
		({_xl: ("myInt" : GoString), _typ: ("~int" : GoString), _want: false} : T__struct_5),
		({_xl: ("int" : GoString), _typ: ("string" : GoString), _want: false} : T__struct_5),
		({_xl: ("~int" : GoString), _typ: ("string" : GoString), _want: false} : T__struct_5),
		({_xl: ("int | string" : GoString), _typ: ("string" : GoString), _want: true} : T__struct_5),
		({_xl: ("int | string" : GoString), _typ: ("~string" : GoString), _want: false} : T__struct_5),
		({_xl: ("~int | string" : GoString), _typ: ("int" : GoString), _want: true} : T__struct_5),
		({_xl: ("~int | string" : GoString), _typ: ("myInt" : GoString), _want: true} : T__struct_5),
		({_xl: ("~int | string | ∅" : GoString), _typ: ("string" : GoString), _want: true} : T__struct_5),
		({_xl: ("~string | ∅ | 𝓤" : GoString), _typ: ("myInt" : GoString), _want: true} : T__struct_5)) : Slice<T__struct_5>)) {
		var _xl:T_termlist = _maketl(_test._xl);
		var _y = _testTerm(_test._typ);
		var _got:Bool = _xl._supersetOf(_y);
		if (_got != (_test._want)) {
			_t.errorf(("(%v).supersetOf(%v) = %v; want %v" : GoString), Go.toInterface(_test._xl), Go.toInterface(Go.asInterface(_y)), Go.toInterface(_got),
				Go.toInterface(_test._want));
		};
	};
}

function testTermlistSubsetOf(_t:Ref<stdgo.testing.Testing.T>):Void {
	for (_0 => _test in (new Slice<T__struct_4>(0, 0, ({_xl: ("∅" : GoString), _yl: ("∅" : GoString), _want: true} : T__struct_4),
		({_xl: ("∅" : GoString), _yl: ("𝓤" : GoString), _want: true} : T__struct_4),
		({_xl: ("𝓤" : GoString), _yl: ("∅" : GoString), _want: false} : T__struct_4),
		({_xl: ("𝓤" : GoString), _yl: ("𝓤" : GoString), _want: true} : T__struct_4),
		({_xl: ("int" : GoString), _yl: ("int | string" : GoString), _want: true} : T__struct_4),
		({_xl: ("~int" : GoString), _yl: ("int | string" : GoString), _want: false} : T__struct_4),
		({_xl: ("~int" : GoString), _yl: ("myInt | string" : GoString), _want: false} : T__struct_4),
		({_xl: ("myInt" : GoString), _yl: ("~int | string" : GoString), _want: true} : T__struct_4),
		({_xl: ("~int" : GoString), _yl: ("string | string | int | ~int" : GoString), _want: true} : T__struct_4),
		({_xl: ("myInt" : GoString), _yl: ("string | string | ~int" : GoString), _want: true} : T__struct_4),
		({_xl: ("int | string" : GoString), _yl: ("string" : GoString), _want: false} : T__struct_4),
		({_xl: ("int | string" : GoString), _yl: ("string | int" : GoString), _want: true} : T__struct_4),
		({_xl: ("int | ~string" : GoString), _yl: ("string | int" : GoString), _want: false} : T__struct_4),
		({_xl: ("myInt | ~string" : GoString), _yl: ("string | int | 𝓤" : GoString), _want: true} : T__struct_4),
		({_xl: ("int | ~string" : GoString), _yl: ("string | int | ∅ | string" : GoString), _want: false} : T__struct_4),
		({_xl: ("int | myInt" : GoString), _yl: ("string | ~int | ∅ | string" : GoString), _want: true} : T__struct_4)) : Slice<T__struct_4>)) {
		var _xl:T_termlist = _maketl(_test._xl);
		var _yl:T_termlist = _maketl(_test._yl);
		var _got:Bool = _xl._subsetOf(_yl);
		if (_got != (_test._want)) {
			_t.errorf(("(%v).subsetOf(%v) = %v; want %v" : GoString), Go.toInterface(_test._xl), Go.toInterface(_test._yl), Go.toInterface(_got),
				Go.toInterface(_test._want));
		};
	};
}

function testZeroTok(_t:Ref<stdgo.testing.Testing.T>):Void {
	var _zero:stdgo.go.token.Token.Token = ((0 : GoInt) : stdgo.go.token.Token.Token);
	if ((0 : stdgo.go.token.Token.Token) != (_zero)) {
		_t.errorf(("%s == %d; want 0" : GoString), Go.toInterface(Go.asInterface((0 : stdgo.go.token.Token.Token))), Go.toInterface(Go.asInterface(_zero)));
	};
}

function testAssignOp(_t:Ref<stdgo.testing.Testing.T>):Void {
	{
		var _i:GoInt = (0 : GoInt);
		Go.cfor(_i < (256:GoInt), _i++, {
			var _tok:stdgo.go.token.Token.Token = (_i : stdgo.go.token.Token.Token);
			var _got:stdgo.go.token.Token.Token = _assignOp(_tok);
			var _want:stdgo.go.token.Token.Token = _assignOps[_tok];
			if (_got != (_want)) {
				_t.errorf(("for assignOp(%s): got %s; want %s" : GoString), Go.toInterface(Go.asInterface(_tok)), Go.toInterface(Go.asInterface(_got)),
					Go.toInterface(Go.asInterface(_want)));
			};
		});
	};
}

/**
	// NewTuple returns a new tuple for the given variables.
**/
function newTuple(_x:haxe.Rest<Ref<Var>>):Ref<Tuple> {
	var _x = new Slice<Ref<Var>>(0, 0, ..._x);
	if ((_x.length) > (0 : GoInt)) {
		return (({_vars: _x} : Tuple) : Ref<Tuple>);
	};
	return null;
}

/**
	// under returns the true expanded underlying type.
	// If it doesn't exist, the result is Typ[Invalid].
	// under must only be called when a type is known
	// to be fully set up.
**/
private function _under(_t:Type):Type {
	{
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_t) : Ref<Named>)) : Ref<Named>), ok: true};
		} catch (_) {
			{value: (null : Ref<Named>), ok: false};
		}, _t = __tmp__.value, _0 = __tmp__.ok;
		if (_t != null) {
			return _t._under();
		};
	};
	return _t.underlying();
}

/**
	// If t is not a type parameter, coreType returns the underlying type.
	// If t is a type parameter, coreType returns the single underlying
	// type of all types in its type set if it exists, or nil otherwise. If the
	// type set contains only unrestricted and restricted channel types (with
	// identical element types), the single underlying type is the restricted
	// channel type if the restrictions are always the same, or nil otherwise.
**/
private function _coreType(_t:Type):Type {
	var __tmp__ = try {
		{value: (Go.typeAssert((Go.toInterface(_t) : Ref<TypeParam>)) : Ref<TypeParam>), ok: true};
	} catch (_) {
		{value: (null : Ref<TypeParam>), ok: false};
	}, _tpar = __tmp__.value, _0 = __tmp__.ok;
	if (_tpar == null) {
		return _under(_t);
	};
	var _su:Type = (null : Type);
	if (_tpar._underIs(function(_u:Type):Bool {
		if (_u == null) {
			return false;
		};
		if (_su != null) {
			_u = _match(_su, _u);
			if (_u == null) {
				return false;
			};
		};
		_su = _u;
		return true;
	})) {
		return _su;
	};
	return (null : Type);
}

/**
	// coreString is like coreType but also considers []byte
	// and strings as identical. In this case, if successful and we saw
	// a string, the result is of type (possibly untyped) string.
**/
private function _coreString(_t:Type):Type {
	var __tmp__ = try {
		{value: (Go.typeAssert((Go.toInterface(_t) : Ref<TypeParam>)) : Ref<TypeParam>), ok: true};
	} catch (_) {
		{value: (null : Ref<TypeParam>), ok: false};
	}, _tpar = __tmp__.value, _0 = __tmp__.ok;
	if (_tpar == null) {
		return _under(_t);
	};
	var _su:Type = (null : Type);
	var _hasString:Bool = false;
	if (_tpar._underIs(function(_u:Type):Bool {
		if (_u == null) {
			return false;
		};
		if (_isString(_u)) {
			_u = Go.asInterface(newSlice(_universeByte));
			_hasString = true;
		};
		if (_su != null) {
			_u = _match(_su, _u);
			if (_u == null) {
				return false;
			};
		};
		_su = _u;
		return true;
	})) {
		if (_hasString) {
			return Go.asInterface(typ[((17 : BasicKind) : GoInt)]);
		};
		return _su;
	};
	return (null : Type);
}

/**
	// If x and y are identical, match returns x.
	// If x and y are identical channels but for their direction
	// and one of them is unrestricted, match returns the channel
	// with the restricted direction.
	// In all other cases, match returns nil.
**/
private function _match(_x:Type, _y:Type):Type {
	if (identical(_x, _y)) {
		return _x;
	};
	{
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_x) : Ref<Chan>)) : Ref<Chan>), ok: true};
		} catch (_) {
			{value: (null : Ref<Chan>), ok: false};
		}, _x = __tmp__.value, _0 = __tmp__.ok;
		if (_x != null) {
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Chan>)) : Ref<Chan>), ok: true};
				} catch (_) {
					{value: (null : Ref<Chan>), ok: false};
				}, _y = __tmp__.value, _1 = __tmp__.ok;
				if ((_y != null) && identical(_x._elem, _y._elem)) {
					if (_x._dir == ((0 : ChanDir))) {
						return Go.asInterface(_y);
					} else if (_y._dir == ((0 : ChanDir))) {
						return Go.asInterface(_x);
					};
				};
			};
		};
	};
	return (null : Type);
}

/**
	// newTypeList returns a new TypeList with the types in list.
**/
private function _newTypeList(_list:Slice<Type>):Ref<TypeList> {
	if ((_list.length) == ((0 : GoInt))) {
		return null;
	};
	return ((new TypeList(_list) : TypeList) : Ref<TypeList>);
}

private function _bindTParams(_list:Slice<Ref<TypeParam>>):Ref<TypeParamList> {
	if ((_list.length) == ((0 : GoInt))) {
		return null;
	};
	for (_i => _typ in _list) {
		if (_typ._index >= (0 : GoInt)) {
			throw Go.toInterface(("type parameter bound more than once" : GoString));
		};
		_typ._index = _i;
	};
	return (({_tparams: _list} : TypeParamList) : Ref<TypeParamList>);
}

/**
	// nextID returns a value increasing monotonically by 1 with
	// each call, starting with 1. It may be called concurrently.
**/
private function _nextID():GoUInt64 {
	return (stdgo.sync.atomic.Atomic.addUint32(Go.pointer(_lastID), ("1" : GoUInt32)) : GoUInt64);
}

/**
	// NewTypeParam returns a new TypeParam. Type parameters may be set on a Named
	// or Signature type by calling SetTypeParams. Setting a type parameter on more
	// than one type will result in a panic.
	//
	// The constraint argument can be nil, and set later via SetConstraint. If the
	// constraint is non-nil, it must be fully defined.
**/
function newTypeParam(_obj:Ref<TypeName>, _constraint:Type):Ref<TypeParam> {
	return (null : Ref<Checker>)._newTypeParam(_obj, _constraint);
}

/**
	// computeInterfaceTypeSet may be called with check == nil.
**/
private function _computeInterfaceTypeSet(_check:Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _ityp:Ref<Interface>):Ref<T__TypeSet> {
	var __deferstack__:Array<Void->Void> = [];
	if (_ityp._tset != null) {
		return _ityp._tset;
	};
	if (!_ityp._complete) {
		return (_topTypeSet : Ref<T__TypeSet>);
	};
	try {
		if ((_check != null) && false) {
			if (!_pos.isValid() && (_ityp._methods.length > (0 : GoInt))) {
				_pos = _ityp._methods[(0 : GoInt)]._object._pos;
			};
			_check._trace(_pos, ("-- type set for %s" : GoString), Go.toInterface(Go.asInterface(_ityp)));
			_check._indent++;
			__deferstack__.unshift(() -> {
				var a = function():Void {
					_check._indent--;
					_check._trace(_pos, ("=> %s " : GoString), Go.toInterface(Go.asInterface(_ityp._typeSet())));
				};
				a();
			});
		};
		_ityp._tset = (({_terms: _allTermlist} : T__TypeSet) : Ref<T__TypeSet>);
		var _unionSets:GoMap<Ref<Union>, Ref<T__TypeSet>> = (null : GoMap<Ref<Union>, Ref<T__TypeSet>>);
		if (_check != null) {
			if (_check._unionTypeSets == null) {
				_check._unionTypeSets = (new GoObjectMap<Ref<Union>,
					Ref<T__TypeSet>>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({
					get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("Union", [], null, false,
						{get: () -> null})})
				},
					{get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("T__TypeSet", [], null,
						false, {get: () -> null})})}))) : GoMap<Ref<Union>, Ref<T__TypeSet>>);
			};
			_unionSets = _check._unionTypeSets;
		} else {
			_unionSets = (new GoObjectMap<Ref<Union>,
				Ref<T__TypeSet>>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
					stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("Union", [], null, false, {get: () ->
						null})})},
				{get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("T__TypeSet", [], null,
					false, {get: () -> null})})}))) : GoMap<Ref<Union>, Ref<T__TypeSet>>);
		};
		var _todo:Slice<Ref<Func>> = (null : Slice<Ref<Func>>);
		var _seen:T_objset = (null : T_objset);
		var _allMethods:Slice<Ref<Func>> = (null : Slice<Ref<Func>>);
		var _mpos = (new GoObjectMap<Ref<Func>,
			stdgo.go.token.Token.Pos>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({
			get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("Func", [], null, false,
				{get: () -> null})})
		},
			{get: () -> stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.token.Token.Pos", [], null, false,
				{get: () -> null})}))) : GoMap<Ref<Func>, stdgo.go.token.Token.Pos>);
		var _addMethod = function(_pos:stdgo.go.token.Token.Pos, _m:Ref<Func>, _explicit:Bool):Void {
			{
				var _other:Object = _seen._insert(Go.asInterface(_m));
				{
					var __switchIndex__ = -1;
					while (true) {
						if (_other == null) {
							_allMethods = _allMethods.__appendref__(_m);
							_mpos[_m] = _pos;
							break;
						} else if (_explicit) {
							if (_check == null) {
								throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("%v: duplicate method %s" : GoString),
									Go.toInterface(Go.asInterface(_m._object._pos)), Go.toInterface(_m._object._name)));
							};
							_check._errorf(Go.asInterface((_pos : T_atPos)), (10 : T_errorCode), ("duplicate method %s" : GoString),
								Go.toInterface(_m._object._name));
							_check._errorf(Go.asInterface((_mpos[(Go.typeAssert((Go.toInterface(_other) : Ref<Func>)) : Ref<Func>)] : T_atPos)),
								(10 : T_errorCode), ("\tother declaration of %s" : GoString), Go.toInterface(_m._object._name));
							break;
						} else {
							if (_check == null) {
								_todo = _todo.__appendref__(_m, (Go.typeAssert((Go.toInterface(_other) : Ref<Func>)) : Ref<Func>));
								break;
							};
							_check._later(function():Void {
								if (!_check._allowVersion(_m._object._pkg, (1 : GoInt), (14 : GoInt))
									|| !identical(_m._object._typ, _other.type())) {
									_check._errorf(Go.asInterface((_pos : T_atPos)), (10 : T_errorCode), ("duplicate method %s" : GoString),
										Go.toInterface(_m._object._name));
									_check._errorf(Go.asInterface((_mpos[(Go.typeAssert((Go.toInterface(_other) : Ref<Func>)) : Ref<Func>)] : T_atPos)),
										(10 : T_errorCode), ("\tother declaration of %s" : GoString), Go.toInterface(_m._object._name));
								};
							})._describef(Go.asInterface((_pos : T_atPos)), ("duplicate method check for %s" : GoString), Go.toInterface(_m._object._name));
						};
						break;
					};
				};
			};
		};
		for (_20 => _m in _ityp._methods) {
			_addMethod(_m._object._pos, _m, true);
		};
		var _allTerms:T_termlist = _allTermlist;
		var _allComparable:Bool = false;
		for (_i => _typ in _ityp._embeddeds) {
			var _pos:stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
			if (_ityp._embedPos != null) {
				_pos = (_ityp._embedPos)[(_i : GoInt)];
			};
			var _comparable:Bool = false;
			var _terms:T_termlist = new T_termlist(0, 0);
			{
				final __type__ = _under(_typ);
				if (Go.typeEquals((__type__ : Ref<Interface>))) {
					var _u:Ref<Interface> = __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__() == null ? (null : Ref<Interface>) : __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__()
						.value;
					_assert(!_isTypeParam(_typ));
					var _tset = _computeInterfaceTypeSet(_check, _pos, _u);
					if (((_check != null) && _check._isImportedConstraint(_typ))
						&& !_check._allowVersion(_check._pkg, (1 : GoInt), (18 : GoInt))) {
						_check._errorf(Go.asInterface((_pos : T_atPos)), (135 : T_errorCode),
							("embedding constraint interface %s requires go1.18 or later" : GoString), Go.toInterface(_typ));
						continue;
					};
					_comparable = _tset._comparable;
					for (_31 => _m in _tset._methods) {
						_addMethod(_pos, _m, false);
					};
					_terms = _tset._terms;
				} else if (Go.typeEquals((__type__ : Ref<Union>))) {
					var _u:Ref<Union> = __type__ == null ? (null : Ref<Union>) : __type__.__underlying__() == null ? (null : Ref<Union>) : __type__ == null ? (null : Ref<Union>) : __type__.__underlying__()
						.value;
					if ((_check != null) && !_check._allowVersion(_check._pkg, (1 : GoInt), (18 : GoInt))) {
						_check._errorf(Go.asInterface((_pos : T_atPos)), (29 : T_errorCode),
							("embedding interface element %s requires go1.18 or later" : GoString), Go.toInterface(Go.asInterface(_u)));
						continue;
					};
					var _tset = _computeUnionTypeSet(_check, _unionSets, _pos, _u);
					if (_tset == ((_invalidTypeSet : Ref<T__TypeSet>))) {
						continue;
					};
					_assert(!_tset._comparable);
					_assert((_tset._methods.length) == ((0 : GoInt)));
					_terms = _tset._terms;
				} else {
					var _u:Type = __type__ == null ? (null : Type) : cast __type__;
					if (Go.toInterface(_u) == (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
						continue;
					};
					if ((_check != null) && !_check._allowVersion(_check._pkg, (1 : GoInt), (18 : GoInt))) {
						_check._errorf(Go.asInterface((_pos : T_atPos)), (29 : T_errorCode),
							("embedding non-interface type %s requires go1.18 or later" : GoString), Go.toInterface(_typ));
						continue;
					};
					_terms = (new Slice<Ref<T_term>>(0, 0, (new T_term(false, _typ) : T_term)) : T_termlist);
				};
			};
			{
				var __tmp__ = _intersectTermLists(_allTerms, _allComparable, _terms, _comparable);
				_allTerms = __tmp__._0;
				_allComparable = __tmp__._1;
			};
		};
		_ityp._embedPos = null;
		{
			var _i:GoInt = (0 : GoInt);
			Go.cfor(_i < (_todo.length), _i = _i + ((2 : GoInt)), {
				var _m = _todo[(_i : GoInt)];
				var _other = _todo[(_i + (1 : GoInt) : GoInt)];
				if (!identical(_m._object._typ, _other._object._typ)) {
					throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("%v: duplicate method %s" : GoString), Go.toInterface(Go.asInterface(_m._object._pos)),
						Go.toInterface(_m._object._name)));
				};
			});
		};
		_ityp._tset._comparable = _allComparable;
		if ((_allMethods.length) != ((0 : GoInt))) {
			_sortMethods(_allMethods);
			_ityp._tset._methods = _allMethods;
		};
		_ityp._tset._terms = _allTerms;
		{
			for (defer in __deferstack__) {
				defer();
			};
			return _ityp._tset;
		};
		for (defer in __deferstack__) {
			defer();
		};
		{
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return (null : Ref<T__TypeSet>);
		};
	} catch (__exception__) {
		if (!(__exception__.native is AnyInterfaceData))
			throw __exception__;
		Go.recover_exception = __exception__.native;
		for (defer in __deferstack__) {
			defer();
		};
		if (Go.recover_exception != null)
			throw Go.recover_exception;
		return (null : Ref<T__TypeSet>);
	};
}

/**
	// intersectTermLists computes the intersection of two term lists and respective comparable bits.
	// xcomp, ycomp are valid only if xterms.isAll() and yterms.isAll() respectively.
**/
private function _intersectTermLists(_xterms:T_termlist, _xcomp:Bool, _yterms:T_termlist, _ycomp:Bool):{var _0:T_termlist; var _1:Bool;} {
	var _terms:T_termlist = _xterms._intersect(_yterms);
	var _comp:Bool = _xcomp || _ycomp;
	if (_comp && !_terms._isAll()) {
		var _i:GoInt = (0 : GoInt);
		for (_0 => _t in _terms) {
			_assert(_t._typ != null);
			if (comparable(_t._typ)) {
				_terms[(_i : GoInt)] = _t;
				_i++;
			};
		};
		_terms = (_terms.__slice__(0, _i) : T_termlist);
		if (!_terms._isAll()) {
			_comp = false;
		};
	};
	_assert(!_comp || _terms._isAll());
	return {_0: _terms, _1: _comp};
}

private function _sortMethods(_list:Slice<Ref<Func>>):Void {
	stdgo.sort.Sort.sort(Go.asInterface((_list : T_byUniqueMethodName)));
}

private function _assertSortedMethods(_list:Slice<Ref<Func>>):Void {
	if (true) {
		throw Go.toInterface(("assertSortedMethods called outside debug mode" : GoString));
	};
	if (!stdgo.sort.Sort.isSorted(Go.asInterface((_list : T_byUniqueMethodName)))) {
		throw Go.toInterface(("methods not sorted" : GoString));
	};
}

/**
	// computeUnionTypeSet may be called with check == nil.
	// The result is &invalidTypeSet if the union overflows.
**/
private function _computeUnionTypeSet(_check:Ref<Checker>, _unionSets:GoMap<Ref<Union>, Ref<T__TypeSet>>, _pos:stdgo.go.token.Token.Pos,
		_utyp:Ref<Union>):Ref<T__TypeSet> {
	{
		var __tmp__ = (_unionSets != null
			&& _unionSets.__exists__(_utyp) ? {value: _unionSets[_utyp], ok: true} : {value: (null : Ref<T__TypeSet>), ok: false}),
			_tset:Ref<T__TypeSet> = __tmp__.value,
			_0:Bool = __tmp__.ok;
		if (_tset != null) {
			return _tset;
		};
	};
	_unionSets[_utyp] = ({} : T__TypeSet);
	var _allTerms:T_termlist = new T_termlist(0, 0);
	for (_1 => _t in _utyp._terms) {
		var _terms:T_termlist = new T_termlist(0, 0);
		var _u:Type = _under(_t._typ);
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_u) : Ref<Interface>)) : Ref<Interface>), ok: true};
			} catch (_) {
				{value: (null : Ref<Interface>), ok: false};
			}, _ui = __tmp__.value, _2 = __tmp__.ok;
			if (_ui != null) {
				_assert(!_isTypeParam(_t._typ));
				_terms = _computeInterfaceTypeSet(_check, _pos, _ui)._terms;
			} else if (Go.toInterface(_u) == (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
				continue;
			} else {
				if (_t._tilde && !identical(_t._typ, _u)) {
					_t = null;
				};
				_terms = (new Slice<Ref<T_term>>(0, 0, {_tilde: _t._tilde, _typ: _t._typ}) : T_termlist);
			};
		};
		_allTerms = _allTerms._union(_terms);
		if ((_allTerms.length) > (100 : GoInt)) {
			if (_check != null) {
				_check._errorf(Go.asInterface((_pos : T_atPos)), (141 : T_errorCode),
					("cannot handle more than %d union terms (implementation limitation)" : GoString), Go.toInterface((100 : GoInt)));
			};
			_unionSets[_utyp] = (_invalidTypeSet : Ref<T__TypeSet>);
			return _unionSets[_utyp];
		};
	};
	_unionSets[_utyp]._terms = _allTerms;
	return _unionSets[_utyp];
}

function testInvalidTypeSet(_t:Ref<stdgo.testing.Testing.T>):Void {
	if (!_invalidTypeSet.isEmpty()) {
		_t.error(Go.toInterface(("invalidTypeSet is not empty" : GoString)));
	};
}

function testTypeSetString(_t:Ref<stdgo.testing.Testing.T>):Void {
	for (_body => _want in ({
		final x = new stdgo.GoMap.GoObjectMap<GoString,
			GoString>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
				stdgo.internal.reflect.Reflect.GoType.basic(string_kind)}, {get: () -> stdgo.internal.reflect.Reflect.GoType.basic(string_kind)})));
		@:privateAccess x._keys = [
			("{}" : GoString),
			("{int}" : GoString),
			("{~int}" : GoString),
			("{int|string}" : GoString),
			("{int; string}" : GoString),
			("{comparable}" : GoString),
			("{comparable; int}" : GoString),
			("{~int; comparable}" : GoString),
			("{int|string; comparable}" : GoString),
			("{comparable; int; string}" : GoString),
			("{m()}" : GoString),
			("{m1(); m2() int }" : GoString),
			("{error}" : GoString),
			("{m(); comparable}" : GoString),
			("{m1(); comparable; m2() int }" : GoString),
			("{comparable; error}" : GoString),
			("{m(); comparable; int|float32|string}" : GoString),
			("{m1(); int; m2(); comparable }" : GoString),
			("{E}; type E interface{}" : GoString),
			("{E}; type E interface{int;string}" : GoString),
			("{E}; type E interface{comparable}" : GoString)
		];
		@:privateAccess x._values = [
			("𝓤" : GoString),
			("{int}" : GoString),
			("{~int}" : GoString),
			("{int | string}" : GoString),
			("∅" : GoString),
			("{comparable}" : GoString),
			("{int}" : GoString),
			("{~int}" : GoString),
			("{int | string}" : GoString),
			("∅" : GoString),
			("{func (p.T).m()}" : GoString),
			("{func (p.T).m1(); func (p.T).m2() int}" : GoString),
			("{func (error).Error() string}" : GoString),
			("{comparable; func (p.T).m()}" : GoString),
			("{comparable; func (p.T).m1(); func (p.T).m2() int}" : GoString),
			("{comparable; func (error).Error() string}" : GoString),
			("{func (p.T).m(); int | float32 | string}" : GoString),
			("{func (p.T).m1(); func (p.T).m2(); int}" : GoString),
			("𝓤" : GoString),
			("∅" : GoString),
			("{comparable}" : GoString)
		];
		x;
	} : stdgo.GoMap<GoString, GoString>)) {
		var _src:GoString = ("package p; type T interface" : GoString) + _body;
		var _fset = stdgo.go.token.Token.newFileSet();
		var __tmp__ = stdgo.go.parser.Parser.parseFile(_fset, ("p.go" : GoString), Go.toInterface(_src), (("32" : GoUInt) : stdgo.go.parser.Parser.Mode)),
			_file:Ref<stdgo.go.ast.Ast.File> = __tmp__._0,
			_err:Error = __tmp__._1;
		if (_file == null) {
			_t.fatalf(("%s: %v (invalid test case)" : GoString), Go.toInterface(_body), Go.toInterface(_err));
		};
		var _conf:Config = ({} : Config);
		var __tmp__ = _conf.check(_file.name.name, _fset, (new Slice<Ref<stdgo.go.ast.Ast.File>>(0, 0, _file) : Slice<Ref<stdgo.go.ast.Ast.File>>), null),
			_pkg:Ref<Package> = __tmp__._0,
			_err:Error = __tmp__._1;
		if (_err != null) {
			_t.fatalf(("%s: %v (invalid test case)" : GoString), Go.toInterface(_body), Go.toInterface(_err));
		};
		var _obj:Object = _pkg._scope.lookup(("T" : GoString));
		if (_obj == null) {
			_t.fatalf(("%s: T not found (invalid test case)" : GoString), Go.toInterface(_body));
		};
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_under(_obj.type())) : Ref<Interface>)) : Ref<Interface>), ok: true};
		} catch (_) {
			{value: (null : Ref<Interface>), ok: false};
		}, t = __tmp__.value, _ok = __tmp__.ok;
		if (!_ok) {
			_t.fatalf(("%s: %v is not an interface (invalid test case)" : GoString), Go.toInterface(_body), Go.toInterface(_obj));
		};
		var _got:GoString = (t._typeSet().string() : GoString);
		if (_got != (_want)) {
			_t.errorf(("%s: got %s; want %s" : GoString), Go.toInterface(_body), Go.toInterface(_got), Go.toInterface(_want));
		};
	};
}

/**
	// RelativeTo returns a Qualifier that fully qualifies members of
	// all packages other than pkg.
**/
function relativeTo(_pkg:Ref<Package>):Qualifier {
	if (_pkg == null) {
		return null;
	};
	return function(_other:Ref<Package>):GoString {
		if (_pkg == (_other)) {
			return Go.str();
		};
		return _other.path();
	};
}

/**
	// TypeString returns the string representation of typ.
	// The Qualifier controls the printing of
	// package-level objects, and may be nil.
**/
function typeString(_typ:Type, _qf:Qualifier):GoString {
	return _typeString(_typ, _qf, false);
}

private function _typeString(_typ:Type, _qf:Qualifier, _debug:Bool):GoString {
	var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
	var _w = _newTypeWriter((_buf : Ref<stdgo.bytes.Bytes.Buffer>), _qf);
	_w._debug = _debug;
	_w._typ(_typ);
	return (_buf.string() : GoString);
}

/**
	// WriteType writes the string representation of typ to buf.
	// The Qualifier controls the printing of
	// package-level objects, and may be nil.
**/
function writeType(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _typ:Type, _qf:Qualifier):Void {
	_newTypeWriter(_buf, _qf)._typ(_typ);
}

/**
	// WriteSignature writes the representation of the signature sig to buf,
	// without a leading "func" keyword.
	// The Qualifier controls the printing of
	// package-level objects, and may be nil.
**/
function writeSignature(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _sig:Ref<Signature>, _qf:Qualifier):Void {
	_newTypeWriter(_buf, _qf)._signature(_sig);
}

private function _newTypeWriter(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _qf:Qualifier):Ref<T_typeWriter> {
	return ((new T_typeWriter(_buf,
		(new GoObjectMap<Type, Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
			stdgo.internal.reflect.Reflect.GoType.named("Type", [], null, false, {get: () -> null})},
			{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind)}))) : GoMap<Type, Bool>),
		_qf, null, null, false) : T_typeWriter) : Ref<T_typeWriter>);
}

private function _newTypeHasher(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _ctxt:Ref<Context>):Ref<T_typeWriter> {
	_assert(_ctxt != null);
	return ((new T_typeWriter(_buf,
		(new GoObjectMap<Type, Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
			stdgo.internal.reflect.Reflect.GoType.named("Type", [], null, false, {get: () -> null})},
			{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind)}))) : GoMap<Type, Bool>),
		null, _ctxt, null, false) : T_typeWriter) : Ref<T_typeWriter>);
}

/**
	// subscript returns the decimal (utf8) representation of x using subscript digits.
**/
private function _subscript(_x:GoUInt64):GoString {
	{};
	var _buf:GoArray<GoByte> = new GoArray<GoUInt8>(...[for (i in 0...96) (0 : GoUInt8)]);
	var _i:GoInt = (_buf.length);
	while (true) {
		_i = _i - ((3 : GoInt));
		stdgo.unicode.utf8.Utf8.encodeRune((_buf.__slice__(_i) : Slice<GoUInt8>), (8320 : GoInt32) + (_x % ("10" : GoUInt64) : GoRune));
		_x = _x / (("10" : GoUInt64));
		if (_x == (("0" : GoUInt64))) {
			break;
		};
	};
	return ((_buf.__slice__(_i) : Slice<GoUInt8>) : GoString);
}

function testTermString(_t:Ref<stdgo.testing.Testing.T>):Void {
	for (_want => _x in _testTerms) {
		{
			var _got:GoString = (_x.string() : GoString);
			if (_got != (_want)) {
				_t.errorf(("%v.String() == %v; want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(_got), Go.toInterface(_want));
			};
		};
	};
}

private function _split(_s:GoString, _n:GoInt):Slice<GoString> {
	var _r = stdgo.strings.Strings.split(_s, (" " : GoString));
	if ((_r.length) != (_n)) {
		throw Go.toInterface(("invalid test case: " : GoString) + _s);
	};
	return _r;
}

private function _testTerm(_name:GoString):Ref<T_term> {
	var __tmp__ = (_testTerms != null
		&& _testTerms.__exists__(_name) ? {value: _testTerms[_name], ok: true} : {value: (null : Ref<T_term>), ok: false}),
		_r:Ref<T_term> = __tmp__.value,
		_ok:Bool = __tmp__.ok;
	if (!_ok) {
		throw Go.toInterface(("invalid test argument: " : GoString) + _name);
	};
	return _r;
}

function testTermEqual(_t:Ref<stdgo.testing.Testing.T>):Void {
	for (_0 => _test in (new Slice<GoString>(0, 0, ("∅ ∅ T" : GoString), ("𝓤 𝓤 T" : GoString), ("int int T" : GoString), ("~int ~int T" : GoString),
		("myInt myInt T" : GoString), ("∅ 𝓤 F" : GoString), ("∅ int F" : GoString), ("∅ ~int F" : GoString), ("𝓤 int F" : GoString),
		("𝓤 ~int F" : GoString), ("𝓤 myInt F" : GoString), ("int ~int F" : GoString), ("int myInt F" : GoString),
		("~int myInt F" : GoString)) : Slice<GoString>)) {
		var _args = _split(_test, (3 : GoInt));
		var _x = _testTerm(_args[(0 : GoInt)]);
		var _y = _testTerm(_args[(1 : GoInt)]);
		var _want:Bool = _args[(2 : GoInt)] == (("T" : GoString));
		{
			var _got:Bool = _x._equal(_y);
			if (_got != (_want)) {
				_t.errorf(("%v.equal(%v) = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)),
					Go.toInterface(_got), Go.toInterface(_want));
			};
		};
		{
			final __tmp__0 = _y;
			final __tmp__1 = _x;
			_x = __tmp__0;
			_y = __tmp__1;
		};
		{
			var _got:Bool = _x._equal(_y);
			if (_got != (_want)) {
				_t.errorf(("%v.equal(%v) = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)),
					Go.toInterface(_got), Go.toInterface(_want));
			};
		};
	};
}

function testTermUnion(_t:Ref<stdgo.testing.Testing.T>):Void {
	for (_0 => _test in (new Slice<GoString>(0, 0, ("∅ ∅ ∅ ∅" : GoString), ("∅ 𝓤 𝓤 ∅" : GoString), ("∅ int int ∅" : GoString), ("∅ ~int ~int ∅" : GoString),
		("∅ myInt myInt ∅" : GoString), ("𝓤 𝓤 𝓤 ∅" : GoString), ("𝓤 int 𝓤 ∅" : GoString), ("𝓤 ~int 𝓤 ∅" : GoString), ("𝓤 myInt 𝓤 ∅" : GoString),
		("int int int ∅" : GoString), ("int ~int ~int ∅" : GoString), ("int string int string" : GoString), ("int ~string int ~string" : GoString),
		("int myInt int myInt" : GoString), ("~int ~string ~int ~string" : GoString), ("~int myInt ~int ∅" : GoString), ("𝓤 ∅ 𝓤 ∅" : GoString),
		("int ∅ int ∅" : GoString), ("~int ∅ ~int ∅" : GoString), ("myInt ∅ myInt ∅" : GoString), ("int 𝓤 𝓤 ∅" : GoString), ("~int 𝓤 𝓤 ∅" : GoString),
		("myInt 𝓤 𝓤 ∅" : GoString), ("~int int ~int ∅" : GoString), ("string int string int" : GoString), ("~string int ~string int" : GoString),
		("myInt int myInt int" : GoString), ("~string ~int ~string ~int" : GoString), ("myInt ~int ~int ∅" : GoString)) : Slice<GoString>)) {
		var _args = _split(_test, (4 : GoInt));
		var _x = _testTerm(_args[(0 : GoInt)]);
		var _y = _testTerm(_args[(1 : GoInt)]);
		var _want1 = _testTerm(_args[(2 : GoInt)]);
		var _want2 = _testTerm(_args[(3 : GoInt)]);
		{
			var __tmp__ = _x._union(_y),
				_got1:Ref<T_term> = __tmp__._0,
				_got2:Ref<T_term> = __tmp__._1;
			if (!_got1._equal(_want1) || !_got2._equal(_want2)) {
				_t.errorf(("%v.union(%v) = %v, %v; want %v, %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)),
					Go.toInterface(Go.asInterface(_got1)), Go.toInterface(Go.asInterface(_got2)), Go.toInterface(Go.asInterface(_want1)),
					Go.toInterface(Go.asInterface(_want2)));
			};
		};
	};
}

function testTermIntersection(_t:Ref<stdgo.testing.Testing.T>):Void {
	for (_0 => _test in (new Slice<GoString>(0, 0, ("∅ ∅ ∅" : GoString), ("∅ 𝓤 ∅" : GoString), ("∅ int ∅" : GoString), ("∅ ~int ∅" : GoString),
		("∅ myInt ∅" : GoString), ("𝓤 𝓤 𝓤" : GoString), ("𝓤 int int" : GoString), ("𝓤 ~int ~int" : GoString), ("𝓤 myInt myInt" : GoString),
		("int int int" : GoString), ("int ~int int" : GoString), ("int string ∅" : GoString), ("int ~string ∅" : GoString), ("int string ∅" : GoString),
		("~int ~string ∅" : GoString), ("~int myInt myInt" : GoString)) : Slice<GoString>)) {
		var _args = _split(_test, (3 : GoInt));
		var _x = _testTerm(_args[(0 : GoInt)]);
		var _y = _testTerm(_args[(1 : GoInt)]);
		var _want = _testTerm(_args[(2 : GoInt)]);
		{
			var _got = _x._intersect(_y);
			if (!_got._equal(_want)) {
				_t.errorf(("%v.intersect(%v) = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)),
					Go.toInterface(Go.asInterface(_got)), Go.toInterface(Go.asInterface(_want)));
			};
		};
		{
			final __tmp__0 = _y;
			final __tmp__1 = _x;
			_x = __tmp__0;
			_y = __tmp__1;
		};
		{
			var _got = _x._intersect(_y);
			if (!_got._equal(_want)) {
				_t.errorf(("%v.intersect(%v) = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)),
					Go.toInterface(Go.asInterface(_got)), Go.toInterface(Go.asInterface(_want)));
			};
		};
	};
}

function testTermIncludes(_t:Ref<stdgo.testing.Testing.T>):Void {
	for (_0 => _test in (new Slice<GoString>(0, 0, ("∅ int F" : GoString), ("𝓤 int T" : GoString), ("int int T" : GoString), ("~int int T" : GoString),
		("~int myInt T" : GoString), ("string int F" : GoString), ("~string int F" : GoString), ("myInt int F" : GoString)) : Slice<GoString>)) {
		var _args = _split(_test, (3 : GoInt));
		var _x = _testTerm(_args[(0 : GoInt)]);
		var _y:Type = _testTerm(_args[(1 : GoInt)])._typ;
		var _want:Bool = _args[(2 : GoInt)] == (("T" : GoString));
		{
			var _got:Bool = _x._includes(_y);
			if (_got != (_want)) {
				_t.errorf(("%v.includes(%v) = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(_y), Go.toInterface(_got),
					Go.toInterface(_want));
			};
		};
	};
}

function testTermSubsetOf(_t:Ref<stdgo.testing.Testing.T>):Void {
	for (_0 => _test in (new Slice<GoString>(0, 0, ("∅ ∅ T" : GoString), ("𝓤 𝓤 T" : GoString), ("int int T" : GoString), ("~int ~int T" : GoString),
		("myInt myInt T" : GoString), ("∅ 𝓤 T" : GoString), ("∅ int T" : GoString), ("∅ ~int T" : GoString), ("∅ myInt T" : GoString),
		("𝓤 int F" : GoString), ("𝓤 ~int F" : GoString), ("𝓤 myInt F" : GoString), ("int ~int T" : GoString), ("int myInt F" : GoString),
		("~int myInt F" : GoString), ("myInt int F" : GoString), ("myInt ~int T" : GoString)) : Slice<GoString>)) {
		var _args = _split(_test, (3 : GoInt));
		var _x = _testTerm(_args[(0 : GoInt)]);
		var _y = _testTerm(_args[(1 : GoInt)]);
		var _want:Bool = _args[(2 : GoInt)] == (("T" : GoString));
		{
			var _got:Bool = _x._subsetOf(_y);
			if (_got != (_want)) {
				_t.errorf(("%v.subsetOf(%v) = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)),
					Go.toInterface(_got), Go.toInterface(_want));
			};
		};
	};
}

function testTermDisjoint(_t:Ref<stdgo.testing.Testing.T>):Void {
	for (_0 => _test in (new Slice<GoString>(0, 0, ("int int F" : GoString), ("~int ~int F" : GoString), ("int ~int F" : GoString),
		("int string T" : GoString), ("int ~string T" : GoString), ("int myInt T" : GoString), ("~int ~string T" : GoString), ("~int myInt F" : GoString),
		("string myInt T" : GoString), ("~string myInt T" : GoString)) : Slice<GoString>)) {
		var _args = _split(_test, (3 : GoInt));
		var _x = _testTerm(_args[(0 : GoInt)]);
		var _y = _testTerm(_args[(1 : GoInt)]);
		var _want:Bool = _args[(2 : GoInt)] == (("T" : GoString));
		{
			var _got:Bool = _x._disjoint(_y);
			if (_got != (_want)) {
				_t.errorf(("%v.disjoint(%v) = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)),
					Go.toInterface(_got), Go.toInterface(_want));
			};
		};
		{
			final __tmp__0 = _y;
			final __tmp__1 = _x;
			_x = __tmp__0;
			_y = __tmp__1;
		};
		{
			var _got:Bool = _x._disjoint(_y);
			if (_got != (_want)) {
				_t.errorf(("%v.disjoint(%v) = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)),
					Go.toInterface(_got), Go.toInterface(_want));
			};
		};
	};
}

/**
	// goTypeName returns the Go type name for typ and
	// removes any occurrences of "types." from that name.
**/
private function _goTypeName(_typ:Type):GoString {
	return stdgo.strings.Strings.replaceAll(stdgo.fmt.Fmt.sprintf(("%T" : GoString), Go.toInterface(_typ)), ("types." : GoString), Go.str());
}

/**
	// newUnifier returns a new unifier.
	// If exact is set, unification requires unified types to match
	// exactly. If exact is not set, a named type's underlying type
	// is considered if unification would fail otherwise, and the
	// direction of channels is ignored.
	// TODO(gri) exact is not set anymore by a caller. Consider removing it.
**/
private function _newUnifier(_exact:Bool):Ref<T_unifier> {
	var _u = (({_exact: _exact} : T_unifier) : Ref<T_unifier>);
	_u._x._unifier = _u;
	_u._y._unifier = _u;
	return _u;
}

/**
	// If tpar is a type parameter in list, tparamIndex returns the type parameter index.
	// Otherwise, the result is < 0. tpar must not be nil.
**/
private function _tparamIndex(_list:Slice<Ref<TypeParam>>, _tpar:Ref<TypeParam>):GoInt {
	{
		var _i:GoInt = _tpar._index;
		if ((((0 : GoInt) <= _i) && (_i < _list.length)) && (_list[(_i : GoInt)] == _tpar)) {
			return _i;
		};
	};
	return (-1 : GoInt);
}

/**
	// NewUnion returns a new Union type with the given terms.
	// It is an error to create an empty union; they are syntactically not possible.
**/
function newUnion(_terms:Slice<Ref<Term>>):Ref<Union> {
	if ((_terms.length) == ((0 : GoInt))) {
		throw Go.toInterface(("empty union" : GoString));
	};
	return ((new Union(_terms) : Union) : Ref<Union>);
}

/**
	// NewTerm returns a new union term.
**/
function newTerm(_tilde:Bool, _typ:Type):Ref<Term> {
	return ((new Term(_tilde, _typ) : Term) : Ref<Term>);
}

/**
	// parseUnion parses uexpr as a union of expressions.
	// The result is a Union type, or Typ[Invalid] for some errors.
**/
private function _parseUnion(_check:Ref<Checker>, _uexpr:stdgo.go.ast.Ast.Expr):Type {
	var __tmp__ = _flattenUnion((null : Slice<stdgo.go.ast.Ast.Expr>), _uexpr),
		_blist:Slice<stdgo.go.ast.Ast.Expr> = __tmp__._0,
		_tlist:Slice<stdgo.go.ast.Ast.Expr> = __tmp__._1;
	_assert((_blist.length) == (_tlist.length - (1 : GoInt)));
	var _terms:Slice<Ref<Term>> = (null : Slice<Ref<Term>>);
	var _u:Type = (null : Type);
	for (_i => _x in _tlist) {
		var _term = _parseTilde(_check, _x);
		if ((_tlist.length == (1 : GoInt)) && !_term._tilde) {
			return _term._typ;
		};
		if ((_terms.length) >= (100 : GoInt)) {
			if (Go.toInterface(_u) != (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
				_check._errorf(_x, (141 : T_errorCode), ("cannot handle more than %d union terms (implementation limitation)" : GoString),
					Go.toInterface((100 : GoInt)));
				_u = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
			};
		} else {
			_terms = _terms.__appendref__(_term);
			_u = Go.asInterface(((new Union(_terms) : Union) : Ref<Union>));
		};
		if (_i > (0 : GoInt)) {
			_check._recordTypeAndValue(_blist[(_i - (1 : GoInt) : GoInt)], (3 : T_operandMode), _u, (null : stdgo.go.constant.Constant.Value));
		};
	};
	if (Go.toInterface(_u) == (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
		return _u;
	};
	_check._later(function():Void {
		for (_i => _t in _terms) {
			if (Go.toInterface(_t._typ) == (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
				continue;
			};
			var _u:Type = _under(_t._typ);
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_u) : Ref<Interface>)) : Ref<Interface>), ok: true};
			} catch (_) {
				{value: (null : Ref<Interface>), ok: false};
			}, _f = __tmp__.value, _0 = __tmp__.ok;
			if (_t._tilde) {
				if (_f != null) {
					_check._errorf(_tlist[(_i : GoInt)], (141 : T_errorCode), ("invalid use of ~ (%s is an interface)" : GoString), Go.toInterface(_t._typ));
					continue;
				};
				if (!identical(_u, _t._typ)) {
					_check._errorf(_tlist[(_i : GoInt)], (141 : T_errorCode), ("invalid use of ~ (underlying type of %s is %s)" : GoString),
						Go.toInterface(_t._typ), Go.toInterface(_u));
					continue;
				};
			};
			if (_f != null) {
				var _tset = _f._typeSet();
				if (_tset.numMethods() != ((0 : GoInt))) {
					_check._errorf(_tlist[(_i : GoInt)], (141 : T_errorCode), ("cannot use %s in union (%s contains methods)" : GoString),
						Go.toInterface(Go.asInterface(_t)), Go.toInterface(Go.asInterface(_t)));
				} else if (Go.toInterface(_t._typ) == (Go.toInterface(_universeComparable.type()))) {
					_check._error(_tlist[(_i : GoInt)], (141 : T_errorCode), ("cannot use comparable in union" : GoString));
				} else if (_tset._comparable) {
					_check._errorf(_tlist[(_i : GoInt)], (141 : T_errorCode), ("cannot use %s in union (%s embeds comparable)" : GoString),
						Go.toInterface(Go.asInterface(_t)), Go.toInterface(Go.asInterface(_t)));
				};
				continue;
			};
			{
				var _j:GoInt = _overlappingTerm((_terms.__slice__(0, _i) : Slice<Ref<Term>>), _t);
				if (_j >= (0 : GoInt)) {
					_check._softErrorf(_tlist[(_i : GoInt)], (141 : T_errorCode), ("overlapping terms %s and %s" : GoString),
						Go.toInterface(Go.asInterface(_t)), Go.toInterface(Go.asInterface(_terms[(_j : GoInt)])));
				};
			};
		};
	})._describef(_uexpr, ("check term validity %s" : GoString), Go.toInterface(_uexpr));
	return _u;
}

private function _parseTilde(_check:Ref<Checker>, _tx:stdgo.go.ast.Ast.Expr):Ref<Term> {
	var _x:stdgo.go.ast.Ast.Expr = _tx;
	var _tilde:Bool = false;
	{
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_x) : Ref<stdgo.go.ast.Ast.UnaryExpr>)) : Ref<stdgo.go.ast.Ast.UnaryExpr>), ok: true};
		} catch (_) {
			{value: (null : Ref<stdgo.go.ast.Ast.UnaryExpr>), ok: false};
		}, _op = __tmp__.value, _0 = __tmp__.ok;
		if ((_op != null) && (_op.op == (88 : stdgo.go.token.Token.Token))) {
			_x = _op.x;
			_tilde = true;
		};
	};
	var _typ:Type = _check._typ(_x);
	if (_isTypeParam(_typ)) {
		if (_tilde) {
			_check._errorf(_x, (144 : T_errorCode), ("type in term %s cannot be a type parameter" : GoString), Go.toInterface(_tx));
		} else {
			_check._error(_x, (144 : T_errorCode), ("term cannot be a type parameter" : GoString));
		};
		_typ = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
	};
	var _term = newTerm(_tilde, _typ);
	if (_tilde) {
		_check._recordTypeAndValue(_tx, (3 : T_operandMode),
			Go.asInterface(((new Union((new Slice<Ref<Term>>(0, 0, _term) : Slice<Ref<Term>>)) : Union) : Ref<Union>)),
			(null : stdgo.go.constant.Constant.Value));
	};
	return _term;
}

/**
	// overlappingTerm reports the index of the term x in terms which is
	// overlapping (not disjoint) from y. The result is < 0 if there is no
	// such term. The type of term y must not be an interface, and terms
	// with an interface type are ignored in the terms list.
**/
private function _overlappingTerm(_terms:Slice<Ref<Term>>, _y:Ref<Term>):GoInt {
	_assert(!isInterface(_y._typ));
	for (_i => _x in _terms) {
		if (isInterface(_x._typ)) {
			continue;
		};
		if (false) {
			if ((((_x == null) || (_x._typ == null)) || (_y == null)) || (_y._typ == null)) {
				throw Go.toInterface(("empty or top union term" : GoString));
			};
		};
		if (! {_tilde: _x._tilde, _typ: _x._typ}._disjoint({_tilde: _y._tilde, _typ: _y._typ})) {
			return _i;
		};
	};
	return (-1 : GoInt);
}

/**
	// flattenUnion walks a union type expression of the form A | B | C | ...,
	// extracting both the binary exprs (blist) and leaf types (tlist).
**/
private function _flattenUnion(_list:Slice<stdgo.go.ast.Ast.Expr>,
		_x:stdgo.go.ast.Ast.Expr):{var _0:Slice<stdgo.go.ast.Ast.Expr>; var _1:Slice<stdgo.go.ast.Ast.Expr>;} {
	var _blist:Slice<stdgo.go.ast.Ast.Expr> = (null : Slice<stdgo.go.ast.Ast.Expr>),
		_tlist:Slice<stdgo.go.ast.Ast.Expr> = (null : Slice<stdgo.go.ast.Ast.Expr>);
	{
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_x) : Ref<stdgo.go.ast.Ast.BinaryExpr>)) : Ref<stdgo.go.ast.Ast.BinaryExpr>), ok: true};
		} catch (_) {
			{value: (null : Ref<stdgo.go.ast.Ast.BinaryExpr>), ok: false};
		}, _o = __tmp__.value, _0 = __tmp__.ok;
		if ((_o != null) && (_o.op == (18 : stdgo.go.token.Token.Token))) {
			{
				var __tmp__ = _flattenUnion(_list, _o.x);
				_blist = __tmp__._0;
				_tlist = __tmp__._1;
			};
			_blist = _blist.__appendref__(Go.asInterface(_o));
			_x = _o.y;
		};
	};
	return {_0: _blist, _1: (_tlist.__append__(_x))};
}

private function _defPredeclaredTypes():Void {
	for (_0 => _t in typ) {
		_def(Go.asInterface(newTypeName((0 : stdgo.go.token.Token.Pos), null, _t._name, Go.asInterface(_t))));
	};
	for (_1 => _t in _aliases) {
		_def(Go.asInterface(newTypeName((0 : stdgo.go.token.Token.Pos), null, _t._name, Go.asInterface(_t))));
	};
	_def(Go.asInterface(newTypeName((0 : stdgo.go.token.Token.Pos), null, ("any" : GoString),
		Go.asInterface((({_complete: true, _tset: (_topTypeSet : Ref<T__TypeSet>)} : Interface) : Ref<Interface>)))));
	{
		var _obj = newTypeName((0 : stdgo.go.token.Token.Pos), null, ("error" : GoString), (null : Type));
		_obj._setColor((("1" : GoUInt32) : T_color));
		var _typ = newNamed(_obj, (null : Type), (null : Slice<Ref<Func>>));
		var _recv = newVar((0 : stdgo.go.token.Token.Pos), null, Go.str(), Go.asInterface(_typ));
		var _res = newVar((0 : stdgo.go.token.Token.Pos), null, Go.str(), Go.asInterface(typ[((17 : BasicKind) : GoInt)]));
		var _sig = newSignatureType(_recv, (null : Slice<Ref<TypeParam>>), (null : Slice<Ref<TypeParam>>), null, newTuple(_res), false);
		var _err = newFunc((0 : stdgo.go.token.Token.Pos), null, ("Error" : GoString), _sig);
		var _ityp = (({_methods: (new Slice<Ref<Func>>(0, 0, _err) : Slice<Ref<Func>>), _complete: true} : Interface) : Ref<Interface>);
		_computeInterfaceTypeSet(null, (0 : stdgo.go.token.Token.Pos), _ityp);
		_typ.setUnderlying(Go.asInterface(_ityp));
		_def(Go.asInterface(_obj));
	};
	{
		var _obj = newTypeName((0 : stdgo.go.token.Token.Pos), null, ("comparable" : GoString), (null : Type));
		_obj._setColor((("1" : GoUInt32) : T_color));
		var _typ = newNamed(_obj, (null : Type), (null : Slice<Ref<Func>>));
		var _ityp = (({_complete: true, _tset: ((new T__TypeSet((null : Slice<Ref<Func>>), _allTermlist,
			true) : T__TypeSet) : Ref<T__TypeSet>)} : Interface) : Ref<Interface>);
		_typ.setUnderlying(Go.asInterface(_ityp));
		_def(Go.asInterface(_obj));
	};
}

private function _defPredeclaredConsts():Void {
	for (_0 => _c in _predeclaredConsts) {
		_def(Go.asInterface(newConst((0 : stdgo.go.token.Token.Pos), null, _c._name, Go.asInterface(typ[(_c._kind : GoInt)]), _c._val)));
	};
}

private function _defPredeclaredNil():Void {
	_def(Go.asInterface(((new Nil(({_name: ("nil" : GoString), _typ: Go.asInterface(typ[((25 : BasicKind) : GoInt)]),
		_color_: (("1" : GoUInt32) : T_color)} : T_object)) : Nil) : Ref<Nil>)));
}

private function _defPredeclaredFuncs():Void {
	for (_i in 0..._predeclaredFuncs.length.toBasic()) {
		var _id:T_builtinId = (_i : T_builtinId);
		if ((_id == (20 : T_builtinId)) || (_id == (21 : T_builtinId))) {
			continue;
		};
		_def(Go.asInterface(_newBuiltin(_id)));
	};
}

/**
	// DefPredeclaredTestFuncs defines the assert and trace built-ins.
	// These built-ins are intended for debugging and testing of this
	// package only.
**/
function defPredeclaredTestFuncs():Void {
	if (universe.lookup(("assert" : GoString)) != null) {
		return;
	};
	_def(Go.asInterface(_newBuiltin((20 : T_builtinId))));
	_def(Go.asInterface(_newBuiltin((21 : T_builtinId))));
}

/**
	// Objects with names containing blanks are internal and not entered into
	// a scope. Objects with exported names are inserted in the unsafe package
	// scope; other objects are inserted in the universe scope.
**/
private function _def(_obj:Object):Void {
	_assert(_obj._color() == ((("1" : GoUInt32) : T_color)));
	var _name:GoString = _obj.name();
	if (stdgo.strings.Strings.contains(_name, (" " : GoString))) {
		return;
	};
	{
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_obj.type()) : Ref<Named>)) : Ref<Named>), ok: true};
		} catch (_) {
			{value: (null : Ref<Named>), ok: false};
		}, _typ = __tmp__.value, _0 = __tmp__.ok;
		if (_typ != null) {
			_typ._obj = (Go.typeAssert((Go.toInterface(_obj) : Ref<TypeName>)) : Ref<TypeName>);
		};
	};
	var _scope = universe;
	if (_obj.exported()) {
		_scope = unsafe._scope;
		{
			final __type__ = _obj;
			if (Go.typeEquals((__type__ : Ref<TypeName>))) {
				var _obj:Ref<TypeName> = __type__ == null ? (null : Ref<TypeName>) : __type__.__underlying__() == null ? (null : Ref<TypeName>) : __type__ == null ? (null : Ref<TypeName>) : __type__.__underlying__()
					.value;
				_obj._object._pkg = unsafe;
			} else if (Go.typeEquals((__type__ : Ref<Builtin>))) {
				var _obj:Ref<Builtin> = __type__ == null ? (null : Ref<Builtin>) : __type__.__underlying__() == null ? (null : Ref<Builtin>) : __type__ == null ? (null : Ref<Builtin>) : __type__.__underlying__()
					.value;
				_obj._object._pkg = unsafe;
			} else {
				var _obj:Object = __type__ == null ? (null : Object) : cast __type__;
				_unreachable();
			};
		};
	};
	if (_scope.insert(_obj) != null) {
		throw Go.toInterface(("double declaration of predeclared identifier" : GoString));
	};
}

/**
	// makeObjList returns the list of type name objects for the given
	// list of named types.
**/
private function _makeObjList(_tlist:Slice<Ref<Named>>):Slice<Object> {
	var _olist = new Slice<Object>((_tlist.length : GoInt).toBasic(), 0, ...[for (i in 0...(_tlist.length : GoInt).toBasic()) (null : Object)]);
	for (_i => _t in _tlist) {
		_olist[(_i : GoInt)] = Go.asInterface(_t._obj);
	};
	return _olist;
}

/**
	// parseGoVersion parses a Go version string (such as "go1.12")
	// and returns the version, or an error. If s is the empty
	// string, the version is 0.0.
**/
private function _parseGoVersion(_s:GoString):{var _0:T_version; var _1:Error;} {
	var _v:T_version = ({} : T_version), _err:Error = (null : Error);
	if (_s == (Go.str())) {
		return {_0: _v, _1: _err};
	};
	var _matches = _goVersionRx.findStringSubmatch(_s);
	if (_matches == null) {
		_err = stdgo.fmt.Fmt.errorf(("should be something like \"go1.12\"" : GoString));
		return {_0: _v, _1: _err};
	};
	{
		var __tmp__ = stdgo.strconv.Strconv.atoi(_matches[(1 : GoInt)]);
		_v._major = __tmp__._0;
		_err = __tmp__._1;
	};
	if (_err != null) {
		return {_0: _v, _1: _err};
	};
	{
		var __tmp__ = stdgo.strconv.Strconv.atoi(_matches[(2 : GoInt)]);
		_v._minor = __tmp__._0;
		_err = __tmp__._1;
	};
	return {_0: _v, _1: _err};
}

@:keep var _ = {
	try {
		_unaryOpPredicates = ({
			final x = new stdgo.GoMap.GoObjectMap<stdgo.go.token.Token.Token, Type->
				Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("T_opPredicates", [], null, false, {
				get: () -> @:implicitReturn throw "__return__"
			})));
			@:privateAccess x._keys = [
				(12 : stdgo.go.token.Token.Token),
				(13 : stdgo.go.token.Token.Token),
				(19 : stdgo.go.token.Token.Token),
				(43 : stdgo.go.token.Token.Token)
			];
			@:privateAccess x._values = [_allNumeric, _allNumeric, _allInteger, _allBoolean];
			x;
		} : stdgo.GoMap<stdgo.go.token.Token.Token, Type->Bool>);
		_binaryOpPredicates = ({
			final x = new stdgo.GoMap.GoObjectMap<stdgo.go.token.Token.Token, Type->
				Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("T_opPredicates", [], null, false, {
				get: () -> @:implicitReturn throw "__return__"
			})));
			@:privateAccess x._keys = [
				(12 : stdgo.go.token.Token.Token),
				(13 : stdgo.go.token.Token.Token),
				(14 : stdgo.go.token.Token.Token),
				(15 : stdgo.go.token.Token.Token),
				(16 : stdgo.go.token.Token.Token),
				(17 : stdgo.go.token.Token.Token),
				(18 : stdgo.go.token.Token.Token),
				(19 : stdgo.go.token.Token.Token),
				(22 : stdgo.go.token.Token.Token),
				(34 : stdgo.go.token.Token.Token),
				(35 : stdgo.go.token.Token.Token)
			];
			@:privateAccess x._values = [
				_allNumericOrString, _allNumeric, _allNumeric, _allNumeric, _allInteger, _allInteger, _allInteger, _allInteger, _allInteger, _allBoolean,
				_allBoolean
			];
			x;
		} : stdgo.GoMap<stdgo.go.token.Token.Token, Type->Bool>);
		universe = newScope(null, (0 : stdgo.go.token.Token.Pos), (0 : stdgo.go.token.Token.Pos), ("universe" : GoString));
		unsafe = newPackage(("unsafe" : GoString), ("unsafe" : GoString));
		unsafe._complete = true;
		_defPredeclaredTypes();
		_defPredeclaredConsts();
		_defPredeclaredNil();
		_defPredeclaredFuncs();
		_universeIota = universe.lookup(("iota" : GoString));
		_universeByte = universe.lookup(("byte" : GoString)).type();
		_universeRune = universe.lookup(("rune" : GoString)).type();
		_universeAny = universe.lookup(("any" : GoString));
		_universeError = universe.lookup(("error" : GoString)).type();
		_universeComparable = universe.lookup(("comparable" : GoString));
	} catch (__exception__)
		if (__exception__.message != "__return__")
			throw __exception__;
	true;
};

class T_error_asInterface {
	/**
		// Error returns an error string formatted as follows:
		// filename:line:column: message
	**/
	@:keep
	public function error():GoString
		return __self__.value.error();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_error>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_error_asInterface) class T_error_static_extension {
	/**
		// Error returns an error string formatted as follows:
		// filename:line:column: message
	**/
	@:keep
	static public function error(_err:T_error):GoString {
		return stdgo.fmt.Fmt.sprintf(("%s: %s" : GoString), Go.toInterface(Go.asInterface(_err.fset.position(_err.pos))), Go.toInterface(_err.msg));
	}
}

class ArgumentError_asInterface {
	@:keep
	public function unwrap():Error
		return __self__.value.unwrap();

	@:keep
	public function error():GoString
		return __self__.value.error();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<ArgumentError>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.ArgumentError_asInterface) class ArgumentError_static_extension {
	@:keep
	static public function unwrap(_e:Ref<ArgumentError>):Error {
		return _e.err;
	}

	@:keep
	static public function error(_e:Ref<ArgumentError>):GoString {
		return _e.err.error();
	}
}

class Config_asInterface {
	@:keep
	public function _sizeof(t:Type):GoInt64
		return __self__.value._sizeof(t);

	/**
		// offsetof returns the offset of the field specified via
		// the index sequence relative to typ. All embedded fields
		// must be structs (rather than pointer to structs).
	**/
	@:keep
	public function _offsetof(_typ:Type, _index:Slice<GoInt>):GoInt64
		return __self__.value._offsetof(_typ, _index);

	@:keep
	public function _offsetsof(t:Ref<Struct>):Slice<GoInt64>
		return __self__.value._offsetsof(t);

	@:keep
	public function _alignof(t:Type):GoInt64
		return __self__.value._alignof(t);

	/**
		// Check type-checks a package and returns the resulting package object and
		// the first error if any. Additionally, if info != nil, Check populates each
		// of the non-nil maps in the Info struct.
		//
		// The package is marked as complete if no errors occurred, otherwise it is
		// incomplete. See Config.Error for controlling behavior in the presence of
		// errors.
		//
		// The package is specified by a list of *ast.Files and corresponding
		// file set, and the package path the package is identified with.
		// The clean path must not be empty or dot (".").
	**/
	@:keep
	public function check(_path:GoString, _fset:Ref<stdgo.go.token.Token.FileSet>, _files:Slice<Ref<stdgo.go.ast.Ast.File>>,
			_info:Ref<Info>):{var _0:Ref<Package>; var _1:Error;}
		return __self__.value.check(_path, _fset, _files, _info);

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Config>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Config_asInterface) class Config_static_extension {
	@:keep
	static public function _sizeof(_conf:Ref<Config>, t:Type):GoInt64 {
		{
			var _s:Sizes = _conf.sizes;
			if (_s != null) {
				{
					var _z:GoInt64 = _s.sizeof(t);
					if (_z >= ("0" : GoInt64)) {
						return _z;
					};
				};
				throw Go.toInterface(("Config.Sizes.Sizeof returned a size < 0" : GoString));
			};
		};
		return _stdSizes.sizeof(t);
	}

	/**
		// offsetof returns the offset of the field specified via
		// the index sequence relative to typ. All embedded fields
		// must be structs (rather than pointer to structs).
	**/
	@:keep
	static public function _offsetof(_conf:Ref<Config>, _typ:Type, _index:Slice<GoInt>):GoInt64 {
		var _o:GoInt64 = (0 : GoInt64);
		for (_0 => _i in _index) {
			var _s = (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Struct>)) : Ref<Struct>);
			_o = _o + (_conf._offsetsof(_s)[(_i : GoInt)]);
			_typ = _s._fields[(_i : GoInt)]._object._typ;
		};
		return _o;
	}

	@:keep
	static public function _offsetsof(_conf:Ref<Config>, t:Ref<Struct>):Slice<GoInt64> {
		var _offsets:Slice<GoInt64> = (null : Slice<GoInt64>);
		if (t.numFields() > (0 : GoInt)) {
			{
				var _s:Sizes = _conf.sizes;
				if (_s != null) {
					_offsets = _s.offsetsof(t._fields);
					if ((_offsets.length) != (t.numFields())) {
						throw Go.toInterface(("Config.Sizes.Offsetsof returned the wrong number of offsets" : GoString));
					};
					for (_0 => _o in _offsets) {
						if (_o < ("0":GoInt64)) {
							throw Go.toInterface(("Config.Sizes.Offsetsof returned an offset < 0" : GoString));
						};
					};
				} else {
					_offsets = _stdSizes.offsetsof(t._fields);
				};
			};
		};
		return _offsets;
	}

	@:keep
	static public function _alignof(_conf:Ref<Config>, t:Type):GoInt64 {
		{
			var _s:Sizes = _conf.sizes;
			if (_s != null) {
				{
					var _a:GoInt64 = _s.alignof_(t);
					if (_a >= ("1" : GoInt64)) {
						return _a;
					};
				};
				throw Go.toInterface(("Config.Sizes.Alignof returned an alignment < 1" : GoString));
			};
		};
		return _stdSizes.alignof_(t);
	}

	/**
		// Check type-checks a package and returns the resulting package object and
		// the first error if any. Additionally, if info != nil, Check populates each
		// of the non-nil maps in the Info struct.
		//
		// The package is marked as complete if no errors occurred, otherwise it is
		// incomplete. See Config.Error for controlling behavior in the presence of
		// errors.
		//
		// The package is specified by a list of *ast.Files and corresponding
		// file set, and the package path the package is identified with.
		// The clean path must not be empty or dot (".").
	**/
	@:keep
	static public function check(_conf:Ref<Config>, _path:GoString, _fset:Ref<stdgo.go.token.Token.FileSet>, _files:Slice<Ref<stdgo.go.ast.Ast.File>>,
			_info:Ref<Info>):{var _0:Ref<Package>; var _1:Error;
	} {
		var _pkg = newPackage(_path, Go.str());
		return {_0: _pkg, _1: newChecker(_conf, _fset, _pkg, _info).files(_files)};
	}
}

class Info_asInterface {
	/**
		// ObjectOf returns the object denoted by the specified id,
		// or nil if not found.
		//
		// If id is an embedded struct field, ObjectOf returns the field (*Var)
		// it defines, not the type (*TypeName) it uses.
		//
		// Precondition: the Uses and Defs maps are populated.
	**/
	@:keep
	public function objectOf(_id:Ref<stdgo.go.ast.Ast.Ident>):Object
		return __self__.value.objectOf(_id);

	/**
		// TypeOf returns the type of expression e, or nil if not found.
		// Precondition: the Types, Uses and Defs maps are populated.
	**/
	@:keep
	public function typeOf(_e:stdgo.go.ast.Ast.Expr):Type
		return __self__.value.typeOf(_e);

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Info>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Info_asInterface) class Info_static_extension {
	/**
		// ObjectOf returns the object denoted by the specified id,
		// or nil if not found.
		//
		// If id is an embedded struct field, ObjectOf returns the field (*Var)
		// it defines, not the type (*TypeName) it uses.
		//
		// Precondition: the Uses and Defs maps are populated.
	**/
	@:keep
	static public function objectOf(_info:Ref<Info>, _id:Ref<stdgo.go.ast.Ast.Ident>):Object {
		{
			var _obj:Object = _info.defs[_id];
			if (_obj != null) {
				return _obj;
			};
		};
		return _info.uses[_id];
	}

	/**
		// TypeOf returns the type of expression e, or nil if not found.
		// Precondition: the Types, Uses and Defs maps are populated.
	**/
	@:keep
	static public function typeOf(_info:Ref<Info>, _e:stdgo.go.ast.Ast.Expr):Type {
		{
			var __tmp__ = (_info.types != null
				&& _info.types.__exists__(_e) ? {value: _info.types[_e], ok: true} : {value: ({} : TypeAndValue), ok: false}),
				_t:TypeAndValue = __tmp__.value,
				_ok:Bool = __tmp__.ok;
			if (_ok) {
				return _t.type;
			};
		};
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_e) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>), ok: true};
			} catch (_) {
				{value: (null : Ref<stdgo.go.ast.Ast.Ident>), ok: false};
			}, _id = __tmp__.value, _0 = __tmp__.ok;
			if (_id != null) {
				{
					var _obj:Object = _info.objectOf(_id);
					if (_obj != null) {
						return _obj.type();
					};
				};
			};
		};
		return (null : Type);
	}
}

class TypeAndValue_asInterface {
	/**
		// HasOk reports whether the corresponding expression may be
		// used on the rhs of a comma-ok assignment.
	**/
	@:keep
	public function hasOk():Bool
		return __self__.value.hasOk();

	/**
		// Assignable reports whether the corresponding expression
		// is assignable to (provided a value of the right type).
	**/
	@:keep
	public function assignable():Bool
		return __self__.value.assignable();

	/**
		// Addressable reports whether the corresponding expression
		// is addressable (https://golang.org/ref/spec#Address_operators).
	**/
	@:keep
	public function addressable():Bool
		return __self__.value.addressable();

	/**
		// IsNil reports whether the corresponding expression denotes the
		// predeclared value nil.
	**/
	@:keep
	public function isNil():Bool
		return __self__.value.isNil();

	/**
		// IsValue reports whether the corresponding expression is a value.
		// Builtins are not considered values. Constant values have a non-
		// nil Value.
	**/
	@:keep
	public function isValue():Bool
		return __self__.value.isValue();

	/**
		// IsBuiltin reports whether the corresponding expression denotes
		// a (possibly parenthesized) built-in function.
	**/
	@:keep
	public function isBuiltin():Bool
		return __self__.value.isBuiltin();

	/**
		// IsType reports whether the corresponding expression specifies a type.
	**/
	@:keep
	public function isType():Bool
		return __self__.value.isType();

	/**
		// IsVoid reports whether the corresponding expression
		// is a function call without results.
	**/
	@:keep
	public function isVoid():Bool
		return __self__.value.isVoid();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<TypeAndValue>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.TypeAndValue_asInterface) class TypeAndValue_static_extension {
	/**
		// HasOk reports whether the corresponding expression may be
		// used on the rhs of a comma-ok assignment.
	**/
	@:keep
	static public function hasOk(_tv:TypeAndValue):Bool {
		return (_tv._mode == (8 : T_operandMode)) || (_tv._mode == (6 : T_operandMode));
	}

	/**
		// Assignable reports whether the corresponding expression
		// is assignable to (provided a value of the right type).
	**/
	@:keep
	static public function assignable(_tv:TypeAndValue):Bool {
		return (_tv._mode == (5 : T_operandMode)) || (_tv._mode == (6 : T_operandMode));
	}

	/**
		// Addressable reports whether the corresponding expression
		// is addressable (https://golang.org/ref/spec#Address_operators).
	**/
	@:keep
	static public function addressable(_tv:TypeAndValue):Bool {
		return _tv._mode == ((5 : T_operandMode));
	}

	/**
		// IsNil reports whether the corresponding expression denotes the
		// predeclared value nil.
	**/
	@:keep
	static public function isNil(_tv:TypeAndValue):Bool {
		return (_tv._mode == (7 : T_operandMode))
			&& (Go.toInterface(_tv.type) == Go.toInterface(Go.asInterface(typ[((25 : BasicKind) : GoInt)])));
	}

	/**
		// IsValue reports whether the corresponding expression is a value.
		// Builtins are not considered values. Constant values have a non-
		// nil Value.
	**/
	@:keep
	static public function isValue(_tv:TypeAndValue):Bool {
		if (_tv._mode == ((4 : T_operandMode)) || _tv._mode == ((5 : T_operandMode)) || _tv._mode == ((6 : T_operandMode))
			|| _tv._mode == ((7 : T_operandMode)) || _tv._mode == ((8 : T_operandMode)) || _tv._mode == ((9 : T_operandMode))) {
			return true;
		};
		return false;
	}

	/**
		// IsBuiltin reports whether the corresponding expression denotes
		// a (possibly parenthesized) built-in function.
	**/
	@:keep
	static public function isBuiltin(_tv:TypeAndValue):Bool {
		return _tv._mode == ((2 : T_operandMode));
	}

	/**
		// IsType reports whether the corresponding expression specifies a type.
	**/
	@:keep
	static public function isType(_tv:TypeAndValue):Bool {
		return _tv._mode == ((3 : T_operandMode));
	}

	/**
		// IsVoid reports whether the corresponding expression
		// is a function call without results.
	**/
	@:keep
	static public function isVoid(_tv:TypeAndValue):Bool {
		return _tv._mode == ((1 : T_operandMode));
	}
}

class Initializer_asInterface {
	@:keep
	public function string():GoString
		return __self__.value.string();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Initializer>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Initializer_asInterface) class Initializer_static_extension {
	@:keep
	static public function string(_init:Ref<Initializer>):GoString {
		var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
		for (_i => _lhs in _init.lhs) {
			if (_i > (0 : GoInt)) {
				_buf.writeString((", " : GoString));
			};
			_buf.writeString(_lhs.name());
		};
		_buf.writeString((" = " : GoString));
		writeExpr((_buf : Ref<stdgo.bytes.Bytes.Buffer>), _init.rhs);
		return (_buf.string() : GoString);
	}
}

class Array__asInterface {
	@:keep
	public function string():GoString
		return __self__.value.string();

	@:keep
	public function underlying():Type
		return __self__.value.underlying();

	/**
		// Elem returns element type of array a.
	**/
	@:keep
	public function elem():Type
		return __self__.value.elem();

	/**
		// Len returns the length of array a.
		// A negative result indicates an unknown length.
	**/
	@:keep
	public function len():GoInt64
		return __self__.value.len();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Array_>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Array__asInterface) class Array__static_extension {
	@:keep
	static public function string(_t:Ref<Array_>):GoString {
		return typeString(Go.asInterface(_t), null);
	}

	@:keep
	static public function underlying(_t:Ref<Array_>):Type {
		return Go.asInterface(_t);
	}

	/**
		// Elem returns element type of array a.
	**/
	@:keep
	static public function elem(_a:Ref<Array_>):Type {
		return _a._elem;
	}

	/**
		// Len returns the length of array a.
		// A negative result indicates an unknown length.
	**/
	@:keep
	static public function len(_a:Ref<Array_>):GoInt64 {
		return _a._len;
	}
}

class Basic_asInterface {
	@:keep
	public function string():GoString
		return __self__.value.string();

	@:keep
	public function underlying():Type
		return __self__.value.underlying();

	/**
		// Name returns the name of basic type b.
	**/
	@:keep
	public function name():GoString
		return __self__.value.name();

	/**
		// Info returns information about properties of basic type b.
	**/
	@:keep
	public function info():BasicInfo
		return __self__.value.info();

	/**
		// Kind returns the kind of basic type b.
	**/
	@:keep
	public function kind():BasicKind
		return __self__.value.kind();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Basic>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Basic_asInterface) class Basic_static_extension {
	@:keep
	static public function string(_t:Ref<Basic>):GoString {
		return typeString(Go.asInterface(_t), null);
	}

	@:keep
	static public function underlying(_t:Ref<Basic>):Type {
		return Go.asInterface(_t);
	}

	/**
		// Name returns the name of basic type b.
	**/
	@:keep
	static public function name(_b:Ref<Basic>):GoString {
		return _b._name;
	}

	/**
		// Info returns information about properties of basic type b.
	**/
	@:keep
	static public function info(_b:Ref<Basic>):BasicInfo {
		return _b._info;
	}

	/**
		// Kind returns the kind of basic type b.
	**/
	@:keep
	static public function kind(_b:Ref<Basic>):BasicKind {
		return _b._kind;
	}
}

class Chan_asInterface {
	@:keep
	public function string():GoString
		return __self__.value.string();

	@:keep
	public function underlying():Type
		return __self__.value.underlying();

	/**
		// Elem returns the element type of channel c.
	**/
	@:keep
	public function elem():Type
		return __self__.value.elem();

	/**
		// Dir returns the direction of channel c.
	**/
	@:keep
	public function dir():ChanDir
		return __self__.value.dir();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Chan>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Chan_asInterface) class Chan_static_extension {
	@:keep
	static public function string(_t:Ref<Chan>):GoString {
		return typeString(Go.asInterface(_t), null);
	}

	@:keep
	static public function underlying(_t:Ref<Chan>):Type {
		return Go.asInterface(_t);
	}

	/**
		// Elem returns the element type of channel c.
	**/
	@:keep
	static public function elem(_c:Ref<Chan>):Type {
		return _c._elem;
	}

	/**
		// Dir returns the direction of channel c.
	**/
	@:keep
	static public function dir(_c:Ref<Chan>):ChanDir {
		return _c._dir;
	}
}

class T_environment_asInterface {
	/**
		// lookup looks up name in the current environment and returns the matching object, or nil.
	**/
	@:keep
	public function _lookup(_name:GoString):Object
		return __self__.value._lookup(_name);

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_environment>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_environment_asInterface) class T_environment_static_extension {
	/**
		// lookup looks up name in the current environment and returns the matching object, or nil.
	**/
	@:keep
	static public function _lookup(_env:Ref<T_environment>, _name:GoString):Object {
		var __tmp__ = _env._scope.lookupParent(_name, _env._pos),
			_0:Ref<Scope> = __tmp__._0,
			_obj:Object = __tmp__._1;
		return _obj;
	}
}

class T_action_asInterface {
	/**
		// If debug is set, describef sets a printf-formatted description for action a.
		// Otherwise, it is a no-op.
	**/
	@:keep
	public function _describef(_pos:T_positioner, _format:GoString, _args:haxe.Rest<AnyInterface>):Void
		__self__.value._describef(_pos, _format, ..._args);

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_action>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_action_asInterface) class T_action_static_extension {
	/**
		// If debug is set, describef sets a printf-formatted description for action a.
		// Otherwise, it is a no-op.
	**/
	@:keep
	static public function _describef(_a:Ref<T_action>, _pos:T_positioner, _format:GoString, _args:haxe.Rest<AnyInterface>):Void {
		var _args = new Slice<AnyInterface>(0, 0, ..._args);
		if (false) {
			_a._desc = ((new T_actionDesc(_pos, _format, _args) : T_actionDesc) : Ref<T_actionDesc>);
		};
	}
}

class Checker_asInterface {
	/**
		// allowVersion reports whether the given package
		// is allowed to use version major.minor.
	**/
	@:keep
	public function _allowVersion(_pkg:Ref<Package>, _major:GoInt, _minor:GoInt):Bool
		return __self__.value._allowVersion(_pkg, _major, _minor);

	/**
		// langCompat reports an error if the representation of a numeric
		// literal is not compatible with the current language version.
	**/
	@:keep
	public function _langCompat(_lit:Ref<stdgo.go.ast.Ast.BasicLit>):Void
		__self__.value._langCompat(_lit);

	/**
		// validType0 checks if the given type is valid. If typ is a type parameter
		// its value is looked up in the type argument list of the instantiated
		// (enclosing) type, if it exists. Otherwise the type parameter must be from
		// an enclosing function and can be ignored.
		// The nest list describes the stack (the "nest in memory") of types which
		// contain (or embed in the case of interfaces) other types. For instance, a
		// struct named S which contains a field of named type F contains (the memory
		// of) F in S, leading to the nest S->F. If a type appears in its own nest
		// (say S->F->S) we have an invalid recursive type. The path list is the full
		// path of named types in a cycle, it is only needed for error reporting.
	**/
	@:keep
	public function _validType0(_typ:Type, _nest:Slice<Ref<Named>>, _path:Slice<Ref<Named>>):Bool
		return __self__.value._validType0(_typ, _nest, _path);

	/**
		// validType verifies that the given type does not "expand" indefinitely
		// producing a cycle in the type graph.
		// (Cycles involving alias types, as in "type A = [10]A" are detected
		// earlier, via the objDecl cycle detection mechanism.)
	**/
	@:keep
	public function _validType(_typ:Ref<Named>):Void
		__self__.value._validType(_typ);

	/**
		// typeList provides the list of types corresponding to the incoming expression list.
		// If an error occurred, the result is nil, but all list elements were type-checked.
	**/
	@:keep
	public function _typeList(_list:Slice<stdgo.go.ast.Ast.Expr>):Slice<Type>
		return __self__.value._typeList(_list);

	/**
		// arrayLength type-checks the array length expression e
		// and returns the constant length >= 0, or a value < 0
		// to indicate an error (and thus an unknown length).
	**/
	@:keep
	public function _arrayLength(_e:stdgo.go.ast.Ast.Expr):GoInt64
		return __self__.value._arrayLength(_e);

	@:keep
	public function _instantiatedType(_ix:Ref<go.internal.typeparams.Typeparams.IndexExpr>, _def:Ref<Named>):Type
		return __self__.value._instantiatedType(_ix, _def);

	/**
		// typInternal drives type checking of types.
		// Must only be called by definedType or genericType.
	**/
	@:keep
	public function _typInternal(_e0:stdgo.go.ast.Ast.Expr, _def:Ref<Named>):Type
		return __self__.value._typInternal(_e0, _def);

	/**
		// genericType is like typ but the type must be an (uninstantiated) generic
		// type. If reason is non-nil and the type expression was a valid type but not
		// generic, reason will be populated with a message describing the error.
	**/
	@:keep
	public function _genericType(_e:stdgo.go.ast.Ast.Expr, _reason:Pointer<GoString>):Type
		return __self__.value._genericType(_e, _reason);

	/**
		// definedType is like typ but also accepts a type name def.
		// If def != nil, e is the type specification for the defined type def, declared
		// in a type declaration, and def.underlying will be set to the type of e before
		// any components of e are type-checked.
	**/
	@:keep
	public function _definedType(_e:stdgo.go.ast.Ast.Expr, _def:Ref<Named>):Type
		return __self__.value._definedType(_e, _def);

	/**
		// validVarType reports an error if typ is a constraint interface.
		// The expression e is used for error reporting, if any.
	**/
	@:keep
	public function _validVarType(_e:stdgo.go.ast.Ast.Expr, _typ:Type):Void
		__self__.value._validVarType(_e, _typ);

	/**
		// varType type-checks the type expression e and returns its type, or Typ[Invalid].
		// The type must not be an (uninstantiated) generic type and it must not be a
		// constraint interface.
	**/
	@:keep
	public function _varType(_e:stdgo.go.ast.Ast.Expr):Type
		return __self__.value._varType(_e);

	/**
		// typ type-checks the type expression e and returns its type, or Typ[Invalid].
		// The type must not be an (uninstantiated) generic type.
	**/
	@:keep
	public function _typ(_e:stdgo.go.ast.Ast.Expr):Type
		return __self__.value._typ(_e);

	/**
		// ident type-checks identifier e and initializes x with the value or type of e.
		// If an error occurred, x.mode is set to invalid.
		// For the meaning of def, see Checker.definedType, below.
		// If wantType is set, the identifier e is expected to denote a type.
	**/
	@:keep
	public function _ident(_x:Ref<T_operand>, _e:Ref<stdgo.go.ast.Ast.Ident>, _def:Ref<Named>, _wantType:Bool):Void
		__self__.value._ident(_x, _e, _def, _wantType);

	/**
		// check may be nil
	**/
	@:keep
	public function _newTypeParam(_obj:Ref<TypeName>, _constraint:Type):Ref<TypeParam>
		return __self__.value._newTypeParam(_obj, _constraint);

	/**
		// subst returns the type typ with its type parameters tpars replaced by the
		// corresponding type arguments targs, recursively. subst is pure in the sense
		// that it doesn't modify the incoming type. If a substitution took place, the
		// result type is different from the incoming type.
		//
		// If expanding is non-nil, it is the instance type currently being expanded.
		// One of expanding or ctxt must be non-nil.
	**/
	@:keep
	public function _subst(_pos:stdgo.go.token.Token.Pos, _typ:Type, _smap:T_substMap, _expanding:Ref<Named>, _ctxt:Ref<Context>):Type
		return __self__.value._subst(_pos, _typ, _smap, _expanding, _ctxt);

	@:keep
	public function _tag(_t:Ref<stdgo.go.ast.Ast.BasicLit>):GoString
		return __self__.value._tag(_t);

	@:keep
	public function _declareInSet(_oset:Ref<T_objset>, _pos:stdgo.go.token.Token.Pos, _obj:Object):Bool
		return __self__.value._declareInSet(_oset, _pos, _obj);

	@:keep
	public function _structType(_styp:Ref<Struct>, _e:Ref<stdgo.go.ast.Ast.StructType>):Void
		__self__.value._structType(_styp, _e);

	/**
		// stmt typechecks statement s.
	**/
	@:keep
	public function _stmt(_ctxt:T_stmtContext, _s:stdgo.go.ast.Ast.Stmt):Void
		__self__.value._stmt(_ctxt, _s);

	/**
		// If the type switch expression is invalid, x is nil.
	**/
	@:keep
	public function _caseTypes(_x:Ref<T_operand>, _types:Slice<stdgo.go.ast.Ast.Expr>, _seen:GoMap<Type, stdgo.go.ast.Ast.Expr>):Type
		return __self__.value._caseTypes(_x, _types, _seen);

	/**
		// isNil reports whether the expression e denotes the predeclared value nil.
	**/
	@:keep
	public function _isNil(_e:stdgo.go.ast.Ast.Expr):Bool
		return __self__.value._isNil(_e);

	@:keep
	public function _caseValues(_x:Ref<T_operand>, _values:Slice<stdgo.go.ast.Ast.Expr>, _seen:T_valueMap):Void
		__self__.value._caseValues(_x, _values, _seen);

	@:keep
	public function _suspendedCall(_keyword:GoString, _call:Ref<stdgo.go.ast.Ast.CallExpr>):Void
		__self__.value._suspendedCall(_keyword, _call);

	@:keep
	public function _closeScope():Void
		__self__.value._closeScope();

	@:keep
	public function _openScope(_node:stdgo.go.ast.Ast.Node, _comment:GoString):Void
		__self__.value._openScope(_node, _comment);

	@:keep
	public function _multipleDefaults(_list:Slice<stdgo.go.ast.Ast.Stmt>):Void
		__self__.value._multipleDefaults(_list);

	@:keep
	public function _stmtList(_ctxt:T_stmtContext, _list:Slice<stdgo.go.ast.Ast.Stmt>):Void
		__self__.value._stmtList(_ctxt, _list);

	@:keep
	public function _simpleStmt(_s:stdgo.go.ast.Ast.Stmt):Void
		__self__.value._simpleStmt(_s);

	@:keep
	public function _usage(_scope:Ref<Scope>):Void
		__self__.value._usage(_scope);

	@:keep
	public function _funcBody(_decl:Ref<T_declInfo>, _name:GoString, _sig:Ref<Signature>, _body:Ref<stdgo.go.ast.Ast.BlockStmt>,
			_iota:stdgo.go.constant.Constant.Value):Void
		__self__.value._funcBody(_decl, _name, _sig, _body, _iota);

	/**
		// collectParams declares the parameters of list in scope and returns the corresponding
		// variable list.
	**/
	@:keep
	public function _collectParams(_scope:Ref<Scope>, _list:Ref<stdgo.go.ast.Ast.FieldList>, _variadicOk:Bool):{var _0:Slice<Ref<Var>>; var _1:Bool;}
		return __self__.value._collectParams(_scope, _list, _variadicOk);

	/**
		// funcType type-checks a function or method type.
	**/
	@:keep
	public function _funcType(_sig:Ref<Signature>, _recvPar:Ref<stdgo.go.ast.Ast.FieldList>, _ftyp:Ref<stdgo.go.ast.Ast.FuncType>):Void
		__self__.value._funcType(_sig, _recvPar, _ftyp);

	@:keep
	public function _isTerminatingSwitch(_body:Ref<stdgo.go.ast.Ast.BlockStmt>, _label:GoString):Bool
		return __self__.value._isTerminatingSwitch(_body, _label);

	@:keep
	public function _isTerminatingList(_list:Slice<stdgo.go.ast.Ast.Stmt>, _label:GoString):Bool
		return __self__.value._isTerminatingList(_list, _label);

	/**
		// isTerminating reports if s is a terminating statement.
		// If s is labeled, label is the label name; otherwise s
		// is "".
	**/
	@:keep
	public function _isTerminating(_s:stdgo.go.ast.Ast.Stmt, _label:GoString):Bool
		return __self__.value._isTerminating(_s, _label);

	@:keep
	public function _errorUnusedPkg(_obj:Ref<PkgName>):Void
		__self__.value._errorUnusedPkg(_obj);

	/**
		// unusedImports checks for unused imports.
	**/
	@:keep
	public function _unusedImports():Void
		__self__.value._unusedImports();

	/**
		// packageObjects typechecks all package objects, but not function bodies.
	**/
	@:keep
	public function _packageObjects():Void
		__self__.value._packageObjects();

	/**
		// resolveBaseTypeName returns the non-alias base type name for typ, and whether
		// there was a pointer indirection to get to it. The base type name must be declared
		// in package scope, and there can be at most one pointer indirection. If no such type
		// name exists, the returned base is nil.
	**/
	@:keep
	public function _resolveBaseTypeName(_seenPtr:Bool, _name:Ref<stdgo.go.ast.Ast.Ident>):{var _0:Bool; var _1:Ref<TypeName>;}
		return __self__.value._resolveBaseTypeName(_seenPtr, _name);

	/**
		// unpackRecv unpacks a receiver type and returns its components: ptr indicates whether
		// rtyp is a pointer receiver, rname is the receiver type name, and tparams are its
		// type parameters, if any. The type parameters are only unpacked if unpackParams is
		// set. If rname is nil, the receiver is unusable (i.e., the source has a bug which we
		// cannot easily work around).
	**/
	@:keep
	public function _unpackRecv(_rtyp:stdgo.go.ast.Ast.Expr,
			_unpackParams:Bool):{var _0:Bool; var _1:Ref<stdgo.go.ast.Ast.Ident>; var _2:Slice<Ref<stdgo.go.ast.Ast.Ident>>;}
		return __self__.value._unpackRecv(_rtyp, _unpackParams);

	/**
		// collectObjects collects all file and package objects and inserts them
		// into their respective scopes. It also performs imports and associates
		// methods with receiver base type names.
	**/
	@:keep
	public function _collectObjects():Void
		__self__.value._collectObjects();

	@:keep
	public function _importPackage(_at:T_positioner, _path:GoString, _dir:GoString):Ref<Package>
		return __self__.value._importPackage(_at, _path, _dir);

	/**
		// filename returns a filename suitable for debugging output.
	**/
	@:keep
	public function _filename(_fileNo:GoInt):GoString
		return __self__.value._filename(_fileNo);

	/**
		// declarePkgObj declares obj in the package scope, records its ident -> obj mapping,
		// and updates check.objMap. The object must not be a function or method.
	**/
	@:keep
	public function _declarePkgObj(_ident:Ref<stdgo.go.ast.Ast.Ident>, _obj:Object, _d:Ref<T_declInfo>):Void
		__self__.value._declarePkgObj(_ident, _obj, _d);

	/**
		// arityMatch checks that the lhs and rhs of a const or var decl
		// have the appropriate number of names and init exprs. For const
		// decls, init is the value spec providing the init exprs; for
		// var decls, init is nil (the init exprs are in s in this case).
	**/
	@:keep
	public function _arityMatch(_s:Ref<stdgo.go.ast.Ast.ValueSpec>, _init:Ref<stdgo.go.ast.Ast.ValueSpec>):Void
		__self__.value._arityMatch(_s, _init);

	/**
		// context returns the type-checker context.
	**/
	@:keep
	public function _context():Ref<Context>
		return __self__.value._context();

	/**
		// newNamedInstance creates a new named instance for the given origin and type
		// arguments, recording pos as the position of its synthetic object (for error
		// reporting).
		//
		// If set, expanding is the named type instance currently being expanded, that
		// led to the creation of this instance.
	**/
	@:keep
	public function _newNamedInstance(_pos:stdgo.go.token.Token.Pos, _orig:Ref<Named>, _targs:Slice<Type>, _expanding:Ref<Named>):Ref<Named>
		return __self__.value._newNamedInstance(_pos, _orig, _targs, _expanding);

	/**
		// newNamed is like NewNamed but with a *Checker receiver and additional orig argument.
	**/
	@:keep
	public function _newNamed(_obj:Ref<TypeName>, _underlying:Type, _methods:Slice<Ref<Func>>):Ref<Named>
		return __self__.value._newNamed(_obj, _underlying, _methods);

	@:keep
	public function _reportInstanceLoop(_v:GoInt):Void
		__self__.value._reportInstanceLoop(_v);

	@:keep
	public function _monomorph():Void
		__self__.value._monomorph();

	/**
		// newAssertableTo reports whether a value of type V can be asserted to have type T.
		// It also implements behavior for interfaces that currently are only permitted
		// in constraint position (we have not yet defined that behavior in the spec).
	**/
	@:keep
	public function _newAssertableTo(v:Ref<Interface>, t:Type):Error
		return __self__.value._newAssertableTo(v, t);

	/**
		// assertableTo reports whether a value of type V can be asserted to have type T.
		// It returns (nil, false) as affirmative answer. Otherwise it returns a missing
		// method required by V and whether it is missing or just has the wrong type.
		// The receiver may be nil if assertableTo is invoked through an exported API call
		// (such as AssertableTo), i.e., when all methods have been type-checked.
		// TODO(gri) replace calls to this function with calls to newAssertableTo.
	**/
	@:keep
	public function _assertableTo(v:Ref<Interface>, t:Type):{var _0:Ref<Func>; var _1:Ref<Func>;}
		return __self__.value._assertableTo(v, t);

	/**
		// check may be nil.
	**/
	@:keep
	public function _funcString(_f:Ref<Func>):GoString
		return __self__.value._funcString(_f);

	/**
		// check may be nil.
	**/
	@:keep
	public function _interfacePtrError(t:Type):GoString
		return __self__.value._interfacePtrError(t);

	/**
		// missingMethodReason returns a string giving the detailed reason for a missing method m,
		// where m is missing from V, but required by T. It puts the reason in parentheses,
		// and may include more have/want info after that. If non-nil, alt is a relevant
		// method that matches in some way. It may have the correct name, but wrong type, or
		// it may have a pointer receiver, or it may have the correct name except wrong case.
		// check may be nil.
	**/
	@:keep
	public function _missingMethodReason(v:Type, t:Type, _m:Ref<Func>, _alt:Ref<Func>):GoString
		return __self__.value._missingMethodReason(v, t, _m, _alt);

	/**
		// missingMethod is like MissingMethod but accepts a *Checker as receiver.
		// The receiver may be nil if missingMethod is invoked through an exported
		// API call (such as MissingMethod), i.e., when all methods have been type-
		// checked.
		//
		// If a method is missing on T but is found on *T, or if a method is found
		// on T when looked up with case-folding, this alternative method is returned
		// as the second result.
	**/
	@:keep
	public function _missingMethod(v:Type, t:Ref<Interface>, _static:Bool):{var _0:Ref<Func>; var _1:Ref<Func>;}
		return __self__.value._missingMethod(v, t, _static);

	/**
		// blockBranches processes a block's statement list and returns the set of outgoing forward jumps.
		// all is the scope of all declared labels, parent the set of labels declared in the immediately
		// enclosing block, and lstmt is the labeled statement this block is associated with (or nil).
	**/
	@:keep
	public function _blockBranches(_all:Ref<Scope>, _parent:Ref<T_block>, _lstmt:Ref<stdgo.go.ast.Ast.LabeledStmt>,
			_list:Slice<stdgo.go.ast.Ast.Stmt>):Slice<Ref<stdgo.go.ast.Ast.BranchStmt>>
		return __self__.value._blockBranches(_all, _parent, _lstmt, _list);

	/**
		// labels checks correct label use in body.
	**/
	@:keep
	public function _labels(_body:Ref<stdgo.go.ast.Ast.BlockStmt>):Void
		__self__.value._labels(_body);

	@:keep
	public function _interfaceType(_ityp:Ref<Interface>, _iface:Ref<stdgo.go.ast.Ast.InterfaceType>, _def:Ref<Named>):Void
		__self__.value._interfaceType(_ityp, _iface, _def);

	/**
		// check may be nil
	**/
	@:keep
	public function _newInterface():Ref<Interface>
		return __self__.value._newInterface();

	/**
		// implements checks if V implements T and reports an error if it doesn't.
		// The receiver may be nil if implements is called through an exported
		// API call such as AssignableTo.
	**/
	@:keep
	public function _implements(v:Type, t:Type):Error
		return __self__.value._implements(v, t);

	@:keep
	public function _verify(_pos:stdgo.go.token.Token.Pos, _tparams:Slice<Ref<TypeParam>>, _targs:Slice<Type>,
			_ctxt:Ref<Context>):{var _0:GoInt; var _1:Error;}
		return __self__.value._verify(_pos, _tparams, _targs, _ctxt);

	/**
		// validateTArgLen verifies that the length of targs and tparams matches,
		// reporting an error if not. If validation fails and check is nil,
		// validateTArgLen panics.
	**/
	@:keep
	public function _validateTArgLen(_pos:stdgo.go.token.Token.Pos, _ntparams:GoInt, _ntargs:GoInt):Bool
		return __self__.value._validateTArgLen(_pos, _ntparams, _ntargs);

	/**
		// instance instantiates the given original (generic) function or type with the
		// provided type arguments and returns the resulting instance. If an identical
		// instance exists already in the given contexts, it returns that instance,
		// otherwise it creates a new one.
		//
		// If expanding is non-nil, it is the Named instance type currently being
		// expanded. If ctxt is non-nil, it is the context associated with the current
		// type-checking pass or call to Instantiate. At least one of expanding or ctxt
		// must be non-nil.
		//
		// For Named types the resulting instance may be unexpanded.
	**/
	@:keep
	public function _instance(_pos:stdgo.go.token.Token.Pos, _orig:Type, _targs:Slice<Type>, _expanding:Ref<Named>, _ctxt:Ref<Context>):Type
		return __self__.value._instance(_pos, _orig, _targs, _expanding, _ctxt);

	/**
		// reportCycle reports an error for the given cycle.
	**/
	@:keep
	public function _reportCycle(_cycle:Slice<Object>):Void
		__self__.value._reportCycle(_cycle);

	/**
		// initOrder computes the Info.InitOrder for package variables.
	**/
	@:keep
	public function _initOrder():Void
		__self__.value._initOrder();

	/**
		// inferB returns the list of actual type arguments inferred from the type parameters'
		// bounds and an initial set of type arguments. If type inference is impossible because
		// unification fails, an error is reported if report is set to true, the resulting types
		// list is nil, and index is 0.
		// Otherwise, types is the list of inferred type arguments, and index is the index of the
		// first type argument in that list that couldn't be inferred (and thus is nil). If all
		// type arguments were inferred successfully, index is < 0. The number of type arguments
		// provided may be less than the number of type parameters, but there must be at least one.
	**/
	@:keep
	public function _inferB(_posn:T_positioner, _tparams:Slice<Ref<TypeParam>>, _targs:Slice<Type>):{var _0:Slice<Type>; var _1:GoInt;}
		return __self__.value._inferB(_posn, _tparams, _targs);

	/**
		// infer attempts to infer the complete set of type arguments for generic function instantiation/call
		// based on the given type parameters tparams, type arguments targs, function parameters params, and
		// function arguments args, if any. There must be at least one type parameter, no more type arguments
		// than type parameters, and params and args must match in number (incl. zero).
		// If successful, infer returns the complete list of type arguments, one for each type parameter.
		// Otherwise the result is nil and appropriate errors will be reported.
		//
		// Inference proceeds as follows:
		//
		//	Starting with given type arguments
		//	1) apply FTI (function type inference) with typed arguments,
		//	2) apply CTI (constraint type inference),
		//	3) apply FTI with untyped function arguments,
		//	4) apply CTI.
		//
		// The process stops as soon as all type arguments are known or an error occurs.
	**/
	@:keep
	public function _infer(_posn:T_positioner, _tparams:Slice<Ref<TypeParam>>, _targs:Slice<Type>, _params:Ref<Tuple>, _args:Slice<Ref<T_operand>>):Slice<Type>
		return __self__.value._infer(_posn, _tparams, _targs, _params, _args);

	/**
		// indexElts checks the elements (elts) of an array or slice composite literal
		// against the literal's element type (typ), and the element indices against
		// the literal length if known (length >= 0). It returns the length of the
		// literal (maximum index value + 1).
	**/
	@:keep
	public function _indexedElts(_elts:Slice<stdgo.go.ast.Ast.Expr>, _typ:Type, _length:GoInt64):GoInt64
		return __self__.value._indexedElts(_elts, _typ, _length);

	@:keep
	public function _isValidIndex(_x:Ref<T_operand>, _code:T_errorCode, _what:GoString, _allowNegative:Bool):Bool
		return __self__.value._isValidIndex(_x, _code, _what, _allowNegative);

	/**
		// index checks an index expression for validity.
		// If max >= 0, it is the upper bound for index.
		// If the result typ is != Typ[Invalid], index is valid and typ is its (possibly named) integer type.
		// If the result val >= 0, index is valid and val is its constant int value.
	**/
	@:keep
	public function _index(_index:stdgo.go.ast.Ast.Expr, _max:GoInt64):{var _0:Type; var _1:GoInt64;}
		return __self__.value._index(_index, _max);

	/**
		// singleIndex returns the (single) index from the index expression e.
		// If the index is missing, or if there are multiple indices, an error
		// is reported and the result is nil.
	**/
	@:keep
	public function _singleIndex(_expr:Ref<go.internal.typeparams.Typeparams.IndexExpr>):stdgo.go.ast.Ast.Expr
		return __self__.value._singleIndex(_expr);

	@:keep
	public function _sliceExpr(_x:Ref<T_operand>, _e:Ref<stdgo.go.ast.Ast.SliceExpr>):Void
		__self__.value._sliceExpr(_x, _e);

	/**
		// If e is a valid function instantiation, indexExpr returns true.
		// In that case x represents the uninstantiated function value and
		// it is the caller's responsibility to instantiate the function.
	**/
	@:keep
	public function _indexExpr(_x:Ref<T_operand>, _e:Ref<go.internal.typeparams.Typeparams.IndexExpr>):Bool
		return __self__.value._indexExpr(_x, _e);

	/**
		// singleValue reports an error if x describes a tuple and sets x.mode to invalid.
	**/
	@:keep
	public function _singleValue(_x:Ref<T_operand>):Void
		__self__.value._singleValue(_x);

	/**
		// exclude reports an error if x.mode is in modeset and sets x.mode to invalid.
		// The modeset may contain any of 1<<novalue, 1<<builtin, 1<<typexpr.
	**/
	@:keep
	public function _exclude(_x:Ref<T_operand>, _modeset:GoUInt):Void
		__self__.value._exclude(_x, _modeset);

	/**
		// exprOrType typechecks expression or type e and initializes x with the expression value or type.
		// If allowGeneric is set, the operand type may be an uninstantiated parameterized type or function
		// value.
		// If an error occurred, x.mode is set to invalid.
	**/
	@:keep
	public function _exprOrType(_x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _allowGeneric:Bool):Void
		__self__.value._exprOrType(_x, _e, _allowGeneric);

	/**
		// exprWithHint typechecks expression e and initializes x with the expression value;
		// hint is the type of a composite literal element.
		// If an error occurred, x.mode is set to invalid.
	**/
	@:keep
	public function _exprWithHint(_x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _hint:Type):Void
		__self__.value._exprWithHint(_x, _e, _hint);

	/**
		// multiExpr is like expr but the result may also be a multi-value.
	**/
	@:keep
	public function _multiExpr(_x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr):Void
		__self__.value._multiExpr(_x, _e);

	/**
		// expr typechecks expression e and initializes x with the expression value.
		// The result must be a single value.
		// If an error occurred, x.mode is set to invalid.
	**/
	@:keep
	public function _expr(_x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr):Void
		__self__.value._expr(_x, _e);

	/**
		// typeAssertion checks x.(T). The type of x must be an interface.
	**/
	@:keep
	public function _typeAssertion(_e:stdgo.go.ast.Ast.Expr, _x:Ref<T_operand>, t:Type, _typeSwitch:Bool):Void
		__self__.value._typeAssertion(_e, _x, t, _typeSwitch);

	/**
		// exprInternal contains the core of type checking of expressions.
		// Must only be called by rawExpr.
	**/
	@:keep
	public function _exprInternal(_x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _hint:Type):T_exprKind
		return __self__.value._exprInternal(_x, _e, _hint);

	/**
		// If x is a generic function or type, nonGeneric reports an error and invalidates x.mode and x.typ.
		// Otherwise it leaves x alone.
	**/
	@:keep
	public function _nonGeneric(_x:Ref<T_operand>):Void
		__self__.value._nonGeneric(_x);

	/**
		// rawExpr typechecks expression e and initializes x with the expression
		// value or type. If an error occurred, x.mode is set to invalid.
		// If hint != nil, it is the type of a composite literal element.
		// If allowGeneric is set, the operand type may be an uninstantiated
		// parameterized type or function value.
	**/
	@:keep
	public function _rawExpr(_x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _hint:Type, _allowGeneric:Bool):T_exprKind
		return __self__.value._rawExpr(_x, _e, _hint, _allowGeneric);

	/**
		// If e != nil, it must be the binary expression; it may be nil for non-constant expressions
		// (when invoked for an assignment operation where the binary expression is implicit).
	**/
	@:keep
	public function _binary(_x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _lhs:stdgo.go.ast.Ast.Expr, _rhs:stdgo.go.ast.Ast.Expr,
			_op:stdgo.go.token.Token.Token, _opPos:stdgo.go.token.Token.Pos):Void
		__self__.value._binary(_x, _e, _lhs, _rhs, _op, _opPos);

	/**
		// If e != nil, it must be the shift expression; it may be nil for non-constant shifts.
	**/
	@:keep
	public function _shift(_x:Ref<T_operand>, _y:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _op:stdgo.go.token.Token.Token):Void
		__self__.value._shift(_x, _y, _e, _op);

	/**
		// kindString returns the type kind as a string.
	**/
	@:keep
	public function _kindString(_typ:Type):GoString
		return __self__.value._kindString(_typ);

	/**
		// incomparableCause returns a more specific cause why typ is not comparable.
		// If there is no more specific cause, the result is "".
	**/
	@:keep
	public function _incomparableCause(_typ:Type):GoString
		return __self__.value._incomparableCause(_typ);

	/**
		// If switchCase is true, the operator op is ignored.
	**/
	@:keep
	public function _comparison(_x:Ref<T_operand>, _y:Ref<T_operand>, _op:stdgo.go.token.Token.Token, _switchCase:Bool):Void
		__self__.value._comparison(_x, _y, _op, _switchCase);

	/**
		// implicitTypeAndValue returns the implicit type of x when used in a context
		// where the target type is expected. If no such implicit conversion is
		// possible, it returns a nil Type and non-zero error code.
		//
		// If x is a constant operand, the returned constant.Value will be the
		// representation of x in this context.
	**/
	@:keep
	public function _implicitTypeAndValue(_x:Ref<T_operand>, _target:Type):{var _0:Type; var _1:stdgo.go.constant.Constant.Value; var _2:T_errorCode;}
		return __self__.value._implicitTypeAndValue(_x, _target);

	/**
		// convertUntyped attempts to set the type of an untyped value to the target type.
	**/
	@:keep
	public function _convertUntyped(_x:Ref<T_operand>, _target:Type):Void
		__self__.value._convertUntyped(_x, _target);

	/**
		// updateExprVal updates the value of x to val.
	**/
	@:keep
	public function _updateExprVal(_x:stdgo.go.ast.Ast.Expr, _val:stdgo.go.constant.Constant.Value):Void
		__self__.value._updateExprVal(_x, _val);

	@:keep
	public function _updateExprType0(_parent:stdgo.go.ast.Ast.Expr, _x:stdgo.go.ast.Ast.Expr, _typ:Type, _final:Bool):Void
		__self__.value._updateExprType0(_parent, _x, _typ, _final);

	/**
		// updateExprType updates the type of x to typ and invokes itself
		// recursively for the operands of x, depending on expression kind.
		// If typ is still an untyped and not the final type, updateExprType
		// only updates the recorded untyped type for x and possibly its
		// operands. Otherwise (i.e., typ is not an untyped type anymore,
		// or it is the final type for x), the type and value are recorded.
		// Also, if x is a constant, it must be representable as a value of typ,
		// and if x is the (formerly untyped) lhs operand of a non-constant
		// shift, it must be an integer value.
	**/
	@:keep
	public function _updateExprType(_x:stdgo.go.ast.Ast.Expr, _typ:Type, _final:Bool):Void
		__self__.value._updateExprType(_x, _typ, _final);

	@:keep
	public function _invalidConversion(_code:T_errorCode, _x:Ref<T_operand>, _target:Type):Void
		__self__.value._invalidConversion(_code, _x, _target);

	/**
		// representation returns the representation of the constant operand x as the
		// basic type typ.
		//
		// If no such representation is possible, it returns a non-zero error code.
	**/
	@:keep
	public function _representation(_x:Ref<T_operand>, _typ:Ref<Basic>):{var _0:stdgo.go.constant.Constant.Value; var _1:T_errorCode;}
		return __self__.value._representation(_x, _typ);

	/**
		// representable checks that a constant operand is representable in the given
		// basic type.
	**/
	@:keep
	public function _representable(_x:Ref<T_operand>, _typ:Ref<Basic>):Void
		__self__.value._representable(_x, _typ);

	/**
		// The unary expression e may be nil. It's passed in for better error messages only.
	**/
	@:keep
	public function _unary(_x:Ref<T_operand>, _e:Ref<stdgo.go.ast.Ast.UnaryExpr>):Void
		__self__.value._unary(_x, _e);

	/**
		// overflow checks that the constant x is representable by its type.
		// For untyped constants, it checks that the value doesn't become
		// arbitrarily large.
	**/
	@:keep
	public function _overflow(_x:Ref<T_operand>, _opPos:stdgo.go.token.Token.Pos):Void
		__self__.value._overflow(_x, _opPos);

	@:keep
	public function _op(_m:T_opPredicates, _x:Ref<T_operand>, _op:stdgo.go.token.Token.Token):Bool
		return __self__.value._op(_m, _x, _op);

	@:keep
	public function _invalidOp(_at:T_positioner, _code:T_errorCode, _format:GoString, _args:haxe.Rest<AnyInterface>):Void
		__self__.value._invalidOp(_at, _code, _format, ..._args);

	@:keep
	public function _invalidArg(_at:T_positioner, _code:T_errorCode, _format:GoString, _args:haxe.Rest<AnyInterface>):Void
		__self__.value._invalidArg(_at, _code, _format, ..._args);

	@:keep
	public function _invalidAST(_at:T_positioner, _format:GoString, _args:haxe.Rest<AnyInterface>):Void
		__self__.value._invalidAST(_at, _format, ..._args);

	@:keep
	public function _versionErrorf(_at:T_positioner, _code:T_errorCode, _goVersion:GoString, _format:GoString, _args:haxe.Rest<AnyInterface>):Void
		__self__.value._versionErrorf(_at, _code, _goVersion, _format, ..._args);

	@:keep
	public function _softErrorf(_at:T_positioner, _code:T_errorCode, _format:GoString, _args:haxe.Rest<AnyInterface>):Void
		__self__.value._softErrorf(_at, _code, _format, ..._args);

	@:keep
	public function _errorf(_at:T_positioner, _code:T_errorCode, _format:GoString, _args:haxe.Rest<AnyInterface>):Void
		__self__.value._errorf(_at, _code, _format, ..._args);

	@:keep
	public function _error(_at:T_positioner, _code:T_errorCode, _msg:GoString):Void
		__self__.value._error(_at, _code, _msg);

	/**
		// Report records the error pointed to by errp, setting check.firstError if
		// necessary.
	**/
	@:keep
	public function _report(_errp:Ref<T_error_>):Void
		__self__.value._report(_errp);

	/**
		// dump is only needed for debugging
	**/
	@:keep
	public function _dump(_format:GoString, _args:haxe.Rest<AnyInterface>):Void
		__self__.value._dump(_format, ..._args);

	@:keep
	public function _trace(_pos:stdgo.go.token.Token.Pos, _format:GoString, _args:haxe.Rest<AnyInterface>):Void
		__self__.value._trace(_pos, _format, ..._args);

	/**
		// check may be nil.
	**/
	@:keep
	public function _sprintf(_format:GoString, _args:haxe.Rest<AnyInterface>):GoString
		return __self__.value._sprintf(_format, ..._args);

	/**
		// markImports recursively walks pkg and its imports, to record unique import
		// paths in pkgPathMap.
	**/
	@:keep
	public function _markImports(_pkg:Ref<Package>):Void
		__self__.value._markImports(_pkg);

	@:keep
	public function _qualifier(_pkg:Ref<Package>):GoString
		return __self__.value._qualifier(_pkg);

	@:keep
	public function _declStmt(_d:stdgo.go.ast.Ast.Decl):Void
		__self__.value._declStmt(_d);

	@:keep
	public function _funcDecl(_obj:Ref<Func>, _decl:Ref<T_declInfo>):Void
		__self__.value._funcDecl(_obj, _decl);

	@:keep
	public function _checkFieldUniqueness(_base:Ref<Named>):Void
		__self__.value._checkFieldUniqueness(_base);

	@:keep
	public function _collectMethods(_obj:Ref<TypeName>):Void
		__self__.value._collectMethods(_obj);

	@:keep
	public function _declareTypeParams(_tparams:Slice<Ref<TypeParam>>, _names:Slice<Ref<stdgo.go.ast.Ast.Ident>>):Slice<Ref<TypeParam>>
		return __self__.value._declareTypeParams(_tparams, _names);

	@:keep
	public function _bound(_x:stdgo.go.ast.Ast.Expr):Type
		return __self__.value._bound(_x);

	@:keep
	public function _collectTypeParams(_dst:Ref<Ref<TypeParamList>>, _list:Ref<stdgo.go.ast.Ast.FieldList>):Void
		__self__.value._collectTypeParams(_dst, _list);

	@:keep
	public function _typeDecl(_obj:Ref<TypeName>, _tdecl:Ref<stdgo.go.ast.Ast.TypeSpec>, _def:Ref<Named>):Void
		__self__.value._typeDecl(_obj, _tdecl, _def);

	/**
		// isImportedConstraint reports whether typ is an imported type constraint.
	**/
	@:keep
	public function _isImportedConstraint(_typ:Type):Bool
		return __self__.value._isImportedConstraint(_typ);

	@:keep
	public function _varDecl(_obj:Ref<Var>, _lhs:Slice<Ref<Var>>, _typ:stdgo.go.ast.Ast.Expr, _init:stdgo.go.ast.Ast.Expr):Void
		__self__.value._varDecl(_obj, _lhs, _typ, _init);

	@:keep
	public function _constDecl(_obj:Ref<Const>, _typ:stdgo.go.ast.Ast.Expr, _init:stdgo.go.ast.Ast.Expr, _inherited:Bool):Void
		__self__.value._constDecl(_obj, _typ, _init, _inherited);

	@:keep
	public function _walkDecl(_d:stdgo.go.ast.Ast.Decl, _f:T_decl->Void):Void
		__self__.value._walkDecl(_d, _f);

	@:keep
	public function _walkDecls(_decls:Slice<stdgo.go.ast.Ast.Decl>, _f:T_decl->Void):Void
		__self__.value._walkDecls(_decls, _f);

	/**
		// cycleError reports a declaration cycle starting with
		// the object in cycle that is "first" in the source.
	**/
	@:keep
	public function _cycleError(_cycle:Slice<Object>):Void
		__self__.value._cycleError(_cycle);

	/**
		// validCycle checks if the cycle starting with obj is valid and
		// reports an error if it is not.
	**/
	@:keep
	public function _validCycle(_obj:Object):Bool
		return __self__.value._validCycle(_obj);

	/**
		// objDecl type-checks the declaration of obj in its respective (file) environment.
		// For the meaning of def, see Checker.definedType, in typexpr.go.
	**/
	@:keep
	public function _objDecl(_obj:Object, _def:Ref<Named>):Void
		__self__.value._objDecl(_obj, _def);

	@:keep
	public function _declare(_scope:Ref<Scope>, _id:Ref<stdgo.go.ast.Ast.Ident>, _obj:Object, _pos:stdgo.go.token.Token.Pos):Void
		__self__.value._declare(_scope, _id, _obj, _pos);

	@:keep
	public function _reportAltDecl(_obj:Object):Void
		__self__.value._reportAltDecl(_obj);

	/**
		// Conversion type-checks the conversion T(x).
		// The result is in x.
	**/
	@:keep
	public function _conversion(_x:Ref<T_operand>, t:Type):Void
		__self__.value._conversion(_x, t);

	@:keep
	public function _recordScope(_node:stdgo.go.ast.Ast.Node, _scope:Ref<Scope>):Void
		__self__.value._recordScope(_node, _scope);

	@:keep
	public function _recordSelection(_x:Ref<stdgo.go.ast.Ast.SelectorExpr>, _kind:SelectionKind, _recv:Type, _obj:Object, _index:Slice<GoInt>,
			_indirect:Bool):Void
		__self__.value._recordSelection(_x, _kind, _recv, _obj, _index, _indirect);

	@:keep
	public function _recordImplicit(_node:stdgo.go.ast.Ast.Node, _obj:Object):Void
		__self__.value._recordImplicit(_node, _obj);

	@:keep
	public function _recordUse(_id:Ref<stdgo.go.ast.Ast.Ident>, _obj:Object):Void
		__self__.value._recordUse(_id, _obj);

	@:keep
	public function _recordDef(_id:Ref<stdgo.go.ast.Ast.Ident>, _obj:Object):Void
		__self__.value._recordDef(_id, _obj);

	/**
		// recordInstance records instantiation information into check.Info, if the
		// Instances map is non-nil. The given expr must be an ident, selector, or
		// index (list) expr with ident or selector operand.
		//
		// TODO(rfindley): the expr parameter is fragile. See if we can access the
		// instantiated identifier in some other way.
	**/
	@:keep
	public function _recordInstance(_expr:stdgo.go.ast.Ast.Expr, _targs:Slice<Type>, _typ:Type):Void
		__self__.value._recordInstance(_expr, _targs, _typ);

	@:keep
	public function _recordCommaOkTypes(_x:stdgo.go.ast.Ast.Expr, _a:GoArray<Type>):Void
		__self__.value._recordCommaOkTypes(_x, _a);

	@:keep
	public function _recordBuiltinType(_f:stdgo.go.ast.Ast.Expr, _sig:Ref<Signature>):Void
		__self__.value._recordBuiltinType(_f, _sig);

	@:keep
	public function _recordTypeAndValue(_x:stdgo.go.ast.Ast.Expr, _mode:T_operandMode, _typ:Type, _val:stdgo.go.constant.Constant.Value):Void
		__self__.value._recordTypeAndValue(_x, _mode, _typ, _val);

	@:keep
	public function _recordUntyped():Void
		__self__.value._recordUntyped();

	@:keep
	public function _record(_x:Ref<T_operand>):Void
		__self__.value._record(_x);

	/**
		// cleanup runs cleanup for all collected cleaners.
	**/
	@:keep
	public function _cleanup():Void
		__self__.value._cleanup();

	/**
		// processDelayed processes all delayed actions pushed after top.
	**/
	@:keep
	public function _processDelayed(_top:GoInt):Void
		__self__.value._processDelayed(_top);

	@:keep
	public function _checkFiles(_files:Slice<Ref<stdgo.go.ast.Ast.File>>):Error
		return __self__.value._checkFiles(_files);

	/**
		// Files checks the provided files as part of the checker's package.
	**/
	@:keep
	public function files(_files:Slice<Ref<stdgo.go.ast.Ast.File>>):Error
		return __self__.value.files(_files);

	@:keep
	public function _handleBailout(_err:Ref<Error>):Void
		__self__.value._handleBailout(_err);

	/**
		// initFiles initializes the files-specific portion of checker.
		// The provided files must all belong to the same package.
	**/
	@:keep
	public function _initFiles(_files:Slice<Ref<stdgo.go.ast.Ast.File>>):Void
		__self__.value._initFiles(_files);

	/**
		// needsCleanup records objects/types that implement the cleanup method
		// which will be called at the end of type-checking.
	**/
	@:keep
	public function _needsCleanup(_c:T_cleaner):Void
		__self__.value._needsCleanup(_c);

	/**
		// pop pops and returns the topmost object from the object path.
	**/
	@:keep
	public function _pop():Object
		return __self__.value._pop();

	/**
		// push pushes obj onto the object path and returns its index in the path.
	**/
	@:keep
	public function _push(_obj:Object):GoInt
		return __self__.value._push(_obj);

	/**
		// later pushes f on to the stack of actions that will be processed later;
		// either at the end of the current statement, or in case of a local constant
		// or variable declaration, before the constant or variable is in scope
		// (so that f still sees the scope before any new declarations).
		// later returns the pushed action so one can provide a description
		// via action.describef for debugging, if desired.
	**/
	@:keep
	public function _later(_f:() -> Void):Ref<T_action>
		return __self__.value._later(_f);

	@:keep
	public function _rememberUntyped(_e:stdgo.go.ast.Ast.Expr, _lhs:Bool, _mode:T_operandMode, _typ:Ref<Basic>, _val:stdgo.go.constant.Constant.Value):Void
		__self__.value._rememberUntyped(_e, _lhs, _mode, _typ, _val);

	/**
		// isBrokenAlias reports whether alias doesn't have a determined type yet.
	**/
	@:keep
	public function _isBrokenAlias(_alias:Ref<TypeName>):Bool
		return __self__.value._isBrokenAlias(_alias);

	/**
		// validAlias records that alias has the valid type typ (possibly Typ[Invalid]).
	**/
	@:keep
	public function _validAlias(_alias:Ref<TypeName>, _typ:Type):Void
		__self__.value._validAlias(_alias, _typ);

	/**
		// brokenAlias records that alias doesn't have a determined type yet.
		// It also sets alias.typ to Typ[Invalid].
	**/
	@:keep
	public function _brokenAlias(_alias:Ref<TypeName>):Void
		__self__.value._brokenAlias(_alias);

	/**
		// addDeclDep adds the dependency edge (check.decl -> to) if check.decl exists
	**/
	@:keep
	public function _addDeclDep(_to:Object):Void
		__self__.value._addDeclDep(_to);

	/**
		// useLHS is like use, but doesn't "use" top-level identifiers.
		// It should be called instead of use if the arguments are
		// expressions on the lhs of an assignment.
		// The arguments must not be nil.
	**/
	@:keep
	public function _useLHS(_arg:haxe.Rest<stdgo.go.ast.Ast.Expr>):Void
		__self__.value._useLHS(..._arg);

	/**
		// use type-checks each argument.
		// Useful to make sure expressions are evaluated
		// (and variables are "used") in the presence of other errors.
		// The arguments may be nil.
	**/
	@:keep
	public function _use(_arg:haxe.Rest<stdgo.go.ast.Ast.Expr>):Void
		__self__.value._use(..._arg);

	@:keep
	public function _selector(_x:Ref<T_operand>, _e:Ref<stdgo.go.ast.Ast.SelectorExpr>, _def:Ref<Named>):Void
		__self__.value._selector(_x, _e, _def);

	/**
		// xlist is the list of type argument expressions supplied in the source code.
	**/
	@:keep
	public function _arguments(_call:Ref<stdgo.go.ast.Ast.CallExpr>, _sig:Ref<Signature>, _targs:Slice<Type>, _args:Slice<Ref<T_operand>>,
			_xlist:Slice<stdgo.go.ast.Ast.Expr>):Ref<Signature>
		return __self__.value._arguments(_call, _sig, _targs, _args, _xlist);

	@:keep
	public function _exprList(_elist:Slice<stdgo.go.ast.Ast.Expr>, _allowCommaOk:Bool):{var _0:Slice<Ref<T_operand>>; var _1:Bool;}
		return __self__.value._exprList(_elist, _allowCommaOk);

	@:keep
	public function _callExpr(_x:Ref<T_operand>, _call:Ref<stdgo.go.ast.Ast.CallExpr>):T_exprKind
		return __self__.value._callExpr(_x, _call);

	@:keep
	public function _instantiateSignature(_pos:stdgo.go.token.Token.Pos, _typ:Ref<Signature>, _targs:Slice<Type>,
			_xlist:Slice<stdgo.go.ast.Ast.Expr>):Ref<Signature>
		return __self__.value._instantiateSignature(_pos, _typ, _targs, _xlist);

	/**
		// funcInst type-checks a function instantiation inst and returns the result in x.
		// The operand x must be the evaluation of inst.X and its type must be a signature.
	**/
	@:keep
	public function _funcInst(_x:Ref<T_operand>, _ix:Ref<go.internal.typeparams.Typeparams.IndexExpr>):Void
		__self__.value._funcInst(_x, _ix);

	/**
		// applyTypeFunc applies f to x. If x is a type parameter,
		// the result is a type parameter constrained by an new
		// interface bound. The type bounds for that interface
		// are computed by applying f to each of the type bounds
		// of x. If any of these applications of f return nil,
		// applyTypeFunc returns nil.
		// If x is not a type parameter, the result is f(x).
	**/
	@:keep
	public function _applyTypeFunc(_f:Type->Type, _x:Ref<T_operand>, _id:T_builtinId):Type
		return __self__.value._applyTypeFunc(_f, _x, _id);

	/**
		// builtin type-checks a call to the built-in specified by id and
		// reports whether the call is valid, with *x holding the result;
		// but x.expr is not set. If the call is invalid, the result is
		// false, and *x is undefined.
	**/
	@:keep
	public function _builtin(_x:Ref<T_operand>, _call:Ref<stdgo.go.ast.Ast.CallExpr>, _id:T_builtinId):Bool
		return __self__.value._builtin(_x, _call, _id);

	@:keep
	public function _shortVarDecl(_pos:T_positioner, _lhs:Slice<stdgo.go.ast.Ast.Expr>, _rhs:Slice<stdgo.go.ast.Ast.Expr>):Void
		__self__.value._shortVarDecl(_pos, _lhs, _rhs);

	@:keep
	public function _assignVars(_lhs:Slice<stdgo.go.ast.Ast.Expr>, _origRHS:Slice<stdgo.go.ast.Ast.Expr>):Void
		__self__.value._assignVars(_lhs, _origRHS);

	/**
		// If returnStmt != nil, initVars is called to type-check the assignment
		// of return expressions, and returnStmt is the return statement.
	**/
	@:keep
	public function _initVars(_lhs:Slice<Ref<Var>>, _origRHS:Slice<stdgo.go.ast.Ast.Expr>, _returnStmt:stdgo.go.ast.Ast.Stmt):Void
		__self__.value._initVars(_lhs, _origRHS, _returnStmt);

	@:keep
	public function _assignError(_rhs:Slice<stdgo.go.ast.Ast.Expr>, _nvars:GoInt, _nvals:GoInt):Void
		__self__.value._assignError(_rhs, _nvars, _nvals);

	/**
		// typesSummary returns a string of the form "(t1, t2, ...)" where the
		// ti's are user-friendly string representations for the given types.
		// If variadic is set and the last type is a slice, its string is of
		// the form "...E" where E is the slice's element type.
	**/
	@:keep
	public function _typesSummary(_list:Slice<Type>, _variadic:Bool):GoString
		return __self__.value._typesSummary(_list, _variadic);

	@:keep
	public function _assignVar(_lhs:stdgo.go.ast.Ast.Expr, _x:Ref<T_operand>):Type
		return __self__.value._assignVar(_lhs, _x);

	@:keep
	public function _initVar(_lhs:Ref<Var>, _x:Ref<T_operand>, _context:GoString):Type
		return __self__.value._initVar(_lhs, _x, _context);

	@:keep
	public function _initConst(_lhs:Ref<Const>, _x:Ref<T_operand>):Void
		__self__.value._initConst(_lhs, _x);

	/**
		// assignment reports whether x can be assigned to a variable of type T,
		// if necessary by attempting to convert untyped values to the appropriate
		// type. context describes the context in which the assignment takes place.
		// Use T == nil to indicate assignment to an untyped blank identifier.
		// x.mode is set to invalid if the assignment failed.
	**/
	@:keep
	public function _assignment(_x:Ref<T_operand>, t:Type, _context:GoString):Void
		__self__.value._assignment(_x, t, _context);

	@:embedded
	public function _lookup(__0:GoString):Object
		return __self__.value._lookup(__0);

	@:embedded
	public function typeOf(_e:stdgo.go.ast.Ast.Expr):Type
		return __self__.value.typeOf(_e);

	@:embedded
	public function objectOf(_id:Ref<stdgo.go.ast.Ast.Ident>):Object
		return __self__.value.objectOf(_id);

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Checker>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Checker_asInterface) class Checker_static_extension {
	/**
		// allowVersion reports whether the given package
		// is allowed to use version major.minor.
	**/
	@:keep
	static public function _allowVersion(_check:Ref<Checker>, _pkg:Ref<Package>, _major:GoInt, _minor:GoInt):Bool {
		if (_pkg != (_check._pkg)) {
			return true;
		};
		var _0:GoInt = _check._version._major,
			_1:GoInt = _check._version._minor,
			_mi:GoInt = _1,
			_ma:GoInt = _0;
		return (((_ma == (0 : GoInt)) && (_mi == (0 : GoInt))) || (_ma > _major)) || ((_ma == _major) && (_mi >= _minor));
	}

	/**
		// langCompat reports an error if the representation of a numeric
		// literal is not compatible with the current language version.
	**/
	@:keep
	static public function _langCompat(_check:Ref<Checker>, _lit:Ref<stdgo.go.ast.Ast.BasicLit>):Void {
		var _s:GoString = _lit.value;
		if ((_s.length <= (2 : GoInt)) || _check._allowVersion(_check._pkg, (1 : GoInt), (13 : GoInt))) {
			return;
		};
		if (stdgo.strings.Strings.contains(_s, ("_" : GoString))) {
			_check._errorf(Go.asInterface(_lit), (71 : T_errorCode), ("underscores in numeric literals requires go1.13 or later" : GoString));
			return;
		};
		if (_s[(0 : GoInt)] != ((48 : GoUInt8))) {
			return;
		};
		var _radix:GoUInt8 = _s[(1 : GoInt)];
		if ((_radix == (98 : GoUInt8)) || (_radix == (66 : GoUInt8))) {
			_check._errorf(Go.asInterface(_lit), (71 : T_errorCode), ("binary literals requires go1.13 or later" : GoString));
			return;
		};
		if ((_radix == (111 : GoUInt8)) || (_radix == (79 : GoUInt8))) {
			_check._errorf(Go.asInterface(_lit), (71 : T_errorCode), ("0o/0O-style octal literals requires go1.13 or later" : GoString));
			return;
		};
		if ((_lit.kind != (5 : stdgo.go.token.Token.Token)) && ((_radix == (120 : GoUInt8)) || (_radix == (88 : GoUInt8)))) {
			_check._errorf(Go.asInterface(_lit), (71 : T_errorCode), ("hexadecimal floating-point literals requires go1.13 or later" : GoString));
		};
	}

	/**
		// validType0 checks if the given type is valid. If typ is a type parameter
		// its value is looked up in the type argument list of the instantiated
		// (enclosing) type, if it exists. Otherwise the type parameter must be from
		// an enclosing function and can be ignored.
		// The nest list describes the stack (the "nest in memory") of types which
		// contain (or embed in the case of interfaces) other types. For instance, a
		// struct named S which contains a field of named type F contains (the memory
		// of) F in S, leading to the nest S->F. If a type appears in its own nest
		// (say S->F->S) we have an invalid recursive type. The path list is the full
		// path of named types in a cycle, it is only needed for error reporting.
	**/
	@:keep
	static public function _validType0(_check:Ref<Checker>, _typ:Type, _nest:Slice<Ref<Named>>, _path:Slice<Ref<Named>>):Bool {
		{
			final __type__ = _typ;
			{
				var __bool__ = true;
				while (__bool__) {
					__bool__ = false;
					if (__type__ == null) {
						var _t:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
						if (false) {
							throw Go.toInterface(("validType0(nil)" : GoString));
						};
					} else if (Go.typeEquals((__type__ : Ref<Array_>))) {
						var _t:Ref<Array_> = __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__() == null ? (null : Ref<Array_>) : __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__()
							.value;
						return _check._validType0(_t._elem, _nest, _path);
					} else if (Go.typeEquals((__type__ : Ref<Struct>))) {
						var _t:Ref<Struct> = __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__() == null ? (null : Ref<Struct>) : __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__()
							.value;
						for (_0 => _f in _t._fields) {
							if (!_check._validType0(_f._object._typ, _nest, _path)) {
								return false;
							};
						};
					} else if (Go.typeEquals((__type__ : Ref<Union>))) {
						var _t:Ref<Union> = __type__ == null ? (null : Ref<Union>) : __type__.__underlying__() == null ? (null : Ref<Union>) : __type__ == null ? (null : Ref<Union>) : __type__.__underlying__()
							.value;
						for (_1 => _t in _t._terms) {
							if (!_check._validType0(_t._typ, _nest, _path)) {
								return false;
							};
						};
					} else if (Go.typeEquals((__type__ : Ref<Interface>))) {
						var _t:Ref<Interface> = __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__() == null ? (null : Ref<Interface>) : __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__()
							.value;
						for (_2 => _etyp in _t._embeddeds) {
							if (!_check._validType0(_etyp, _nest, _path)) {
								return false;
							};
						};
					} else if (Go.typeEquals((__type__ : Ref<Named>))) {
						var _t:Ref<Named> = __type__ == null ? (null : Ref<Named>) : __type__.__underlying__() == null ? (null : Ref<Named>) : __type__ == null ? (null : Ref<Named>) : __type__.__underlying__()
							.value;
						if (_check._valids._lookup(_t) != null) {
							break;
						};
						if (Go.toInterface(_t.underlying()) == (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
							return false;
						};
						for (_7 => _e in _nest) {
							if (identical(Go.asInterface(_e), Go.asInterface(_t))) {
								_assert(_t._obj._object._pkg == (_check._pkg));
								_t._underlying = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
								for (_start => _p in _path) {
									if (identical(Go.asInterface(_p), Go.asInterface(_t))) {
										_check._cycleError(_makeObjList((_path.__slice__(_start) : Slice<Ref<Named>>)));
										return false;
									};
								};
								throw Go.toInterface(("cycle start not found" : GoString));
							};
						};
						if (!_check._validType0(_t.origin()._fromRHS, (_nest.__append__(_t)), (_path.__append__(_t)))) {
							return false;
						};
						_check._valids._add(_t);
					} else if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
						var _t:Ref<TypeParam> = __type__ == null ? (null : Ref<TypeParam>) : __type__.__underlying__() == null ? (null : Ref<TypeParam>) : __type__ == null ? (null : Ref<TypeParam>) : __type__.__underlying__()
							.value;
						if ((_nest.length) > (0 : GoInt)) {
							var _inst = _nest[((_nest.length) - (1 : GoInt) : GoInt)];
							for (_i => _tparam in _inst.typeParams()._list()) {
								if ((_t == _tparam) && (_i < _inst.typeArgs().len())) {
									var _targ:Type = _inst.typeArgs().at(_i);
									return _check._validType0(_targ, (_nest.__slice__(0, (_nest.length) - (1 : GoInt)) : Slice<Ref<Named>>), _path);
								};
							};
						};
					};
					break;
				};
			};
		};
		return true;
	}

	/**
		// validType verifies that the given type does not "expand" indefinitely
		// producing a cycle in the type graph.
		// (Cycles involving alias types, as in "type A = [10]A" are detected
		// earlier, via the objDecl cycle detection mechanism.)
	**/
	@:keep
	static public function _validType(_check:Ref<Checker>, _typ:Ref<Named>):Void {
		_check._validType0(Go.asInterface(_typ), (null : Slice<Ref<Named>>), (null : Slice<Ref<Named>>));
	}

	/**
		// typeList provides the list of types corresponding to the incoming expression list.
		// If an error occurred, the result is nil, but all list elements were type-checked.
	**/
	@:keep
	static public function _typeList(_check:Ref<Checker>, _list:Slice<stdgo.go.ast.Ast.Expr>):Slice<Type> {
		var _res = new Slice<Type>((_list.length : GoInt).toBasic(), 0, ...[for (i in 0...(_list.length : GoInt).toBasic()) (null : Type)]);
		for (_i => _x in _list) {
			var _t:Type = _check._varType(_x);
			if (Go.toInterface(_t) == (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
				_res = (null : Slice<Type>);
			};
			if (_res != null) {
				_res[(_i : GoInt)] = _t;
			};
		};
		return _res;
	}

	/**
		// arrayLength type-checks the array length expression e
		// and returns the constant length >= 0, or a value < 0
		// to indicate an error (and thus an unknown length).
	**/
	@:keep
	static public function _arrayLength(_check:Ref<Checker>, _e:stdgo.go.ast.Ast.Expr):GoInt64 {
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_e) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>), ok: true};
			} catch (_) {
				{value: (null : Ref<stdgo.go.ast.Ast.Ident>), ok: false};
			}, _name = __tmp__.value, _0 = __tmp__.ok;
			if (_name != null) {
				var _obj:Object = _check._lookup(_name.name);
				if (_obj == null) {
					_check._errorf(Go.asInterface(_name), (26 : T_errorCode), ("undeclared name %s for array length" : GoString), Go.toInterface(_name.name));
					return ("-1" : GoInt64);
				};
				{
					var __tmp__ = try {
						{value: (Go.typeAssert((Go.toInterface(_obj) : Ref<Const>)) : Ref<Const>), ok: true};
					} catch (_) {
						{value: (null : Ref<Const>), ok: false};
					}, _1 = __tmp__.value, _ok = __tmp__.ok;
					if (!_ok) {
						_check._errorf(Go.asInterface(_name), (26 : T_errorCode), ("invalid array length %s" : GoString), Go.toInterface(_name.name));
						return ("-1" : GoInt64);
					};
				};
			};
		};
		var _x:T_operand = ({} : T_operand);
		_check._expr((_x : Ref<T_operand>), _e);
		if (_x._mode != ((4 : T_operandMode))) {
			if (_x._mode != ((0 : T_operandMode))) {
				_check._errorf(Go.asInterface((_x : Ref<T_operand>)), (26 : T_errorCode), ("array length %s must be constant" : GoString),
					Go.toInterface(Go.asInterface((_x : Ref<T_operand>))));
			};
			return ("-1" : GoInt64);
		};
		if (_isUntyped(_x._typ) || _isInteger(_x._typ)) {
			{
				var _val:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.toInt(_x._val);
				if (_val.kind() == ((3 : stdgo.go.constant.Constant.Kind))) {
					if (_representableConst(_val, _check, typ[((2 : BasicKind) : GoInt)], (null : Ref<stdgo.go.constant.Constant.Value>))) {
						{
							var __tmp__ = stdgo.go.constant.Constant.int64Val(_val),
								_n:GoInt64 = __tmp__._0,
								_ok:Bool = __tmp__._1;
							if (_ok && (_n >= (("0" : GoInt64) : GoInt64))) {
								return _n;
							};
						};
						_check._errorf(Go.asInterface((_x : Ref<T_operand>)), (26 : T_errorCode), ("invalid array length %s" : GoString),
							Go.toInterface(Go.asInterface((_x : Ref<T_operand>))));
						return ("-1" : GoInt64);
					};
				};
			};
		};
		_check._errorf(Go.asInterface((_x : Ref<T_operand>)), (26 : T_errorCode), ("array length %s must be integer" : GoString),
			Go.toInterface(Go.asInterface((_x : Ref<T_operand>))));
		return ("-1" : GoInt64);
	}

	@:keep
	static public function _instantiatedType(_check:Ref<Checker>, _ix:Ref<go.internal.typeparams.Typeparams.IndexExpr>, _def:Ref<Named>):Type {
		var __deferstack__:Array<Void->Void> = [];
		var _res:Type = (null : Type);
		if (false) {
			_check._trace(_ix.pos(), ("-- instantiating type %s with %s" : GoString), Go.toInterface(_ix.indexListExpr.x),
				Go.toInterface(_ix.indexListExpr.indices));
			_check._indent++;
			__deferstack__.unshift(() -> {
				var a = function():Void {
					_check._indent--;
					_check._trace(_ix.pos(), ("=> %s" : GoString), Go.toInterface(_res));
				};
				a();
			});
		};
		try {
			var _reason:GoString = ("" : GoString);
			var _gtyp:Type = _check._genericType(_ix.indexListExpr.x, Go.pointer(_reason));
			if (_reason != (Go.str())) {
				_check._invalidOp(_ix.orig, (136 : T_errorCode), ("%s (%s)" : GoString), Go.toInterface(_ix.orig), Go.toInterface(_reason));
			};
			if (Go.toInterface(_gtyp) == (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
				{
					for (defer in __deferstack__) {
						defer();
					};
					return _gtyp;
				};
			};
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_gtyp) : Ref<Named>)) : Ref<Named>), ok: true};
			} catch (_) {
				{value: (null : Ref<Named>), ok: false};
			}, _orig = __tmp__.value, _2 = __tmp__.ok;
			if (_orig == null) {
				throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("%v: cannot instantiate %v" : GoString), Go.toInterface(Go.asInterface(_ix.pos())),
					Go.toInterface(_gtyp)));
			};
			var _targs = _check._typeList(_ix.indexListExpr.indices);
			if (_targs == null) {
				_def._setUnderlying(Go.asInterface(typ[((0 : BasicKind) : GoInt)]));
				{
					for (defer in __deferstack__) {
						defer();
					};
					return Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
				};
			};
			var _inst = (Go.typeAssert((Go.toInterface(_check._instance(_ix.pos(), Go.asInterface(_orig), _targs, null,
				_check._context())) : Ref<Named>)) : Ref<Named>);
			_def._setUnderlying(Go.asInterface(_inst));
			_check._later(function():Void {
				_check._recordInstance(_ix.orig, _inst.typeArgs()._list(), Go.asInterface(_inst));
				if (_check._validateTArgLen(_ix.pos(), _inst.typeParams().len(), _inst.typeArgs().len())) {
					{
						var __tmp__ = _check._verify(_ix.pos(), _inst.typeParams()._list(), _inst.typeArgs()._list(), _check._context()),
							_i:GoInt = __tmp__._0,
							_err:Error = __tmp__._1;
						if (_err != null) {
							var _pos:stdgo.go.token.Token.Pos = _ix.pos();
							if (_i < (_ix.indexListExpr.indices.length)) {
								_pos = _ix.indexListExpr.indices[(_i : GoInt)].pos();
							};
							_check._softErrorf(Go.asInterface((_pos : T_atPos)), (139 : T_errorCode), _err.error());
						} else {
							_check._mono._recordInstance(_check._pkg, _ix.pos(), _inst.typeParams()._list(), _inst.typeArgs()._list(),
								_ix.indexListExpr.indices);
						};
					};
				};
				_check._validType(_inst);
			})._describef(Go.asInterface(_ix), ("resolve instance %s" : GoString), Go.toInterface(Go.asInterface(_inst)));
			{
				for (defer in __deferstack__) {
					defer();
				};
				return Go.asInterface(_inst);
			};
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return _res;
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return _res;
		};
	}

	/**
		// typInternal drives type checking of types.
		// Must only be called by definedType or genericType.
	**/
	@:keep
	static public function _typInternal(_check:Ref<Checker>, _e0:stdgo.go.ast.Ast.Expr, _def:Ref<Named>):Type {
		var __deferstack__:Array<Void->Void> = [];
		var t:Type = (null : Type);
		if (false) {
			_check._trace(_e0.pos(), ("-- type %s" : GoString), Go.toInterface(_e0));
			_check._indent++;
			__deferstack__.unshift(() -> {
				var a = function():Void {
					_check._indent--;
					var _under:Type = (null : Type);
					if (t != null) {
						_under = _safeUnderlying(t);
					};
					if (Go.toInterface(t) == (Go.toInterface(_under))) {
						_check._trace(_e0.pos(), ("=> %s // %s" : GoString), Go.toInterface(t), Go.toInterface(_goTypeName(t)));
					} else {
						_check._trace(_e0.pos(), ("=> %s (under = %s) // %s" : GoString), Go.toInterface(t), Go.toInterface(_under),
							Go.toInterface(_goTypeName(t)));
					};
				};
				a();
			});
		};
		try {
			{
				final __type__ = _e0;
				if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BadExpr>))) {
					var _e:Ref<stdgo.go.ast.Ast.BadExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BadExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BadExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BadExpr>) : __type__.__underlying__()
						.value;
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ident>))) {
					var _e:Ref<stdgo.go.ast.Ast.Ident> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__()
						.value;
					var _x:T_operand = ({} : T_operand);
					_check._ident((_x : Ref<T_operand>), _e, _def, true);
					if (_x._mode == ((3 : T_operandMode))) {
						var _typ:Type = _x._typ;
						_def._setUnderlying(_typ);
						{
							for (defer in __deferstack__) {
								defer();
							};
							return _typ;
						};
					} else if (_x._mode == ((0 : T_operandMode))) {} else if (_x._mode == ((1 : T_operandMode))) {
						_check._errorf(Go.asInterface((_x : Ref<T_operand>)), (25 : T_errorCode), ("%s used as type" : GoString),
							Go.toInterface(Go.asInterface((_x : Ref<T_operand>))));
					} else {
						_check._errorf(Go.asInterface((_x : Ref<T_operand>)), (25 : T_errorCode), ("%s is not a type" : GoString),
							Go.toInterface(Go.asInterface((_x : Ref<T_operand>))));
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectorExpr>))) {
					var _e:Ref<stdgo.go.ast.Ast.SelectorExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__()
						.value;
					var _x:T_operand = ({} : T_operand);
					_check._selector((_x : Ref<T_operand>), _e, _def);
					if (_x._mode == ((3 : T_operandMode))) {
						var _typ:Type = _x._typ;
						_def._setUnderlying(_typ);
						{
							for (defer in __deferstack__) {
								defer();
							};
							return _typ;
						};
					} else if (_x._mode == ((0 : T_operandMode))) {} else if (_x._mode == ((1 : T_operandMode))) {
						_check._errorf(Go.asInterface((_x : Ref<T_operand>)), (25 : T_errorCode), ("%s used as type" : GoString),
							Go.toInterface(Go.asInterface((_x : Ref<T_operand>))));
					} else {
						_check._errorf(Go.asInterface((_x : Ref<T_operand>)), (25 : T_errorCode), ("%s is not a type" : GoString),
							Go.toInterface(Go.asInterface((_x : Ref<T_operand>))));
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexExpr>))
					|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexListExpr>))) {
					var _e:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
					var _ix = go.internal.typeparams.Typeparams.unpackIndexExpr(_e);
					if (!_check._allowVersion(_check._pkg, (1 : GoInt), (18 : GoInt))) {
						_check._softErrorf(Go.asInterface(_inNode(_e, _ix.indexListExpr.lbrack)), (135 : T_errorCode),
							("type instantiation requires go1.18 or later" : GoString));
					};
					{
						for (defer in __deferstack__) {
							defer();
						};
						return _check._instantiatedType(_ix, _def);
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ParenExpr>))) {
					var _e:Ref<stdgo.go.ast.Ast.ParenExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__()
						.value;
					{
						for (defer in __deferstack__) {
							defer();
						};
						return _check._definedType(_e.x, _def);
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ArrayType>))) {
					var _e:Ref<stdgo.go.ast.Ast.ArrayType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ArrayType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ArrayType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ArrayType>) : __type__.__underlying__()
						.value;
					if (_e.len == null) {
						var _typ = ({} : Slice_);
						_def._setUnderlying(Go.asInterface(_typ));
						_typ._elem = _check._varType(_e.elt);
						{
							for (defer in __deferstack__) {
								defer();
							};
							return Go.asInterface(_typ);
						};
					};
					var _typ = ({} : Array_);
					_def._setUnderlying(Go.asInterface(_typ));
					_typ._len = _check._arrayLength(_e.len);
					_typ._elem = _check._varType(_e.elt);
					if (_typ._len >= ("0" : GoInt64)) {
						{
							for (defer in __deferstack__) {
								defer();
							};
							return Go.asInterface(_typ);
						};
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ellipsis>))) {
					var _e:Ref<stdgo.go.ast.Ast.Ellipsis> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__.__underlying__()
						.value;
					_check._error(Go.asInterface(_e), (81 : T_errorCode), ("invalid use of \'...\'" : GoString));
					_check._use(_e.elt);
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.StructType>))) {
					var _e:Ref<stdgo.go.ast.Ast.StructType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StructType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.StructType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StructType>) : __type__.__underlying__()
						.value;
					var _typ = ({} : Struct);
					_def._setUnderlying(Go.asInterface(_typ));
					_check._structType(_typ, _e);
					{
						for (defer in __deferstack__) {
							defer();
						};
						return Go.asInterface(_typ);
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.StarExpr>))) {
					var _e:Ref<stdgo.go.ast.Ast.StarExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__()
						.value;
					var _typ = ({} : Pointer_);
					_typ._base = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
					_def._setUnderlying(Go.asInterface(_typ));
					_typ._base = _check._varType(_e.x);
					{
						for (defer in __deferstack__) {
							defer();
						};
						return Go.asInterface(_typ);
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.FuncType>))) {
					var _e:Ref<stdgo.go.ast.Ast.FuncType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.FuncType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.FuncType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.FuncType>) : __type__.__underlying__()
						.value;
					var _typ = ({} : Signature);
					_def._setUnderlying(Go.asInterface(_typ));
					_check._funcType(_typ, null, _e);
					{
						for (defer in __deferstack__) {
							defer();
						};
						return Go.asInterface(_typ);
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.InterfaceType>))) {
					var _e:Ref<stdgo.go.ast.Ast.InterfaceType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.InterfaceType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.InterfaceType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.InterfaceType>) : __type__.__underlying__()
						.value;
					var _typ = _check._newInterface();
					_def._setUnderlying(Go.asInterface(_typ));
					_check._interfaceType(_typ, _e, _def);
					{
						for (defer in __deferstack__) {
							defer();
						};
						return Go.asInterface(_typ);
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.MapType>))) {
					var _e:Ref<stdgo.go.ast.Ast.MapType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.MapType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.MapType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.MapType>) : __type__.__underlying__()
						.value;
					var _typ = ({} : Map_);
					_def._setUnderlying(Go.asInterface(_typ));
					_typ._key = _check._varType(_e.key);
					_typ._elem = _check._varType(_e.value);
					_check._later(function():Void {
						if (!comparable(_typ._key)) {
							var _why:GoString = ("" : GoString);
							if (_isTypeParam(_typ._key)) {
								_why = (" (missing comparable constraint)" : GoString);
							};
							_check._errorf(_e.key, (28 : T_errorCode), ("incomparable map key type %s%s" : GoString), Go.toInterface(_typ._key),
								Go.toInterface(_why));
						};
					})._describef(_e.key, ("check map key %s" : GoString), Go.toInterface(_typ._key));
					{
						for (defer in __deferstack__) {
							defer();
						};
						return Go.asInterface(_typ);
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ChanType>))) {
					var _e:Ref<stdgo.go.ast.Ast.ChanType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ChanType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ChanType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ChanType>) : __type__.__underlying__()
						.value;
					var _typ = ({} : Chan);
					_def._setUnderlying(Go.asInterface(_typ));
					var _dir:ChanDir = (0 : ChanDir);
					if (_e.dir == ((3 : stdgo.go.ast.Ast.ChanDir))) {} else if (_e.dir == ((1 : stdgo.go.ast.Ast.ChanDir))) {
						_dir = (1 : ChanDir);
					} else if (_e.dir == ((2 : stdgo.go.ast.Ast.ChanDir))) {
						_dir = (2 : ChanDir);
					} else {
						_check._invalidAST(Go.asInterface(_e), ("unknown channel direction %d" : GoString), Go.toInterface(_e.dir));
					};
					_typ._dir = _dir;
					_typ._elem = _check._varType(_e.value);
					{
						for (defer in __deferstack__) {
							defer();
						};
						return Go.asInterface(_typ);
					};
				} else {
					var _e:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
					_check._errorf(_e0, (25 : T_errorCode), ("%s is not a type" : GoString), Go.toInterface(_e0));
				};
			};
			var _typ = typ[((0 : BasicKind) : GoInt)];
			_def._setUnderlying(Go.asInterface(_typ));
			{
				for (defer in __deferstack__) {
					defer();
				};
				return Go.asInterface(_typ);
			};
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return t;
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return t;
		};
	}

	/**
		// genericType is like typ but the type must be an (uninstantiated) generic
		// type. If reason is non-nil and the type expression was a valid type but not
		// generic, reason will be populated with a message describing the error.
	**/
	@:keep
	static public function _genericType(_check:Ref<Checker>, _e:stdgo.go.ast.Ast.Expr, _reason:Pointer<GoString>):Type {
		var _typ:Type = _check._typInternal(_e, null);
		_assert(_isTyped(_typ));
		if ((Go.toInterface(_typ) != Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)]))) && !_isGeneric(_typ)) {
			if (_reason != null) {
				_reason.value = _check._sprintf(("%s is not a generic type" : GoString), Go.toInterface(_typ));
			};
			_typ = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
		};
		_check._recordTypeAndValue(_e, (3 : T_operandMode), _typ, (null : stdgo.go.constant.Constant.Value));
		return _typ;
	}

	/**
		// definedType is like typ but also accepts a type name def.
		// If def != nil, e is the type specification for the defined type def, declared
		// in a type declaration, and def.underlying will be set to the type of e before
		// any components of e are type-checked.
	**/
	@:keep
	static public function _definedType(_check:Ref<Checker>, _e:stdgo.go.ast.Ast.Expr, _def:Ref<Named>):Type {
		var _typ:Type = _check._typInternal(_e, _def);
		_assert(_isTyped(_typ));
		if (_isGeneric(_typ)) {
			_check._errorf(_e, (137 : T_errorCode), ("cannot use generic type %s without instantiation" : GoString), Go.toInterface(_typ));
			_typ = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
		};
		_check._recordTypeAndValue(_e, (3 : T_operandMode), _typ, (null : stdgo.go.constant.Constant.Value));
		return _typ;
	}

	/**
		// validVarType reports an error if typ is a constraint interface.
		// The expression e is used for error reporting, if any.
	**/
	@:keep
	static public function _validVarType(_check:Ref<Checker>, _e:stdgo.go.ast.Ast.Expr, _typ:Type):Void {
		if (_isTypeParam(_typ)) {
			return;
		};
		_check._later(function():Void {
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Interface>)) : Ref<Interface>), ok: true};
				} catch (_) {
					{value: (null : Ref<Interface>), ok: false};
				}, _t = __tmp__.value, _0 = __tmp__.ok;
				if (_t != null) {
					var _tset = _computeInterfaceTypeSet(_check, _e.pos(), _t);
					if (!_tset.isMethodSet()) {
						if (_tset._comparable) {
							_check._softErrorf(_e, (142 : T_errorCode),
								("cannot use type %s outside a type constraint: interface is (or embeds) comparable" : GoString), Go.toInterface(_typ));
						} else {
							_check._softErrorf(_e, (142 : T_errorCode),
								("cannot use type %s outside a type constraint: interface contains type constraints" : GoString), Go.toInterface(_typ));
						};
					};
				};
			};
		})._describef(_e, ("check var type %s" : GoString), Go.toInterface(_typ));
	}

	/**
		// varType type-checks the type expression e and returns its type, or Typ[Invalid].
		// The type must not be an (uninstantiated) generic type and it must not be a
		// constraint interface.
	**/
	@:keep
	static public function _varType(_check:Ref<Checker>, _e:stdgo.go.ast.Ast.Expr):Type {
		var _typ:Type = _check._definedType(_e, null);
		_check._validVarType(_e, _typ);
		return _typ;
	}

	/**
		// typ type-checks the type expression e and returns its type, or Typ[Invalid].
		// The type must not be an (uninstantiated) generic type.
	**/
	@:keep
	static public function _typ(_check:Ref<Checker>, _e:stdgo.go.ast.Ast.Expr):Type {
		return _check._definedType(_e, null);
	}

	/**
		// ident type-checks identifier e and initializes x with the value or type of e.
		// If an error occurred, x.mode is set to invalid.
		// For the meaning of def, see Checker.definedType, below.
		// If wantType is set, the identifier e is expected to denote a type.
	**/
	@:keep
	static public function _ident(_check:Ref<Checker>, _x:Ref<T_operand>, _e:Ref<stdgo.go.ast.Ast.Ident>, _def:Ref<Named>, _wantType:Bool):Void {
		_x._mode = (0 : T_operandMode);
		_x._expr = Go.asInterface(_e);
		var __tmp__ = _check._pkg._scope.lookupParent(_e.name, _check._pkg._scope._pos),
			_scope:Ref<Scope> = __tmp__._0,
			_obj:Object = __tmp__._1;
		if (_obj == null) {
			if (_e.name == (("_" : GoString))) {
				{
					var _tpar = _check._recvTParamMap[_e];
					if (_tpar != null) {
						_x._mode = (3 : T_operandMode);
						_x._typ = Go.asInterface(_tpar);
					} else {
						_check._error(Go.asInterface(_e), (35 : T_errorCode), ("cannot use _ as value or type" : GoString));
					};
				};
			} else {
				_check._errorf(Go.asInterface(_e), (75 : T_errorCode), ("undeclared name: %s" : GoString), Go.toInterface(_e.name));
			};
			return;
		} else if (Go.toInterface(_obj) == (Go.toInterface(_universeAny))
			|| Go.toInterface(_obj) == (Go.toInterface(_universeComparable))) {
			if (!_check._allowVersion(_check._pkg, (1 : GoInt), (18 : GoInt))) {
				_check._versionErrorf(Go.asInterface(_e), (75 : T_errorCode), ("go1.18" : GoString), ("predeclared %s" : GoString), Go.toInterface(_e.name));
				return;
			};
		};
		_check._recordUse(_e, _obj);
		var _typ:Type = _obj.type();
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_obj) : Ref<TypeName>)) : Ref<TypeName>), ok: true};
			} catch (_) {
				{value: (null : Ref<TypeName>), ok: false};
			}, _8 = __tmp__.value, _gotType = __tmp__.ok;
			if ((_typ == null) || (_gotType && _wantType)) {
				_check._objDecl(_obj, _def);
				_typ = _obj.type();
			};
		};
		_assert(_typ != null);
		{
			var _pkgName = _check._dotImportMap[(new T_dotImportKey(_scope, _obj.name()) : T_dotImportKey)];
			if (_pkgName != null) {
				_pkgName._used = true;
			};
		};
		{
			final __type__ = _obj;
			if (Go.typeEquals((__type__ : Ref<PkgName>))) {
				var _obj:Ref<PkgName> = __type__ == null ? (null : Ref<PkgName>) : __type__.__underlying__() == null ? (null : Ref<PkgName>) : __type__ == null ? (null : Ref<PkgName>) : __type__.__underlying__()
					.value;
				_check._errorf(Go.asInterface(_e), (4 : T_errorCode), ("use of package %s not in selector" : GoString), Go.toInterface(_obj._object._name));
				return;
			} else if (Go.typeEquals((__type__ : Ref<Const>))) {
				var _obj:Ref<Const> = __type__ == null ? (null : Ref<Const>) : __type__.__underlying__() == null ? (null : Ref<Const>) : __type__ == null ? (null : Ref<Const>) : __type__.__underlying__()
					.value;
				_check._addDeclDep(Go.asInterface(_obj));
				if (Go.toInterface(_typ) == (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
					return;
				};
				if (Go.toInterface(Go.asInterface(_obj)) == (Go.toInterface(_universeIota))) {
					if (_check._environment._iota == null) {
						_check._errorf(Go.asInterface(_e), (36 : T_errorCode), ("cannot use iota outside constant declaration" : GoString));
						return;
					};
					_x._val = _check._environment._iota;
				} else {
					_x._val = _obj._val;
				};
				_assert(_x._val != null);
				_x._mode = (4 : T_operandMode);
			} else if (Go.typeEquals((__type__ : Ref<TypeName>))) {
				var _obj:Ref<TypeName> = __type__ == null ? (null : Ref<TypeName>) : __type__.__underlying__() == null ? (null : Ref<TypeName>) : __type__ == null ? (null : Ref<TypeName>) : __type__.__underlying__()
					.value;
				if (_check._isBrokenAlias(_obj)) {
					_check._errorf(Go.asInterface(_e), (11 : T_errorCode), ("invalid use of type alias %s in recursive type (see issue #50729)" : GoString),
						Go.toInterface(_obj._object._name));
					return;
				};
				_x._mode = (3 : T_operandMode);
			} else if (Go.typeEquals((__type__ : Ref<Var>))) {
				var _obj:Ref<Var> = __type__ == null ? (null : Ref<Var>) : __type__.__underlying__() == null ? (null : Ref<Var>) : __type__ == null ? (null : Ref<Var>) : __type__.__underlying__()
					.value;
				if (_obj._object._pkg == (_check._pkg)) {
					_obj._used = true;
				};
				_check._addDeclDep(Go.asInterface(_obj));
				if (Go.toInterface(_typ) == (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
					return;
				};
				_x._mode = (5 : T_operandMode);
			} else if (Go.typeEquals((__type__ : Ref<Func>))) {
				var _obj:Ref<Func> = __type__ == null ? (null : Ref<Func>) : __type__.__underlying__() == null ? (null : Ref<Func>) : __type__ == null ? (null : Ref<Func>) : __type__.__underlying__()
					.value;
				_check._addDeclDep(Go.asInterface(_obj));
				_x._mode = (7 : T_operandMode);
			} else if (Go.typeEquals((__type__ : Ref<Builtin>))) {
				var _obj:Ref<Builtin> = __type__ == null ? (null : Ref<Builtin>) : __type__.__underlying__() == null ? (null : Ref<Builtin>) : __type__ == null ? (null : Ref<Builtin>) : __type__.__underlying__()
					.value;
				_x._id = _obj._id;
				_x._mode = (2 : T_operandMode);
			} else if (Go.typeEquals((__type__ : Ref<Nil>))) {
				var _obj:Ref<Nil> = __type__ == null ? (null : Ref<Nil>) : __type__.__underlying__() == null ? (null : Ref<Nil>) : __type__ == null ? (null : Ref<Nil>) : __type__.__underlying__()
					.value;
				_x._mode = (7 : T_operandMode);
			} else {
				var _obj:Object = __type__ == null ? (null : Object) : cast __type__;
				_unreachable();
			};
		};
		_x._typ = _typ;
	}

	/**
		// check may be nil
	**/
	@:keep
	static public function _newTypeParam(_check:Ref<Checker>, _obj:Ref<TypeName>, _constraint:Type):Ref<TypeParam> {
		var _id:GoUInt64 = _nextID();
		if (_check != null) {
			_check._nextID++;
			_id = _check._nextID;
		};
		var _typ = (({
			_check: _check,
			_id: _id,
			_obj: _obj,
			_index: (-1 : GoInt),
			_bound: _constraint
		} : TypeParam) : Ref<TypeParam>);
		if (_obj._object._typ == null) {
			_obj._object._typ = Go.asInterface(_typ);
		};
		if (_check != null) {
			_check._needsCleanup(Go.asInterface(_typ));
		} else if (_constraint != null) {
			_typ._iface();
		};
		return _typ;
	}

	/**
		// subst returns the type typ with its type parameters tpars replaced by the
		// corresponding type arguments targs, recursively. subst is pure in the sense
		// that it doesn't modify the incoming type. If a substitution took place, the
		// result type is different from the incoming type.
		//
		// If expanding is non-nil, it is the instance type currently being expanded.
		// One of expanding or ctxt must be non-nil.
	**/
	@:keep
	static public function _subst(_check:Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _typ:Type, _smap:T_substMap, _expanding:Ref<Named>,
			_ctxt:Ref<Context>):Type {
		_assert((_expanding != null) || (_ctxt != null));
		if (_smap._empty()) {
			return _typ;
		};
		{
			final __type__ = _typ;
			if (Go.typeEquals((__type__ : Ref<Basic>))) {
				var _t:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
					.value;
				return _typ;
			} else if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
				var _t:Ref<TypeParam> = __type__ == null ? (null : Ref<TypeParam>) : __type__.__underlying__() == null ? (null : Ref<TypeParam>) : __type__ == null ? (null : Ref<TypeParam>) : __type__.__underlying__()
					.value;
				return _smap._lookup(_t);
			};
		};
		var _subst:T_subster = ({
			_pos: _pos,
			_smap: _smap,
			_check: _check,
			_expanding: _expanding,
			_ctxt: _ctxt
		} : T_subster);
		return _subst._typ(_typ);
	}

	@:keep
	static public function _tag(_check:Ref<Checker>, _t:Ref<stdgo.go.ast.Ast.BasicLit>):GoString {
		if (_t != null) {
			if (_t.kind == ((9 : stdgo.go.token.Token.Token))) {
				{
					var __tmp__ = stdgo.strconv.Strconv.unquote(_t.value),
						_val:GoString = __tmp__._0,
						_err:Error = __tmp__._1;
					if (_err == null) {
						return _val;
					};
				};
			};
			_check._invalidAST(Go.asInterface(_t), ("incorrect tag syntax: %q" : GoString), Go.toInterface(_t.value));
		};
		return Go.str();
	}

	@:keep
	static public function _declareInSet(_check:Ref<Checker>, _oset:Ref<T_objset>, _pos:stdgo.go.token.Token.Pos, _obj:Object):Bool {
		{
			var _alt:Object = _oset._insert(_obj);
			if (_alt != null) {
				_check._errorf(Go.asInterface((_pos : T_atPos)), (10 : T_errorCode), ("%s redeclared" : GoString), Go.toInterface(_obj.name()));
				_check._reportAltDecl(_alt);
				return false;
			};
		};
		return true;
	}

	@:keep
	static public function _structType(_check:Ref<Checker>, _styp:Ref<Struct>, _e:Ref<stdgo.go.ast.Ast.StructType>):Void {
		var _list = _e.fields;
		if (_list == null) {
			_styp._markComplete();
			return;
		};
		var _fields:Slice<Ref<Var>> = (null : Slice<Ref<Var>>);
		var _tags:Slice<GoString> = (null : Slice<GoString>);
		var _fset:T_objset = (null : T_objset);
		var _typ:Type = (null : Type);
		var _tag:GoString = ("" : GoString);
		var _add = function(_ident:Ref<stdgo.go.ast.Ast.Ident>, _embedded:Bool, _pos:stdgo.go.token.Token.Pos):Void {
			if ((_tag != Go.str()) && (_tags == null)) {
				_tags = new Slice<GoString>((_fields.length : GoInt).toBasic(), 0, ...[for (i in 0...(_fields.length : GoInt).toBasic()) ("" : GoString)]);
			};
			if (_tags != null) {
				_tags = _tags.__appendref__(_tag);
			};
			var _name:GoString = _ident.name;
			var _fld = newField(_pos, _check._pkg, _name, _typ, _embedded);
			if ((_name == ("_" : GoString)) || _check._declareInSet((_fset : Ref<T_objset>), _pos, Go.asInterface(_fld))) {
				_fields = _fields.__appendref__(_fld);
				_check._recordDef(_ident, Go.asInterface(_fld));
			};
		};
		var _addInvalid = function(_ident:Ref<stdgo.go.ast.Ast.Ident>, _pos:stdgo.go.token.Token.Pos):Void {
			_typ = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
			_tag = Go.str();
			_add(_ident, true, _pos);
		};
		for (_0 => _f in _list.list) {
			_typ = _check._varType(_f.type);
			_tag = _check._tag(_f.tag);
			if ((_f.names.length) > (0 : GoInt)) {
				for (_1 => _name in _f.names) {
					_add(_name, false, _name.pos());
				};
			} else {
				var _pos:stdgo.go.token.Token.Pos = _f.type.pos();
				var _name = _embeddedFieldIdent(_f.type);
				if (_name == null) {
					_check._invalidAST(_f.type, ("embedded field type %s has no name" : GoString), Go.toInterface(_f.type));
					_name = stdgo.go.ast.Ast.newIdent(("_" : GoString));
					_name.namePos = _pos;
					_addInvalid(_name, _pos);
					continue;
				};
				_add(_name, true, _pos);
				var _embeddedTyp:Type = _typ;
				var _embeddedPos:stdgo.go.ast.Ast.Expr = _f.type;
				_check._later(function():Void {
					var __tmp__ = _deref(_embeddedTyp),
						_t:Type = __tmp__._0,
						_isPtr:Bool = __tmp__._1;
					{
						final __type__ = _under(_t);
						{
							var __bool__ = true;
							while (__bool__) {
								__bool__ = false;
								if (Go.typeEquals((__type__ : Ref<Basic>))) {
									var _u:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
										.value;
									if (Go.toInterface(_t) == (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
										return;
									};
									if (_u._kind == ((18 : BasicKind))) {
										_check._error(_embeddedPos, (30 : T_errorCode), ("embedded field type cannot be unsafe.Pointer" : GoString));
									};
								} else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
									var _u:Ref<Pointer_> = __type__ == null ? (null : Ref<Pointer_>) : __type__.__underlying__() == null ? (null : Ref<Pointer_>) : __type__ == null ? (null : Ref<Pointer_>) : __type__.__underlying__()
										.value;
									_check._error(_embeddedPos, (30 : T_errorCode), ("embedded field type cannot be a pointer" : GoString));
								} else if (Go.typeEquals((__type__ : Ref<Interface>))) {
									var _u:Ref<Interface> = __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__() == null ? (null : Ref<Interface>) : __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__()
										.value;
									if (_isTypeParam(_t)) {
										_check._error(_embeddedPos, (144 : T_errorCode),
											("embedded field type cannot be a (pointer to a) type parameter" : GoString));
										break;
									};
									if (_isPtr) {
										_check._error(_embeddedPos, (30 : T_errorCode),
											("embedded field type cannot be a pointer to an interface" : GoString));
									};
								};
								break;
							};
						};
					};
				})._describef(_embeddedPos, ("check embedded type %s" : GoString), Go.toInterface(_embeddedTyp));
			};
		};
		_styp._fields = _fields;
		_styp._tags = _tags;
		_styp._markComplete();
	}

	/**
		// stmt typechecks statement s.
	**/
	@:keep
	static public function _stmt(_check:Ref<Checker>, _ctxt:T_stmtContext, _s:stdgo.go.ast.Ast.Stmt):Void {
		var __deferstack__:Array<Void->Void> = [];
		if (false) {
			{
				var _a0 = _check._pkg._scope;
				__deferstack__.unshift(() -> {
					var a = function(_scope:Ref<Scope>):Void {
						{
							var _p:AnyInterface = ({
								final r = Go.recover_exception;
								Go.recover_exception = null;
								r;
							});
							if (_p != null) {
								throw Go.toInterface(_p);
							};
						};
						_assert(_scope == (_check._pkg._scope));
					};
					a(_a0);
				});
			};
		};
		try {
			{
				var _a0 = (_check._delayed.length);
				__deferstack__.unshift(() -> _check._processDelayed(_a0));
			};
			var _inner:T_stmtContext = _ctxt & ((("28" : GoUInt) : T_stmtContext) ^ (-1 : GoInt));
			{
				final __type__ = _s;
				if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BadStmt>))
					|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.EmptyStmt>))) {
					var _s:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.DeclStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.DeclStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.DeclStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.DeclStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.DeclStmt>) : __type__.__underlying__()
						.value;
					_check._declStmt(_s.decl);
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.LabeledStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.LabeledStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__()
						.value;
					_check._environment._hasLabel = true;
					_check._stmt(_ctxt, _s.stmt);
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ExprStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.ExprStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__()
						.value;
					var _x:T_operand = ({} : T_operand);
					var _kind:T_exprKind = _check._rawExpr((_x : Ref<T_operand>), _s.x, (null : Type), false);
					var _msg:GoString = ("" : GoString);
					var _code:T_errorCode = ((0 : GoInt) : T_errorCode);
					if (_x._mode == ((2 : T_operandMode))) {
						_msg = ("must be called" : GoString);
						_code = (82 : T_errorCode);
					} else if (_x._mode == ((3 : T_operandMode))) {
						_msg = ("is not an expression" : GoString);
						_code = (42 : T_errorCode);
					};
					_check._errorf(Go.asInterface((_x : Ref<T_operand>)), _code, ("%s %s" : GoString), Go.toInterface(Go.asInterface((_x : Ref<T_operand>))),
						Go.toInterface(_msg));
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SendStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.SendStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SendStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SendStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SendStmt>) : __type__.__underlying__()
						.value;
					var _0:T_operand = ({} : T_operand),
						_1:T_operand = ({} : T_operand),
						_val:T_operand = _1,
						_ch:T_operand = _0;
					_check._expr((_ch : Ref<T_operand>), _s.chan);
					_check._expr((_val : Ref<T_operand>), _s.value);
					if ((_ch._mode == (0 : T_operandMode)) || (_val._mode == (0 : T_operandMode))) {
						{
							for (defer in __deferstack__) {
								defer();
							};
							return;
						};
					};
					var _u:Type = _coreType(_ch._typ);
					if (_u == null) {
						_check._invalidOp(Go.asInterface(_inNode(Go.asInterface(_s), _s.arrow)), (59 : T_errorCode),
							("cannot send to %s: no core type" : GoString), Go.toInterface(Go.asInterface((_ch : Ref<T_operand>))));
						{
							for (defer in __deferstack__) {
								defer();
							};
							return;
						};
					};
					var __tmp__ = try {
						{value: (Go.typeAssert((Go.toInterface(_u) : Ref<Chan>)) : Ref<Chan>), ok: true};
					} catch (_) {
						{value: (null : Ref<Chan>), ok: false};
					}, _uch = __tmp__.value, _6 = __tmp__.ok;
					if (_uch == null) {
						_check._invalidOp(Go.asInterface(_inNode(Go.asInterface(_s), _s.arrow)), (59 : T_errorCode),
							("cannot send to non-channel %s" : GoString), Go.toInterface(Go.asInterface((_ch : Ref<T_operand>))));
						{
							for (defer in __deferstack__) {
								defer();
							};
							return;
						};
					};
					if (_uch._dir == ((2 : ChanDir))) {
						_check._invalidOp(Go.asInterface(_inNode(Go.asInterface(_s), _s.arrow)), (59 : T_errorCode),
							("cannot send to receive-only channel %s" : GoString), Go.toInterface(Go.asInterface((_ch : Ref<T_operand>))));
						{
							for (defer in __deferstack__) {
								defer();
							};
							return;
						};
					};
					_check._assignment((_val : Ref<T_operand>), _uch._elem, ("send" : GoString));
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IncDecStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.IncDecStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IncDecStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.IncDecStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IncDecStmt>) : __type__.__underlying__()
						.value;
					var _op:stdgo.go.token.Token.Token = ((0 : GoInt) : stdgo.go.token.Token.Token);
					if (_s.tok == ((37 : stdgo.go.token.Token.Token))) {
						_op = (12 : stdgo.go.token.Token.Token);
					} else if (_s.tok == ((38 : stdgo.go.token.Token.Token))) {
						_op = (13 : stdgo.go.token.Token.Token);
					} else {
						_check._invalidAST(Go.asInterface(_inNode(Go.asInterface(_s), _s.tokPos)), ("unknown inc/dec operation %s" : GoString),
							Go.toInterface(Go.asInterface(_s.tok)));
						{
							for (defer in __deferstack__) {
								defer();
							};
							return;
						};
					};
					var _x:T_operand = ({} : T_operand);
					_check._expr((_x : Ref<T_operand>), _s.x);
					if (_x._mode == ((0 : T_operandMode))) {
						{
							for (defer in __deferstack__) {
								defer();
							};
							return;
						};
					};
					if (!_allNumeric(_x._typ)) {
						_check._invalidOp(_s.x, (48 : T_errorCode), ("%s%s (non-numeric type %s)" : GoString), Go.toInterface(_s.x),
							Go.toInterface(Go.asInterface(_s.tok)), Go.toInterface(_x._typ));
						{
							for (defer in __deferstack__) {
								defer();
							};
							return;
						};
					};
					var y = (({valuePos: _s.x.pos(), kind: (5 : stdgo.go.token.Token.Token),
						value: ("1" : GoString)} : stdgo.go.ast.Ast.BasicLit) : Ref<stdgo.go.ast.Ast.BasicLit>);
					_check._binary((_x : Ref<T_operand>), (null : stdgo.go.ast.Ast.Expr), _s.x, Go.asInterface(y), _op, _s.tokPos);
					if (_x._mode == ((0 : T_operandMode))) {
						{
							for (defer in __deferstack__) {
								defer();
							};
							return;
						};
					};
					_check._assignVar(_s.x, (_x : Ref<T_operand>));
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.AssignStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.AssignStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__()
						.value;
					if (_s.tok == ((42 : stdgo.go.token.Token.Token)) || _s.tok == ((47 : stdgo.go.token.Token.Token))) {
						if ((_s.lhs.length) == ((0 : GoInt))) {
							_check._invalidAST(Go.asInterface(_s), ("missing lhs in assignment" : GoString));
							{
								for (defer in __deferstack__) {
									defer();
								};
								return;
							};
						};
						if (_s.tok == ((47 : stdgo.go.token.Token.Token))) {
							_check._shortVarDecl(Go.asInterface(_inNode(Go.asInterface(_s), _s.tokPos)), _s.lhs, _s.rhs);
						} else {
							_check._assignVars(_s.lhs, _s.rhs);
						};
					} else {
						if ((_s.lhs.length != (1 : GoInt)) || (_s.rhs.length != (1 : GoInt))) {
							_check._errorf(Go.asInterface(_inNode(Go.asInterface(_s), _s.tokPos)), (20 : T_errorCode),
								("assignment operation %s requires single-valued expressions" : GoString), Go.toInterface(Go.asInterface(_s.tok)));
							{
								for (defer in __deferstack__) {
									defer();
								};
								return;
							};
						};
						var _op:stdgo.go.token.Token.Token = _assignOp(_s.tok);
						if (_op == ((0 : stdgo.go.token.Token.Token))) {
							_check._invalidAST(Go.asInterface((_s.tokPos : T_atPos)), ("unknown assignment operation %s" : GoString),
								Go.toInterface(Go.asInterface(_s.tok)));
							{
								for (defer in __deferstack__) {
									defer();
								};
								return;
							};
						};
						var _x:T_operand = ({} : T_operand);
						_check._binary((_x : Ref<T_operand>), (null : stdgo.go.ast.Ast.Expr), _s.lhs[(0 : GoInt)], _s.rhs[(0 : GoInt)], _op, _s.tokPos);
						if (_x._mode == ((0 : T_operandMode))) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return;
							};
						};
						_check._assignVar(_s.lhs[(0 : GoInt)], (_x : Ref<T_operand>));
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.GoStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.GoStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.GoStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.GoStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.GoStmt>) : __type__.__underlying__()
						.value;
					_check._suspendedCall(("go" : GoString), _s.call);
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.DeferStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.DeferStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.DeferStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.DeferStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.DeferStmt>) : __type__.__underlying__()
						.value;
					_check._suspendedCall(("defer" : GoString), _s.call);
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ReturnStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.ReturnStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ReturnStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ReturnStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ReturnStmt>) : __type__.__underlying__()
						.value;
					var _res = _check._environment._sig._results;
					if (((_s.results.length == (0 : GoInt)) && (_res.len() > (0 : GoInt)))
						&& (_res._vars[(0 : GoInt)]._object._name != Go.str())) {
						for (_9 => _obj in _res._vars) {
							{
								var _alt:Object = _check._lookup(_obj._object._name);
								if ((_alt != null) && (Go.toInterface(_alt) != Go.toInterface(Go.asInterface(_obj)))) {
									_check._errorf(Go.asInterface(_s), (104 : T_errorCode), ("result parameter %s not in scope at return" : GoString),
										Go.toInterface(_obj._object._name));
									_check._errorf(_alt, (104 : T_errorCode), ("\tinner declaration of %s" : GoString), Go.toInterface(Go.asInterface(_obj)));
								};
							};
						};
					} else {
						var _lhs:Slice<Ref<Var>> = (null : Slice<Ref<Var>>);
						if (_res.len() > (0 : GoInt)) {
							_lhs = _res._vars;
						};
						_check._initVars(_lhs, _s.results, Go.asInterface(_s));
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BranchStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.BranchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__()
						.value;
					if (_s.label != null) {
						_check._environment._hasLabel = true;
						{
							for (defer in __deferstack__) {
								defer();
							};
							return;
						};
					};
					if (_s.tok == ((61 : stdgo.go.token.Token.Token))) {
						if (_ctxt & (("1" : GoUInt) : T_stmtContext) == ((("0" : GoUInt) : T_stmtContext))) {
							_check._error(Go.asInterface(_s), (110 : T_errorCode), ("break not in for, switch, or select statement" : GoString));
						};
					} else if (_s.tok == ((65 : stdgo.go.token.Token.Token))) {
						if (_ctxt & (("2" : GoUInt) : T_stmtContext) == ((("0" : GoUInt) : T_stmtContext))) {
							_check._error(Go.asInterface(_s), (111 : T_errorCode), ("continue not in for statement" : GoString));
						};
					} else if (_s.tok == ((69 : stdgo.go.token.Token.Token))) {
						if (_ctxt & (("4" : GoUInt) : T_stmtContext) == ((("0" : GoUInt) : T_stmtContext))) {
							var _msg:GoString = ("" : GoString);
							if (_ctxt & (("8" : GoUInt) : T_stmtContext) != ((("0" : GoUInt) : T_stmtContext))) {
								_msg = ("cannot fallthrough final case in switch" : GoString);
							} else if (_ctxt & (("16" : GoUInt) : T_stmtContext) != ((("0" : GoUInt) : T_stmtContext))) {
								_msg = ("cannot fallthrough in type switch" : GoString);
							} else {
								_msg = ("fallthrough statement out of place" : GoString);
							};
							_check._error(Go.asInterface(_s), (112 : T_errorCode), _msg);
						};
					} else {
						_check._invalidAST(Go.asInterface(_s), ("branch statement: %s" : GoString), Go.toInterface(Go.asInterface(_s.tok)));
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BlockStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.BlockStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__()
						.value;
					_check._openScope(Go.asInterface(_s), ("block" : GoString));
					__deferstack__.unshift(() -> _check._closeScope());
					_check._stmtList(_inner, _s.list);
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IfStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.IfStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__()
						.value;
					_check._openScope(Go.asInterface(_s), ("if" : GoString));
					__deferstack__.unshift(() -> _check._closeScope());
					_check._simpleStmt(_s.init);
					var _x:T_operand = ({} : T_operand);
					_check._expr((_x : Ref<T_operand>), _s.cond);
					if ((_x._mode != (0 : T_operandMode)) && !_allBoolean(_x._typ)) {
						_check._error(_s.cond, (105 : T_errorCode), ("non-boolean condition in if statement" : GoString));
					};
					_check._stmt(_inner, Go.asInterface(_s.body));
					{
						final __type__ = _s.else_;
						if (__type__ == null
							|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BadStmt>))) {} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IfStmt>))
							|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BlockStmt>))) {
							_check._stmt(_inner, _s.else_);
						} else {
							_check._invalidAST(_s.else_, ("invalid else branch in if statement" : GoString));
						};
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SwitchStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.SwitchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__()
						.value;
					_inner = _inner | ((("1" : GoUInt) : T_stmtContext));
					_check._openScope(Go.asInterface(_s), ("switch" : GoString));
					__deferstack__.unshift(() -> _check._closeScope());
					_check._simpleStmt(_s.init);
					var _x:T_operand = ({} : T_operand);
					if (_s.tag != null) {
						_check._expr((_x : Ref<T_operand>), _s.tag);
						_check._assignment((_x : Ref<T_operand>), (null : Type), ("switch expression" : GoString));
						if (((_x._mode != (0 : T_operandMode)) && !comparable(_x._typ)) && !_hasNil(_x._typ)) {
							_check._errorf(Go.asInterface((_x : Ref<T_operand>)), (117 : T_errorCode),
								("cannot switch on %s (%s is not comparable)" : GoString), Go.toInterface(Go.asInterface((_x : Ref<T_operand>))),
								Go.toInterface(_x._typ));
							_x._mode = (0 : T_operandMode);
						};
					} else {
						_x._mode = (4 : T_operandMode);
						_x._typ = Go.asInterface(typ[((1 : BasicKind) : GoInt)]);
						_x._val = stdgo.go.constant.Constant.makeBool(true);
						_x._expr = Go.asInterface((({namePos: _s.body.lbrace,
							name: ("true" : GoString)} : stdgo.go.ast.Ast.Ident) : Ref<stdgo.go.ast.Ast.Ident>));
					};
					_check._multipleDefaults(_s.body.list);
					var _seen:T_valueMap = (new GoObjectMap<AnyInterface,
						Slice<T_valueType>>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("T_valueMap", [], null, false,
							{
						get: () -> null
					}))) : T_valueMap);
					for (_i => _c in _s.body.list) {
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_c) : Ref<stdgo.go.ast.Ast.CaseClause>)) : Ref<stdgo.go.ast.Ast.CaseClause>), ok: true};
						} catch (_) {
							{value: (null : Ref<stdgo.go.ast.Ast.CaseClause>), ok: false};
						}, _clause = __tmp__.value, _12 = __tmp__.ok;
						if (_clause == null) {
							_check._invalidAST(_c, ("incorrect expression switch case" : GoString));
							continue;
						};
						_check._caseValues((_x : Ref<T_operand>), _clause.list, _seen);
						_check._openScope(Go.asInterface(_clause), ("case" : GoString));
						var _inner:T_stmtContext = _inner;
						if ((_i + (1 : GoInt)) < (_s.body.list.length)) {
							_inner = _inner | ((("4" : GoUInt) : T_stmtContext));
						} else {
							_inner = _inner | ((("8" : GoUInt) : T_stmtContext));
						};
						_check._stmtList(_inner, _clause.body);
						_check._closeScope();
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.TypeSwitchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__()
						.value;
					_inner = _inner | ((("17" : GoUInt) : T_stmtContext));
					_check._openScope(Go.asInterface(_s), ("type switch" : GoString));
					__deferstack__.unshift(() -> _check._closeScope());
					_check._simpleStmt(_s.init);
					var _lhs:Ref<stdgo.go.ast.Ast.Ident> = (null : Ref<stdgo.go.ast.Ast.Ident>);
					var _rhs:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
					{
						final __type__ = _s.assign;
						if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ExprStmt>))) {
							var _guard:Ref<stdgo.go.ast.Ast.ExprStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__()
								.value;
							_rhs = _guard.x;
						} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.AssignStmt>))) {
							var _guard:Ref<stdgo.go.ast.Ast.AssignStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__()
								.value;
							if (((_guard.lhs.length != (1 : GoInt)) || (_guard.tok != (47 : stdgo.go.token.Token.Token)))
								|| (_guard.rhs.length != (1 : GoInt))) {
								_check._invalidAST(Go.asInterface(_s), ("incorrect form of type switch guard" : GoString));
								{
									for (defer in __deferstack__) {
										defer();
									};
									return;
								};
							};
							{
								var __tmp__ = try {
									{value: (Go.typeAssert((Go.toInterface(_guard.lhs[(0 : GoInt)]) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>),
										ok: true};
								} catch (_) {
									{value: (null : Ref<stdgo.go.ast.Ast.Ident>), ok: false};
								};
								_lhs = __tmp__.value;
							};
							if (_lhs == null) {
								_check._invalidAST(Go.asInterface(_s), ("incorrect form of type switch guard" : GoString));
								{
									for (defer in __deferstack__) {
										defer();
									};
									return;
								};
							};
							if (_lhs.name == (("_" : GoString))) {
								_check._softErrorf(Go.asInterface(_lhs), (19 : T_errorCode), ("no new variable on left side of :=" : GoString));
								_lhs = null;
							} else {
								_check._recordDef(_lhs, (null : Object));
							};
							_rhs = _guard.rhs[(0 : GoInt)];
						} else {
							var _guard:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
							_check._invalidAST(Go.asInterface(_s), ("incorrect form of type switch guard" : GoString));
							{
								for (defer in __deferstack__) {
									defer();
								};
								return;
							};
						};
					};
					var __tmp__ = try {
						{value: (Go.typeAssert((Go.toInterface(_rhs) : Ref<stdgo.go.ast.Ast.TypeAssertExpr>)) : Ref<stdgo.go.ast.Ast.TypeAssertExpr>),
							ok: true};
					} catch (_) {
						{value: (null : Ref<stdgo.go.ast.Ast.TypeAssertExpr>), ok: false};
					}, _expr = __tmp__.value, _13 = __tmp__.ok;
					if ((_expr == null) || (_expr.type != null)) {
						_check._invalidAST(Go.asInterface(_s), ("incorrect form of type switch guard" : GoString));
						{
							for (defer in __deferstack__) {
								defer();
							};
							return;
						};
					};
					var _x:T_operand = ({} : T_operand);
					_check._expr((_x : Ref<T_operand>), _expr.x);
					if (_x._mode == ((0 : T_operandMode))) {
						{
							for (defer in __deferstack__) {
								defer();
							};
							return;
						};
					};
					var _sx:Ref<T_operand> = (null : Ref<T_operand>);
					if (_isTypeParam(_x._typ)) {
						_check._errorf(Go.asInterface((_x : Ref<T_operand>)), (116 : T_errorCode),
							("cannot use type switch on type parameter value %s" : GoString), Go.toInterface(Go.asInterface((_x : Ref<T_operand>))));
					} else {
						{
							var __tmp__ = try {
								{value: (Go.typeAssert((Go.toInterface(_under(_x._typ)) : Ref<Interface>)) : Ref<Interface>), ok: true};
							} catch (_) {
								{value: (null : Ref<Interface>), ok: false};
							}, _14 = __tmp__.value, _ok = __tmp__.ok;
							if (_ok) {
								_sx = (_x : Ref<T_operand>);
							} else {
								_check._errorf(Go.asInterface((_x : Ref<T_operand>)), (116 : T_errorCode), ("%s is not an interface" : GoString),
									Go.toInterface(Go.asInterface((_x : Ref<T_operand>))));
							};
						};
					};
					_check._multipleDefaults(_s.body.list);
					var _lhsVars:Slice<Ref<Var>> = (null : Slice<Ref<Var>>);
					var _seen = (new GoObjectMap<Type,
						stdgo.go.ast.Ast.Expr>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({
						get: () -> stdgo.internal.reflect.Reflect.GoType.named("Type", [], null, false, {get: () -> null})
					},
						{get: () -> stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.ast.Ast.Expr", [], null, false,
							{get: () -> null})}))) : GoMap<Type, stdgo.go.ast.Ast.Expr>);
					for (_15 => _s in _s.body.list) {
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_s) : Ref<stdgo.go.ast.Ast.CaseClause>)) : Ref<stdgo.go.ast.Ast.CaseClause>), ok: true};
						} catch (_) {
							{value: (null : Ref<stdgo.go.ast.Ast.CaseClause>), ok: false};
						}, _clause = __tmp__.value, _16 = __tmp__.ok;
						if (_clause == null) {
							_check._invalidAST(_s, ("incorrect type switch case" : GoString));
							continue;
						};
						var t:Type = _check._caseTypes(_sx, _clause.list, _seen);
						_check._openScope(Go.asInterface(_clause), ("case" : GoString));
						if (_lhs != null) {
							if ((_clause.list.length != (1 : GoInt)) || (t == null)) {
								t = _x._typ;
							};
							var _obj = newVar(_lhs.pos(), _check._pkg, _lhs.name, t);
							var _scopePos:stdgo.go.token.Token.Pos = _clause.pos() + (("default" : GoString).length : stdgo.go.token.Token.Pos);
							{
								var _n:GoInt = (_clause.list.length);
								if (_n > (0 : GoInt)) {
									_scopePos = _clause.list[(_n - (1 : GoInt) : GoInt)].end();
								};
							};
							_check._declare(_check._pkg._scope, null, Go.asInterface(_obj), _scopePos);
							_check._recordImplicit(Go.asInterface(_clause), Go.asInterface(_obj));
							_lhsVars = _lhsVars.__appendref__(_obj);
						};
						_check._stmtList(_inner, _clause.body);
						_check._closeScope();
					};
					if (_lhs != null) {
						var _used:Bool = false;
						for (_21 => _v in _lhsVars) {
							if (_v._used) {
								_used = true;
							};
							_v._used = true;
						};
						if (!_used) {
							_check._softErrorf(Go.asInterface(_lhs), (101 : T_errorCode), ("%s declared but not used" : GoString), Go.toInterface(_lhs.name));
						};
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.SelectStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__()
						.value;
					_inner = _inner | ((("1" : GoUInt) : T_stmtContext));
					_check._multipleDefaults(_s.body.list);
					for (_22 => _s in _s.body.list) {
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_s) : Ref<stdgo.go.ast.Ast.CommClause>)) : Ref<stdgo.go.ast.Ast.CommClause>), ok: true};
						} catch (_) {
							{value: (null : Ref<stdgo.go.ast.Ast.CommClause>), ok: false};
						}, _clause = __tmp__.value, _23 = __tmp__.ok;
						if (_clause == null) {
							continue;
						};
						var _valid:Bool = false;
						var _rhs:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
						{
							final __type__ = _clause.comm;
							if (__type__ == null || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SendStmt>))) {
								var _s:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
								_valid = true;
							} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.AssignStmt>))) {
								var _s:Ref<stdgo.go.ast.Ast.AssignStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__()
									.value;
								if ((_s.rhs.length) == ((1 : GoInt))) {
									_rhs = _s.rhs[(0 : GoInt)];
								};
							} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ExprStmt>))) {
								var _s:Ref<stdgo.go.ast.Ast.ExprStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__()
									.value;
								_rhs = _s.x;
							};
						};
						if (_rhs != null) {
							{
								var __tmp__ = try {
									{value: (Go.typeAssert((Go.toInterface(_unparen(_rhs)) : Ref<stdgo.go.ast.Ast.UnaryExpr>)) : Ref<stdgo.go.ast.Ast.UnaryExpr>),
										ok: true};
								} catch (_) {
									{value: (null : Ref<stdgo.go.ast.Ast.UnaryExpr>), ok: false};
								}, _x = __tmp__.value, _24 = __tmp__.ok;
								if ((_x != null) && (_x.op == (36 : stdgo.go.token.Token.Token))) {
									_valid = true;
								};
							};
						};
						if (!_valid) {
							_check._error(_clause.comm, (118 : T_errorCode), ("select case must be send or receive (possibly with assignment)" : GoString));
							continue;
						};
						_check._openScope(_s, ("case" : GoString));
						if (_clause.comm != null) {
							_check._stmt(_inner, _clause.comm);
						};
						_check._stmtList(_inner, _clause.body);
						_check._closeScope();
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ForStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.ForStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__()
						.value;
					_inner = _inner | ((("3" : GoUInt) : T_stmtContext));
					_check._openScope(Go.asInterface(_s), ("for" : GoString));
					__deferstack__.unshift(() -> _check._closeScope());
					_check._simpleStmt(_s.init);
					if (_s.cond != null) {
						var _x:T_operand = ({} : T_operand);
						_check._expr((_x : Ref<T_operand>), _s.cond);
						if ((_x._mode != (0 : T_operandMode)) && !_allBoolean(_x._typ)) {
							_check._error(_s.cond, (105 : T_errorCode), ("non-boolean condition in for statement" : GoString));
						};
					};
					_check._simpleStmt(_s.post);
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_s.post) : Ref<stdgo.go.ast.Ast.AssignStmt>)) : Ref<stdgo.go.ast.Ast.AssignStmt>), ok: true};
						} catch (_) {
							{value: (null : Ref<stdgo.go.ast.Ast.AssignStmt>), ok: false};
						}, _s = __tmp__.value, _25 = __tmp__.ok;
						if ((_s != null) && (_s.tok == (47 : stdgo.go.token.Token.Token))) {
							_check._softErrorf(Go.asInterface(_s), (106 : T_errorCode), ("cannot declare in post statement" : GoString));
							_check._use(..._s.lhs.__toArray__());
						};
					};
					_check._stmt(_inner, Go.asInterface(_s.body));
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.RangeStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.RangeStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__.__underlying__()
						.value;
					_inner = _inner | ((("3" : GoUInt) : T_stmtContext));
					var _x:T_operand = ({} : T_operand);
					_check._expr((_x : Ref<T_operand>), _s.x);
					var _0:Type = (null : Type),
						_1:Type = (null : Type),
						_val:Type = _1,
						_key:Type = _0;
					if (_x._mode != ((0 : T_operandMode))) {
						var _cause:GoString = ("" : GoString);
						var _u:Type = _coreType(_x._typ);
						{
							final __type__ = _u;
							if (__type__ == null) {
								var _t:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
								_cause = _check._sprintf(("%s has no core type" : GoString), Go.toInterface(_x._typ));
							} else if (Go.typeEquals((__type__ : Ref<Chan>))) {
								var _t:Ref<Chan> = __type__ == null ? (null : Ref<Chan>) : __type__.__underlying__() == null ? (null : Ref<Chan>) : __type__ == null ? (null : Ref<Chan>) : __type__.__underlying__()
									.value;
								if (_s.value != null) {
									_check._softErrorf(_s.value, (108 : T_errorCode), ("range over %s permits only one iteration variable" : GoString),
										Go.toInterface(Go.asInterface((_x : Ref<T_operand>))));
								};
								if (_t._dir == ((1 : ChanDir))) {
									_cause = ("receive from send-only channel" : GoString);
								};
							};
						};
						{
							var __tmp__ = _rangeKeyVal(_u);
							_key = __tmp__._0;
							_val = __tmp__._1;
						};
						if ((_key == null) || (_cause != Go.str())) {
							if (_cause == (Go.str())) {
								_check._softErrorf(Go.asInterface((_x : Ref<T_operand>)), (109 : T_errorCode), ("cannot range over %s" : GoString),
									Go.toInterface(Go.asInterface((_x : Ref<T_operand>))));
							} else {
								_check._softErrorf(Go.asInterface((_x : Ref<T_operand>)), (109 : T_errorCode), ("cannot range over %s (%s)" : GoString),
									Go.toInterface(Go.asInterface((_x : Ref<T_operand>))), Go.toInterface(_cause));
							};
						};
					};
					_check._openScope(Go.asInterface(_s), ("range" : GoString));
					__deferstack__.unshift(() -> _check._closeScope());
					var _lhs = (new GoArray<stdgo.go.ast.Ast.Expr>(_s.key, _s.value) : GoArray<stdgo.go.ast.Ast.Expr>);
					var _rhs = (new GoArray<Type>(_key, _val) : GoArray<Type>);
					if (_s.tok == ((47 : stdgo.go.token.Token.Token))) {
						var _vars:Slice<Ref<Var>> = (null : Slice<Ref<Var>>);
						for (_i => _lhs in _lhs) {
							if (_lhs == null) {
								continue;
							};
							var _obj:Ref<Var> = (null : Ref<Var>);
							{
								var __tmp__ = try {
									{value: (Go.typeAssert((Go.toInterface(_lhs) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>), ok: true};
								} catch (_) {
									{value: (null : Ref<stdgo.go.ast.Ast.Ident>), ok: false};
								}, _ident = __tmp__.value, _26 = __tmp__.ok;
								if (_ident != null) {
									var _name:GoString = _ident.name;
									_obj = newVar(_ident.pos(), _check._pkg, _name, (null : Type));
									_check._recordDef(_ident, Go.asInterface(_obj));
									if (_name != (("_" : GoString))) {
										_vars = _vars.__appendref__(_obj);
									};
								} else {
									_check._invalidAST(_lhs, ("cannot declare %s" : GoString), Go.toInterface(_lhs));
									_obj = newVar(_lhs.pos(), _check._pkg, ("_" : GoString), (null : Type));
								};
							};
							{
								var _typ:Type = _rhs[(_i : GoInt)];
								if (_typ != null) {
									_x._mode = (7 : T_operandMode);
									_x._expr = _lhs;
									_x._typ = _typ;
									_check._initVar(_obj, (_x : Ref<T_operand>), ("range clause" : GoString));
								} else {
									_obj._object._typ = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
									_obj._used = true;
								};
							};
						};
						if ((_vars.length) > (0 : GoInt)) {
							var _scopePos:stdgo.go.token.Token.Pos = _s.body.pos();
							for (_31 => _obj in _vars) {
								_check._declare(_check._pkg._scope, null, Go.asInterface(_obj), _scopePos);
							};
						} else {
							_check._error(Go.asInterface(_inNode(Go.asInterface(_s), _s.tokPos)), (19 : T_errorCode),
								("no new variables on left side of :=" : GoString));
						};
					} else {
						for (_i => _lhs in _lhs) {
							if (_lhs == null) {
								continue;
							};
							{
								var _typ:Type = _rhs[(_i : GoInt)];
								if (_typ != null) {
									_x._mode = (7 : T_operandMode);
									_x._expr = _lhs;
									_x._typ = _typ;
									_check._assignVar(_lhs, (_x : Ref<T_operand>));
								};
							};
						};
					};
					_check._stmt(_inner, Go.asInterface(_s.body));
				} else {
					var _s:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
					_check._invalidAST(_s, ("invalid statement" : GoString));
				};
			};
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return;
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return;
		};
	}

	/**
		// If the type switch expression is invalid, x is nil.
	**/
	@:keep
	static public function _caseTypes(_check:Ref<Checker>, _x:Ref<T_operand>, _types:Slice<stdgo.go.ast.Ast.Expr>,
			_seen:GoMap<Type, stdgo.go.ast.Ast.Expr>):Type {
		return stdgo.internal.Macro.controlFlow({
			var t:Type = (null : Type);
			var _dummy:T_operand = ({} : T_operand);
			@:label("L") for (_0 => _e in _types) {
				if (_check._isNil(_e)) {
					t = (null : Type);
					_check._expr((_dummy : Ref<T_operand>), _e);
				} else {
					t = _check._varType(_e);
					if (Go.toInterface(t) == (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
						@:jump("L") continue;
					};
				};
				for (_t => _other in _seen) {
					if (((t == null) && (_t == null)) || (((t != null) && (_t != null)) && identical(t, _t))) {
						var ts:GoString = ("nil" : GoString);
						if (t != null) {
							ts = typeString(t, _check._qualifier);
						};
						_check._errorf(_e, (113 : T_errorCode), ("duplicate case %s in type switch" : GoString), Go.toInterface(ts));
						_check._error(_other, (113 : T_errorCode), ("\tprevious case" : GoString));
						@:jump("L") continue;
					};
				};
				_seen[t] = _e;
				if ((_x != null) && (t != null)) {
					_check._typeAssertion(_e, _x, t, true);
				};
			};
			return t;
		});
	}

	/**
		// isNil reports whether the expression e denotes the predeclared value nil.
	**/
	@:keep
	static public function _isNil(_check:Ref<Checker>, _e:stdgo.go.ast.Ast.Expr):Bool {
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_unparen(_e)) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>), ok: true};
			} catch (_) {
				{value: (null : Ref<stdgo.go.ast.Ast.Ident>), ok: false};
			}, _name = __tmp__.value, _0 = __tmp__.ok;
			if (_name != null) {
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_check._lookup(_name.name)) : Ref<Nil>)) : Ref<Nil>), ok: true};
				} catch (_) {
					{value: (null : Ref<Nil>), ok: false};
				}, _1 = __tmp__.value, _ok = __tmp__.ok;
				return _ok;
			};
		};
		return false;
	}

	@:keep
	static public function _caseValues(_check:Ref<Checker>, _x:Ref<T_operand>, _values:Slice<stdgo.go.ast.Ast.Expr>, _seen:T_valueMap):Void {
		stdgo.internal.Macro.controlFlow({
			@:label("L") for (_0 => _e in _values) {
				var _v:T_operand = ({} : T_operand);
				_check._expr((_v : Ref<T_operand>), _e);
				if ((_x._mode == (0 : T_operandMode)) || (_v._mode == (0 : T_operandMode))) {
					@:jump("L") continue;
				};
				_check._convertUntyped((_v : Ref<T_operand>), _x._typ);
				if (_v._mode == ((0 : T_operandMode))) {
					@:jump("L") continue;
				};
				var _res:T_operand = (_v == null ? null : _v.__copy__());
				_check._comparison((_res : Ref<T_operand>), _x, (39 : stdgo.go.token.Token.Token), true);
				if (_res._mode == ((0 : T_operandMode))) {
					@:jump("L") continue;
				};
				if (_v._mode != ((4 : T_operandMode))) {
					@:jump("L") continue;
				};
				{
					var _val:AnyInterface = _goVal(_v._val);
					if (_val != null) {
						for (_1 => _vt in _seen[_val]) {
							if (identical(_v._typ, _vt._typ)) {
								_check._errorf(Go.asInterface((_v : Ref<T_operand>)), (113 : T_errorCode),
									("duplicate case %s in expression switch" : GoString), Go.toInterface(Go.asInterface((_v : Ref<T_operand>))));
								_check._error(Go.asInterface((_vt._pos : T_atPos)), (113 : T_errorCode), ("\tprevious case" : GoString));
								@:jump("L") continue;
							};
						};
						_seen[_val] = _seen[_val].__appendref__((new T_valueType(_v.pos(), _v._typ) : T_valueType));
					};
				};
			};
		});
	}

	@:keep
	static public function _suspendedCall(_check:Ref<Checker>, _keyword:GoString, _call:Ref<stdgo.go.ast.Ast.CallExpr>):Void {
		var _x:T_operand = ({} : T_operand);
		var _msg:GoString = ("" : GoString);
		var _code:T_errorCode = ((0 : GoInt) : T_errorCode);
		if (_check._rawExpr((_x : Ref<T_operand>), Go.asInterface(_call), (null : Type), false) == ((0 : T_exprKind))) {
			_msg = ("requires function call, not conversion" : GoString);
			_code = (129 : T_errorCode);
			if (_keyword == (("go" : GoString))) {
				_code = (130 : T_errorCode);
			};
		} else if (_check._rawExpr((_x : Ref<T_operand>), Go.asInterface(_call), (null : Type), false) == ((1 : T_exprKind))) {
			_msg = ("discards result of" : GoString);
			_code = (128 : T_errorCode);
		} else if (_check._rawExpr((_x : Ref<T_operand>), Go.asInterface(_call), (null : Type), false) == ((2 : T_exprKind))) {
			return;
		} else {
			_unreachable();
		};
		_check._errorf(Go.asInterface((_x : Ref<T_operand>)), _code, ("%s %s %s" : GoString), Go.toInterface(_keyword), Go.toInterface(_msg),
			Go.toInterface(Go.asInterface((_x : Ref<T_operand>))));
	}

	@:keep
	static public function _closeScope(_check:Ref<Checker>):Void {
		_check._pkg._scope = _check._pkg._scope.parent();
	}

	@:keep
	static public function _openScope(_check:Ref<Checker>, _node:stdgo.go.ast.Ast.Node, _comment:GoString):Void {
		var _scope = newScope(_check._pkg._scope, _node.pos(), _node.end(), _comment);
		_check._recordScope(_node, _scope);
		_check._pkg._scope = _scope;
	}

	@:keep
	static public function _multipleDefaults(_check:Ref<Checker>, _list:Slice<stdgo.go.ast.Ast.Stmt>):Void {
		var _first:stdgo.go.ast.Ast.Stmt = (null : stdgo.go.ast.Ast.Stmt);
		for (_0 => _s in _list) {
			var _d:stdgo.go.ast.Ast.Stmt = (null : stdgo.go.ast.Ast.Stmt);
			{
				final __type__ = _s;
				if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CaseClause>))) {
					var _c:Ref<stdgo.go.ast.Ast.CaseClause> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CaseClause>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.CaseClause>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CaseClause>) : __type__.__underlying__()
						.value;
					if ((_c.list.length) == ((0 : GoInt))) {
						_d = _s;
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CommClause>))) {
					var _c:Ref<stdgo.go.ast.Ast.CommClause> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CommClause>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.CommClause>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CommClause>) : __type__.__underlying__()
						.value;
					if (_c.comm == null) {
						_d = _s;
					};
				} else {
					var _c:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
					_check._invalidAST(_s, ("case/communication clause expected" : GoString));
				};
			};
			if (_d != null) {
				if (_first != null) {
					_check._errorf(_d, (114 : T_errorCode), ("multiple defaults (first at %s)" : GoString),
						Go.toInterface(Go.asInterface(_check._fset.position(_first.pos()))));
				} else {
					_first = _d;
				};
			};
		};
	}

	@:keep
	static public function _stmtList(_check:Ref<Checker>, _ctxt:T_stmtContext, _list:Slice<stdgo.go.ast.Ast.Stmt>):Void {
		var _ok:Bool = _ctxt & (("4" : GoUInt) : T_stmtContext) != ((("0" : GoUInt) : T_stmtContext));
		var _inner:T_stmtContext = _ctxt & ((("4" : GoUInt) : T_stmtContext) ^ (-1 : GoInt));
		_list = _trimTrailingEmptyStmts(_list);
		for (_i => _s in _list) {
			var _inner:T_stmtContext = _inner;
			if (_ok && ((_i + (1 : GoInt)) == (_list.length))) {
				_inner = _inner | ((("4" : GoUInt) : T_stmtContext));
			};
			_check._stmt(_inner, _s);
		};
	}

	@:keep
	static public function _simpleStmt(_check:Ref<Checker>, _s:stdgo.go.ast.Ast.Stmt):Void {
		if (_s != null) {
			_check._stmt((("0" : GoUInt) : T_stmtContext), _s);
		};
	}

	@:keep
	static public function _usage(_check:Ref<Checker>, _scope:Ref<Scope>):Void {
		var _unused:Slice<Ref<Var>> = (null : Slice<Ref<Var>>);
		for (_name => _elem in _scope._elems) {
			_elem = _resolve(_name, _elem);
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_elem) : Ref<Var>)) : Ref<Var>), ok: true};
				} catch (_) {
					{value: (null : Ref<Var>), ok: false};
				}, _v = __tmp__.value, _0 = __tmp__.ok;
				if ((_v != null) && !_v._used) {
					_unused = _unused.__appendref__(_v);
				};
			};
		};
		stdgo.sort.Sort.slice(Go.toInterface(_unused), function(_i:GoInt, _j:GoInt):Bool {
			return _unused[(_i : GoInt)]._object._pos < _unused[(_j : GoInt)]._object._pos;
		});
		for (_1 => _v in _unused) {
			_check._softErrorf(Go.asInterface(_v), (101 : T_errorCode), ("%s declared but not used" : GoString), Go.toInterface(_v._object._name));
		};
		for (_2 => _scope in _scope._children) {
			if (!_scope._isFunc) {
				_check._usage(_scope);
			};
		};
	}

	@:keep
	static public function _funcBody(_check:Ref<Checker>, _decl:Ref<T_declInfo>, _name:GoString, _sig:Ref<Signature>, _body:Ref<stdgo.go.ast.Ast.BlockStmt>,
			_iota:stdgo.go.constant.Constant.Value):Void {
		var __deferstack__:Array<Void->Void> = [];
		if (_check._conf.ignoreFuncBodies) {
			throw Go.toInterface(("function body not ignored" : GoString));
		};
		try {
			if (false) {
				_check._trace(_body.pos(), ("-- %s: %s" : GoString), Go.toInterface(_name), Go.toInterface(Go.asInterface(_sig)));
			};
			_sig._scope._pos = _body.pos();
			_sig._scope._end = _body.end();
			{
				var _a0 = _check._environment;
				var _a1 = _check._indent;
				__deferstack__.unshift(() -> {
					var a = function(_env:T_environment, _indent:GoInt):Void {
						_check._environment = (_env == null ? null : _env.__copy__());
						_check._indent = _indent;
					};
					a((_a0 == null ? null : _a0.__copy__()), _a1);
				});
			};
			_check._environment = ({
				_decl: _decl,
				_scope: _sig._scope,
				_iota: _iota,
				_sig: _sig
			} : T_environment);
			_check._indent = (0 : GoInt);
			_check._stmtList((("0" : GoUInt) : T_stmtContext), _body.list);
			if (_check._environment._hasLabel) {
				_check._labels(_body);
			};
			if ((_sig._results.len() > (0 : GoInt)) && !_check._isTerminating(Go.asInterface(_body), Go.str())) {
				_check._error(Go.asInterface((_body.rbrace : T_atPos)), (102 : T_errorCode), ("missing return" : GoString));
			};
			_check._usage(_sig._scope);
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return;
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return;
		};
	}

	/**
		// collectParams declares the parameters of list in scope and returns the corresponding
		// variable list.
	**/
	@:keep
	static public function _collectParams(_check:Ref<Checker>, _scope:Ref<Scope>, _list:Ref<stdgo.go.ast.Ast.FieldList>,
			_variadicOk:Bool):{var _0:Slice<Ref<Var>>; var _1:Bool;} {
		var _params:Slice<Ref<Var>> = (null : Slice<Ref<Var>>),
			_variadic:Bool = false;
		if (_list == null) {
			return {_0: _params, _1: _variadic};
		};
		var _0:Bool = false,
			_1:Bool = false,
			_anonymous:Bool = _1,
			_named:Bool = _0;
		for (_i => _field in _list.list) {
			var _ftype:stdgo.go.ast.Ast.Expr = _field.type;
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_ftype) : Ref<stdgo.go.ast.Ast.Ellipsis>)) : Ref<stdgo.go.ast.Ast.Ellipsis>), ok: true};
				} catch (_) {
					{value: (null : Ref<stdgo.go.ast.Ast.Ellipsis>), ok: false};
				}, _t = __tmp__.value, _0 = __tmp__.ok;
				if (_t != null) {
					_ftype = _t.elt;
					if ((_variadicOk && (_i == (_list.list.length - (1 : GoInt)))) && (_field.names.length <= (1 : GoInt))) {
						_variadic = true;
					} else {
						_check._softErrorf(Go.asInterface(_t), (79 : T_errorCode), ("can only use ... with final parameter in list" : GoString));
					};
				};
			};
			var _typ:Type = _check._varType(_ftype);
			if ((_field.names.length) > (0 : GoInt)) {
				for (_1 => _name in _field.names) {
					if (_name.name == (Go.str())) {
						_check._invalidAST(Go.asInterface(_name), ("anonymous parameter" : GoString));
					};
					var _par = newParam(_name.pos(), _check._pkg, _name.name, _typ);
					_check._declare(_scope, _name, Go.asInterface(_par), _scope._pos);
					_params = _params.__appendref__(_par);
				};
				_named = true;
			} else {
				var _par = newParam(_ftype.pos(), _check._pkg, Go.str(), _typ);
				_check._recordImplicit(Go.asInterface(_field), Go.asInterface(_par));
				_params = _params.__appendref__(_par);
				_anonymous = true;
			};
		};
		if (_named && _anonymous) {
			_check._invalidAST(Go.asInterface(_list), ("list contains both named and anonymous parameters" : GoString));
		};
		if (_variadic) {
			var _last = _params[((_params.length) - (1 : GoInt) : GoInt)];
			_last._object._typ = Go.asInterface((({_elem: _last._object._typ} : Slice_) : Ref<Slice_>));
			_check._recordTypeAndValue(_list.list[((_list.list.length) - (1 : GoInt) : GoInt)].type, (3 : T_operandMode), _last._object._typ,
				(null : stdgo.go.constant.Constant.Value));
		};
		return {_0: _params, _1: _variadic};
	}

	/**
		// funcType type-checks a function or method type.
	**/
	@:keep
	static public function _funcType(_check:Ref<Checker>, _sig:Ref<Signature>, _recvPar:Ref<stdgo.go.ast.Ast.FieldList>,
			_ftyp:Ref<stdgo.go.ast.Ast.FuncType>):Void {
		var __deferstack__:Array<Void->Void> = [];
		_check._openScope(Go.asInterface(_ftyp), ("function" : GoString));
		try {
			_check._pkg._scope._isFunc = true;
			_check._recordScope(Go.asInterface(_ftyp), _check._pkg._scope);
			_sig._scope = _check._pkg._scope;
			__deferstack__.unshift(() -> _check._closeScope());
			if ((_recvPar != null) && (_recvPar.list.length > (0 : GoInt))) {
				var __tmp__ = _check._unpackRecv(_recvPar.list[(0 : GoInt)].type, true),
					_6:Bool = __tmp__._0,
					_rname:Ref<stdgo.go.ast.Ast.Ident> = __tmp__._1,
					_rparams:Slice<Ref<stdgo.go.ast.Ast.Ident>> = __tmp__._2;
				if ((_rparams.length) > (0 : GoInt)) {
					var _tparams = _check._declareTypeParams((null : Slice<Ref<TypeParam>>), _rparams);
					_sig._rparams = _bindTParams(_tparams);
					for (_i => _p in _rparams) {
						if (_p.name == (("_" : GoString))) {
							if (_check._recvTParamMap == null) {
								_check._recvTParamMap = (new GoObjectMap<Ref<stdgo.go.ast.Ast.Ident>,
									Ref<TypeParam>>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({
									get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () ->
											stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.ast.Ast.Ident", [], null, false, {get: () -> null})})
								},
									{get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () ->
											stdgo.internal.reflect.Reflect.GoType.named("TypeParam", [], null, false, {get: () ->
												null})})}))) : GoMap<Ref<stdgo.go.ast.Ast.Ident>, Ref<TypeParam>>);
							};
							_check._recvTParamMap[_p] = _tparams[(_i : GoInt)];
						};
					};
					var _recvTParams:Slice<Ref<TypeParam>> = (null : Slice<Ref<TypeParam>>);
					if (_rname != null) {
						{
							var __tmp__ = try {
								{value: (Go.typeAssert((Go.toInterface(_check._genericType(Go.asInterface(_rname),
									(null : Pointer<GoString>))) : Ref<Named>)) : Ref<Named>), ok: true};
							} catch (_) {
								{value: (null : Ref<Named>), ok: false};
							}, _recv = __tmp__.value, _13 = __tmp__.ok;
							if (_recv != null) {
								_recvTParams = _recv.typeParams()._list();
							};
						};
					};
					if ((_tparams.length) == ((_recvTParams.length))) {
						var _smap:T_substMap = _makeRenameMap(_recvTParams, _tparams);
						for (_i => _tpar in _tparams) {
							var _recvTPar = _recvTParams[(_i : GoInt)];
							_check._mono._recordCanon(_tpar, _recvTPar);
							_tpar._bound = _check._subst(_tpar._obj._object._pos, _recvTPar._bound, _smap, null, _check._context());
						};
					} else if ((_tparams.length) < (_recvTParams.length)) {
						var _got:GoString = _measure((_tparams.length), ("type parameter" : GoString));
						_check._errorf(Go.asInterface(_recvPar), (31 : T_errorCode), ("got %s, but receiver base type declares %d" : GoString),
							Go.toInterface(_got), Go.toInterface((_recvTParams.length)));
					};
				};
			};
			if (_ftyp.typeParams != null) {
				_check._collectTypeParams((_sig._tparams : Ref<Ref<TypeParamList>>), _ftyp.typeParams);
				if (_recvPar != null) {
					_check._errorf(Go.asInterface(_ftyp.typeParams), (143 : T_errorCode), ("methods cannot have type parameters" : GoString));
				};
			};
			var _scope = newScope(_check._pkg._scope, (0 : stdgo.go.token.Token.Pos), (0 : stdgo.go.token.Token.Pos),
				("function body (temp. scope)" : GoString));
			var __tmp__ = _check._collectParams(_scope, _recvPar, false),
				_recvList:Slice<Ref<Var>> = __tmp__._0,
				_24:Bool = __tmp__._1;
			var __tmp__ = _check._collectParams(_scope, _ftyp.params, true),
				_params:Slice<Ref<Var>> = __tmp__._0,
				_variadic:Bool = __tmp__._1;
			var __tmp__ = _check._collectParams(_scope, _ftyp.results, false),
				_results:Slice<Ref<Var>> = __tmp__._0,
				_25:Bool = __tmp__._1;
			_scope._squash(function(_obj:Object, _alt:Object):Void {
				_check._errorf(_obj, (10 : T_errorCode), ("%s redeclared in this block" : GoString), Go.toInterface(_obj.name()));
				_check._reportAltDecl(_alt);
			});
			if (_recvPar != null) {
				var _recv:Ref<Var> = (null : Ref<Var>);
				{
					var __switchIndex__ = -1;
					while (true) {
						if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (_recvList.length == (0 : GoInt)))) {
							_recv = newParam((0 : stdgo.go.token.Token.Pos), null, Go.str(), Go.asInterface(typ[((0 : BasicKind) : GoInt)]));
							break;
							break;
						} else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && (_recvList.length == (1 : GoInt)))) {
							_recv = _recvList[(0 : GoInt)];
							break;
							break;
						};
						break;
					};
				};
				_sig._recv = _recv;
				_check._later(function():Void {
					var __tmp__ = _deref(_recv._object._typ),
						_rtyp:Type = __tmp__._0,
						_0:Bool = __tmp__._1;
					if (Go.toInterface(_rtyp) == (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
						return;
					};
					{
						final __type__ = _rtyp;
						if (Go.typeEquals((__type__ : Ref<Named>))) {
							var t:Ref<Named> = __type__ == null ? (null : Ref<Named>) : __type__.__underlying__() == null ? (null : Ref<Named>) : __type__ == null ? (null : Ref<Named>) : __type__.__underlying__()
								.value;
							if ((t.typeArgs() != null) && (_sig.recvTypeParams() == null)) {
								_check._errorf(Go.asInterface(_recv), (32 : T_errorCode), ("cannot define new methods on instantiated type %s" : GoString),
									Go.toInterface(_rtyp));
								break;
							};
							if (t._obj._object._pkg != (_check._pkg)) {
								_check._errorf(Go.asInterface(_recv), (32 : T_errorCode), ("cannot define new methods on non-local type %s" : GoString),
									Go.toInterface(_rtyp));
								break;
							};
							var _cause:GoString = ("" : GoString);
							{
								final __type__ = t._under();
								if (Go.typeEquals((__type__ : Ref<Basic>))) {
									var _u:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
										.value;
									if (_u._kind == ((18 : BasicKind))) {
										_cause = ("unsafe.Pointer" : GoString);
									};
								} else if (Go.typeEquals((__type__ : Ref<Pointer_>)) || Go.typeEquals((__type__ : Ref<Interface>))) {
									var _u:Type = __type__ == null ? (null : Type) : cast __type__;
									_cause = ("pointer or interface type" : GoString);
								} else if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
									var _u:Ref<TypeParam> = __type__ == null ? (null : Ref<TypeParam>) : __type__.__underlying__() == null ? (null : Ref<TypeParam>) : __type__ == null ? (null : Ref<TypeParam>) : __type__.__underlying__()
										.value;
									_unreachable();
								};
							};
							if (_cause != (Go.str())) {
								_check._errorf(Go.asInterface(_recv), (32 : T_errorCode), ("invalid receiver type %s (%s)" : GoString), Go.toInterface(_rtyp),
									Go.toInterface(_cause));
							};
						} else if (Go.typeEquals((__type__ : Ref<Basic>))) {
							var t:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
								.value;
							_check._errorf(Go.asInterface(_recv), (32 : T_errorCode), ("cannot define new methods on non-local type %s" : GoString),
								Go.toInterface(_rtyp));
						} else {
							var t:Type = __type__ == null ? (null : Type) : cast __type__;
							_check._errorf(Go.asInterface(_recv), (32 : T_errorCode), ("invalid receiver type %s" : GoString),
								Go.toInterface(_recv._object._typ));
						};
					};
				})._describef(Go.asInterface(_recv), ("validate receiver %s" : GoString), Go.toInterface(Go.asInterface(_recv)));
			};
			_sig._params = newTuple(..._params.__toArray__());
			_sig._results = newTuple(..._results.__toArray__());
			_sig._variadic = _variadic;
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return;
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return;
		};
	}

	@:keep
	static public function _isTerminatingSwitch(_check:Ref<Checker>, _body:Ref<stdgo.go.ast.Ast.BlockStmt>, _label:GoString):Bool {
		var _hasDefault:Bool = false;
		for (_0 => _s in _body.list) {
			var _cc = (Go.typeAssert((Go.toInterface(_s) : Ref<stdgo.go.ast.Ast.CaseClause>)) : Ref<stdgo.go.ast.Ast.CaseClause>);
			if (_cc.list == null) {
				_hasDefault = true;
			};
			if (!_check._isTerminatingList(_cc.body, Go.str()) || _hasBreakList(_cc.body, _label, true)) {
				return false;
			};
		};
		return _hasDefault;
	}

	@:keep
	static public function _isTerminatingList(_check:Ref<Checker>, _list:Slice<stdgo.go.ast.Ast.Stmt>, _label:GoString):Bool {
		{
			var _i:GoInt = (_list.length) - (1 : GoInt);
			Go.cfor(_i >= (0 : GoInt), _i--, {
				{
					var __tmp__ = try {
						{value: (Go.typeAssert((Go.toInterface(_list[(_i : GoInt)]) : Ref<stdgo.go.ast.Ast.EmptyStmt>)) : Ref<stdgo.go.ast.Ast.EmptyStmt>),
							ok: true};
					} catch (_) {
						{value: (null : Ref<stdgo.go.ast.Ast.EmptyStmt>), ok: false};
					}, _0 = __tmp__.value, _ok = __tmp__.ok;
					if (!_ok) {
						return _check._isTerminating(_list[(_i : GoInt)], _label);
					};
				};
			});
		};
		return false;
	}

	/**
		// isTerminating reports if s is a terminating statement.
		// If s is labeled, label is the label name; otherwise s
		// is "".
	**/
	@:keep
	static public function _isTerminating(_check:Ref<Checker>, _s:stdgo.go.ast.Ast.Stmt, _label:GoString):Bool {
		{
			final __type__ = _s;
			if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BadStmt>))
				|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.DeclStmt>))
				|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.EmptyStmt>))
				|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SendStmt>))
				|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IncDecStmt>))
				|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.AssignStmt>))
				|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.GoStmt>))
				|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.DeferStmt>))
				|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.RangeStmt>))) {
				var _s:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
			} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.LabeledStmt>))) {
				var _s:Ref<stdgo.go.ast.Ast.LabeledStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__()
					.value;
				return _check._isTerminating(_s.stmt, _s.label.name);
			} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ExprStmt>))) {
				var _s:Ref<stdgo.go.ast.Ast.ExprStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__()
					.value;
				{
					var __tmp__ = try {
						{value: (Go.typeAssert((Go.toInterface(_unparen(_s.x)) : Ref<stdgo.go.ast.Ast.CallExpr>)) : Ref<stdgo.go.ast.Ast.CallExpr>), ok: true};
					} catch (_) {
						{value: (null : Ref<stdgo.go.ast.Ast.CallExpr>), ok: false};
					}, _call = __tmp__.value, _ok = __tmp__.ok;
					if (_ok && _check._environment._isPanic[_call]) {
						return true;
					};
				};
			} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ReturnStmt>))) {
				var _s:Ref<stdgo.go.ast.Ast.ReturnStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ReturnStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ReturnStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ReturnStmt>) : __type__.__underlying__()
					.value;
				return true;
			} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BranchStmt>))) {
				var _s:Ref<stdgo.go.ast.Ast.BranchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__()
					.value;
				if ((_s.tok == (73 : stdgo.go.token.Token.Token)) || (_s.tok == (69 : stdgo.go.token.Token.Token))) {
					return true;
				};
			} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BlockStmt>))) {
				var _s:Ref<stdgo.go.ast.Ast.BlockStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__()
					.value;
				return _check._isTerminatingList(_s.list, Go.str());
			} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IfStmt>))) {
				var _s:Ref<stdgo.go.ast.Ast.IfStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__()
					.value;
				if (((_s.else_ != null) && _check._isTerminating(Go.asInterface(_s.body), Go.str()))
					&& _check._isTerminating(_s.else_, Go.str())) {
					return true;
				};
			} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SwitchStmt>))) {
				var _s:Ref<stdgo.go.ast.Ast.SwitchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__()
					.value;
				return _check._isTerminatingSwitch(_s.body, _label);
			} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>))) {
				var _s:Ref<stdgo.go.ast.Ast.TypeSwitchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__()
					.value;
				return _check._isTerminatingSwitch(_s.body, _label);
			} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectStmt>))) {
				var _s:Ref<stdgo.go.ast.Ast.SelectStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__()
					.value;
				for (_2 => _s in _s.body.list) {
					var _cc = (Go.typeAssert((Go.toInterface(_s) : Ref<stdgo.go.ast.Ast.CommClause>)) : Ref<stdgo.go.ast.Ast.CommClause>);
					if (!_check._isTerminatingList(_cc.body, Go.str()) || _hasBreakList(_cc.body, _label, true)) {
						return false;
					};
				};
				return true;
			} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ForStmt>))) {
				var _s:Ref<stdgo.go.ast.Ast.ForStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__()
					.value;
				if ((_s.cond == null) && !_hasBreak(Go.asInterface(_s.body), _label, true)) {
					return true;
				};
			} else {
				var _s:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
				_unreachable();
			};
		};
		return false;
	}

	@:keep
	static public function _errorUnusedPkg(_check:Ref<Checker>, _obj:Ref<PkgName>):Void {
		var _path:GoString = _obj._imported._path;
		var _elem:GoString = _path;
		{
			var _i:GoInt = stdgo.strings.Strings.lastIndex(_elem, ("/" : GoString));
			if (_i >= (0 : GoInt)) {
				_elem = (_elem.__slice__(_i + (1 : GoInt)) : GoString);
			};
		};
		if (((_obj._object._name == Go.str()) || (_obj._object._name == ("." : GoString))) || (_obj._object._name == _elem)) {
			_check._softErrorf(Go.asInterface(_obj), (8 : T_errorCode), ("%q imported but not used" : GoString), Go.toInterface(_path));
		} else {
			_check._softErrorf(Go.asInterface(_obj), (8 : T_errorCode), ("%q imported but not used as %s" : GoString), Go.toInterface(_path),
				Go.toInterface(_obj._object._name));
		};
	}

	/**
		// unusedImports checks for unused imports.
	**/
	@:keep
	static public function _unusedImports(_check:Ref<Checker>):Void {
		if (_check._conf.ignoreFuncBodies) {
			return;
		};
		for (_2 => _obj in _check._imports) {
			if (!_obj._used && (_obj._object._name != ("_" : GoString))) {
				_check._errorUnusedPkg(_obj);
			};
		};
	}

	/**
		// packageObjects typechecks all package objects, but not function bodies.
	**/
	@:keep
	static public function _packageObjects(_check:Ref<Checker>):Void {
		var _objList = new Slice<Object>((_check._objMap.length : GoInt).toBasic(), 0,
			...[for (i in 0...(_check._objMap.length : GoInt).toBasic()) (null : Object)]);
		var _i:GoInt = (0 : GoInt);
		for (_obj => _ in _check._objMap) {
			_objList[(_i : GoInt)] = _obj;
			_i++;
		};
		stdgo.sort.Sort.sort(Go.asInterface((_objList : T_inSourceOrder)));
		for (_4 => _obj in _objList) {
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_obj) : Ref<TypeName>)) : Ref<TypeName>), ok: true};
				} catch (_) {
					{value: (null : Ref<TypeName>), ok: false};
				}, _obj = __tmp__.value, _5 = __tmp__.ok;
				if ((_obj != null) && (_obj._object._typ != null)) {
					_check._collectMethods(_obj);
				};
			};
		};
		var _aliasList:Slice<Ref<TypeName>> = (null : Slice<Ref<TypeName>>);
		var _othersList:Slice<Object> = (null : Slice<Object>);
		for (_6 => _obj in _objList) {
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_obj) : Ref<TypeName>)) : Ref<TypeName>), ok: true};
				} catch (_) {
					{value: (null : Ref<TypeName>), ok: false};
				}, _tname = __tmp__.value, _7 = __tmp__.ok;
				if (_tname != null) {
					if (_check._objMap[Go.asInterface(_tname)]._tdecl.assign.isValid()) {
						_aliasList = _aliasList.__appendref__(_tname);
					} else {
						_check._objDecl(_obj, null);
					};
				} else {
					_othersList = _othersList.__appendref__(_obj);
				};
			};
		};
		for (_10 => _obj in _aliasList) {
			_check._objDecl(Go.asInterface(_obj), null);
		};
		for (_11 => _obj in _othersList) {
			_check._objDecl(_obj, null);
		};
		_check._methods = (null : GoMap<Ref<TypeName>, Slice<Ref<Func>>>);
	}

	/**
		// resolveBaseTypeName returns the non-alias base type name for typ, and whether
		// there was a pointer indirection to get to it. The base type name must be declared
		// in package scope, and there can be at most one pointer indirection. If no such type
		// name exists, the returned base is nil.
	**/
	@:keep
	static public function _resolveBaseTypeName(_check:Ref<Checker>, _seenPtr:Bool, _name:Ref<stdgo.go.ast.Ast.Ident>):{var _0:Bool; var _1:Ref<TypeName>;} {
		var _ptr:Bool = false, _base:Ref<TypeName> = (null : Ref<TypeName>);
		_ptr = _seenPtr;
		var _seen:GoMap<Ref<TypeName>, Bool> = (null : GoMap<Ref<TypeName>, Bool>);
		var _typ:stdgo.go.ast.Ast.Expr = Go.asInterface(_name);
		while (true) {
			_typ = _unparen(_typ);
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_typ) : Ref<stdgo.go.ast.Ast.StarExpr>)) : Ref<stdgo.go.ast.Ast.StarExpr>), ok: true};
				} catch (_) {
					{value: (null : Ref<stdgo.go.ast.Ast.StarExpr>), ok: false};
				}, _pexpr = __tmp__.value, _0 = __tmp__.ok;
				if (_pexpr != null) {
					if (_ptr) {
						return {_0: false, _1: null};
					};
					_ptr = true;
					_typ = _unparen(_pexpr.x);
				};
			};
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_typ) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>), ok: true};
			} catch (_) {
				{value: (null : Ref<stdgo.go.ast.Ast.Ident>), ok: false};
			}, _name = __tmp__.value, _1 = __tmp__.ok;
			if (_name == null) {
				return {_0: false, _1: null};
			};
			var _obj:Object = _check._pkg._scope.lookup(_name.name);
			if (_obj == null) {
				return {_0: false, _1: null};
			};
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_obj) : Ref<TypeName>)) : Ref<TypeName>), ok: true};
			} catch (_) {
				{value: (null : Ref<TypeName>), ok: false};
			}, _tname = __tmp__.value, _4 = __tmp__.ok;
			if (_tname == null) {
				return {_0: false, _1: null};
			};
			if (_seen[_tname]) {
				return {_0: false, _1: null};
			};
			var _tdecl = _check._objMap[Go.asInterface(_tname)]._tdecl;
			if (!_tdecl.assign.isValid()) {
				return {_0: _ptr, _1: _tname};
			};
			_typ = _tdecl.type;
			if (_seen == null) {
				_seen = (new GoObjectMap<Ref<TypeName>,
					Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
						stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("TypeName", [], null, false,
							{get: () -> null})})},
					{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind)}))) : GoMap<Ref<TypeName>, Bool>);
			};
			_seen[_tname] = true;
		};
	}

	/**
		// unpackRecv unpacks a receiver type and returns its components: ptr indicates whether
		// rtyp is a pointer receiver, rname is the receiver type name, and tparams are its
		// type parameters, if any. The type parameters are only unpacked if unpackParams is
		// set. If rname is nil, the receiver is unusable (i.e., the source has a bug which we
		// cannot easily work around).
	**/
	@:keep
	static public function _unpackRecv(_check:Ref<Checker>, _rtyp:stdgo.go.ast.Ast.Expr,
			_unpackParams:Bool):{var _0:Bool; var _1:Ref<stdgo.go.ast.Ast.Ident>; var _2:Slice<Ref<stdgo.go.ast.Ast.Ident>>;} {
		return stdgo.internal.Macro.controlFlow({
			var _ptr:Bool = false,
				_rname:Ref<stdgo.go.ast.Ast.Ident> = (null : Ref<stdgo.go.ast.Ast.Ident>),
				_tparams:Slice<Ref<stdgo.go.ast.Ast.Ident>> = (null : Slice<Ref<stdgo.go.ast.Ast.Ident>>);
			@:label("L") while (true) {
				{
					final __type__ = _rtyp;
					{
						var __bool__ = true;
						while (__bool__) {
							__bool__ = false;
							if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ParenExpr>))) {
								var _t:Ref<stdgo.go.ast.Ast.ParenExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__()
									.value;
								_rtyp = _t.x;
							} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.StarExpr>))) {
								var _t:Ref<stdgo.go.ast.Ast.StarExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__()
									.value;
								_ptr = true;
								_rtyp = _t.x;
							} else {
								var _t:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
								@:jump("L") break;
							};
							break;
						};
					};
				};
			};
			{
				final __type__ = _rtyp;
				if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexExpr>))
					|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexListExpr>))) {
					var _ix = go.internal.typeparams.Typeparams.unpackIndexExpr(_rtyp);
					_rtyp = _ix.indexListExpr.x;
					if (_unpackParams) {
						for (_0 => _arg in _ix.indexListExpr.indices) {
							var _par:Ref<stdgo.go.ast.Ast.Ident> = (null : Ref<stdgo.go.ast.Ast.Ident>);
							{
								final __type__ = _arg;
								if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ident>))) {
									var _arg:Ref<stdgo.go.ast.Ast.Ident> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__()
										.value;
									_par = _arg;
								} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BadExpr>))) {
									var _arg:Ref<stdgo.go.ast.Ast.BadExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BadExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BadExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BadExpr>) : __type__.__underlying__()
										.value;
								} else if (__type__ == null) {
									var _arg:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
									_check._invalidAST(_ix.orig, ("parameterized receiver contains nil parameters" : GoString));
								} else {
									var _arg:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
									_check._errorf(_arg, (131 : T_errorCode), ("receiver type parameter %s must be an identifier" : GoString),
										Go.toInterface(_arg));
								};
							};
							if (_par == null) {
								_par = (({namePos: _arg.pos(), name: ("_" : GoString)} : stdgo.go.ast.Ast.Ident) : Ref<stdgo.go.ast.Ast.Ident>);
							};
							_tparams = _tparams.__appendref__(_par);
						};
					};
				};
			};
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_rtyp) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>), ok: true};
				} catch (_) {
					{value: (null : Ref<stdgo.go.ast.Ast.Ident>), ok: false};
				}, _name = __tmp__.value, _1 = __tmp__.ok;
				if (_name != null) {
					_rname = _name;
				};
			};
			return {_0: _ptr, _1: _rname, _2: _tparams};
		});
	}

	/**
		// collectObjects collects all file and package objects and inserts them
		// into their respective scopes. It also performs imports and associates
		// methods with receiver base type names.
	**/
	@:keep
	static public function _collectObjects(_check:Ref<Checker>):Void {
		var _pkg = _check._pkg;
		var _pkgImports:GoMap<Ref<Package>, Bool> = (new GoObjectMap<Ref<Package>,
			Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({
			get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("Package", [], null, false,
				{get: () -> null})})
		},
			{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind)}))) : GoMap<Ref<Package>, Bool>);
		for (_2 => _imp in _pkg._imports) {
			_pkgImports[_imp] = true;
		};
		{};
		var _methods:Slice<T_methodInfo__collectObjects_0> = (null : Slice<T_methodInfo__collectObjects_0>);
		var _fileScopes:Slice<Ref<Scope>> = (null : Slice<Ref<Scope>>);
		for (_fileNo => _file in _check._files) {
			_check._recordDef(_file.name, (null : Object));
			var _0:stdgo.go.token.Token.Pos = _file.pos(),
				_1:stdgo.go.token.Token.Pos = _file.end(),
				_end:stdgo.go.token.Token.Pos = _1,
				_pos:stdgo.go.token.Token.Pos = _0;
			{
				var _f = _check._fset.file(_file.pos());
				if (_f != null) {
					{
						final __tmp__0 = (_f.base() : stdgo.go.token.Token.Pos);
						final __tmp__1 = (_f.base() + _f.size():stdgo.go.token.Token.Pos);
						_pos = __tmp__0;
						_end = __tmp__1;
					};
				};
			};
			var _fileScope = newScope(_check._pkg._scope, _pos, _end, _check._filename(_fileNo));
			_fileScopes = _fileScopes.__appendref__(_fileScope);
			_check._recordScope(Go.asInterface(_file), _fileScope);
			var _fileDir:GoString = _dir(_check._fset.position(_file.name.pos()).filename);
			_check._walkDecls(_file.decls, function(_d:T_decl):Void {
				{
					final __type__ = _d;
					if (Go.typeEquals((__type__ : T_importDecl))) {
						var _d:T_importDecl = __type__ == null ? ({} : T_importDecl) : __type__.__underlying__() == null ? ({} : T_importDecl) : __type__ == null ? ({} : T_importDecl) : __type__.__underlying__()
							.value;
						var __tmp__ = _validatedImportPath(_d._spec.path.value),
							_path:GoString = __tmp__._0,
							_err:Error = __tmp__._1;
						if (_err != null) {
							_check._errorf(Go.asInterface(_d._spec.path), (5 : T_errorCode), ("invalid import path (%s)" : GoString), Go.toInterface(_err));
							return;
						};
						var _imp = _check._importPackage(Go.asInterface(_d._spec.path), _path, _fileDir);
						if (_imp == null) {
							return;
						};
						var _name:GoString = _imp._name;
						if (_d._spec.name != null) {
							_name = _d._spec.name.name;
							if (_path == (("C" : GoString))) {
								_check._errorf(Go.asInterface(_d._spec.name), (7 : T_errorCode), ("cannot rename import \"C\"" : GoString));
								return;
							};
						};
						if (_name == (("init" : GoString))) {
							_check._errorf(Go.asInterface(_d._spec), (39 : T_errorCode), ("cannot import package as init - init must be a func" : GoString));
							return;
						};
						if (!_pkgImports[_imp]) {
							_pkgImports[_imp] = true;
							_pkg._imports = _pkg._imports.__appendref__(_imp);
						};
						var _pkgName = newPkgName(_d._spec.pos(), _pkg, _name, _imp);
						if (_d._spec.name != null) {
							_check._recordDef(_d._spec.name, Go.asInterface(_pkgName));
						} else {
							_check._recordImplicit(Go.asInterface(_d._spec), Go.asInterface(_pkgName));
						};
						if (_imp._fake) {
							_pkgName._used = true;
						};
						_check._imports = _check._imports.__appendref__(_pkgName);
						if (_name == (("." : GoString))) {
							if (_check._dotImportMap == null) {
								_check._dotImportMap = (new GoObjectMap<T_dotImportKey,
									Ref<PkgName>>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({
									get: () -> stdgo.internal.reflect.Reflect.GoType.named("T_dotImportKey", [], null, false, {get: () -> null})
								},
									{get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () ->
											stdgo.internal.reflect.Reflect.GoType.named("PkgName", [], null, false, {get: () ->
												null})})}))) : GoMap<T_dotImportKey, Ref<PkgName>>);
							};
							for (_name => _obj in _imp._scope._elems) {
								if (stdgo.go.token.Token.isExported(_name)) {
									{
										var _alt:Object = _fileScope.lookup(_name);
										if (_alt != null) {
											_check._errorf(Go.asInterface(_d._spec.name), (10 : T_errorCode), ("%s redeclared in this block" : GoString),
												Go.toInterface(_alt.name()));
											_check._reportAltDecl(_alt);
										} else {
											_fileScope._insert(_name, _obj);
											_check._dotImportMap[(new T_dotImportKey(_fileScope, _name) : T_dotImportKey)] = _pkgName;
										};
									};
								};
							};
						} else {
							_check._declare(_fileScope, null, Go.asInterface(_pkgName), (0 : stdgo.go.token.Token.Pos));
						};
					} else if (Go.typeEquals((__type__ : T_constDecl))) {
						var _d:T_constDecl = __type__ == null ? ({} : T_constDecl) : __type__.__underlying__() == null ? ({} : T_constDecl) : __type__ == null ? ({} : T_constDecl) : __type__.__underlying__()
							.value;
						for (_i => _name in _d._spec.names) {
							var _obj = newConst(_name.pos(), _pkg, _name.name, (null : Type), stdgo.go.constant.Constant.makeInt64((_d._iota : GoInt64)));
							var _init:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
							if (_i < (_d._init.length)) {
								_init = _d._init[(_i : GoInt)];
							};
							var _d = (({
								_file: _fileScope,
								_vtyp: _d._typ,
								_init: _init,
								_inherited: _d._inherited
							} : T_declInfo) : Ref<T_declInfo>);
							_check._declarePkgObj(_name, Go.asInterface(_obj), _d);
						};
					} else if (Go.typeEquals((__type__ : T_varDecl))) {
						var _d:T_varDecl = __type__ == null ? ({} : T_varDecl) : __type__.__underlying__() == null ? ({} : T_varDecl) : __type__ == null ? ({} : T_varDecl) : __type__.__underlying__()
							.value;
						var _lhs = new Slice<Ref<Var>>((_d._spec.names.length : GoInt).toBasic(), 0,
							...[for (i in 0...(_d._spec.names.length : GoInt).toBasic()) (null : Ref<Var>)]);
						var _d1:Ref<T_declInfo> = (null : Ref<T_declInfo>);
						if ((_d._spec.values.length) == ((1 : GoInt))) {
							_d1 = (({
								_file: _fileScope,
								_lhs: _lhs,
								_vtyp: _d._spec.type,
								_init: _d._spec.values[(0 : GoInt)]
							} : T_declInfo) : Ref<T_declInfo>);
						};
						for (_i => _name in _d._spec.names) {
							var _obj = newVar(_name.pos(), _pkg, _name.name, (null : Type));
							_lhs[(_i : GoInt)] = _obj;
							var _di = _d1;
							if (_di == null) {
								var _init:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
								if (_i < (_d._spec.values.length)) {
									_init = _d._spec.values[(_i : GoInt)];
								};
								_di = (({_file: _fileScope, _vtyp: _d._spec.type, _init: _init} : T_declInfo) : Ref<T_declInfo>);
							};
							_check._declarePkgObj(_name, Go.asInterface(_obj), _di);
						};
					} else if (Go.typeEquals((__type__ : T_typeDecl))) {
						var _d:T_typeDecl = __type__ == null ? ({} : T_typeDecl) : __type__.__underlying__() == null ? ({} : T_typeDecl) : __type__ == null ? ({} : T_typeDecl) : __type__.__underlying__()
							.value;
						if ((_d._spec.typeParams.numFields() != (0 : GoInt)) && !_check._allowVersion(_pkg, (1 : GoInt), (18 : GoInt))) {
							_check._softErrorf(Go.asInterface(_d._spec.typeParams.list[(0 : GoInt)]), (135 : T_errorCode),
								("type parameters require go1.18 or later" : GoString));
						};
						var _obj = newTypeName(_d._spec.name.pos(), _pkg, _d._spec.name.name, (null : Type));
						_check._declarePkgObj(_d._spec.name, Go.asInterface(_obj), (({_file: _fileScope, _tdecl: _d._spec} : T_declInfo) : Ref<T_declInfo>));
					} else if (Go.typeEquals((__type__ : T_funcDecl))) {
						var _d:T_funcDecl = __type__ == null ? ({} : T_funcDecl) : __type__.__underlying__() == null ? ({} : T_funcDecl) : __type__ == null ? ({} : T_funcDecl) : __type__.__underlying__()
							.value;
						var _name:GoString = _d._decl.name.name;
						var _obj = newFunc(_d._decl.name.pos(), _pkg, _name, null);
						var _hasTParamError:Bool = false;
						if (_d._decl.recv.numFields() == ((0 : GoInt))) {
							if (_d._decl.recv != null) {
								_check._error(Go.asInterface(_d._decl.recv), (31 : T_errorCode), ("method is missing receiver" : GoString));
							};
							if ((_name == ("init" : GoString))
								|| ((_name == ("main" : GoString)) && (_check._pkg._name == ("main" : GoString)))) {
								var _code:T_errorCode = (39 : T_errorCode);
								if (_name == (("main" : GoString))) {
									_code = (40 : T_errorCode);
								};
								if (_d._decl.type.typeParams.numFields() != ((0 : GoInt))) {
									_check._softErrorf(Go.asInterface(_d._decl.type.typeParams.list[(0 : GoInt)]), _code,
										("func %s must have no type parameters" : GoString), Go.toInterface(_name));
									_hasTParamError = true;
								};
								{
									var _t = _d._decl.type;
									if ((_t.params.numFields() != (0 : GoInt)) || (_t.results != null)) {
										_check._softErrorf(Go.asInterface(_d._decl), _code,
											("func %s must have no arguments and no return values" : GoString), Go.toInterface(_name));
									};
								};
							};
							if (_name == (("init" : GoString))) {
								_obj._object._parent = _pkg._scope;
								_check._recordDef(_d._decl.name, Go.asInterface(_obj));
								if (_d._decl.body == null) {
									_check._softErrorf(Go.asInterface(_obj), (37 : T_errorCode), ("missing function body" : GoString));
								};
							} else {
								_check._declare(_pkg._scope, _d._decl.name, Go.asInterface(_obj), (0 : stdgo.go.token.Token.Pos));
							};
						} else {
							var __tmp__ = _check._unpackRecv(_d._decl.recv.list[(0 : GoInt)].type, false),
								_ptr:Bool = __tmp__._0,
								_recv:Ref<stdgo.go.ast.Ast.Ident> = __tmp__._1,
								_12:Slice<Ref<stdgo.go.ast.Ast.Ident>> = __tmp__._2;
							if ((_recv != null) && (_name != ("_" : GoString))) {
								_methods = _methods.__appendref__((new T_methodInfo__collectObjects_0(_obj, _ptr, _recv) : T_methodInfo__collectObjects_0));
							};
							_check._recordDef(_d._decl.name, Go.asInterface(_obj));
						};
						if (((_d._decl.type.typeParams.numFields() != (0 : GoInt))
							&& !_check._allowVersion(_pkg, (1 : GoInt), (18 : GoInt)))
							&& !_hasTParamError) {
							_check._softErrorf(Go.asInterface(_d._decl.type.typeParams.list[(0 : GoInt)]), (135 : T_errorCode),
								("type parameters require go1.18 or later" : GoString));
						};
						var _info = (({_file: _fileScope, _fdecl: _d._decl} : T_declInfo) : Ref<T_declInfo>);
						_check._objMap[Go.asInterface(_obj)] = _info;
						_obj._setOrder((_check._objMap.length : GoUInt32));
					};
				};
			});
		};
		for (_11 => _scope in _fileScopes) {
			for (_name => _obj in _scope._elems) {
				{
					var _alt:Object = _pkg._scope.lookup(_name);
					if (_alt != null) {
						_obj = _resolve(_name, _obj);
						{
							var __tmp__ = try {
								{value: (Go.typeAssert((Go.toInterface(_obj) : Ref<PkgName>)) : Ref<PkgName>), ok: true};
							} catch (_) {
								{value: (null : Ref<PkgName>), ok: false};
							}, _pkg = __tmp__.value, _ok = __tmp__.ok;
							if (_ok) {
								_check._errorf(_alt, (10 : T_errorCode), ("%s already declared through import of %s" : GoString), Go.toInterface(_alt.name()),
									Go.toInterface(Go.asInterface(_pkg.imported())));
								_check._reportAltDecl(Go.asInterface(_pkg));
							} else {
								_check._errorf(_alt, (10 : T_errorCode), ("%s already declared through dot-import of %s" : GoString),
									Go.toInterface(_alt.name()), Go.toInterface(Go.asInterface(_obj.pkg())));
								_check._reportAltDecl(_obj);
							};
						};
					};
				};
			};
		};
		if (_methods == null) {
			return;
		};
		_check._methods = (new GoObjectMap<Ref<TypeName>,
			Slice<Ref<Func>>>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({
			get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("TypeName", [], null, false,
				{get: () -> null})})
		},
			{get: () -> stdgo.internal.reflect.Reflect.GoType.sliceType({get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () ->
					stdgo.internal.reflect.Reflect.GoType.named("Func", [], null, false, {get: () -> null})})})}))) : GoMap<Ref<TypeName>, Slice<Ref<Func>>>);
		for (_i in 0..._methods.length.toBasic()) {
			var _m = (_methods[(_i : GoInt)] : Ref<T_methodInfo__collectObjects_0>);
			var __tmp__ = _check._resolveBaseTypeName(_m._ptr, _m._recv),
				_ptr:Bool = __tmp__._0,
				_base:Ref<TypeName> = __tmp__._1;
			if (_base != null) {
				_m._obj._hasPtrRecv_ = _ptr;
				_check._methods[_base] = _check._methods[_base].__appendref__(_m._obj);
			};
		};
	}

	@:keep
	static public function _importPackage(_check:Ref<Checker>, _at:T_positioner, _path:GoString, _dir:GoString):Ref<Package> {
		var _key:T_importKey = (new T_importKey(_path, _dir) : T_importKey);
		var _imp = _check._impMap[(_key == null ? null : _key.__copy__())];
		if (_imp != null) {
			return _imp;
		};
		if ((_path == ("C" : GoString)) && (_check._conf.fakeImportC || _check._conf._go115UsesCgo)) {
			_imp = newPackage(("C" : GoString), ("C" : GoString));
			_imp._fake = true;
			_imp._cgo = _check._conf._go115UsesCgo;
		} else {
			var _err:Error = (null : Error);
			{
				var _importer:Importer = _check._conf.importer;
				if (_importer == null) {
					_err = stdgo.fmt.Fmt.errorf(("Config.Importer not installed" : GoString));
				} else {
					var __tmp__ = try {
						{value: (Go.typeAssert((Go.toInterface(_importer) : ImporterFrom)) : ImporterFrom), ok: true};
					} catch (_) {
						{value: (null : ImporterFrom), ok: false};
					}, _importerFrom = __tmp__.value, _ok = __tmp__.ok;
					if (_ok) {
						{
							var __tmp__ = _importerFrom.importFrom(_path, _dir, (0 : ImportMode));
							_imp = __tmp__._0;
							_err = __tmp__._1;
						};
						if ((_imp == null) && (_err == null)) {
							_err = stdgo.fmt.Fmt.errorf(("Config.Importer.ImportFrom(%s, %s, 0) returned nil but no error" : GoString), Go.toInterface(_path),
								Go.toInterface(_dir));
						};
					} else {
						{
							var __tmp__ = _importer.import_(_path);
							_imp = __tmp__._0;
							_err = __tmp__._1;
						};
						if ((_imp == null) && (_err == null)) {
							_err = stdgo.fmt.Fmt.errorf(("Config.Importer.Import(%s) returned nil but no error" : GoString), Go.toInterface(_path));
						};
					};
				};
			};
			if (((_err == null) && (_imp != null)) && ((_imp._name == ("_" : GoString)) || (_imp._name == Go.str()))) {
				_err = stdgo.fmt.Fmt.errorf(("invalid package name: %q" : GoString), Go.toInterface(_imp._name));
				_imp = null;
			};
			if (_err != null) {
				_check._errorf(_at, (6 : T_errorCode), ("could not import %s (%s)" : GoString), Go.toInterface(_path), Go.toInterface(_err));
				if (_imp == null) {
					var _name:GoString = _path;
					{
						var _i:GoInt = (_name.length);
						if ((_i > (0 : GoInt)) && (_name[(_i - (1 : GoInt) : GoInt)] == (47 : GoUInt8))) {
							_name = (_name.__slice__(0, _i - (1 : GoInt)) : GoString);
						};
					};
					{
						var _i:GoInt = stdgo.strings.Strings.lastIndex(_name, ("/" : GoString));
						if (_i >= (0 : GoInt)) {
							_name = (_name.__slice__(_i + (1 : GoInt)) : GoString);
						};
					};
					_imp = newPackage(_path, _name);
				};
				_imp._fake = true;
			};
		};
		if (_imp._complete || _imp._fake) {
			_check._impMap[(_key == null ? null : _key.__copy__())] = _imp;
			if (_check._pkgPathMap != null) {
				_check._markImports(_imp);
			};
			return _imp;
		};
		return null;
	}

	/**
		// filename returns a filename suitable for debugging output.
	**/
	@:keep
	static public function _filename(_check:Ref<Checker>, _fileNo:GoInt):GoString {
		var _file = _check._files[(_fileNo : GoInt)];
		{
			var _pos:stdgo.go.token.Token.Pos = _file.pos();
			if (_pos.isValid()) {
				return _check._fset.file(_pos).name();
			};
		};
		return stdgo.fmt.Fmt.sprintf(("file[%d]" : GoString), Go.toInterface(_fileNo));
	}

	/**
		// declarePkgObj declares obj in the package scope, records its ident -> obj mapping,
		// and updates check.objMap. The object must not be a function or method.
	**/
	@:keep
	static public function _declarePkgObj(_check:Ref<Checker>, _ident:Ref<stdgo.go.ast.Ast.Ident>, _obj:Object, _d:Ref<T_declInfo>):Void {
		_assert(_ident.name == (_obj.name()));
		if (_ident.name == (("init" : GoString))) {
			_check._errorf(Go.asInterface(_ident), (39 : T_errorCode), ("cannot declare init - must be func" : GoString));
			return;
		};
		if ((_ident.name == ("main" : GoString)) && (_check._pkg._name == ("main" : GoString))) {
			_check._errorf(Go.asInterface(_ident), (40 : T_errorCode), ("cannot declare main - must be func" : GoString));
			return;
		};
		_check._declare(_check._pkg._scope, _ident, _obj, (0 : stdgo.go.token.Token.Pos));
		_check._objMap[_obj] = _d;
		_obj._setOrder((_check._objMap.length : GoUInt32));
	}

	/**
		// arityMatch checks that the lhs and rhs of a const or var decl
		// have the appropriate number of names and init exprs. For const
		// decls, init is the value spec providing the init exprs; for
		// var decls, init is nil (the init exprs are in s in this case).
	**/
	@:keep
	static public function _arityMatch(_check:Ref<Checker>, _s:Ref<stdgo.go.ast.Ast.ValueSpec>, _init:Ref<stdgo.go.ast.Ast.ValueSpec>):Void {
		var _l:GoInt = (_s.names.length);
		var _r:GoInt = (_s.values.length);
		if (_init != null) {
			_r = (_init.values.length);
		};
		{};
		if ((_init == null) && (_r == (0 : GoInt))) {
			if (_s.type == null) {
				_check._errorf(Go.asInterface(_s), (17 : T_errorCode), ("missing type or init expr" : GoString));
			};
		} else if (_l < _r) {
			if (_l < (_s.values.length)) {
				var _n:stdgo.go.ast.Ast.Expr = _s.values[(_l : GoInt)];
				_check._errorf(_n, (17 : T_errorCode), ("extra init expr %s" : GoString), Go.toInterface(_n));
			} else {
				_check._errorf(Go.asInterface(_s), (17 : T_errorCode), ("extra init expr at %s" : GoString),
					Go.toInterface(Go.asInterface(_check._fset.position(_init.pos()))));
			};
		} else if ((_l > _r) && ((_init != null) || (_r != (1 : GoInt)))) {
			var _n = _s.names[(_r : GoInt)];
			_check._errorf(Go.asInterface(_n), (17 : T_errorCode), ("missing init expr for %s" : GoString), Go.toInterface(Go.asInterface(_n)));
		};
	}

	/**
		// context returns the type-checker context.
	**/
	@:keep
	static public function _context(_check:Ref<Checker>):Ref<Context> {
		if (_check._ctxt == null) {
			_check._ctxt = newContext();
		};
		return _check._ctxt;
	}

	/**
		// newNamedInstance creates a new named instance for the given origin and type
		// arguments, recording pos as the position of its synthetic object (for error
		// reporting).
		//
		// If set, expanding is the named type instance currently being expanded, that
		// led to the creation of this instance.
	**/
	@:keep
	static public function _newNamedInstance(_check:Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _orig:Ref<Named>, _targs:Slice<Type>,
			_expanding:Ref<Named>):Ref<Named> {
		_assert((_targs.length) > (0 : GoInt));
		var _obj = newTypeName(_pos, _orig._obj._object._pkg, _orig._obj._object._name, (null : Type));
		var _inst = (({_orig: _orig, _targs: _newTypeList(_targs)} : T_instance) : Ref<T_instance>);
		if ((_expanding != null) && (_expanding.obj()._object._pkg == _obj._object._pkg)) {
			_inst._ctxt = _expanding._inst._ctxt;
		};
		var _typ = (({_check: _check, _obj: _obj, _inst: _inst} : Named) : Ref<Named>);
		_obj._object._typ = Go.asInterface(_typ);
		if (_check != null) {
			_check._needsCleanup(Go.asInterface(_typ));
		};
		return _typ;
	}

	/**
		// newNamed is like NewNamed but with a *Checker receiver and additional orig argument.
	**/
	@:keep
	static public function _newNamed(_check:Ref<Checker>, _obj:Ref<TypeName>, _underlying:Type, _methods:Slice<Ref<Func>>):Ref<Named> {
		var _typ = (({
			_check: _check,
			_obj: _obj,
			_fromRHS: _underlying,
			_underlying: _underlying,
			_methods: _methods
		} : Named) : Ref<Named>);
		if (_obj._object._typ == null) {
			_obj._object._typ = Go.asInterface(_typ);
		};
		if (_check != null) {
			_check._needsCleanup(Go.asInterface(_typ));
		};
		return _typ;
	}

	@:keep
	static public function _reportInstanceLoop(_check:Ref<Checker>, _v:GoInt):Void {
		var _stack:Slice<GoInt> = (null : Slice<GoInt>);
		var _seen = new Slice<Bool>((_check._mono._vertices.length : GoInt).toBasic(), 0,
			...[for (i in 0...(_check._mono._vertices.length : GoInt).toBasic()) false]);
		while (!_seen[(_v : GoInt)]) {
			_stack = _stack.__appendref__(_v);
			_seen[(_v : GoInt)] = true;
			_v = _check._mono._edges[(_check._mono._vertices[(_v : GoInt)]._pre : GoInt)]._src;
		};
		while (_stack[(0 : GoInt)] != (_v)) {
			_stack = (_stack.__slice__((1 : GoInt)) : Slice<GoInt>);
		};
		var _obj0 = _check._mono._vertices[(_v : GoInt)]._obj;
		_check._errorf(Go.asInterface(_obj0), (140 : T_errorCode), ("instantiation cycle:" : GoString));
		var _qf:Qualifier = relativeTo(_check._pkg);
		for (_10 => _v in _stack) {
			var _edge:T_monoEdge = (_check._mono._edges[(_check._mono._vertices[(_v : GoInt)]._pre : GoInt)] == null ? null : _check._mono._edges[(_check._mono._vertices[(_v : GoInt)]._pre : GoInt)].__copy__());
			var _obj = _check._mono._vertices[(_edge._dst : GoInt)]._obj;
			{
				final __type__ = _obj.type();
				if (Go.typeEquals((__type__ : Ref<Named>))) {
					_check._errorf(Go.asInterface((_edge._pos : T_atPos)), (140 : T_errorCode), ("\t%s implicitly parameterized by %s" : GoString),
						Go.toInterface(_obj.name()), Go.toInterface(typeString(_edge._typ, _qf)));
				} else if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
					_check._errorf(Go.asInterface((_edge._pos : T_atPos)), (140 : T_errorCode), ("\t%s instantiated as %s" : GoString),
						Go.toInterface(_obj.name()), Go.toInterface(typeString(_edge._typ, _qf)));
				} else {
					throw Go.toInterface(("unexpected type" : GoString));
				};
			};
		};
	}

	@:keep
	static public function _monomorph(_check:Ref<Checker>):Void {
		var _again:Bool = true;
		while (_again) {
			_again = false;
			for (_i => _edge in _check._mono._edges) {
				var _src = (_check._mono._vertices[(_edge._src : GoInt)] : Ref<T_monoVertex>);
				var _dst = (_check._mono._vertices[(_edge._dst : GoInt)] : Ref<T_monoVertex>);
				var _w:GoInt = _src._weight + _edge._weight;
				if (_w <= _dst._weight) {
					continue;
				};
				_dst._pre = _i;
				_dst._len = _src._len + (1 : GoInt);
				if (_dst._len == ((_check._mono._vertices.length))) {
					_check._reportInstanceLoop(_edge._dst);
					return;
				};
				_dst._weight = _w;
				_again = true;
			};
		};
	}

	/**
		// newAssertableTo reports whether a value of type V can be asserted to have type T.
		// It also implements behavior for interfaces that currently are only permitted
		// in constraint position (we have not yet defined that behavior in the spec).
	**/
	@:keep
	static public function _newAssertableTo(_check:Ref<Checker>, v:Ref<Interface>, t:Type):Error {
		if (isInterface(t)) {
			return (null : Error);
		};
		return _check._implements(t, Go.asInterface(v));
	}

	/**
		// assertableTo reports whether a value of type V can be asserted to have type T.
		// It returns (nil, false) as affirmative answer. Otherwise it returns a missing
		// method required by V and whether it is missing or just has the wrong type.
		// The receiver may be nil if assertableTo is invoked through an exported API call
		// (such as AssertableTo), i.e., when all methods have been type-checked.
		// TODO(gri) replace calls to this function with calls to newAssertableTo.
	**/
	@:keep
	static public function _assertableTo(_check:Ref<Checker>, v:Ref<Interface>, t:Type):{var _0:Ref<Func>; var _1:Ref<Func>;} {
		var _method:Ref<Func> = (null : Ref<Func>),
			_wrongType:Ref<Func> = (null : Ref<Func>);
		if (isInterface(t)) {
			return {_0: _method, _1: _wrongType};
		};
		return _check._missingMethod(t, v, false);
	}

	/**
		// check may be nil.
	**/
	@:keep
	static public function _funcString(_check:Ref<Checker>, _f:Ref<Func>):GoString {
		var _buf = stdgo.bytes.Bytes.newBufferString(_f._object._name);
		var _qf:Qualifier = (null : Qualifier);
		if (_check != null) {
			_qf = _check._qualifier;
		};
		writeSignature(_buf, (Go.typeAssert((Go.toInterface(_f._object._typ) : Ref<Signature>)) : Ref<Signature>), _qf);
		return (_buf.string() : GoString);
	}

	/**
		// check may be nil.
	**/
	@:keep
	static public function _interfacePtrError(_check:Ref<Checker>, t:Type):GoString {
		_assert(_isInterfacePtr(t));
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_under(t)) : Ref<Pointer_>)) : Ref<Pointer_>), ok: true};
			} catch (_) {
				{value: (null : Ref<Pointer_>), ok: false};
			}, _p = __tmp__.value, _0 = __tmp__.ok;
			if (_isTypeParam(_p._base)) {
				return _check._sprintf(("type %s is pointer to type parameter, not type parameter" : GoString), Go.toInterface(t));
			};
		};
		return _check._sprintf(("type %s is pointer to interface, not interface" : GoString), Go.toInterface(t));
	}

	/**
		// missingMethodReason returns a string giving the detailed reason for a missing method m,
		// where m is missing from V, but required by T. It puts the reason in parentheses,
		// and may include more have/want info after that. If non-nil, alt is a relevant
		// method that matches in some way. It may have the correct name, but wrong type, or
		// it may have a pointer receiver, or it may have the correct name except wrong case.
		// check may be nil.
	**/
	@:keep
	static public function _missingMethodReason(_check:Ref<Checker>, v:Type, t:Type, _m:Ref<Func>, _alt:Ref<Func>):GoString {
		var _mname:GoString = ("" : GoString);
		if ((_check != null) && false) {
			_mname = _m.name() + (" method" : GoString);
		} else {
			_mname = ("method " : GoString) + _m.name();
		};
		if (_alt != null) {
			if (_m.name() != (_alt.name())) {
				return _check._sprintf(("(missing %s)\n\t\thave %s\n\t\twant %s" : GoString), Go.toInterface(_mname),
					Go.toInterface(_check._funcString(_alt)), Go.toInterface(_check._funcString(_m)));
			};
			if (identical(_m._object._typ, _alt._object._typ)) {
				return _check._sprintf(("(%s has pointer receiver)" : GoString), Go.toInterface(_mname));
			};
			return _check._sprintf(("(wrong type for %s)\n\t\thave %s\n\t\twant %s" : GoString), Go.toInterface(_mname),
				Go.toInterface(_check._funcString(_alt)), Go.toInterface(_check._funcString(_m)));
		};
		if (_isInterfacePtr(v)) {
			return (("(" : GoString) + _check._interfacePtrError(v)) + (")" : GoString);
		};
		if (_isInterfacePtr(t)) {
			return (("(" : GoString) + _check._interfacePtrError(t)) + (")" : GoString);
		};
		return _check._sprintf(("(missing %s)" : GoString), Go.toInterface(_mname));
	}

	/**
		// missingMethod is like MissingMethod but accepts a *Checker as receiver.
		// The receiver may be nil if missingMethod is invoked through an exported
		// API call (such as MissingMethod), i.e., when all methods have been type-
		// checked.
		//
		// If a method is missing on T but is found on *T, or if a method is found
		// on T when looked up with case-folding, this alternative method is returned
		// as the second result.
	**/
	@:keep
	static public function _missingMethod(_check:Ref<Checker>, v:Type, t:Ref<Interface>, _static:Bool):{var _0:Ref<Func>; var _1:Ref<Func>;} {
		var _method:Ref<Func> = (null : Ref<Func>),
			_alt:Ref<Func> = (null : Ref<Func>);
		if (t.numMethods() == ((0 : GoInt))) {
			return {_0: _method, _1: _alt};
		};
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_under(v)) : Ref<Interface>)) : Ref<Interface>), ok: true};
			} catch (_) {
				{value: (null : Ref<Interface>), ok: false};
			}, _u = __tmp__.value, _0 = __tmp__.ok;
			if (_u != null) {
				var _tset = _u._typeSet();
				for (_1 => _m in t._typeSet()._methods) {
					var __tmp__ = _tset.lookupMethod(_m._object._pkg, _m._object._name, false),
						_2:GoInt = __tmp__._0,
						_f:Ref<Func> = __tmp__._1;
					if (_f == null) {
						if (!_static) {
							continue;
						};
						return {_0: _m, _1: null};
					};
					if (!identical(_f._object._typ, _m._object._typ)) {
						return {_0: _m, _1: _f};
					};
				};
				return {_0: _method, _1: _alt};
			};
		};
		for (_3 => _m in t._typeSet()._methods) {
			var __tmp__ = _lookupFieldOrMethod(v, false, _m._object._pkg, _m._object._name, false),
				_obj:Object = __tmp__._0,
				_4:Slice<GoInt> = __tmp__._1,
				_5:Bool = __tmp__._2;
			var _found:Bool = _obj != null;
			if (!_found) {
				{
					var __tmp__ = _lookupFieldOrMethod(Go.asInterface(newPointer(v)), false, _m._object._pkg, _m._object._name, false);
					_obj = __tmp__._0;
				};
				if (_obj == null) {
					{
						var __tmp__ = _lookupFieldOrMethod(v, false, _m._object._pkg, _m._object._name, true);
						_obj = __tmp__._0;
					};
				};
			};
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_obj) : Ref<Func>)) : Ref<Func>), ok: true};
			} catch (_) {
				{value: (null : Ref<Func>), ok: false};
			}, _f = __tmp__.value, _6 = __tmp__.ok;
			if (_f == null) {
				return {_0: _m, _1: null};
			};
			if (_check != null) {
				_check._objDecl(Go.asInterface(_f), null);
			};
			if (!_found || !identical(_f._object._typ, _m._object._typ)) {
				return {_0: _m, _1: _f};
			};
		};
		return {_0: _method, _1: _alt};
	}

	/**
		// blockBranches processes a block's statement list and returns the set of outgoing forward jumps.
		// all is the scope of all declared labels, parent the set of labels declared in the immediately
		// enclosing block, and lstmt is the labeled statement this block is associated with (or nil).
	**/
	@:keep
	static public function _blockBranches(_check:Ref<Checker>, _all:Ref<Scope>, _parent:Ref<T_block>, _lstmt:Ref<stdgo.go.ast.Ast.LabeledStmt>,
			_list:Slice<stdgo.go.ast.Ast.Stmt>):Slice<Ref<stdgo.go.ast.Ast.BranchStmt>> {
		var _b = (({_parent: _parent, _lstmt: _lstmt} : T_block) : Ref<T_block>);
		var _0:stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos),
			_1:Slice<Ref<stdgo.go.ast.Ast.BranchStmt>> = (null : Slice<Ref<stdgo.go.ast.Ast.BranchStmt>>),
			_2:Slice<Ref<stdgo.go.ast.Ast.BranchStmt>> = (null : Slice<Ref<stdgo.go.ast.Ast.BranchStmt>>),
			_badJumps:Slice<Ref<stdgo.go.ast.Ast.BranchStmt>> = _2,
			_fwdJumps:Slice<Ref<stdgo.go.ast.Ast.BranchStmt>> = _1,
			_varDeclPos:stdgo.go.token.Token.Pos = _0;
		var _recordVarDecl:stdgo.go.token.Token.Pos->Void = function(_pos:stdgo.go.token.Token.Pos):Void {
			_varDeclPos = _pos;
			_badJumps = ((_badJumps.__slice__(0, (0 : GoInt)) : Slice<Ref<stdgo.go.ast.Ast.BranchStmt>>).__append__(..._fwdJumps.__toArray__()));
		};
		var _jumpsOverVarDecl = function(_jmp:Ref<stdgo.go.ast.Ast.BranchStmt>):Bool {
			if (_varDeclPos.isValid()) {
				for (_0 => _bad in _badJumps) {
					if (_jmp == (_bad)) {
						return true;
					};
				};
			};
			return false;
		};
		var _blockBranches = function(_lstmt:Ref<stdgo.go.ast.Ast.LabeledStmt>, _list:Slice<stdgo.go.ast.Ast.Stmt>):Void {
			_fwdJumps = _fwdJumps.__appendref__(..._check._blockBranches(_all, _b, _lstmt, _list).__toArray__());
		};
		var _stmtBranches:stdgo.go.ast.Ast.Stmt->Void = null;
		_stmtBranches = function(_s:stdgo.go.ast.Ast.Stmt):Void {
			{
				final __type__ = _s;
				if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.DeclStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.DeclStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.DeclStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.DeclStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.DeclStmt>) : __type__.__underlying__()
						.value;
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_s.decl) : Ref<stdgo.go.ast.Ast.GenDecl>)) : Ref<stdgo.go.ast.Ast.GenDecl>), ok: true};
						} catch (_) {
							{value: (null : Ref<stdgo.go.ast.Ast.GenDecl>), ok: false};
						}, _d = __tmp__.value, _0 = __tmp__.ok;
						if ((_d != null) && (_d.tok == (85 : stdgo.go.token.Token.Token))) {
							_recordVarDecl(_d.pos());
						};
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.LabeledStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.LabeledStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__()
						.value;
					{
						var _name:GoString = _s.label.name;
						if (_name != (("_" : GoString))) {
							var _lbl = newLabel(_s.label.pos(), _check._pkg, _name);
							{
								var _alt:Object = _all.insert(Go.asInterface(_lbl));
								if (_alt != null) {
									_check._softErrorf(Go.asInterface(_lbl), (120 : T_errorCode), ("label %s already declared" : GoString),
										Go.toInterface(_name));
									_check._reportAltDecl(_alt);
								} else {
									_b._insert(_s);
									_check._recordDef(_s.label, Go.asInterface(_lbl));
								};
							};
							var _i:GoInt = (0 : GoInt);
							for (_3 => _jmp in _fwdJumps) {
								if (_jmp.label.name == (_name)) {
									_lbl._used = true;
									_check._recordUse(_jmp.label, Go.asInterface(_lbl));
									if (_jumpsOverVarDecl(_jmp)) {
										_check._softErrorf(Go.asInterface(_jmp.label), (123 : T_errorCode),
											("goto %s jumps over variable declaration at line %d" : GoString), Go.toInterface(_name),
											Go.toInterface(_check._fset.position(_varDeclPos).line));
									};
								} else {
									_fwdJumps[(_i : GoInt)] = _jmp;
									_i++;
								};
							};
							_fwdJumps = (_fwdJumps.__slice__(0, _i) : Slice<Ref<stdgo.go.ast.Ast.BranchStmt>>);
							_lstmt = _s;
						};
					};
					_stmtBranches(_s.stmt);
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BranchStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.BranchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__()
						.value;
					if (_s.label == null) {
						return;
					};
					var _name:GoString = _s.label.name;
					if (_s.tok == ((61 : stdgo.go.token.Token.Token))) {
						var _valid:Bool = false;
						{
							var _t = _b._enclosingTarget(_name);
							if (_t != null) {
								{
									final __type__ = _t.stmt;
									if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SwitchStmt>))
										|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>))
										|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectStmt>))
										|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ForStmt>))
										|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.RangeStmt>))) {
										_valid = true;
									};
								};
							};
						};
						if (!_valid) {
							_check._errorf(Go.asInterface(_s.label), (121 : T_errorCode), ("invalid break label %s" : GoString), Go.toInterface(_name));
							return;
						};
					} else if (_s.tok == ((65 : stdgo.go.token.Token.Token))) {
						var _valid:Bool = false;
						{
							var _t = _b._enclosingTarget(_name);
							if (_t != null) {
								{
									final __type__ = _t.stmt;
									if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ForStmt>))
										|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.RangeStmt>))) {
										_valid = true;
									};
								};
							};
						};
						if (!_valid) {
							_check._errorf(Go.asInterface(_s.label), (121 : T_errorCode), ("invalid continue label %s" : GoString), Go.toInterface(_name));
							return;
						};
					} else if (_s.tok == ((73 : stdgo.go.token.Token.Token))) {
						if (_b._gotoTarget(_name) == null) {
							_fwdJumps = _fwdJumps.__appendref__(_s);
							return;
						};
					} else {
						_check._invalidAST(Go.asInterface(_s), ("branch statement: %s %s" : GoString), Go.toInterface(Go.asInterface(_s.tok)),
							Go.toInterface(_name));
						return;
					};
					var _obj:Object = _all.lookup(_name);
					(Go.typeAssert((Go.toInterface(_obj) : Ref<Label>)) : Ref<Label>)._used = true;
					_check._recordUse(_s.label, _obj);
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.AssignStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.AssignStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__()
						.value;
					if (_s.tok == ((47 : stdgo.go.token.Token.Token))) {
						_recordVarDecl(_s.pos());
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BlockStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.BlockStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__()
						.value;
					_blockBranches(_lstmt, _s.list);
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IfStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.IfStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__()
						.value;
					_stmtBranches(Go.asInterface(_s.body));
					if (_s.else_ != null) {
						_stmtBranches(_s.else_);
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CaseClause>))) {
					var _s:Ref<stdgo.go.ast.Ast.CaseClause> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CaseClause>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.CaseClause>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CaseClause>) : __type__.__underlying__()
						.value;
					_blockBranches(null, _s.body);
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SwitchStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.SwitchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__()
						.value;
					_stmtBranches(Go.asInterface(_s.body));
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.TypeSwitchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__()
						.value;
					_stmtBranches(Go.asInterface(_s.body));
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CommClause>))) {
					var _s:Ref<stdgo.go.ast.Ast.CommClause> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CommClause>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.CommClause>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CommClause>) : __type__.__underlying__()
						.value;
					_blockBranches(null, _s.body);
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.SelectStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__()
						.value;
					_stmtBranches(Go.asInterface(_s.body));
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ForStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.ForStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__()
						.value;
					_stmtBranches(Go.asInterface(_s.body));
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.RangeStmt>))) {
					var _s:Ref<stdgo.go.ast.Ast.RangeStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__.__underlying__()
						.value;
					_stmtBranches(Go.asInterface(_s.body));
				};
			};
		};
		for (_0 => _s in _list) {
			_stmtBranches(_s);
		};
		return _fwdJumps;
	}

	/**
		// labels checks correct label use in body.
	**/
	@:keep
	static public function _labels(_check:Ref<Checker>, _body:Ref<stdgo.go.ast.Ast.BlockStmt>):Void {
		var _all = newScope(null, _body.pos(), _body.end(), ("label" : GoString));
		var _fwdJumps = _check._blockBranches(_all, null, null, _body.list);
		for (_0 => _jmp in _fwdJumps) {
			var _msg:GoString = ("" : GoString);
			var _code:T_errorCode = ((0 : GoInt) : T_errorCode);
			var _name:GoString = _jmp.label.name;
			{
				var _alt:Object = _all.lookup(_name);
				if (_alt != null) {
					_msg = ("goto %s jumps into block" : GoString);
					(Go.typeAssert((Go.toInterface(_alt) : Ref<Label>)) : Ref<Label>)._used = true;
					_code = (124 : T_errorCode);
				} else {
					_msg = ("label %s not declared" : GoString);
					_code = (119 : T_errorCode);
				};
			};
			_check._errorf(Go.asInterface(_jmp.label), _code, _msg, Go.toInterface(_name));
		};
		for (_name => _obj in _all._elems) {
			_obj = _resolve(_name, _obj);
			{
				var _lbl = (Go.typeAssert((Go.toInterface(_obj) : Ref<Label>)) : Ref<Label>);
				if (!_lbl._used) {
					_check._softErrorf(Go.asInterface(_lbl), (122 : T_errorCode), ("label %s declared but not used" : GoString),
						Go.toInterface(_lbl._object._name));
				};
			};
		};
	}

	@:keep
	static public function _interfaceType(_check:Ref<Checker>, _ityp:Ref<Interface>, _iface:Ref<stdgo.go.ast.Ast.InterfaceType>, _def:Ref<Named>):Void {
		var _addEmbedded:(stdgo.go.token.Token.Pos, Type) -> Void = function(_pos:stdgo.go.token.Token.Pos, _typ:Type):Void {
			_ityp._embeddeds = _ityp._embeddeds.__appendref__(_typ);
			if (_ityp._embedPos == null) {
				_ityp._embedPos = (null : Slice<stdgo.go.token.Token.Pos>);
			};
			_ityp._embedPos.__setData__(_ityp._embedPos.__appendref__(_pos));
		};
		for (_0 => _f in _iface.methods.list) {
			if ((_f.names.length) == ((0 : GoInt))) {
				_addEmbedded(_f.type.pos(), _parseUnion(_check, _f.type));
				continue;
			};
			var _name = _f.names[(0 : GoInt)];
			if (_name.name == (("_" : GoString))) {
				_check._errorf(Go.asInterface(_name), (27 : T_errorCode), ("methods must have a unique non-blank name" : GoString));
				continue;
			};
			var _typ:Type = _check._typ(_f.type);
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_typ) : Ref<Signature>)) : Ref<Signature>), ok: true};
			} catch (_) {
				{value: (null : Ref<Signature>), ok: false};
			}, _sig = __tmp__.value, _1 = __tmp__.ok;
			if (_sig == null) {
				if (Go.toInterface(_typ) != (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
					_check._invalidAST(_f.type, ("%s is not a method signature" : GoString), Go.toInterface(_typ));
				};
				continue;
			};
			if (_sig._tparams != null) {
				var _at:T_positioner = _f.type;
				{
					var __tmp__ = try {
						{value: (Go.typeAssert((Go.toInterface(_f.type) : Ref<stdgo.go.ast.Ast.FuncType>)) : Ref<stdgo.go.ast.Ast.FuncType>), ok: true};
					} catch (_) {
						{value: (null : Ref<stdgo.go.ast.Ast.FuncType>), ok: false};
					}, _ftyp = __tmp__.value, _2 = __tmp__.ok;
					if ((_ftyp != null) && (_ftyp.typeParams != null)) {
						_at = Go.asInterface(_ftyp.typeParams);
					};
				};
				_check._errorf(_at, (143 : T_errorCode), ("methods cannot have type parameters" : GoString));
			};
			var _recvTyp:Type = Go.asInterface(_ityp);
			if (_def != null) {
				_recvTyp = Go.asInterface(_def);
			};
			_sig._recv = newVar(_name.pos(), _check._pkg, Go.str(), _recvTyp);
			var _m = newFunc(_name.pos(), _check._pkg, _name.name, _sig);
			_check._recordDef(_name, Go.asInterface(_m));
			_ityp._methods = _ityp._methods.__appendref__(_m);
		};
		_ityp._complete = true;
		if ((_ityp._methods.length == (0 : GoInt)) && (_ityp._embeddeds.length == (0 : GoInt))) {
			_ityp._tset = (_topTypeSet : Ref<T__TypeSet>);
			return;
		};
		_sortMethods(_ityp._methods);
		_check._later(function():Void {
			_computeInterfaceTypeSet(_check, _iface.pos(), _ityp);
		})._describef(Go.asInterface(_iface), ("compute type set for %s" : GoString), Go.toInterface(Go.asInterface(_ityp)));
	}

	/**
		// check may be nil
	**/
	@:keep
	static public function _newInterface(_check:Ref<Checker>):Ref<Interface> {
		var _typ = (({_check: _check} : Interface) : Ref<Interface>);
		if (_check != null) {
			_check._needsCleanup(Go.asInterface(_typ));
		};
		return _typ;
	}

	/**
		// implements checks if V implements T and reports an error if it doesn't.
		// The receiver may be nil if implements is called through an exported
		// API call such as AssignableTo.
	**/
	@:keep
	static public function _implements(_check:Ref<Checker>, v:Type, t:Type):Error {
		var vu:Type = _under(v);
		var tu:Type = _under(t);
		if ((Go.toInterface(vu) == Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))
			|| (Go.toInterface(tu) == Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
			return (null : Error);
		};
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(vu) : Ref<Pointer_>)) : Ref<Pointer_>), ok: true};
			} catch (_) {
				{value: (null : Ref<Pointer_>), ok: false};
			}, _p = __tmp__.value, _0 = __tmp__.ok;
			if ((_p != null) && (Go.toInterface(_under(_p._base)) == Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
				return (null : Error);
			};
		};
		var _errorf = function(_format:GoString, _args:haxe.Rest<AnyInterface>):Error {
			return stdgo.errors.Errors.new_(_check._sprintf(_format, ..._args.__toArray__()));
		};
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(tu) : Ref<Interface>)) : Ref<Interface>), ok: true};
		} catch (_) {
			{value: (null : Ref<Interface>), ok: false};
		}, ti = __tmp__.value, _1 = __tmp__.ok;
		if (ti == null) {
			var _cause:GoString = ("" : GoString);
			if (_isInterfacePtr(tu)) {
				_cause = _check._sprintf(("type %s is pointer to interface, not interface" : GoString), Go.toInterface(t));
			} else {
				_cause = _check._sprintf(("%s is not an interface" : GoString), Go.toInterface(t));
			};
			return _errorf(("%s does not implement %s (%s)" : GoString), Go.toInterface(v), Go.toInterface(t), Go.toInterface(_cause));
		};
		if (ti.empty()) {
			return (null : Error);
		};
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(vu) : Ref<Interface>)) : Ref<Interface>), ok: true};
		} catch (_) {
			{value: (null : Ref<Interface>), ok: false};
		}, vi = __tmp__.value, _2 = __tmp__.ok;
		if ((vi != null) && vi._typeSet().isEmpty()) {
			return (null : Error);
		};
		if (ti._typeSet().isEmpty()) {
			return _errorf(("cannot implement %s (empty type set)" : GoString), Go.toInterface(t));
		};
		{
			var __tmp__ = _check._missingMethod(v, ti, true),
				_m:Ref<Func> = __tmp__._0,
				_wrong:Ref<Func> = __tmp__._1;
			if (_m != null) {
				return _errorf(("%s does not implement %s %s" : GoString), Go.toInterface(v), Go.toInterface(t),
					Go.toInterface(_check._missingMethodReason(v, t, _m, _wrong)));
			};
		};
		var _pending:Error = (null : Error);
		if (ti.isComparable() && !_comparable(v, false, (null : GoMap<Type, Bool>), null)) {
			_pending = _errorf(("%s does not implement comparable" : GoString), Go.toInterface(v));
		};
		if (!ti._typeSet()._hasTerms()) {
			return _pending;
		};
		if (vi != null) {
			if (!vi._typeSet()._subsetOf(ti._typeSet())) {
				return _errorf(("%s does not implement %s" : GoString), Go.toInterface(v), Go.toInterface(t));
			};
			return _pending;
		};
		var _alt:Type = (null : Type);
		if (ti._typeSet()._is(function(_t:Ref<T_term>):Bool {
			if (!_t._includes(v)) {
				if (((_alt == null) && !_t._tilde) && identical(_t._typ, _under(_t._typ))) {
					var _tt:T_term = (_t == null ? null : _t.__copy__());
					_tt._tilde = true;
					if (_tt._includes(v)) {
						_alt = _t._typ;
					};
				};
				return true;
			};
			return false;
		})) {
			if (_alt != null) {
				return _errorf(("%s does not implement %s (possibly missing ~ for %s in constraint %s)" : GoString), Go.toInterface(v), Go.toInterface(t),
					Go.toInterface(_alt), Go.toInterface(t));
			} else {
				return _errorf(("%s does not implement %s (%s missing in %s)" : GoString), Go.toInterface(v), Go.toInterface(t), Go.toInterface(v),
					Go.toInterface(Go.asInterface(ti._typeSet()._terms)));
			};
		};
		return _pending;
	}

	@:keep
	static public function _verify(_check:Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _tparams:Slice<Ref<TypeParam>>, _targs:Slice<Type>,
			_ctxt:Ref<Context>):{var _0:GoInt; var _1:Error;} {
		var _smap:T_substMap = _makeSubstMap(_tparams, _targs);
		for (_i => _tpar in _tparams) {
			_tpar._iface();
			var _bound:Type = _check._subst(_pos, _tpar._bound, _smap, null, _ctxt);
			{
				var _err:Error = _check._implements(_targs[(_i : GoInt)], _bound);
				if (_err != null) {
					return {_0: _i, _1: _err};
				};
			};
		};
		return {_0: (-1 : GoInt), _1: (null : Error)};
	}

	/**
		// validateTArgLen verifies that the length of targs and tparams matches,
		// reporting an error if not. If validation fails and check is nil,
		// validateTArgLen panics.
	**/
	@:keep
	static public function _validateTArgLen(_check:Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _ntparams:GoInt, _ntargs:GoInt):Bool {
		if (_ntargs != (_ntparams)) {
			if (_check != null) {
				_check._errorf(Go.asInterface((_pos : T_atPos)), (137 : T_errorCode), ("got %d arguments but %d type parameters" : GoString),
					Go.toInterface(_ntargs), Go.toInterface(_ntparams));
				return false;
			};
			throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("%v: got %d arguments but %d type parameters" : GoString), Go.toInterface(Go.asInterface(_pos)),
				Go.toInterface(_ntargs), Go.toInterface(_ntparams)));
		};
		return true;
	}

	/**
		// instance instantiates the given original (generic) function or type with the
		// provided type arguments and returns the resulting instance. If an identical
		// instance exists already in the given contexts, it returns that instance,
		// otherwise it creates a new one.
		//
		// If expanding is non-nil, it is the Named instance type currently being
		// expanded. If ctxt is non-nil, it is the context associated with the current
		// type-checking pass or call to Instantiate. At least one of expanding or ctxt
		// must be non-nil.
		//
		// For Named types the resulting instance may be unexpanded.
	**/
	@:keep
	static public function _instance(_check:Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _orig:Type, _targs:Slice<Type>, _expanding:Ref<Named>,
			_ctxt:Ref<Context>):Type {
		var _res:Type = (null : Type);
		var _ctxts:Slice<Ref<Context>> = (null : Slice<Ref<Context>>);
		if (_expanding != null) {
			_ctxts = _ctxts.__appendref__(_expanding._inst._ctxt);
		};
		if (_ctxt != null) {
			_ctxts = _ctxts.__appendref__(_ctxt);
		};
		_assert((_ctxts.length) > (0 : GoInt));
		var _hashes = new Slice<GoString>((_ctxts.length : GoInt).toBasic(), 0, ...[for (i in 0...(_ctxts.length : GoInt).toBasic()) ("" : GoString)]);
		for (_i => _ctxt in _ctxts) {
			_hashes[(_i : GoInt)] = _ctxt._instanceHash(_orig, _targs);
		};
		var _updateContexts:Type->Type = function(_res:Type):Type {
			{
				var _i:GoInt = (_ctxts.length) - (1 : GoInt);
				Go.cfor(_i >= (0 : GoInt), _i--, {
					_res = _ctxts[(_i : GoInt)]._update(_hashes[(_i : GoInt)], _orig, _targs, _res);
				});
			};
			return _res;
		};
		for (_i => _ctxt in _ctxts) {
			{
				var _inst:Type = _ctxt._lookup(_hashes[(_i : GoInt)], _orig, _targs);
				if (_inst != null) {
					return _updateContexts(_inst);
				};
			};
		};
		{
			final __type__ = _orig;
			if (Go.typeEquals((__type__ : Ref<Named>))) {
				var _orig:Ref<Named> = __type__ == null ? (null : Ref<Named>) : __type__.__underlying__() == null ? (null : Ref<Named>) : __type__ == null ? (null : Ref<Named>) : __type__.__underlying__()
					.value;
				_res = Go.asInterface(_check._newNamedInstance(_pos, _orig, _targs, _expanding));
			} else if (Go.typeEquals((__type__ : Ref<Signature>))) {
				var _orig:Ref<Signature> = __type__ == null ? (null : Ref<Signature>) : __type__.__underlying__() == null ? (null : Ref<Signature>) : __type__ == null ? (null : Ref<Signature>) : __type__.__underlying__()
					.value;
				_assert(_expanding == null);
				var _tparams = _orig.typeParams();
				if (!_check._validateTArgLen(_pos, _tparams.len(), (_targs.length))) {
					return Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
				};
				if (_tparams.len() == ((0 : GoInt))) {
					return Go.asInterface(_orig);
				};
				var _sig = (Go.typeAssert((Go.toInterface(_check._subst(_pos, Go.asInterface(_orig), _makeSubstMap(_tparams._list(), _targs), null,
					_ctxt)) : Ref<Signature>)) : Ref<Signature>);
				if (_sig == (_orig)) {
					var _copy:Signature = (_sig == null ? null : _sig.__copy__());
					_sig = (_copy : Ref<Signature>);
				};
				_sig._tparams = null;
				_res = Go.asInterface(_sig);
			} else {
				var _orig:Type = __type__ == null ? (null : Type) : cast __type__;
				throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("%v: cannot instantiate %v" : GoString), Go.toInterface(Go.asInterface(_pos)),
					Go.toInterface(_orig)));
			};
		};
		return _updateContexts(_res);
	}

	/**
		// reportCycle reports an error for the given cycle.
	**/
	@:keep
	static public function _reportCycle(_check:Ref<Checker>, _cycle:Slice<Object>):Void {
		var _obj:Object = _cycle[(0 : GoInt)];
		_check._errorf(_obj, (9 : T_errorCode), ("initialization cycle for %s" : GoString), Go.toInterface(_obj.name()));
		{
			var _i:GoInt = (_cycle.length) - (1 : GoInt);
			Go.cfor(_i >= (0 : GoInt), _i--, {
				_check._errorf(_obj, (9 : T_errorCode), ("\t%s refers to" : GoString), Go.toInterface(_obj.name()));
				_obj = _cycle[(_i : GoInt)];
			});
		};
		_check._errorf(_obj, (9 : T_errorCode), ("\t%s" : GoString), Go.toInterface(_obj.name()));
	}

	/**
		// initOrder computes the Info.InitOrder for package variables.
	**/
	@:keep
	static public function _initOrder(_check:Ref<Checker>):Void {
		_check.info.initOrder = (_check.info.initOrder.__slice__(0, (0 : GoInt)) : Slice<Ref<Initializer>>);
		var _pq:T_nodeQueue = (_dependencyGraph(_check._objMap) : T_nodeQueue);
		stdgo.container.heap.Heap.init(Go.asInterface((_pq : Ref<T_nodeQueue>)));
		{};
		if (false) {
			stdgo.fmt.Fmt.printf(("Computing initialization order for %s\n\n" : GoString), Go.toInterface(Go.asInterface(_check._pkg)));
			stdgo.fmt.Fmt.println(Go.toInterface(("Object dependency graph:" : GoString)));
			for (_obj => _d in _check._objMap) {
				{
					var __tmp__ = try {
						{value: (Go.typeAssert((Go.toInterface(_obj) : T_dependency)) : T_dependency), ok: true};
					} catch (_) {
						{value: (null : T_dependency), ok: false};
					}, _obj = __tmp__.value, _10 = __tmp__.ok;
					if (_obj != null) {
						if ((_d._deps.length) > (0 : GoInt)) {
							stdgo.fmt.Fmt.printf(("\t%s depends on\n" : GoString), Go.toInterface(_obj.name()));
							for (_dep => _ in _d._deps) {
								stdgo.fmt.Fmt.printf(("\t\t%s\n" : GoString), Go.toInterface(_dep.name()));
							};
						} else {
							stdgo.fmt.Fmt.printf(("\t%s has no dependencies\n" : GoString), Go.toInterface(_obj.name()));
						};
					};
				};
			};
			stdgo.fmt.Fmt.println();
			stdgo.fmt.Fmt.println(Go.toInterface(("Transposed object dependency graph (functions eliminated):" : GoString)));
			for (_11 => _n in _pq) {
				stdgo.fmt.Fmt.printf(("\t%s depends on %d nodes\n" : GoString), Go.toInterface(_n._obj.name()), Go.toInterface(_n._ndeps));
				for (_p => _ in _n._pred) {
					stdgo.fmt.Fmt.printf(("\t\t%s is dependent\n" : GoString), Go.toInterface(_p._obj.name()));
				};
			};
			stdgo.fmt.Fmt.println();
			stdgo.fmt.Fmt.println(Go.toInterface(("Processing nodes:" : GoString)));
		};
		var _emitted = (new GoObjectMap<Ref<T_declInfo>,
			Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
				stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("T_declInfo", [], null, false,
					{get: () -> null})})},
			{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind)}))) : GoMap<Ref<T_declInfo>, Bool>);
		while ((_pq.length) > (0 : GoInt)) {
			var _n = (Go.typeAssert((stdgo.container.heap.Heap.pop(Go.asInterface((_pq : Ref<T_nodeQueue>))) : Ref<T_graphNode>)) : Ref<T_graphNode>);
			if (false) {
				stdgo.fmt.Fmt.printf(("\t%s (src pos %d) depends on %d nodes now\n" : GoString), Go.toInterface(_n._obj.name()),
					Go.toInterface(_n._obj._order()), Go.toInterface(_n._ndeps));
			};
			if (_n._ndeps > (0 : GoInt)) {
				var _cycle = _findPath(_check._objMap, _n._obj, _n._obj,
					(new GoObjectMap<Object, Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({
						get: () -> stdgo.internal.reflect.Reflect.GoType.named("Object", [], null, false, {get: () -> null})
					},
						{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind)}))) : GoMap<Object, Bool>));
				if (_cycle != null) {
					_check._reportCycle(_cycle);
				};
			};
			for (_p => _ in _n._pred) {
				_p._ndeps--;
				stdgo.container.heap.Heap.fix(Go.asInterface((_pq : Ref<T_nodeQueue>)), _p._index);
			};
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_n._obj) : Ref<Var>)) : Ref<Var>), ok: true};
			} catch (_) {
				{value: (null : Ref<Var>), ok: false};
			}, _v = __tmp__.value, _14 = __tmp__.ok;
			var _info = _check._objMap[Go.asInterface(_v)];
			if ((_v == null) || !_info._hasInitializer()) {
				continue;
			};
			if (_emitted[_info]) {
				continue;
			};
			_emitted[_info] = true;
			var _infoLhs = _info._lhs;
			if (_infoLhs == null) {
				_infoLhs = (new Slice<Ref<Var>>(0, 0, _v) : Slice<Ref<Var>>);
			};
			var _init = ((new Initializer(_infoLhs, _info._init) : Initializer) : Ref<Initializer>);
			_check.info.initOrder = _check.info.initOrder.__appendref__(_init);
		};
		if (false) {
			stdgo.fmt.Fmt.println();
			stdgo.fmt.Fmt.println(Go.toInterface(("Initialization order:" : GoString)));
			for (_21 => _init in _check.info.initOrder) {
				stdgo.fmt.Fmt.printf(("\t%s\n" : GoString), Go.toInterface(Go.asInterface(_init)));
			};
			stdgo.fmt.Fmt.println();
		};
	}

	/**
		// inferB returns the list of actual type arguments inferred from the type parameters'
		// bounds and an initial set of type arguments. If type inference is impossible because
		// unification fails, an error is reported if report is set to true, the resulting types
		// list is nil, and index is 0.
		// Otherwise, types is the list of inferred type arguments, and index is the index of the
		// first type argument in that list that couldn't be inferred (and thus is nil). If all
		// type arguments were inferred successfully, index is < 0. The number of type arguments
		// provided may be less than the number of type parameters, but there must be at least one.
	**/
	@:keep
	static public function _inferB(_check:Ref<Checker>, _posn:T_positioner, _tparams:Slice<Ref<TypeParam>>,
			_targs:Slice<Type>):{var _0:Slice<Type>; var _1:GoInt;} {
		var __deferstack__:Array<Void->Void> = [];
		var _types:Slice<Type> = (null : Slice<Type>),
			_index:GoInt = (0 : GoInt);
		_assert((_tparams.length >= _targs.length) && (_targs.length > (0 : GoInt)));
		if (false) {
			_check._dump(("-- inferB %s ➞ %s" : GoString), Go.toInterface(_tparams), Go.toInterface(_targs));
			__deferstack__.unshift(() -> {
				var a = function():Void {
					_check._dump(("=> inferB %s ➞ %s" : GoString), Go.toInterface(_tparams), Go.toInterface(_types));
				};
				a();
			});
		};
		try {
			var _u = _newUnifier(false);
			_u._x._init(_tparams);
			_u._y = (_u._x == null ? null : _u._x.__copy__());
			for (_i => _targ in _targs) {
				if (_targ != null) {
					_u._x._set(_i, _targ);
				};
			};
			{
				var _n:GoInt = _u._x._unknowns();
				while (_n > (0 : GoInt)) {
					var _nn:GoInt = _n;
					for (_i => _tpar in _tparams) {
						{
							var __tmp__ = _coreTerm(_tpar),
								_core:Ref<T_term> = __tmp__._0,
								_single:Bool = __tmp__._1;
							if (_core != null) {
								var _tx:Type = _u._x._at(_i);
								if (_tx != null) {
									if (_core._tilde && !_isTypeParam(_tx)) {
										_tx = _under(_tx);
									};
									if (!_u._unify(_tx, _core._typ)) {
										var _tilde:GoString = Go.str();
										if (_core._tilde) {
											_tilde = ("~" : GoString);
										};
										_check._errorf(_posn, (139 : T_errorCode), ("%s does not match %s%s" : GoString),
											Go.toInterface(Go.asInterface(_tpar)), Go.toInterface(_tilde), Go.toInterface(_core._typ));
										{
											for (defer in __deferstack__) {
												defer();
											};
											return {_0: (null : Slice<Type>), _1: (0 : GoInt)};
										};
									};
								} else if (_single && !_core._tilde) {
									_u._x._set(_i, _core._typ);
								} else {
									continue;
								};
								_nn = _u._x._unknowns();
								if (_nn == ((0 : GoInt))) {
									break;
								};
							};
						};
					};
					_assert(_nn <= _n);
					if (_nn == (_n)) {
						break;
					};
					_n = _nn;
				};
			};
			{
				var __tmp__ = _u._x._types();
				_types = __tmp__._0;
			};
			if (false) {
				for (_i => _targ in _targs) {
					_assert((_targ == null) || (Go.toInterface(_types[(_i : GoInt)]) == Go.toInterface(_targ)));
				};
			};
			var _w:T_cycleFinder = (new T_cycleFinder(_tparams, _types,
				(new GoObjectMap<Type, Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({
					get: () -> stdgo.internal.reflect.Reflect.GoType.named("Type", [], null, false, {get: () -> null})
				},
					{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind)}))) : GoMap<Type, Bool>)) : T_cycleFinder);
			for (_0 => _t in _tparams) {
				_w._typ(Go.asInterface(_t));
			};
			var _dirty:Slice<GoInt> = (null : Slice<GoInt>);
			for (_i => _typ in _types) {
				if ((_typ != null) && ((_i >= _targs.length) || (_targs[(_i : GoInt)] == null))) {
					_dirty = _dirty.__appendref__(_i);
				};
			};
			while ((_dirty.length) > (0 : GoInt)) {
				var _smap:T_substMap = _makeSubstMap(_tparams, _types);
				var _n:GoInt = (0 : GoInt);
				for (_1 => _index in _dirty) {
					var _t0:Type = _types[(_index : GoInt)];
					{
						var _t1:Type = _check._subst((0 : stdgo.go.token.Token.Pos), _t0, _smap, null, _check._context());
						if (Go.toInterface(_t1) != (Go.toInterface(_t0))) {
							_types[(_index : GoInt)] = _t1;
							_dirty[(_n : GoInt)] = _index;
							_n++;
						};
					};
				};
				_dirty = (_dirty.__slice__(0, _n) : Slice<GoInt>);
			};
			for (_i => _typ in _types) {
				if ((_typ != null) && _isParameterized(_tparams, _typ)) {
					_types[(_i : GoInt)] = (null : Type);
				};
			};
			_index = (-1 : GoInt);
			for (_i => _typ in _types) {
				if (_typ == null) {
					_index = _i;
					break;
				};
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				return {_0: _types, _1: _index};
			};
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return {_0: _types, _1: _index};
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return {_0: _types, _1: _index};
		};
	}

	/**
		// infer attempts to infer the complete set of type arguments for generic function instantiation/call
		// based on the given type parameters tparams, type arguments targs, function parameters params, and
		// function arguments args, if any. There must be at least one type parameter, no more type arguments
		// than type parameters, and params and args must match in number (incl. zero).
		// If successful, infer returns the complete list of type arguments, one for each type parameter.
		// Otherwise the result is nil and appropriate errors will be reported.
		//
		// Inference proceeds as follows:
		//
		//	Starting with given type arguments
		//	1) apply FTI (function type inference) with typed arguments,
		//	2) apply CTI (constraint type inference),
		//	3) apply FTI with untyped function arguments,
		//	4) apply CTI.
		//
		// The process stops as soon as all type arguments are known or an error occurs.
	**/
	@:keep
	static public function _infer(_check:Ref<Checker>, _posn:T_positioner, _tparams:Slice<Ref<TypeParam>>, _targs:Slice<Type>, _params:Ref<Tuple>,
			_args:Slice<Ref<T_operand>>):Slice<Type> {
		var __deferstack__:Array<Void->Void> = [];
		var _result:Slice<Type> = (null : Slice<Type>);
		if (false) {
			__deferstack__.unshift(() -> {
				var a = function():Void {
					_assert((_result == null) || (_result.length == (_tparams.length)));
					for (_0 => _targ in _result) {
						_assert(_targ != null);
					};
				};
				a();
			});
		};
		try {
			if (false) {
				_check._dump(("-- inferA %s%s ➞ %s" : GoString), Go.toInterface(_tparams), Go.toInterface(Go.asInterface(_params)), Go.toInterface(_targs));
				__deferstack__.unshift(() -> {
					var a = function():Void {
						_check._dump(("=> inferA %s ➞ %s" : GoString), Go.toInterface(_tparams), Go.toInterface(_result));
					};
					a();
				});
			};
			var _n:GoInt = (_tparams.length);
			_assert((_n > (0 : GoInt)) && (_targs.length <= _n));
			_assert(_params.len() == ((_args.length)));
			if ((_targs.length) == (_n)) {
				{
					for (defer in __deferstack__) {
						defer();
					};
					return _targs;
				};
			};
			{};
			if (true) {
				var _selfRecursive:Bool = ((_check._environment._sig != null)
					&& (_check._environment._sig._tparams.len() > (0 : GoInt)))
					&& (_tparams[(0 : GoInt)] == _check._environment._sig._tparams.at((0 : GoInt)));
				if (_selfRecursive) {
					var _tparams2 = new Slice<Ref<TypeParam>>((_tparams.length : GoInt).toBasic(), 0,
						...[for (i in 0...(_tparams.length : GoInt).toBasic()) (null : Ref<TypeParam>)]);
					for (_i => _tparam in _tparams) {
						var _tname = newTypeName(_tparam.obj().pos(), _tparam.obj().pkg(), _tparam.obj().name(), (null : Type));
						_tparams2[(_i : GoInt)] = newTypeParam(_tname, (null : Type));
						_tparams2[(_i : GoInt)]._index = _tparam._index;
					};
					var _renameMap:T_substMap = _makeRenameMap(_tparams, _tparams2);
					for (_i => _tparam in _tparams) {
						_tparams2[(_i : GoInt)]._bound = _check._subst(_posn.pos(), _tparam._bound, _renameMap, null, _check._context());
					};
					_tparams = _tparams2;
					_params = (Go.typeAssert((Go.toInterface(_check._subst(_posn.pos(), Go.asInterface(_params), _renameMap, null,
						_check._context())) : Ref<Tuple>)) : Ref<Tuple>);
				};
			};
			{};
			{
				var _m:GoInt = (_args.length);
				if ((_m >= (2 : GoInt)) && true) {
					var _0:Slice<GoInt> = (null : Slice<GoInt>),
						_1:Slice<GoInt> = (null : Slice<GoInt>),
						_unnamed:Slice<GoInt> = _1,
						_named:Slice<GoInt> = _0;
					for (_i => _arg in _args) {
						if (_hasName(_arg._typ)) {
							_named = _named.__appendref__(_i);
						} else {
							_unnamed = _unnamed.__appendref__(_i);
						};
					};
					if ((_named.length != (0 : GoInt)) && (_unnamed.length != (0 : GoInt))) {
						var _params2 = new Slice<Ref<Var>>((_m : GoInt).toBasic(), 0, ...[for (i in 0...(_m : GoInt).toBasic()) (null : Ref<Var>)]);
						var _args2 = new Slice<Ref<T_operand>>((_m : GoInt).toBasic(), 0, ...[for (i in 0...(_m : GoInt).toBasic()) (null : Ref<T_operand>)]);
						var _i:GoInt = (0 : GoInt);
						for (_14 => _j in _named) {
							_params2[(_i : GoInt)] = _params.at(_j);
							_args2[(_i : GoInt)] = _args[(_j : GoInt)];
							_i++;
						};
						for (_15 => _j in _unnamed) {
							_params2[(_i : GoInt)] = _params.at(_j);
							_args2[(_i : GoInt)] = _args[(_j : GoInt)];
							_i++;
						};
						_params = newTuple(..._params2.__toArray__());
						_args = _args2;
					};
				};
			};
			if ((_targs.length) < _n) {
				var _targs2 = new Slice<Type>((_n : GoInt).toBasic(), 0, ...[for (i in 0...(_n : GoInt).toBasic()) (null : Type)]);
				Go.copySlice(_targs2, _targs);
				_targs = _targs2;
			};
			if (_params.len() > (0 : GoInt)) {
				var _smap:T_substMap = _makeSubstMap(_tparams, _targs);
				_params = (Go.typeAssert((Go.toInterface(_check._subst((0 : stdgo.go.token.Token.Pos), Go.asInterface(_params), _smap, null,
					_check._context())) : Ref<Tuple>)) : Ref<Tuple>);
			};
			var _u = _newUnifier(false);
			_u._x._init(_tparams);
			for (_i => _targ in _targs) {
				if (_targ != null) {
					_u._x._set(_i, _targ);
				};
			};
			var _errorf = function(_kind:GoString, _tpar:Type, _targ:Type, _arg:Ref<T_operand>):Void {
				var __tmp__ = _u._x._types(), _targs:Slice<Type> = __tmp__._0, _index:GoInt = __tmp__._1;
				if (_index == ((0 : GoInt))) {
					var _allFailed:Bool = true;
					for (_0 => _targ in _targs) {
						if (_targ != null) {
							_allFailed = false;
							break;
						};
					};
					if (_allFailed) {
						_check._errorf(Go.asInterface(_arg), (138 : T_errorCode), ("%s %s of %s does not match %s (cannot infer %s)" : GoString),
							Go.toInterface(_kind), Go.toInterface(_targ), Go.toInterface(_arg._expr), Go.toInterface(_tpar),
							Go.toInterface(_typeParamsString(_tparams)));
						return;
					};
				};
				var _smap:T_substMap = _makeSubstMap(_tparams, _targs);
				var _inferred:Type = _check._subst(_arg.pos(), _tpar, _smap, null, _check._context());
				if (Go.toInterface(_inferred) != (Go.toInterface(_tpar))) {
					_check._errorf(Go.asInterface(_arg), (138 : T_errorCode), ("%s %s of %s does not match inferred type %s for %s" : GoString),
						Go.toInterface(_kind), Go.toInterface(_targ), Go.toInterface(_arg._expr), Go.toInterface(_inferred), Go.toInterface(_tpar));
				} else {
					_check._errorf(Go.asInterface(_arg), (138 : T_errorCode), ("%s %s of %s does not match %s" : GoString), Go.toInterface(_kind),
						Go.toInterface(_targ), Go.toInterface(_arg._expr), Go.toInterface(_tpar));
				};
			};
			var _indices:Slice<GoInt> = (null : Slice<GoInt>);
			for (_i => _arg in _args) {
				var _par = _params.at(_i);
				if (_isParameterized(_tparams, _par._object._typ)) {
					if (_arg._mode == ((0 : T_operandMode))) {
						continue;
					};
					{
						var _targ:Type = _arg._typ;
						if (_isTyped(_targ)) {
							if (!_u._unify(_par._object._typ, _targ)) {
								_errorf(("type" : GoString), _par._object._typ, _targ, _arg);
								{
									for (defer in __deferstack__) {
										defer();
									};
									return (null : Slice<Type>);
								};
							};
						} else {
							var __tmp__ = try {
								{value: (Go.typeAssert((Go.toInterface(_par._object._typ) : Ref<TypeParam>)) : Ref<TypeParam>), ok: true};
							} catch (_) {
								{value: (null : Ref<TypeParam>), ok: false};
							}, _16 = __tmp__.value, _ok = __tmp__.ok;
							if (_ok) {
								_indices = _indices.__appendref__(_i);
							};
						};
					};
				};
			};
			var _index:GoInt = (0 : GoInt);
			{
				var __tmp__ = _u._x._types();
				_targs = __tmp__._0;
				_index = __tmp__._1;
			};
			if (_index < (0:GoInt)) {
				{
					for (defer in __deferstack__) {
						defer();
					};
					return _targs;
				};
			};
			{
				var __tmp__ = _check._inferB(_posn, _tparams, _targs);
				_targs = __tmp__._0;
				_index = __tmp__._1;
			};
			if ((_targs == null) || (_index < (0:GoInt))) {
				{
					for (defer in __deferstack__) {
						defer();
					};
					return _targs;
				};
			};
			for (_17 => _i in _indices) {
				var _tpar = (Go.typeAssert((Go.toInterface(_params.at(_i)._object._typ) : Ref<TypeParam>)) : Ref<TypeParam>);
				if (_targs[(_tpar._index : GoInt)] == null) {
					var _arg = _args[(_i : GoInt)];
					var _targ:Type = default_(_arg._typ);
					if (_isTyped(_targ) && !_u._unify(Go.asInterface(_tpar), _targ)) {
						_errorf(("default type" : GoString), Go.asInterface(_tpar), _targ, _arg);
						{
							for (defer in __deferstack__) {
								defer();
							};
							return (null : Slice<Type>);
						};
					};
				};
			};
			{
				var __tmp__ = _u._x._types();
				_targs = __tmp__._0;
				_index = __tmp__._1;
			};
			if (_index < (0:GoInt)) {
				{
					for (defer in __deferstack__) {
						defer();
					};
					return _targs;
				};
			};
			{
				var __tmp__ = _check._inferB(_posn, _tparams, _targs);
				_targs = __tmp__._0;
				_index = __tmp__._1;
			};
			if ((_targs == null) || (_index < (0:GoInt))) {
				{
					for (defer in __deferstack__) {
						defer();
					};
					return _targs;
				};
			};
			_assert((_index >= (0 : GoInt)) && (_targs[(_index : GoInt)] == null));
			var _tpar = _tparams[(_index : GoInt)];
			_check._errorf(_posn, (138 : T_errorCode), ("cannot infer %s (%v)" : GoString), Go.toInterface(_tpar._obj._object._name),
				Go.toInterface(Go.asInterface(_tpar._obj._object._pos)));
			{
				for (defer in __deferstack__) {
					defer();
				};
				return (null : Slice<Type>);
			};
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return _result;
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return _result;
		};
	}

	/**
		// indexElts checks the elements (elts) of an array or slice composite literal
		// against the literal's element type (typ), and the element indices against
		// the literal length if known (length >= 0). It returns the length of the
		// literal (maximum index value + 1).
	**/
	@:keep
	static public function _indexedElts(_check:Ref<Checker>, _elts:Slice<stdgo.go.ast.Ast.Expr>, _typ:Type, _length:GoInt64):GoInt64 {
		var _visited = (new GoObjectMap<GoInt64, Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
			stdgo.internal.reflect.Reflect.GoType.basic(int64_kind)},
			{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind)}))) : GoMap<GoInt64, Bool>);
		var _0:GoInt64 = (0 : GoInt64),
			_1:GoInt64 = (0 : GoInt64),
			_max:GoInt64 = _1,
			_index:GoInt64 = _0;
		for (_0 => _e in _elts) {
			var _validIndex:Bool = false;
			var _eval:stdgo.go.ast.Ast.Expr = _e;
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_e) : Ref<stdgo.go.ast.Ast.KeyValueExpr>)) : Ref<stdgo.go.ast.Ast.KeyValueExpr>), ok: true};
				} catch (_) {
					{value: (null : Ref<stdgo.go.ast.Ast.KeyValueExpr>), ok: false};
				}, _kv = __tmp__.value, _1 = __tmp__.ok;
				if (_kv != null) {
					{
						var __tmp__ = _check._index(_kv.key, _length),
							_typ:Type = __tmp__._0,
							_i:GoInt64 = __tmp__._1;
						if (Go.toInterface(_typ) != (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
							if (_i >= ("0" : GoInt64)) {
								_index = _i;
								_validIndex = true;
							} else {
								_check._errorf(_e, (62 : T_errorCode), ("index %s must be integer constant" : GoString), Go.toInterface(_kv.key));
							};
						};
					};
					_eval = _kv.value;
				} else if ((_length >= (("0" : GoInt64) : GoInt64)) && (_index >= _length)) {
					_check._errorf(_e, (63 : T_errorCode), ("index %d is out of bounds (>= %d)" : GoString), Go.toInterface(_index), Go.toInterface(_length));
				} else {
					_validIndex = true;
				};
			};
			if (_validIndex) {
				if (_visited[_index]) {
					_check._errorf(_e, (60 : T_errorCode), ("duplicate index %d in array or slice literal" : GoString), Go.toInterface(_index));
				};
				_visited[_index] = true;
			};
			_index++;
			if (_index > _max) {
				_max = _index;
			};
			var _x:T_operand = ({} : T_operand);
			_check._exprWithHint((_x : Ref<T_operand>), _eval, _typ);
			_check._assignment((_x : Ref<T_operand>), _typ, ("array or slice literal" : GoString));
		};
		return _max;
	}

	@:keep
	static public function _isValidIndex(_check:Ref<Checker>, _x:Ref<T_operand>, _code:T_errorCode, _what:GoString, _allowNegative:Bool):Bool {
		if (_x._mode == ((0 : T_operandMode))) {
			return false;
		};
		_check._convertUntyped(_x, Go.asInterface(typ[((2 : BasicKind) : GoInt)]));
		if (_x._mode == ((0 : T_operandMode))) {
			return false;
		};
		if (!_allInteger(_x._typ)) {
			_check._invalidArg(Go.asInterface(_x), _code, ("%s %s must be integer" : GoString), Go.toInterface(_what), Go.toInterface(Go.asInterface(_x)));
			return false;
		};
		if (_x._mode == ((4 : T_operandMode))) {
			if (!_allowNegative && (stdgo.go.constant.Constant.sign(_x._val) < (0:GoInt))) {
				_check._invalidArg(Go.asInterface(_x), _code, ("%s %s must not be negative" : GoString), Go.toInterface(_what),
					Go.toInterface(Go.asInterface(_x)));
				return false;
			};
			if (!_representableConst(_x._val, _check, typ[((2 : BasicKind) : GoInt)], (_x._val : Ref<stdgo.go.constant.Constant.Value>))) {
				_check._invalidArg(Go.asInterface(_x), _code, ("%s %s overflows int" : GoString), Go.toInterface(_what), Go.toInterface(Go.asInterface(_x)));
				return false;
			};
		};
		return true;
	}

	/**
		// index checks an index expression for validity.
		// If max >= 0, it is the upper bound for index.
		// If the result typ is != Typ[Invalid], index is valid and typ is its (possibly named) integer type.
		// If the result val >= 0, index is valid and val is its constant int value.
	**/
	@:keep
	static public function _index(_check:Ref<Checker>, _index:stdgo.go.ast.Ast.Expr, _max:GoInt64):{var _0:Type; var _1:GoInt64;} {
		var _typ:Type = (null : Type), _val:GoInt64 = (0 : GoInt64);
		_typ = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
		_val = ("-1" : GoInt64);
		var _x:T_operand = ({} : T_operand);
		_check._expr((_x : Ref<T_operand>), _index);
		if (!_check._isValidIndex((_x : Ref<T_operand>), (52 : T_errorCode), ("index" : GoString), false)) {
			return {_0: _typ, _1: _val};
		};
		if (_x._mode != ((4 : T_operandMode))) {
			return {_0: _x._typ, _1: ("-1" : GoInt64)};
		};
		if (_x._val.kind() == ((0 : stdgo.go.constant.Constant.Kind))) {
			return {_0: _typ, _1: _val};
		};
		var __tmp__ = stdgo.go.constant.Constant.int64Val(_x._val),
			_v:GoInt64 = __tmp__._0,
			_ok:Bool = __tmp__._1;
		_assert(_ok);
		if ((_max >= (("0" : GoInt64) : GoInt64)) && (_v >= _max)) {
			_check._invalidArg(Go.asInterface((_x : Ref<T_operand>)), (52 : T_errorCode), ("index %s out of bounds [0:%d]" : GoString),
				Go.toInterface((_x._val.string() : GoString)), Go.toInterface(_max));
			return {_0: _typ, _1: _val};
		};
		return {_0: _x._typ, _1: _v};
	}

	/**
		// singleIndex returns the (single) index from the index expression e.
		// If the index is missing, or if there are multiple indices, an error
		// is reported and the result is nil.
	**/
	@:keep
	static public function _singleIndex(_check:Ref<Checker>, _expr:Ref<go.internal.typeparams.Typeparams.IndexExpr>):stdgo.go.ast.Ast.Expr {
		if ((_expr.indexListExpr.indices.length) == ((0 : GoInt))) {
			_check._invalidAST(_expr.orig, ("index expression %v with 0 indices" : GoString), Go.toInterface(Go.asInterface(_expr)));
			return (null : stdgo.go.ast.Ast.Expr);
		};
		if ((_expr.indexListExpr.indices.length) > (1 : GoInt)) {
			_check._invalidOp(_expr.indexListExpr.indices[(1 : GoInt)], (52 : T_errorCode), ("more than one index" : GoString));
		};
		return _expr.indexListExpr.indices[(0 : GoInt)];
	}

	@:keep
	static public function _sliceExpr(_check:Ref<Checker>, _x:Ref<T_operand>, _e:Ref<stdgo.go.ast.Ast.SliceExpr>):Void {
		stdgo.internal.Macro.controlFlow({
			_check._expr(_x, _e.x);
			if (_x._mode == ((0 : T_operandMode))) {
				_check._use(_e.low, _e.high, _e.max);
				return;
			};
			var _valid:Bool = false;
			var _length:GoInt64 = (("-1" : GoInt64) : GoInt64);
			{
				final __type__ = _coreString(_x._typ);
				if (__type__ == null) {
					var _u:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
					_check._invalidOp(Go.asInterface(_x), (54 : T_errorCode), ("cannot slice %s: %s has no core type" : GoString),
						Go.toInterface(Go.asInterface(_x)), Go.toInterface(_x._typ));
					_x._mode = (0 : T_operandMode);
					return;
				} else if (Go.typeEquals((__type__ : Ref<Basic>))) {
					var _u:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
						.value;
					if (_isString(Go.asInterface(_u))) {
						if (_e.slice3) {
							var _at:stdgo.go.ast.Ast.Expr = _e.max;
							if (_at == null) {
								_at = Go.asInterface(_e);
							};
							_check._invalidOp(_at, (55 : T_errorCode), ("3-index slice of string" : GoString));
							_x._mode = (0 : T_operandMode);
							return;
						};
						_valid = true;
						if (_x._mode == ((4 : T_operandMode))) {
							_length = (stdgo.go.constant.Constant.stringVal(_x._val).length : GoInt64);
						};
						if (_isUntyped(_x._typ)) {
							_x._typ = Go.asInterface(typ[((17 : BasicKind) : GoInt)]);
						};
					};
				} else if (Go.typeEquals((__type__ : Ref<Array_>))) {
					var _u:Ref<Array_> = __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__() == null ? (null : Ref<Array_>) : __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__()
						.value;
					_valid = true;
					_length = _u._len;
					if (_x._mode != ((5 : T_operandMode))) {
						_check._invalidOp(Go.asInterface(_x), (54 : T_errorCode), ("cannot slice %s (value not addressable)" : GoString),
							Go.toInterface(Go.asInterface(_x)));
						_x._mode = (0 : T_operandMode);
						return;
					};
					_x._typ = Go.asInterface((({_elem: _u._elem} : Slice_) : Ref<Slice_>));
				} else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
					var _u:Ref<Pointer_> = __type__ == null ? (null : Ref<Pointer_>) : __type__.__underlying__() == null ? (null : Ref<Pointer_>) : __type__ == null ? (null : Ref<Pointer_>) : __type__.__underlying__()
						.value;
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_under(_u._base)) : Ref<Array_>)) : Ref<Array_>), ok: true};
						} catch (_) {
							{value: (null : Ref<Array_>), ok: false};
						}, _u = __tmp__.value, _0 = __tmp__.ok;
						if (_u != null) {
							_valid = true;
							_length = _u._len;
							_x._typ = Go.asInterface((({_elem: _u._elem} : Slice_) : Ref<Slice_>));
						};
					};
				} else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
					var _u:Ref<Slice_> = __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__() == null ? (null : Ref<Slice_>) : __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__()
						.value;
					_valid = true;
				};
			};
			if (!_valid) {
				_check._invalidOp(Go.asInterface(_x), (54 : T_errorCode), ("cannot slice %s" : GoString), Go.toInterface(Go.asInterface(_x)));
				_x._mode = (0 : T_operandMode);
				return;
			};
			_x._mode = (7 : T_operandMode);
			if (_e.slice3 && ((_e.high == null) || (_e.max == null))) {
				_check._invalidAST(Go.asInterface(_inNode(Go.asInterface(_e), _e.rbrack)), ("2nd and 3rd index required in 3-index slice" : GoString));
				_x._mode = (0 : T_operandMode);
				return;
			};
			var _ind:GoArray<GoInt64> = new GoArray<GoInt64>(...[for (i in 0...3) (0 : GoInt64)]);
			for (_i => _expr in (new Slice<stdgo.go.ast.Ast.Expr>(0, 0, _e.low, _e.high, _e.max) : Slice<stdgo.go.ast.Ast.Expr>)) {
				var _x:GoInt64 = (("-1" : GoInt64) : GoInt64);
				if (_expr != null) {
					var _max:GoInt64 = (("-1" : GoInt64) : GoInt64);
					if (_length >= ("0" : GoInt64)) {
						_max = _length + ("1" : GoInt64);
					};
					{
						var __tmp__ = _check._index(_expr, _max),
							_1:Type = __tmp__._0,
							_v:GoInt64 = __tmp__._1;
						if (_v >= ("0" : GoInt64)) {
							_x = _v;
						};
					};
				} else if (_i == ((0 : GoInt))) {
					_x = ("0" : GoInt64);
				} else if (_length >= ("0" : GoInt64)) {
					_x = _length;
				};
				_ind[(_i : GoInt)] = _x;
			};
			@:label("L") for (_i => _x in (_ind.__slice__(0, (2 : GoInt)) : Slice<GoInt64>)) {
				if (_x > ("0" : GoInt64)) {
					for (_j => _y in (_ind.__slice__(_i + (1 : GoInt)) : Slice<GoInt64>)) {
						if ((_y >= (("0" : GoInt64) : GoInt64)) && (_y < _x)) {
							var _at:stdgo.go.ast.Ast.Expr = (new Slice<stdgo.go.ast.Ast.Expr>(0, 0, _e.low, _e.high,
								_e.max) : Slice<stdgo.go.ast.Ast.Expr>)[((_i + (1 : GoInt)) + _j : GoInt)];
							_check._errorf(_at, (53 : T_errorCode), ("invalid slice indices: %d < %d" : GoString), Go.toInterface(_y), Go.toInterface(_x));
							@:jump("L") break;
						};
					};
				};
			};
		});
	}

	/**
		// If e is a valid function instantiation, indexExpr returns true.
		// In that case x represents the uninstantiated function value and
		// it is the caller's responsibility to instantiate the function.
	**/
	@:keep
	static public function _indexExpr(_check:Ref<Checker>, _x:Ref<T_operand>, _e:Ref<go.internal.typeparams.Typeparams.IndexExpr>):Bool {
		var _isFuncInst:Bool = false;
		_check._exprOrType(_x, _e.indexListExpr.x, true);
		if (_x._mode == ((0 : T_operandMode))) {
			_check._use(..._e.indexListExpr.indices.__toArray__());
			return false;
		} else if (_x._mode == ((3 : T_operandMode))) {
			_x._mode = (0 : T_operandMode);
			_x._typ = _check._varType(_e.orig);
			if (Go.toInterface(_x._typ) != (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
				_x._mode = (3 : T_operandMode);
			};
			return false;
		} else if (_x._mode == ((7 : T_operandMode))) {
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_under(_x._typ)) : Ref<Signature>)) : Ref<Signature>), ok: true};
				} catch (_) {
					{value: (null : Ref<Signature>), ok: false};
				}, _sig = __tmp__.value, _0 = __tmp__.ok;
				if ((_sig != null) && (_sig.typeParams().len() > (0 : GoInt))) {
					return true;
				};
			};
		};
		_check._nonGeneric(_x);
		if (_x._mode == ((0 : T_operandMode))) {
			return false;
		};
		var _valid:Bool = false;
		var _length:GoInt64 = (("-1" : GoInt64) : GoInt64);
		{
			final __type__ = _under(_x._typ);
			{
				var __bool__ = true;
				while (__bool__) {
					__bool__ = false;
					if (Go.typeEquals((__type__ : Ref<Basic>))) {
						var _typ:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
							.value;
						if (_isString(Go.asInterface(_typ))) {
							_valid = true;
							if (_x._mode == ((4 : T_operandMode))) {
								_length = (stdgo.go.constant.Constant.stringVal(_x._val).length : GoInt64);
							};
							_x._mode = (7 : T_operandMode);
							_x._typ = _universeByte;
						};
					} else if (Go.typeEquals((__type__ : Ref<Array_>))) {
						var _typ:Ref<Array_> = __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__() == null ? (null : Ref<Array_>) : __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__()
							.value;
						_valid = true;
						_length = _typ._len;
						if (_x._mode != ((5 : T_operandMode))) {
							_x._mode = (7 : T_operandMode);
						};
						_x._typ = _typ._elem;
					} else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
						var _typ:Ref<Pointer_> = __type__ == null ? (null : Ref<Pointer_>) : __type__.__underlying__() == null ? (null : Ref<Pointer_>) : __type__ == null ? (null : Ref<Pointer_>) : __type__.__underlying__()
							.value;
						{
							var __tmp__ = try {
								{value: (Go.typeAssert((Go.toInterface(_under(_typ._base)) : Ref<Array_>)) : Ref<Array_>), ok: true};
							} catch (_) {
								{value: (null : Ref<Array_>), ok: false};
							}, _typ = __tmp__.value, _1 = __tmp__.ok;
							if (_typ != null) {
								_valid = true;
								_length = _typ._len;
								_x._mode = (5 : T_operandMode);
								_x._typ = _typ._elem;
							};
						};
					} else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
						var _typ:Ref<Slice_> = __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__() == null ? (null : Ref<Slice_>) : __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__()
							.value;
						_valid = true;
						_x._mode = (5 : T_operandMode);
						_x._typ = _typ._elem;
					} else if (Go.typeEquals((__type__ : Ref<Map_>))) {
						var _typ:Ref<Map_> = __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__() == null ? (null : Ref<Map_>) : __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__()
							.value;
						var _index:stdgo.go.ast.Ast.Expr = _check._singleIndex(_e);
						if (_index == null) {
							_x._mode = (0 : T_operandMode);
							return false;
						};
						var _key:T_operand = ({} : T_operand);
						_check._expr((_key : Ref<T_operand>), _index);
						_check._assignment((_key : Ref<T_operand>), _typ._key, ("map index" : GoString));
						_x._mode = (6 : T_operandMode);
						_x._typ = _typ._elem;
						_x._expr = _e.orig;
						return false;
					} else if (Go.typeEquals((__type__ : Ref<Interface>))) {
						var _typ:Ref<Interface> = __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__() == null ? (null : Ref<Interface>) : __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__()
							.value;
						if (!_isTypeParam(_x._typ)) {
							break;
						};
						var _0:Type = (null : Type),
							_1:Type = (null : Type),
							_elem:Type = _1,
							_key:Type = _0;
						var _mode:T_operandMode = (5 : T_operandMode);
						if (_typ._typeSet()._underIs(function(_u:Type):Bool {
							var _l:GoInt64 = (("-1" : GoInt64) : GoInt64);
							var _0:Type = (null : Type),
								_1:Type = (null : Type),
								_e:Type = _1,
								_k:Type = _0;
							{
								final __type__ = _u;
								if (Go.typeEquals((__type__ : Ref<Basic>))) {
									var _t:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
										.value;
									if (_isString(Go.asInterface(_t))) {
										_e = _universeByte;
										_mode = (7 : T_operandMode);
									};
								} else if (Go.typeEquals((__type__ : Ref<Array_>))) {
									var _t:Ref<Array_> = __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__() == null ? (null : Ref<Array_>) : __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__()
										.value;
									_l = _t._len;
									_e = _t._elem;
									if (_x._mode != ((5 : T_operandMode))) {
										_mode = (7 : T_operandMode);
									};
								} else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
									var _t:Ref<Pointer_> = __type__ == null ? (null : Ref<Pointer_>) : __type__.__underlying__() == null ? (null : Ref<Pointer_>) : __type__ == null ? (null : Ref<Pointer_>) : __type__.__underlying__()
										.value;
									{
										var __tmp__ = try {
											{value: (Go.typeAssert((Go.toInterface(_under(_t._base)) : Ref<Array_>)) : Ref<Array_>), ok: true};
										} catch (_) {
											{value: (null : Ref<Array_>), ok: false};
										}, _t = __tmp__.value, _0 = __tmp__.ok;
										if (_t != null) {
											_l = _t._len;
											_e = _t._elem;
										};
									};
								} else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
									var _t:Ref<Slice_> = __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__() == null ? (null : Ref<Slice_>) : __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__()
										.value;
									_e = _t._elem;
								} else if (Go.typeEquals((__type__ : Ref<Map_>))) {
									var _t:Ref<Map_> = __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__() == null ? (null : Ref<Map_>) : __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__()
										.value;
									_k = _t._key;
									_e = _t._elem;
								};
							};
							if (_e == null) {
								return false;
							};
							if (_elem == null) {
								_length = _l;
								{
									final __tmp__0 = _k;
									final __tmp__1 = _e;
									_key = __tmp__0;
									_elem = __tmp__1;
								};
								return true;
							};
							if (!identical(_key, _k)) {
								return false;
							};
							if (!identical(_elem, _e)) {
								return false;
							};
							if ((_l >= (("0" : GoInt64) : GoInt64)) && (_l < _length)) {
								_length = _l;
							};
							return true;
						})) {
							if (_key != null) {
								var _index:stdgo.go.ast.Ast.Expr = _check._singleIndex(_e);
								if (_index == null) {
									_x._mode = (0 : T_operandMode);
									return false;
								};
								var _k:T_operand = ({} : T_operand);
								_check._expr((_k : Ref<T_operand>), _index);
								_check._assignment((_k : Ref<T_operand>), _key, ("map index" : GoString));
								_x._mode = (6 : T_operandMode);
								_x._typ = _elem;
								_x._expr = Go.asInterface(_e);
								return false;
							};
							_valid = true;
							_x._mode = _mode;
							_x._typ = _elem;
						};
					};
					break;
				};
			};
		};
		if (!_valid) {
			_check._invalidOp(Go.asInterface(_x), (51 : T_errorCode), ("cannot index %s" : GoString), Go.toInterface(Go.asInterface(_x)));
			_x._mode = (0 : T_operandMode);
			return false;
		};
		var _index:stdgo.go.ast.Ast.Expr = _check._singleIndex(_e);
		if (_index == null) {
			_x._mode = (0 : T_operandMode);
			return false;
		};
		if (_x._typ == null) {
			_x._typ = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
		};
		_check._index(_index, _length);
		return false;
	}

	/**
		// singleValue reports an error if x describes a tuple and sets x.mode to invalid.
	**/
	@:keep
	static public function _singleValue(_check:Ref<Checker>, _x:Ref<T_operand>):Void {
		if (_x._mode == ((7 : T_operandMode))) {
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_x._typ) : Ref<Tuple>)) : Ref<Tuple>), ok: true};
				} catch (_) {
					{value: (null : Ref<Tuple>), ok: false};
				}, _t = __tmp__.value, _ok = __tmp__.ok;
				if (_ok) {
					_assert(_t.len() != ((1 : GoInt)));
					if (false) {
						_check._errorf(Go.asInterface(_x), (41 : T_errorCode), ("multiple-value %s in single-value context" : GoString),
							Go.toInterface(Go.asInterface(_x)));
					} else {
						_check._errorf(Go.asInterface(_x), (41 : T_errorCode), ("%d-valued %s where single value is expected" : GoString),
							Go.toInterface(_t.len()), Go.toInterface(Go.asInterface(_x)));
					};
					_x._mode = (0 : T_operandMode);
				};
			};
		};
	}

	/**
		// exclude reports an error if x.mode is in modeset and sets x.mode to invalid.
		// The modeset may contain any of 1<<novalue, 1<<builtin, 1<<typexpr.
	**/
	@:keep
	static public function _exclude(_check:Ref<Checker>, _x:Ref<T_operand>, _modeset:GoUInt):Void {
		if (_modeset & ((("1" : GoUInt) : GoUInt) << _x._mode) != (("0" : GoUInt))) {
			var _msg:GoString = ("" : GoString);
			var _code:T_errorCode = ((0 : GoInt) : T_errorCode);
			if (_x._mode == ((1 : T_operandMode))) {
				if (_modeset & ("8" : GoUInt) != (("0" : GoUInt))) {
					_msg = ("%s used as value" : GoString);
				} else {
					_msg = ("%s used as value or type" : GoString);
				};
				_code = (41 : T_errorCode);
			} else if (_x._mode == ((2 : T_operandMode))) {
				_msg = ("%s must be called" : GoString);
				_code = (82 : T_errorCode);
			} else if (_x._mode == ((3 : T_operandMode))) {
				_msg = ("%s is not an expression" : GoString);
				_code = (42 : T_errorCode);
			} else {
				_unreachable();
			};
			_check._errorf(Go.asInterface(_x), _code, _msg, Go.toInterface(Go.asInterface(_x)));
			_x._mode = (0 : T_operandMode);
		};
	}

	/**
		// exprOrType typechecks expression or type e and initializes x with the expression value or type.
		// If allowGeneric is set, the operand type may be an uninstantiated parameterized type or function
		// value.
		// If an error occurred, x.mode is set to invalid.
	**/
	@:keep
	static public function _exprOrType(_check:Ref<Checker>, _x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _allowGeneric:Bool):Void {
		_check._rawExpr(_x, _e, (null : Type), _allowGeneric);
		_check._exclude(_x, ("2" : GoUInt));
		_check._singleValue(_x);
	}

	/**
		// exprWithHint typechecks expression e and initializes x with the expression value;
		// hint is the type of a composite literal element.
		// If an error occurred, x.mode is set to invalid.
	**/
	@:keep
	static public function _exprWithHint(_check:Ref<Checker>, _x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _hint:Type):Void {
		_assert(_hint != null);
		_check._rawExpr(_x, _e, _hint, false);
		_check._exclude(_x, ("14" : GoUInt));
		_check._singleValue(_x);
	}

	/**
		// multiExpr is like expr but the result may also be a multi-value.
	**/
	@:keep
	static public function _multiExpr(_check:Ref<Checker>, _x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr):Void {
		_check._rawExpr(_x, _e, (null : Type), false);
		_check._exclude(_x, ("14" : GoUInt));
	}

	/**
		// expr typechecks expression e and initializes x with the expression value.
		// The result must be a single value.
		// If an error occurred, x.mode is set to invalid.
	**/
	@:keep
	static public function _expr(_check:Ref<Checker>, _x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr):Void {
		_check._rawExpr(_x, _e, (null : Type), false);
		_check._exclude(_x, ("14" : GoUInt));
		_check._singleValue(_x);
	}

	/**
		// typeAssertion checks x.(T). The type of x must be an interface.
	**/
	@:keep
	static public function _typeAssertion(_check:Ref<Checker>, _e:stdgo.go.ast.Ast.Expr, _x:Ref<T_operand>, t:Type, _typeSwitch:Bool):Void {
		var __tmp__ = _check._assertableTo((Go.typeAssert((Go.toInterface(_under(_x._typ)) : Ref<Interface>)) : Ref<Interface>), t),
			_method:Ref<Func> = __tmp__._0,
			_alt:Ref<Func> = __tmp__._1;
		if (_method == null) {
			return;
		};
		var _cause:GoString = _check._missingMethodReason(t, _x._typ, _method, _alt);
		if (_typeSwitch) {
			_check._errorf(_e, (95 : T_errorCode), ("impossible type switch case: %s\n\t%s cannot have dynamic type %s %s" : GoString), Go.toInterface(_e),
				Go.toInterface(Go.asInterface(_x)), Go.toInterface(t), Go.toInterface(_cause));
			return;
		};
		_check._errorf(_e, (95 : T_errorCode), ("impossible type assertion: %s\n\t%s does not implement %s %s" : GoString), Go.toInterface(_e),
			Go.toInterface(t), Go.toInterface(_x._typ), Go.toInterface(_cause));
	}

	/**
		// exprInternal contains the core of type checking of expressions.
		// Must only be called by rawExpr.
	**/
	@:keep
	static public function _exprInternal(_check:Ref<Checker>, _x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _hint:Type):T_exprKind {
		return stdgo.internal.Macro.controlFlow({
			_x._mode = (0 : T_operandMode);
			_x._typ = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
			{
				final __type__ = _e;
				if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BadExpr>))) {
					var _e:Ref<stdgo.go.ast.Ast.BadExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BadExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BadExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BadExpr>) : __type__.__underlying__()
						.value;
					@:goto "Error";
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ident>))) {
					var _e:Ref<stdgo.go.ast.Ast.Ident> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__()
						.value;
					_check._ident(_x, _e, null, false);
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ellipsis>))) {
					var _e:Ref<stdgo.go.ast.Ast.Ellipsis> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__.__underlying__()
						.value;
					_check._error(Go.asInterface(_e), (77 : T_errorCode), ("invalid use of \'...\'" : GoString));
					@:goto "Error";
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BasicLit>))) {
					var _e:Ref<stdgo.go.ast.Ast.BasicLit> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BasicLit>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BasicLit>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BasicLit>) : __type__.__underlying__()
						.value;
					if (_e.kind == ((5 : stdgo.go.token.Token.Token))
						|| _e.kind == ((6 : stdgo.go.token.Token.Token))
						|| _e.kind == ((7 : stdgo.go.token.Token.Token))) {
						_check._langCompat(_e);
						{};
						if ((_e.value.length) > (10000 : GoInt)) {
							_check._errorf(Go.asInterface(_e), (14 : T_errorCode), ("excessively long constant: %s... (%d chars)" : GoString),
								Go.toInterface((_e.value.__slice__(0, (10 : GoInt)) : GoString)), Go.toInterface((_e.value.length)));
							@:goto "Error";
						};
					};
					_x._setConst(_e.kind, _e.value);
					if (_x._mode == ((0 : T_operandMode))) {
						_check._errorf(Go.asInterface(_e), (14 : T_errorCode), ("malformed constant: %s" : GoString), Go.toInterface(_e.value));
						@:goto "Error";
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.FuncLit>))) {
					var _e:Ref<stdgo.go.ast.Ast.FuncLit> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.FuncLit>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.FuncLit>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.FuncLit>) : __type__.__underlying__()
						.value;
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_check._typ(Go.asInterface(_e.type))) : Ref<Signature>)) : Ref<Signature>), ok: true};
						} catch (_) {
							{value: (null : Ref<Signature>), ok: false};
						}, _sig = __tmp__.value, _ok = __tmp__.ok;
						if (_ok) {
							if (!_check._conf.ignoreFuncBodies && (_e.body != null)) {
								var _decl = _check._environment._decl;
								var _iota:stdgo.go.constant.Constant.Value = _check._environment._iota;
								_check._later(function():Void {
									_check._funcBody(_decl, ("<function literal>" : GoString), _sig, _e.body, _iota);
								})._describef(Go.asInterface(_e), ("func literal" : GoString));
							};
							_x._mode = (7 : T_operandMode);
							_x._typ = Go.asInterface(_sig);
						} else {
							_check._invalidAST(Go.asInterface(_e), ("invalid function literal %s" : GoString), Go.toInterface(Go.asInterface(_e)));
							@:goto "Error";
						};
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CompositeLit>))) {
					var _e:Ref<stdgo.go.ast.Ast.CompositeLit> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CompositeLit>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.CompositeLit>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CompositeLit>) : __type__.__underlying__()
						.value;
					var _0:Type = (null : Type),
						_1:Type = (null : Type),
						_base:Type = _1,
						_typ:Type = _0;
					{
						var __switchIndex__ = -1;
						while (true) {
							if (_e.type != null) {
								{
									var __tmp__ = try {
										{value: (Go.typeAssert((Go.toInterface(_e.type) : Ref<stdgo.go.ast.Ast.ArrayType>)) : Ref<stdgo.go.ast.Ast.ArrayType>),
											ok: true};
									} catch (_) {
										{value: (null : Ref<stdgo.go.ast.Ast.ArrayType>), ok: false};
									}, _atyp = __tmp__.value, _6 = __tmp__.ok;
									if ((_atyp != null) && (_atyp.len != null)) {
										{
											var __tmp__ = try {
												{value: (Go.typeAssert((Go.toInterface(_atyp.len) : Ref<stdgo.go.ast.Ast.Ellipsis>)) : Ref<stdgo.go.ast.Ast.Ellipsis>),
													ok: true};
											} catch (_) {
												{value: (null : Ref<stdgo.go.ast.Ast.Ellipsis>), ok: false};
											}, _ellip = __tmp__.value, _7 = __tmp__.ok;
											if ((_ellip != null) && (_ellip.elt == null)) {
												_typ = Go.asInterface((({_len: ("-1" : GoInt64), _elem: _check._varType(_atyp.elt)} : Array_) : Ref<Array_>));
												_base = _typ;
												break;
											};
										};
									};
								};
								_typ = _check._typ(_e.type);
								_base = _typ;
								break;
							} else if (_hint != null) {
								_typ = _hint;
								{
									var __tmp__ = _deref(_coreType(_typ));
									_base = __tmp__._0;
								};
								if (_base == null) {
									_check._errorf(Go.asInterface(_e), (71 : T_errorCode),
										("invalid composite literal element type %s: no core type" : GoString), Go.toInterface(_typ));
									@:goto "Error";
								};
								break;
							} else {
								_check._error(Go.asInterface(_e), (70 : T_errorCode), ("missing type in composite literal" : GoString));
								@:goto "Error";
							};
							break;
						};
					};
					{
						final __type__ = _coreType(_base);
						{
							var __bool__ = true;
							while (__bool__) {
								__bool__ = false;
								if (Go.typeEquals((__type__ : Ref<Struct>))) {
									var _utyp:Ref<Struct> = __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__() == null ? (null : Ref<Struct>) : __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__()
										.value;
									if (_utyp._fields == null) {
										_check._error(Go.asInterface(_e), (11 : T_errorCode), ("illegal cycle in type declaration" : GoString));
										@:goto "Error";
									};
									if ((_e.elts.length) == ((0 : GoInt))) {
										break;
									};
									var _fields = _utyp._fields;
									{
										var __tmp__ = try {
											{value: (Go.typeAssert((Go.toInterface(_e.elts[(0 : GoInt)]) : Ref<stdgo.go.ast.Ast.KeyValueExpr>)) : Ref<stdgo.go.ast.Ast.KeyValueExpr>),
												ok: true};
										} catch (_) {
											{value: (null : Ref<stdgo.go.ast.Ast.KeyValueExpr>), ok: false};
										}, _8 = __tmp__.value, _ok = __tmp__.ok;
										if (_ok) {
											var _visited = new Slice<Bool>((_fields.length : GoInt).toBasic(), 0,
												...[for (i in 0...(_fields.length : GoInt).toBasic()) false]);
											for (_9 => _e in _e.elts) {
												var __tmp__ = try {
													{value: (Go.typeAssert((Go.toInterface(_e) : Ref<stdgo.go.ast.Ast.KeyValueExpr>)) : Ref<stdgo.go.ast.Ast.KeyValueExpr>),
														ok: true};
												} catch (_) {
													{value: (null : Ref<stdgo.go.ast.Ast.KeyValueExpr>), ok: false};
												}, _kv = __tmp__.value, _10 = __tmp__.ok;
												if (_kv == null) {
													_check._error(_e, (64 : T_errorCode),
														("mixture of field:value and value elements in struct literal" : GoString));
													continue;
												};
												var __tmp__ = try {
													{value: (Go.typeAssert((Go.toInterface(_kv.key) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>),
														ok: true};
												} catch (_) {
													{value: (null : Ref<stdgo.go.ast.Ast.Ident>), ok: false};
												}, _key = __tmp__.value, _11 = __tmp__.ok;
												_check._expr(_x, _kv.value);
												if (_key == null) {
													_check._errorf(Go.asInterface(_kv), (69 : T_errorCode),
														("invalid field name %s in struct literal" : GoString), Go.toInterface(_kv.key));
													continue;
												};
												var _i:GoInt = _fieldIndex(_utyp._fields, _check._pkg, _key.name);
												if (_i < (0:GoInt)) {
													_check._errorf(Go.asInterface(_kv), (66 : T_errorCode), ("unknown field %s in struct literal" : GoString),
														Go.toInterface(_key.name));
													continue;
												};
												var _fld = _fields[(_i : GoInt)];
												_check._recordUse(_key, Go.asInterface(_fld));
												var _etyp:Type = _fld._object._typ;
												_check._assignment(_x, _etyp, ("struct literal" : GoString));
												if (_visited[(_i : GoInt)]) {
													_check._errorf(Go.asInterface(_kv), (67 : T_errorCode),
														("duplicate field name %s in struct literal" : GoString), Go.toInterface(_key.name));
													continue;
												};
												_visited[(_i : GoInt)] = true;
											};
										} else {
											for (_i => _e in _e.elts) {
												{
													var __tmp__ = try {
														{value: (Go.typeAssert((Go.toInterface(_e) : Ref<stdgo.go.ast.Ast.KeyValueExpr>)) : Ref<stdgo.go.ast.Ast.KeyValueExpr>),
															ok: true};
													} catch (_) {
														{value: (null : Ref<stdgo.go.ast.Ast.KeyValueExpr>), ok: false};
													}, _kv = __tmp__.value, _14 = __tmp__.ok;
													if (_kv != null) {
														_check._error(Go.asInterface(_kv), (64 : T_errorCode),
															("mixture of field:value and value elements in struct literal" : GoString));
														continue;
													};
												};
												_check._expr(_x, _e);
												if (_i >= (_fields.length)) {
													_check._errorf(Go.asInterface(_x), (65 : T_errorCode), ("too many values in %s{…}" : GoString),
														Go.toInterface(_base));
													break;
												};
												var _fld = _fields[(_i : GoInt)];
												if (!_fld.exported() && (_fld._object._pkg != _check._pkg)) {
													_check._errorf(Go.asInterface(_x), (68 : T_errorCode),
														("implicit assignment to unexported field %s in %s literal" : GoString),
														Go.toInterface(_fld._object._name), Go.toInterface(_typ));
													continue;
												};
												var _etyp:Type = _fld._object._typ;
												_check._assignment(_x, _etyp, ("struct literal" : GoString));
											};
											if ((_e.elts.length) < (_fields.length)) {
												_check._errorf(Go.asInterface(_inNode(Go.asInterface(_e), _e.rbrace)), (65 : T_errorCode),
													("too few values in %s{…}" : GoString), Go.toInterface(_base));
											};
										};
									};
								} else if (Go.typeEquals((__type__ : Ref<Array_>))) {
									var _utyp:Ref<Array_> = __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__() == null ? (null : Ref<Array_>) : __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__()
										.value;
									if (_utyp._elem == null) {
										_check._error(Go.asInterface(_e), (12 : T_errorCode), ("illegal cycle in type declaration" : GoString));
										@:goto "Error";
									};
									var _n:GoInt64 = _check._indexedElts(_e.elts, _utyp._elem, _utyp._len);
									if (_utyp._len < ("0":GoInt64)) {
										_utyp._len = _n;
										if (_e.type != null) {
											_check._recordTypeAndValue(_e.type, (3 : T_operandMode), Go.asInterface(_utyp),
												(null : stdgo.go.constant.Constant.Value));
										};
									};
								} else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
									var _utyp:Ref<Slice_> = __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__() == null ? (null : Ref<Slice_>) : __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__()
										.value;
									if (_utyp._elem == null) {
										_check._error(Go.asInterface(_e), (12 : T_errorCode), ("illegal cycle in type declaration" : GoString));
										@:goto "Error";
									};
									_check._indexedElts(_e.elts, _utyp._elem, ("-1" : GoInt64));
								} else if (Go.typeEquals((__type__ : Ref<Map_>))) {
									var _utyp:Ref<Map_> = __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__() == null ? (null : Ref<Map_>) : __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__()
										.value;
									if ((_utyp._key == null) || (_utyp._elem == null)) {
										_check._error(Go.asInterface(_e), (12 : T_errorCode), ("illegal cycle in type declaration" : GoString));
										@:goto "Error";
									};
									var _keyIsInterface:Bool = _isNonTypeParamInterface(_utyp._key);
									var _visited = (new GoObjectMap<AnyInterface,
										Slice<Type>>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({
										get: () -> stdgo.internal.reflect.Reflect.GoType.interfaceType(true, [])
									},
										{get: () -> stdgo.internal.reflect.Reflect.GoType.sliceType({get: () ->
												stdgo.internal.reflect.Reflect.GoType.named("Type", [], null, false, {get: () ->
													null})})}))) : GoMap<AnyInterface, Slice<Type>>);
									for (_17 => _e in _e.elts) {
										var __tmp__ = try {
											{value: (Go.typeAssert((Go.toInterface(_e) : Ref<stdgo.go.ast.Ast.KeyValueExpr>)) : Ref<stdgo.go.ast.Ast.KeyValueExpr>),
												ok: true};
										} catch (_) {
											{value: (null : Ref<stdgo.go.ast.Ast.KeyValueExpr>), ok: false};
										}, _kv = __tmp__.value, _18 = __tmp__.ok;
										if (_kv == null) {
											_check._error(_e, (61 : T_errorCode), ("missing key in map literal" : GoString));
											continue;
										};
										_check._exprWithHint(_x, _kv.key, _utyp._key);
										_check._assignment(_x, _utyp._key, ("map literal" : GoString));
										if (_x._mode == ((0 : T_operandMode))) {
											continue;
										};
										if (_x._mode == ((4 : T_operandMode))) {
											var _duplicate:Bool = false;
											var _xkey:AnyInterface = _keyVal(_x._val);
											if (_keyIsInterface) {
												for (_19 => _vtyp in _visited[_xkey]) {
													if (identical(_vtyp, _x._typ)) {
														_duplicate = true;
														break;
													};
												};
												_visited[_xkey] = _visited[_xkey].__appendref__(_x._typ);
											} else {
												{
													var __tmp__ = (_visited != null
														&& _visited.__exists__(_xkey) ? {value: _visited[_xkey], ok: true} : {value: (null : Slice<Type>),
															ok: false});
													_duplicate = __tmp__.ok;
												};
												_visited[_xkey] = (null : Slice<Type>);
											};
											if (_duplicate) {
												_check._errorf(Go.asInterface(_x), (60 : T_errorCode), ("duplicate key %s in map literal" : GoString),
													Go.toInterface(_x._val));
												continue;
											};
										};
										_check._exprWithHint(_x, _kv.value, _utyp._elem);
										_check._assignment(_x, _utyp._elem, ("map literal" : GoString));
									};
								} else {
									var _utyp:Type = __type__ == null ? (null : Type) : cast __type__;
									for (_20 => _e in _e.elts) {
										{
											var __tmp__ = try {
												{value: (Go.typeAssert((Go.toInterface(_e) : Ref<stdgo.go.ast.Ast.KeyValueExpr>)) : Ref<stdgo.go.ast.Ast.KeyValueExpr>),
													ok: true};
											} catch (_) {
												{value: (null : Ref<stdgo.go.ast.Ast.KeyValueExpr>), ok: false};
											}, _kv = __tmp__.value, _21 = __tmp__.ok;
											if (_kv != null) {
												_e = _kv.value;
											};
										};
										_check._use(_e);
									};
									if (Go.toInterface(_utyp) != (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
										_check._errorf(Go.asInterface(_e), (71 : T_errorCode), ("invalid composite literal type %s" : GoString),
											Go.toInterface(_typ));
										@:goto "Error";
									};
								};
								break;
							};
						};
					};
					_x._mode = (7 : T_operandMode);
					_x._typ = _typ;
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ParenExpr>))) {
					var _e:Ref<stdgo.go.ast.Ast.ParenExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__()
						.value;
					var _kind:T_exprKind = _check._rawExpr(_x, _e.x, (null : Type), false);
					_x._expr = Go.asInterface(_e);
					return _kind;
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectorExpr>))) {
					var _e:Ref<stdgo.go.ast.Ast.SelectorExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__()
						.value;
					_check._selector(_x, _e, null);
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexExpr>))
					|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexListExpr>))) {
					var _e:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
					var _ix = go.internal.typeparams.Typeparams.unpackIndexExpr(_e);
					if (_check._indexExpr(_x, _ix)) {
						_check._funcInst(_x, _ix);
					};
					if (_x._mode == ((0 : T_operandMode))) {
						@:goto "Error";
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SliceExpr>))) {
					var _e:Ref<stdgo.go.ast.Ast.SliceExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SliceExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SliceExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SliceExpr>) : __type__.__underlying__()
						.value;
					_check._sliceExpr(_x, _e);
					if (_x._mode == ((0 : T_operandMode))) {
						@:goto "Error";
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.TypeAssertExpr>))) {
					var _e:Ref<stdgo.go.ast.Ast.TypeAssertExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeAssertExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.TypeAssertExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeAssertExpr>) : __type__.__underlying__()
						.value;
					_check._expr(_x, _e.x);
					if (_x._mode == ((0 : T_operandMode))) {
						@:goto "Error";
					};
					if (_isTypeParam(_x._typ)) {
						_check._invalidOp(Go.asInterface(_x), (94 : T_errorCode), ("cannot use type assertion on type parameter value %s" : GoString),
							Go.toInterface(Go.asInterface(_x)));
						@:goto "Error";
					};
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_under(_x._typ)) : Ref<Interface>)) : Ref<Interface>), ok: true};
						} catch (_) {
							{value: (null : Ref<Interface>), ok: false};
						}, _22 = __tmp__.value, _ok = __tmp__.ok;
						if (!_ok) {
							_check._invalidOp(Go.asInterface(_x), (94 : T_errorCode), ("%s is not an interface" : GoString),
								Go.toInterface(Go.asInterface(_x)));
							@:goto "Error";
						};
					};
					if (_e.type == null) {
						_check._error(Go.asInterface(_e), (115 : T_errorCode), ("use of .(type) outside type switch" : GoString));
						@:goto "Error";
					};
					var t:Type = _check._varType(_e.type);
					if (Go.toInterface(t) == (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
						@:goto "Error";
					};
					_check._typeAssertion(Go.asInterface(_e), _x, t, false);
					_x._mode = (8 : T_operandMode);
					_x._typ = t;
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CallExpr>))) {
					var _e:Ref<stdgo.go.ast.Ast.CallExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CallExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.CallExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CallExpr>) : __type__.__underlying__()
						.value;
					return _check._callExpr(_x, _e);
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.StarExpr>))) {
					var _e:Ref<stdgo.go.ast.Ast.StarExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__()
						.value;
					_check._exprOrType(_x, _e.x, false);
					if (_x._mode == ((0 : T_operandMode))) {
						@:goto "Error";
					} else if (_x._mode == ((3 : T_operandMode))) {
						_check._validVarType(_e.x, _x._typ);
						_x._typ = Go.asInterface((({_base: _x._typ} : Pointer_) : Ref<Pointer_>));
					} else {
						var _base:Type = (null : Type);
						if (!_underIs(_x._typ, function(_u:Type):Bool {
							var __tmp__ = try {
								{value: (Go.typeAssert((Go.toInterface(_u) : Ref<Pointer_>)) : Ref<Pointer_>), ok: true};
							} catch (_) {
								{value: (null : Ref<Pointer_>), ok: false};
							}, _p = __tmp__.value, _0 = __tmp__.ok;
							if (_p == null) {
								_check._invalidOp(Go.asInterface(_x), (50 : T_errorCode), ("cannot indirect %s" : GoString),
									Go.toInterface(Go.asInterface(_x)));
								return false;
							};
							if ((_base != null) && !identical(_p._base, _base)) {
								_check._invalidOp(Go.asInterface(_x), (50 : T_errorCode), ("pointers of %s must have identical base types" : GoString),
									Go.toInterface(Go.asInterface(_x)));
								return false;
							};
							_base = _p._base;
							return true;
						})) {
							@:goto "Error";
						};
						_x._mode = (5 : T_operandMode);
						_x._typ = _base;
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.UnaryExpr>))) {
					var _e:Ref<stdgo.go.ast.Ast.UnaryExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__()
						.value;
					_check._unary(_x, _e);
					if (_x._mode == ((0 : T_operandMode))) {
						@:goto "Error";
					};
					if (_e.op == ((36 : stdgo.go.token.Token.Token))) {
						_x._expr = Go.asInterface(_e);
						return (2 : T_exprKind);
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BinaryExpr>))) {
					var _e:Ref<stdgo.go.ast.Ast.BinaryExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__()
						.value;
					_check._binary(_x, Go.asInterface(_e), _e.x, _e.y, _e.op, _e.opPos);
					if (_x._mode == ((0 : T_operandMode))) {
						@:goto "Error";
					};
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.KeyValueExpr>))) {
					var _e:Ref<stdgo.go.ast.Ast.KeyValueExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.KeyValueExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.KeyValueExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.KeyValueExpr>) : __type__.__underlying__()
						.value;
					_check._invalidAST(Go.asInterface(_e), ("no key:value expected" : GoString));
					@:goto "Error";
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ArrayType>))
					|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.StructType>))
					|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.FuncType>))
					|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.InterfaceType>))
					|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.MapType>))
					|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ChanType>))) {
					var _e:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
					_x._mode = (3 : T_operandMode);
					_x._typ = _check._typ(_e);
				} else {
					var _e:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
					throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("%s: unknown expression type %T" : GoString),
						Go.toInterface(Go.asInterface(_check._fset.position(_e.pos()))), Go.toInterface(_e)));
				};
			};
			_x._expr = _e;
			return (1 : T_exprKind);
			@:label("Error") _x._mode = (0 : T_operandMode);
			_x._expr = _e;
			return (2 : T_exprKind);
		});
	}

	/**
		// If x is a generic function or type, nonGeneric reports an error and invalidates x.mode and x.typ.
		// Otherwise it leaves x alone.
	**/
	@:keep
	static public function _nonGeneric(_check:Ref<Checker>, _x:Ref<T_operand>):Void {
		if ((_x._mode == (0 : T_operandMode)) || (_x._mode == (1 : T_operandMode))) {
			return;
		};
		var _what:GoString = ("" : GoString);
		{
			final __type__ = _x._typ;
			if (Go.typeEquals((__type__ : Ref<Named>))) {
				var _t:Ref<Named> = __type__ == null ? (null : Ref<Named>) : __type__.__underlying__() == null ? (null : Ref<Named>) : __type__ == null ? (null : Ref<Named>) : __type__.__underlying__()
					.value;
				if (_isGeneric(Go.asInterface(_t))) {
					_what = ("type" : GoString);
				};
			} else if (Go.typeEquals((__type__ : Ref<Signature>))) {
				var _t:Ref<Signature> = __type__ == null ? (null : Ref<Signature>) : __type__.__underlying__() == null ? (null : Ref<Signature>) : __type__ == null ? (null : Ref<Signature>) : __type__.__underlying__()
					.value;
				if (_t._tparams != null) {
					_what = ("function" : GoString);
				};
			};
		};
		if (_what != (Go.str())) {
			_check._errorf(_x._expr, (137 : T_errorCode), ("cannot use generic %s %s without instantiation" : GoString), Go.toInterface(_what),
				Go.toInterface(_x._expr));
			_x._mode = (0 : T_operandMode);
			_x._typ = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
		};
	}

	/**
		// rawExpr typechecks expression e and initializes x with the expression
		// value or type. If an error occurred, x.mode is set to invalid.
		// If hint != nil, it is the type of a composite literal element.
		// If allowGeneric is set, the operand type may be an uninstantiated
		// parameterized type or function value.
	**/
	@:keep
	static public function _rawExpr(_check:Ref<Checker>, _x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _hint:Type, _allowGeneric:Bool):T_exprKind {
		var __deferstack__:Array<Void->Void> = [];
		if (false) {
			_check._trace(_e.pos(), ("-- expr %s" : GoString), Go.toInterface(_e));
			_check._indent++;
			__deferstack__.unshift(() -> {
				var a = function():Void {
					_check._indent--;
					_check._trace(_e.pos(), ("=> %s" : GoString), Go.toInterface(Go.asInterface(_x)));
				};
				a();
			});
		};
		var _kind:T_exprKind = _check._exprInternal(_x, _e, _hint);
		try {
			if (!_allowGeneric) {
				_check._nonGeneric(_x);
			};
			_check._record(_x);
			{
				for (defer in __deferstack__) {
					defer();
				};
				return _kind;
			};
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return ((0 : GoInt) : T_exprKind);
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return ((0 : GoInt) : T_exprKind);
		};
	}

	/**
		// If e != nil, it must be the binary expression; it may be nil for non-constant expressions
		// (when invoked for an assignment operation where the binary expression is implicit).
	**/
	@:keep
	static public function _binary(_check:Ref<Checker>, _x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _lhs:stdgo.go.ast.Ast.Expr, _rhs:stdgo.go.ast.Ast.Expr,
			_op:stdgo.go.token.Token.Token, _opPos:stdgo.go.token.Token.Pos):Void {
		var _y:T_operand = ({} : T_operand);
		_check._expr(_x, _lhs);
		_check._expr((_y : Ref<T_operand>), _rhs);
		if (_x._mode == ((0 : T_operandMode))) {
			return;
		};
		if (_y._mode == ((0 : T_operandMode))) {
			_x._mode = (0 : T_operandMode);
			_x._expr = _y._expr;
			return;
		};
		if (_isShift(_op)) {
			_check._shift(_x, (_y : Ref<T_operand>), _e, _op);
			return;
		};
		var _canMix = function(_x:Ref<T_operand>, _y:Ref<T_operand>):Bool {
			if (_isNonTypeParamInterface(_x._typ) || _isNonTypeParamInterface(_y._typ)) {
				return true;
			};
			if (_allBoolean(_x._typ) != (_allBoolean(_y._typ))) {
				return false;
			};
			if (_allString(_x._typ) != (_allString(_y._typ))) {
				return false;
			};
			if (_x._isNil() && !_hasNil(_y._typ)) {
				return false;
			};
			if (_y._isNil() && !_hasNil(_x._typ)) {
				return false;
			};
			return true;
		};
		if (_canMix(_x, (_y : Ref<T_operand>))) {
			_check._convertUntyped(_x, _y._typ);
			if (_x._mode == ((0 : T_operandMode))) {
				return;
			};
			_check._convertUntyped((_y : Ref<T_operand>), _x._typ);
			if (_y._mode == ((0 : T_operandMode))) {
				_x._mode = (0 : T_operandMode);
				return;
			};
		};
		if (_isComparison(_op)) {
			_check._comparison(_x, (_y : Ref<T_operand>), _op, false);
			return;
		};
		if (!identical(_x._typ, _y._typ)) {
			if ((Go.toInterface(_x._typ) != Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))
				&& (Go.toInterface(_y._typ) != Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
				var _posn:T_positioner = Go.asInterface(_x);
				if (_e != null) {
					_posn = _e;
				};
				if (_e != null) {
					_check._invalidOp(_posn, (46 : T_errorCode), ("%s (mismatched types %s and %s)" : GoString), Go.toInterface(_e), Go.toInterface(_x._typ),
						Go.toInterface(_y._typ));
				} else {
					_check._invalidOp(_posn, (46 : T_errorCode), ("%s %s= %s (mismatched types %s and %s)" : GoString), Go.toInterface(_lhs),
						Go.toInterface(Go.asInterface(_op)), Go.toInterface(_rhs), Go.toInterface(_x._typ), Go.toInterface(_y._typ));
				};
			};
			_x._mode = (0 : T_operandMode);
			return;
		};
		if (!_check._op(_binaryOpPredicates, _x, _op)) {
			_x._mode = (0 : T_operandMode);
			return;
		};
		if ((_op == (15 : stdgo.go.token.Token.Token)) || (_op == (16 : stdgo.go.token.Token.Token))) {
			if ((((_x._mode == (4 : T_operandMode)) || _allInteger(_x._typ)) && (_y._mode == (4 : T_operandMode)))
				&& (stdgo.go.constant.Constant.sign(_y._val) == (0 : GoInt))) {
				_check._invalidOp(Go.asInterface((_y : Ref<T_operand>)), (47 : T_errorCode), ("division by zero" : GoString));
				_x._mode = (0 : T_operandMode);
				return;
			};
			if (((_x._mode == (4 : T_operandMode)) && (_y._mode == (4 : T_operandMode))) && _isComplex(_x._typ)) {
				var _0:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.real(_y._val),
					_1:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.imag(_y._val),
					_im:stdgo.go.constant.Constant.Value = _1,
					_re:stdgo.go.constant.Constant.Value = _0;
				var _0:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.binaryOp(_re, (14 : stdgo.go.token.Token.Token), _re),
					_1:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.binaryOp(_im, (14 : stdgo.go.token.Token.Token), _im),
					_im2:stdgo.go.constant.Constant.Value = _1,
					_re2:stdgo.go.constant.Constant.Value = _0;
				if ((stdgo.go.constant.Constant.sign(_re2) == (0 : GoInt)) && (stdgo.go.constant.Constant.sign(_im2) == (0 : GoInt))) {
					_check._invalidOp(Go.asInterface((_y : Ref<T_operand>)), (47 : T_errorCode), ("division by zero" : GoString));
					_x._mode = (0 : T_operandMode);
					return;
				};
			};
		};
		if ((_x._mode == (4 : T_operandMode)) && (_y._mode == (4 : T_operandMode))) {
			if ((_x._val.kind() == (0 : stdgo.go.constant.Constant.Kind)) || (_y._val.kind() == (0 : stdgo.go.constant.Constant.Kind))) {
				_x._val = stdgo.go.constant.Constant.makeUnknown();
				return;
			};
			if ((_op == (15 : stdgo.go.token.Token.Token)) && _isInteger(_x._typ)) {
				_op = (26 : stdgo.go.token.Token.Token);
			};
			_x._val = stdgo.go.constant.Constant.binaryOp(_x._val, _op, _y._val);
			_x._expr = _e;
			_check._overflow(_x, _opPos);
			return;
		};
		_x._mode = (7 : T_operandMode);
	}

	/**
		// If e != nil, it must be the shift expression; it may be nil for non-constant shifts.
	**/
	@:keep
	static public function _shift(_check:Ref<Checker>, _x:Ref<T_operand>, _y:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _op:stdgo.go.token.Token.Token):Void {
		var _xval:stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
		if (_x._mode == ((4 : T_operandMode))) {
			_xval = stdgo.go.constant.Constant.toInt(_x._val);
		};
		if (_allInteger(_x._typ)
			|| ((_isUntyped(_x._typ) && (_xval != null)) && (_xval.kind() == (3 : stdgo.go.constant.Constant.Kind)))) {} else {
			_check._invalidOp(Go.asInterface(_x), (57 : T_errorCode), ("shifted operand %s must be integer" : GoString), Go.toInterface(Go.asInterface(_x)));
			_x._mode = (0 : T_operandMode);
			return;
		};
		if (_y._mode == ((4 : T_operandMode))) {
			var _yval:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.toInt(_y._val);
			if ((_yval.kind() == (3 : stdgo.go.constant.Constant.Kind)) && (stdgo.go.constant.Constant.sign(_yval) < (0:GoInt))) {
				_check._invalidOp(Go.asInterface(_y), (56 : T_errorCode), ("negative shift count %s" : GoString), Go.toInterface(Go.asInterface(_y)));
				_x._mode = (0 : T_operandMode);
				return;
			};
			if (_isUntyped(_y._typ)) {
				_check._representable(_y, typ[((7 : BasicKind) : GoInt)]);
				if (_y._mode == ((0 : T_operandMode))) {
					_x._mode = (0 : T_operandMode);
					return;
				};
			};
		} else {
			if (_allInteger(_y._typ)) {
				if (!_allUnsigned(_y._typ) && !_check._allowVersion(_check._pkg, (1 : GoInt), (13 : GoInt))) {
					_check._invalidOp(Go.asInterface(_y), (56 : T_errorCode), ("signed shift count %s requires go1.13 or later" : GoString),
						Go.toInterface(Go.asInterface(_y)));
					_x._mode = (0 : T_operandMode);
					return;
				};
			} else if (_isUntyped(_y._typ)) {
				_check._convertUntyped(_y, Go.asInterface(typ[((7 : BasicKind) : GoInt)]));
				if (_y._mode == ((0 : T_operandMode))) {
					_x._mode = (0 : T_operandMode);
					return;
				};
			} else {
				_check._invalidOp(Go.asInterface(_y), (56 : T_errorCode), ("shift count %s must be integer" : GoString), Go.toInterface(Go.asInterface(_y)));
				_x._mode = (0 : T_operandMode);
				return;
			};
		};
		if (_x._mode == ((4 : T_operandMode))) {
			if (_y._mode == ((4 : T_operandMode))) {
				if ((_x._val.kind() == (0 : stdgo.go.constant.Constant.Kind))
					|| (_y._val.kind() == (0 : stdgo.go.constant.Constant.Kind))) {
					_x._val = stdgo.go.constant.Constant.makeUnknown();
					if (!_isInteger(_x._typ)) {
						_x._typ = Go.asInterface(typ[((20 : BasicKind) : GoInt)]);
					};
					return;
				};
				{};
				var __tmp__ = stdgo.go.constant.Constant.uint64Val(_y._val),
					_s:GoUInt64 = __tmp__._0,
					_ok:Bool = __tmp__._1;
				if (!_ok || (_s > (("1074" : GoUInt64) : GoUInt64))) {
					_check._invalidOp(Go.asInterface(_y), (56 : T_errorCode), ("invalid shift count %s" : GoString), Go.toInterface(Go.asInterface(_y)));
					_x._mode = (0 : T_operandMode);
					return;
				};
				if (!_isInteger(_x._typ)) {
					_x._typ = Go.asInterface(typ[((20 : BasicKind) : GoInt)]);
				};
				_x._val = stdgo.go.constant.Constant.shift(_xval, _op, (_s : GoUInt));
				_x._expr = _e;
				var _opPos:stdgo.go.token.Token.Pos = _x.pos();
				{
					var __tmp__ = try {
						{value: (Go.typeAssert((Go.toInterface(_e) : Ref<stdgo.go.ast.Ast.BinaryExpr>)) : Ref<stdgo.go.ast.Ast.BinaryExpr>), ok: true};
					} catch (_) {
						{value: (null : Ref<stdgo.go.ast.Ast.BinaryExpr>), ok: false};
					}, _b = __tmp__.value, _2 = __tmp__.ok;
					if (_b != null) {
						_opPos = _b.opPos;
					};
				};
				_check._overflow(_x, _opPos);
				return;
			};
			if (_isUntyped(_x._typ)) {
				{
					var __tmp__ = (_check._untyped != null
						&& _check._untyped.__exists__(_x._expr) ? {value: _check._untyped[_x._expr], ok: true} : {value: ({} : T_exprInfo), ok: false}),
						_info:T_exprInfo = __tmp__.value,
						_found:Bool = __tmp__.ok;
					if (_found) {
						_info._isLhs = true;
						_check._untyped[_x._expr] = (_info == null ? null : _info.__copy__());
					};
				};
				_x._mode = (7 : T_operandMode);
				return;
			};
		};
		if (!_allInteger(_x._typ)) {
			_check._invalidOp(Go.asInterface(_x), (57 : T_errorCode), ("shifted operand %s must be integer" : GoString), Go.toInterface(Go.asInterface(_x)));
			_x._mode = (0 : T_operandMode);
			return;
		};
		_x._mode = (7 : T_operandMode);
	}

	/**
		// kindString returns the type kind as a string.
	**/
	@:keep
	static public function _kindString(_check:Ref<Checker>, _typ:Type):GoString {
		{
			final __type__ = _under(_typ);
			if (Go.typeEquals((__type__ : Ref<Array_>))) {
				return ("array" : GoString);
			} else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
				return ("slice" : GoString);
			} else if (Go.typeEquals((__type__ : Ref<Struct>))) {
				return ("struct" : GoString);
			} else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
				return ("pointer" : GoString);
			} else if (Go.typeEquals((__type__ : Ref<Signature>))) {
				return ("func" : GoString);
			} else if (Go.typeEquals((__type__ : Ref<Interface>))) {
				if (_isTypeParam(_typ)) {
					return _check._sprintf(("type parameter %s" : GoString), Go.toInterface(_typ));
				};
				return ("interface" : GoString);
			} else if (Go.typeEquals((__type__ : Ref<Map_>))) {
				return ("map" : GoString);
			} else if (Go.typeEquals((__type__ : Ref<Chan>))) {
				return ("chan" : GoString);
			} else {
				return _check._sprintf(("%s" : GoString), Go.toInterface(_typ));
			};
		};
	}

	/**
		// incomparableCause returns a more specific cause why typ is not comparable.
		// If there is no more specific cause, the result is "".
	**/
	@:keep
	static public function _incomparableCause(_check:Ref<Checker>, _typ:Type):GoString {
		{
			final __type__ = _under(_typ);
			if (Go.typeEquals((__type__ : Ref<Slice_>))
				|| Go.typeEquals((__type__ : Ref<Signature>))
				|| Go.typeEquals((__type__ : Ref<Map_>))) {
				return _check._kindString(_typ) + (" can only be compared to nil" : GoString);
			};
		};
		var _cause:GoString = ("" : GoString);
		_comparable(_typ, true, (null : GoMap<Type, Bool>), function(_format:GoString, _args:haxe.Rest<AnyInterface>):Void {
			_cause = _check._sprintf(_format, ..._args.__toArray__());
		});
		return _cause;
	}

	/**
		// If switchCase is true, the operator op is ignored.
	**/
	@:keep
	static public function _comparison(_check:Ref<Checker>, _x:Ref<T_operand>, _y:Ref<T_operand>, _op:stdgo.go.token.Token.Token, _switchCase:Bool):Void {
		stdgo.internal.Macro.controlFlow({
			if (_switchCase) {
				_op = (39 : stdgo.go.token.Token.Token);
			};
			var _errOp = _x;
			var _cause:GoString = Go.str();
			var _code:T_errorCode = (46 : T_errorCode);
			var __tmp__ = _x._assignableTo(_check, _y._typ, (null : Pointer<GoString>)),
				_ok:Bool = __tmp__._0,
				_0:T_errorCode = __tmp__._1;
			if (!_ok) {
				{
					var __tmp__ = _y._assignableTo(_check, _x._typ, (null : Pointer<GoString>));
					_ok = __tmp__._0;
				};
			};
			if (!_ok) {
				_errOp = _y;
				if (true) {
					_errOp = _x;
				};
				_cause = _check._sprintf(("mismatched types %s and %s" : GoString), Go.toInterface(_x._typ), Go.toInterface(_y._typ));
				@:goto "Error";
			};
			_code = (45 : T_errorCode);
			if (_op == ((39 : stdgo.go.token.Token.Token)) || _op == ((44 : stdgo.go.token.Token.Token))) {
				if (_x._isNil() || _y._isNil()) {
					var _typ:Type = _x._typ;
					if (_x._isNil()) {
						_typ = _y._typ;
					};
					if (!_hasNil(_typ)) {
						_errOp = _y;
						@:goto "Error";
					};
				} else if (!comparable(_x._typ)) {
					_errOp = _x;
					_cause = _check._incomparableCause(_x._typ);
					@:goto "Error";
				} else if (!comparable(_y._typ)) {
					_errOp = _y;
					_cause = _check._incomparableCause(_y._typ);
					@:goto "Error";
				};
			} else if (_op == ((40 : stdgo.go.token.Token.Token))
				|| _op == ((45 : stdgo.go.token.Token.Token))
				|| _op == ((41 : stdgo.go.token.Token.Token))
				|| _op == ((46 : stdgo.go.token.Token.Token))) {
				if (!_allOrdered(_x._typ)) {
					_errOp = _x;
					@:goto "Error";
				} else if (!_allOrdered(_y._typ)) {
					_errOp = _y;
					@:goto "Error";
				};
			} else {
				_unreachable();
			};
			if ((_x._mode == (4 : T_operandMode)) && (_y._mode == (4 : T_operandMode))) {
				_x._val = stdgo.go.constant.Constant.makeBool(stdgo.go.constant.Constant.compare(_x._val, _op, _y._val));
			} else {
				_x._mode = (7 : T_operandMode);
				_check._updateExprType(_x._expr, default_(_x._typ), true);
				_check._updateExprType(_y._expr, default_(_y._typ), true);
			};
			_x._typ = Go.asInterface(typ[((19 : BasicKind) : GoInt)]);
			return;
			@:label("Error") if (_cause == (Go.str())) {
				if (_isTypeParam(_x._typ) || _isTypeParam(_y._typ)) {
					if (!_isTypeParam(_x._typ)) {
						_errOp = _y;
					};
					_cause = _check._sprintf(("type parameter %s is not comparable with %s" : GoString), Go.toInterface(_errOp._typ),
						Go.toInterface(Go.asInterface(_op)));
				} else {
					_cause = _check._sprintf(("operator %s not defined on %s" : GoString), Go.toInterface(Go.asInterface(_op)),
						Go.toInterface(_check._kindString(_errOp._typ)));
				};
			};
			if (_switchCase) {
				_check._errorf(Go.asInterface(_x), _code, ("invalid case %s in switch on %s (%s)" : GoString), Go.toInterface(_x._expr),
					Go.toInterface(_y._expr), Go.toInterface(_cause));
			} else {
				if (false) {
					_check._invalidOp(Go.asInterface(_errOp), _code, ("%s %s %s (%s)" : GoString), Go.toInterface(_x._expr),
						Go.toInterface(Go.asInterface(_op)), Go.toInterface(_y._expr), Go.toInterface(_cause));
				} else {
					_check._invalidOp(Go.asInterface(_errOp), _code, ("cannot compare %s %s %s (%s)" : GoString), Go.toInterface(_x._expr),
						Go.toInterface(Go.asInterface(_op)), Go.toInterface(_y._expr), Go.toInterface(_cause));
				};
			};
			_x._mode = (0 : T_operandMode);
		});
	}

	/**
		// implicitTypeAndValue returns the implicit type of x when used in a context
		// where the target type is expected. If no such implicit conversion is
		// possible, it returns a nil Type and non-zero error code.
		//
		// If x is a constant operand, the returned constant.Value will be the
		// representation of x in this context.
	**/
	@:keep
	static public function _implicitTypeAndValue(_check:Ref<Checker>, _x:Ref<T_operand>,
			_target:Type):{var _0:Type; var _1:stdgo.go.constant.Constant.Value; var _2:T_errorCode;} {
		if (((_x._mode == (0 : T_operandMode)) || _isTyped(_x._typ))
			|| (Go.toInterface(_target) == Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
			return {_0: _x._typ, _1: (null : stdgo.go.constant.Constant.Value), _2: (0 : T_errorCode)};
		};
		if (_isUntyped(_target)) {
			var _xkind:BasicKind = (Go.typeAssert((Go.toInterface(_x._typ) : Ref<Basic>)) : Ref<Basic>)._kind;
			var _tkind:BasicKind = (Go.typeAssert((Go.toInterface(_target) : Ref<Basic>)) : Ref<Basic>)._kind;
			if (_isNumeric(_x._typ) && _isNumeric(_target)) {
				if (_xkind < _tkind) {
					return {_0: _target, _1: (null : stdgo.go.constant.Constant.Value), _2: (0 : T_errorCode)};
				};
			} else if (_xkind != (_tkind)) {
				return {_0: (null : Type), _1: (null : stdgo.go.constant.Constant.Value), _2: (97 : T_errorCode)};
			};
			return {_0: _x._typ, _1: (null : stdgo.go.constant.Constant.Value), _2: (0 : T_errorCode)};
		};
		{
			final __type__ = _under(_target);
			{
				var __bool__ = true;
				while (__bool__) {
					__bool__ = false;
					if (Go.typeEquals((__type__ : Ref<Basic>))) {
						var _u:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
							.value;
						if (_x._mode == ((4 : T_operandMode))) {
							var __tmp__ = _check._representation(_x, _u),
								_v:stdgo.go.constant.Constant.Value = __tmp__._0,
								_code:T_errorCode = __tmp__._1;
							if (_code != ((0 : T_errorCode))) {
								return {_0: (null : Type), _1: (null : stdgo.go.constant.Constant.Value), _2: _code};
							};
							return {_0: _target, _1: _v, _2: _code};
						};
						if ((Go.typeAssert((Go.toInterface(_x._typ) : Ref<Basic>)) : Ref<Basic>)._kind == ((19 : BasicKind))) {
							if (!_isBoolean(_target)) {
								return {_0: (null : Type), _1: (null : stdgo.go.constant.Constant.Value), _2: (97 : T_errorCode)};
							};
						} else if ((Go.typeAssert((Go.toInterface(_x._typ) : Ref<Basic>)) : Ref<Basic>)._kind == ((20 : BasicKind))
							|| (Go.typeAssert((Go.toInterface(_x._typ) : Ref<Basic>)) : Ref<Basic>)._kind == ((21 : BasicKind))
								|| (Go.typeAssert((Go.toInterface(_x._typ) : Ref<Basic>)) : Ref<Basic>)._kind == ((22 : BasicKind))
									|| (Go.typeAssert((Go.toInterface(_x._typ) : Ref<Basic>)) : Ref<Basic>)._kind == ((23 : BasicKind))) {
							if (!_isNumeric(_target)) {
								return {_0: (null : Type), _1: (null : stdgo.go.constant.Constant.Value), _2: (97 : T_errorCode)};
							};
						} else if ((Go.typeAssert((Go.toInterface(_x._typ) : Ref<Basic>)) : Ref<Basic>)._kind == ((24 : BasicKind))) {
							if (!_isString(_target)) {
								return {_0: (null : Type), _1: (null : stdgo.go.constant.Constant.Value), _2: (97 : T_errorCode)};
							};
						} else if ((Go.typeAssert((Go.toInterface(_x._typ) : Ref<Basic>)) : Ref<Basic>)._kind == ((25 : BasicKind))) {
							if (!_hasNil(_target)) {
								return {_0: (null : Type), _1: (null : stdgo.go.constant.Constant.Value), _2: (97 : T_errorCode)};
							};
							return {_0: Go.asInterface(typ[((25 : BasicKind) : GoInt)]), _1: (null : stdgo.go.constant.Constant.Value), _2: (0 : T_errorCode)};
						} else {
							return {_0: (null : Type), _1: (null : stdgo.go.constant.Constant.Value), _2: (97 : T_errorCode)};
						};
					} else if (Go.typeEquals((__type__ : Ref<Interface>))) {
						var _u:Ref<Interface> = __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__() == null ? (null : Ref<Interface>) : __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__()
							.value;
						if (_isTypeParam(_target)) {
							if (!_u._typeSet()._underIs(function(_u:Type):Bool {
								if (_u == null) {
									return false;
								};
								var __tmp__ = _check._implicitTypeAndValue(_x, _u),
									_t:Type = __tmp__._0,
									_0:stdgo.go.constant.Constant.Value = __tmp__._1,
									_1:T_errorCode = __tmp__._2;
								return _t != null;
							})) {
								return {_0: (null : Type), _1: (null : stdgo.go.constant.Constant.Value), _2: (97 : T_errorCode)};
							};
							if (_x._isNil()) {
								return {_0: Go.asInterface(typ[((25 : BasicKind) : GoInt)]), _1: (null : stdgo.go.constant.Constant.Value),
									_2: (0 : T_errorCode)};
							};
							break;
						};
						if (_x._isNil()) {
							return {_0: Go.asInterface(typ[((25 : BasicKind) : GoInt)]), _1: (null : stdgo.go.constant.Constant.Value), _2: (0 : T_errorCode)};
						};
						if (!_u.empty()) {
							return {_0: (null : Type), _1: (null : stdgo.go.constant.Constant.Value), _2: (97 : T_errorCode)};
						};
						return {_0: default_(_x._typ), _1: (null : stdgo.go.constant.Constant.Value), _2: (0 : T_errorCode)};
					} else if (Go.typeEquals((__type__ : Ref<Pointer_>))
						|| Go.typeEquals((__type__ : Ref<Signature>))
						|| Go.typeEquals((__type__ : Ref<Slice_>))
						|| Go.typeEquals((__type__ : Ref<Map_>))
						|| Go.typeEquals((__type__ : Ref<Chan>))) {
						var _u:Type = __type__ == null ? (null : Type) : cast __type__;
						if (!_x._isNil()) {
							return {_0: (null : Type), _1: (null : stdgo.go.constant.Constant.Value), _2: (97 : T_errorCode)};
						};
						return {_0: Go.asInterface(typ[((25 : BasicKind) : GoInt)]), _1: (null : stdgo.go.constant.Constant.Value), _2: (0 : T_errorCode)};
					} else {
						var _u:Type = __type__ == null ? (null : Type) : cast __type__;
						return {_0: (null : Type), _1: (null : stdgo.go.constant.Constant.Value), _2: (97 : T_errorCode)};
					};
					break;
				};
			};
		};
		return {_0: _target, _1: (null : stdgo.go.constant.Constant.Value), _2: (0 : T_errorCode)};
	}

	/**
		// convertUntyped attempts to set the type of an untyped value to the target type.
	**/
	@:keep
	static public function _convertUntyped(_check:Ref<Checker>, _x:Ref<T_operand>, _target:Type):Void {
		var __tmp__ = _check._implicitTypeAndValue(_x, _target),
			_newType:Type = __tmp__._0,
			_val:stdgo.go.constant.Constant.Value = __tmp__._1,
			_code:T_errorCode = __tmp__._2;
		if (_code != ((0 : T_errorCode))) {
			var _t:Type = _target;
			if (!_isTypeParam(_target)) {
				_t = _safeUnderlying(_target);
			};
			_check._invalidConversion(_code, _x, _t);
			_x._mode = (0 : T_operandMode);
			return;
		};
		if (_val != null) {
			_x._val = _val;
			_check._updateExprVal(_x._expr, _val);
		};
		if (Go.toInterface(_newType) != (Go.toInterface(_x._typ))) {
			_x._typ = _newType;
			_check._updateExprType(_x._expr, _newType, false);
		};
	}

	/**
		// updateExprVal updates the value of x to val.
	**/
	@:keep
	static public function _updateExprVal(_check:Ref<Checker>, _x:stdgo.go.ast.Ast.Expr, _val:stdgo.go.constant.Constant.Value):Void {
		{
			var __tmp__ = (_check._untyped != null
				&& _check._untyped.__exists__(_x) ? {value: _check._untyped[_x], ok: true} : {value: ({} : T_exprInfo), ok: false}),
				_info:T_exprInfo = __tmp__.value,
				_ok:Bool = __tmp__.ok;
			if (_ok) {
				_info._val = _val;
				_check._untyped[_x] = (_info == null ? null : _info.__copy__());
			};
		};
	}

	@:keep
	static public function _updateExprType0(_check:Ref<Checker>, _parent:stdgo.go.ast.Ast.Expr, _x:stdgo.go.ast.Ast.Expr, _typ:Type, _final:Bool):Void {
		var __tmp__ = (_check._untyped != null
			&& _check._untyped.__exists__(_x) ? {value: _check._untyped[_x], ok: true} : {value: ({} : T_exprInfo), ok: false}),
			_old:T_exprInfo = __tmp__.value,
			_found:Bool = __tmp__.ok;
		if (!_found) {
			return;
		};
		{
			final __type__ = _x;
			{
				var __bool__ = true;
				while (__bool__) {
					__bool__ = false;
					if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BadExpr>))
						|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.FuncLit>))
						|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CompositeLit>))
						|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexExpr>))
						|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SliceExpr>))
						|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.TypeAssertExpr>))
						|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.StarExpr>))
						|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.KeyValueExpr>))
						|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ArrayType>))
						|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.StructType>))
						|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.FuncType>))
						|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.InterfaceType>))
						|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.MapType>))
						|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ChanType>))) {
						var _x:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
						if (false) {
							_check._dump(("%v: found old type(%s): %s (new: %s)" : GoString), Go.toInterface(Go.asInterface(_x.pos())), Go.toInterface(_x),
								Go.toInterface(Go.asInterface(_old._typ)), Go.toInterface(_typ));
							_unreachable();
						};
						return;
					} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CallExpr>))) {
						var _x:Ref<stdgo.go.ast.Ast.CallExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CallExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.CallExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CallExpr>) : __type__.__underlying__()
							.value;
					} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ident>))
						|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BasicLit>))
						|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectorExpr>))) {
						var _x:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
					} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ParenExpr>))) {
						var _x:Ref<stdgo.go.ast.Ast.ParenExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__()
							.value;
						_check._updateExprType0(Go.asInterface(_x), _x.x, _typ, _final);
					} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.UnaryExpr>))) {
						var _x:Ref<stdgo.go.ast.Ast.UnaryExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__()
							.value;
						if (_old._val != null) {
							break;
						};
						_check._updateExprType0(Go.asInterface(_x), _x.x, _typ, _final);
					} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BinaryExpr>))) {
						var _x:Ref<stdgo.go.ast.Ast.BinaryExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__()
							.value;
						if (_old._val != null) {
							break;
						};
						if (_isComparison(_x.op)) {} else if (_isShift(_x.op)) {
							_check._updateExprType0(Go.asInterface(_x), _x.x, _typ, _final);
						} else {
							_check._updateExprType0(Go.asInterface(_x), _x.x, _typ, _final);
							_check._updateExprType0(Go.asInterface(_x), _x.y, _typ, _final);
						};
					} else {
						var _x:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
						_unreachable();
					};
					break;
				};
			};
		};
		if (!_final && _isUntyped(_typ)) {
			_old._typ = (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Basic>)) : Ref<Basic>);
			_check._untyped[_x] = (_old == null ? null : _old.__copy__());
			return;
		};
		if (_check._untyped != null)
			_check._untyped.__remove__(_x);
		if (_old._isLhs) {
			if (!_allInteger(_typ)) {
				if (false) {
					_check._invalidOp(_x, (57 : T_errorCode), ("%s (shift of type %s)" : GoString), Go.toInterface(_parent), Go.toInterface(_typ));
				} else {
					_check._invalidOp(_x, (57 : T_errorCode), ("shifted operand %s (type %s) must be integer" : GoString), Go.toInterface(_x),
						Go.toInterface(_typ));
				};
				return;
			};
		};
		if (_old._val != null) {
			var _c:T_operand = (new T_operand(_old._mode, _x, Go.asInterface(_old._typ), _old._val, (0 : T_builtinId)) : T_operand);
			_check._convertUntyped((_c : Ref<T_operand>), _typ);
			if (_c._mode == ((0 : T_operandMode))) {
				return;
			};
		};
		_check._recordTypeAndValue(_x, _old._mode, _typ, _old._val);
	}

	/**
		// updateExprType updates the type of x to typ and invokes itself
		// recursively for the operands of x, depending on expression kind.
		// If typ is still an untyped and not the final type, updateExprType
		// only updates the recorded untyped type for x and possibly its
		// operands. Otherwise (i.e., typ is not an untyped type anymore,
		// or it is the final type for x), the type and value are recorded.
		// Also, if x is a constant, it must be representable as a value of typ,
		// and if x is the (formerly untyped) lhs operand of a non-constant
		// shift, it must be an integer value.
	**/
	@:keep
	static public function _updateExprType(_check:Ref<Checker>, _x:stdgo.go.ast.Ast.Expr, _typ:Type, _final:Bool):Void {
		_check._updateExprType0((null : stdgo.go.ast.Ast.Expr), _x, _typ, _final);
	}

	@:keep
	static public function _invalidConversion(_check:Ref<Checker>, _code:T_errorCode, _x:Ref<T_operand>, _target:Type):Void {
		var _msg:GoString = ("cannot convert %s to %s" : GoString);
		if (_code == ((43 : T_errorCode))) {
			_msg = ("%s truncated to %s" : GoString);
		} else if (_code == ((44 : T_errorCode))) {
			_msg = ("%s overflows %s" : GoString);
		};
		_check._errorf(Go.asInterface(_x), _code, _msg, Go.toInterface(Go.asInterface(_x)), Go.toInterface(_target));
	}

	/**
		// representation returns the representation of the constant operand x as the
		// basic type typ.
		//
		// If no such representation is possible, it returns a non-zero error code.
	**/
	@:keep
	static public function _representation(_check:Ref<Checker>, _x:Ref<T_operand>,
			_typ:Ref<Basic>):{var _0:stdgo.go.constant.Constant.Value; var _1:T_errorCode;} {
		_assert(_x._mode == ((4 : T_operandMode)));
		var _v:stdgo.go.constant.Constant.Value = _x._val;
		if (!_representableConst(_x._val, _check, _typ, (_v : Ref<stdgo.go.constant.Constant.Value>))) {
			if (_isNumeric(_x._typ) && _isNumeric(Go.asInterface(_typ))) {
				if (!_isInteger(_x._typ) && _isInteger(Go.asInterface(_typ))) {
					return {_0: (null : stdgo.go.constant.Constant.Value), _1: (43 : T_errorCode)};
				} else {
					return {_0: (null : stdgo.go.constant.Constant.Value), _1: (44 : T_errorCode)};
				};
			};
			return {_0: (null : stdgo.go.constant.Constant.Value), _1: (14 : T_errorCode)};
		};
		return {_0: _v, _1: (0 : T_errorCode)};
	}

	/**
		// representable checks that a constant operand is representable in the given
		// basic type.
	**/
	@:keep
	static public function _representable(_check:Ref<Checker>, _x:Ref<T_operand>, _typ:Ref<Basic>):Void {
		var __tmp__ = _check._representation(_x, _typ),
			_v:stdgo.go.constant.Constant.Value = __tmp__._0,
			_code:T_errorCode = __tmp__._1;
		if (_code != ((0 : T_errorCode))) {
			_check._invalidConversion(_code, _x, Go.asInterface(_typ));
			_x._mode = (0 : T_operandMode);
			return;
		};
		_assert(_v != null);
		_x._val = _v;
	}

	/**
		// The unary expression e may be nil. It's passed in for better error messages only.
	**/
	@:keep
	static public function _unary(_check:Ref<Checker>, _x:Ref<T_operand>, _e:Ref<stdgo.go.ast.Ast.UnaryExpr>):Void {
		_check._expr(_x, _e.x);
		if (_x._mode == ((0 : T_operandMode))) {
			return;
		};
		if (_e.op == ((17 : stdgo.go.token.Token.Token))) {
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_unparen(_e.x)) : Ref<stdgo.go.ast.Ast.CompositeLit>)) : Ref<stdgo.go.ast.Ast.CompositeLit>),
						ok: true};
				} catch (_) {
					{value: (null : Ref<stdgo.go.ast.Ast.CompositeLit>), ok: false};
				}, _0 = __tmp__.value, _ok = __tmp__.ok;
				if (!_ok && (_x._mode != (5 : T_operandMode))) {
					_check._invalidOp(Go.asInterface(_x), (49 : T_errorCode), ("cannot take address of %s" : GoString), Go.toInterface(Go.asInterface(_x)));
					_x._mode = (0 : T_operandMode);
					return;
				};
			};
			_x._mode = (7 : T_operandMode);
			_x._typ = Go.asInterface((({_base: _x._typ} : Pointer_) : Ref<Pointer_>));
			return;
		} else if (_e.op == ((36 : stdgo.go.token.Token.Token))) {
			var _u:Type = _coreType(_x._typ);
			if (_u == null) {
				_check._invalidOp(Go.asInterface(_x), (58 : T_errorCode), ("cannot receive from %s: no core type" : GoString),
					Go.toInterface(Go.asInterface(_x)));
				_x._mode = (0 : T_operandMode);
				return;
			};
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_u) : Ref<Chan>)) : Ref<Chan>), ok: true};
			} catch (_) {
				{value: (null : Ref<Chan>), ok: false};
			}, _ch = __tmp__.value, _1 = __tmp__.ok;
			if (_ch == null) {
				_check._invalidOp(Go.asInterface(_x), (58 : T_errorCode), ("cannot receive from non-channel %s" : GoString),
					Go.toInterface(Go.asInterface(_x)));
				_x._mode = (0 : T_operandMode);
				return;
			};
			if (_ch._dir == ((1 : ChanDir))) {
				_check._invalidOp(Go.asInterface(_x), (58 : T_errorCode), ("cannot receive from send-only channel %s" : GoString),
					Go.toInterface(Go.asInterface(_x)));
				_x._mode = (0 : T_operandMode);
				return;
			};
			_x._mode = (8 : T_operandMode);
			_x._typ = _ch._elem;
			_check._environment._hasCallOrRecv = true;
			return;
		} else if (_e.op == ((88 : stdgo.go.token.Token.Token))) {
			_check._error(Go.asInterface(_e), (45 : T_errorCode), ("cannot use ~ outside of interface or type constraint" : GoString));
			_x._mode = (0 : T_operandMode);
			return;
		};
		if (!_check._op(_unaryOpPredicates, _x, _e.op)) {
			_x._mode = (0 : T_operandMode);
			return;
		};
		if (_x._mode == ((4 : T_operandMode))) {
			if (_x._val.kind() == ((0 : stdgo.go.constant.Constant.Kind))) {
				return;
			};
			var _prec:GoUInt = (0 : GoUInt);
			if (_isUnsigned(_x._typ)) {
				_prec = (_check._conf._sizeof(_x._typ) * ("8" : GoInt64):GoUInt);
			};
			_x._val = stdgo.go.constant.Constant.unaryOp(_e.op, _x._val, _prec);
			_x._expr = Go.asInterface(_e);
			_check._overflow(_x, _x.pos());
			return;
		};
		_x._mode = (7 : T_operandMode);
	}

	/**
		// overflow checks that the constant x is representable by its type.
		// For untyped constants, it checks that the value doesn't become
		// arbitrarily large.
	**/
	@:keep
	static public function _overflow(_check:Ref<Checker>, _x:Ref<T_operand>, _opPos:stdgo.go.token.Token.Pos):Void {
		_assert(_x._mode == ((4 : T_operandMode)));
		if (_x._val.kind() == ((0 : stdgo.go.constant.Constant.Kind))) {
			_check._errorf(Go.asInterface((_opPos : T_atPos)), (14 : T_errorCode), ("constant result is not representable" : GoString));
			return;
		};
		if (_isTyped(_x._typ)) {
			_check._representable(_x, (Go.typeAssert((Go.toInterface(_under(_x._typ)) : Ref<Basic>)) : Ref<Basic>));
			return;
		};
		{};
		if ((_x._val.kind() == (3 : stdgo.go.constant.Constant.Kind)) && (stdgo.go.constant.Constant.bitLen(_x._val) > (512 : GoInt))) {
			_check._errorf(Go.asInterface((_opPos : T_atPos)), (14 : T_errorCode), ("constant %s overflow" : GoString), Go.toInterface(_opName(_x._expr)));
			_x._val = stdgo.go.constant.Constant.makeUnknown();
		};
	}

	@:keep
	static public function _op(_check:Ref<Checker>, _m:T_opPredicates, _x:Ref<T_operand>, _op:stdgo.go.token.Token.Token):Bool {
		{
			var _pred:Type->Bool = _m[_op];
			if (_pred != null) {
				if (!_pred(_x._typ)) {
					_check._invalidOp(Go.asInterface(_x), (45 : T_errorCode), ("operator %s not defined on %s" : GoString),
						Go.toInterface(Go.asInterface(_op)), Go.toInterface(Go.asInterface(_x)));
					return false;
				};
			} else {
				_check._invalidAST(Go.asInterface(_x), ("unknown operator %s" : GoString), Go.toInterface(Go.asInterface(_op)));
				return false;
			};
		};
		return true;
	}

	@:keep
	static public function _invalidOp(_check:Ref<Checker>, _at:T_positioner, _code:T_errorCode, _format:GoString, _args:haxe.Rest<AnyInterface>):Void {
		var _args = new Slice<AnyInterface>(0, 0, ..._args);
		_check._errorf(_at, _code, ("invalid operation: " : GoString) + _format, ..._args.__toArray__());
	}

	@:keep
	static public function _invalidArg(_check:Ref<Checker>, _at:T_positioner, _code:T_errorCode, _format:GoString, _args:haxe.Rest<AnyInterface>):Void {
		var _args = new Slice<AnyInterface>(0, 0, ..._args);
		_check._errorf(_at, _code, ("invalid argument: " : GoString) + _format, ..._args.__toArray__());
	}

	@:keep
	static public function _invalidAST(_check:Ref<Checker>, _at:T_positioner, _format:GoString, _args:haxe.Rest<AnyInterface>):Void {
		var _args = new Slice<AnyInterface>(0, 0, ..._args);
		_check._errorf(_at, (0 : T_errorCode), ("invalid AST: " : GoString) + _format, ..._args.__toArray__());
	}

	@:keep
	static public function _versionErrorf(_check:Ref<Checker>, _at:T_positioner, _code:T_errorCode, _goVersion:GoString, _format:GoString,
			_args:haxe.Rest<AnyInterface>):Void {
		var _args = new Slice<AnyInterface>(0, 0, ..._args);
		var _msg:GoString = _check._sprintf(_format, ..._args.__toArray__());
		var _err:Ref<T_error_> = (null : Ref<T_error_>);
		if (false) {
			_err = _newErrorf(_at, _code, ("%s requires %s or later (-lang was set to %s; check go.mod)" : GoString), Go.toInterface(_msg),
				Go.toInterface(_goVersion), Go.toInterface(_check._conf.goVersion));
		} else {
			_err = _newErrorf(_at, _code, ("%s requires %s or later" : GoString), Go.toInterface(_msg), Go.toInterface(_goVersion));
		};
		_check._report(_err);
	}

	@:keep
	static public function _softErrorf(_check:Ref<Checker>, _at:T_positioner, _code:T_errorCode, _format:GoString, _args:haxe.Rest<AnyInterface>):Void {
		var _args = new Slice<AnyInterface>(0, 0, ..._args);
		var _err = _newErrorf(_at, _code, _format, ..._args.__toArray__());
		_err._soft = true;
		_check._report(_err);
	}

	@:keep
	static public function _errorf(_check:Ref<Checker>, _at:T_positioner, _code:T_errorCode, _format:GoString, _args:haxe.Rest<AnyInterface>):Void {
		var _args = new Slice<AnyInterface>(0, 0, ..._args);
		_check._report(_newErrorf(_at, _code, _format, ..._args.__toArray__()));
	}

	@:keep
	static public function _error(_check:Ref<Checker>, _at:T_positioner, _code:T_errorCode, _msg:GoString):Void {
		_check._report(_newErrorf(_at, _code, _msg));
	}

	/**
		// Report records the error pointed to by errp, setting check.firstError if
		// necessary.
	**/
	@:keep
	static public function _report(_check:Ref<Checker>, _errp:Ref<T_error_>):Void {
		if (_errp._empty()) {
			throw Go.toInterface(("empty error details" : GoString));
		};
		var _span:T_posSpan = (_spanOf(_errp._desc[(0 : GoInt)]._posn) == null ? null : _spanOf(_errp._desc[(0 : GoInt)]._posn).__copy__());
		var _e:T_error = ({
			fset: _check._fset,
			pos: _span._pos,
			msg: _errp._msg(_check._fset, _check._qualifier),
			soft: _errp._soft,
			_go116code: _errp._code,
			_go116start: _span._start,
			_go116end: _span._end
		} : T_error);
		var _isInvalidErr:Bool = (stdgo.strings.Strings.index(_e.msg, ("invalid operand" : GoString)) > (0 : GoInt))
			|| (stdgo.strings.Strings.index(_e.msg, ("invalid type" : GoString)) > (0 : GoInt));
		if ((_check._firstErr != null) && _isInvalidErr) {
			return;
		};
		_e.msg = _stripAnnotations(_e.msg);
		if (_check._environment._errpos != null) {
			var _span:T_posSpan = (_spanOf(_check._environment._errpos) == null ? null : _spanOf(_check._environment._errpos).__copy__());
			_e.pos = _span._pos;
			_e._go116start = _span._start;
			_e._go116end = _span._end;
		};
		var _err:T_error = (_e == null ? null : _e.__copy__());
		if (_check._firstErr == null) {
			_check._firstErr = Go.asInterface(_err);
		};
		if (false) {
			var _pos:stdgo.go.token.Token.Pos = _e.pos;
			var _msg:GoString = _e.msg;
			_check._trace(_pos, ("ERROR: %s" : GoString), Go.toInterface(_msg));
		};
		var _f:Error->Void = _check._conf.error;
		if (_f == null) {
			throw Go.toInterface((new T_bailout() : T_bailout));
		};
		_f(Go.asInterface(_err));
	}

	/**
		// dump is only needed for debugging
	**/
	@:keep
	static public function _dump(_check:Ref<Checker>, _format:GoString, _args:haxe.Rest<AnyInterface>):Void {
		var _args = new Slice<AnyInterface>(0, 0, ..._args);
		stdgo.fmt.Fmt.println(Go.toInterface(stdgo.go.types.Types._sprintf(_check._fset, _check._qualifier, true, _format, ..._args.__toArray__())));
	}

	@:keep
	static public function _trace(_check:Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _format:GoString, _args:haxe.Rest<AnyInterface>):Void {
		var _args = new Slice<AnyInterface>(0, 0, ..._args);
		stdgo.fmt.Fmt.printf(("%s:\t%s%s\n" : GoString), Go.toInterface(Go.asInterface(_check._fset.position(_pos))),
			Go.toInterface(stdgo.strings.Strings.repeat((".  " : GoString), _check._indent)),
			Go.toInterface(stdgo.go.types.Types._sprintf(_check._fset, _check._qualifier, true, _format, ..._args.__toArray__())));
	}

	/**
		// check may be nil.
	**/
	@:keep
	static public function _sprintf(_check:Ref<Checker>, _format:GoString, _args:haxe.Rest<AnyInterface>):GoString {
		var _args = new Slice<AnyInterface>(0, 0, ..._args);
		var _fset:Ref<stdgo.go.token.Token.FileSet> = (null : Ref<stdgo.go.token.Token.FileSet>);
		var _qf:Qualifier = (null : Qualifier);
		if (_check != null) {
			_fset = _check._fset;
			_qf = _check._qualifier;
		};
		return stdgo.go.types.Types._sprintf(_fset, _qf, false, _format, ..._args.__toArray__());
	}

	/**
		// markImports recursively walks pkg and its imports, to record unique import
		// paths in pkgPathMap.
	**/
	@:keep
	static public function _markImports(_check:Ref<Checker>, _pkg:Ref<Package>):Void {
		if (_check._seenPkgMap[_pkg]) {
			return;
		};
		_check._seenPkgMap[_pkg] = true;
		var __tmp__ = (_check._pkgPathMap != null
			&& _check._pkgPathMap.__exists__(_pkg._name) ? {value: _check._pkgPathMap[_pkg._name], ok: true} : {value: (null : GoMap<GoString, Bool>),
				ok: false}),
			_forName:GoMap<GoString, Bool> = __tmp__.value,
			_ok:Bool = __tmp__.ok;
		if (!_ok) {
			_forName = (new GoObjectMap<GoString, Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
				stdgo.internal.reflect.Reflect.GoType.basic(string_kind)},
				{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind)}))) : GoMap<GoString, Bool>);
			_check._pkgPathMap[_pkg._name] = _forName;
		};
		_forName[_pkg._path] = true;
		for (_10 => _imp in _pkg._imports) {
			_check._markImports(_imp);
		};
	}

	@:keep
	static public function _qualifier(_check:Ref<Checker>, _pkg:Ref<Package>):GoString {
		if (_pkg != (_check._pkg)) {
			if (_check._pkgPathMap == null) {
				_check._pkgPathMap = (new GoObjectMap<GoString, GoMap<GoString,
					Bool>>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({
					get: () -> stdgo.internal.reflect.Reflect.GoType.basic(string_kind)
				},
					{get: () -> stdgo.internal.reflect.Reflect.GoType.mapType({get: () -> stdgo.internal.reflect.Reflect.GoType.basic(string_kind)},
						{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind)})}))) : GoMap<GoString, GoMap<GoString, Bool>>);
				_check._seenPkgMap = (new GoObjectMap<Ref<Package>,
					Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({
					get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("Package", [], null,
						false, {get: () -> null})})
				},
					{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind)}))) : GoMap<Ref<Package>, Bool>);
				_check._markImports(_check._pkg);
			};
			if ((_check._pkgPathMap[_pkg._name].length) > (1 : GoInt)) {
				return stdgo.strconv.Strconv.quote(_pkg._path);
			};
			return _pkg._name;
		};
		return Go.str();
	}

	@:keep
	static public function _declStmt(_check:Ref<Checker>, _d:stdgo.go.ast.Ast.Decl):Void {
		var _pkg = _check._pkg;
		_check._walkDecl(_d, function(_d:T_decl):Void {
			{
				final __type__ = _d;
				{
					var __bool__ = true;
					while (__bool__) {
						__bool__ = false;
						if (Go.typeEquals((__type__ : T_constDecl))) {
							var _d:T_constDecl = __type__ == null ? ({} : T_constDecl) : __type__.__underlying__() == null ? ({} : T_constDecl) : __type__ == null ? ({} : T_constDecl) : __type__.__underlying__()
								.value;
							var _top:GoInt = (_check._delayed.length);
							var _lhs = new Slice<Ref<Const>>((_d._spec.names.length : GoInt).toBasic(), 0,
								...[for (i in 0...(_d._spec.names.length : GoInt).toBasic()) (null : Ref<Const>)]);
							for (_i => _name in _d._spec.names) {
								var _obj = newConst(_name.pos(), _pkg, _name.name, (null : Type), stdgo.go.constant.Constant.makeInt64((_d._iota : GoInt64)));
								_lhs[(_i : GoInt)] = _obj;
								var _init:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
								if (_i < (_d._init.length)) {
									_init = _d._init[(_i : GoInt)];
								};
								_check._constDecl(_obj, _d._typ, _init, _d._inherited);
							};
							_check._processDelayed(_top);
							var _scopePos:stdgo.go.token.Token.Pos = _d._spec.end();
							for (_i => _name in _d._spec.names) {
								_check._declare(_check._pkg._scope, _name, Go.asInterface(_lhs[(_i : GoInt)]), _scopePos);
							};
						} else if (Go.typeEquals((__type__ : T_varDecl))) {
							var _d:T_varDecl = __type__ == null ? ({} : T_varDecl) : __type__.__underlying__() == null ? ({} : T_varDecl) : __type__ == null ? ({} : T_varDecl) : __type__.__underlying__()
								.value;
							var _top:GoInt = (_check._delayed.length);
							var _lhs0 = new Slice<Ref<Var>>((_d._spec.names.length : GoInt).toBasic(), 0,
								...[for (i in 0...(_d._spec.names.length : GoInt).toBasic()) (null : Ref<Var>)]);
							for (_i => _name in _d._spec.names) {
								_lhs0[(_i : GoInt)] = newVar(_name.pos(), _pkg, _name.name, (null : Type));
							};
							for (_i => _obj in _lhs0) {
								var _lhs:Slice<Ref<Var>> = (null : Slice<Ref<Var>>);
								var _init:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
								if ((_d._spec.values.length) == ((_d._spec.names.length))) {
									_init = _d._spec.values[(_i : GoInt)];
								} else if ((_d._spec.values.length) == ((1 : GoInt))) {
									_lhs = _lhs0;
									_init = _d._spec.values[(0 : GoInt)];
								} else {
									if (_i < (_d._spec.values.length)) {
										_init = _d._spec.values[(_i : GoInt)];
									};
								};
								_check._varDecl(_obj, _lhs, _d._spec.type, _init);
								if ((_d._spec.values.length) == ((1 : GoInt))) {
									if (false) {
										for (_6 => _obj in _lhs0) {
											_assert(_obj._object._typ != null);
										};
									};
									break;
								};
							};
							_check._processDelayed(_top);
							var _scopePos:stdgo.go.token.Token.Pos = _d._spec.end();
							for (_i => _name in _d._spec.names) {
								_check._declare(_check._pkg._scope, _name, Go.asInterface(_lhs0[(_i : GoInt)]), _scopePos);
							};
						} else if (Go.typeEquals((__type__ : T_typeDecl))) {
							var _d:T_typeDecl = __type__ == null ? ({} : T_typeDecl) : __type__.__underlying__() == null ? ({} : T_typeDecl) : __type__ == null ? ({} : T_typeDecl) : __type__.__underlying__()
								.value;
							var _obj = newTypeName(_d._spec.name.pos(), _pkg, _d._spec.name.name, (null : Type));
							var _scopePos:stdgo.go.token.Token.Pos = _d._spec.name.pos();
							_check._declare(_check._pkg._scope, _d._spec.name, Go.asInterface(_obj), _scopePos);
							_obj._setColor((("2" : GoUInt32) : T_color) + (_check._push(Go.asInterface(_obj)) : T_color));
							_check._typeDecl(_obj, _d._spec, null);
							_check._pop()._setColor((("1" : GoUInt32) : T_color));
						} else {
							var _d:T_decl = __type__ == null ? (null : T_decl) : cast __type__;
							_check._invalidAST(_d._node(), ("unknown ast.Decl node %T" : GoString), Go.toInterface(_d._node()));
						};
						break;
					};
				};
			};
		});
	}

	@:keep
	static public function _funcDecl(_check:Ref<Checker>, _obj:Ref<Func>, _decl:Ref<T_declInfo>):Void {
		_assert(_obj._object._typ == null);
		_assert(_check._environment._iota == null);
		var _sig = ({} : Signature);
		_obj._object._typ = Go.asInterface(_sig);
		var _saved:T_color = _obj._object._color_;
		_obj._object._color_ = (("1" : GoUInt32) : T_color);
		var _fdecl = _decl._fdecl;
		_check._funcType(_sig, _fdecl.recv, _fdecl.type);
		_obj._object._color_ = _saved;
		if ((_fdecl.type.typeParams.numFields() > (0 : GoInt)) && (_fdecl.body == null)) {
			_check._softErrorf(Go.asInterface(_fdecl.name), (131 : T_errorCode), ("parameterized function is missing function body" : GoString));
		};
		if (!_check._conf.ignoreFuncBodies && (_fdecl.body != null)) {
			_check._later(function():Void {
				_check._funcBody(_decl, _obj._object._name, _sig, _fdecl.body, (null : stdgo.go.constant.Constant.Value));
			})._describef(Go.asInterface(_obj), ("func %s" : GoString), Go.toInterface(_obj._object._name));
		};
	}

	@:keep
	static public function _checkFieldUniqueness(_check:Ref<Checker>, _base:Ref<Named>):Void {
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_base._under()) : Ref<Struct>)) : Ref<Struct>), ok: true};
			} catch (_) {
				{value: (null : Ref<Struct>), ok: false};
			}, _t = __tmp__.value, _0 = __tmp__.ok;
			if (_t != null) {
				var _mset:T_objset = (null : T_objset);
				{
					var _i:GoInt = (0 : GoInt);
					Go.cfor(_i < _base.numMethods(), _i++, {
						var _m = _base.method(_i);
						_assert(_m._object._name != (("_" : GoString)));
						_assert(_mset._insert(Go.asInterface(_m)) == null);
					});
				};
				for (_1 => _fld in _t._fields) {
					if (_fld._object._name != (("_" : GoString))) {
						{
							var _alt:Object = _mset._insert(Go.asInterface(_fld));
							if (_alt != null) {
								(Go.typeAssert((Go.toInterface(_alt) : Ref<Func>)) : Ref<Func>);
								_check._errorf(_alt, (33 : T_errorCode), ("field and method with the same name %s" : GoString),
									Go.toInterface(_fld._object._name));
								_check._reportAltDecl(Go.asInterface(_fld));
							};
						};
					};
				};
			};
		};
	}

	@:keep
	static public function _collectMethods(_check:Ref<Checker>, _obj:Ref<TypeName>):Void {
		var _methods = _check._methods[_obj];
		if (_methods == null) {
			return;
		};
		if (_check._methods != null)
			_check._methods.__remove__(_obj);
		_assert(!_check._objMap[Go.asInterface(_obj)]._tdecl.assign.isValid());
		var _mset:T_objset = (null : T_objset);
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_obj._object._typ) : Ref<Named>)) : Ref<Named>), ok: true};
		} catch (_) {
			{value: (null : Ref<Named>), ok: false};
		}, _base = __tmp__.value, _6 = __tmp__.ok;
		if (_base != null) {
			_assert(_base.typeArgs().len() == ((0 : GoInt)));
			_check._later(function():Void {
				_check._checkFieldUniqueness(_base);
			})._describef(Go.asInterface(_obj), ("verifying field uniqueness for %v" : GoString), Go.toInterface(Go.asInterface(_base)));
			{
				var _i:GoInt = (0 : GoInt);
				Go.cfor(_i < _base.numMethods(), _i++, {
					var _m = _base.method(_i);
					_assert(_m._object._name != (("_" : GoString)));
					_assert(_mset._insert(Go.asInterface(_m)) == null);
				});
			};
		};
		for (_7 => _m in _methods) {
			_assert(_m._object._name != (("_" : GoString)));
			{
				var _alt:Object = _mset._insert(Go.asInterface(_m));
				if (_alt != null) {
					_check._errorf(Go.asInterface(_m), (34 : T_errorCode), ("method %s already declared for %s" : GoString), Go.toInterface(_m._object._name),
						Go.toInterface(Go.asInterface(_obj)));
					_check._reportAltDecl(_alt);
					continue;
				};
			};
			if (_base != null) {
				_base.addMethod(_m);
			};
		};
	}

	@:keep
	static public function _declareTypeParams(_check:Ref<Checker>, _tparams:Slice<Ref<TypeParam>>,
			_names:Slice<Ref<stdgo.go.ast.Ast.Ident>>):Slice<Ref<TypeParam>> {
		for (_0 => _name in _names) {
			var _tname = newTypeName(_name.pos(), _check._pkg, _name.name, (null : Type));
			var _tpar = _check._newTypeParam(_tname, Go.asInterface(typ[((0 : BasicKind) : GoInt)]));
			_check._declare(_check._pkg._scope, _name, Go.asInterface(_tname), _check._pkg._scope._pos);
			_tparams = _tparams.__appendref__(_tpar);
		};
		if (false && (_names.length > (0 : GoInt))) {
			_check._trace(_names[(0 : GoInt)].pos(), ("type params = %v" : GoString),
				Go.toInterface((_tparams.__slice__((_tparams.length) - (_names.length)) : Slice<Ref<TypeParam>>)));
		};
		return _tparams;
	}

	@:keep
	static public function _bound(_check:Ref<Checker>, _x:stdgo.go.ast.Ast.Expr):Type {
		var _wrap:Bool = false;
		{
			final __type__ = _x;
			if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.UnaryExpr>))) {
				var _op:Ref<stdgo.go.ast.Ast.UnaryExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__()
					.value;
				_wrap = _op.op == ((88 : stdgo.go.token.Token.Token));
			} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BinaryExpr>))) {
				var _op:Ref<stdgo.go.ast.Ast.BinaryExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__()
					.value;
				_wrap = _op.op == ((18 : stdgo.go.token.Token.Token));
			};
		};
		if (_wrap) {
			_x = Go.asInterface((({methods: (({list: (new Slice<Ref<stdgo.go.ast.Ast.Field>>(0, 0,
				({type: _x} : stdgo.go.ast.Ast.Field)) : Slice<Ref<stdgo.go.ast.Ast.Field>>)} : stdgo.go.ast.Ast.FieldList) : Ref<stdgo.go.ast.Ast.FieldList>)} : stdgo.go.ast.Ast.InterfaceType) : Ref<stdgo.go.ast.Ast.InterfaceType>));
			var _t:Type = _check._typ(_x);
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_t) : Ref<Interface>)) : Ref<Interface>), ok: true};
				} catch (_) {
					{value: (null : Ref<Interface>), ok: false};
				}, _t = __tmp__.value, _0 = __tmp__.ok;
				if (_t != null) {
					_t._implicit = true;
				};
			};
			return _t;
		};
		return _check._typ(_x);
	}

	@:keep
	static public function _collectTypeParams(_check:Ref<Checker>, _dst:Ref<Ref<TypeParamList>>, _list:Ref<stdgo.go.ast.Ast.FieldList>):Void {
		var __deferstack__:Array<Void->Void> = [];
		var _tparams:Slice<Ref<TypeParam>> = (null : Slice<Ref<TypeParam>>);
		try {
			for (_0 => _f in _list.list) {
				_tparams = _check._declareTypeParams(_tparams, _f.names);
			};
			_dst = _bindTParams(_tparams);
			_assert(!_check._environment._inTParamList);
			_check._environment._inTParamList = true;
			__deferstack__.unshift(() -> {
				var a = function():Void {
					_check._environment._inTParamList = false;
				};
				a();
			});
			var _index:GoInt = (0 : GoInt);
			for (_5 => _f in _list.list) {
				var _bound:Type = (null : Type);
				if (_f.type != null) {
					_bound = _check._bound(_f.type);
					if (_isTypeParam(_bound)) {
						_check._error(_f.type, (144 : T_errorCode), ("cannot use a type parameter as constraint" : GoString));
						_bound = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
					};
				} else {
					_bound = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
				};
				for (_i in 0..._f.names.length.toBasic()) {
					_tparams[(_index + _i : GoInt)]._bound = _bound;
				};
				_index = _index + ((_f.names.length));
			};
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return;
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return;
		};
	}

	@:keep
	static public function _typeDecl(_check:Ref<Checker>, _obj:Ref<TypeName>, _tdecl:Ref<stdgo.go.ast.Ast.TypeSpec>, _def:Ref<Named>):Void {
		var __deferstack__:Array<Void->Void> = [];
		_assert(_obj._object._typ == null);
		try {
			var _rhs:Type = (null : Type);
			_check._later(function():Void {
				{
					var __tmp__ = try {
						{value: (Go.typeAssert((Go.toInterface(_obj._object._typ) : Ref<Named>)) : Ref<Named>), ok: true};
					} catch (_) {
						{value: (null : Ref<Named>), ok: false};
					}, _t = __tmp__.value, _0 = __tmp__.ok;
					if (_t != null) {
						_check._validType(_t);
					};
				};
				if (_check._isImportedConstraint(_rhs) && !_check._allowVersion(_check._pkg, (1 : GoInt), (18 : GoInt))) {
					_check._errorf(_tdecl.type, (135 : T_errorCode), ("using type constraint %s requires go1.18 or later" : GoString), Go.toInterface(_rhs));
				};
			})._describef(Go.asInterface(_obj), ("validType(%s)" : GoString), Go.toInterface(_obj.name()));
			var _alias:Bool = _tdecl.assign.isValid();
			if (_alias && (_tdecl.typeParams.numFields() != (0 : GoInt))) {
				_check._error(Go.asInterface((_tdecl.assign : T_atPos)), (131 : T_errorCode), ("generic type cannot be alias" : GoString));
				_alias = false;
			};
			if (_alias) {
				if (!_check._allowVersion(_check._pkg, (1 : GoInt), (9 : GoInt))) {
					_check._errorf(Go.asInterface((_tdecl.assign : T_atPos)), (131 : T_errorCode), ("type aliases requires go1.9 or later" : GoString));
				};
				_check._brokenAlias(_obj);
				_rhs = _check._typ(_tdecl.type);
				_check._validAlias(_obj, _rhs);
				return;
			};
			var _named = _check._newNamed(_obj, (null : Type), (null : Slice<Ref<Func>>));
			_def._setUnderlying(Go.asInterface(_named));
			if (_tdecl.typeParams != null) {
				_check._openScope(Go.asInterface(_tdecl), ("type parameters" : GoString));
				__deferstack__.unshift(() -> _check._closeScope());
				_check._collectTypeParams((_named._tparams : Ref<Ref<TypeParamList>>), _tdecl.typeParams);
			};
			_rhs = _check._definedType(_tdecl.type, _named);
			_assert(_rhs != null);
			_named._fromRHS = _rhs;
			if (_named._underlying == null) {
				_named._underlying = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
			};
			if (_isTypeParam(_rhs)) {
				_check._error(_tdecl.type, (144 : T_errorCode), ("cannot use a type parameter as RHS in type declaration" : GoString));
				_named._underlying = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
			};
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return;
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return;
		};
	}

	/**
		// isImportedConstraint reports whether typ is an imported type constraint.
	**/
	@:keep
	static public function _isImportedConstraint(_check:Ref<Checker>, _typ:Type):Bool {
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_typ) : Ref<Named>)) : Ref<Named>), ok: true};
		} catch (_) {
			{value: (null : Ref<Named>), ok: false};
		}, _named = __tmp__.value, _0 = __tmp__.ok;
		if (((_named == null) || (_named._obj._object._pkg == _check._pkg)) || (_named._obj._object._pkg == null)) {
			return false;
		};
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_named._under()) : Ref<Interface>)) : Ref<Interface>), ok: true};
		} catch (_) {
			{value: (null : Ref<Interface>), ok: false};
		}, _u = __tmp__.value, _7 = __tmp__.ok;
		return (_u != null) && !_u.isMethodSet();
	}

	@:keep
	static public function _varDecl(_check:Ref<Checker>, _obj:Ref<Var>, _lhs:Slice<Ref<Var>>, _typ:stdgo.go.ast.Ast.Expr, _init:stdgo.go.ast.Ast.Expr):Void {
		_assert(_obj._object._typ == null);
		if (_typ != null) {
			_obj._object._typ = _check._varType(_typ);
		};
		if (_init == null) {
			if (_typ == null) {
				_obj._object._typ = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
			};
			return;
		};
		if ((_lhs == null) || (_lhs.length == (1 : GoInt))) {
			_assert((_lhs == null) || (_lhs[(0 : GoInt)] == _obj));
			var _x:T_operand = ({} : T_operand);
			_check._expr((_x : Ref<T_operand>), _init);
			_check._initVar(_obj, (_x : Ref<T_operand>), ("variable declaration" : GoString));
			return;
		};
		if (false) {
			var _found:Bool = false;
			for (_0 => _lhs in _lhs) {
				if (_obj == (_lhs)) {
					_found = true;
					break;
				};
			};
			if (!_found) {
				throw Go.toInterface(("inconsistent lhs" : GoString));
			};
		};
		if (_typ != null) {
			for (_1 => _lhs in _lhs) {
				_lhs._object._typ = _obj._object._typ;
			};
		};
		_check._initVars(_lhs, (new Slice<stdgo.go.ast.Ast.Expr>(0, 0, _init) : Slice<stdgo.go.ast.Ast.Expr>), (null : stdgo.go.ast.Ast.Stmt));
	}

	@:keep
	static public function _constDecl(_check:Ref<Checker>, _obj:Ref<Const>, _typ:stdgo.go.ast.Ast.Expr, _init:stdgo.go.ast.Ast.Expr, _inherited:Bool):Void {
		var __deferstack__:Array<Void->Void> = [];
		_assert(_obj._object._typ == null);
		try {
			{
				var _a0 = _check._environment._iota;
				var _a1 = _check._environment._errpos;
				__deferstack__.unshift(() -> {
					var a = function(_iota:stdgo.go.constant.Constant.Value, _errpos:T_positioner):Void {
						_check._environment._iota = _iota;
						_check._environment._errpos = _errpos;
					};
					a(_a0, _a1);
				});
			};
			_check._environment._iota = _obj._val;
			_check._environment._errpos = (null : T_positioner);
			_obj._val = stdgo.go.constant.Constant.makeUnknown();
			if (_typ != null) {
				var _t:Type = _check._typ(_typ);
				if (!_isConstType(_t)) {
					if (Go.toInterface(_under(_t)) != (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
						_check._errorf(_typ, (15 : T_errorCode), ("invalid constant type %s" : GoString), Go.toInterface(_t));
					};
					_obj._object._typ = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
					{
						for (defer in __deferstack__) {
							defer();
						};
						return;
					};
				};
				_obj._object._typ = _t;
			};
			var _x:T_operand = ({} : T_operand);
			if (_init != null) {
				if (_inherited) {
					_check._environment._errpos = Go.asInterface((_obj._object._pos : T_atPos));
				};
				_check._expr((_x : Ref<T_operand>), _init);
			};
			_check._initConst(_obj, (_x : Ref<T_operand>));
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return;
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return;
		};
	}

	@:keep
	static public function _walkDecl(_check:Ref<Checker>, _d:stdgo.go.ast.Ast.Decl, _f:T_decl->Void):Void {
		{
			final __type__ = _d;
			if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BadDecl>))) {
				var _d:Ref<stdgo.go.ast.Ast.BadDecl> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BadDecl>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BadDecl>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BadDecl>) : __type__.__underlying__()
					.value;
			} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.GenDecl>))) {
				var _d:Ref<stdgo.go.ast.Ast.GenDecl> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.GenDecl>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.GenDecl>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.GenDecl>) : __type__.__underlying__()
					.value;
				var _last:Ref<stdgo.go.ast.Ast.ValueSpec> = (null : Ref<stdgo.go.ast.Ast.ValueSpec>);
				for (_iota => _s in _d.specs) {
					{
						final __type__ = _s;
						if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ImportSpec>))) {
							var _s:Ref<stdgo.go.ast.Ast.ImportSpec> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ImportSpec>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ImportSpec>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ImportSpec>) : __type__.__underlying__()
								.value;
							_f(Go.asInterface((new T_importDecl(_s) : T_importDecl)));
						} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ValueSpec>))) {
							var _s:Ref<stdgo.go.ast.Ast.ValueSpec> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ValueSpec>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ValueSpec>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ValueSpec>) : __type__.__underlying__()
								.value;
							if (_d.tok == ((64 : stdgo.go.token.Token.Token))) {
								var _inherited:Bool = true;
								if ((_s.type != null) || (_s.values.length > (0 : GoInt))) {
									_last = _s;
									_inherited = false;
								} else if (_last == null) {
									_last = ({} : stdgo.go.ast.Ast.ValueSpec);
									_inherited = false;
								};
								_check._arityMatch(_s, _last);
								_f(Go.asInterface(({
									_spec: _s,
									_iota: _iota,
									_typ: _last.type,
									_init: _last.values,
									_inherited: _inherited
								} : T_constDecl)));
							} else if (_d.tok == ((85 : stdgo.go.token.Token.Token))) {
								_check._arityMatch(_s, null);
								_f(Go.asInterface((new T_varDecl(_s) : T_varDecl)));
							} else {
								_check._invalidAST(Go.asInterface(_s), ("invalid token %s" : GoString), Go.toInterface(Go.asInterface(_d.tok)));
							};
						} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.TypeSpec>))) {
							var _s:Ref<stdgo.go.ast.Ast.TypeSpec> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeSpec>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.TypeSpec>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeSpec>) : __type__.__underlying__()
								.value;
							_f(Go.asInterface((new T_typeDecl(_s) : T_typeDecl)));
						} else {
							var _s:stdgo.go.ast.Ast.Spec = __type__ == null ? (null : stdgo.go.ast.Ast.Spec) : cast __type__;
							_check._invalidAST(_s, ("unknown ast.Spec node %T" : GoString), Go.toInterface(_s));
						};
					};
				};
			} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.FuncDecl>))) {
				var _d:Ref<stdgo.go.ast.Ast.FuncDecl> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.FuncDecl>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.FuncDecl>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.FuncDecl>) : __type__.__underlying__()
					.value;
				_f(Go.asInterface((new T_funcDecl(_d) : T_funcDecl)));
			} else {
				var _d:stdgo.go.ast.Ast.Decl = __type__ == null ? (null : stdgo.go.ast.Ast.Decl) : cast __type__;
				_check._invalidAST(_d, ("unknown ast.Decl node %T" : GoString), Go.toInterface(_d));
			};
		};
	}

	@:keep
	static public function _walkDecls(_check:Ref<Checker>, _decls:Slice<stdgo.go.ast.Ast.Decl>, _f:T_decl->Void):Void {
		for (_0 => _d in _decls) {
			_check._walkDecl(_d, _f);
		};
	}

	/**
		// cycleError reports a declaration cycle starting with
		// the object in cycle that is "first" in the source.
	**/
	@:keep
	static public function _cycleError(_check:Ref<Checker>, _cycle:Slice<Object>):Void {
		var _name:Object->GoString = function(_obj:Object):GoString {
			var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
			_writePackage((_buf : Ref<stdgo.bytes.Bytes.Buffer>), _obj.pkg(), _check._qualifier);
			_buf.writeString(_obj.name());
			return (_buf.string() : GoString);
		};
		var _i:GoInt = _firstInSrc(_cycle);
		var _obj:Object = _cycle[(_i : GoInt)];
		var _objName:GoString = _name(_obj);
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_obj) : Ref<TypeName>)) : Ref<TypeName>), ok: true};
		} catch (_) {
			{value: (null : Ref<TypeName>), ok: false};
		}, _tname = __tmp__.value, _0 = __tmp__.ok;
		if ((_tname != null) && _tname.isAlias()) {
			_check._validAlias(_tname, Go.asInterface(typ[((0 : BasicKind) : GoInt)]));
		};
		if ((_tname != null) && false) {
			_check._errorf(_obj, (11 : T_errorCode), ("invalid recursive type %s" : GoString), Go.toInterface(_objName));
		} else {
			_check._errorf(_obj, (11 : T_errorCode), ("illegal cycle in declaration of %s" : GoString), Go.toInterface(_objName));
		};
		for (_ in 0..._cycle.length.toBasic()) {
			_check._errorf(_obj, (11 : T_errorCode), ("\t%s refers to" : GoString), Go.toInterface(_objName));
			_i++;
			if (_i >= (_cycle.length)) {
				_i = (0 : GoInt);
			};
			_obj = _cycle[(_i : GoInt)];
			_objName = _name(_obj);
		};
		_check._errorf(_obj, (11 : T_errorCode), ("\t%s" : GoString), Go.toInterface(_objName));
	}

	/**
		// validCycle checks if the cycle starting with obj is valid and
		// reports an error if it is not.
	**/
	@:keep
	static public function _validCycle(_check:Ref<Checker>, _obj:Object):Bool {
		return stdgo.internal.Macro.controlFlow({
			var __deferstack__:Array<Void->Void> = [];
			var _valid:Bool = false;
			if (false) {
				var _info = _check._objMap[_obj];
				var _inObjMap:Bool = (_info != null) && ((_info._fdecl == null) || (_info._fdecl.recv == null));
				var _isPkgObj:Bool = _obj.parent() == (_check._pkg._scope);
				if (_isPkgObj != (_inObjMap)) {
					_check._dump(("%v: inconsistent object map for %s (isPkgObj = %v, inObjMap = %v)" : GoString), Go.toInterface(Go.asInterface(_obj.pos())),
						Go.toInterface(_obj), Go.toInterface(_isPkgObj), Go.toInterface(_inObjMap));
					_unreachable();
				};
			};
			try {
				_assert(_obj._color() >= (("2" : GoUInt32) : T_color));
				var _start:T_color = _obj._color() - (("2" : GoUInt32) : T_color);
				var _cycle = (_check._objPath.__slice__(_start) : Slice<Object>);
				var _tparCycle:Bool = false;
				var _nval:GoInt = (0 : GoInt);
				var _ndef:GoInt = (0 : GoInt);
				@:label("loop") for (_6 => _obj in _cycle) {
					{
						final __type__ = _obj;
						{
							var __bool__ = true;
							while (__bool__) {
								__bool__ = false;
								if (Go.typeEquals((__type__ : Ref<Const>)) || Go.typeEquals((__type__ : Ref<Var>))) {
									var _obj:Object = __type__ == null ? (null : Object) : cast __type__;
									_nval++;
								} else if (Go.typeEquals((__type__ : Ref<TypeName>))) {
									var _obj:Ref<TypeName> = __type__ == null ? (null : Ref<TypeName>) : __type__.__underlying__() == null ? (null : Ref<TypeName>) : __type__ == null ? (null : Ref<TypeName>) : __type__.__underlying__()
										.value;
									if (_check._environment._inTParamList && _isGeneric(_obj._object._typ)) {
										_tparCycle = true;
										@:jump("loop") break;
									};
									var _alias:Bool = false;
									{
										var _d = _check._objMap[Go.asInterface(_obj)];
										if (_d != null) {
											_alias = _d._tdecl.assign.isValid();
										} else {
											_alias = _obj.isAlias();
										};
									};
									if (!_alias) {
										_ndef++;
									};
								} else if (Go.typeEquals((__type__ : Ref<Func>))) {
									var _obj:Ref<Func> = __type__ == null ? (null : Ref<Func>) : __type__.__underlying__() == null ? (null : Ref<Func>) : __type__ == null ? (null : Ref<Func>) : __type__.__underlying__()
										.value;
								} else {
									var _obj:Object = __type__ == null ? (null : Object) : cast __type__;
									_unreachable();
								};
								break;
							};
						};
					};
				};
				if (false) {
					_check._trace(_obj.pos(), ("## cycle detected: objPath = %s->%s (len = %d)" : GoString), Go.toInterface(_pathString(_cycle)),
						Go.toInterface(_obj.name()), Go.toInterface((_cycle.length)));
					if (_tparCycle) {
						_check._trace(_obj.pos(), ("## cycle contains: generic type in a type parameter list" : GoString));
					} else {
						_check._trace(_obj.pos(), ("## cycle contains: %d values, %d type definitions" : GoString), Go.toInterface(_nval),
							Go.toInterface(_ndef));
					};
					__deferstack__.unshift(() -> {
						var a = function():Void {
							if (_valid) {
								_check._trace(_obj.pos(), ("=> cycle is valid" : GoString));
							} else {
								_check._trace(_obj.pos(), ("=> error: cycle is invalid" : GoString));
							};
						};
						a();
					});
				};
				if (!_tparCycle) {
					if (_nval == ((_cycle.length))) {
						{
							for (defer in __deferstack__) {
								defer();
							};
							return true;
						};
					};
					if ((_nval == (0 : GoInt)) && (_ndef > (0 : GoInt))) {
						{
							for (defer in __deferstack__) {
								defer();
							};
							return true;
						};
					};
				};
				_check._cycleError(_cycle);
				{
					for (defer in __deferstack__) {
						defer();
					};
					return false;
				};
				for (defer in __deferstack__) {
					defer();
				};
				{
					for (defer in __deferstack__) {
						defer();
					};
					if (Go.recover_exception != null)
						throw Go.recover_exception;
					return _valid;
				};
			} catch (__exception__) {
				if (!(__exception__.native is AnyInterfaceData))
					throw __exception__;
				Go.recover_exception = __exception__.native;
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return _valid;
			};
		});
	}

	/**
		// objDecl type-checks the declaration of obj in its respective (file) environment.
		// For the meaning of def, see Checker.definedType, in typexpr.go.
	**/
	@:keep
	static public function _objDecl(_check:Ref<Checker>, _obj:Object, _def:Ref<Named>):Void {
		var __deferstack__:Array<Void->Void> = [];
		if (false && (_obj.type() == null)) {
			if (_check._indent == ((0 : GoInt))) {
				stdgo.fmt.Fmt.println();
			};
			_check._trace(_obj.pos(), ("-- checking %s (%s, objPath = %s)" : GoString), Go.toInterface(_obj), Go.toInterface(Go.asInterface(_obj._color())),
				Go.toInterface(_pathString(_check._objPath)));
			_check._indent++;
			__deferstack__.unshift(() -> {
				var a = function():Void {
					_check._indent--;
					_check._trace(_obj.pos(), ("=> %s (%s)" : GoString), Go.toInterface(_obj), Go.toInterface(Go.asInterface(_obj._color())));
				};
				a();
			});
		};
		try {
			if ((_obj._color() == (("0" : GoUInt32) : T_color)) && (_obj.type() != null)) {
				_obj._setColor((("1" : GoUInt32) : T_color));
				{
					for (defer in __deferstack__) {
						defer();
					};
					return;
				};
			};
			{
				var __switchIndex__ = -1;
				while (true) {
					if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (_obj._color() == (("0" : GoUInt32) : T_color)))) {
						_assert(_obj.type() == null);
						_obj._setColor((("2" : GoUInt32) : T_color) + (_check._push(_obj) : T_color));
						__deferstack__.unshift(() -> {
							var a = function():Void {
								_check._pop()._setColor((("1" : GoUInt32) : T_color));
							};
							a();
						});
						break;
						break;
					} else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && (_obj._color() == (("1" : GoUInt32) : T_color)))) {
						_assert(_obj.type() != null);
						{
							for (defer in __deferstack__) {
								defer();
							};
							return;
						};
						break;
						break;
					} else if (__switchIndex__ == 3 || (__switchIndex__ == -1 && (_obj._color() == (("2" : GoUInt32) : T_color)))) {
						{
							final __type__ = _obj;
							if (Go.typeEquals((__type__ : Ref<Const>))) {
								var _obj:Ref<Const> = __type__ == null ? (null : Ref<Const>) : __type__.__underlying__() == null ? (null : Ref<Const>) : __type__ == null ? (null : Ref<Const>) : __type__.__underlying__()
									.value;
								if (!_check._validCycle(Go.asInterface(_obj)) || (_obj._object._typ == null)) {
									_obj._object._typ = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
								};
							} else if (Go.typeEquals((__type__ : Ref<Var>))) {
								var _obj:Ref<Var> = __type__ == null ? (null : Ref<Var>) : __type__.__underlying__() == null ? (null : Ref<Var>) : __type__ == null ? (null : Ref<Var>) : __type__.__underlying__()
									.value;
								if (!_check._validCycle(Go.asInterface(_obj)) || (_obj._object._typ == null)) {
									_obj._object._typ = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
								};
							} else if (Go.typeEquals((__type__ : Ref<TypeName>))) {
								var _obj:Ref<TypeName> = __type__ == null ? (null : Ref<TypeName>) : __type__.__underlying__() == null ? (null : Ref<TypeName>) : __type__ == null ? (null : Ref<TypeName>) : __type__.__underlying__()
									.value;
								if (!_check._validCycle(Go.asInterface(_obj))) {
									_obj._object._typ = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
								};
							} else if (Go.typeEquals((__type__ : Ref<Func>))) {
								var _obj:Ref<Func> = __type__ == null ? (null : Ref<Func>) : __type__.__underlying__() == null ? (null : Ref<Func>) : __type__ == null ? (null : Ref<Func>) : __type__.__underlying__()
									.value;
								if (!_check._validCycle(Go.asInterface(_obj))) {};
							} else {
								var _obj:Object = __type__ == null ? (null : Object) : cast __type__;
								_unreachable();
							};
						};
						_assert(_obj.type() != null);
						{
							for (defer in __deferstack__) {
								defer();
							};
							return;
						};
						break;
						break;
					};
					break;
				};
			};
			var _d = _check._objMap[_obj];
			if (_d == null) {
				_check._dump(("%v: %s should have been declared" : GoString), Go.toInterface(Go.asInterface(_obj.pos())), Go.toInterface(_obj));
				_unreachable();
			};
			{
				var _a0 = _check._environment;
				__deferstack__.unshift(() -> {
					var a = function(_env:T_environment):Void {
						_check._environment = (_env == null ? null : _env.__copy__());
					};
					a((_a0 == null ? null : _a0.__copy__()));
				});
			};
			_check._environment = ({_scope: _d._file} : T_environment);
			{
				final __type__ = _obj;
				if (Go.typeEquals((__type__ : Ref<Const>))) {
					var _obj:Ref<Const> = __type__ == null ? (null : Ref<Const>) : __type__.__underlying__() == null ? (null : Ref<Const>) : __type__ == null ? (null : Ref<Const>) : __type__.__underlying__()
						.value;
					_check._environment._decl = _d;
					_check._constDecl(_obj, _d._vtyp, _d._init, _d._inherited);
				} else if (Go.typeEquals((__type__ : Ref<Var>))) {
					var _obj:Ref<Var> = __type__ == null ? (null : Ref<Var>) : __type__.__underlying__() == null ? (null : Ref<Var>) : __type__ == null ? (null : Ref<Var>) : __type__.__underlying__()
						.value;
					_check._environment._decl = _d;
					_check._varDecl(_obj, _d._lhs, _d._vtyp, _d._init);
				} else if (Go.typeEquals((__type__ : Ref<TypeName>))) {
					var _obj:Ref<TypeName> = __type__ == null ? (null : Ref<TypeName>) : __type__.__underlying__() == null ? (null : Ref<TypeName>) : __type__ == null ? (null : Ref<TypeName>) : __type__.__underlying__()
						.value;
					_check._typeDecl(_obj, _d._tdecl, _def);
					_check._collectMethods(_obj);
				} else if (Go.typeEquals((__type__ : Ref<Func>))) {
					var _obj:Ref<Func> = __type__ == null ? (null : Ref<Func>) : __type__.__underlying__() == null ? (null : Ref<Func>) : __type__ == null ? (null : Ref<Func>) : __type__.__underlying__()
						.value;
					_check._funcDecl(_obj, _d);
				} else {
					var _obj:Object = __type__ == null ? (null : Object) : cast __type__;
					_unreachable();
				};
			};
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return;
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return;
		};
	}

	@:keep
	static public function _declare(_check:Ref<Checker>, _scope:Ref<Scope>, _id:Ref<stdgo.go.ast.Ast.Ident>, _obj:Object, _pos:stdgo.go.token.Token.Pos):Void {
		if (_obj.name() != (("_" : GoString))) {
			{
				var _alt:Object = _scope.insert(_obj);
				if (_alt != null) {
					_check._errorf(_obj, (10 : T_errorCode), ("%s redeclared in this block" : GoString), Go.toInterface(_obj.name()));
					_check._reportAltDecl(_alt);
					return;
				};
			};
			_obj._setScopePos(_pos);
		};
		if (_id != null) {
			_check._recordDef(_id, _obj);
		};
	}

	@:keep
	static public function _reportAltDecl(_check:Ref<Checker>, _obj:Object):Void {
		{
			var _pos:stdgo.go.token.Token.Pos = _obj.pos();
			if (_pos.isValid()) {
				_check._errorf(_obj, (10 : T_errorCode), ("\tother declaration of %s" : GoString), Go.toInterface(_obj.name()));
			};
		};
	}

	/**
		// Conversion type-checks the conversion T(x).
		// The result is in x.
	**/
	@:keep
	static public function _conversion(_check:Ref<Checker>, _x:Ref<T_operand>, t:Type):Void {
		var _constArg:Bool = _x._mode == ((4 : T_operandMode));
		var _constConvertibleTo = function(t:Type, _val:Ref<stdgo.go.constant.Constant.Value>):Bool {
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_under(t)) : Ref<Basic>)) : Ref<Basic>), ok: true};
				} catch (_) {
					{value: (null : Ref<Basic>), ok: false};
				}, _t = __tmp__.value, _0 = __tmp__.ok;
				if (_t == null) {} else if (_representableConst(_x._val, _check, _t, _val)) {
					return true;
				} else if (_isInteger(_x._typ) && _isString(Go.asInterface(_t))) {
					var _codepoint:GoInt32 = (65533 : GoInt32);
					{
						var __tmp__ = stdgo.go.constant.Constant.uint64Val(_x._val), _i:GoUInt64 = __tmp__._0, _ok:Bool = __tmp__._1;
						if (_ok && (_i <= (("1114111" : GoUInt64) : GoUInt64))) {
							_codepoint = (_i : GoRune);
						};
					};
					if (_val != null) {
						_val = stdgo.go.constant.Constant.makeString((_codepoint : GoString));
					};
					return true;
				};
			};
			return false;
		};
		var _ok:Bool = false;
		var _cause:GoString = ("" : GoString);
		if (_constArg && _isConstType(t)) {
			_ok = _constConvertibleTo(t, (_x._val : Ref<stdgo.go.constant.Constant.Value>));
		} else if (_constArg && _isTypeParam(t)) {
			_ok = (Go.typeAssert((Go.toInterface(t) : Ref<TypeParam>)) : Ref<TypeParam>)._underIs(function(_u:Type):Bool {
				if (_u == null) {
					_cause = _check._sprintf(("%s does not contain specific types" : GoString), Go.toInterface(t));
					return false;
				};
				if (_isString(_x._typ) && _isBytesOrRunes(_u)) {
					return true;
				};
				if (!_constConvertibleTo(_u, (null : Ref<stdgo.go.constant.Constant.Value>))) {
					_cause = _check._sprintf(("cannot convert %s to %s (in %s)" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(_u),
						Go.toInterface(t));
					return false;
				};
				return true;
			});
			_x._mode = (7 : T_operandMode);
		} else if (_x._convertibleTo(_check, t, Go.pointer(_cause))) {
			_ok = true;
			_x._mode = (7 : T_operandMode);
		};
		if (!_ok) {
			if (false) {
				if (_cause != (Go.str())) {
					var _err = _newErrorf(Go.asInterface(_x), (96 : T_errorCode), ("cannot convert %s to type %s:" : GoString),
						Go.toInterface(Go.asInterface(_x)), Go.toInterface(t));
					_err._errorf((0 : stdgo.go.token.Token.Pos), _cause);
					_check._report(_err);
				} else {
					_check._errorf(Go.asInterface(_x), (96 : T_errorCode), ("cannot convert %s to type %s" : GoString), Go.toInterface(Go.asInterface(_x)),
						Go.toInterface(t));
				};
			} else {
				if (_cause != (Go.str())) {
					_check._errorf(Go.asInterface(_x), (96 : T_errorCode), ("cannot convert %s to %s (%s)" : GoString), Go.toInterface(Go.asInterface(_x)),
						Go.toInterface(t), Go.toInterface(_cause));
				} else {
					_check._errorf(Go.asInterface(_x), (96 : T_errorCode), ("cannot convert %s to %s" : GoString), Go.toInterface(Go.asInterface(_x)),
						Go.toInterface(t));
				};
			};
			_x._mode = (0 : T_operandMode);
			return;
		};
		if (_isUntyped(_x._typ)) {
			var _final:Type = t;
			if ((_isNonTypeParamInterface(t) || (_constArg && !_isConstType(t))) || _x._isNil()) {
				_final = default_(_x._typ);
			} else if (((_x._mode == (4 : T_operandMode)) && _isInteger(_x._typ)) && _allString(t)) {
				_final = _x._typ;
			};
			_check._updateExprType(_x._expr, _final, true);
		};
		_x._typ = t;
	}

	@:keep
	static public function _recordScope(_check:Ref<Checker>, _node:stdgo.go.ast.Ast.Node, _scope:Ref<Scope>):Void {
		_assert(_node != null);
		_assert(_scope != null);
		{
			var _m = _check.info.scopes;
			if (_m != null) {
				_m[_node] = _scope;
			};
		};
	}

	@:keep
	static public function _recordSelection(_check:Ref<Checker>, _x:Ref<stdgo.go.ast.Ast.SelectorExpr>, _kind:SelectionKind, _recv:Type, _obj:Object,
			_index:Slice<GoInt>, _indirect:Bool):Void {
		_assert((_obj != null) && ((_recv == null) || (_index.length > (0 : GoInt))));
		_check._recordUse(_x.sel, _obj);
		{
			var _m = _check.info.selections;
			if (_m != null) {
				_m[_x] = ((new Selection(_kind, _recv, _obj, _index, _indirect) : Selection) : Ref<Selection>);
			};
		};
	}

	@:keep
	static public function _recordImplicit(_check:Ref<Checker>, _node:stdgo.go.ast.Ast.Node, _obj:Object):Void {
		_assert(_node != null);
		_assert(_obj != null);
		{
			var _m = _check.info.implicits;
			if (_m != null) {
				_m[_node] = _obj;
			};
		};
	}

	@:keep
	static public function _recordUse(_check:Ref<Checker>, _id:Ref<stdgo.go.ast.Ast.Ident>, _obj:Object):Void {
		_assert(_id != null);
		_assert(_obj != null);
		{
			var _m = _check.info.uses;
			if (_m != null) {
				_m[_id] = _obj;
			};
		};
	}

	@:keep
	static public function _recordDef(_check:Ref<Checker>, _id:Ref<stdgo.go.ast.Ast.Ident>, _obj:Object):Void {
		_assert(_id != null);
		{
			var _m = _check.info.defs;
			if (_m != null) {
				_m[_id] = _obj;
			};
		};
	}

	/**
		// recordInstance records instantiation information into check.Info, if the
		// Instances map is non-nil. The given expr must be an ident, selector, or
		// index (list) expr with ident or selector operand.
		//
		// TODO(rfindley): the expr parameter is fragile. See if we can access the
		// instantiated identifier in some other way.
	**/
	@:keep
	static public function _recordInstance(_check:Ref<Checker>, _expr:stdgo.go.ast.Ast.Expr, _targs:Slice<Type>, _typ:Type):Void {
		var _ident = _instantiatedIdent(_expr);
		_assert(_ident != null);
		_assert(_typ != null);
		{
			var _m = _check.info.instances;
			if (_m != null) {
				_m[_ident] = (new Instance(_newTypeList(_targs), _typ) : Instance);
			};
		};
	}

	@:keep
	static public function _recordCommaOkTypes(_check:Ref<Checker>, _x:stdgo.go.ast.Ast.Expr, _a:GoArray<Type>):Void {
		_assert(_x != null);
		if ((_a[(0 : GoInt)] == null) || (_a[(1 : GoInt)] == null)) {
			return;
		};
		_assert((_isTyped(_a[(0 : GoInt)]) && _isTyped(_a[(1 : GoInt)]))
			&& (_isBoolean(_a[(1 : GoInt)]) || (Go.toInterface(_a[(1 : GoInt)]) == Go.toInterface(_universeError))));
		{
			var _m = _check.info.types;
			if (_m != null) {
				while (true) {
					var _tv:TypeAndValue = (_m[_x] == null ? null : _m[_x].__copy__());
					_assert(_tv.type != null);
					var _pos:stdgo.go.token.Token.Pos = _x.pos();
					_tv.type = Go.asInterface(newTuple(newVar(_pos, _check._pkg, Go.str(), _a[(0 : GoInt)]),
						newVar(_pos, _check._pkg, Go.str(), _a[(1 : GoInt)])));
					_m[_x] = (_tv == null ? null : _tv.__copy__());
					var __tmp__ = try {
						{value: (Go.typeAssert((Go.toInterface(_x) : Ref<stdgo.go.ast.Ast.ParenExpr>)) : Ref<stdgo.go.ast.Ast.ParenExpr>), ok: true};
					} catch (_) {
						{value: (null : Ref<stdgo.go.ast.Ast.ParenExpr>), ok: false};
					}, _p = __tmp__.value, _6 = __tmp__.ok;
					if (_p == null) {
						break;
					};
					_x = _p.x;
				};
			};
		};
	}

	@:keep
	static public function _recordBuiltinType(_check:Ref<Checker>, _f:stdgo.go.ast.Ast.Expr, _sig:Ref<Signature>):Void {
		while (true) {
			_check._recordTypeAndValue(_f, (2 : T_operandMode), Go.asInterface(_sig), (null : stdgo.go.constant.Constant.Value));
			{
				final __type__ = _f;
				if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ident>))
					|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectorExpr>))) {
					var _p:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
					return;
				} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ParenExpr>))) {
					var _p:Ref<stdgo.go.ast.Ast.ParenExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__()
						.value;
					_f = _p.x;
				} else {
					var _p:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
					_unreachable();
				};
			};
		};
	}

	@:keep
	static public function _recordTypeAndValue(_check:Ref<Checker>, _x:stdgo.go.ast.Ast.Expr, _mode:T_operandMode, _typ:Type,
			_val:stdgo.go.constant.Constant.Value):Void {
		_assert(_x != null);
		_assert(_typ != null);
		if (_mode == ((0 : T_operandMode))) {
			return;
		};
		if (_mode == ((4 : T_operandMode))) {
			_assert(_val != null);
			_assert((Go.toInterface(_typ) == Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))
				|| _allBasic(_typ, (59 : BasicInfo)));
		};
		{
			var _m = _check.info.types;
			if (_m != null) {
				_m[_x] = (new TypeAndValue(_mode, _typ, _val) : TypeAndValue);
			};
		};
	}

	@:keep
	static public function _recordUntyped(_check:Ref<Checker>):Void {
		if (true && (_check.info.types == null)) {
			return;
		};
		for (_x => info in _check._untyped) {
			if (false && _isTyped(Go.asInterface(info._typ))) {
				_check._dump(("%v: %s (type %s) is typed" : GoString), Go.toInterface(Go.asInterface(_x.pos())), Go.toInterface(_x),
					Go.toInterface(Go.asInterface(info._typ)));
				_unreachable();
			};
			_check._recordTypeAndValue(_x, info._mode, Go.asInterface(info._typ), info._val);
		};
	}

	@:keep
	static public function _record(_check:Ref<Checker>, _x:Ref<T_operand>):Void {
		var _typ:Type = (null : Type);
		var _val:stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
		if (_x._mode == ((0 : T_operandMode))) {
			_typ = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
		} else if (_x._mode == ((1 : T_operandMode))) {
			_typ = Go.asInterface((null : Ref<Tuple>));
		} else if (_x._mode == ((4 : T_operandMode))) {
			_typ = _x._typ;
			_val = _x._val;
		} else {
			_typ = _x._typ;
		};
		_assert((_x._expr != null) && (_typ != null));
		if (_isUntyped(_typ)) {
			_check._rememberUntyped(_x._expr, false, _x._mode, (Go.typeAssert((Go.toInterface(_typ) : Ref<Basic>)) : Ref<Basic>), _val);
		} else {
			_check._recordTypeAndValue(_x._expr, _x._mode, _typ, _val);
		};
	}

	/**
		// cleanup runs cleanup for all collected cleaners.
	**/
	@:keep
	static public function _cleanup(_check:Ref<Checker>):Void {
		{
			var _i:GoInt = (0 : GoInt);
			Go.cfor(_i < (_check._cleaners.length), _i++, {
				_check._cleaners[(_i : GoInt)]._cleanup();
			});
		};
		_check._cleaners = (null : Slice<T_cleaner>);
	}

	/**
		// processDelayed processes all delayed actions pushed after top.
	**/
	@:keep
	static public function _processDelayed(_check:Ref<Checker>, _top:GoInt):Void {
		{
			var _i:GoInt = _top;
			Go.cfor(_i < (_check._delayed.length), _i++, {
				var _a = (_check._delayed[(_i : GoInt)] : Ref<T_action>);
				if (false) {
					if (_a._desc != null) {
						_check._trace(_a._desc._pos.pos(), ("-- " : GoString) + _a._desc._format, ..._a._desc._args.__toArray__());
					} else {
						_check._trace((0 : stdgo.go.token.Token.Pos), ("-- delayed %p" : GoString), Go.toInterface(_a._f));
					};
				};
				_a._f();
				if (false) {
					stdgo.fmt.Fmt.println();
				};
			});
		};
		_assert(_top <= (_check._delayed.length));
		_check._delayed = (_check._delayed.__slice__(0, _top) : Slice<T_action>);
	}

	@:keep
	static public function _checkFiles(_check:Ref<Checker>, _files:Slice<Ref<stdgo.go.ast.Ast.File>>):Error {
		var __deferstack__:Array<Void->Void> = [];
		var _err:Error = (null : Error);
		if (_check._conf.fakeImportC && _check._conf._go115UsesCgo) {
			return _errBadCgo;
		};
		try {
			{
				var _a0 = (_err : Ref<Error>);
				__deferstack__.unshift(() -> _check._handleBailout(_a0));
			};
			var _print:GoString->Void = function(_msg:GoString):Void {
				if (false) {
					stdgo.fmt.Fmt.println();
					stdgo.fmt.Fmt.println(Go.toInterface(_msg));
				};
			};
			_print(("== initFiles ==" : GoString));
			_check._initFiles(_files);
			_print(("== collectObjects ==" : GoString));
			_check._collectObjects();
			_print(("== packageObjects ==" : GoString));
			_check._packageObjects();
			_print(("== processDelayed ==" : GoString));
			_check._processDelayed((0 : GoInt));
			_print(("== cleanup ==" : GoString));
			_check._cleanup();
			_print(("== initOrder ==" : GoString));
			_check._initOrder();
			if (!_check._conf.disableUnusedImportCheck) {
				_print(("== unusedImports ==" : GoString));
				_check._unusedImports();
			};
			_print(("== recordUntyped ==" : GoString));
			_check._recordUntyped();
			if (_check._firstErr == null) {
				_check._monomorph();
			};
			_check._pkg._complete = true;
			_check._imports = (null : Slice<Ref<PkgName>>);
			_check._dotImportMap = (null : GoMap<T_dotImportKey, Ref<PkgName>>);
			_check._pkgPathMap = (null : GoMap<GoString, GoMap<GoString, Bool>>);
			_check._seenPkgMap = (null : GoMap<Ref<Package>, Bool>);
			_check._recvTParamMap = (null : GoMap<Ref<stdgo.go.ast.Ast.Ident>, Ref<TypeParam>>);
			_check._brokenAliases = (null : GoMap<Ref<TypeName>, Bool>);
			_check._unionTypeSets = (null : GoMap<Ref<Union>, Ref<T__TypeSet>>);
			_check._ctxt = null;
			{
				for (defer in __deferstack__) {
					defer();
				};
				return _err;
			};
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return _err;
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return _err;
		};
	}

	/**
		// Files checks the provided files as part of the checker's package.
	**/
	@:keep
	static public function files(_check:Ref<Checker>, _files:Slice<Ref<stdgo.go.ast.Ast.File>>):Error {
		return _check._checkFiles(_files);
	}

	@:keep
	static public function _handleBailout(_check:Ref<Checker>, _err:Ref<Error>):Void {
		{
			final __type__ = ({
				final r = Go.recover_exception;
				Go.recover_exception = null;
				r;
			});
			if (__type__ == null || Go.typeEquals((__type__ : T_bailout))) {
				var _p:AnyInterface = __type__ == null ? null : __type__.__underlying__();
				_err = _check._firstErr;
			} else {
				var _p:AnyInterface = __type__ == null ? null : __type__.__underlying__();
				throw Go.toInterface(_p);
			};
		};
	}

	/**
		// initFiles initializes the files-specific portion of checker.
		// The provided files must all belong to the same package.
	**/
	@:keep
	static public function _initFiles(_check:Ref<Checker>, _files:Slice<Ref<stdgo.go.ast.Ast.File>>):Void {
		_check._files = (null : Slice<Ref<stdgo.go.ast.Ast.File>>);
		_check._imports = (null : Slice<Ref<PkgName>>);
		_check._dotImportMap = (null : GoMap<T_dotImportKey, Ref<PkgName>>);
		_check._firstErr = (null : Error);
		_check._methods = (null : GoMap<Ref<TypeName>, Slice<Ref<Func>>>);
		_check._untyped = (null : GoMap<stdgo.go.ast.Ast.Expr, T_exprInfo>);
		_check._delayed = (null : Slice<T_action>);
		_check._objPath = (null : Slice<Object>);
		_check._cleaners = (null : Slice<T_cleaner>);
		var _pkg = _check._pkg;
		for (_20 => _file in _files) {
			{
				var _name:GoString = _file.name.name;
				{
					var __switchIndex__ = -1;
					while (true) {
						if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (_pkg._name == Go.str()))) {
							if (_name != (("_" : GoString))) {
								_pkg._name = _name;
							} else {
								_check._errorf(Go.asInterface(_file.name), (2 : T_errorCode), ("invalid package name _" : GoString));
							};
							@:fallthrough {
								__switchIndex__ = 1;
								continue;
							};
							break;
						} else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && (_pkg._name == _name))) {
							_check._files = _check._files.__appendref__(_file);
							break;
							break;
						} else {
							_check._errorf(Go.asInterface((_file.package_ : T_atPos)), (3 : T_errorCode), ("package %s; expected %s" : GoString),
								Go.toInterface(_name), Go.toInterface(_pkg._name));
							break;
						};
						break;
					};
				};
			};
		};
	}

	/**
		// needsCleanup records objects/types that implement the cleanup method
		// which will be called at the end of type-checking.
	**/
	@:keep
	static public function _needsCleanup(_check:Ref<Checker>, _c:T_cleaner):Void {
		_check._cleaners = _check._cleaners.__appendref__(_c);
	}

	/**
		// pop pops and returns the topmost object from the object path.
	**/
	@:keep
	static public function _pop(_check:Ref<Checker>):Object {
		var _i:GoInt = (_check._objPath.length) - (1 : GoInt);
		var _obj:Object = _check._objPath[(_i : GoInt)];
		_check._objPath[(_i : GoInt)] = (null : Object);
		_check._objPath = (_check._objPath.__slice__(0, _i) : Slice<Object>);
		return _obj;
	}

	/**
		// push pushes obj onto the object path and returns its index in the path.
	**/
	@:keep
	static public function _push(_check:Ref<Checker>, _obj:Object):GoInt {
		_check._objPath = _check._objPath.__appendref__(_obj);
		return (_check._objPath.length) - (1 : GoInt);
	}

	/**
		// later pushes f on to the stack of actions that will be processed later;
		// either at the end of the current statement, or in case of a local constant
		// or variable declaration, before the constant or variable is in scope
		// (so that f still sees the scope before any new declarations).
		// later returns the pushed action so one can provide a description
		// via action.describef for debugging, if desired.
	**/
	@:keep
	static public function _later(_check:Ref<Checker>, _f:() -> Void):Ref<T_action> {
		var _i:GoInt = (_check._delayed.length);
		_check._delayed = _check._delayed.__appendref__(({_f: _f} : T_action));
		return (_check._delayed[(_i : GoInt)] : Ref<T_action>);
	}

	@:keep
	static public function _rememberUntyped(_check:Ref<Checker>, _e:stdgo.go.ast.Ast.Expr, _lhs:Bool, _mode:T_operandMode, _typ:Ref<Basic>,
			_val:stdgo.go.constant.Constant.Value):Void {
		var _m = _check._untyped;
		if (_m == null) {
			_m = (new GoObjectMap<stdgo.go.ast.Ast.Expr,
				T_exprInfo>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
					stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.ast.Ast.Expr", [], null, false, {get: () -> null})},
				{get: () -> stdgo.internal.reflect.Reflect.GoType.named("T_exprInfo", [], null, false,
					{get: () -> null})}))) : GoMap<stdgo.go.ast.Ast.Expr, T_exprInfo>);
			_check._untyped = _m;
		};
		_m[_e] = (new T_exprInfo(_lhs, _mode, _typ, _val) : T_exprInfo);
	}

	/**
		// isBrokenAlias reports whether alias doesn't have a determined type yet.
	**/
	@:keep
	static public function _isBrokenAlias(_check:Ref<Checker>, _alias:Ref<TypeName>):Bool {
		return (Go.toInterface(_alias._object._typ) == Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))
			&& _check._brokenAliases[_alias];
	}

	/**
		// validAlias records that alias has the valid type typ (possibly Typ[Invalid]).
	**/
	@:keep
	static public function _validAlias(_check:Ref<Checker>, _alias:Ref<TypeName>, _typ:Type):Void {
		if (_check._brokenAliases != null)
			_check._brokenAliases.__remove__(_alias);
		_alias._object._typ = _typ;
	}

	/**
		// brokenAlias records that alias doesn't have a determined type yet.
		// It also sets alias.typ to Typ[Invalid].
	**/
	@:keep
	static public function _brokenAlias(_check:Ref<Checker>, _alias:Ref<TypeName>):Void {
		if (_check._brokenAliases == null) {
			_check._brokenAliases = (new GoObjectMap<Ref<TypeName>,
				Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({
				get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("TypeName", [], null, false,
					{get: () -> null})})
			},
				{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind)}))) : GoMap<Ref<TypeName>, Bool>);
		};
		_check._brokenAliases[_alias] = true;
		_alias._object._typ = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
	}

	/**
		// addDeclDep adds the dependency edge (check.decl -> to) if check.decl exists
	**/
	@:keep
	static public function _addDeclDep(_check:Ref<Checker>, _to:Object):Void {
		var _from = _check._environment._decl;
		if (_from == null) {
			return;
		};
		{
			var __tmp__ = (_check._objMap != null
				&& _check._objMap.__exists__(_to) ? {value: _check._objMap[_to], ok: true} : {value: (null : Ref<T_declInfo>), ok: false}),
				_6:Ref<T_declInfo> = __tmp__.value,
				_found:Bool = __tmp__.ok;
			if (!_found) {
				return;
			};
		};
		_from._addDep(_to);
	}

	/**
		// useLHS is like use, but doesn't "use" top-level identifiers.
		// It should be called instead of use if the arguments are
		// expressions on the lhs of an assignment.
		// The arguments must not be nil.
	**/
	@:keep
	static public function _useLHS(_check:Ref<Checker>, _arg:haxe.Rest<stdgo.go.ast.Ast.Expr>):Void {
		var _arg = new Slice<stdgo.go.ast.Ast.Expr>(0, 0, ..._arg);
		var _x:T_operand = ({} : T_operand);
		for (_0 => _e in _arg) {
			var _v:Ref<Var> = (null : Ref<Var>);
			var _v_used:Bool = false;
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_unparen(_e)) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>), ok: true};
				} catch (_) {
					{value: (null : Ref<stdgo.go.ast.Ast.Ident>), ok: false};
				}, _ident = __tmp__.value, _1 = __tmp__.ok;
				if (_ident != null) {
					if (_ident.name == (("_" : GoString))) {
						continue;
					};
					{
						var __tmp__ = _check._pkg._scope.lookupParent(_ident.name, (0 : stdgo.go.token.Token.Pos)),
							_4:Ref<Scope> = __tmp__._0,
							_obj:Object = __tmp__._1;
						if (_obj != null) {
							{
								var __tmp__ = try {
									{value: (Go.typeAssert((Go.toInterface(_obj) : Ref<Var>)) : Ref<Var>), ok: true};
								} catch (_) {
									{value: (null : Ref<Var>), ok: false};
								}, _w = __tmp__.value, _5 = __tmp__.ok;
								if ((_w != null) && (_w._object._pkg == _check._pkg)) {
									_v = _w;
									_v_used = _v._used;
								};
							};
						};
					};
				};
			};
			_check._rawExpr((_x : Ref<T_operand>), _e, (null : Type), false);
			if (_v != null) {
				_v._used = _v_used;
			};
		};
	}

	/**
		// use type-checks each argument.
		// Useful to make sure expressions are evaluated
		// (and variables are "used") in the presence of other errors.
		// The arguments may be nil.
	**/
	@:keep
	static public function _use(_check:Ref<Checker>, _arg:haxe.Rest<stdgo.go.ast.Ast.Expr>):Void {
		var _arg = new Slice<stdgo.go.ast.Ast.Expr>(0, 0, ..._arg);
		var _x:T_operand = ({} : T_operand);
		for (_0 => _e in _arg) {
			if (_e != null) {
				_check._rawExpr((_x : Ref<T_operand>), _e, (null : Type), false);
			};
		};
	}

	@:keep
	static public function _selector(_check:Ref<Checker>, _x:Ref<T_operand>, _e:Ref<stdgo.go.ast.Ast.SelectorExpr>, _def:Ref<Named>):Void {
		stdgo.internal.Macro.controlFlow({
			var _0:Object = (null : Object),
				_1:Slice<GoInt> = (null : Slice<GoInt>),
				_2:Bool = false,
				_indirect:Bool = _2,
				_index:Slice<GoInt> = _1,
				_obj:Object = _0;
			var _sel:GoString = _e.sel.name;
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_e.x) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>), ok: true};
				} catch (_) {
					{value: (null : Ref<stdgo.go.ast.Ast.Ident>), ok: false};
				}, _ident = __tmp__.value, _ok = __tmp__.ok;
				if (_ok) {
					var _obj:Object = _check._lookup(_ident.name);
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_obj) : Ref<PkgName>)) : Ref<PkgName>), ok: true};
						} catch (_) {
							{value: (null : Ref<PkgName>), ok: false};
						}, _pname = __tmp__.value, _0 = __tmp__.ok;
						if (_pname != null) {
							_assert(_pname._object._pkg == (_check._pkg));
							_check._recordUse(_ident, Go.asInterface(_pname));
							_pname._used = true;
							var _pkg = _pname._imported;
							var _exp:Object = (null : Object);
							var _funcMode:T_operandMode = (7 : T_operandMode);
							if (_pkg._cgo) {
								if (_sel == (("malloc" : GoString))) {
									_sel = ("_CMalloc" : GoString);
								} else {
									_funcMode = (10 : T_operandMode);
								};
								for (_3 => _prefix in _cgoPrefixes) {
									{
										var __tmp__ = _check._pkg._scope.lookupParent(_prefix + _sel, _check._pkg._scope._pos);
										_exp = __tmp__._1;
									};
									if (_exp != null) {
										break;
									};
								};
								if (_exp == null) {
									_check._errorf(Go.asInterface(_e.sel), (73 : T_errorCode), ("%s not declared by package C" : GoString),
										Go.toInterface(_sel));
									@:goto "Error";
								};
								_check._objDecl(_exp, null);
							} else {
								_exp = _pkg._scope.lookup(_sel);
								if (_exp == null) {
									if (!_pkg._fake) {
										_check._errorf(Go.asInterface(_e.sel), (73 : T_errorCode), ("%s not declared by package %s" : GoString),
											Go.toInterface(_sel), Go.toInterface(_pkg._name));
									};
									@:goto "Error";
								};
								if (!_exp.exported()) {
									_check._errorf(Go.asInterface(_e.sel), (74 : T_errorCode), ("%s not exported by package %s" : GoString),
										Go.toInterface(_sel), Go.toInterface(_pkg._name));
								};
							};
							_check._recordUse(_e.sel, _exp);
							{
								final __type__ = _exp;
								if (Go.typeEquals((__type__ : Ref<Const>))) {
									var _exp:Ref<Const> = __type__ == null ? (null : Ref<Const>) : __type__.__underlying__() == null ? (null : Ref<Const>) : __type__ == null ? (null : Ref<Const>) : __type__.__underlying__()
										.value;
									_assert(_exp.val() != null);
									_x._mode = (4 : T_operandMode);
									_x._typ = _exp._object._typ;
									_x._val = _exp._val;
								} else if (Go.typeEquals((__type__ : Ref<TypeName>))) {
									var _exp:Ref<TypeName> = __type__ == null ? (null : Ref<TypeName>) : __type__.__underlying__() == null ? (null : Ref<TypeName>) : __type__ == null ? (null : Ref<TypeName>) : __type__.__underlying__()
										.value;
									_x._mode = (3 : T_operandMode);
									_x._typ = _exp._object._typ;
								} else if (Go.typeEquals((__type__ : Ref<Var>))) {
									var _exp:Ref<Var> = __type__ == null ? (null : Ref<Var>) : __type__.__underlying__() == null ? (null : Ref<Var>) : __type__ == null ? (null : Ref<Var>) : __type__.__underlying__()
										.value;
									_x._mode = (5 : T_operandMode);
									_x._typ = _exp._object._typ;
									if (_pkg._cgo && stdgo.strings.Strings.hasPrefix(_exp._object._name, ("_Cvar_" : GoString))) {
										_x._typ = (Go.typeAssert((Go.toInterface(_x._typ) : Ref<Pointer_>)) : Ref<Pointer_>)._base;
									};
								} else if (Go.typeEquals((__type__ : Ref<Func>))) {
									var _exp:Ref<Func> = __type__ == null ? (null : Ref<Func>) : __type__.__underlying__() == null ? (null : Ref<Func>) : __type__ == null ? (null : Ref<Func>) : __type__.__underlying__()
										.value;
									_x._mode = _funcMode;
									_x._typ = _exp._object._typ;
									if (_pkg._cgo && stdgo.strings.Strings.hasPrefix(_exp._object._name, ("_Cmacro_" : GoString))) {
										_x._mode = (7 : T_operandMode);
										_x._typ = (Go.typeAssert((Go.toInterface(_x._typ) : Ref<Signature>)) : Ref<Signature>)
											._results._vars[(0 : GoInt)]._object._typ;
									};
								} else if (Go.typeEquals((__type__ : Ref<Builtin>))) {
									var _exp:Ref<Builtin> = __type__ == null ? (null : Ref<Builtin>) : __type__.__underlying__() == null ? (null : Ref<Builtin>) : __type__ == null ? (null : Ref<Builtin>) : __type__.__underlying__()
										.value;
									_x._mode = (2 : T_operandMode);
									_x._typ = _exp._object._typ;
									_x._id = _exp._id;
								} else {
									var _exp:Object = __type__ == null ? (null : Object) : cast __type__;
									_check._dump(("%v: unexpected object %v" : GoString), Go.toInterface(Go.asInterface(_e.sel.pos())), Go.toInterface(_exp));
									_unreachable();
								};
							};
							_x._expr = Go.asInterface(_e);
							return;
						};
					};
				};
			};
			_check._exprOrType(_x, _e.x, false);
			if (_x._mode == ((3 : T_operandMode))) {
				if ((_def != null) && (Go.toInterface(_x._typ) == Go.toInterface(Go.asInterface(_def)))) {
					_check._cycleError((new Slice<Object>(0, 0, Go.asInterface(_def._obj)) : Slice<Object>));
					@:goto "Error";
				};
			} else if (_x._mode == ((2 : T_operandMode))) {
				_check._errorf(Go.asInterface(_e.sel), (82 : T_errorCode), ("cannot select on %s" : GoString), Go.toInterface(Go.asInterface(_x)));
				@:goto "Error";
			} else if (_x._mode == ((0 : T_operandMode))) {
				@:goto "Error";
			};
			{
				var __tmp__ = lookupFieldOrMethod(_x._typ, _x._mode == ((5 : T_operandMode)), _check._pkg, _sel);
				_obj = __tmp__._0;
				_index = __tmp__._1;
				_indirect = __tmp__._2;
			};
			if (_obj == null) {
				if (Go.toInterface(_under(_x._typ)) == (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
					@:goto "Error";
				};
				if (_index != null) {
					_check._errorf(Go.asInterface(_e.sel), (72 : T_errorCode), ("ambiguous selector %s.%s" : GoString), Go.toInterface(_x._expr),
						Go.toInterface(_sel));
					@:goto "Error";
				};
				if (_indirect) {
					_check._errorf(Go.asInterface(_e.sel), (125 : T_errorCode), ("cannot call pointer method %s on %s" : GoString), Go.toInterface(_sel),
						Go.toInterface(_x._typ));
					@:goto "Error";
				};
				var _why:GoString = ("" : GoString);
				if (_isInterfacePtr(_x._typ)) {
					_why = _check._interfacePtrError(_x._typ);
				} else {
					_why = _check._sprintf(("type %s has no field or method %s" : GoString), Go.toInterface(_x._typ), Go.toInterface(_sel));
					if ((_sel.length) > (0 : GoInt)) {
						var _changeCase:GoString = ("" : GoString);
						{
							var _r:GoInt32 = (_sel[(0 : GoInt)] : GoRune);
							if (stdgo.unicode.Unicode.isUpper(_r)) {
								_changeCase = (stdgo.unicode.Unicode.toLower(_r) : GoString) + (_sel.__slice__((1 : GoInt)) : GoString);
							} else {
								_changeCase = (stdgo.unicode.Unicode.toUpper(_r) : GoString) + (_sel.__slice__((1 : GoInt)) : GoString);
							};
						};
						{
							{
								var __tmp__ = lookupFieldOrMethod(_x._typ, _x._mode == ((5 : T_operandMode)), _check._pkg, _changeCase);
								_obj = __tmp__._0;
							};
							if (_obj != null) {
								_why = _why + ((", but does have " : GoString) + _changeCase);
							};
						};
					};
				};
				_check._errorf(Go.asInterface(_e.sel), (76 : T_errorCode), ("%s.%s undefined (%s)" : GoString), Go.toInterface(_x._expr),
					Go.toInterface(_sel), Go.toInterface(_why));
				@:goto "Error";
			};
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_obj) : Ref<Func>)) : Ref<Func>), ok: true};
				} catch (_) {
					{value: (null : Ref<Func>), ok: false};
				}, _m = __tmp__.value, _14 = __tmp__.ok;
				if (_m != null) {
					_check._objDecl(Go.asInterface(_m), null);
				};
			};
			if (_x._mode == ((3 : T_operandMode))) {
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_obj) : Ref<Func>)) : Ref<Func>), ok: true};
				} catch (_) {
					{value: (null : Ref<Func>), ok: false};
				}, _m = __tmp__.value, _15 = __tmp__.ok;
				if (_m == null) {
					_check._errorf(Go.asInterface(_e.sel), (76 : T_errorCode), ("%s.%s undefined (type %s has no method %s)" : GoString),
						Go.toInterface(_x._expr), Go.toInterface(_sel), Go.toInterface(_x._typ), Go.toInterface(_sel));
					@:goto "Error";
				};
				_check._recordSelection(_e, (2 : SelectionKind), _x._typ, Go.asInterface(_m), _index, _indirect);
				var _sig = (Go.typeAssert((Go.toInterface(_m._object._typ) : Ref<Signature>)) : Ref<Signature>);
				if (_sig._recv == null) {
					_check._error(Go.asInterface(_e), (11 : T_errorCode), ("illegal cycle in method declaration" : GoString));
					@:goto "Error";
				};
				var _params:Slice<Ref<Var>> = (null : Slice<Ref<Var>>);
				if (_sig._params != null) {
					_params = _sig._params._vars;
				};
				var _name:GoString = Go.str();
				if ((_params.length > (0 : GoInt)) && (_params[(0 : GoInt)]._object._name != Go.str())) {
					_name = _sig._recv._object._name;
					if (_name == (Go.str())) {
						_name = ("_" : GoString);
					};
				};
				_params = ((new Slice<Ref<Var>>(0, 0,
					newVar(_sig._recv._object._pos, _sig._recv._object._pkg, _name, _x._typ)) : Slice<Ref<Var>>).__append__(..._params.__toArray__()));
				_x._mode = (7 : T_operandMode);
				_x._typ = Go.asInterface((({
					_tparams: _sig._tparams,
					_params: newTuple(..._params.__toArray__()),
					_results: _sig._results,
					_variadic: _sig._variadic
				} : Signature) : Ref<Signature>));
				_check._addDeclDep(Go.asInterface(_m));
			} else {
				{
					final __type__ = _obj;
					if (Go.typeEquals((__type__ : Ref<Var>))) {
						var _obj:Ref<Var> = __type__ == null ? (null : Ref<Var>) : __type__.__underlying__() == null ? (null : Ref<Var>) : __type__ == null ? (null : Ref<Var>) : __type__.__underlying__()
							.value;
						_check._recordSelection(_e, (0 : SelectionKind), _x._typ, Go.asInterface(_obj), _index, _indirect);
						if ((_x._mode == (5 : T_operandMode)) || _indirect) {
							_x._mode = (5 : T_operandMode);
						} else {
							_x._mode = (7 : T_operandMode);
						};
						_x._typ = _obj._object._typ;
					} else if (Go.typeEquals((__type__ : Ref<Func>))) {
						var _obj:Ref<Func> = __type__ == null ? (null : Ref<Func>) : __type__.__underlying__() == null ? (null : Ref<Func>) : __type__ == null ? (null : Ref<Func>) : __type__.__underlying__()
							.value;
						_check._recordSelection(_e, (1 : SelectionKind), _x._typ, Go.asInterface(_obj), _index, _indirect);
						var _disabled:Bool = true;
						if (!_disabled && false) {
							var _typ:Type = _x._typ;
							if (_x._mode == ((5 : T_operandMode))) {
								{
									var __tmp__ = try {
										{value: (Go.typeAssert((Go.toInterface(_typ) : Ref<Pointer_>)) : Ref<Pointer_>), ok: true};
									} catch (_) {
										{value: (null : Ref<Pointer_>), ok: false};
									}, _16 = __tmp__.value, _ok = __tmp__.ok;
									if (!_ok && !isInterface(_typ)) {
										_typ = Go.asInterface((({_base: _typ} : Pointer_) : Ref<Pointer_>));
									};
								};
							};
							var _mset = newMethodSet(_typ);
							{
								var _m = _mset.lookup(_check._pkg, _sel);
								if ((_m == null) || (Go.toInterface(_m._obj) != Go.toInterface(Go.asInterface(_obj)))) {
									_check._dump(("%v: (%s).%v -> %s" : GoString), Go.toInterface(Go.asInterface(_e.pos())), Go.toInterface(_typ),
										Go.toInterface(_obj._object._name), Go.toInterface(Go.asInterface(_m)));
									_check._dump(("%s\n" : GoString), Go.toInterface(Go.asInterface(_mset)));
									throw Go.toInterface(("method sets and lookup don\'t agree" : GoString));
								};
							};
						};
						_x._mode = (7 : T_operandMode);
						var _sig:Signature = ((Go.typeAssert((Go.toInterface(_obj._object._typ) : Ref<Signature>)) : Ref<Signature>) == null ? null : (Go.typeAssert((Go.toInterface(_obj._object._typ) : Ref<Signature>)) : Ref<Signature>)
							.__copy__());
						_sig._recv = null;
						_x._typ = Go.asInterface((_sig : Ref<Signature>));
						_check._addDeclDep(Go.asInterface(_obj));
					} else {
						var _obj:Object = __type__ == null ? (null : Object) : cast __type__;
						_unreachable();
					};
				};
			};
			_x._expr = Go.asInterface(_e);
			return;
			@:label("Error") _x._mode = (0 : T_operandMode);
			_x._expr = Go.asInterface(_e);
		});
	}

	/**
		// xlist is the list of type argument expressions supplied in the source code.
	**/
	@:keep
	static public function _arguments(_check:Ref<Checker>, _call:Ref<stdgo.go.ast.Ast.CallExpr>, _sig:Ref<Signature>, _targs:Slice<Type>,
			_args:Slice<Ref<T_operand>>, _xlist:Slice<stdgo.go.ast.Ast.Expr>):Ref<Signature> {
		var _rsig:Ref<Signature> = (null : Ref<Signature>);
		_rsig = _sig;
		for (_0 => _a in _args) {
			if (_a._mode == ((3 : T_operandMode))) {
				_check._errorf(Go.asInterface(_a), (0 : T_errorCode), ("%s used as value" : GoString), Go.toInterface(Go.asInterface(_a)));
				return _rsig;
			} else if (_a._mode == ((0 : T_operandMode))) {
				return _rsig;
			};
		};
		var _nargs:GoInt = (_args.length);
		var _npars:GoInt = _sig._params.len();
		var _ddd:Bool = _call.ellipsis.isValid();
		var _sigParams = _sig._params;
		var _adjusted:Bool = false;
		if (_sig._variadic) {
			if (_ddd) {
				if ((_call.args.length == (1 : GoInt)) && (_nargs > (1 : GoInt))) {
					_check._errorf(Go.asInterface(_inNode(Go.asInterface(_call), _call.ellipsis)), (81 : T_errorCode),
						("cannot use ... with %d-valued %s" : GoString), Go.toInterface(_nargs), Go.toInterface(_call.args[(0 : GoInt)]));
					return _rsig;
				};
			} else {
				if (_nargs >= (_npars - (1 : GoInt))) {
					var _vars = new Slice<Ref<Var>>((_npars - (1 : GoInt) : GoInt).toBasic(), 0,
						...[for (i in 0...(_npars - (1 : GoInt) : GoInt).toBasic()) (null : Ref<Var>)]);
					Go.copySlice(_vars, _sig._params._vars);
					var _last = _sig._params._vars[(_npars - (1 : GoInt) : GoInt)];
					var _typ:Type = (Go.typeAssert((Go.toInterface(_last._object._typ) : Ref<Slice_>)) : Ref<Slice_>)._elem;
					while ((_vars.length) < _nargs) {
						_vars = _vars.__appendref__(newParam(_last._object._pos, _last._object._pkg, _last._object._name, _typ));
					};
					_sigParams = newTuple(..._vars.__toArray__());
					_adjusted = true;
					_npars = _nargs;
				} else {
					_npars--;
				};
			};
		} else {
			if (_ddd) {
				_check._errorf(Go.asInterface(_inNode(Go.asInterface(_call), _call.ellipsis)), (78 : T_errorCode),
					("cannot use ... in call to non-variadic %s" : GoString), Go.toInterface(_call.fun));
				return _rsig;
			};
		};
		if (_nargs != (_npars)) {
			var _at:T_positioner = Go.asInterface(_call);
			var _qualifier:GoString = ("not enough" : GoString);
			if (_nargs > _npars) {
				_at = _args[(_npars : GoInt)]._expr;
				_qualifier = ("too many" : GoString);
			} else {
				_at = Go.asInterface((_call.rparen : T_atPos));
			};
			var _params:Slice<Ref<Var>> = (null : Slice<Ref<Var>>);
			if (_sig._params != null) {
				_params = _sig._params._vars;
			};
			var _err = _newErrorf(_at, (126 : T_errorCode), ("%s arguments in call to %s" : GoString), Go.toInterface(_qualifier), Go.toInterface(_call.fun));
			_err._errorf((0 : stdgo.go.token.Token.Pos), ("have %s" : GoString), Go.toInterface(_check._typesSummary(_operandTypes(_args), false)));
			_err._errorf((0 : stdgo.go.token.Token.Pos), ("want %s" : GoString), Go.toInterface(_check._typesSummary(_varTypes(_params), _sig._variadic)));
			_check._report(_err);
			return _rsig;
		};
		if (_sig.typeParams().len() > (0 : GoInt)) {
			if (!_check._allowVersion(_check._pkg, (1 : GoInt), (18 : GoInt))) {
				{
					final __type__ = _call.fun;
					if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexExpr>))
						|| Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexListExpr>))) {
						var _ix = go.internal.typeparams.Typeparams.unpackIndexExpr(_call.fun);
						_check._softErrorf(Go.asInterface(_inNode(_call.fun, _ix.indexListExpr.lbrack)), (135 : T_errorCode),
							("function instantiation requires go1.18 or later" : GoString));
					} else {
						_check._softErrorf(Go.asInterface(_inNode(Go.asInterface(_call), _call.lparen)), (135 : T_errorCode),
							("implicit function instantiation requires go1.18 or later" : GoString));
					};
				};
			};
			var _targs = _check._infer(Go.asInterface(_call), _sig.typeParams()._list(), _targs, _sigParams, _args);
			if (_targs == null) {
				return _rsig;
			};
			_rsig = _check._instantiateSignature(_call.pos(), _sig, _targs, _xlist);
			_assert(_rsig.typeParams().len() == ((0 : GoInt)));
			_check._recordInstance(_call.fun, _targs, Go.asInterface(_rsig));
			if (_adjusted) {
				_sigParams = (Go.typeAssert((Go.toInterface(_check._subst(_call.pos(), Go.asInterface(_sigParams),
					_makeSubstMap(_sig.typeParams()._list(), _targs), null, _check._context())) : Ref<Tuple>)) : Ref<Tuple>);
			} else {
				_sigParams = _rsig._params;
			};
		};
		if ((_args.length) > (0 : GoInt)) {
			var _context:GoString = _check._sprintf(("argument to %s" : GoString), Go.toInterface(_call.fun));
			for (_i => _a in _args) {
				_check._assignment(_a, _sigParams._vars[(_i : GoInt)]._object._typ, _context);
			};
		};
		return _rsig;
	}

	@:keep
	static public function _exprList(_check:Ref<Checker>, _elist:Slice<stdgo.go.ast.Ast.Expr>,
			_allowCommaOk:Bool):{var _0:Slice<Ref<T_operand>>; var _1:Bool;} {
		var _xlist:Slice<Ref<T_operand>> = (null : Slice<Ref<T_operand>>),
			_commaOk:Bool = false;
		{
			var __switchIndex__ = -1;
			while (true) {
				if ((_elist.length) == ((0 : GoInt))) {
					break;
				} else if ((_elist.length) == ((1 : GoInt))) {
					var _e:stdgo.go.ast.Ast.Expr = _elist[(0 : GoInt)];
					var _x:T_operand = ({} : T_operand);
					_check._multiExpr((_x : Ref<T_operand>), _e);
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_x._typ) : Ref<Tuple>)) : Ref<Tuple>), ok: true};
						} catch (_) {
							{value: (null : Ref<Tuple>), ok: false};
						}, _t = __tmp__.value, _ok = __tmp__.ok;
						if (_ok && (_x._mode != (0 : T_operandMode))) {
							_xlist = new Slice<Ref<T_operand>>((_t.len() : GoInt).toBasic(), 0,
								...[for (i in 0...(_t.len() : GoInt).toBasic()) (null : Ref<T_operand>)]);
							for (_i => _v in _t._vars) {
								_xlist[(_i : GoInt)] = (({_mode: (7 : T_operandMode), _expr: _e, _typ: _v._object._typ} : T_operand) : Ref<T_operand>);
							};
							break;
						};
					};
					_xlist = (new Slice<Ref<T_operand>>(0, 0, (_x : Ref<T_operand>)) : Slice<Ref<T_operand>>);
					if (_allowCommaOk
						&& (((_x._mode == (6 : T_operandMode)) || (_x._mode == (8 : T_operandMode)))
							|| (_x._mode == (9 : T_operandMode)))) {
						var _x2 = (({_mode: (7 : T_operandMode), _expr: _e,
							_typ: Go.asInterface(typ[((19 : BasicKind) : GoInt)])} : T_operand) : Ref<T_operand>);
						if (_x._mode == ((9 : T_operandMode))) {
							_x2._typ = _universeError;
						};
						_xlist = _xlist.__appendref__(_x2);
						_commaOk = true;
					};
					break;
				} else {
					_xlist = new Slice<Ref<T_operand>>((_elist.length : GoInt).toBasic(), 0,
						...[for (i in 0...(_elist.length : GoInt).toBasic()) (null : Ref<T_operand>)]);
					for (_i => _e in _elist) {
						var _x:T_operand = ({} : T_operand);
						_check._expr((_x : Ref<T_operand>), _e);
						_xlist[(_i : GoInt)] = (_x : Ref<T_operand>);
					};
				};
				break;
			};
		};
		return {_0: _xlist, _1: _commaOk};
	}

	@:keep
	static public function _callExpr(_check:Ref<Checker>, _x:Ref<T_operand>, _call:Ref<stdgo.go.ast.Ast.CallExpr>):T_exprKind {
		var _ix = go.internal.typeparams.Typeparams.unpackIndexExpr(_call.fun);
		if (_ix != null) {
			if (_check._indexExpr(_x, _ix)) {
				_assert(_x._mode == ((7 : T_operandMode)));
			} else {
				_ix = null;
			};
			_x._expr = _call.fun;
			_check._record(_x);
		} else {
			_check._exprOrType(_x, _call.fun, true);
		};
		{
			var __switchIndex__ = -1;
			while (true) {
				if (_x._mode == ((0 : T_operandMode))) {
					_check._use(..._call.args.__toArray__());
					_x._expr = Go.asInterface(_call);
					return (2 : T_exprKind);
					break;
				} else if (_x._mode == ((3 : T_operandMode))) {
					_check._nonGeneric(_x);
					if (_x._mode == ((0 : T_operandMode))) {
						return (0 : T_exprKind);
					};
					var t:Type = _x._typ;
					_x._mode = (0 : T_operandMode);
					{
						var _n:GoInt = (_call.args.length);
						{
							var __switchIndex__ = -1;
							while (true) {
								if (_n == ((0 : GoInt))) {
									_check._errorf(Go.asInterface(_inNode(Go.asInterface(_call), _call.rparen)), (126 : T_errorCode),
										("missing argument in conversion to %s" : GoString), Go.toInterface(t));
									break;
								} else if (_n == ((1 : GoInt))) {
									_check._expr(_x, _call.args[(0 : GoInt)]);
									if (_x._mode != ((0 : T_operandMode))) {
										if (_call.ellipsis.isValid()) {
											_check._errorf(_call.args[(0 : GoInt)], (77 : T_errorCode), ("invalid use of ... in conversion to %s" : GoString),
												Go.toInterface(t));
											break;
										};
										{
											var __tmp__ = try {
												{value: (Go.typeAssert((Go.toInterface(_under(t)) : Ref<Interface>)) : Ref<Interface>), ok: true};
											} catch (_) {
												{value: (null : Ref<Interface>), ok: false};
											}, _t = __tmp__.value, _0 = __tmp__.ok;
											if ((_t != null) && !_isTypeParam(t)) {
												if (!_t.isMethodSet()) {
													_check._errorf(Go.asInterface(_call), (142 : T_errorCode),
														("cannot use interface %s in conversion (contains specific type constraints or is comparable)" : GoString),
														Go.toInterface(t));
													break;
												};
											};
										};
										_check._conversion(_x, t);
									};
									break;
								} else {
									_check._use(..._call.args.__toArray__());
									_check._errorf(_call.args[(_n - (1 : GoInt) : GoInt)], (126 : T_errorCode),
										("too many arguments in conversion to %s" : GoString), Go.toInterface(t));
								};
								break;
							};
						};
					};
					_x._expr = Go.asInterface(_call);
					return (0 : T_exprKind);
					break;
				} else if (_x._mode == ((2 : T_operandMode))) {
					var _id:T_builtinId = _x._id;
					if (!_check._builtin(_x, _call, _id)) {
						_x._mode = (0 : T_operandMode);
					};
					_x._expr = Go.asInterface(_call);
					if ((_x._mode != (0 : T_operandMode)) && (_x._mode != (4 : T_operandMode))) {
						_check._environment._hasCallOrRecv = true;
					};
					return _predeclaredFuncs[(_id : GoInt)]._kind;
					break;
				};
				break;
			};
		};
		var _cgocall:Bool = _x._mode == ((10 : T_operandMode));
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_coreType(_x._typ)) : Ref<Signature>)) : Ref<Signature>), ok: true};
		} catch (_) {
			{value: (null : Ref<Signature>), ok: false};
		}, _sig = __tmp__.value, _3 = __tmp__.ok;
		if (_sig == null) {
			_check._invalidOp(Go.asInterface(_x), (127 : T_errorCode), ("cannot call non-function %s" : GoString), Go.toInterface(Go.asInterface(_x)));
			_x._mode = (0 : T_operandMode);
			_x._expr = Go.asInterface(_call);
			return (2 : T_exprKind);
		};
		var _xlist:Slice<stdgo.go.ast.Ast.Expr> = (null : Slice<stdgo.go.ast.Ast.Expr>);
		var _targs:Slice<Type> = (null : Slice<Type>);
		if (_ix != null) {
			_xlist = _ix.indexListExpr.indices;
			_targs = _check._typeList(_xlist);
			if (_targs == null) {
				_check._use(..._call.args.__toArray__());
				_x._mode = (0 : T_operandMode);
				_x._expr = Go.asInterface(_call);
				return (2 : T_exprKind);
			};
			_assert((_targs.length) == ((_xlist.length)));
			var _0:GoInt = (_targs.length),
				_1:GoInt = _sig.typeParams().len(),
				_want:GoInt = _1,
				_got:GoInt = _0;
			if (_got > _want) {
				_check._errorf(_xlist[(_want : GoInt)], (137 : T_errorCode), ("got %d type arguments but want %d" : GoString), Go.toInterface(_got),
					Go.toInterface(_want));
				_check._use(..._call.args.__toArray__());
				_x._mode = (0 : T_operandMode);
				_x._expr = Go.asInterface(_call);
				return (2 : T_exprKind);
			};
		};
		var __tmp__ = _check._exprList(_call.args, false),
			_args:Slice<Ref<T_operand>> = __tmp__._0,
			_4:Bool = __tmp__._1;
		var _isGeneric:Bool = _sig.typeParams().len() > (0 : GoInt);
		_sig = _check._arguments(_call, _sig, _targs, _args, _xlist);
		if (_isGeneric && (_sig.typeParams().len() == (0 : GoInt))) {
			_check._recordTypeAndValue(_call.fun, (7 : T_operandMode), Go.asInterface(_sig), (null : stdgo.go.constant.Constant.Value));
		};
		if (_sig._results.len() == ((0 : GoInt))) {
			_x._mode = (1 : T_operandMode);
		} else if (_sig._results.len() == ((1 : GoInt))) {
			if (_cgocall) {
				_x._mode = (9 : T_operandMode);
			} else {
				_x._mode = (7 : T_operandMode);
			};
			_x._typ = _sig._results._vars[(0 : GoInt)]._object._typ;
		} else {
			_x._mode = (7 : T_operandMode);
			_x._typ = Go.asInterface(_sig._results);
		};
		_x._expr = Go.asInterface(_call);
		_check._environment._hasCallOrRecv = true;
		if (((_x._mode == (7 : T_operandMode)) && (_sig.typeParams().len() > (0 : GoInt)))
			&& _isParameterized(_sig.typeParams()._list(), _x._typ)) {
			_x._mode = (0 : T_operandMode);
		};
		return (2 : T_exprKind);
	}

	@:keep
	static public function _instantiateSignature(_check:Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _typ:Ref<Signature>, _targs:Slice<Type>,
			_xlist:Slice<stdgo.go.ast.Ast.Expr>):Ref<Signature> {
		var __deferstack__:Array<Void->Void> = [];
		var _res:Ref<Signature> = (null : Ref<Signature>);
		_assert(_check != null);
		try {
			_assert((_targs.length) == (_typ.typeParams().len()));
			if (false) {
				_check._trace(_pos, ("-- instantiating signature %s with %s" : GoString), Go.toInterface(Go.asInterface(_typ)), Go.toInterface(_targs));
				_check._indent++;
				__deferstack__.unshift(() -> {
					var a = function():Void {
						_check._indent--;
						_check._trace(_pos, ("=> %s (under = %s)" : GoString), Go.toInterface(Go.asInterface(_res)), Go.toInterface(_res.underlying()));
					};
					a();
				});
			};
			var _inst = (Go.typeAssert((Go.toInterface(_check._instance(_pos, Go.asInterface(_typ), _targs, null,
				_check._context())) : Ref<Signature>)) : Ref<Signature>);
			_assert((_xlist.length) <= (_targs.length));
			_check._later(function():Void {
				var _tparams = _typ.typeParams()._list();
				{
					var __tmp__ = _check._verify(_pos, _tparams, _targs, _check._context()),
						_i:GoInt = __tmp__._0,
						_err:Error = __tmp__._1;
					if (_err != null) {
						var _pos:stdgo.go.token.Token.Pos = _pos;
						if (_i < (_xlist.length)) {
							_pos = _xlist[(_i : GoInt)].pos();
						};
						_check._softErrorf(Go.asInterface((_pos : T_atPos)), (139 : T_errorCode), ("%s" : GoString), Go.toInterface(_err));
					} else {
						_check._mono._recordInstance(_check._pkg, _pos, _tparams, _targs, _xlist);
					};
				};
			})._describef(Go.asInterface((_pos : T_atPos)), ("verify instantiation" : GoString));
			{
				for (defer in __deferstack__) {
					defer();
				};
				return _inst;
			};
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return _res;
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return _res;
		};
	}

	/**
		// funcInst type-checks a function instantiation inst and returns the result in x.
		// The operand x must be the evaluation of inst.X and its type must be a signature.
	**/
	@:keep
	static public function _funcInst(_check:Ref<Checker>, _x:Ref<T_operand>, _ix:Ref<go.internal.typeparams.Typeparams.IndexExpr>):Void {
		if (!_check._allowVersion(_check._pkg, (1 : GoInt), (18 : GoInt))) {
			_check._softErrorf(Go.asInterface(_inNode(_ix.orig, _ix.indexListExpr.lbrack)), (135 : T_errorCode),
				("function instantiation requires go1.18 or later" : GoString));
		};
		var _targs = _check._typeList(_ix.indexListExpr.indices);
		if (_targs == null) {
			_x._mode = (0 : T_operandMode);
			_x._expr = _ix.orig;
			return;
		};
		_assert((_targs.length) == ((_ix.indexListExpr.indices.length)));
		var _sig = (Go.typeAssert((Go.toInterface(_x._typ) : Ref<Signature>)) : Ref<Signature>);
		var _0:GoInt = (_targs.length),
			_1:GoInt = _sig.typeParams().len(),
			_want:GoInt = _1,
			_got:GoInt = _0;
		if (_got > _want) {
			_check._errorf(_ix.indexListExpr.indices[(_got - (1 : GoInt) : GoInt)], (137 : T_errorCode), ("got %d type arguments but want %d" : GoString),
				Go.toInterface(_got), Go.toInterface(_want));
			_x._mode = (0 : T_operandMode);
			_x._expr = _ix.orig;
			return;
		};
		if (_got < _want) {
			_targs = _check._infer(_ix.orig, _sig.typeParams()._list(), _targs, null, (null : Slice<Ref<T_operand>>));
			if (_targs == null) {
				_x._mode = (0 : T_operandMode);
				_x._expr = _ix.orig;
				return;
			};
			_got = (_targs.length);
		};
		_assert(_got == (_want));
		var _res = _check._instantiateSignature(_x.pos(), _sig, _targs, _ix.indexListExpr.indices);
		_assert(_res.typeParams().len() == ((0 : GoInt)));
		_check._recordInstance(_ix.orig, _targs, Go.asInterface(_res));
		_x._typ = Go.asInterface(_res);
		_x._mode = (7 : T_operandMode);
		_x._expr = _ix.orig;
	}

	/**
		// applyTypeFunc applies f to x. If x is a type parameter,
		// the result is a type parameter constrained by an new
		// interface bound. The type bounds for that interface
		// are computed by applying f to each of the type bounds
		// of x. If any of these applications of f return nil,
		// applyTypeFunc returns nil.
		// If x is not a type parameter, the result is f(x).
	**/
	@:keep
	static public function _applyTypeFunc(_check:Ref<Checker>, _f:Type->Type, _x:Ref<T_operand>, _id:T_builtinId):Type {
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_x._typ) : Ref<TypeParam>)) : Ref<TypeParam>), ok: true};
			} catch (_) {
				{value: (null : Ref<TypeParam>), ok: false};
			}, _tp = __tmp__.value, _0 = __tmp__.ok;
			if (_tp != null) {
				var _terms:Slice<Ref<Term>> = (null : Slice<Ref<Term>>);
				if (!_tp._is(function(_t:Ref<T_term>):Bool {
					if (_t == null) {
						return false;
					};
					{
						var _r:Type = _f(_t._typ);
						if (_r != null) {
							_terms = _terms.__appendref__(newTerm(_t._tilde, _r));
							return true;
						};
					};
					return false;
				})) {
					return (null : Type);
				};
				var _code:T_errorCode = ((0 : GoInt) : T_errorCode);
				if (_id == ((13 : T_builtinId))) {
					_code = (93 : T_errorCode);
				} else if (_id == ((6 : T_builtinId))) {
					_code = (89 : T_errorCode);
				} else if (_id == ((3 : T_builtinId))) {
					_code = (87 : T_errorCode);
				} else {
					_unreachable();
				};
				_check._softErrorf(Go.asInterface(_x), _code, ("%s not supported as argument to %s for go1.18 (see issue #50937)" : GoString),
					Go.toInterface(Go.asInterface(_x)), Go.toInterface(_predeclaredFuncs[(_id : GoInt)]._name));
				var _tpar = newTypeName((0 : stdgo.go.token.Token.Pos), _check._pkg, _tp._obj._object._name, (null : Type));
				var _ptyp = _check._newTypeParam(_tpar,
					Go.asInterface(newInterfaceType((null : Slice<Ref<Func>>), (new Slice<Type>(0, 0, Go.asInterface(newUnion(_terms))) : Slice<Type>))));
				_ptyp._index = _tp._index;
				return Go.asInterface(_ptyp);
			};
		};
		return _f(_x._typ);
	}

	/**
		// builtin type-checks a call to the built-in specified by id and
		// reports whether the call is valid, with *x holding the result;
		// but x.expr is not set. If the call is invalid, the result is
		// false, and *x is undefined.
	**/
	@:keep
	static public function _builtin(_check:Ref<Checker>, _x:Ref<T_operand>, _call:Ref<stdgo.go.ast.Ast.CallExpr>, _id:T_builtinId):Bool {
		var __deferstack__:Array<Void->Void> = [];
		var _0:Bool = false;
		var _bin:T__struct_7 = {
			final x = _predeclaredFuncs[(_id : GoInt)];
			({
				_name: x._name,
				_nargs: x._nargs,
				_variadic: x._variadic,
				_kind: x._kind
			} : T__struct_7);
		};
		try {
			if (_call.ellipsis.isValid() && (_id != (0 : T_builtinId))) {
				_check._invalidOp(Go.asInterface((_call.ellipsis : T_atPos)), (81 : T_errorCode), ("invalid use of ... with built-in %s" : GoString),
					Go.toInterface(_bin._name));
				_check._use(..._call.args.__toArray__());
				return _0;
			};
			if ((_id == (7 : T_builtinId)) || (_id == (1 : T_builtinId))) {
				{
					var _a0 = _check._environment._hasCallOrRecv;
					__deferstack__.unshift(() -> {
						var a = function(_b:Bool):Void {
							_check._environment._hasCallOrRecv = _b;
						};
						a(_a0);
					});
				};
				_check._environment._hasCallOrRecv = false;
			};
			var _arg:(Ref<T_operand>, GoInt) -> Void = null;
			var _nargs:GoInt = (_call.args.length);
			if (_id == ((8 : T_builtinId)) || _id == ((9 : T_builtinId)) || _id == ((17 : T_builtinId)) || _id == ((21 : T_builtinId))) {};
			{
				var _msg:GoString = Go.str();
				if (_nargs < _bin._nargs) {
					_msg = ("not enough" : GoString);
				} else if (!_bin._variadic && (_nargs > _bin._nargs)) {
					_msg = ("too many" : GoString);
				};
				if (_msg != (Go.str())) {
					_check._invalidOp(Go.asInterface(_inNode(Go.asInterface(_call), _call.rparen)), (126 : T_errorCode),
						("%s arguments for %s (expected %d, found %d)" : GoString), Go.toInterface(_msg), Go.toInterface(Go.asInterface(_call)),
						Go.toInterface(_bin._nargs), Go.toInterface(_nargs));
					{
						for (defer in __deferstack__) {
							defer();
						};
						return _0;
					};
				};
			};
			{
				var __switchIndex__ = -1;
				while (true) {
					if (_id == ((0 : T_builtinId))) {
						var s:Type = _x._typ;
						var t:Type = (null : Type);
						{
							var __tmp__ = try {
								{value: (Go.typeAssert((Go.toInterface(_coreType(s)) : Ref<Slice_>)) : Ref<Slice_>), ok: true};
							} catch (_) {
								{value: (null : Ref<Slice_>), ok: false};
							}, _s = __tmp__.value, _5 = __tmp__.ok;
							if (_s != null) {
								t = _s._elem;
							} else {
								var _cause:GoString = ("" : GoString);
								if (_x._isNil()) {
									_cause = ("have untyped nil" : GoString);
								} else if (_isTypeParam(s)) {
									{
										var _u:Type = _coreType(s);
										if (_u != null) {
											_cause = _check._sprintf(("%s has core type %s" : GoString), Go.toInterface(Go.asInterface(_x)),
												Go.toInterface(_u));
										} else {
											_cause = _check._sprintf(("%s has no core type" : GoString), Go.toInterface(Go.asInterface(_x)));
										};
									};
								} else {
									_cause = _check._sprintf(("have %s" : GoString), Go.toInterface(Go.asInterface(_x)));
								};
								_check._errorf(Go.asInterface(_x), (83 : T_errorCode), ("first argument to append must be a slice; %s" : GoString),
									Go.toInterface(_cause));
								{
									for (defer in __deferstack__) {
										defer();
									};
									return _0;
								};
							};
						};
						var _alist = (new Slice<T_operand>(0, 0, (_x == null ? null : _x.__copy__())) : Slice<T_operand>);
						if ((_nargs == (2 : GoInt)) && _call.ellipsis.isValid()) {
							{
								var __tmp__ = _x._assignableTo(_check, Go.asInterface(newSlice(_universeByte)), (null : Pointer<GoString>)),
									_ok:Bool = __tmp__._0,
									_6:T_errorCode = __tmp__._1;
								if (_ok) {
									_arg(_x, (1 : GoInt));
									if (_x._mode == ((0 : T_operandMode))) {
										{
											for (defer in __deferstack__) {
												defer();
											};
											return _0;
										};
									};
									{
										var _t:Type = _coreString(_x._typ);
										if ((_t != null) && _isString(_t)) {
											if (_check.info.types != null) {
												var _sig = _makeSig(s, s, _x._typ);
												_sig._variadic = true;
												_check._recordBuiltinType(_call.fun, _sig);
											};
											_x._mode = (7 : T_operandMode);
											_x._typ = s;
											break;
										};
									};
									_alist = _alist.__appendref__((_x == null ? null : _x.__copy__()));
								};
							};
						};
						var _sig = _makeSig(s, s, Go.asInterface(newSlice(t)));
						_sig._variadic = true;
						var _xlist:Slice<Ref<T_operand>> = (null : Slice<Ref<T_operand>>);
						for (_i in 0..._alist.length.toBasic()) {
							_xlist = _xlist.__appendref__((_alist[(_i : GoInt)] : Ref<T_operand>));
						};
						{
							var _i:GoInt = (_alist.length);
							Go.cfor(_i < _nargs, _i++, {
								var _x:T_operand = ({} : T_operand);
								_arg((_x : Ref<T_operand>), _i);
								_xlist = _xlist.__appendref__((_x : Ref<T_operand>));
							});
						};
						_check._arguments(_call, _sig, (null : Slice<Type>), _xlist, (null : Slice<stdgo.go.ast.Ast.Expr>));
						_x._mode = (7 : T_operandMode);
						_x._typ = s;
						if (_check.info.types != null) {
							_check._recordBuiltinType(_call.fun, _sig);
						};
						break;
					} else if (_id == ((1 : T_builtinId)) || _id == ((7 : T_builtinId))) {
						var _mode:T_operandMode = (0 : T_operandMode);
						var _val:stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
						{
							final __type__ = _arrayPtrDeref(_under(_x._typ));
							{
								var __bool__ = true;
								while (__bool__) {
									__bool__ = false;
									if (Go.typeEquals((__type__ : Ref<Basic>))) {
										var _t:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
											.value;
										if (_isString(Go.asInterface(_t)) && (_id == (7 : T_builtinId))) {
											if (_x._mode == ((4 : T_operandMode))) {
												_mode = (4 : T_operandMode);
												_val = stdgo.go.constant.Constant.makeInt64((stdgo.go.constant.Constant.stringVal(_x._val).length : GoInt64));
											} else {
												_mode = (7 : T_operandMode);
											};
										};
									} else if (Go.typeEquals((__type__ : Ref<Array_>))) {
										var _t:Ref<Array_> = __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__() == null ? (null : Ref<Array_>) : __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__()
											.value;
										_mode = (7 : T_operandMode);
										if (!_check._environment._hasCallOrRecv) {
											_mode = (4 : T_operandMode);
											if (_t._len >= ("0" : GoInt64)) {
												_val = stdgo.go.constant.Constant.makeInt64(_t._len);
											} else {
												_val = stdgo.go.constant.Constant.makeUnknown();
											};
										};
									} else if (Go.typeEquals((__type__ : Ref<Slice_>)) || Go.typeEquals((__type__ : Ref<Chan>))) {
										var _t:Type = __type__ == null ? (null : Type) : cast __type__;
										_mode = (7 : T_operandMode);
									} else if (Go.typeEquals((__type__ : Ref<Map_>))) {
										var _t:Ref<Map_> = __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__() == null ? (null : Ref<Map_>) : __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__()
											.value;
										if (_id == ((7 : T_builtinId))) {
											_mode = (7 : T_operandMode);
										};
									} else if (Go.typeEquals((__type__ : Ref<Interface>))) {
										var _t:Ref<Interface> = __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__() == null ? (null : Ref<Interface>) : __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__()
											.value;
										if (!_isTypeParam(_x._typ)) {
											break;
										};
										if (_t._typeSet()._underIs(function(_t:Type):Bool {
											{
												final __type__ = _arrayPtrDeref(_t);
												if (Go.typeEquals((__type__ : Ref<Basic>))) {
													var _t:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
														.value;
													if (_isString(Go.asInterface(_t)) && (_id == (7 : T_builtinId))) {
														return true;
													};
												} else if (Go.typeEquals((__type__ : Ref<Array_>))
													|| Go.typeEquals((__type__ : Ref<Slice_>))
													|| Go.typeEquals((__type__ : Ref<Chan>))) {
													var _t:Type = __type__ == null ? (null : Type) : cast __type__;
													return true;
												} else if (Go.typeEquals((__type__ : Ref<Map_>))) {
													var _t:Ref<Map_> = __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__() == null ? (null : Ref<Map_>) : __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__()
														.value;
													if (_id == ((7 : T_builtinId))) {
														return true;
													};
												};
											};
											return false;
										})) {
											_mode = (7 : T_operandMode);
										};
									};
									break;
								};
							};
						};
						if ((_mode == (0 : T_operandMode))
							&& (Go.toInterface(_under(_x._typ)) != Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
							var _code:T_errorCode = (84 : T_errorCode);
							if (_id == ((7 : T_builtinId))) {
								_code = (90 : T_errorCode);
							};
							_check._invalidArg(Go.asInterface(_x), _code, ("%s for %s" : GoString), Go.toInterface(Go.asInterface(_x)),
								Go.toInterface(_bin._name));
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						if ((_check.info.types != null) && (_mode != (4 : T_operandMode))) {
							_check._recordBuiltinType(_call.fun, _makeSig(Go.asInterface(typ[((2 : BasicKind) : GoInt)]), _x._typ));
						};
						_x._mode = _mode;
						_x._typ = Go.asInterface(typ[((2 : BasicKind) : GoInt)]);
						_x._val = _val;
						break;
					} else if (_id == ((2 : T_builtinId))) {
						if (!_underIs(_x._typ, function(_u:Type):Bool {
							var __tmp__ = try {
								{value: (Go.typeAssert((Go.toInterface(_u) : Ref<Chan>)) : Ref<Chan>), ok: true};
							} catch (_) {
								{value: (null : Ref<Chan>), ok: false};
							}, _uch = __tmp__.value, _0 = __tmp__.ok;
							if (_uch == null) {
								_check._invalidOp(Go.asInterface(_x), (85 : T_errorCode), ("cannot close non-channel %s" : GoString),
									Go.toInterface(Go.asInterface(_x)));
								return false;
							};
							if (_uch._dir == ((2 : ChanDir))) {
								_check._invalidOp(Go.asInterface(_x), (85 : T_errorCode), ("cannot close receive-only channel %s" : GoString),
									Go.toInterface(Go.asInterface(_x)));
								return false;
							};
							return true;
						})) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						_x._mode = (1 : T_operandMode);
						if (_check.info.types != null) {
							_check._recordBuiltinType(_call.fun, _makeSig((null : Type), _x._typ));
						};
						break;
					} else if (_id == ((3 : T_builtinId))) {
						var _y:T_operand = ({} : T_operand);
						_arg((_y : Ref<T_operand>), (1 : GoInt));
						if (_y._mode == ((0 : T_operandMode))) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						var _d:GoInt = (0 : GoInt);
						if (_isUntyped(_x._typ)) {
							_d = _d | ((1 : GoInt));
						};
						if (_isUntyped(_y._typ)) {
							_d = _d | ((2 : GoInt));
						};
						if (_d == ((0 : GoInt))) {} else if (_d == ((1 : GoInt))) {
							_check._convertUntyped(_x, _y._typ);
						} else if (_d == ((2 : GoInt))) {
							_check._convertUntyped((_y : Ref<T_operand>), _x._typ);
						} else if (_d == ((3 : GoInt))) {
							if ((_x._mode == (4 : T_operandMode)) && (_y._mode == (4 : T_operandMode))) {
								var _toFloat = function(_x:Ref<T_operand>):Void {
									if (_isNumeric(_x._typ)
										&& (stdgo.go.constant.Constant.sign(stdgo.go.constant.Constant.imag(_x._val)) == (0 : GoInt))) {
										_x._typ = Go.asInterface(typ[((22 : BasicKind) : GoInt)]);
									};
								};
								_toFloat(_x);
								_toFloat((_y : Ref<T_operand>));
							} else {
								_check._convertUntyped(_x, Go.asInterface(typ[((14 : BasicKind) : GoInt)]));
								_check._convertUntyped((_y : Ref<T_operand>), Go.asInterface(typ[((14 : BasicKind) : GoInt)]));
							};
						};
						if ((_x._mode == (0 : T_operandMode)) || (_y._mode == (0 : T_operandMode))) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						if (!identical(_x._typ, _y._typ)) {
							_check._invalidArg(Go.asInterface(_x), (87 : T_errorCode), ("mismatched types %s and %s" : GoString), Go.toInterface(_x._typ),
								Go.toInterface(_y._typ));
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						var _f:Type->Type = function(_typ:Type):Type {
							_assert(!_isTypeParam(_typ));
							{
								var __tmp__ = try {
									{value: (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Basic>)) : Ref<Basic>), ok: true};
								} catch (_) {
									{value: (null : Ref<Basic>), ok: false};
								}, _t = __tmp__.value, _0 = __tmp__.ok;
								if (_t != null) {
									if (_t._kind == ((13 : BasicKind))) {
										return Go.asInterface(typ[((15 : BasicKind) : GoInt)]);
									} else if (_t._kind == ((14 : BasicKind))) {
										return Go.asInterface(typ[((16 : BasicKind) : GoInt)]);
									} else if (_t._kind == ((22 : BasicKind))) {
										return Go.asInterface(typ[((23 : BasicKind) : GoInt)]);
									};
								};
							};
							return (null : Type);
						};
						var _resTyp:Type = _check._applyTypeFunc(_f, _x, _id);
						if (_resTyp == null) {
							_check._invalidArg(Go.asInterface(_x), (87 : T_errorCode), ("arguments have type %s, expected floating-point" : GoString),
								Go.toInterface(_x._typ));
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						if ((_x._mode == (4 : T_operandMode)) && (_y._mode == (4 : T_operandMode))) {
							_x._val = stdgo.go.constant.Constant.binaryOp(stdgo.go.constant.Constant.toFloat(_x._val), (12 : stdgo.go.token.Token.Token),
								stdgo.go.constant.Constant.makeImag(stdgo.go.constant.Constant.toFloat(_y._val)));
						} else {
							_x._mode = (7 : T_operandMode);
						};
						if ((_check.info.types != null) && (_x._mode != (4 : T_operandMode))) {
							_check._recordBuiltinType(_call.fun, _makeSig(_resTyp, _x._typ, _x._typ));
						};
						_x._typ = _resTyp;
						break;
					} else if (_id == ((4 : T_builtinId))) {
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_coreType(_x._typ)) : Ref<Slice_>)) : Ref<Slice_>), ok: true};
						} catch (_) {
							{value: (null : Ref<Slice_>), ok: false};
						}, _dst = __tmp__.value, _19 = __tmp__.ok;
						var _y:T_operand = ({} : T_operand);
						_arg((_y : Ref<T_operand>), (1 : GoInt));
						if (_y._mode == ((0 : T_operandMode))) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						var _src0:Type = _coreString(_y._typ);
						if ((_src0 != null) && _isString(_src0)) {
							_src0 = Go.asInterface(newSlice(_universeByte));
						};
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_src0) : Ref<Slice_>)) : Ref<Slice_>), ok: true};
						} catch (_) {
							{value: (null : Ref<Slice_>), ok: false};
						}, _src = __tmp__.value, _20 = __tmp__.ok;
						if ((_dst == null) || (_src == null)) {
							_check._invalidArg(Go.asInterface(_x), (86 : T_errorCode), ("copy expects slice arguments; found %s and %s" : GoString),
								Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface((_y : Ref<T_operand>))));
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						if (!identical(_dst._elem, _src._elem)) {
							_check._errorf(Go.asInterface(_x), (86 : T_errorCode),
								("arguments to copy %s and %s have different element types %s and %s" : GoString), Go.toInterface(Go.asInterface(_x)),
								Go.toInterface(Go.asInterface((_y : Ref<T_operand>))), Go.toInterface(_dst._elem), Go.toInterface(_src._elem));
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						if (_check.info.types != null) {
							_check._recordBuiltinType(_call.fun, _makeSig(Go.asInterface(typ[((2 : BasicKind) : GoInt)]), _x._typ, _y._typ));
						};
						_x._mode = (7 : T_operandMode);
						_x._typ = Go.asInterface(typ[((2 : BasicKind) : GoInt)]);
						break;
					} else if (_id == ((5 : T_builtinId))) {
						var _map_:Type = _x._typ;
						var _key:Type = (null : Type);
						if (!_underIs(_map_, function(_u:Type):Bool {
							var __tmp__ = try {
								{value: (Go.typeAssert((Go.toInterface(_u) : Ref<Map_>)) : Ref<Map_>), ok: true};
							} catch (_) {
								{value: (null : Ref<Map_>), ok: false};
							}, _map_ = __tmp__.value, _0 = __tmp__.ok;
							if (_map_ == null) {
								_check._invalidArg(Go.asInterface(_x), (88 : T_errorCode), ("%s is not a map" : GoString), Go.toInterface(Go.asInterface(_x)));
								return false;
							};
							if ((_key != null) && !identical(_map_._key, _key)) {
								_check._invalidArg(Go.asInterface(_x), (88 : T_errorCode), ("maps of %s must have identical key types" : GoString),
									Go.toInterface(Go.asInterface(_x)));
								return false;
							};
							_key = _map_._key;
							return true;
						})) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						_arg(_x, (1 : GoInt));
						if (_x._mode == ((0 : T_operandMode))) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						_check._assignment(_x, _key, ("argument to delete" : GoString));
						if (_x._mode == ((0 : T_operandMode))) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						_x._mode = (1 : T_operandMode);
						if (_check.info.types != null) {
							_check._recordBuiltinType(_call.fun, _makeSig((null : Type), _map_, _key));
						};
						break;
					} else if (_id == ((6 : T_builtinId)) || _id == ((13 : T_builtinId))) {
						if (_isUntyped(_x._typ)) {
							if (_x._mode == ((4 : T_operandMode))) {
								if (_isNumeric(_x._typ)) {
									_x._typ = Go.asInterface(typ[((23 : BasicKind) : GoInt)]);
								};
							} else {
								_check._convertUntyped(_x, Go.asInterface(typ[((16 : BasicKind) : GoInt)]));
								if (_x._mode == ((0 : T_operandMode))) {
									{
										for (defer in __deferstack__) {
											defer();
										};
										return _0;
									};
								};
							};
						};
						var _f:Type->Type = function(_typ:Type):Type {
							_assert(!_isTypeParam(_typ));
							{
								var __tmp__ = try {
									{value: (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Basic>)) : Ref<Basic>), ok: true};
								} catch (_) {
									{value: (null : Ref<Basic>), ok: false};
								}, _t = __tmp__.value, _0 = __tmp__.ok;
								if (_t != null) {
									if (_t._kind == ((15 : BasicKind))) {
										return Go.asInterface(typ[((13 : BasicKind) : GoInt)]);
									} else if (_t._kind == ((16 : BasicKind))) {
										return Go.asInterface(typ[((14 : BasicKind) : GoInt)]);
									} else if (_t._kind == ((23 : BasicKind))) {
										return Go.asInterface(typ[((22 : BasicKind) : GoInt)]);
									};
								};
							};
							return (null : Type);
						};
						var _resTyp:Type = _check._applyTypeFunc(_f, _x, _id);
						if (_resTyp == null) {
							var _code:T_errorCode = (89 : T_errorCode);
							if (_id == ((13 : T_builtinId))) {
								_code = (93 : T_errorCode);
							};
							_check._invalidArg(Go.asInterface(_x), _code, ("argument has type %s, expected complex type" : GoString), Go.toInterface(_x._typ));
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						if (_x._mode == ((4 : T_operandMode))) {
							if (_id == ((13 : T_builtinId))) {
								_x._val = stdgo.go.constant.Constant.real(_x._val);
							} else {
								_x._val = stdgo.go.constant.Constant.imag(_x._val);
							};
						} else {
							_x._mode = (7 : T_operandMode);
						};
						if ((_check.info.types != null) && (_x._mode != (4 : T_operandMode))) {
							_check._recordBuiltinType(_call.fun, _makeSig(_resTyp, _x._typ));
						};
						_x._typ = _resTyp;
						break;
					} else if (_id == ((8 : T_builtinId))) {
						var _arg0:stdgo.go.ast.Ast.Expr = _call.args[(0 : GoInt)];
						var t:Type = _check._varType(_arg0);
						if (Go.toInterface(t) == (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						var _min:GoInt = (0 : GoInt);
						{
							final __type__ = _coreType(t);
							if (Go.typeEquals((__type__ : Ref<Slice_>))) {
								_min = (2 : GoInt);
							} else if (Go.typeEquals((__type__ : Ref<Map_>)) || Go.typeEquals((__type__ : Ref<Chan>))) {
								_min = (1 : GoInt);
							} else if (__type__ == null) {
								_check._errorf(_arg0, (92 : T_errorCode), ("cannot make %s: no core type" : GoString), Go.toInterface(_arg0));
								{
									for (defer in __deferstack__) {
										defer();
									};
									return _0;
								};
							} else {
								_check._invalidArg(_arg0, (92 : T_errorCode), ("cannot make %s; type must be slice, map, or channel" : GoString),
									Go.toInterface(_arg0));
								{
									for (defer in __deferstack__) {
										defer();
									};
									return _0;
								};
							};
						};
						if ((_nargs < _min) || ((_min + (1 : GoInt)) < _nargs)) {
							_check._invalidOp(Go.asInterface(_call), (126 : T_errorCode), ("%v expects %d or %d arguments; found %d" : GoString),
								Go.toInterface(Go.asInterface(_call)), Go.toInterface(_min), Go.toInterface(_min + (1 : GoInt)), Go.toInterface(_nargs));
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						var _types = (new Slice<Type>(0, 0, t) : Slice<Type>);
						var _sizes:Slice<GoInt64> = (null : Slice<GoInt64>);
						for (_27 => _arg in (_call.args.__slice__((1 : GoInt)) : Slice<stdgo.go.ast.Ast.Expr>)) {
							var __tmp__ = _check._index(_arg, ("-1" : GoInt64)),
								_typ:Type = __tmp__._0,
								_size:GoInt64 = __tmp__._1;
							_types = _types.__appendref__(_typ);
							if (_size >= ("0" : GoInt64)) {
								_sizes = _sizes.__appendref__(_size);
							};
						};
						if ((_sizes.length == (2 : GoInt)) && (_sizes[(0 : GoInt)] > _sizes[(1 : GoInt)])) {
							_check._invalidArg(_call.args[(1 : GoInt)], (91 : T_errorCode), ("length and capacity swapped" : GoString));
						};
						_x._mode = (7 : T_operandMode);
						_x._typ = t;
						if (_check.info.types != null) {
							_check._recordBuiltinType(_call.fun, _makeSig(_x._typ, ..._types.__toArray__()));
						};
						break;
					} else if (_id == ((9 : T_builtinId))) {
						var t:Type = _check._varType(_call.args[(0 : GoInt)]);
						if (Go.toInterface(t) == (Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						_x._mode = (7 : T_operandMode);
						_x._typ = Go.asInterface((({_base: t} : Pointer_) : Ref<Pointer_>));
						if (_check.info.types != null) {
							_check._recordBuiltinType(_call.fun, _makeSig(_x._typ, t));
						};
						break;
					} else if (_id == ((10 : T_builtinId))) {
						if ((_check._environment._sig != null) && (_check._environment._sig._results.len() > (0 : GoInt))) {
							var _p = _check._environment._isPanic;
							if (_p == null) {
								_p = (new GoObjectMap<Ref<stdgo.go.ast.Ast.CallExpr>,
									Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({
									get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () ->
											stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.ast.Ast.CallExpr", [], null, false, {get: () -> null})})
								},
									{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind)}))) : GoMap<Ref<stdgo.go.ast.Ast.CallExpr>, Bool>);
								_check._environment._isPanic = _p;
							};
							_p[_call] = true;
						};
						_check._assignment(_x, Go.asInterface((_emptyInterface : Ref<Interface>)), ("argument to panic" : GoString));
						if (_x._mode == ((0 : T_operandMode))) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						_x._mode = (1 : T_operandMode);
						if (_check.info.types != null) {
							_check._recordBuiltinType(_call.fun, _makeSig((null : Type), Go.asInterface((_emptyInterface : Ref<Interface>))));
						};
						break;
					} else if (_id == ((11 : T_builtinId)) || _id == ((12 : T_builtinId))) {
						var _params:Slice<Type> = (null : Slice<Type>);
						if (_nargs > (0 : GoInt)) {
							_params = new Slice<Type>((_nargs : GoInt).toBasic(), 0, ...[for (i in 0...(_nargs : GoInt).toBasic()) (null : Type)]);
							{
								var _i:GoInt = (0 : GoInt);
								Go.cfor(_i < _nargs, _i++, {
									if (_i > (0 : GoInt)) {
										_arg(_x, _i);
									};
									_check._assignment(_x, (null : Type), ("argument to " : GoString) + _predeclaredFuncs[(_id : GoInt)]._name);
									if (_x._mode == ((0 : T_operandMode))) {
										{
											for (defer in __deferstack__) {
												defer();
											};
											return _0;
										};
									};
									_params[(_i : GoInt)] = _x._typ;
								});
							};
						};
						_x._mode = (1 : T_operandMode);
						if (_check.info.types != null) {
							_check._recordBuiltinType(_call.fun, _makeSig((null : Type), ..._params.__toArray__()));
						};
						break;
					} else if (_id == ((14 : T_builtinId))) {
						_x._mode = (7 : T_operandMode);
						_x._typ = Go.asInterface((_emptyInterface : Ref<Interface>));
						if (_check.info.types != null) {
							_check._recordBuiltinType(_call.fun, _makeSig(_x._typ));
						};
						break;
					} else if (_id == ((15 : T_builtinId))) {
						if (!_check._allowVersion(_check._pkg, (1 : GoInt), (17 : GoInt))) {
							_check._errorf(_call.fun, (133 : T_errorCode), ("unsafe.Add requires go1.17 or later" : GoString));
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						_check._assignment(_x, Go.asInterface(typ[((18 : BasicKind) : GoInt)]), ("argument to unsafe.Add" : GoString));
						if (_x._mode == ((0 : T_operandMode))) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						var _y:T_operand = ({} : T_operand);
						_arg((_y : Ref<T_operand>), (1 : GoInt));
						if (!_check._isValidIndex((_y : Ref<T_operand>), (133 : T_errorCode), ("length" : GoString), true)) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						_x._mode = (7 : T_operandMode);
						_x._typ = Go.asInterface(typ[((18 : BasicKind) : GoInt)]);
						if (_check.info.types != null) {
							_check._recordBuiltinType(_call.fun, _makeSig(_x._typ, _x._typ, _y._typ));
						};
						break;
					} else if (_id == ((16 : T_builtinId))) {
						_check._assignment(_x, (null : Type), ("argument to unsafe.Alignof" : GoString));
						if (_x._mode == ((0 : T_operandMode))) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						if (_hasVarSize(_x._typ, (null : GoMap<Ref<Named>, Bool>))) {
							_x._mode = (7 : T_operandMode);
							if (_check.info.types != null) {
								_check._recordBuiltinType(_call.fun, _makeSig(Go.asInterface(typ[((12 : BasicKind) : GoInt)]), _x._typ));
							};
						} else {
							_x._mode = (4 : T_operandMode);
							_x._val = stdgo.go.constant.Constant.makeInt64(_check._conf._alignof(_x._typ));
						};
						_x._typ = Go.asInterface(typ[((12 : BasicKind) : GoInt)]);
						break;
					} else if (_id == ((17 : T_builtinId))) {
						var _arg0:stdgo.go.ast.Ast.Expr = _call.args[(0 : GoInt)];
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_unparen(_arg0)) : Ref<stdgo.go.ast.Ast.SelectorExpr>)) : Ref<stdgo.go.ast.Ast.SelectorExpr>),
								ok: true};
						} catch (_) {
							{value: (null : Ref<stdgo.go.ast.Ast.SelectorExpr>), ok: false};
						}, _selx = __tmp__.value, _54 = __tmp__.ok;
						if (_selx == null) {
							_check._invalidArg(_arg0, (98 : T_errorCode), ("%s is not a selector expression" : GoString), Go.toInterface(_arg0));
							_check._use(_arg0);
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						_check._expr(_x, _selx.x);
						if (_x._mode == ((0 : T_operandMode))) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						var _base:Type = _derefStructPtr(_x._typ);
						var _sel:GoString = _selx.sel.name;
						var __tmp__ = lookupFieldOrMethod(_base, false, _check._pkg, _sel),
							_obj:Object = __tmp__._0,
							_index:Slice<GoInt> = __tmp__._1,
							_indirect:Bool = __tmp__._2;
						{
							final __type__ = _obj;
							if (__type__ == null) {
								_check._invalidArg(Go.asInterface(_x), (76 : T_errorCode), ("%s has no single field %s" : GoString), Go.toInterface(_base),
									Go.toInterface(_sel));
								{
									for (defer in __deferstack__) {
										defer();
									};
									return _0;
								};
							} else if (Go.typeEquals((__type__ : Ref<Func>))) {
								_check._invalidArg(_arg0, (99 : T_errorCode), ("%s is a method value" : GoString), Go.toInterface(_arg0));
								{
									for (defer in __deferstack__) {
										defer();
									};
									return _0;
								};
							};
						};
						if (_indirect) {
							_check._invalidArg(Go.asInterface(_x), (99 : T_errorCode), ("field %s is embedded via a pointer in %s" : GoString),
								Go.toInterface(_sel), Go.toInterface(_base));
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						_check._recordSelection(_selx, (0 : SelectionKind), _base, _obj, _index, false);
						{
							var _mode:T_operandMode = (7 : T_operandMode);
							if ((_x._mode == (5 : T_operandMode)) || _indirect) {
								_mode = (5 : T_operandMode);
							};
							_check._record(((new T_operand(_mode, Go.asInterface(_selx), _obj.type(), (null : stdgo.go.constant.Constant.Value),
								(0 : T_builtinId)) : T_operand) : Ref<T_operand>));
						};
						if (_hasVarSize(_base, (null : GoMap<Ref<Named>, Bool>))) {
							_x._mode = (7 : T_operandMode);
							if (_check.info.types != null) {
								_check._recordBuiltinType(_call.fun, _makeSig(Go.asInterface(typ[((12 : BasicKind) : GoInt)]), _obj.type()));
							};
						} else {
							_x._mode = (4 : T_operandMode);
							_x._val = stdgo.go.constant.Constant.makeInt64(_check._conf._offsetof(_base, _index));
						};
						_x._typ = Go.asInterface(typ[((12 : BasicKind) : GoInt)]);
						break;
					} else if (_id == ((18 : T_builtinId))) {
						_check._assignment(_x, (null : Type), ("argument to unsafe.Sizeof" : GoString));
						if (_x._mode == ((0 : T_operandMode))) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						if (_hasVarSize(_x._typ, (null : GoMap<Ref<Named>, Bool>))) {
							_x._mode = (7 : T_operandMode);
							if (_check.info.types != null) {
								_check._recordBuiltinType(_call.fun, _makeSig(Go.asInterface(typ[((12 : BasicKind) : GoInt)]), _x._typ));
							};
						} else {
							_x._mode = (4 : T_operandMode);
							_x._val = stdgo.go.constant.Constant.makeInt64(_check._conf._sizeof(_x._typ));
						};
						_x._typ = Go.asInterface(typ[((12 : BasicKind) : GoInt)]);
						break;
					} else if (_id == ((19 : T_builtinId))) {
						if (!_check._allowVersion(_check._pkg, (1 : GoInt), (17 : GoInt))) {
							_check._errorf(_call.fun, (134 : T_errorCode), ("unsafe.Slice requires go1.17 or later" : GoString));
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_under(_x._typ)) : Ref<Pointer_>)) : Ref<Pointer_>), ok: true};
						} catch (_) {
							{value: (null : Ref<Pointer_>), ok: false};
						}, _typ = __tmp__.value, _67 = __tmp__.ok;
						if (_typ == null) {
							_check._invalidArg(Go.asInterface(_x), (134 : T_errorCode), ("%s is not a pointer" : GoString),
								Go.toInterface(Go.asInterface(_x)));
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						var _y:T_operand = ({} : T_operand);
						_arg((_y : Ref<T_operand>), (1 : GoInt));
						if (!_check._isValidIndex((_y : Ref<T_operand>), (134 : T_errorCode), ("length" : GoString), false)) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						_x._mode = (7 : T_operandMode);
						_x._typ = Go.asInterface(newSlice(_typ._base));
						if (_check.info.types != null) {
							_check._recordBuiltinType(_call.fun, _makeSig(_x._typ, Go.asInterface(_typ), _y._typ));
						};
						break;
					} else if (_id == ((20 : T_builtinId))) {
						if ((_x._mode != (4 : T_operandMode)) || !_isBoolean(_x._typ)) {
							_check._invalidArg(Go.asInterface(_x), (1 : T_errorCode), ("%s is not a boolean constant" : GoString),
								Go.toInterface(Go.asInterface(_x)));
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						if (_x._val.kind() != ((1 : stdgo.go.constant.Constant.Kind))) {
							_check._errorf(Go.asInterface(_x), (1 : T_errorCode), ("internal error: value of %s should be a boolean constant" : GoString),
								Go.toInterface(Go.asInterface(_x)));
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _0;
							};
						};
						if (!stdgo.go.constant.Constant.boolVal(_x._val)) {
							_check._errorf(Go.asInterface(_call), (1 : T_errorCode), ("%v failed" : GoString), Go.toInterface(Go.asInterface(_call)));
						};
						break;
					} else if (_id == ((21 : T_builtinId))) {
						if (_nargs == ((0 : GoInt))) {
							_check._dump(("%v: trace() without arguments" : GoString), Go.toInterface(Go.asInterface(_call.pos())));
							_x._mode = (1 : T_operandMode);
							break;
						};
						var _t:T_operand = ({} : T_operand);
						var _x1 = _x;
						for (_70 => _arg in _call.args) {
							_check._rawExpr(_x1, _arg, (null : Type), false);
							_check._dump(("%v: %s" : GoString), Go.toInterface(Go.asInterface(_x1.pos())), Go.toInterface(Go.asInterface(_x1)));
							_x1 = (_t : Ref<T_operand>);
						};
						break;
					} else {
						_unreachable();
					};
					break;
				};
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				return true;
			};
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return _0;
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return _0;
		};
	}

	@:keep
	static public function _shortVarDecl(_check:Ref<Checker>, _pos:T_positioner, _lhs:Slice<stdgo.go.ast.Ast.Expr>, _rhs:Slice<stdgo.go.ast.Ast.Expr>):Void {
		var _top:GoInt = (_check._delayed.length);
		var _scope = _check._pkg._scope;
		var _seen = (new GoObjectMap<GoString, Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
			stdgo.internal.reflect.Reflect.GoType.basic(string_kind)},
			{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind)}))) : GoMap<GoString, Bool>);
		var _lhsVars = new Slice<Ref<Var>>((_lhs.length : GoInt).toBasic(), 0, ...[for (i in 0...(_lhs.length : GoInt).toBasic()) (null : Ref<Var>)]);
		var _newVars = new Slice<Ref<Var>>((0 : GoInt).toBasic(), (_lhs.length), ...[for (i in 0...(0 : GoInt).toBasic()) (null : Ref<Var>)]);
		var _hasErr:Bool = false;
		for (_i => _lhs in _lhs) {
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_lhs) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>), ok: true};
			} catch (_) {
				{value: (null : Ref<stdgo.go.ast.Ast.Ident>), ok: false};
			}, _ident = __tmp__.value, _4 = __tmp__.ok;
			if (_ident == null) {
				_check._useLHS(_lhs);
				_check._errorf(_lhs, (131 : T_errorCode), ("non-name %s on left side of :=" : GoString), Go.toInterface(_lhs));
				_hasErr = true;
				continue;
			};
			var _name:GoString = _ident.name;
			if (_name != (("_" : GoString))) {
				if (_seen[_name]) {
					_check._errorf(_lhs, (132 : T_errorCode), ("%s repeated on left side of :=" : GoString), Go.toInterface(_lhs));
					_hasErr = true;
					continue;
				};
				_seen[_name] = true;
			};
			{
				var _alt:Object = _scope.lookup(_name);
				if (_alt != null) {
					_check._recordUse(_ident, _alt);
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_alt) : Ref<Var>)) : Ref<Var>), ok: true};
						} catch (_) {
							{value: (null : Ref<Var>), ok: false};
						}, _obj = __tmp__.value, _5 = __tmp__.ok;
						if (_obj != null) {
							_lhsVars[(_i : GoInt)] = _obj;
						} else {
							_check._errorf(_lhs, (18 : T_errorCode), ("cannot assign to %s" : GoString), Go.toInterface(_lhs));
							_hasErr = true;
						};
					};
					continue;
				};
			};
			var _obj = newVar(_ident.pos(), _check._pkg, _name, (null : Type));
			_lhsVars[(_i : GoInt)] = _obj;
			if (_name != (("_" : GoString))) {
				_newVars = _newVars.__appendref__(_obj);
			};
			_check._recordDef(_ident, Go.asInterface(_obj));
		};
		for (_i => _obj in _lhsVars) {
			if (_obj == null) {
				_lhsVars[(_i : GoInt)] = newVar(_lhs[(_i : GoInt)].pos(), _check._pkg, ("_" : GoString), (null : Type));
			};
		};
		_check._initVars(_lhsVars, _rhs, (null : stdgo.go.ast.Ast.Stmt));
		_check._processDelayed(_top);
		if ((_newVars.length == (0 : GoInt)) && !_hasErr) {
			_check._softErrorf(_pos, (19 : T_errorCode), ("no new variables on left side of :=" : GoString));
			return;
		};
		var _scopePos:stdgo.go.token.Token.Pos = _rhs[((_rhs.length) - (1 : GoInt) : GoInt)].end();
		for (_10 => _obj in _newVars) {
			_check._declare(_scope, null, Go.asInterface(_obj), _scopePos);
		};
	}

	@:keep
	static public function _assignVars(_check:Ref<Checker>, _lhs:Slice<stdgo.go.ast.Ast.Expr>, _origRHS:Slice<stdgo.go.ast.Ast.Expr>):Void {
		var __tmp__ = _check._exprList(_origRHS, (_lhs.length) == ((2 : GoInt))),
			_rhs:Slice<Ref<T_operand>> = __tmp__._0,
			_commaOk:Bool = __tmp__._1;
		if ((_lhs.length) != ((_rhs.length))) {
			_check._useLHS(..._lhs.__toArray__());
			for (_0 => _x in _rhs) {
				if (_x._mode == ((0 : T_operandMode))) {
					return;
				};
			};
			if (false) {
				_check._assignError(_origRHS, (_lhs.length), (_rhs.length));
			} else {
				_check._errorf(Go.asInterface(_rhs[(0 : GoInt)]), (17 : T_errorCode), ("cannot assign %d values to %d variables" : GoString),
					Go.toInterface((_rhs.length)), Go.toInterface((_lhs.length)));
			};
			return;
		};
		if (_commaOk) {
			var _a:GoArray<Type> = new GoArray<Type>(...[for (i in 0...2) (null : Type)]);
			for (_i in 0..._a.length.toBasic()) {
				_a[(_i : GoInt)] = _check._assignVar(_lhs[(_i : GoInt)], _rhs[(_i : GoInt)]);
			};
			_check._recordCommaOkTypes(_origRHS[(0 : GoInt)], (_a == null ? null : _a.__copy__()));
			return;
		};
		for (_i => _lhs in _lhs) {
			_check._assignVar(_lhs, _rhs[(_i : GoInt)]);
		};
	}

	/**
		// If returnStmt != nil, initVars is called to type-check the assignment
		// of return expressions, and returnStmt is the return statement.
	**/
	@:keep
	static public function _initVars(_check:Ref<Checker>, _lhs:Slice<Ref<Var>>, _origRHS:Slice<stdgo.go.ast.Ast.Expr>,
			_returnStmt:stdgo.go.ast.Ast.Stmt):Void {
		var __tmp__ = _check._exprList(_origRHS, (_lhs.length == (2 : GoInt)) && (_returnStmt == null)),
			_rhs:Slice<Ref<T_operand>> = __tmp__._0,
			_commaOk:Bool = __tmp__._1;
		if ((_lhs.length) != ((_rhs.length))) {
			for (_0 => _obj in _lhs) {
				_obj._used = true;
				if (_obj._object._typ == null) {
					_obj._object._typ = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
				};
			};
			for (_1 => _x in _rhs) {
				if (_x._mode == ((0 : T_operandMode))) {
					return;
				};
			};
			if (_returnStmt != null) {
				var _at:T_positioner = _returnStmt;
				var _qualifier:GoString = ("not enough" : GoString);
				if ((_rhs.length) > (_lhs.length)) {
					_at = _rhs[(_lhs.length : GoInt)]._expr;
					_qualifier = ("too many" : GoString);
				} else if ((_rhs.length) > (0 : GoInt)) {
					_at = _rhs[((_rhs.length) - (1 : GoInt) : GoInt)]._expr;
				};
				var _err = _newErrorf(_at, (103 : T_errorCode), ("%s return values" : GoString), Go.toInterface(_qualifier));
				_err._errorf((0 : stdgo.go.token.Token.Pos), ("have %s" : GoString), Go.toInterface(_check._typesSummary(_operandTypes(_rhs), false)));
				_err._errorf((0 : stdgo.go.token.Token.Pos), ("want %s" : GoString), Go.toInterface(_check._typesSummary(_varTypes(_lhs), false)));
				_check._report(_err);
				return;
			};
			if (false) {
				_check._assignError(_origRHS, (_lhs.length), (_rhs.length));
			} else {
				_check._errorf(Go.asInterface(_rhs[(0 : GoInt)]), (17 : T_errorCode), ("cannot initialize %d variables with %d values" : GoString),
					Go.toInterface((_lhs.length)), Go.toInterface((_rhs.length)));
			};
			return;
		};
		var _context:GoString = ("assignment" : GoString);
		if (_returnStmt != null) {
			_context = ("return statement" : GoString);
		};
		if (_commaOk) {
			var _a:GoArray<Type> = new GoArray<Type>(...[for (i in 0...2) (null : Type)]);
			for (_i in 0..._a.length.toBasic()) {
				_a[(_i : GoInt)] = _check._initVar(_lhs[(_i : GoInt)], _rhs[(_i : GoInt)], _context);
			};
			_check._recordCommaOkTypes(_origRHS[(0 : GoInt)], (_a == null ? null : _a.__copy__()));
			return;
		};
		for (_i => _lhs in _lhs) {
			_check._initVar(_lhs, _rhs[(_i : GoInt)], _context);
		};
	}

	@:keep
	static public function _assignError(_check:Ref<Checker>, _rhs:Slice<stdgo.go.ast.Ast.Expr>, _nvars:GoInt, _nvals:GoInt):Void {
		var _vars:GoString = _measure(_nvars, ("variable" : GoString));
		var _vals:GoString = _measure(_nvals, ("value" : GoString));
		var _rhs0:stdgo.go.ast.Ast.Expr = _rhs[(0 : GoInt)];
		if ((_rhs.length) == ((1 : GoInt))) {
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_unparen(_rhs0)) : Ref<stdgo.go.ast.Ast.CallExpr>)) : Ref<stdgo.go.ast.Ast.CallExpr>), ok: true};
				} catch (_) {
					{value: (null : Ref<stdgo.go.ast.Ast.CallExpr>), ok: false};
				}, _call = __tmp__.value, _0 = __tmp__.ok;
				if (_call != null) {
					_check._errorf(_rhs0, (17 : T_errorCode), ("assignment mismatch: %s but %s returns %s" : GoString), Go.toInterface(_vars),
						Go.toInterface(_call.fun), Go.toInterface(_vals));
					return;
				};
			};
		};
		_check._errorf(_rhs0, (17 : T_errorCode), ("assignment mismatch: %s but %s" : GoString), Go.toInterface(_vars), Go.toInterface(_vals));
	}

	/**
		// typesSummary returns a string of the form "(t1, t2, ...)" where the
		// ti's are user-friendly string representations for the given types.
		// If variadic is set and the last type is a slice, its string is of
		// the form "...E" where E is the slice's element type.
	**/
	@:keep
	static public function _typesSummary(_check:Ref<Checker>, _list:Slice<Type>, _variadic:Bool):GoString {
		var _res:Slice<GoString> = (null : Slice<GoString>);
		for (_i => _t in _list) {
			var _s:GoString = ("" : GoString);
			{
				var __switchIndex__ = -1;
				while (true) {
					if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (_t == null))) {
						@:fallthrough {
							__switchIndex__ = 1;
							continue;
						};
						break;
					} else if (__switchIndex__ == 1
						|| (__switchIndex__ == -1
							&& (Go.toInterface(_t) == Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)]))))) {
						_s = ("<T>" : GoString);
						break;
						break;
					} else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && _isUntyped(_t))) {
						if (_isNumeric(_t)) {
							_s = ("number" : GoString);
						} else {
							_s = stdgo.strings.Strings.replace((Go.typeAssert((Go.toInterface(_t) : Ref<Basic>)) : Ref<Basic>)._name, ("untyped " : GoString),
								Go.str(), (-1 : GoInt));
						};
						break;
						break;
					} else if (__switchIndex__ == 3 || (__switchIndex__ == -1 && (_variadic && (_i == (_list.length - (1 : GoInt)))))) {
						_s = _check._sprintf(("...%s" : GoString), Go.toInterface((Go.typeAssert((Go.toInterface(_t) : Ref<Slice_>)) : Ref<Slice_>)._elem));
						break;
						break;
					};
					break;
				};
			};
			if (_s == (Go.str())) {
				_s = _check._sprintf(("%s" : GoString), Go.toInterface(_t));
			};
			_res = _res.__appendref__(_s);
		};
		return (("(" : GoString) + stdgo.strings.Strings.join(_res, (", " : GoString))) + (")" : GoString);
	}

	@:keep
	static public function _assignVar(_check:Ref<Checker>, _lhs:stdgo.go.ast.Ast.Expr, _x:Ref<T_operand>):Type {
		if ((_x._mode == (0 : T_operandMode))
			|| (Go.toInterface(_x._typ) == Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
			_check._useLHS(_lhs);
			return (null : Type);
		};
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_unparen(_lhs)) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>), ok: true};
		} catch (_) {
			{value: (null : Ref<stdgo.go.ast.Ast.Ident>), ok: false};
		}, _ident = __tmp__.value, _0 = __tmp__.ok;
		if ((_ident != null) && (_ident.name == ("_" : GoString))) {
			_check._recordDef(_ident, (null : Object));
			_check._assignment(_x, (null : Type), ("assignment to _ identifier" : GoString));
			if (_x._mode == ((0 : T_operandMode))) {
				return (null : Type);
			};
			return _x._typ;
		};
		var _v:Ref<Var> = (null : Ref<Var>);
		var _v_used:Bool = false;
		if (_ident != null) {
			{
				var _obj:Object = _check._lookup(_ident.name);
				if (_obj != null) {
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_obj) : Ref<Var>)) : Ref<Var>), ok: true};
						} catch (_) {
							{value: (null : Ref<Var>), ok: false};
						}, _w = __tmp__.value, _1 = __tmp__.ok;
						if ((_w != null) && (_w._object._pkg == _check._pkg)) {
							_v = _w;
							_v_used = _v._used;
						};
					};
				};
			};
		};
		var _z:T_operand = ({} : T_operand);
		_check._expr((_z : Ref<T_operand>), _lhs);
		if (_v != null) {
			_v._used = _v_used;
		};
		if ((_z._mode == (0 : T_operandMode))
			|| (Go.toInterface(_z._typ) == Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
			return (null : Type);
		};
		if (_z._mode == ((0 : T_operandMode))) {
			return (null : Type);
		} else if (_z._mode == ((5 : T_operandMode)) || _z._mode == ((6 : T_operandMode))) {} else {
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_z._expr) : Ref<stdgo.go.ast.Ast.SelectorExpr>)) : Ref<stdgo.go.ast.Ast.SelectorExpr>), ok: true};
				} catch (_) {
					{value: (null : Ref<stdgo.go.ast.Ast.SelectorExpr>), ok: false};
				}, _sel = __tmp__.value, _ok = __tmp__.ok;
				if (_ok) {
					var _op:T_operand = ({} : T_operand);
					_check._expr((_op : Ref<T_operand>), _sel.x);
					if (_op._mode == ((6 : T_operandMode))) {
						_check._errorf(Go.asInterface((_z : Ref<T_operand>)), (24 : T_errorCode), ("cannot assign to struct field %s in map" : GoString),
							Go.toInterface(exprString(_z._expr)));
						return (null : Type);
					};
				};
			};
			_check._errorf(Go.asInterface((_z : Ref<T_operand>)), (18 : T_errorCode), ("cannot assign to %s" : GoString),
				Go.toInterface(Go.asInterface((_z : Ref<T_operand>))));
			return (null : Type);
		};
		_check._assignment(_x, _z._typ, ("assignment" : GoString));
		if (_x._mode == ((0 : T_operandMode))) {
			return (null : Type);
		};
		return _x._typ;
	}

	@:keep
	static public function _initVar(_check:Ref<Checker>, _lhs:Ref<Var>, _x:Ref<T_operand>, _context:GoString):Type {
		if (((_x._mode == (0 : T_operandMode))
			|| (Go.toInterface(_x._typ) == Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)]))))
			|| (Go.toInterface(_lhs._object._typ) == Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
			if (_lhs._object._typ == null) {
				_lhs._object._typ = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
			};
			return (null : Type);
		};
		if (_lhs._object._typ == null) {
			var _typ:Type = _x._typ;
			if (_isUntyped(_typ)) {
				if (Go.toInterface(_typ) == (Go.toInterface(Go.asInterface(typ[((25 : BasicKind) : GoInt)])))) {
					_check._errorf(Go.asInterface(_x), (16 : T_errorCode), ("use of untyped nil in %s" : GoString), Go.toInterface(_context));
					_lhs._object._typ = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
					return (null : Type);
				};
				_typ = default_(_typ);
			};
			_lhs._object._typ = _typ;
		};
		_check._assignment(_x, _lhs._object._typ, _context);
		if (_x._mode == ((0 : T_operandMode))) {
			return (null : Type);
		};
		return _x._typ;
	}

	@:keep
	static public function _initConst(_check:Ref<Checker>, _lhs:Ref<Const>, _x:Ref<T_operand>):Void {
		if (((_x._mode == (0 : T_operandMode))
			|| (Go.toInterface(_x._typ) == Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)]))))
			|| (Go.toInterface(_lhs._object._typ) == Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
			if (_lhs._object._typ == null) {
				_lhs._object._typ = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
			};
			return;
		};
		if (_x._mode != ((4 : T_operandMode))) {
			_check._errorf(Go.asInterface(_x), (13 : T_errorCode), ("%s is not constant" : GoString), Go.toInterface(Go.asInterface(_x)));
			if (_lhs._object._typ == null) {
				_lhs._object._typ = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
			};
			return;
		};
		_assert(_isConstType(_x._typ));
		if (_lhs._object._typ == null) {
			_lhs._object._typ = _x._typ;
		};
		_check._assignment(_x, _lhs._object._typ, ("constant declaration" : GoString));
		if (_x._mode == ((0 : T_operandMode))) {
			return;
		};
		_lhs._val = _x._val;
	}

	/**
		// assignment reports whether x can be assigned to a variable of type T,
		// if necessary by attempting to convert untyped values to the appropriate
		// type. context describes the context in which the assignment takes place.
		// Use T == nil to indicate assignment to an untyped blank identifier.
		// x.mode is set to invalid if the assignment failed.
	**/
	@:keep
	static public function _assignment(_check:Ref<Checker>, _x:Ref<T_operand>, t:Type, _context:GoString):Void {
		_check._singleValue(_x);
		if (_x._mode == ((0 : T_operandMode))) {
			return;
		} else if (_x._mode == ((4 : T_operandMode)) || _x._mode == ((5 : T_operandMode)) || _x._mode == ((6 : T_operandMode))
			|| _x._mode == ((7 : T_operandMode)) || _x._mode == ((8 : T_operandMode)) || _x._mode == ((9 : T_operandMode))) {} else {
			_check._errorf(Go.asInterface(_x), (0 : T_errorCode), ("cannot assign %s to %s in %s" : GoString), Go.toInterface(Go.asInterface(_x)),
				Go.toInterface(t), Go.toInterface(_context));
			return;
		};
		if (_isUntyped(_x._typ)) {
			var _target:Type = t;
			if ((t == null) || _isNonTypeParamInterface(t)) {
				if ((t == null) && (Go.toInterface(_x._typ) == Go.toInterface(Go.asInterface(typ[((25 : BasicKind) : GoInt)])))) {
					_check._errorf(Go.asInterface(_x), (16 : T_errorCode), ("use of untyped nil in %s" : GoString), Go.toInterface(_context));
					_x._mode = (0 : T_operandMode);
					return;
				};
				_target = default_(_x._typ);
			};
			var __tmp__ = _check._implicitTypeAndValue(_x, _target),
				_newType:Type = __tmp__._0,
				_val:stdgo.go.constant.Constant.Value = __tmp__._1,
				_code:T_errorCode = __tmp__._2;
			if (_code != ((0 : T_errorCode))) {
				var _msg:GoString = _check._sprintf(("cannot use %s as %s value in %s" : GoString), Go.toInterface(Go.asInterface(_x)),
					Go.toInterface(_target), Go.toInterface(_context));
				if (_code == ((43 : T_errorCode))) {
					_msg = _msg + ((" (truncated)" : GoString));
				} else if (_code == ((44 : T_errorCode))) {
					_msg = _msg + ((" (overflows)" : GoString));
				} else {
					_code = (23 : T_errorCode);
				};
				_check._error(Go.asInterface(_x), _code, _msg);
				_x._mode = (0 : T_operandMode);
				return;
			};
			if (_val != null) {
				_x._val = _val;
				_check._updateExprVal(_x._expr, _val);
			};
			if (Go.toInterface(_newType) != (Go.toInterface(_x._typ))) {
				_x._typ = _newType;
				_check._updateExprType(_x._expr, _newType, false);
			};
		};
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_under(_x._typ)) : Ref<Signature>)) : Ref<Signature>), ok: true};
			} catch (_) {
				{value: (null : Ref<Signature>), ok: false};
			}, _sig = __tmp__.value, _0 = __tmp__.ok;
			if ((_sig != null) && (_sig.typeParams().len() > (0 : GoInt))) {
				_check._errorf(Go.asInterface(_x), (137 : T_errorCode), ("cannot use generic function %s without instantiation in %s" : GoString),
					Go.toInterface(Go.asInterface(_x)), Go.toInterface(_context));
			};
		};
		if (t == null) {
			return;
		};
		var _reason:GoString = Go.str();
		{
			var __tmp__ = _x._assignableTo(_check, t, Go.pointer(_reason)),
				_ok:Bool = __tmp__._0,
				_code:T_errorCode = __tmp__._1;
			if (!_ok) {
				if (false) {
					if (_reason != (Go.str())) {
						_check._errorf(Go.asInterface(_x), _code, ("cannot use %s as type %s in %s:\n\t%s" : GoString), Go.toInterface(Go.asInterface(_x)),
							Go.toInterface(t), Go.toInterface(_context), Go.toInterface(_reason));
					} else {
						_check._errorf(Go.asInterface(_x), _code, ("cannot use %s as type %s in %s" : GoString), Go.toInterface(Go.asInterface(_x)),
							Go.toInterface(t), Go.toInterface(_context));
					};
				} else {
					if (_reason != (Go.str())) {
						_check._errorf(Go.asInterface(_x), _code, ("cannot use %s as %s value in %s: %s" : GoString), Go.toInterface(Go.asInterface(_x)),
							Go.toInterface(t), Go.toInterface(_context), Go.toInterface(_reason));
					} else {
						_check._errorf(Go.asInterface(_x), _code, ("cannot use %s as %s value in %s" : GoString), Go.toInterface(Go.asInterface(_x)),
							Go.toInterface(t), Go.toInterface(_context));
					};
				};
				_x._mode = (0 : T_operandMode);
			};
		};
	}

	@:embedded
	public static function _lookup(__self__:Checker, __0:GoString):Object
		return __self__._lookup(__0);

	@:embedded
	public static function typeOf(__self__:Checker, _e:stdgo.go.ast.Ast.Expr):Type
		return __self__.typeOf(_e);

	@:embedded
	public static function objectOf(__self__:Checker, _id:Ref<stdgo.go.ast.Ast.Ident>):Object
		return __self__.objectOf(_id);
}

@:structInit private class T_methodInfo__collectObjects_0 {
	public var _obj:Ref<Func> = (null : Ref<Func>);
	public var _ptr:Bool = false;
	public var _recv:Ref<stdgo.go.ast.Ast.Ident> = (null : Ref<stdgo.go.ast.Ast.Ident>);

	public function new(?_obj:Ref<Func>, ?_ptr:Bool, ?_recv:Ref<stdgo.go.ast.Ast.Ident>) {
		if (_obj != null)
			this._obj = _obj;
		if (_ptr != null)
			this._ptr = _ptr;
		if (_recv != null)
			this._recv = _recv;
	}

	public function __underlying__()
		return Go.toInterface(this);

	public function __copy__() {
		return new T_methodInfo__collectObjects_0(_obj, _ptr, _recv);
	}
}

class Context_asInterface {
	/**
		// getID returns a unique ID for the type t.
	**/
	@:keep
	public function _getID(_t:Type):GoInt
		return __self__.value._getID(_t);

	/**
		// update de-duplicates n against previously seen types with the hash h.  If an
		// identical type is found with the type hash h, the previously seen type is
		// returned. Otherwise, n is returned, and recorded in the Context for the hash
		// h.
	**/
	@:keep
	public function _update(_h:GoString, _orig:Type, _targs:Slice<Type>, _inst:Type):Type
		return __self__.value._update(_h, _orig, _targs, _inst);

	/**
		// lookup returns an existing instantiation of orig with targs, if it exists.
		// Otherwise, it returns nil.
	**/
	@:keep
	public function _lookup(_h:GoString, _orig:Type, _targs:Slice<Type>):Type
		return __self__.value._lookup(_h, _orig, _targs);

	/**
		// instanceHash returns a string representation of typ instantiated with targs.
		// The hash should be a perfect hash, though out of caution the type checker
		// does not assume this. The result is guaranteed to not contain blanks.
	**/
	@:keep
	public function _instanceHash(_orig:Type, _targs:Slice<Type>):GoString
		return __self__.value._instanceHash(_orig, _targs);

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Context>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Context_asInterface) class Context_static_extension {
	/**
		// getID returns a unique ID for the type t.
	**/
	@:keep
	static public function _getID(_ctxt:Ref<Context>, _t:Type):GoInt {
		var __deferstack__:Array<Void->Void> = [];
		_ctxt._mu.lock();
		__deferstack__.unshift(() -> _ctxt._mu.unlock());
		try {
			var __tmp__ = (_ctxt._originIDs != null
				&& _ctxt._originIDs.__exists__(_t) ? {value: _ctxt._originIDs[_t], ok: true} : {value: (0 : GoInt), ok: false}),
				_id:GoInt = __tmp__.value,
				_ok:Bool = __tmp__.ok;
			if (!_ok) {
				_id = _ctxt._nextID;
				_ctxt._originIDs[_t] = _id;
				_ctxt._nextID++;
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				return _id;
			};
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return (0 : GoInt);
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return (0 : GoInt);
		};
	}

	/**
		// update de-duplicates n against previously seen types with the hash h.  If an
		// identical type is found with the type hash h, the previously seen type is
		// returned. Otherwise, n is returned, and recorded in the Context for the hash
		// h.
	**/
	@:keep
	static public function _update(_ctxt:Ref<Context>, _h:GoString, _orig:Type, _targs:Slice<Type>, _inst:Type):Type {
		var __deferstack__:Array<Void->Void> = [];
		_assert(_inst != null);
		_ctxt._mu.lock();
		try {
			__deferstack__.unshift(() -> _ctxt._mu.unlock());
			for (_0 => _e in _ctxt._typeMap[_h]) {
				if ((_inst == null) || identical(_inst, _e._instance)) {
					{
						for (defer in __deferstack__) {
							defer();
						};
						return _e._instance;
					};
				};
				if (false) {
					throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("%s and %s are not identical" : GoString), Go.toInterface(_inst),
						Go.toInterface(_e._instance)));
				};
			};
			_ctxt._typeMap[_h] = _ctxt._typeMap[_h].__appendref__(({_orig: _orig, _targs: _targs, _instance: _inst} : T_ctxtEntry));
			{
				for (defer in __deferstack__) {
					defer();
				};
				return _inst;
			};
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return (null : Type);
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return (null : Type);
		};
	}

	/**
		// lookup returns an existing instantiation of orig with targs, if it exists.
		// Otherwise, it returns nil.
	**/
	@:keep
	static public function _lookup(_ctxt:Ref<Context>, _h:GoString, _orig:Type, _targs:Slice<Type>):Type {
		var __deferstack__:Array<Void->Void> = [];
		_ctxt._mu.lock();
		__deferstack__.unshift(() -> _ctxt._mu.unlock());
		try {
			for (_0 => _e in _ctxt._typeMap[_h]) {
				if (_identicalInstance(_orig, _targs, _e._orig, _e._targs)) {
					{
						for (defer in __deferstack__) {
							defer();
						};
						return _e._instance;
					};
				};
				if (false) {
					throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("non-identical instances: (orig: %s, targs: %v) and %s" : GoString), Go.toInterface(_orig),
						Go.toInterface(_targs), Go.toInterface(_e._instance)));
				};
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				return (null : Type);
			};
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return (null : Type);
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return (null : Type);
		};
	}

	/**
		// instanceHash returns a string representation of typ instantiated with targs.
		// The hash should be a perfect hash, though out of caution the type checker
		// does not assume this. The result is guaranteed to not contain blanks.
	**/
	@:keep
	static public function _instanceHash(_ctxt:Ref<Context>, _orig:Type, _targs:Slice<Type>):GoString {
		_assert(_ctxt != null);
		_assert(_orig != null);
		var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
		var _h = _newTypeHasher((_buf : Ref<stdgo.bytes.Bytes.Buffer>), _ctxt);
		_h._string(stdgo.strconv.Strconv.itoa(_ctxt._getID(_orig)));
		_h._typ(_orig);
		if ((_targs.length) > (0 : GoInt)) {
			_h._typeList(_targs);
		};
		return stdgo.strings.Strings.replace((_buf.string() : GoString), (" " : GoString), ("#" : GoString), (-1 : GoInt));
	}
}

class T_importDecl_asInterface {
	@:keep
	public function _node():stdgo.go.ast.Ast.Node
		return __self__.value._node();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_importDecl>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_importDecl_asInterface) class T_importDecl_static_extension {
	@:keep
	static public function _node(_d:T_importDecl):stdgo.go.ast.Ast.Node {
		return Go.asInterface(_d._spec);
	}
}

class T_constDecl_asInterface {
	@:keep
	public function _node():stdgo.go.ast.Ast.Node
		return __self__.value._node();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_constDecl>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_constDecl_asInterface) class T_constDecl_static_extension {
	@:keep
	static public function _node(_d:T_constDecl):stdgo.go.ast.Ast.Node {
		return Go.asInterface(_d._spec);
	}
}

class T_varDecl_asInterface {
	@:keep
	public function _node():stdgo.go.ast.Ast.Node
		return __self__.value._node();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_varDecl>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_varDecl_asInterface) class T_varDecl_static_extension {
	@:keep
	static public function _node(_d:T_varDecl):stdgo.go.ast.Ast.Node {
		return Go.asInterface(_d._spec);
	}
}

class T_typeDecl_asInterface {
	@:keep
	public function _node():stdgo.go.ast.Ast.Node
		return __self__.value._node();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_typeDecl>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_typeDecl_asInterface) class T_typeDecl_static_extension {
	@:keep
	static public function _node(_d:T_typeDecl):stdgo.go.ast.Ast.Node {
		return Go.asInterface(_d._spec);
	}
}

class T_funcDecl_asInterface {
	@:keep
	public function _node():stdgo.go.ast.Ast.Node
		return __self__.value._node();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_funcDecl>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_funcDecl_asInterface) class T_funcDecl_static_extension {
	@:keep
	static public function _node(_d:T_funcDecl):stdgo.go.ast.Ast.Node {
		return Go.asInterface(_d._decl);
	}
}

class T_error__asInterface {
	/**
		// errorf adds formatted error information to err.
		// It may be called multiple times to provide additional information.
	**/
	@:keep
	public function _errorf(_at:stdgo.go.token.Token.Pos, _format:GoString, _args:haxe.Rest<AnyInterface>):Void
		__self__.value._errorf(_at, _format, ..._args);

	/**
		// String is for testing.
	**/
	@:keep
	public function string():GoString
		return __self__.value.string();

	@:keep
	public function _msg(_fset:Ref<stdgo.go.token.Token.FileSet>, _qf:Qualifier):GoString
		return __self__.value._msg(_fset, _qf);

	@:keep
	public function _pos():stdgo.go.token.Token.Pos
		return __self__.value._pos();

	@:keep
	public function _empty():Bool
		return __self__.value._empty();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_error_>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_error__asInterface) class T_error__static_extension {
	/**
		// errorf adds formatted error information to err.
		// It may be called multiple times to provide additional information.
	**/
	@:keep
	static public function _errorf(_err:Ref<T_error_>, _at:stdgo.go.token.Token.Pos, _format:GoString, _args:haxe.Rest<AnyInterface>):Void {
		var _args = new Slice<AnyInterface>(0, 0, ..._args);
		_err._desc = _err._desc.__appendref__((new T_errorDesc(Go.asInterface((_at : T_atPos)), _format, _args) : T_errorDesc));
	}

	/**
		// String is for testing.
	**/
	@:keep
	static public function string(_err:Ref<T_error_>):GoString {
		if (_err._empty()) {
			return ("no error" : GoString);
		};
		return stdgo.fmt.Fmt.sprintf(("%d: %s" : GoString), Go.toInterface(Go.asInterface(_err._pos())), Go.toInterface(_err._msg(null, null)));
	}

	@:keep
	static public function _msg(_err:Ref<T_error_>, _fset:Ref<stdgo.go.token.Token.FileSet>, _qf:Qualifier):GoString {
		if (_err._empty()) {
			return ("no error" : GoString);
		};
		var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
		for (_i in 0..._err._desc.length.toBasic()) {
			var _p = (_err._desc[(_i : GoInt)] : Ref<T_errorDesc>);
			if (_i > (0 : GoInt)) {
				stdgo.fmt.Fmt.fprint(Go.asInterface((_buf : Ref<stdgo.bytes.Bytes.Buffer>)), Go.toInterface(("\n\t" : GoString)));
				if (_p._posn.pos().isValid()) {
					stdgo.fmt.Fmt.fprintf(Go.asInterface((_buf : Ref<stdgo.bytes.Bytes.Buffer>)), ("%s: " : GoString),
						Go.toInterface(Go.asInterface(_fset.position(_p._posn.pos()))));
				};
			};
			_buf.writeString(_sprintf(_fset, _qf, false, _p._format, ..._p._args.__toArray__()));
		};
		return (_buf.string() : GoString);
	}

	@:keep
	static public function _pos(_err:Ref<T_error_>):stdgo.go.token.Token.Pos {
		if (_err._empty()) {
			return (0 : stdgo.go.token.Token.Pos);
		};
		return _err._desc[(0 : GoInt)]._posn.pos();
	}

	@:keep
	static public function _empty(_err:Ref<T_error_>):Bool {
		return _err._desc == null;
	}
}

class T_posSpan_asInterface {
	@:keep
	public function pos():stdgo.go.token.Token.Pos
		return __self__.value.pos();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_posSpan>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_posSpan_asInterface) class T_posSpan_static_extension {
	@:keep
	static public function pos(_e:T_posSpan):stdgo.go.token.Token.Pos {
		return _e._pos;
	}
}

class T_tpWalker_asInterface {
	@:keep
	public function _isParameterizedTypeList(_list:Slice<Type>):Bool
		return __self__.value._isParameterizedTypeList(_list);

	@:keep
	public function _isParameterized(_typ:Type):Bool
		return __self__.value._isParameterized(_typ);

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_tpWalker>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_tpWalker_asInterface) class T_tpWalker_static_extension {
	@:keep
	static public function _isParameterizedTypeList(_w:Ref<T_tpWalker>, _list:Slice<Type>):Bool {
		for (_0 => _t in _list) {
			if (_w._isParameterized(_t)) {
				return true;
			};
		};
		return false;
	}

	@:keep
	static public function _isParameterized(_w:Ref<T_tpWalker>, _typ:Type):Bool {
		var __deferstack__:Array<Void->Void> = [];
		var _res:Bool = false;
		{
			var __tmp__ = (_w._seen != null && _w._seen.__exists__(_typ) ? {value: _w._seen[_typ], ok: true} : {value: false, ok: false}),
				_x:Bool = __tmp__.value,
				_ok:Bool = __tmp__.ok;
			if (_ok) {
				return _x;
			};
		};
		try {
			_w._seen[_typ] = false;
			__deferstack__.unshift(() -> {
				var a = function():Void {
					_w._seen[_typ] = _res;
				};
				a();
			});
			{
				final __type__ = _typ;
				{
					var __bool__ = true;
					while (__bool__) {
						__bool__ = false;
						if (__type__ == null || Go.typeEquals((__type__ : Ref<Basic>))) {
							var _t:Type = __type__ == null ? (null : Type) : cast __type__;
							break;
						} else if (Go.typeEquals((__type__ : Ref<Array_>))) {
							var _t:Ref<Array_> = __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__() == null ? (null : Ref<Array_>) : __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__()
								.value;
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _w._isParameterized(_t._elem);
							};
						} else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
							var _t:Ref<Slice_> = __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__() == null ? (null : Ref<Slice_>) : __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__()
								.value;
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _w._isParameterized(_t._elem);
							};
						} else if (Go.typeEquals((__type__ : Ref<Struct>))) {
							var _t:Ref<Struct> = __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__() == null ? (null : Ref<Struct>) : __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__()
								.value;
							for (_0 => _fld in _t._fields) {
								if (_w._isParameterized(_fld._object._typ)) {
									{
										for (defer in __deferstack__) {
											defer();
										};
										return true;
									};
								};
							};
						} else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
							var _t:Ref<Pointer_> = __type__ == null ? (null : Ref<Pointer_>) : __type__.__underlying__() == null ? (null : Ref<Pointer_>) : __type__ == null ? (null : Ref<Pointer_>) : __type__.__underlying__()
								.value;
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _w._isParameterized(_t._base);
							};
						} else if (Go.typeEquals((__type__ : Ref<Tuple>))) {
							var _t:Ref<Tuple> = __type__ == null ? (null : Ref<Tuple>) : __type__.__underlying__() == null ? (null : Ref<Tuple>) : __type__ == null ? (null : Ref<Tuple>) : __type__.__underlying__()
								.value;
							var _n:GoInt = _t.len();
							{
								var _i:GoInt = (0 : GoInt);
								Go.cfor(_i < _n, _i++, {
									if (_w._isParameterized(_t.at(_i)._object._typ)) {
										{
											for (defer in __deferstack__) {
												defer();
											};
											return true;
										};
									};
								});
							};
						} else if (Go.typeEquals((__type__ : Ref<Signature>))) {
							var _t:Ref<Signature> = __type__ == null ? (null : Ref<Signature>) : __type__.__underlying__() == null ? (null : Ref<Signature>) : __type__ == null ? (null : Ref<Signature>) : __type__.__underlying__()
								.value;
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _w._isParameterized(Go.asInterface(_t._params)) || _w._isParameterized(Go.asInterface(_t._results));
							};
						} else if (Go.typeEquals((__type__ : Ref<Interface>))) {
							var _t:Ref<Interface> = __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__() == null ? (null : Ref<Interface>) : __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__()
								.value;
							var _tset = _t._typeSet();
							for (_1 => _m in _tset._methods) {
								if (_w._isParameterized(_m._object._typ)) {
									{
										for (defer in __deferstack__) {
											defer();
										};
										return true;
									};
								};
							};
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _tset._is(function(_t:Ref<T_term>):Bool {
									return (_t != null) && _w._isParameterized(_t._typ);
								});
							};
						} else if (Go.typeEquals((__type__ : Ref<Map_>))) {
							var _t:Ref<Map_> = __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__() == null ? (null : Ref<Map_>) : __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__()
								.value;
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _w._isParameterized(_t._key) || _w._isParameterized(_t._elem);
							};
						} else if (Go.typeEquals((__type__ : Ref<Chan>))) {
							var _t:Ref<Chan> = __type__ == null ? (null : Ref<Chan>) : __type__.__underlying__() == null ? (null : Ref<Chan>) : __type__ == null ? (null : Ref<Chan>) : __type__.__underlying__()
								.value;
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _w._isParameterized(_t._elem);
							};
						} else if (Go.typeEquals((__type__ : Ref<Named>))) {
							var _t:Ref<Named> = __type__ == null ? (null : Ref<Named>) : __type__.__underlying__() == null ? (null : Ref<Named>) : __type__ == null ? (null : Ref<Named>) : __type__.__underlying__()
								.value;
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _w._isParameterizedTypeList(_t.typeArgs()._list());
							};
						} else if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
							var _t:Ref<TypeParam> = __type__ == null ? (null : Ref<TypeParam>) : __type__.__underlying__() == null ? (null : Ref<TypeParam>) : __type__ == null ? (null : Ref<TypeParam>) : __type__.__underlying__()
								.value;
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _tparamIndex(_w._tparams, _t) >= (0 : GoInt);
							};
						} else {
							var _t:Type = __type__ == null ? (null : Type) : cast __type__;
							_unreachable();
						};
						break;
					};
				};
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				return false;
			};
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return _res;
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return _res;
		};
	}
}

class T_cycleFinder_asInterface {
	@:keep
	public function _varList(_list:Slice<Ref<Var>>):Void
		__self__.value._varList(_list);

	@:keep
	public function _typ(_typ:Type):Void
		__self__.value._typ(_typ);

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_cycleFinder>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_cycleFinder_asInterface) class T_cycleFinder_static_extension {
	@:keep
	static public function _varList(_w:Ref<T_cycleFinder>, _list:Slice<Ref<Var>>):Void {
		for (_0 => _v in _list) {
			_w._typ(_v._object._typ);
		};
	}

	@:keep
	static public function _typ(_w:Ref<T_cycleFinder>, _typ:Type):Void {
		var __deferstack__:Array<Void->Void> = [];
		if (_w._seen[_typ]) {
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_typ) : Ref<TypeParam>)) : Ref<TypeParam>), ok: true};
				} catch (_) {
					{value: (null : Ref<TypeParam>), ok: false};
				}, _tpar = __tmp__.value, _0 = __tmp__.ok;
				if (_tpar != null) {
					{
						var _i:GoInt = _tparamIndex(_w._tparams, _tpar);
						if (_i >= (0 : GoInt)) {
							_w._types[(_i : GoInt)] = (null : Type);
						};
					};
				};
			};
			return;
		};
		try {
			_w._seen[_typ] = true;
			{
				var _a0 = _w._seen;
				var _a1 = _typ;
				__deferstack__.unshift(() -> if (_a0 != null) _a0.__remove__(_a1));
			};
			{
				final __type__ = _typ;
				if (Go.typeEquals((__type__ : Ref<Basic>))) {
					var _t:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
						.value;
				} else if (Go.typeEquals((__type__ : Ref<Array_>))) {
					var _t:Ref<Array_> = __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__() == null ? (null : Ref<Array_>) : __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__()
						.value;
					_w._typ(_t._elem);
				} else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
					var _t:Ref<Slice_> = __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__() == null ? (null : Ref<Slice_>) : __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__()
						.value;
					_w._typ(_t._elem);
				} else if (Go.typeEquals((__type__ : Ref<Struct>))) {
					var _t:Ref<Struct> = __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__() == null ? (null : Ref<Struct>) : __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__()
						.value;
					_w._varList(_t._fields);
				} else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
					var _t:Ref<Pointer_> = __type__ == null ? (null : Ref<Pointer_>) : __type__.__underlying__() == null ? (null : Ref<Pointer_>) : __type__ == null ? (null : Ref<Pointer_>) : __type__.__underlying__()
						.value;
					_w._typ(_t._base);
				} else if (Go.typeEquals((__type__ : Ref<Signature>))) {
					var _t:Ref<Signature> = __type__ == null ? (null : Ref<Signature>) : __type__.__underlying__() == null ? (null : Ref<Signature>) : __type__ == null ? (null : Ref<Signature>) : __type__.__underlying__()
						.value;
					if (_t._params != null) {
						_w._varList(_t._params._vars);
					};
					if (_t._results != null) {
						_w._varList(_t._results._vars);
					};
				} else if (Go.typeEquals((__type__ : Ref<Union>))) {
					var _t:Ref<Union> = __type__ == null ? (null : Ref<Union>) : __type__.__underlying__() == null ? (null : Ref<Union>) : __type__ == null ? (null : Ref<Union>) : __type__.__underlying__()
						.value;
					for (_1 => _t in _t._terms) {
						_w._typ(_t._typ);
					};
				} else if (Go.typeEquals((__type__ : Ref<Interface>))) {
					var _t:Ref<Interface> = __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__() == null ? (null : Ref<Interface>) : __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__()
						.value;
					for (_2 => _m in _t._methods) {
						_w._typ(_m._object._typ);
					};
					for (_5 => _t in _t._embeddeds) {
						_w._typ(_t);
					};
				} else if (Go.typeEquals((__type__ : Ref<Map_>))) {
					var _t:Ref<Map_> = __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__() == null ? (null : Ref<Map_>) : __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__()
						.value;
					_w._typ(_t._key);
					_w._typ(_t._elem);
				} else if (Go.typeEquals((__type__ : Ref<Chan>))) {
					var _t:Ref<Chan> = __type__ == null ? (null : Ref<Chan>) : __type__.__underlying__() == null ? (null : Ref<Chan>) : __type__ == null ? (null : Ref<Chan>) : __type__.__underlying__()
						.value;
					_w._typ(_t._elem);
				} else if (Go.typeEquals((__type__ : Ref<Named>))) {
					var _t:Ref<Named> = __type__ == null ? (null : Ref<Named>) : __type__.__underlying__() == null ? (null : Ref<Named>) : __type__ == null ? (null : Ref<Named>) : __type__.__underlying__()
						.value;
					for (_8 => _tpar in _t.typeArgs()._list()) {
						_w._typ(_tpar);
					};
				} else if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
					var _t:Ref<TypeParam> = __type__ == null ? (null : Ref<TypeParam>) : __type__.__underlying__() == null ? (null : Ref<TypeParam>) : __type__ == null ? (null : Ref<TypeParam>) : __type__.__underlying__()
						.value;
					{
						var _i:GoInt = _tparamIndex(_w._tparams, _t);
						if ((_i >= (0 : GoInt)) && (_w._types[(_i : GoInt)] != null)) {
							_w._typ(_w._types[(_i : GoInt)]);
						};
					};
				} else {
					var _t:Type = __type__ == null ? (null : Type) : cast __type__;
					throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("unexpected %T" : GoString), Go.toInterface(_typ)));
				};
			};
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return;
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return;
		};
	}
}

class T_graphNode_asInterface {
	/**
		// cost returns the cost of removing this node, which involves copying each
		// predecessor to each successor (and vice-versa).
	**/
	@:keep
	public function _cost():GoInt
		return __self__.value._cost();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_graphNode>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_graphNode_asInterface) class T_graphNode_static_extension {
	/**
		// cost returns the cost of removing this node, which involves copying each
		// predecessor to each successor (and vice-versa).
	**/
	@:keep
	static public function _cost(_n:Ref<T_graphNode>):GoInt {
		return (_n._pred.length) * (_n._succ.length);
	}
}

class Interface_asInterface {
	@:keep
	public function _cleanup():Void
		__self__.value._cleanup();

	@:keep
	public function string():GoString
		return __self__.value.string();

	@:keep
	public function underlying():Type
		return __self__.value.underlying();

	/**
		// Complete computes the interface's type set. It must be called by users of
		// NewInterfaceType and NewInterface after the interface's embedded types are
		// fully defined and before using the interface type in any way other than to
		// form other types. The interface must not contain duplicate methods or a
		// panic occurs. Complete returns the receiver.
		//
		// Interface types that have been completed are safe for concurrent use.
	**/
	@:keep
	public function complete():Ref<Interface>
		return __self__.value.complete();

	/**
		// IsImplicit reports whether the interface t is a wrapper for a type set literal.
	**/
	@:keep
	public function isImplicit():Bool
		return __self__.value.isImplicit();

	/**
		// IsMethodSet reports whether the interface t is fully described by its method
		// set.
	**/
	@:keep
	public function isMethodSet():Bool
		return __self__.value.isMethodSet();

	/**
		// IsComparable reports whether each type in interface t's type set is comparable.
	**/
	@:keep
	public function isComparable():Bool
		return __self__.value.isComparable();

	/**
		// Empty reports whether t is the empty interface.
	**/
	@:keep
	public function empty():Bool
		return __self__.value.empty();

	/**
		// Method returns the i'th method of interface t for 0 <= i < t.NumMethods().
		// The methods are ordered by their unique Id.
	**/
	@:keep
	public function method(_i:GoInt):Ref<Func>
		return __self__.value.method(_i);

	/**
		// NumMethods returns the total number of methods of interface t.
	**/
	@:keep
	public function numMethods():GoInt
		return __self__.value.numMethods();

	/**
		// EmbeddedType returns the i'th embedded type of interface t for 0 <= i < t.NumEmbeddeds().
	**/
	@:keep
	public function embeddedType(_i:GoInt):Type
		return __self__.value.embeddedType(_i);

	/**
		// Embedded returns the i'th embedded defined (*Named) type of interface t for 0 <= i < t.NumEmbeddeds().
		// The result is nil if the i'th embedded type is not a defined type.
		//
		// Deprecated: Use EmbeddedType which is not restricted to defined (*Named) types.
	**/
	@:keep
	public function embedded(_i:GoInt):Ref<Named>
		return __self__.value.embedded(_i);

	/**
		// NumEmbeddeds returns the number of embedded types in interface t.
	**/
	@:keep
	public function numEmbeddeds():GoInt
		return __self__.value.numEmbeddeds();

	/**
		// ExplicitMethod returns the i'th explicitly declared method of interface t for 0 <= i < t.NumExplicitMethods().
		// The methods are ordered by their unique Id.
	**/
	@:keep
	public function explicitMethod(_i:GoInt):Ref<Func>
		return __self__.value.explicitMethod(_i);

	/**
		// NumExplicitMethods returns the number of explicitly declared methods of interface t.
	**/
	@:keep
	public function numExplicitMethods():GoInt
		return __self__.value.numExplicitMethods();

	/**
		// MarkImplicit marks the interface t as implicit, meaning this interface
		// corresponds to a constraint literal such as ~T or A|B without explicit
		// interface embedding. MarkImplicit should be called before any concurrent use
		// of implicit interfaces.
	**/
	@:keep
	public function markImplicit():Void
		__self__.value.markImplicit();

	/**
		// typeSet returns the type set for interface t.
	**/
	@:keep
	public function _typeSet():Ref<T__TypeSet>
		return __self__.value._typeSet();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Interface>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Interface_asInterface) class Interface_static_extension {
	@:keep
	static public function _cleanup(_t:Ref<Interface>):Void {
		_t._check = null;
		_t._embedPos = null;
	}

	@:keep
	static public function string(_t:Ref<Interface>):GoString {
		return typeString(Go.asInterface(_t), null);
	}

	@:keep
	static public function underlying(_t:Ref<Interface>):Type {
		return Go.asInterface(_t);
	}

	/**
		// Complete computes the interface's type set. It must be called by users of
		// NewInterfaceType and NewInterface after the interface's embedded types are
		// fully defined and before using the interface type in any way other than to
		// form other types. The interface must not contain duplicate methods or a
		// panic occurs. Complete returns the receiver.
		//
		// Interface types that have been completed are safe for concurrent use.
	**/
	@:keep
	static public function complete(_t:Ref<Interface>):Ref<Interface> {
		if (!_t._complete) {
			_t._complete = true;
		};
		_t._typeSet();
		return _t;
	}

	/**
		// IsImplicit reports whether the interface t is a wrapper for a type set literal.
	**/
	@:keep
	static public function isImplicit(_t:Ref<Interface>):Bool {
		return _t._implicit;
	}

	/**
		// IsMethodSet reports whether the interface t is fully described by its method
		// set.
	**/
	@:keep
	static public function isMethodSet(_t:Ref<Interface>):Bool {
		return _t._typeSet().isMethodSet();
	}

	/**
		// IsComparable reports whether each type in interface t's type set is comparable.
	**/
	@:keep
	static public function isComparable(_t:Ref<Interface>):Bool {
		return _t._typeSet().isComparable((null : GoMap<Type, Bool>));
	}

	/**
		// Empty reports whether t is the empty interface.
	**/
	@:keep
	static public function empty(_t:Ref<Interface>):Bool {
		return _t._typeSet().isAll();
	}

	/**
		// Method returns the i'th method of interface t for 0 <= i < t.NumMethods().
		// The methods are ordered by their unique Id.
	**/
	@:keep
	static public function method(_t:Ref<Interface>, _i:GoInt):Ref<Func> {
		return _t._typeSet().method(_i);
	}

	/**
		// NumMethods returns the total number of methods of interface t.
	**/
	@:keep
	static public function numMethods(_t:Ref<Interface>):GoInt {
		return _t._typeSet().numMethods();
	}

	/**
		// EmbeddedType returns the i'th embedded type of interface t for 0 <= i < t.NumEmbeddeds().
	**/
	@:keep
	static public function embeddedType(_t:Ref<Interface>, _i:GoInt):Type {
		return _t._embeddeds[(_i : GoInt)];
	}

	/**
		// Embedded returns the i'th embedded defined (*Named) type of interface t for 0 <= i < t.NumEmbeddeds().
		// The result is nil if the i'th embedded type is not a defined type.
		//
		// Deprecated: Use EmbeddedType which is not restricted to defined (*Named) types.
	**/
	@:keep
	static public function embedded(_t:Ref<Interface>, _i:GoInt):Ref<Named> {
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(_t._embeddeds[(_i : GoInt)]) : Ref<Named>)) : Ref<Named>), ok: true};
		} catch (_) {
			{value: (null : Ref<Named>), ok: false};
		}, _tname = __tmp__.value, _2 = __tmp__.ok;
		return _tname;
	}

	/**
		// NumEmbeddeds returns the number of embedded types in interface t.
	**/
	@:keep
	static public function numEmbeddeds(_t:Ref<Interface>):GoInt {
		return (_t._embeddeds.length);
	}

	/**
		// ExplicitMethod returns the i'th explicitly declared method of interface t for 0 <= i < t.NumExplicitMethods().
		// The methods are ordered by their unique Id.
	**/
	@:keep
	static public function explicitMethod(_t:Ref<Interface>, _i:GoInt):Ref<Func> {
		return _t._methods[(_i : GoInt)];
	}

	/**
		// NumExplicitMethods returns the number of explicitly declared methods of interface t.
	**/
	@:keep
	static public function numExplicitMethods(_t:Ref<Interface>):GoInt {
		return (_t._methods.length);
	}

	/**
		// MarkImplicit marks the interface t as implicit, meaning this interface
		// corresponds to a constraint literal such as ~T or A|B without explicit
		// interface embedding. MarkImplicit should be called before any concurrent use
		// of implicit interfaces.
	**/
	@:keep
	static public function markImplicit(_t:Ref<Interface>):Void {
		_t._implicit = true;
	}

	/**
		// typeSet returns the type set for interface t.
	**/
	@:keep
	static public function _typeSet(_t:Ref<Interface>):Ref<T__TypeSet> {
		return _computeInterfaceTypeSet(_t._check, (0 : stdgo.go.token.Token.Pos), _t);
	}
}

class T_block_asInterface {
	/**
		// enclosingTarget returns the innermost enclosing labeled
		// statement with the given label name, or nil.
	**/
	@:keep
	public function _enclosingTarget(_name:GoString):Ref<stdgo.go.ast.Ast.LabeledStmt>
		return __self__.value._enclosingTarget(_name);

	/**
		// gotoTarget returns the labeled statement in the current
		// or an enclosing block with the given label name, or nil.
	**/
	@:keep
	public function _gotoTarget(_name:GoString):Ref<stdgo.go.ast.Ast.LabeledStmt>
		return __self__.value._gotoTarget(_name);

	/**
		// insert records a new label declaration for the current block.
		// The label must not have been declared before in any block.
	**/
	@:keep
	public function _insert(_s:Ref<stdgo.go.ast.Ast.LabeledStmt>):Void
		__self__.value._insert(_s);

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_block>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_block_asInterface) class T_block_static_extension {
	/**
		// enclosingTarget returns the innermost enclosing labeled
		// statement with the given label name, or nil.
	**/
	@:keep
	static public function _enclosingTarget(_b:Ref<T_block>, _name:GoString):Ref<stdgo.go.ast.Ast.LabeledStmt> {
		{
			var _s = _b;
			Go.cfor(_s != null, _s = _s._parent, {
				{
					var _t = _s._lstmt;
					if ((_t != null) && (_t.label.name == _name)) {
						return _t;
					};
				};
			});
		};
		return null;
	}

	/**
		// gotoTarget returns the labeled statement in the current
		// or an enclosing block with the given label name, or nil.
	**/
	@:keep
	static public function _gotoTarget(_b:Ref<T_block>, _name:GoString):Ref<stdgo.go.ast.Ast.LabeledStmt> {
		{
			var _s = _b;
			Go.cfor(_s != null, _s = _s._parent, {
				{
					var _t = _s._labels[_name];
					if (_t != null) {
						return _t;
					};
				};
			});
		};
		return null;
	}

	/**
		// insert records a new label declaration for the current block.
		// The label must not have been declared before in any block.
	**/
	@:keep
	static public function _insert(_b:Ref<T_block>, _s:Ref<stdgo.go.ast.Ast.LabeledStmt>):Void {
		var _name:GoString = _s.label.name;
		if (false) {
			_assert(_b._gotoTarget(_name) == null);
		};
		var _labels = _b._labels;
		if (_labels == null) {
			_labels = (new GoObjectMap<GoString,
				Ref<stdgo.go.ast.Ast.LabeledStmt>>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({
				get: () -> stdgo.internal.reflect.Reflect.GoType.basic(string_kind)
			},
				{get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () ->
						stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.ast.Ast.LabeledStmt", [], null, false, {get: () -> null})})}))) : GoMap<GoString,
					Ref<stdgo.go.ast.Ast.LabeledStmt>>);
			_b._labels = _labels;
		};
		_labels[_name] = _s;
	}
}

class T_instanceLookup_asInterface {
	@:keep
	public function _add(_inst:Ref<Named>):Void
		__self__.value._add(_inst);

	@:keep
	public function _lookup(_inst:Ref<Named>):Ref<Named>
		return __self__.value._lookup(_inst);

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_instanceLookup>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_instanceLookup_asInterface) class T_instanceLookup_static_extension {
	@:keep
	static public function _add(_l:Ref<T_instanceLookup>, _inst:Ref<Named>):Void {
		if (_l._m == null) {
			_l._m = (new GoObjectMap<Ref<Named>,
				Slice<Ref<Named>>>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
					stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("Named", [], null, false, {get: () ->
						null})})},
				{get: () -> stdgo.internal.reflect.Reflect.GoType.sliceType({get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () ->
						stdgo.internal.reflect.Reflect.GoType.named("Named", [], null, false, {get: () -> null})})})}))) : GoMap<Ref<Named>,
					Slice<Ref<Named>>>);
		};
		var _insts = _l._m[_inst.origin()];
		_l._m[_inst.origin()] = (_insts.__append__(_inst));
	}

	@:keep
	static public function _lookup(_l:Ref<T_instanceLookup>, _inst:Ref<Named>):Ref<Named> {
		for (_0 => _t in _l._m[_inst.origin()]) {
			if (identical(Go.asInterface(_inst), Go.asInterface(_t))) {
				return _t;
			};
		};
		return null;
	}
}

class Map__asInterface {
	@:keep
	public function string():GoString
		return __self__.value.string();

	@:keep
	public function underlying():Type
		return __self__.value.underlying();

	/**
		// Elem returns the element type of map m.
	**/
	@:keep
	public function elem():Type
		return __self__.value.elem();

	/**
		// Key returns the key type of map m.
	**/
	@:keep
	public function key():Type
		return __self__.value.key();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Map_>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Map__asInterface) class Map__static_extension {
	@:keep
	static public function string(_t:Ref<Map_>):GoString {
		return typeString(Go.asInterface(_t), null);
	}

	@:keep
	static public function underlying(_t:Ref<Map_>):Type {
		return Go.asInterface(_t);
	}

	/**
		// Elem returns the element type of map m.
	**/
	@:keep
	static public function elem(_m:Ref<Map_>):Type {
		return _m._elem;
	}

	/**
		// Key returns the key type of map m.
	**/
	@:keep
	static public function key(_m:Ref<Map_>):Type {
		return _m._key;
	}
}

class MethodSet_asInterface {
	/**
		// Lookup returns the method with matching package and name, or nil if not found.
	**/
	@:keep
	public function lookup(_pkg:Ref<Package>, _name:GoString):Ref<Selection>
		return __self__.value.lookup(_pkg, _name);

	/**
		// At returns the i'th method in s for 0 <= i < s.Len().
	**/
	@:keep
	public function at(_i:GoInt):Ref<Selection>
		return __self__.value.at(_i);

	/**
		// Len returns the number of methods in s.
	**/
	@:keep
	public function len():GoInt
		return __self__.value.len();

	@:keep
	public function string():GoString
		return __self__.value.string();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<MethodSet>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.MethodSet_asInterface) class MethodSet_static_extension {
	/**
		// Lookup returns the method with matching package and name, or nil if not found.
	**/
	@:keep
	static public function lookup(_s:Ref<MethodSet>, _pkg:Ref<Package>, _name:GoString):Ref<Selection> {
		if (_s.len() == ((0 : GoInt))) {
			return null;
		};
		var _key:GoString = id(_pkg, _name);
		var _i:GoInt = stdgo.sort.Sort.search((_s._list.length), function(_i:GoInt):Bool {
			var _m = _s._list[(_i : GoInt)];
			return _m._obj.id() >= _key;
		});
		if (_i < (_s._list.length)) {
			var _m = _s._list[(_i : GoInt)];
			if (_m._obj.id() == (_key)) {
				return _m;
			};
		};
		return null;
	}

	/**
		// At returns the i'th method in s for 0 <= i < s.Len().
	**/
	@:keep
	static public function at(_s:Ref<MethodSet>, _i:GoInt):Ref<Selection> {
		return _s._list[(_i : GoInt)];
	}

	/**
		// Len returns the number of methods in s.
	**/
	@:keep
	static public function len(_s:Ref<MethodSet>):GoInt {
		return (_s._list.length);
	}

	@:keep
	static public function string(_s:Ref<MethodSet>):GoString {
		if (_s.len() == ((0 : GoInt))) {
			return ("MethodSet {}" : GoString);
		};
		var _buf:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
		stdgo.fmt.Fmt.fprintln(Go.asInterface((_buf : Ref<stdgo.strings.Strings.Builder>)), Go.toInterface(("MethodSet {" : GoString)));
		for (_0 => _f in _s._list) {
			stdgo.fmt.Fmt.fprintf(Go.asInterface((_buf : Ref<stdgo.strings.Strings.Builder>)), ("\t%s\n" : GoString), Go.toInterface(Go.asInterface(_f)));
		};
		stdgo.fmt.Fmt.fprintln(Go.asInterface((_buf : Ref<stdgo.strings.Strings.Builder>)), Go.toInterface(("}" : GoString)));
		return (_buf.string() : GoString);
	}
}

class T_monoGraph_asInterface {
	@:keep
	public function _addEdge(_dst:GoInt, _src:GoInt, _weight:GoInt, _pos:stdgo.go.token.Token.Pos, _typ:Type):Void
		__self__.value._addEdge(_dst, _src, _weight, _pos, _typ);

	/**
		// typeParamVertex returns the index of the vertex representing tpar.
	**/
	@:keep
	public function _typeParamVertex(_tpar:Ref<TypeParam>):GoInt
		return __self__.value._typeParamVertex(_tpar);

	/**
		// localNamedVertex returns the index of the vertex representing
		// named, or -1 if named doesn't need representation.
	**/
	@:keep
	public function _localNamedVertex(_pkg:Ref<Package>, _named:Ref<Named>):GoInt
		return __self__.value._localNamedVertex(_pkg, _named);

	/**
		// assign records that tpar was instantiated as targ at pos.
	**/
	@:keep
	public function _assign(_pkg:Ref<Package>, _pos:stdgo.go.token.Token.Pos, _tpar:Ref<TypeParam>, _targ:Type):Void
		__self__.value._assign(_pkg, _pos, _tpar, _targ);

	/**
		// recordInstance records that the given type parameters were
		// instantiated with the corresponding type arguments.
	**/
	@:keep
	public function _recordInstance(_pkg:Ref<Package>, _pos:stdgo.go.token.Token.Pos, _tparams:Slice<Ref<TypeParam>>, _targs:Slice<Type>,
			_xlist:Slice<stdgo.go.ast.Ast.Expr>):Void
		__self__.value._recordInstance(_pkg, _pos, _tparams, _targs, _xlist);

	/**
		// recordCanon records that tpar is the canonical type parameter
		// corresponding to method type parameter mpar.
	**/
	@:keep
	public function _recordCanon(_mpar:Ref<TypeParam>, _tpar:Ref<TypeParam>):Void
		__self__.value._recordCanon(_mpar, _tpar);

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_monoGraph>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_monoGraph_asInterface) class T_monoGraph_static_extension {
	@:keep
	static public function _addEdge(_w:Ref<T_monoGraph>, _dst:GoInt, _src:GoInt, _weight:GoInt, _pos:stdgo.go.token.Token.Pos, _typ:Type):Void {
		_w._edges = _w._edges.__appendref__(({
			_dst: _dst,
			_src: _src,
			_weight: _weight,
			_pos: _pos,
			_typ: _typ
		} : T_monoEdge));
	}

	/**
		// typeParamVertex returns the index of the vertex representing tpar.
	**/
	@:keep
	static public function _typeParamVertex(_w:Ref<T_monoGraph>, _tpar:Ref<TypeParam>):GoInt {
		{
			var __tmp__ = (_w._canon != null
				&& _w._canon.__exists__(_tpar) ? {value: _w._canon[_tpar], ok: true} : {value: (null : Ref<TypeParam>), ok: false}),
				_x:Ref<TypeParam> = __tmp__.value,
				_ok:Bool = __tmp__.ok;
			if (_ok) {
				_tpar = _x;
			};
		};
		var _obj = _tpar.obj();
		{
			var __tmp__ = (_w._nameIdx != null
				&& _w._nameIdx.__exists__(_obj) ? {value: _w._nameIdx[_obj], ok: true} : {value: (0 : GoInt), ok: false}),
				_idx:GoInt = __tmp__.value,
				_ok:Bool = __tmp__.ok;
			if (_ok) {
				return _idx;
			};
		};
		if (_w._nameIdx == null) {
			_w._nameIdx = (new GoObjectMap<Ref<TypeName>,
				GoInt>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
					stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("TypeName", [], null, false,
						{get: () -> null})})},
				{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(int_kind)}))) : GoMap<Ref<TypeName>, GoInt>);
		};
		var _idx:GoInt = (_w._vertices.length);
		_w._vertices = _w._vertices.__appendref__(({_obj: _obj} : T_monoVertex));
		_w._nameIdx[_obj] = _idx;
		return _idx;
	}

	/**
		// localNamedVertex returns the index of the vertex representing
		// named, or -1 if named doesn't need representation.
	**/
	@:keep
	static public function _localNamedVertex(_w:Ref<T_monoGraph>, _pkg:Ref<Package>, _named:Ref<Named>):GoInt {
		var _obj = _named.obj();
		if (_obj.pkg() != (_pkg)) {
			return (-1 : GoInt);
		};
		var _root = _pkg.scope();
		if (_obj.parent() == (_root)) {
			return (-1 : GoInt);
		};
		{
			var __tmp__ = (_w._nameIdx != null
				&& _w._nameIdx.__exists__(_obj) ? {value: _w._nameIdx[_obj], ok: true} : {value: (0 : GoInt), ok: false}),
				_idx:GoInt = __tmp__.value,
				_ok:Bool = __tmp__.ok;
			if (_ok) {
				return _idx;
			};
		};
		var _idx:GoInt = (-1 : GoInt);
		{
			var _scope = _obj.parent();
			Go.cfor(_scope != (_root), _scope = _scope.parent(), {
				for (_0 => _elem in _scope._elems) {
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_elem) : Ref<TypeName>)) : Ref<TypeName>), ok: true};
						} catch (_) {
							{value: (null : Ref<TypeName>), ok: false};
						}, _elem = __tmp__.value, _ok = __tmp__.ok;
						if ((_ok && !_elem.isAlias()) && (_elem.pos() < _obj.pos())) {
							{
								var __tmp__ = try {
									{value: (Go.typeAssert((Go.toInterface(_elem.type()) : Ref<TypeParam>)) : Ref<TypeParam>), ok: true};
								} catch (_) {
									{value: (null : Ref<TypeParam>), ok: false};
								}, _tpar = __tmp__.value, _ok = __tmp__.ok;
								if (_ok) {
									if (_idx < (0:GoInt)) {
										_idx = (_w._vertices.length);
										_w._vertices = _w._vertices.__appendref__(({_obj: _obj} : T_monoVertex));
									};
									_w._addEdge(_idx, _w._typeParamVertex(_tpar), (1 : GoInt), _obj.pos(), Go.asInterface(_tpar));
								};
							};
						};
					};
				};
			});
		};
		if (_w._nameIdx == null) {
			_w._nameIdx = (new GoObjectMap<Ref<TypeName>,
				GoInt>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
					stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("TypeName", [], null, false,
						{get: () -> null})})},
				{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(int_kind)}))) : GoMap<Ref<TypeName>, GoInt>);
		};
		_w._nameIdx[_obj] = _idx;
		return _idx;
	}

	/**
		// assign records that tpar was instantiated as targ at pos.
	**/
	@:keep
	static public function _assign(_w:Ref<T_monoGraph>, _pkg:Ref<Package>, _pos:stdgo.go.token.Token.Pos, _tpar:Ref<TypeParam>, _targ:Type):Void {
		if (_tpar.obj().pkg() != (_pkg)) {
			return;
		};
		var _flow:(GoInt, Type) -> Void = function(_src:GoInt, _typ:Type):Void {
			var _weight:GoInt = (1 : GoInt);
			if (Go.toInterface(_typ) == (Go.toInterface(_targ))) {
				_weight = (0 : GoInt);
			};
			_w._addEdge(_w._typeParamVertex(_tpar), _src, _weight, _pos, _targ);
		};
		var _do:(_typ:Type) -> Void = null;
		_do = function(_typ:Type):Void {
			{
				final __type__ = _typ;
				if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
					var _typ:Ref<TypeParam> = __type__ == null ? (null : Ref<TypeParam>) : __type__.__underlying__() == null ? (null : Ref<TypeParam>) : __type__ == null ? (null : Ref<TypeParam>) : __type__.__underlying__()
						.value;
					_assert(_typ.obj().pkg() == (_pkg));
					_flow(_w._typeParamVertex(_typ), Go.asInterface(_typ));
				} else if (Go.typeEquals((__type__ : Ref<Named>))) {
					var _typ:Ref<Named> = __type__ == null ? (null : Ref<Named>) : __type__.__underlying__() == null ? (null : Ref<Named>) : __type__ == null ? (null : Ref<Named>) : __type__.__underlying__()
						.value;
					{
						var _src:GoInt = _w._localNamedVertex(_pkg, _typ.origin());
						if (_src >= (0 : GoInt)) {
							_flow(_src, Go.asInterface(_typ));
						};
					};
					var _targs = _typ.typeArgs();
					{
						var _i:GoInt = (0 : GoInt);
						Go.cfor(_i < _targs.len(), _i++, {
							_do(_targs.at(_i));
						});
					};
				} else if (Go.typeEquals((__type__ : Ref<Array_>))) {
					var _typ:Ref<Array_> = __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__() == null ? (null : Ref<Array_>) : __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__()
						.value;
					_do(_typ.elem());
				} else if (Go.typeEquals((__type__ : Ref<Basic>))) {
					var _typ:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
						.value;
				} else if (Go.typeEquals((__type__ : Ref<Chan>))) {
					var _typ:Ref<Chan> = __type__ == null ? (null : Ref<Chan>) : __type__.__underlying__() == null ? (null : Ref<Chan>) : __type__ == null ? (null : Ref<Chan>) : __type__.__underlying__()
						.value;
					_do(_typ.elem());
				} else if (Go.typeEquals((__type__ : Ref<Map_>))) {
					var _typ:Ref<Map_> = __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__() == null ? (null : Ref<Map_>) : __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__()
						.value;
					_do(_typ.key());
					_do(_typ.elem());
				} else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
					var _typ:Ref<Pointer_> = __type__ == null ? (null : Ref<Pointer_>) : __type__.__underlying__() == null ? (null : Ref<Pointer_>) : __type__ == null ? (null : Ref<Pointer_>) : __type__.__underlying__()
						.value;
					_do(_typ.elem());
				} else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
					var _typ:Ref<Slice_> = __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__() == null ? (null : Ref<Slice_>) : __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__()
						.value;
					_do(_typ.elem());
				} else if (Go.typeEquals((__type__ : Ref<Interface>))) {
					var _typ:Ref<Interface> = __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__() == null ? (null : Ref<Interface>) : __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__()
						.value;
					{
						var _i:GoInt = (0 : GoInt);
						Go.cfor(_i < _typ.numMethods(), _i++, {
							_do(_typ.method(_i).type());
						});
					};
				} else if (Go.typeEquals((__type__ : Ref<Signature>))) {
					var _typ:Ref<Signature> = __type__ == null ? (null : Ref<Signature>) : __type__.__underlying__() == null ? (null : Ref<Signature>) : __type__ == null ? (null : Ref<Signature>) : __type__.__underlying__()
						.value;
					var _tuple = function(_tup:Ref<Tuple>):Void {
						{
							var _i:GoInt = (0 : GoInt);
							Go.cfor(_i < _tup.len(), _i++, {
								_do(_tup.at(_i).type());
							});
						};
					};
					_tuple(_typ.params());
					_tuple(_typ.results());
				} else if (Go.typeEquals((__type__ : Ref<Struct>))) {
					var _typ:Ref<Struct> = __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__() == null ? (null : Ref<Struct>) : __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__()
						.value;
					{
						var _i:GoInt = (0 : GoInt);
						Go.cfor(_i < _typ.numFields(), _i++, {
							_do(_typ.field(_i).type());
						});
					};
				} else {
					var _typ:Type = __type__ == null ? (null : Type) : cast __type__;
					throw Go.toInterface(("unexpected type" : GoString));
				};
			};
		};
		_do(_targ);
	}

	/**
		// recordInstance records that the given type parameters were
		// instantiated with the corresponding type arguments.
	**/
	@:keep
	static public function _recordInstance(_w:Ref<T_monoGraph>, _pkg:Ref<Package>, _pos:stdgo.go.token.Token.Pos, _tparams:Slice<Ref<TypeParam>>,
			_targs:Slice<Type>, _xlist:Slice<stdgo.go.ast.Ast.Expr>):Void {
		for (_i => _tpar in _tparams) {
			var _pos:stdgo.go.token.Token.Pos = _pos;
			if (_i < (_xlist.length)) {
				_pos = _xlist[(_i : GoInt)].pos();
			};
			_w._assign(_pkg, _pos, _tpar, _targs[(_i : GoInt)]);
		};
	}

	/**
		// recordCanon records that tpar is the canonical type parameter
		// corresponding to method type parameter mpar.
	**/
	@:keep
	static public function _recordCanon(_w:Ref<T_monoGraph>, _mpar:Ref<TypeParam>, _tpar:Ref<TypeParam>):Void {
		if (_w._canon == null) {
			_w._canon = (new GoObjectMap<Ref<TypeParam>,
				Ref<TypeParam>>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({
				get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("TypeParam", [], null, false,
					{get: () -> null})})
			},
				{get: () -> stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("TypeParam", [], null,
					false, {get: () -> null})})}))) : GoMap<Ref<TypeParam>, Ref<TypeParam>>);
		};
		_w._canon[_mpar] = _tpar;
	}
}

class Named_asInterface {
	/**
		// expandUnderlying substitutes type arguments in the underlying type n.orig,
		// returning the result. Returns Typ[Invalid] if there was an error.
	**/
	@:keep
	public function _expandUnderlying():Type
		return __self__.value._expandUnderlying();

	@:keep
	public function _lookupMethod(_pkg:Ref<Package>, _name:GoString, _foldCase:Bool):{var _0:GoInt; var _1:Ref<Func>;}
		return __self__.value._lookupMethod(_pkg, _name, _foldCase);

	@:keep
	public function _setUnderlying(_typ:Type):Void
		__self__.value._setUnderlying(_typ);

	/**
		// under returns the expanded underlying type of n0; possibly by following
		// forward chains of named types. If an underlying type is found, resolve
		// the chain by setting the underlying type for each defined type in the
		// chain before returning it. If no underlying type is found or a cycle
		// is detected, the result is Typ[Invalid]. If a cycle is detected and
		// n0.check != nil, the cycle is reported.
		//
		// This is necessary because the underlying type of named may be itself a
		// named type that is incomplete:
		//
		//	type (
		//		A B
		//		B *C
		//		C A
		//	)
		//
		// The type of C is the (named) type of A which is incomplete,
		// and which has as its underlying type the named type B.
	**/
	@:keep
	public function _under():Type
		return __self__.value._under();

	@:keep
	public function string():GoString
		return __self__.value.string();

	@:keep
	public function underlying():Type
		return __self__.value.underlying();

	/**
		// AddMethod adds method m unless it is already in the method list.
		// t must not have type arguments.
	**/
	@:keep
	public function addMethod(_m:Ref<Func>):Void
		__self__.value.addMethod(_m);

	/**
		// SetUnderlying sets the underlying type and marks t as complete.
		// t must not have type arguments.
	**/
	@:keep
	public function setUnderlying(_underlying:Type):Void
		__self__.value.setUnderlying(_underlying);

	/**
		// expandMethod substitutes type arguments in the i'th method for an
		// instantiated receiver.
	**/
	@:keep
	public function _expandMethod(_i:GoInt):Ref<Func>
		return __self__.value._expandMethod(_i);

	/**
		// Method returns the i'th method of named type t for 0 <= i < t.NumMethods().
		//
		// For an ordinary or instantiated type t, the receiver base type of this
		// method is the named type t. For an uninstantiated generic type t, each
		// method receiver is instantiated with its receiver type parameters.
	**/
	@:keep
	public function method(_i:GoInt):Ref<Func>
		return __self__.value.method(_i);

	/**
		// NumMethods returns the number of explicit methods defined for t.
	**/
	@:keep
	public function numMethods():GoInt
		return __self__.value.numMethods();

	/**
		// TypeArgs returns the type arguments used to instantiate the named type t.
	**/
	@:keep
	public function typeArgs():Ref<TypeList>
		return __self__.value.typeArgs();

	/**
		// SetTypeParams sets the type parameters of the named type t.
		// t must not have type arguments.
	**/
	@:keep
	public function setTypeParams(_tparams:Slice<Ref<TypeParam>>):Void
		__self__.value.setTypeParams(_tparams);

	/**
		// TypeParams returns the type parameters of the named type t, or nil.
		// The result is non-nil for an (originally) generic type even if it is instantiated.
	**/
	@:keep
	public function typeParams():Ref<TypeParamList>
		return __self__.value.typeParams();

	/**
		// Origin returns the generic type from which the named type t is
		// instantiated. If t is not an instantiated type, the result is t.
	**/
	@:keep
	public function origin():Ref<Named>
		return __self__.value.origin();

	/**
		// Obj returns the type name for the declaration defining the named type t. For
		// instantiated types, this is same as the type name of the origin type.
	**/
	@:keep
	public function obj():Ref<TypeName>
		return __self__.value.obj();

	@:keep
	public function _cleanup():Void
		__self__.value._cleanup();

	/**
		// setState atomically stores the given state for n.
		// Must only be called while holding n.mu.
	**/
	@:keep
	public function _setState(_state:T_namedState):Void
		__self__.value._setState(_state);

	/**
		// state atomically accesses the current state of the receiver.
	**/
	@:keep
	public function _state():T_namedState
		return __self__.value._state();

	/**
		// resolve resolves the type parameters, methods, and underlying type of n.
		// This information may be loaded from a provided loader function, or computed
		// from an origin type (in the case of instances).
		//
		// After resolution, the type parameters, methods, and underlying type of n are
		// accessible; but if n is an instantiated type, its methods may still be
		// unexpanded.
	**/
	@:keep
	public function _resolve():Ref<Named>
		return __self__.value._resolve();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Named>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Named_asInterface) class Named_static_extension {
	/**
		// expandUnderlying substitutes type arguments in the underlying type n.orig,
		// returning the result. Returns Typ[Invalid] if there was an error.
	**/
	@:keep
	static public function _expandUnderlying(_n:Ref<Named>):Type {
		var __deferstack__:Array<Void->Void> = [];
		var _check = _n._check;
		if ((_check != null) && false) {
			_check._trace(_n._obj._object._pos, ("-- Named.expandUnderlying %s" : GoString), Go.toInterface(Go.asInterface(_n)));
			_check._indent++;
			__deferstack__.unshift(() -> {
				var a = function():Void {
					_check._indent--;
					_check._trace(_n._obj._object._pos, ("=> %s (tparams = %s, under = %s)" : GoString), Go.toInterface(Go.asInterface(_n)),
						Go.toInterface(_n._tparams._list()), Go.toInterface(_n._underlying));
				};
				a();
			});
		};
		try {
			_assert(_n._inst._orig._underlying != null);
			if (_n._inst._ctxt == null) {
				_n._inst._ctxt = newContext();
			};
			var _orig = _n._inst._orig;
			var _targs = _n._inst._targs;
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_orig._underlying) : Ref<Named>)) : Ref<Named>), ok: true};
				} catch (_) {
					{value: (null : Ref<Named>), ok: false};
				}, _20 = __tmp__.value, _unexpanded = __tmp__.ok;
				if (_unexpanded) {
					_assert(_check != null);
				};
			};
			if (_orig._tparams.len() != (_targs.len())) {
				{
					for (defer in __deferstack__) {
						defer();
					};
					return Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
				};
			};
			var _h:GoString = _n._inst._ctxt._instanceHash(Go.asInterface(_orig), _targs._list());
			var _n2:Type = _n._inst._ctxt._update(_h, Go.asInterface(_orig), _n.typeArgs()._list(), Go.asInterface(_n));
			_assert(Go.toInterface(Go.asInterface(_n)) == (Go.toInterface(_n2)));
			var _smap:T_substMap = _makeSubstMap(_orig._tparams._list(), _targs._list());
			var _ctxt:Ref<Context> = (null : Ref<Context>);
			if (_check != null) {
				_ctxt = _check._context();
			};
			var _underlying:Type = _n._check._subst(_n._obj._object._pos, _orig._underlying, _smap, _n, _ctxt);
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_underlying) : Ref<Interface>)) : Ref<Interface>), ok: true};
				} catch (_) {
					{value: (null : Ref<Interface>), ok: false};
				}, _iface = __tmp__.value, _35 = __tmp__.ok;
				if (_iface != null) {
					{
						var __tmp__ = _replaceRecvType(_iface._methods, Go.asInterface(_orig), Go.asInterface(_n)),
							_methods:Slice<Ref<Func>> = __tmp__._0,
							_copied:Bool = __tmp__._1;
						if (_copied) {
							if (Go.toInterface(Go.asInterface(_iface)) == (Go.toInterface(_orig._underlying))) {
								var _old = _iface;
								_iface = _check._newInterface();
								_iface._embeddeds = _old._embeddeds;
								_iface._complete = _old._complete;
								_iface._implicit = _old._implicit;
								_underlying = Go.asInterface(_iface);
							};
							_iface._methods = _methods;
						};
					};
				};
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				return _underlying;
			};
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return (null : Type);
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return (null : Type);
		};
	}

	@:keep
	static public function _lookupMethod(_n:Ref<Named>, _pkg:Ref<Package>, _name:GoString, _foldCase:Bool):{var _0:GoInt; var _1:Ref<Func>;} {
		_n._resolve();
		var __tmp__ = stdgo.go.types.Types._lookupMethod(_n.origin()._methods, _pkg, _name, _foldCase),
			_i:GoInt = __tmp__._0,
			_2:Ref<Func> = __tmp__._1;
		if (_i < (0:GoInt)) {
			return {_0: (-1 : GoInt), _1: null};
		};
		return {_0: _i, _1: _n.method(_i)};
	}

	@:keep
	static public function _setUnderlying(_n:Ref<Named>, _typ:Type):Void {
		if (_n != null) {
			_n._underlying = _typ;
		};
	}

	/**
		// under returns the expanded underlying type of n0; possibly by following
		// forward chains of named types. If an underlying type is found, resolve
		// the chain by setting the underlying type for each defined type in the
		// chain before returning it. If no underlying type is found or a cycle
		// is detected, the result is Typ[Invalid]. If a cycle is detected and
		// n0.check != nil, the cycle is reported.
		//
		// This is necessary because the underlying type of named may be itself a
		// named type that is incomplete:
		//
		//	type (
		//		A B
		//		B *C
		//		C A
		//	)
		//
		// The type of C is the (named) type of A which is incomplete,
		// and which has as its underlying type the named type B.
	**/
	@:keep
	static public function _under(_n0:Ref<Named>):Type {
		return stdgo.internal.Macro.controlFlow({
			var _u:Type = _n0.underlying();
			var _n1:Ref<Named> = (null : Ref<Named>);
			{
				final __type__ = _u;
				if (__type__ == null) {
					var _u1:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
					throw Go.toInterface(("nil underlying" : GoString));
				} else if (Go.typeEquals((__type__ : Ref<Named>))) {
					var _u1:Ref<Named> = __type__ == null ? (null : Ref<Named>) : __type__.__underlying__() == null ? (null : Ref<Named>) : __type__ == null ? (null : Ref<Named>) : __type__.__underlying__()
						.value;
					_n1 = _u1;
				} else {
					var _u1:Type = __type__ == null ? (null : Type) : cast __type__;
					return _u;
				};
			};
			if (_n0._check == null) {
				throw Go.toInterface(("Named.check == nil but type is incomplete" : GoString));
			};
			var _check = _n0._check;
			var _n = _n0;
			var _seen = (new GoObjectMap<Ref<Named>, GoInt>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
				stdgo.internal.reflect.Reflect.GoType.refType({get: () -> stdgo.internal.reflect.Reflect.GoType.named("Named", [], null, false, {get: () ->
					null})})},
				{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(int_kind)}))) : GoMap<Ref<Named>, GoInt>);
			var _path:Slice<Object> = (null : Slice<Object>);
			@:label("loop") while (true) {
				_seen[_n] = (_seen.length);
				_path = _path.__appendref__(Go.asInterface(_n._obj));
				_n = _n1;
				{
					var __tmp__ = (_seen != null && _seen.__exists__(_n) ? {value: _seen[_n], ok: true} : {value: (0 : GoInt), ok: false}),
						_i:GoInt = __tmp__.value,
						_ok:Bool = __tmp__.ok;
					if (_ok) {
						_check._cycleError((_path.__slice__(_i) : Slice<Object>));
						_u = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
						break;
					};
				};
				_u = _n.underlying();
				{
					final __type__ = _u;
					{
						var __bool__ = true;
						while (__bool__) {
							__bool__ = false;
							if (__type__ == null) {
								var _u1:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
								_u = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
								@:jump("loop") break;
							} else if (Go.typeEquals((__type__ : Ref<Named>))) {
								var _u1:Ref<Named> = __type__ == null ? (null : Ref<Named>) : __type__.__underlying__() == null ? (null : Ref<Named>) : __type__ == null ? (null : Ref<Named>) : __type__.__underlying__()
									.value;
								_n1 = _u1;
							} else {
								var _u1:Type = __type__ == null ? (null : Type) : cast __type__;
								@:jump("loop") break;
							};
							break;
						};
					};
				};
			};
			for (_n => _ in _seen) {
				if (_n._obj._object._pkg != (_check._pkg)) {
					throw Go.toInterface(("imported type with unresolved underlying type" : GoString));
				};
				_n._underlying = _u;
			};
			return _u;
		});
	}

	@:keep
	static public function string(_t:Ref<Named>):GoString {
		return typeString(Go.asInterface(_t), null);
	}

	@:keep
	static public function underlying(_t:Ref<Named>):Type {
		return _t._resolve()._underlying;
	}

	/**
		// AddMethod adds method m unless it is already in the method list.
		// t must not have type arguments.
	**/
	@:keep
	static public function addMethod(_t:Ref<Named>, _m:Ref<Func>):Void {
		_assert(_t._inst == null);
		_t._resolve();
		{
			var __tmp__ = stdgo.go.types.Types._lookupMethod(_t._methods, _m._object._pkg, _m._object._name, false),
				_i:GoInt = __tmp__._0,
				_4:Ref<Func> = __tmp__._1;
			if (_i < (0:GoInt)) {
				_t._methods = _t._methods.__appendref__(_m);
			};
		};
	}

	/**
		// SetUnderlying sets the underlying type and marks t as complete.
		// t must not have type arguments.
	**/
	@:keep
	static public function setUnderlying(_t:Ref<Named>, _underlying:Type):Void {
		_assert(_t._inst == null);
		if (_underlying == null) {
			throw Go.toInterface(("underlying type must not be nil" : GoString));
		};
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_underlying) : Ref<Named>)) : Ref<Named>), ok: true};
			} catch (_) {
				{value: (null : Ref<Named>), ok: false};
			}, _2 = __tmp__.value, _ok = __tmp__.ok;
			if (_ok) {
				throw Go.toInterface(("underlying type must not be *Named" : GoString));
			};
		};
		_t._resolve()._underlying = _underlying;
		if (_t._fromRHS == null) {
			_t._fromRHS = _underlying;
		};
	}

	/**
		// expandMethod substitutes type arguments in the i'th method for an
		// instantiated receiver.
	**/
	@:keep
	static public function _expandMethod(_t:Ref<Named>, _i:GoInt):Ref<Func> {
		var _origm = _t._inst._orig.method(_i);
		_assert(_origm != null);
		var _check = _t._check;
		if (_check != null) {
			_check._objDecl(Go.asInterface(_origm), null);
		};
		var _origSig = (Go.typeAssert((Go.toInterface(_origm._object._typ) : Ref<Signature>)) : Ref<Signature>);
		var __tmp__ = _deref(_origSig.recv().type()),
			_rbase:Type = __tmp__._0,
			_4:Bool = __tmp__._1;
		if (Go.toInterface(_rbase) == (Go.toInterface(Go.asInterface(_t)))) {
			return _origm;
		};
		var _sig = _origSig;
		if (_origSig.recvTypeParams().len() == (_t._inst._targs.len())) {
			var _smap:T_substMap = _makeSubstMap(_origSig.recvTypeParams()._list(), _t._inst._targs._list());
			var _ctxt:Ref<Context> = (null : Ref<Context>);
			if (_check != null) {
				_ctxt = _check._context();
			};
			_sig = (Go.typeAssert((Go.toInterface(_check._subst(_origm._object._pos, Go.asInterface(_origSig), _smap, _t,
				_ctxt)) : Ref<Signature>)) : Ref<Signature>);
		};
		if (_sig == (_origSig)) {
			var _copy:Signature = (_origSig == null ? null : _origSig.__copy__());
			_sig = (_copy : Ref<Signature>);
		};
		var _rtyp:Type = (null : Type);
		if (_origm._hasPtrRecv()) {
			_rtyp = Go.asInterface(newPointer(Go.asInterface(_t)));
		} else {
			_rtyp = Go.asInterface(_t);
		};
		_sig._recv = _substVar(_origSig._recv, _rtyp);
		return _substFunc(_origm, Go.asInterface(_sig));
	}

	/**
		// Method returns the i'th method of named type t for 0 <= i < t.NumMethods().
		//
		// For an ordinary or instantiated type t, the receiver base type of this
		// method is the named type t. For an uninstantiated generic type t, each
		// method receiver is instantiated with its receiver type parameters.
	**/
	@:keep
	static public function method(_t:Ref<Named>, _i:GoInt):Ref<Func> {
		var __deferstack__:Array<Void->Void> = [];
		_t._resolve();
		if (_t._state() >= (("2" : GoUInt32) : T_namedState)) {
			return _t._methods[(_i : GoInt)];
		};
		try {
			_assert(_t._inst != null);
			var _orig = _t._inst._orig;
			_t._mu.lock();
			__deferstack__.unshift(() -> _t._mu.unlock());
			if ((_t._methods.length) != ((_orig._methods.length))) {
				_assert((_t._methods.length) == ((0 : GoInt)));
				_t._methods = new Slice<Ref<Func>>((_orig._methods.length : GoInt).toBasic(), 0,
					...[for (i in 0...(_orig._methods.length : GoInt).toBasic()) (null : Ref<Func>)]);
			};
			if (_t._methods[(_i : GoInt)] == null) {
				_assert(_t._inst._ctxt != null);
				_t._methods[(_i : GoInt)] = _t._expandMethod(_i);
				_t._inst._expandedMethods++;
				if (_t._inst._expandedMethods == ((_orig._methods.length))) {
					_t._setState((("2" : GoUInt32) : T_namedState));
					_t._inst._ctxt = null;
				};
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				return _t._methods[(_i : GoInt)];
			};
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return (null : Ref<Func>);
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return (null : Ref<Func>);
		};
	}

	/**
		// NumMethods returns the number of explicit methods defined for t.
	**/
	@:keep
	static public function numMethods(_t:Ref<Named>):GoInt {
		return (_t.origin()._resolve()._methods.length);
	}

	/**
		// TypeArgs returns the type arguments used to instantiate the named type t.
	**/
	@:keep
	static public function typeArgs(_t:Ref<Named>):Ref<TypeList> {
		if (_t._inst == null) {
			return null;
		};
		return _t._inst._targs;
	}

	/**
		// SetTypeParams sets the type parameters of the named type t.
		// t must not have type arguments.
	**/
	@:keep
	static public function setTypeParams(_t:Ref<Named>, _tparams:Slice<Ref<TypeParam>>):Void {
		_assert(_t._inst == null);
		_t._resolve()._tparams = _bindTParams(_tparams);
	}

	/**
		// TypeParams returns the type parameters of the named type t, or nil.
		// The result is non-nil for an (originally) generic type even if it is instantiated.
	**/
	@:keep
	static public function typeParams(_t:Ref<Named>):Ref<TypeParamList> {
		return _t._resolve()._tparams;
	}

	/**
		// Origin returns the generic type from which the named type t is
		// instantiated. If t is not an instantiated type, the result is t.
	**/
	@:keep
	static public function origin(_t:Ref<Named>):Ref<Named> {
		if (_t._inst == null) {
			return _t;
		};
		return _t._inst._orig;
	}

	/**
		// Obj returns the type name for the declaration defining the named type t. For
		// instantiated types, this is same as the type name of the origin type.
	**/
	@:keep
	static public function obj(_t:Ref<Named>):Ref<TypeName> {
		if (_t._inst == null) {
			return _t._obj;
		};
		return _t._inst._orig._obj;
	}

	@:keep
	static public function _cleanup(_t:Ref<Named>):Void {
		_assert((_t._inst == null) || (_t._inst._orig._inst == null));
		{
			final __type__ = _t._underlying;
			if (__type__ == null) {
				if (_t.typeArgs().len() == ((0 : GoInt))) {
					throw Go.toInterface(("nil underlying" : GoString));
				};
			} else if (Go.typeEquals((__type__ : Ref<Named>))) {
				_t._under();
			};
		};
		_t._check = null;
	}

	/**
		// setState atomically stores the given state for n.
		// Must only be called while holding n.mu.
	**/
	@:keep
	static public function _setState(_n:Ref<Named>, _state:T_namedState):Void {
		stdgo.sync.atomic.Atomic.storeUint32(Go.pointer(_n._state_), (_state : GoUInt32));
	}

	/**
		// state atomically accesses the current state of the receiver.
	**/
	@:keep
	static public function _state(_n:Ref<Named>):T_namedState {
		return (stdgo.sync.atomic.Atomic.loadUint32(Go.pointer(_n._state_)) : T_namedState);
	}

	/**
		// resolve resolves the type parameters, methods, and underlying type of n.
		// This information may be loaded from a provided loader function, or computed
		// from an origin type (in the case of instances).
		//
		// After resolution, the type parameters, methods, and underlying type of n are
		// accessible; but if n is an instantiated type, its methods may still be
		// unexpanded.
	**/
	@:keep
	static public function _resolve(_n:Ref<Named>):Ref<Named> {
		var __deferstack__:Array<Void->Void> = [];
		if (_n._state() >= (("1" : GoUInt32) : T_namedState)) {
			return _n;
		};
		_n._mu.lock();
		try {
			__deferstack__.unshift(() -> _n._mu.unlock());
			if (_n._state() >= (("1" : GoUInt32) : T_namedState)) {
				{
					for (defer in __deferstack__) {
						defer();
					};
					return _n;
				};
			};
			if (_n._inst != null) {
				_assert(_n._underlying == null);
				_assert(_n._loader == null);
				var _orig = _n._inst._orig;
				_orig._resolve();
				var _underlying:Type = _n._expandUnderlying();
				_n._tparams = _orig._tparams;
				_n._underlying = _underlying;
				_n._fromRHS = _orig._fromRHS;
				if ((_orig._methods.length) == ((0 : GoInt))) {
					_n._setState((("2" : GoUInt32) : T_namedState));
					_n._inst._ctxt = null;
				} else {
					_n._setState((("1" : GoUInt32) : T_namedState));
				};
				{
					for (defer in __deferstack__) {
						defer();
					};
					return _n;
				};
			};
			if (_n._loader != null) {
				_assert(_n._underlying == null);
				_assert(_n.typeArgs().len() == ((0 : GoInt)));
				var __tmp__ = _n._loader(_n),
					_tparams:Slice<Ref<TypeParam>> = __tmp__._0,
					_underlying:Type = __tmp__._1,
					_methods:Slice<Ref<Func>> = __tmp__._2;
				_n._tparams = _bindTParams(_tparams);
				_n._underlying = _underlying;
				_n._fromRHS = _underlying;
				_n._methods = _methods;
				_n._loader = null;
			};
			_n._setState((("2" : GoUInt32) : T_namedState));
			{
				for (defer in __deferstack__) {
					defer();
				};
				return _n;
			};
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return (null : Ref<Named>);
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return (null : Ref<Named>);
		};
	}
}

class T_object_asInterface {
	@:keep
	public function _sameId(_pkg:Ref<Package>, _name:GoString):Bool
		return __self__.value._sameId(_pkg, _name);

	@:keep
	public function _setScopePos(_pos:stdgo.go.token.Token.Pos):Void
		__self__.value._setScopePos(_pos);

	@:keep
	public function _setColor(_color:T_color):Void
		__self__.value._setColor(_color);

	@:keep
	public function _setOrder(_order:GoUInt32):Void
		__self__.value._setOrder(_order);

	@:keep
	public function _setType(_typ:Type):Void
		__self__.value._setType(_typ);

	@:keep
	public function _setParent(_parent:Ref<Scope>):Void
		__self__.value._setParent(_parent);

	@:keep
	public function _scopePos():stdgo.go.token.Token.Pos
		return __self__.value._scopePos();

	@:keep
	public function _color():T_color
		return __self__.value._color();

	@:keep
	public function _order():GoUInt32
		return __self__.value._order();

	@:keep
	public function string():GoString
		return __self__.value.string();

	/**
		// Id is a wrapper for Id(obj.Pkg(), obj.Name()).
	**/
	@:keep
	public function id():GoString
		return __self__.value.id();

	/**
		// Exported reports whether the object is exported (starts with a capital letter).
		// It doesn't take into account whether the object is in a local (function) scope
		// or not.
	**/
	@:keep
	public function exported():Bool
		return __self__.value.exported();

	/**
		// Type returns the object's type.
	**/
	@:keep
	public function type():Type
		return __self__.value.type();

	/**
		// Name returns the object's (package-local, unqualified) name.
	**/
	@:keep
	public function name():GoString
		return __self__.value.name();

	/**
		// Pkg returns the package to which the object belongs.
		// The result is nil for labels and objects in the Universe scope.
	**/
	@:keep
	public function pkg():Ref<Package>
		return __self__.value.pkg();

	/**
		// Pos returns the declaration position of the object's identifier.
	**/
	@:keep
	public function pos():stdgo.go.token.Token.Pos
		return __self__.value.pos();

	/**
		// Parent returns the scope in which the object is declared.
		// The result is nil for methods and struct fields.
	**/
	@:keep
	public function parent():Ref<Scope>
		return __self__.value.parent();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_object>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_object_asInterface) class T_object_static_extension {
	@:keep
	static public function _sameId(_obj:Ref<T_object>, _pkg:Ref<Package>, _name:GoString):Bool {
		if (_name != (_obj._name)) {
			return false;
		};
		if (_obj.exported()) {
			return true;
		};
		if ((_pkg == null) || (_obj._pkg == null)) {
			return _pkg == (_obj._pkg);
		};
		return _pkg._path == (_obj._pkg._path);
	}

	@:keep
	static public function _setScopePos(_obj:Ref<T_object>, _pos:stdgo.go.token.Token.Pos):Void {
		_obj._scopePos_ = _pos;
	}

	@:keep
	static public function _setColor(_obj:Ref<T_object>, _color:T_color):Void {
		_assert(_color != ((("0" : GoUInt32) : T_color)));
		_obj._color_ = _color;
	}

	@:keep
	static public function _setOrder(_obj:Ref<T_object>, _order:GoUInt32):Void {
		_assert(_order > ("0" : GoUInt32));
		_obj._order_ = _order;
	}

	@:keep
	static public function _setType(_obj:Ref<T_object>, _typ:Type):Void {
		_obj._typ = _typ;
	}

	@:keep
	static public function _setParent(_obj:Ref<T_object>, _parent:Ref<Scope>):Void {
		_obj._parent = _parent;
	}

	@:keep
	static public function _scopePos(_obj:Ref<T_object>):stdgo.go.token.Token.Pos {
		return _obj._scopePos_;
	}

	@:keep
	static public function _color(_obj:Ref<T_object>):T_color {
		return _obj._color_;
	}

	@:keep
	static public function _order(_obj:Ref<T_object>):GoUInt32 {
		return _obj._order_;
	}

	@:keep
	static public function string(_obj:Ref<T_object>):GoString {
		throw Go.toInterface(("abstract" : GoString));
	}

	/**
		// Id is a wrapper for Id(obj.Pkg(), obj.Name()).
	**/
	@:keep
	static public function id(_obj:Ref<T_object>):GoString {
		return stdgo.go.types.Types.id(_obj._pkg, _obj._name);
	}

	/**
		// Exported reports whether the object is exported (starts with a capital letter).
		// It doesn't take into account whether the object is in a local (function) scope
		// or not.
	**/
	@:keep
	static public function exported(_obj:Ref<T_object>):Bool {
		return stdgo.go.token.Token.isExported(_obj._name);
	}

	/**
		// Type returns the object's type.
	**/
	@:keep
	static public function type(_obj:Ref<T_object>):Type {
		return _obj._typ;
	}

	/**
		// Name returns the object's (package-local, unqualified) name.
	**/
	@:keep
	static public function name(_obj:Ref<T_object>):GoString {
		return _obj._name;
	}

	/**
		// Pkg returns the package to which the object belongs.
		// The result is nil for labels and objects in the Universe scope.
	**/
	@:keep
	static public function pkg(_obj:Ref<T_object>):Ref<Package> {
		return _obj._pkg;
	}

	/**
		// Pos returns the declaration position of the object's identifier.
	**/
	@:keep
	static public function pos(_obj:Ref<T_object>):stdgo.go.token.Token.Pos {
		return _obj._pos;
	}

	/**
		// Parent returns the scope in which the object is declared.
		// The result is nil for methods and struct fields.
	**/
	@:keep
	static public function parent(_obj:Ref<T_object>):Ref<Scope> {
		return _obj._parent;
	}
}

class PkgName_asInterface {
	@:keep
	public function string():GoString
		return __self__.value.string();

	/**
		// Imported returns the package that was imported.
		// It is distinct from Pkg(), which is the package containing the import statement.
	**/
	@:keep
	public function imported():Ref<Package>
		return __self__.value.imported();

	@:embedded
	public function _setType(__0:Type):Void
		__self__.value._setType(__0);

	@:embedded
	public function _setScopePos(_p:stdgo.go.token.Token.Pos):Void
		__self__.value._setScopePos(_p);

	@:embedded
	public function _setParent(__0:Ref<Scope>):Void
		__self__.value._setParent(__0);

	@:embedded
	public function _setOrder(__0:GoUInt32):Void
		__self__.value._setOrder(__0);

	@:embedded
	public function _setColor(__0:T_color):Void
		__self__.value._setColor(__0);

	@:embedded
	public function _scopePos():stdgo.go.token.Token.Pos
		return __self__.value._scopePos();

	@:embedded
	public function _sameId(_pkg_:Ref<Package>, _name_:GoString):Bool
		return __self__.value._sameId(_pkg_, _name_);

	@:embedded
	public function _order():GoUInt32
		return __self__.value._order();

	@:embedded
	public function _color():T_color
		return __self__.value._color();

	@:embedded
	public function type():Type
		return __self__.value.type();

	@:embedded
	public function pos():stdgo.go.token.Token.Pos
		return __self__.value.pos();

	@:embedded
	public function pkg():Ref<Package>
		return __self__.value.pkg();

	@:embedded
	public function parent():Ref<Scope>
		return __self__.value.parent();

	@:embedded
	public function name():GoString
		return __self__.value.name();

	@:embedded
	public function id():GoString
		return __self__.value.id();

	@:embedded
	public function exported():Bool
		return __self__.value.exported();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<PkgName>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.PkgName_asInterface) class PkgName_static_extension {
	@:keep
	static public function string(_obj:Ref<PkgName>):GoString {
		return objectString(Go.asInterface(_obj), null);
	}

	/**
		// Imported returns the package that was imported.
		// It is distinct from Pkg(), which is the package containing the import statement.
	**/
	@:keep
	static public function imported(_obj:Ref<PkgName>):Ref<Package> {
		return _obj._imported;
	}

	@:embedded
	public static function _setType(__self__:PkgName, __0:Type)
		__self__._setType(__0);

	@:embedded
	public static function _setScopePos(__self__:PkgName, _p:stdgo.go.token.Token.Pos)
		__self__._setScopePos(_p);

	@:embedded
	public static function _setParent(__self__:PkgName, __0:Ref<Scope>)
		__self__._setParent(__0);

	@:embedded
	public static function _setOrder(__self__:PkgName, __0:GoUInt32)
		__self__._setOrder(__0);

	@:embedded
	public static function _setColor(__self__:PkgName, __0:T_color)
		__self__._setColor(__0);

	@:embedded
	public static function _scopePos(__self__:PkgName):stdgo.go.token.Token.Pos
		return __self__._scopePos();

	@:embedded
	public static function _sameId(__self__:PkgName, _pkg_:Ref<Package>, _name_:GoString):Bool
		return __self__._sameId(_pkg_, _name_);

	@:embedded
	public static function _order(__self__:PkgName):GoUInt32
		return __self__._order();

	@:embedded
	public static function _color(__self__:PkgName):T_color
		return __self__._color();

	@:embedded
	public static function type(__self__:PkgName):Type
		return __self__.type();

	@:embedded
	public static function pos(__self__:PkgName):stdgo.go.token.Token.Pos
		return __self__.pos();

	@:embedded
	public static function pkg(__self__:PkgName):Ref<Package>
		return __self__.pkg();

	@:embedded
	public static function parent(__self__:PkgName):Ref<Scope>
		return __self__.parent();

	@:embedded
	public static function name(__self__:PkgName):GoString
		return __self__.name();

	@:embedded
	public static function id(__self__:PkgName):GoString
		return __self__.id();

	@:embedded
	public static function exported(__self__:PkgName):Bool
		return __self__.exported();
}

class Const_asInterface {
	@:keep
	public function string():GoString
		return __self__.value.string();

	@:keep
	public function _isDependency():Void
		__self__.value._isDependency();

	/**
		// Val returns the constant's value.
	**/
	@:keep
	public function val():stdgo.go.constant.Constant.Value
		return __self__.value.val();

	@:embedded
	public function _setType(__0:Type):Void
		__self__.value._setType(__0);

	@:embedded
	public function _setScopePos(_p:stdgo.go.token.Token.Pos):Void
		__self__.value._setScopePos(_p);

	@:embedded
	public function _setParent(__0:Ref<Scope>):Void
		__self__.value._setParent(__0);

	@:embedded
	public function _setOrder(__0:GoUInt32):Void
		__self__.value._setOrder(__0);

	@:embedded
	public function _setColor(__0:T_color):Void
		__self__.value._setColor(__0);

	@:embedded
	public function _scopePos():stdgo.go.token.Token.Pos
		return __self__.value._scopePos();

	@:embedded
	public function _sameId(_pkg_:Ref<Package>, _name_:GoString):Bool
		return __self__.value._sameId(_pkg_, _name_);

	@:embedded
	public function _order():GoUInt32
		return __self__.value._order();

	@:embedded
	public function _color():T_color
		return __self__.value._color();

	@:embedded
	public function type():Type
		return __self__.value.type();

	@:embedded
	public function pos():stdgo.go.token.Token.Pos
		return __self__.value.pos();

	@:embedded
	public function pkg():Ref<Package>
		return __self__.value.pkg();

	@:embedded
	public function parent():Ref<Scope>
		return __self__.value.parent();

	@:embedded
	public function name():GoString
		return __self__.value.name();

	@:embedded
	public function id():GoString
		return __self__.value.id();

	@:embedded
	public function exported():Bool
		return __self__.value.exported();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Const>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Const_asInterface) class Const_static_extension {
	@:keep
	static public function string(_obj:Ref<Const>):GoString {
		return objectString(Go.asInterface(_obj), null);
	}

	@:keep
	static public function _isDependency(_:Ref<Const>):Void {}

	/**
		// Val returns the constant's value.
	**/
	@:keep
	static public function val(_obj:Ref<Const>):stdgo.go.constant.Constant.Value {
		return _obj._val;
	}

	@:embedded
	public static function _setType(__self__:Const, __0:Type)
		__self__._setType(__0);

	@:embedded
	public static function _setScopePos(__self__:Const, _p:stdgo.go.token.Token.Pos)
		__self__._setScopePos(_p);

	@:embedded
	public static function _setParent(__self__:Const, __0:Ref<Scope>)
		__self__._setParent(__0);

	@:embedded
	public static function _setOrder(__self__:Const, __0:GoUInt32)
		__self__._setOrder(__0);

	@:embedded
	public static function _setColor(__self__:Const, __0:T_color)
		__self__._setColor(__0);

	@:embedded
	public static function _scopePos(__self__:Const):stdgo.go.token.Token.Pos
		return __self__._scopePos();

	@:embedded
	public static function _sameId(__self__:Const, _pkg_:Ref<Package>, _name_:GoString):Bool
		return __self__._sameId(_pkg_, _name_);

	@:embedded
	public static function _order(__self__:Const):GoUInt32
		return __self__._order();

	@:embedded
	public static function _color(__self__:Const):T_color
		return __self__._color();

	@:embedded
	public static function type(__self__:Const):Type
		return __self__.type();

	@:embedded
	public static function pos(__self__:Const):stdgo.go.token.Token.Pos
		return __self__.pos();

	@:embedded
	public static function pkg(__self__:Const):Ref<Package>
		return __self__.pkg();

	@:embedded
	public static function parent(__self__:Const):Ref<Scope>
		return __self__.parent();

	@:embedded
	public static function name(__self__:Const):GoString
		return __self__.name();

	@:embedded
	public static function id(__self__:Const):GoString
		return __self__.id();

	@:embedded
	public static function exported(__self__:Const):Bool
		return __self__.exported();
}

class TypeName_asInterface {
	@:keep
	public function string():GoString
		return __self__.value.string();

	/**
		// IsAlias reports whether obj is an alias name for a type.
	**/
	@:keep
	public function isAlias():Bool
		return __self__.value.isAlias();

	@:embedded
	public function _setType(__0:Type):Void
		__self__.value._setType(__0);

	@:embedded
	public function _setScopePos(_p:stdgo.go.token.Token.Pos):Void
		__self__.value._setScopePos(_p);

	@:embedded
	public function _setParent(__0:Ref<Scope>):Void
		__self__.value._setParent(__0);

	@:embedded
	public function _setOrder(__0:GoUInt32):Void
		__self__.value._setOrder(__0);

	@:embedded
	public function _setColor(__0:T_color):Void
		__self__.value._setColor(__0);

	@:embedded
	public function _scopePos():stdgo.go.token.Token.Pos
		return __self__.value._scopePos();

	@:embedded
	public function _sameId(_pkg_:Ref<Package>, _name_:GoString):Bool
		return __self__.value._sameId(_pkg_, _name_);

	@:embedded
	public function _order():GoUInt32
		return __self__.value._order();

	@:embedded
	public function _color():T_color
		return __self__.value._color();

	@:embedded
	public function type():Type
		return __self__.value.type();

	@:embedded
	public function pos():stdgo.go.token.Token.Pos
		return __self__.value.pos();

	@:embedded
	public function pkg():Ref<Package>
		return __self__.value.pkg();

	@:embedded
	public function parent():Ref<Scope>
		return __self__.value.parent();

	@:embedded
	public function name():GoString
		return __self__.value.name();

	@:embedded
	public function id():GoString
		return __self__.value.id();

	@:embedded
	public function exported():Bool
		return __self__.value.exported();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<TypeName>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.TypeName_asInterface) class TypeName_static_extension {
	@:keep
	static public function string(_obj:Ref<TypeName>):GoString {
		return objectString(Go.asInterface(_obj), null);
	}

	/**
		// IsAlias reports whether obj is an alias name for a type.
	**/
	@:keep
	static public function isAlias(_obj:Ref<TypeName>):Bool {
		{
			final __type__ = _obj._object._typ;
			if (__type__ == null) {
				var _t:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
				return false;
			} else if (Go.typeEquals((__type__ : Ref<Basic>))) {
				var _t:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
					.value;
				if (_obj._object._pkg == (unsafe)) {
					return false;
				};
				return (((_obj._object._pkg != null) || (_t._name != _obj._object._name))
					|| (Go.toInterface(Go.asInterface(_t)) == Go.toInterface(_universeByte)))
					|| (Go.toInterface(Go.asInterface(_t)) == Go.toInterface(_universeRune));
			} else if (Go.typeEquals((__type__ : Ref<Named>))) {
				var _t:Ref<Named> = __type__ == null ? (null : Ref<Named>) : __type__.__underlying__() == null ? (null : Ref<Named>) : __type__ == null ? (null : Ref<Named>) : __type__.__underlying__()
					.value;
				return _obj != (_t._obj);
			} else if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
				var _t:Ref<TypeParam> = __type__ == null ? (null : Ref<TypeParam>) : __type__.__underlying__() == null ? (null : Ref<TypeParam>) : __type__ == null ? (null : Ref<TypeParam>) : __type__.__underlying__()
					.value;
				return _obj != (_t._obj);
			} else {
				var _t:Type = __type__ == null ? (null : Type) : cast __type__;
				return true;
			};
		};
	}

	@:embedded
	public static function _setType(__self__:TypeName, __0:Type)
		__self__._setType(__0);

	@:embedded
	public static function _setScopePos(__self__:TypeName, _p:stdgo.go.token.Token.Pos)
		__self__._setScopePos(_p);

	@:embedded
	public static function _setParent(__self__:TypeName, __0:Ref<Scope>)
		__self__._setParent(__0);

	@:embedded
	public static function _setOrder(__self__:TypeName, __0:GoUInt32)
		__self__._setOrder(__0);

	@:embedded
	public static function _setColor(__self__:TypeName, __0:T_color)
		__self__._setColor(__0);

	@:embedded
	public static function _scopePos(__self__:TypeName):stdgo.go.token.Token.Pos
		return __self__._scopePos();

	@:embedded
	public static function _sameId(__self__:TypeName, _pkg_:Ref<Package>, _name_:GoString):Bool
		return __self__._sameId(_pkg_, _name_);

	@:embedded
	public static function _order(__self__:TypeName):GoUInt32
		return __self__._order();

	@:embedded
	public static function _color(__self__:TypeName):T_color
		return __self__._color();

	@:embedded
	public static function type(__self__:TypeName):Type
		return __self__.type();

	@:embedded
	public static function pos(__self__:TypeName):stdgo.go.token.Token.Pos
		return __self__.pos();

	@:embedded
	public static function pkg(__self__:TypeName):Ref<Package>
		return __self__.pkg();

	@:embedded
	public static function parent(__self__:TypeName):Ref<Scope>
		return __self__.parent();

	@:embedded
	public static function name(__self__:TypeName):GoString
		return __self__.name();

	@:embedded
	public static function id(__self__:TypeName):GoString
		return __self__.id();

	@:embedded
	public static function exported(__self__:TypeName):Bool
		return __self__.exported();
}

class Var_asInterface {
	@:keep
	public function string():GoString
		return __self__.value.string();

	@:keep
	public function _isDependency():Void
		__self__.value._isDependency();

	/**
		// Origin returns the canonical Var for its receiver, i.e. the Var object
		// recorded in Info.Defs.
		//
		// For synthetic Vars created during instantiation (such as struct fields or
		// function parameters that depend on type arguments), this will be the
		// corresponding Var on the generic (uninstantiated) type. For all other Vars
		// Origin returns the receiver.
	**/
	@:keep
	public function origin():Ref<Var>
		return __self__.value.origin();

	/**
		// IsField reports whether the variable is a struct field.
	**/
	@:keep
	public function isField():Bool
		return __self__.value.isField();

	/**
		// Embedded reports whether the variable is an embedded field.
	**/
	@:keep
	public function embedded():Bool
		return __self__.value.embedded();

	/**
		// Anonymous reports whether the variable is an embedded field.
		// Same as Embedded; only present for backward-compatibility.
	**/
	@:keep
	public function anonymous():Bool
		return __self__.value.anonymous();

	@:embedded
	public function _setType(__0:Type):Void
		__self__.value._setType(__0);

	@:embedded
	public function _setScopePos(_p:stdgo.go.token.Token.Pos):Void
		__self__.value._setScopePos(_p);

	@:embedded
	public function _setParent(__0:Ref<Scope>):Void
		__self__.value._setParent(__0);

	@:embedded
	public function _setOrder(__0:GoUInt32):Void
		__self__.value._setOrder(__0);

	@:embedded
	public function _setColor(__0:T_color):Void
		__self__.value._setColor(__0);

	@:embedded
	public function _scopePos():stdgo.go.token.Token.Pos
		return __self__.value._scopePos();

	@:embedded
	public function _sameId(_pkg_:Ref<Package>, _name_:GoString):Bool
		return __self__.value._sameId(_pkg_, _name_);

	@:embedded
	public function _order():GoUInt32
		return __self__.value._order();

	@:embedded
	public function _color():T_color
		return __self__.value._color();

	@:embedded
	public function type():Type
		return __self__.value.type();

	@:embedded
	public function pos():stdgo.go.token.Token.Pos
		return __self__.value.pos();

	@:embedded
	public function pkg():Ref<Package>
		return __self__.value.pkg();

	@:embedded
	public function parent():Ref<Scope>
		return __self__.value.parent();

	@:embedded
	public function name():GoString
		return __self__.value.name();

	@:embedded
	public function id():GoString
		return __self__.value.id();

	@:embedded
	public function exported():Bool
		return __self__.value.exported();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Var>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Var_asInterface) class Var_static_extension {
	@:keep
	static public function string(_obj:Ref<Var>):GoString {
		return objectString(Go.asInterface(_obj), null);
	}

	@:keep
	static public function _isDependency(_:Ref<Var>):Void {}

	/**
		// Origin returns the canonical Var for its receiver, i.e. the Var object
		// recorded in Info.Defs.
		//
		// For synthetic Vars created during instantiation (such as struct fields or
		// function parameters that depend on type arguments), this will be the
		// corresponding Var on the generic (uninstantiated) type. For all other Vars
		// Origin returns the receiver.
	**/
	@:keep
	static public function origin(_obj:Ref<Var>):Ref<Var> {
		if (_obj._origin != null) {
			return _obj._origin;
		};
		return _obj;
	}

	/**
		// IsField reports whether the variable is a struct field.
	**/
	@:keep
	static public function isField(_obj:Ref<Var>):Bool {
		return _obj._isField;
	}

	/**
		// Embedded reports whether the variable is an embedded field.
	**/
	@:keep
	static public function embedded(_obj:Ref<Var>):Bool {
		return _obj._embedded;
	}

	/**
		// Anonymous reports whether the variable is an embedded field.
		// Same as Embedded; only present for backward-compatibility.
	**/
	@:keep
	static public function anonymous(_obj:Ref<Var>):Bool {
		return _obj._embedded;
	}

	@:embedded
	public static function _setType(__self__:Var, __0:Type)
		__self__._setType(__0);

	@:embedded
	public static function _setScopePos(__self__:Var, _p:stdgo.go.token.Token.Pos)
		__self__._setScopePos(_p);

	@:embedded
	public static function _setParent(__self__:Var, __0:Ref<Scope>)
		__self__._setParent(__0);

	@:embedded
	public static function _setOrder(__self__:Var, __0:GoUInt32)
		__self__._setOrder(__0);

	@:embedded
	public static function _setColor(__self__:Var, __0:T_color)
		__self__._setColor(__0);

	@:embedded
	public static function _scopePos(__self__:Var):stdgo.go.token.Token.Pos
		return __self__._scopePos();

	@:embedded
	public static function _sameId(__self__:Var, _pkg_:Ref<Package>, _name_:GoString):Bool
		return __self__._sameId(_pkg_, _name_);

	@:embedded
	public static function _order(__self__:Var):GoUInt32
		return __self__._order();

	@:embedded
	public static function _color(__self__:Var):T_color
		return __self__._color();

	@:embedded
	public static function type(__self__:Var):Type
		return __self__.type();

	@:embedded
	public static function pos(__self__:Var):stdgo.go.token.Token.Pos
		return __self__.pos();

	@:embedded
	public static function pkg(__self__:Var):Ref<Package>
		return __self__.pkg();

	@:embedded
	public static function parent(__self__:Var):Ref<Scope>
		return __self__.parent();

	@:embedded
	public static function name(__self__:Var):GoString
		return __self__.name();

	@:embedded
	public static function id(__self__:Var):GoString
		return __self__.id();

	@:embedded
	public static function exported(__self__:Var):Bool
		return __self__.exported();
}

class Func_asInterface {
	@:keep
	public function string():GoString
		return __self__.value.string();

	@:keep
	public function _isDependency():Void
		__self__.value._isDependency();

	/**
		// hasPtrRecv reports whether the receiver is of the form *T for the given method obj.
	**/
	@:keep
	public function _hasPtrRecv():Bool
		return __self__.value._hasPtrRecv();

	/**
		// Origin returns the canonical Func for its receiver, i.e. the Func object
		// recorded in Info.Defs.
		//
		// For synthetic functions created during instantiation (such as methods on an
		// instantiated Named type or interface methods that depend on type arguments),
		// this will be the corresponding Func on the generic (uninstantiated) type.
		// For all other Funcs Origin returns the receiver.
	**/
	@:keep
	public function origin():Ref<Func>
		return __self__.value.origin();

	/**
		// Scope returns the scope of the function's body block.
		// The result is nil for imported or instantiated functions and methods
		// (but there is also no mechanism to get to an instantiated function).
	**/
	@:keep
	public function scope():Ref<Scope>
		return __self__.value.scope();

	/**
		// FullName returns the package- or receiver-type-qualified name of
		// function or method obj.
	**/
	@:keep
	public function fullName():GoString
		return __self__.value.fullName();

	@:embedded
	public function _setType(__0:Type):Void
		__self__.value._setType(__0);

	@:embedded
	public function _setScopePos(_p:stdgo.go.token.Token.Pos):Void
		__self__.value._setScopePos(_p);

	@:embedded
	public function _setParent(__0:Ref<Scope>):Void
		__self__.value._setParent(__0);

	@:embedded
	public function _setOrder(__0:GoUInt32):Void
		__self__.value._setOrder(__0);

	@:embedded
	public function _setColor(__0:T_color):Void
		__self__.value._setColor(__0);

	@:embedded
	public function _scopePos():stdgo.go.token.Token.Pos
		return __self__.value._scopePos();

	@:embedded
	public function _sameId(_pkg_:Ref<Package>, _name_:GoString):Bool
		return __self__.value._sameId(_pkg_, _name_);

	@:embedded
	public function _order():GoUInt32
		return __self__.value._order();

	@:embedded
	public function _color():T_color
		return __self__.value._color();

	@:embedded
	public function type():Type
		return __self__.value.type();

	@:embedded
	public function pos():stdgo.go.token.Token.Pos
		return __self__.value.pos();

	@:embedded
	public function pkg():Ref<Package>
		return __self__.value.pkg();

	@:embedded
	public function parent():Ref<Scope>
		return __self__.value.parent();

	@:embedded
	public function name():GoString
		return __self__.value.name();

	@:embedded
	public function id():GoString
		return __self__.value.id();

	@:embedded
	public function exported():Bool
		return __self__.value.exported();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Func>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Func_asInterface) class Func_static_extension {
	@:keep
	static public function string(_obj:Ref<Func>):GoString {
		return objectString(Go.asInterface(_obj), null);
	}

	@:keep
	static public function _isDependency(_:Ref<Func>):Void {}

	/**
		// hasPtrRecv reports whether the receiver is of the form *T for the given method obj.
	**/
	@:keep
	static public function _hasPtrRecv(_obj:Ref<Func>):Bool {
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_obj._object._typ) : Ref<Signature>)) : Ref<Signature>), ok: true};
			} catch (_) {
				{value: (null : Ref<Signature>), ok: false};
			}, _sig = __tmp__.value, _0 = __tmp__.ok;
			if ((_sig != null) && (_sig._recv != null)) {
				var __tmp__ = _deref(_sig._recv._object._typ),
					_1:Type = __tmp__._0,
					_isPtr:Bool = __tmp__._1;
				return _isPtr;
			};
		};
		return _obj._hasPtrRecv_;
	}

	/**
		// Origin returns the canonical Func for its receiver, i.e. the Func object
		// recorded in Info.Defs.
		//
		// For synthetic functions created during instantiation (such as methods on an
		// instantiated Named type or interface methods that depend on type arguments),
		// this will be the corresponding Func on the generic (uninstantiated) type.
		// For all other Funcs Origin returns the receiver.
	**/
	@:keep
	static public function origin(_obj:Ref<Func>):Ref<Func> {
		if (_obj._origin != null) {
			return _obj._origin;
		};
		return _obj;
	}

	/**
		// Scope returns the scope of the function's body block.
		// The result is nil for imported or instantiated functions and methods
		// (but there is also no mechanism to get to an instantiated function).
	**/
	@:keep
	static public function scope(_obj:Ref<Func>):Ref<Scope> {
		return (Go.typeAssert((Go.toInterface(_obj._object._typ) : Ref<Signature>)) : Ref<Signature>)._scope;
	}

	/**
		// FullName returns the package- or receiver-type-qualified name of
		// function or method obj.
	**/
	@:keep
	static public function fullName(_obj:Ref<Func>):GoString {
		var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
		_writeFuncName((_buf : Ref<stdgo.bytes.Bytes.Buffer>), _obj, null);
		return (_buf.string() : GoString);
	}

	@:embedded
	public static function _setType(__self__:Func, __0:Type)
		__self__._setType(__0);

	@:embedded
	public static function _setScopePos(__self__:Func, _p:stdgo.go.token.Token.Pos)
		__self__._setScopePos(_p);

	@:embedded
	public static function _setParent(__self__:Func, __0:Ref<Scope>)
		__self__._setParent(__0);

	@:embedded
	public static function _setOrder(__self__:Func, __0:GoUInt32)
		__self__._setOrder(__0);

	@:embedded
	public static function _setColor(__self__:Func, __0:T_color)
		__self__._setColor(__0);

	@:embedded
	public static function _scopePos(__self__:Func):stdgo.go.token.Token.Pos
		return __self__._scopePos();

	@:embedded
	public static function _sameId(__self__:Func, _pkg_:Ref<Package>, _name_:GoString):Bool
		return __self__._sameId(_pkg_, _name_);

	@:embedded
	public static function _order(__self__:Func):GoUInt32
		return __self__._order();

	@:embedded
	public static function _color(__self__:Func):T_color
		return __self__._color();

	@:embedded
	public static function type(__self__:Func):Type
		return __self__.type();

	@:embedded
	public static function pos(__self__:Func):stdgo.go.token.Token.Pos
		return __self__.pos();

	@:embedded
	public static function pkg(__self__:Func):Ref<Package>
		return __self__.pkg();

	@:embedded
	public static function parent(__self__:Func):Ref<Scope>
		return __self__.parent();

	@:embedded
	public static function name(__self__:Func):GoString
		return __self__.name();

	@:embedded
	public static function id(__self__:Func):GoString
		return __self__.id();

	@:embedded
	public static function exported(__self__:Func):Bool
		return __self__.exported();
}

class Label_asInterface {
	@:keep
	public function string():GoString
		return __self__.value.string();

	@:embedded
	public function _setType(__0:Type):Void
		__self__.value._setType(__0);

	@:embedded
	public function _setScopePos(_p:stdgo.go.token.Token.Pos):Void
		__self__.value._setScopePos(_p);

	@:embedded
	public function _setParent(__0:Ref<Scope>):Void
		__self__.value._setParent(__0);

	@:embedded
	public function _setOrder(__0:GoUInt32):Void
		__self__.value._setOrder(__0);

	@:embedded
	public function _setColor(__0:T_color):Void
		__self__.value._setColor(__0);

	@:embedded
	public function _scopePos():stdgo.go.token.Token.Pos
		return __self__.value._scopePos();

	@:embedded
	public function _sameId(_pkg_:Ref<Package>, _name_:GoString):Bool
		return __self__.value._sameId(_pkg_, _name_);

	@:embedded
	public function _order():GoUInt32
		return __self__.value._order();

	@:embedded
	public function _color():T_color
		return __self__.value._color();

	@:embedded
	public function type():Type
		return __self__.value.type();

	@:embedded
	public function pos():stdgo.go.token.Token.Pos
		return __self__.value.pos();

	@:embedded
	public function pkg():Ref<Package>
		return __self__.value.pkg();

	@:embedded
	public function parent():Ref<Scope>
		return __self__.value.parent();

	@:embedded
	public function name():GoString
		return __self__.value.name();

	@:embedded
	public function id():GoString
		return __self__.value.id();

	@:embedded
	public function exported():Bool
		return __self__.value.exported();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Label>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Label_asInterface) class Label_static_extension {
	@:keep
	static public function string(_obj:Ref<Label>):GoString {
		return objectString(Go.asInterface(_obj), null);
	}

	@:embedded
	public static function _setType(__self__:Label, __0:Type)
		__self__._setType(__0);

	@:embedded
	public static function _setScopePos(__self__:Label, _p:stdgo.go.token.Token.Pos)
		__self__._setScopePos(_p);

	@:embedded
	public static function _setParent(__self__:Label, __0:Ref<Scope>)
		__self__._setParent(__0);

	@:embedded
	public static function _setOrder(__self__:Label, __0:GoUInt32)
		__self__._setOrder(__0);

	@:embedded
	public static function _setColor(__self__:Label, __0:T_color)
		__self__._setColor(__0);

	@:embedded
	public static function _scopePos(__self__:Label):stdgo.go.token.Token.Pos
		return __self__._scopePos();

	@:embedded
	public static function _sameId(__self__:Label, _pkg_:Ref<Package>, _name_:GoString):Bool
		return __self__._sameId(_pkg_, _name_);

	@:embedded
	public static function _order(__self__:Label):GoUInt32
		return __self__._order();

	@:embedded
	public static function _color(__self__:Label):T_color
		return __self__._color();

	@:embedded
	public static function type(__self__:Label):Type
		return __self__.type();

	@:embedded
	public static function pos(__self__:Label):stdgo.go.token.Token.Pos
		return __self__.pos();

	@:embedded
	public static function pkg(__self__:Label):Ref<Package>
		return __self__.pkg();

	@:embedded
	public static function parent(__self__:Label):Ref<Scope>
		return __self__.parent();

	@:embedded
	public static function name(__self__:Label):GoString
		return __self__.name();

	@:embedded
	public static function id(__self__:Label):GoString
		return __self__.id();

	@:embedded
	public static function exported(__self__:Label):Bool
		return __self__.exported();
}

class Builtin_asInterface {
	@:keep
	public function string():GoString
		return __self__.value.string();

	@:embedded
	public function _setType(__0:Type):Void
		__self__.value._setType(__0);

	@:embedded
	public function _setScopePos(_p:stdgo.go.token.Token.Pos):Void
		__self__.value._setScopePos(_p);

	@:embedded
	public function _setParent(__0:Ref<Scope>):Void
		__self__.value._setParent(__0);

	@:embedded
	public function _setOrder(__0:GoUInt32):Void
		__self__.value._setOrder(__0);

	@:embedded
	public function _setColor(__0:T_color):Void
		__self__.value._setColor(__0);

	@:embedded
	public function _scopePos():stdgo.go.token.Token.Pos
		return __self__.value._scopePos();

	@:embedded
	public function _sameId(_pkg_:Ref<Package>, _name_:GoString):Bool
		return __self__.value._sameId(_pkg_, _name_);

	@:embedded
	public function _order():GoUInt32
		return __self__.value._order();

	@:embedded
	public function _color():T_color
		return __self__.value._color();

	@:embedded
	public function type():Type
		return __self__.value.type();

	@:embedded
	public function pos():stdgo.go.token.Token.Pos
		return __self__.value.pos();

	@:embedded
	public function pkg():Ref<Package>
		return __self__.value.pkg();

	@:embedded
	public function parent():Ref<Scope>
		return __self__.value.parent();

	@:embedded
	public function name():GoString
		return __self__.value.name();

	@:embedded
	public function id():GoString
		return __self__.value.id();

	@:embedded
	public function exported():Bool
		return __self__.value.exported();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Builtin>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Builtin_asInterface) class Builtin_static_extension {
	@:keep
	static public function string(_obj:Ref<Builtin>):GoString {
		return objectString(Go.asInterface(_obj), null);
	}

	@:embedded
	public static function _setType(__self__:Builtin, __0:Type)
		__self__._setType(__0);

	@:embedded
	public static function _setScopePos(__self__:Builtin, _p:stdgo.go.token.Token.Pos)
		__self__._setScopePos(_p);

	@:embedded
	public static function _setParent(__self__:Builtin, __0:Ref<Scope>)
		__self__._setParent(__0);

	@:embedded
	public static function _setOrder(__self__:Builtin, __0:GoUInt32)
		__self__._setOrder(__0);

	@:embedded
	public static function _setColor(__self__:Builtin, __0:T_color)
		__self__._setColor(__0);

	@:embedded
	public static function _scopePos(__self__:Builtin):stdgo.go.token.Token.Pos
		return __self__._scopePos();

	@:embedded
	public static function _sameId(__self__:Builtin, _pkg_:Ref<Package>, _name_:GoString):Bool
		return __self__._sameId(_pkg_, _name_);

	@:embedded
	public static function _order(__self__:Builtin):GoUInt32
		return __self__._order();

	@:embedded
	public static function _color(__self__:Builtin):T_color
		return __self__._color();

	@:embedded
	public static function type(__self__:Builtin):Type
		return __self__.type();

	@:embedded
	public static function pos(__self__:Builtin):stdgo.go.token.Token.Pos
		return __self__.pos();

	@:embedded
	public static function pkg(__self__:Builtin):Ref<Package>
		return __self__.pkg();

	@:embedded
	public static function parent(__self__:Builtin):Ref<Scope>
		return __self__.parent();

	@:embedded
	public static function name(__self__:Builtin):GoString
		return __self__.name();

	@:embedded
	public static function id(__self__:Builtin):GoString
		return __self__.id();

	@:embedded
	public static function exported(__self__:Builtin):Bool
		return __self__.exported();
}

class Nil_asInterface {
	@:keep
	public function string():GoString
		return __self__.value.string();

	@:embedded
	public function _setType(__0:Type):Void
		__self__.value._setType(__0);

	@:embedded
	public function _setScopePos(_p:stdgo.go.token.Token.Pos):Void
		__self__.value._setScopePos(_p);

	@:embedded
	public function _setParent(__0:Ref<Scope>):Void
		__self__.value._setParent(__0);

	@:embedded
	public function _setOrder(__0:GoUInt32):Void
		__self__.value._setOrder(__0);

	@:embedded
	public function _setColor(__0:T_color):Void
		__self__.value._setColor(__0);

	@:embedded
	public function _scopePos():stdgo.go.token.Token.Pos
		return __self__.value._scopePos();

	@:embedded
	public function _sameId(_pkg_:Ref<Package>, _name_:GoString):Bool
		return __self__.value._sameId(_pkg_, _name_);

	@:embedded
	public function _order():GoUInt32
		return __self__.value._order();

	@:embedded
	public function _color():T_color
		return __self__.value._color();

	@:embedded
	public function type():Type
		return __self__.value.type();

	@:embedded
	public function pos():stdgo.go.token.Token.Pos
		return __self__.value.pos();

	@:embedded
	public function pkg():Ref<Package>
		return __self__.value.pkg();

	@:embedded
	public function parent():Ref<Scope>
		return __self__.value.parent();

	@:embedded
	public function name():GoString
		return __self__.value.name();

	@:embedded
	public function id():GoString
		return __self__.value.id();

	@:embedded
	public function exported():Bool
		return __self__.value.exported();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Nil>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Nil_asInterface) class Nil_static_extension {
	@:keep
	static public function string(_obj:Ref<Nil>):GoString {
		return objectString(Go.asInterface(_obj), null);
	}

	@:embedded
	public static function _setType(__self__:Nil, __0:Type)
		__self__._setType(__0);

	@:embedded
	public static function _setScopePos(__self__:Nil, _p:stdgo.go.token.Token.Pos)
		__self__._setScopePos(_p);

	@:embedded
	public static function _setParent(__self__:Nil, __0:Ref<Scope>)
		__self__._setParent(__0);

	@:embedded
	public static function _setOrder(__self__:Nil, __0:GoUInt32)
		__self__._setOrder(__0);

	@:embedded
	public static function _setColor(__self__:Nil, __0:T_color)
		__self__._setColor(__0);

	@:embedded
	public static function _scopePos(__self__:Nil):stdgo.go.token.Token.Pos
		return __self__._scopePos();

	@:embedded
	public static function _sameId(__self__:Nil, _pkg_:Ref<Package>, _name_:GoString):Bool
		return __self__._sameId(_pkg_, _name_);

	@:embedded
	public static function _order(__self__:Nil):GoUInt32
		return __self__._order();

	@:embedded
	public static function _color(__self__:Nil):T_color
		return __self__._color();

	@:embedded
	public static function type(__self__:Nil):Type
		return __self__.type();

	@:embedded
	public static function pos(__self__:Nil):stdgo.go.token.Token.Pos
		return __self__.pos();

	@:embedded
	public static function pkg(__self__:Nil):Ref<Package>
		return __self__.pkg();

	@:embedded
	public static function parent(__self__:Nil):Ref<Scope>
		return __self__.parent();

	@:embedded
	public static function name(__self__:Nil):GoString
		return __self__.name();

	@:embedded
	public static function id(__self__:Nil):GoString
		return __self__.id();

	@:embedded
	public static function exported(__self__:Nil):Bool
		return __self__.exported();
}

class T_operand_asInterface {
	/**
		// assignableTo reports whether x is assignable to a variable of type T. If the
		// result is false and a non-nil reason is provided, it may be set to a more
		// detailed explanation of the failure (result != ""). The returned error code
		// is only valid if the (first) result is false. The check parameter may be nil
		// if assignableTo is invoked through an exported API call, i.e., when all
		// methods have been type-checked.
	**/
	@:keep
	public function _assignableTo(_check:Ref<Checker>, t:Type, _reason:Pointer<GoString>):{var _0:Bool; var _1:T_errorCode;}
		return __self__.value._assignableTo(_check, t, _reason);

	/**
		// isNil reports whether x is the nil value.
	**/
	@:keep
	public function _isNil():Bool
		return __self__.value._isNil();

	/**
		// setConst sets x to the untyped constant for literal lit.
	**/
	@:keep
	public function _setConst(_tok:stdgo.go.token.Token.Token, _lit:GoString):Void
		__self__.value._setConst(_tok, _lit);

	@:keep
	public function string():GoString
		return __self__.value.string();

	/**
		// Pos returns the position of the expression corresponding to x.
		// If x is invalid the position is token.NoPos.
	**/
	@:keep
	public function pos():stdgo.go.token.Token.Pos
		return __self__.value.pos();

	/**
		// convertibleTo reports whether T(x) is valid. In the failure case, *cause
		// may be set to the cause for the failure.
		// The check parameter may be nil if convertibleTo is invoked through an
		// exported API call, i.e., when all methods have been type-checked.
	**/
	@:keep
	public function _convertibleTo(_check:Ref<Checker>, t:Type, _cause:Pointer<GoString>):Bool
		return __self__.value._convertibleTo(_check, t, _cause);

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_operand>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_operand_asInterface) class T_operand_static_extension {
	/**
		// assignableTo reports whether x is assignable to a variable of type T. If the
		// result is false and a non-nil reason is provided, it may be set to a more
		// detailed explanation of the failure (result != ""). The returned error code
		// is only valid if the (first) result is false. The check parameter may be nil
		// if assignableTo is invoked through an exported API call, i.e., when all
		// methods have been type-checked.
	**/
	@:keep
	static public function _assignableTo(_x:Ref<T_operand>, _check:Ref<Checker>, t:Type, _reason:Pointer<GoString>):{var _0:Bool; var _1:T_errorCode;} {
		if ((_x._mode == (0 : T_operandMode)) || (Go.toInterface(t) == Go.toInterface(Go.asInterface(typ[((0 : BasicKind) : GoInt)])))) {
			return {_0: true, _1: (0 : T_errorCode)};
		};
		var v:Type = _x._typ;
		if (identical(v, t)) {
			return {_0: true, _1: (0 : T_errorCode)};
		};
		var vu:Type = _under(v);
		var tu:Type = _under(t);
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(v) : Ref<TypeParam>)) : Ref<TypeParam>), ok: true};
		} catch (_) {
			{value: (null : Ref<TypeParam>), ok: false};
		}, vp = __tmp__.value, _0 = __tmp__.ok;
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(t) : Ref<TypeParam>)) : Ref<TypeParam>), ok: true};
		} catch (_) {
			{value: (null : Ref<TypeParam>), ok: false};
		}, tp = __tmp__.value, _1 = __tmp__.ok;
		if (_isUntyped(vu)) {
			_assert(vp == null);
			if (tp != null) {
				return {
					_0: tp._is(function(_t:Ref<T_term>):Bool {
						if (_t == null) {
							return false;
						};
						var __tmp__ = _check._implicitTypeAndValue(_x, _t._typ),
							_newType:Type = __tmp__._0,
							_0:stdgo.go.constant.Constant.Value = __tmp__._1,
							_1:T_errorCode = __tmp__._2;
						return _newType != null;
					}),
					_1: (23 : T_errorCode)
				};
			};
			var __tmp__ = _check._implicitTypeAndValue(_x, t),
				_newType:Type = __tmp__._0,
				_2:stdgo.go.constant.Constant.Value = __tmp__._1,
				_3:T_errorCode = __tmp__._2;
			return {_0: _newType != null, _1: (23 : T_errorCode)};
		};
		if (((identical(vu, tu) && (!_hasName(v) || !_hasName(t))) && (vp == null)) && (tp == null)) {
			return {_0: true, _1: (0 : T_errorCode)};
		};
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(tu) : Ref<Interface>)) : Ref<Interface>), ok: true};
			} catch (_) {
				{value: (null : Ref<Interface>), ok: false};
			}, _4 = __tmp__.value, _ok = __tmp__.ok;
			if ((_ok && (tp == null)) || _isInterfacePtr(tu)) {
				{
					var _err:Error = _check._implements(v, t);
					if (_err != null) {
						if (_reason != null) {
							_reason.value = _err.error();
						};
						return {_0: false, _1: (21 : T_errorCode)};
					};
				};
				return {_0: true, _1: (0 : T_errorCode)};
			};
		};
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(vu) : Ref<Interface>)) : Ref<Interface>), ok: true};
			} catch (_) {
				{value: (null : Ref<Interface>), ok: false};
			}, vi = __tmp__.value, _5 = __tmp__.ok;
			if ((vi != null) && (vp == null)) {
				if (_check._implements(t, v) == null) {
					if (_reason != null) {
						_reason.value = ("need type assertion" : GoString);
					};
					return {_0: false, _1: (23 : T_errorCode)};
				};
			};
		};
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(vu) : Ref<Chan>)) : Ref<Chan>), ok: true};
			} catch (_) {
				{value: (null : Ref<Chan>), ok: false};
			}, vc = __tmp__.value, _ok = __tmp__.ok;
			if (_ok && (vc._dir == (0 : ChanDir))) {
				{
					var __tmp__ = try {
						{value: (Go.typeAssert((Go.toInterface(tu) : Ref<Chan>)) : Ref<Chan>), ok: true};
					} catch (_) {
						{value: (null : Ref<Chan>), ok: false};
					}, tc = __tmp__.value, _ok = __tmp__.ok;
					if (_ok && identical(vc._elem, tc._elem)) {
						return {_0: !_hasName(v) || !_hasName(t), _1: (22 : T_errorCode)};
					};
				};
			};
		};
		if ((vp == null) && (tp == null)) {
			return {_0: false, _1: (23 : T_errorCode)};
		};
		var _errorf = function(_format:GoString, _args:haxe.Rest<AnyInterface>):Void {
			if ((_check != null) && (_reason != null)) {
				var _msg:GoString = _check._sprintf(_format, ..._args.__toArray__());
				if (_reason.value != (Go.str())) {
					_msg = _msg + (("\n\t" : GoString) + _reason.value);
				};
				_reason.value = _msg;
			};
		};
		if (!_hasName(v) && (tp != null)) {
			var _ok:Bool = false;
			var _code:T_errorCode = (23 : T_errorCode);
			tp._is(function(t:Ref<T_term>):Bool {
				if (t == null) {
					return false;
				};
				{
					var __tmp__ = _x._assignableTo(_check, t._typ, _reason);
					_ok = __tmp__._0;
					_code = __tmp__._1;
				};
				if (!_ok) {
					_errorf(("cannot assign %s to %s (in %s)" : GoString), Go.toInterface(_x._typ), Go.toInterface(t._typ),
						Go.toInterface(Go.asInterface(tp)));
					return false;
				};
				return true;
			});
			return {_0: _ok, _1: _code};
		};
		if ((vp != null) && !_hasName(t)) {
			var _x:T_operand = (_x == null ? null : _x.__copy__());
			var _ok:Bool = false;
			var _code:T_errorCode = (23 : T_errorCode);
			vp._is(function(v:Ref<T_term>):Bool {
				if (v == null) {
					return false;
				};
				_x._typ = v._typ;
				{
					var __tmp__ = _x._assignableTo(_check, t, _reason);
					_ok = __tmp__._0;
					_code = __tmp__._1;
				};
				if (!_ok) {
					_errorf(("cannot assign %s (in %s) to %s" : GoString), Go.toInterface(v._typ), Go.toInterface(Go.asInterface(vp)), Go.toInterface(t));
					return false;
				};
				return true;
			});
			return {_0: _ok, _1: _code};
		};
		return {_0: false, _1: (23 : T_errorCode)};
	}

	/**
		// isNil reports whether x is the nil value.
	**/
	@:keep
	static public function _isNil(_x:Ref<T_operand>):Bool {
		return (_x._mode == (7 : T_operandMode))
			&& (Go.toInterface(_x._typ) == Go.toInterface(Go.asInterface(typ[((25 : BasicKind) : GoInt)])));
	}

	/**
		// setConst sets x to the untyped constant for literal lit.
	**/
	@:keep
	static public function _setConst(_x:Ref<T_operand>, _tok:stdgo.go.token.Token.Token, _lit:GoString):Void {
		var _kind:BasicKind = ((0 : GoInt) : BasicKind);
		if (_tok == ((5 : stdgo.go.token.Token.Token))) {
			_kind = (20 : BasicKind);
		} else if (_tok == ((6 : stdgo.go.token.Token.Token))) {
			_kind = (22 : BasicKind);
		} else if (_tok == ((7 : stdgo.go.token.Token.Token))) {
			_kind = (23 : BasicKind);
		} else if (_tok == ((8 : stdgo.go.token.Token.Token))) {
			_kind = (21 : BasicKind);
		} else if (_tok == ((9 : stdgo.go.token.Token.Token))) {
			_kind = (24 : BasicKind);
		} else {
			_unreachable();
		};
		var _val:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.makeFromLiteral(_lit, _tok, ("0" : GoUInt));
		if (_val.kind() == ((0 : stdgo.go.constant.Constant.Kind))) {
			_x._mode = (0 : T_operandMode);
			_x._typ = Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
			return;
		};
		_x._mode = (4 : T_operandMode);
		_x._typ = Go.asInterface(typ[(_kind : GoInt)]);
		_x._val = _val;
	}

	@:keep
	static public function string(_x:Ref<T_operand>):GoString {
		return _operandString(_x, null);
	}

	/**
		// Pos returns the position of the expression corresponding to x.
		// If x is invalid the position is token.NoPos.
	**/
	@:keep
	static public function pos(_x:Ref<T_operand>):stdgo.go.token.Token.Pos {
		if (_x._expr == null) {
			return (0 : stdgo.go.token.Token.Pos);
		};
		return _x._expr.pos();
	}

	/**
		// convertibleTo reports whether T(x) is valid. In the failure case, *cause
		// may be set to the cause for the failure.
		// The check parameter may be nil if convertibleTo is invoked through an
		// exported API call, i.e., when all methods have been type-checked.
	**/
	@:keep
	static public function _convertibleTo(_x:Ref<T_operand>, _check:Ref<Checker>, t:Type, _cause:Pointer<GoString>):Bool {
		{
			var __tmp__ = _x._assignableTo(_check, t, _cause),
				_ok:Bool = __tmp__._0,
				_0:T_errorCode = __tmp__._1;
			if (_ok) {
				return true;
			};
		};
		var v:Type = _x._typ;
		var vu:Type = _under(v);
		var tu:Type = _under(t);
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(v) : Ref<TypeParam>)) : Ref<TypeParam>), ok: true};
		} catch (_) {
			{value: (null : Ref<TypeParam>), ok: false};
		}, vp = __tmp__.value, _1 = __tmp__.ok;
		var __tmp__ = try {
			{value: (Go.typeAssert((Go.toInterface(t) : Ref<TypeParam>)) : Ref<TypeParam>), ok: true};
		} catch (_) {
			{value: (null : Ref<TypeParam>), ok: false};
		}, tp = __tmp__.value, _2 = __tmp__.ok;
		if ((identicalIgnoreTags(vu, tu) && (vp == null)) && (tp == null)) {
			return true;
		};
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(v) : Ref<Pointer_>)) : Ref<Pointer_>), ok: true};
			} catch (_) {
				{value: (null : Ref<Pointer_>), ok: false};
			}, v = __tmp__.value, _ok = __tmp__.ok;
			if (_ok) {
				{
					var __tmp__ = try {
						{value: (Go.typeAssert((Go.toInterface(t) : Ref<Pointer_>)) : Ref<Pointer_>), ok: true};
					} catch (_) {
						{value: (null : Ref<Pointer_>), ok: false};
					}, t = __tmp__.value, _ok = __tmp__.ok;
					if (_ok) {
						if ((identicalIgnoreTags(_under(v._base), _under(t._base)) && !_isTypeParam(v._base)) && !_isTypeParam(t._base)) {
							return true;
						};
					};
				};
			};
		};
		if (_isIntegerOrFloat(vu) && _isIntegerOrFloat(tu)) {
			return true;
		};
		if (_isComplex(vu) && _isComplex(tu)) {
			return true;
		};
		if ((_isInteger(vu) || _isBytesOrRunes(vu)) && _isString(tu)) {
			return true;
		};
		if (_isString(vu) && _isBytesOrRunes(tu)) {
			return true;
		};
		if ((_isPointer(vu) || _isUintptr(vu)) && _isUnsafePointer(tu)) {
			return true;
		};
		if (_isUnsafePointer(vu) && (_isPointer(tu) || _isUintptr(tu))) {
			return true;
		};
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(vu) : Ref<Slice_>)) : Ref<Slice_>), ok: true};
			} catch (_) {
				{value: (null : Ref<Slice_>), ok: false};
			}, _s = __tmp__.value, _3 = __tmp__.ok;
			if (_s != null) {
				{
					var __tmp__ = try {
						{value: (Go.typeAssert((Go.toInterface(tu) : Ref<Pointer_>)) : Ref<Pointer_>), ok: true};
					} catch (_) {
						{value: (null : Ref<Pointer_>), ok: false};
					}, _p = __tmp__.value, _4 = __tmp__.ok;
					if (_p != null) {
						{
							var __tmp__ = try {
								{value: (Go.typeAssert((Go.toInterface(_under(_p.elem())) : Ref<Array_>)) : Ref<Array_>), ok: true};
							} catch (_) {
								{value: (null : Ref<Array_>), ok: false};
							}, _a = __tmp__.value, _5 = __tmp__.ok;
							if (_a != null) {
								if (identical(_s.elem(), _a.elem())) {
									if ((_check == null) || _check._allowVersion(_check._pkg, (1 : GoInt), (17 : GoInt))) {
										return true;
									};
									if (_cause != null) {
										_cause.value = ("conversion of slices to array pointers requires go1.17 or later" : GoString);
									};
								};
							};
						};
					};
				};
			};
		};
		if ((vp == null) && (tp == null)) {
			return false;
		};
		var _errorf = function(_format:GoString, _args:haxe.Rest<AnyInterface>):Void {
			if ((_check != null) && (_cause != null)) {
				var _msg:GoString = _check._sprintf(_format, ..._args.__toArray__());
				if (_cause.value != (Go.str())) {
					_msg = _msg + (("\n\t" : GoString) + _cause.value);
				};
				_cause.value = _msg;
			};
		};
		if ((vp != null) && (tp != null)) {
			var _x:T_operand = (_x == null ? null : _x.__copy__());
			return vp._is(function(v:Ref<T_term>):Bool {
				if (v == null) {
					return false;
				};
				_x._typ = v._typ;
				return tp._is(function(t:Ref<T_term>):Bool {
					if (t == null) {
						return false;
					};
					if (!_x._convertibleTo(_check, t._typ, _cause)) {
						_errorf(("cannot convert %s (in %s) to %s (in %s)" : GoString), Go.toInterface(v._typ), Go.toInterface(Go.asInterface(vp)),
							Go.toInterface(t._typ), Go.toInterface(Go.asInterface(tp)));
						return false;
					};
					return true;
				});
			});
		} else if (vp != null) {
			var _x:T_operand = (_x == null ? null : _x.__copy__());
			return vp._is(function(v:Ref<T_term>):Bool {
				if (v == null) {
					return false;
				};
				_x._typ = v._typ;
				if (!_x._convertibleTo(_check, t, _cause)) {
					_errorf(("cannot convert %s (in %s) to %s" : GoString), Go.toInterface(v._typ), Go.toInterface(Go.asInterface(vp)), Go.toInterface(t));
					return false;
				};
				return true;
			});
		} else if (tp != null) {
			return tp._is(function(t:Ref<T_term>):Bool {
				if (t == null) {
					return false;
				};
				if (!_x._convertibleTo(_check, t._typ, _cause)) {
					_errorf(("cannot convert %s to %s (in %s)" : GoString), Go.toInterface(_x._typ), Go.toInterface(t._typ),
						Go.toInterface(Go.asInterface(tp)));
					return false;
				};
				return true;
			});
		};
		return false;
	}
}

class Package_asInterface {
	@:keep
	public function string():GoString
		return __self__.value.string();

	/**
		// SetImports sets the list of explicitly imported packages to list.
		// It is the caller's responsibility to make sure list elements are unique.
	**/
	@:keep
	public function setImports(_list:Slice<Ref<Package>>):Void
		__self__.value.setImports(_list);

	/**
		// Imports returns the list of packages directly imported by
		// pkg; the list is in source order.
		//
		// If pkg was loaded from export data, Imports includes packages that
		// provide package-level objects referenced by pkg. This may be more or
		// less than the set of packages directly imported by pkg's source code.
	**/
	@:keep
	public function imports():Slice<Ref<Package>>
		return __self__.value.imports();

	/**
		// MarkComplete marks a package as complete.
	**/
	@:keep
	public function markComplete():Void
		__self__.value.markComplete();

	/**
		// A package is complete if its scope contains (at least) all
		// exported objects; otherwise it is incomplete.
	**/
	@:keep
	public function complete():Bool
		return __self__.value.complete();

	/**
		// Scope returns the (complete or incomplete) package scope
		// holding the objects declared at package level (TypeNames,
		// Consts, Vars, and Funcs).
		// For a nil pkg receiver, Scope returns the Universe scope.
	**/
	@:keep
	public function scope():Ref<Scope>
		return __self__.value.scope();

	/**
		// SetName sets the package name.
	**/
	@:keep
	public function setName(_name:GoString):Void
		__self__.value.setName(_name);

	/**
		// Name returns the package name.
	**/
	@:keep
	public function name():GoString
		return __self__.value.name();

	/**
		// Path returns the package path.
	**/
	@:keep
	public function path():GoString
		return __self__.value.path();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Package>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Package_asInterface) class Package_static_extension {
	@:keep
	static public function string(_pkg:Ref<Package>):GoString {
		return stdgo.fmt.Fmt.sprintf(("package %s (%q)" : GoString), Go.toInterface(_pkg._name), Go.toInterface(_pkg._path));
	}

	/**
		// SetImports sets the list of explicitly imported packages to list.
		// It is the caller's responsibility to make sure list elements are unique.
	**/
	@:keep
	static public function setImports(_pkg:Ref<Package>, _list:Slice<Ref<Package>>):Void {
		_pkg._imports = _list;
	}

	/**
		// Imports returns the list of packages directly imported by
		// pkg; the list is in source order.
		//
		// If pkg was loaded from export data, Imports includes packages that
		// provide package-level objects referenced by pkg. This may be more or
		// less than the set of packages directly imported by pkg's source code.
	**/
	@:keep
	static public function imports(_pkg:Ref<Package>):Slice<Ref<Package>> {
		return _pkg._imports;
	}

	/**
		// MarkComplete marks a package as complete.
	**/
	@:keep
	static public function markComplete(_pkg:Ref<Package>):Void {
		_pkg._complete = true;
	}

	/**
		// A package is complete if its scope contains (at least) all
		// exported objects; otherwise it is incomplete.
	**/
	@:keep
	static public function complete(_pkg:Ref<Package>):Bool {
		return _pkg._complete;
	}

	/**
		// Scope returns the (complete or incomplete) package scope
		// holding the objects declared at package level (TypeNames,
		// Consts, Vars, and Funcs).
		// For a nil pkg receiver, Scope returns the Universe scope.
	**/
	@:keep
	static public function scope(_pkg:Ref<Package>):Ref<Scope> {
		if (_pkg != null) {
			return _pkg._scope;
		};
		return universe;
	}

	/**
		// SetName sets the package name.
	**/
	@:keep
	static public function setName(_pkg:Ref<Package>, _name:GoString):Void {
		_pkg._name = _name;
	}

	/**
		// Name returns the package name.
	**/
	@:keep
	static public function name(_pkg:Ref<Package>):GoString {
		return _pkg._name;
	}

	/**
		// Path returns the package path.
	**/
	@:keep
	static public function path(_pkg:Ref<Package>):GoString {
		return _pkg._path;
	}
}

class Pointer__asInterface {
	@:keep
	public function string():GoString
		return __self__.value.string();

	@:keep
	public function underlying():Type
		return __self__.value.underlying();

	/**
		// Elem returns the element type for the given pointer p.
	**/
	@:keep
	public function elem():Type
		return __self__.value.elem();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Pointer_>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Pointer__asInterface) class Pointer__static_extension {
	@:keep
	static public function string(_t:Ref<Pointer_>):GoString {
		return typeString(Go.asInterface(_t), null);
	}

	@:keep
	static public function underlying(_t:Ref<Pointer_>):Type {
		return Go.asInterface(_t);
	}

	/**
		// Elem returns the element type for the given pointer p.
	**/
	@:keep
	static public function elem(_p:Ref<Pointer_>):Type {
		return _p._base;
	}
}

class T_ifacePair_asInterface {
	@:keep
	public function _identical(_q:Ref<T_ifacePair>):Bool
		return __self__.value._identical(_q);

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_ifacePair>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_ifacePair_asInterface) class T_ifacePair_static_extension {
	@:keep
	static public function _identical(_p:Ref<T_ifacePair>, _q:Ref<T_ifacePair>):Bool {
		return ((_p._x == _q._x) && (_p._y == _q._y)) || ((_p._x == _q._y) && (_p._y == _q._x));
	}
}

class T_declInfo_asInterface {
	/**
		// addDep adds obj to the set of objects d's init expression depends on.
	**/
	@:keep
	public function _addDep(_obj:Object):Void
		__self__.value._addDep(_obj);

	/**
		// hasInitializer reports whether the declared object has an initialization
		// expression or function body.
	**/
	@:keep
	public function _hasInitializer():Bool
		return __self__.value._hasInitializer();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_declInfo>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_declInfo_asInterface) class T_declInfo_static_extension {
	/**
		// addDep adds obj to the set of objects d's init expression depends on.
	**/
	@:keep
	static public function _addDep(_d:Ref<T_declInfo>, _obj:Object):Void {
		var _m = _d._deps;
		if (_m == null) {
			_m = (new GoObjectMap<Object, Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
				stdgo.internal.reflect.Reflect.GoType.named("Object", [], null, false, {get: () -> null})},
				{get: () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind)}))) : GoMap<Object, Bool>);
			_d._deps = _m;
		};
		_m[_obj] = true;
	}

	/**
		// hasInitializer reports whether the declared object has an initialization
		// expression or function body.
	**/
	@:keep
	static public function _hasInitializer(_d:Ref<T_declInfo>):Bool {
		return (_d._init != null) || ((_d._fdecl != null) && (_d._fdecl.body != null));
	}
}

class Scope_asInterface {
	/**
		// String returns a string representation of the scope, for debugging.
	**/
	@:keep
	public function string():GoString
		return __self__.value.string();

	/**
		// WriteTo writes a string representation of the scope to w,
		// with the scope elements sorted by name.
		// The level of indentation is controlled by n >= 0, with
		// n == 0 for no indentation.
		// If recurse is set, it also writes nested (children) scopes.
	**/
	@:keep
	public function writeTo(_w:stdgo.io.Io.Writer, _n:GoInt, _recurse:Bool):Void
		__self__.value.writeTo(_w, _n, _recurse);

	/**
		// Innermost returns the innermost (child) scope containing
		// pos. If pos is not within any scope, the result is nil.
		// The result is also nil for the Universe scope.
		// The result is guaranteed to be valid only if the type-checked
		// AST has complete position information.
	**/
	@:keep
	public function innermost(_pos:stdgo.go.token.Token.Pos):Ref<Scope>
		return __self__.value.innermost(_pos);

	/**
		// Contains reports whether pos is within the scope's extent.
		// The result is guaranteed to be valid only if the type-checked
		// AST has complete position information.
	**/
	@:keep
	public function contains(_pos:stdgo.go.token.Token.Pos):Bool
		return __self__.value.contains(_pos);

	@:keep
	public function end():stdgo.go.token.Token.Pos
		return __self__.value.end();

	/**
		// Pos and End describe the scope's source code extent [pos, end).
		// The results are guaranteed to be valid only if the type-checked
		// AST has complete position information. The extent is undefined
		// for Universe and package scopes.
	**/
	@:keep
	public function pos():stdgo.go.token.Token.Pos
		return __self__.value.pos();

	/**
		// squash merges s with its parent scope p by adding all
		// objects of s to p, adding all children of s to the
		// children of p, and removing s from p's children.
		// The function f is called for each object obj in s which
		// has an object alt in p. s should be discarded after
		// having been squashed.
	**/
	@:keep
	public function _squash(_err:(_obj:Object, _alt:Object) -> Void):Void
		__self__.value._squash(_err);

	@:keep
	public function _insert(_name:GoString, _obj:Object):Void
		__self__.value._insert(_name, _obj);

	/**
		// _InsertLazy is like Insert, but allows deferring construction of the
		// inserted object until it's accessed with Lookup. The Object
		// returned by resolve must have the same name as given to _InsertLazy.
		// If s already contains an alternative object with the same name,
		// _InsertLazy leaves s unchanged and returns false. Otherwise it
		// records the binding and returns true. The object's parent scope
		// will be set to s after resolve is called.
	**/
	@:keep
	public function __InsertLazy(_name:GoString, _resolve:() -> Object):Bool
		return __self__.value.__InsertLazy(_name, _resolve);

	/**
		// Insert attempts to insert an object obj into scope s.
		// If s already contains an alternative object alt with
		// the same name, Insert leaves s unchanged and returns alt.
		// Otherwise it inserts obj, sets the object's parent scope
		// if not already set, and returns nil.
	**/
	@:keep
	public function insert(_obj:Object):Object
		return __self__.value.insert(_obj);

	/**
		// LookupParent follows the parent chain of scopes starting with s until
		// it finds a scope where Lookup(name) returns a non-nil object, and then
		// returns that scope and object. If a valid position pos is provided,
		// only objects that were declared at or before pos are considered.
		// If no such scope and object exists, the result is (nil, nil).
		//
		// Note that obj.Parent() may be different from the returned scope if the
		// object was inserted into the scope and already had a parent at that
		// time (see Insert). This can only happen for dot-imported objects
		// whose scope is the scope of the package that exported them.
	**/
	@:keep
	public function lookupParent(_name:GoString, _pos:stdgo.go.token.Token.Pos):{var _0:Ref<Scope>; var _1:Object;}
		return __self__.value.lookupParent(_name, _pos);

	/**
		// Lookup returns the object in scope s with the given name if such an
		// object exists; otherwise the result is nil.
	**/
	@:keep
	public function lookup(_name:GoString):Object
		return __self__.value.lookup(_name);

	/**
		// Child returns the i'th child scope for 0 <= i < NumChildren().
	**/
	@:keep
	public function child(_i:GoInt):Ref<Scope>
		return __self__.value.child(_i);

	/**
		// NumChildren returns the number of scopes nested in s.
	**/
	@:keep
	public function numChildren():GoInt
		return __self__.value.numChildren();

	/**
		// Names returns the scope's element names in sorted order.
	**/
	@:keep
	public function names():Slice<GoString>
		return __self__.value.names();

	/**
		// Len returns the number of scope elements.
	**/
	@:keep
	public function len():GoInt
		return __self__.value.len();

	/**
		// Parent returns the scope's containing (parent) scope.
	**/
	@:keep
	public function parent():Ref<Scope>
		return __self__.value.parent();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Scope>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Scope_asInterface) class Scope_static_extension {
	/**
		// String returns a string representation of the scope, for debugging.
	**/
	@:keep
	static public function string(_s:Ref<Scope>):GoString {
		var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
		_s.writeTo(Go.asInterface((_buf : Ref<stdgo.bytes.Bytes.Buffer>)), (0 : GoInt), false);
		return (_buf.string() : GoString);
	}

	/**
		// WriteTo writes a string representation of the scope to w,
		// with the scope elements sorted by name.
		// The level of indentation is controlled by n >= 0, with
		// n == 0 for no indentation.
		// If recurse is set, it also writes nested (children) scopes.
	**/
	@:keep
	static public function writeTo(_s:Ref<Scope>, _w:stdgo.io.Io.Writer, _n:GoInt, _recurse:Bool):Void {
		{};
		var _indn:GoString = stdgo.strings.Strings.repeat((".  " : GoString), _n);
		stdgo.fmt.Fmt.fprintf(_w, ("%s%s scope %p {\n" : GoString), Go.toInterface(_indn), Go.toInterface(_s._comment), Go.toInterface(Go.asInterface(_s)));
		var _indn1:GoString = _indn + (".  " : GoString);
		for (_0 => _name in _s.names()) {
			stdgo.fmt.Fmt.fprintf(_w, ("%s%s\n" : GoString), Go.toInterface(_indn1), Go.toInterface(_s.lookup(_name)));
		};
		if (_recurse) {
			for (_1 => _s in _s._children) {
				_s.writeTo(_w, _n + (1 : GoInt), _recurse);
			};
		};
		stdgo.fmt.Fmt.fprintf(_w, ("%s}\n" : GoString), Go.toInterface(_indn));
	}

	/**
		// Innermost returns the innermost (child) scope containing
		// pos. If pos is not within any scope, the result is nil.
		// The result is also nil for the Universe scope.
		// The result is guaranteed to be valid only if the type-checked
		// AST has complete position information.
	**/
	@:keep
	static public function innermost(_s:Ref<Scope>, _pos:stdgo.go.token.Token.Pos):Ref<Scope> {
		if (_s._parent == (universe)) {
			for (_0 => _s in _s._children) {
				{
					var _inner = _s.innermost(_pos);
					if (_inner != null) {
						return _inner;
					};
				};
			};
		};
		if (_s.contains(_pos)) {
			for (_1 => _s in _s._children) {
				if (_s.contains(_pos)) {
					return _s.innermost(_pos);
				};
			};
			return _s;
		};
		return null;
	}

	/**
		// Contains reports whether pos is within the scope's extent.
		// The result is guaranteed to be valid only if the type-checked
		// AST has complete position information.
	**/
	@:keep
	static public function contains(_s:Ref<Scope>, _pos:stdgo.go.token.Token.Pos):Bool {
		return (_s._pos <= _pos) && (_pos < _s._end);
	}

	@:keep
	static public function end(_s:Ref<Scope>):stdgo.go.token.Token.Pos {
		return _s._end;
	}

	/**
		// Pos and End describe the scope's source code extent [pos, end).
		// The results are guaranteed to be valid only if the type-checked
		// AST has complete position information. The extent is undefined
		// for Universe and package scopes.
	**/
	@:keep
	static public function pos(_s:Ref<Scope>):stdgo.go.token.Token.Pos {
		return _s._pos;
	}

	/**
		// squash merges s with its parent scope p by adding all
		// objects of s to p, adding all children of s to the
		// children of p, and removing s from p's children.
		// The function f is called for each object obj in s which
		// has an object alt in p. s should be discarded after
		// having been squashed.
	**/
	@:keep
	static public function _squash(_s:Ref<Scope>, _err:(_obj:Object, _alt:Object) -> Void):Void {
		var _p = _s._parent;
		_assert(_p != null);
		for (_name => _obj in _s._elems) {
			_obj = _resolve(_name, _obj);
			_obj._setParent(null);
			{
				var _alt:Object = _p.insert(_obj);
				if (_alt != null) {
					_err(_obj, _alt);
				};
			};
		};
		var _j:GoInt = (-1 : GoInt);
		for (_i => _ch in _p._children) {
			if (_ch == (_s)) {
				_j = _i;
				break;
			};
		};
		_assert(_j >= (0 : GoInt));
		var _k:GoInt = (_p._children.length) - (1 : GoInt);
		_p._children[(_j : GoInt)] = _p._children[(_k : GoInt)];
		_p._children = (_p._children.__slice__(0, _k) : Slice<Ref<Scope>>);
		_p._children = _p._children.__appendref__(..._s._children.__toArray__());
		_s._children = (null : Slice<Ref<Scope>>);
		_s._elems = (null : GoMap<GoString, Object>);
	}

	@:keep
	static public function _insert(_s:Ref<Scope>, _name:GoString, _obj:Object):Void {
		if (_s._elems == null) {
			_s._elems = (new GoObjectMap<GoString, Object>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
				stdgo.internal.reflect.Reflect.GoType.basic(string_kind)},
				{get: () -> stdgo.internal.reflect.Reflect.GoType.named("Object", [], null, false, {get: () -> null})}))) : GoMap<GoString, Object>);
		};
		_s._elems[_name] = _obj;
	}

	/**
		// _InsertLazy is like Insert, but allows deferring construction of the
		// inserted object until it's accessed with Lookup. The Object
		// returned by resolve must have the same name as given to _InsertLazy.
		// If s already contains an alternative object with the same name,
		// _InsertLazy leaves s unchanged and returns false. Otherwise it
		// records the binding and returns true. The object's parent scope
		// will be set to s after resolve is called.
	**/
	@:keep
	static public function __InsertLazy(_s:Ref<Scope>, _name:GoString, _resolve:() -> Object):Bool {
		if (_s._elems[_name] != null) {
			return false;
		};
		_s._insert(_name, Go.asInterface((({_parent: _s, _resolve: _resolve} : T_lazyObject) : Ref<T_lazyObject>)));
		return true;
	}

	/**
		// Insert attempts to insert an object obj into scope s.
		// If s already contains an alternative object alt with
		// the same name, Insert leaves s unchanged and returns alt.
		// Otherwise it inserts obj, sets the object's parent scope
		// if not already set, and returns nil.
	**/
	@:keep
	static public function insert(_s:Ref<Scope>, _obj:Object):Object {
		var _name:GoString = _obj.name();
		{
			var _alt:Object = _s.lookup(_name);
			if (_alt != null) {
				return _alt;
			};
		};
		_s._insert(_name, _obj);
		if (_obj.parent() == null) {
			_obj._setParent(_s);
		};
		return (null : Object);
	}

	/**
		// LookupParent follows the parent chain of scopes starting with s until
		// it finds a scope where Lookup(name) returns a non-nil object, and then
		// returns that scope and object. If a valid position pos is provided,
		// only objects that were declared at or before pos are considered.
		// If no such scope and object exists, the result is (nil, nil).
		//
		// Note that obj.Parent() may be different from the returned scope if the
		// object was inserted into the scope and already had a parent at that
		// time (see Insert). This can only happen for dot-imported objects
		// whose scope is the scope of the package that exported them.
	**/
	@:keep
	static public function lookupParent(_s:Ref<Scope>, _name:GoString, _pos:stdgo.go.token.Token.Pos):{var _0:Ref<Scope>; var _1:Object;} {
		Go.cfor(_s != null, _s = _s._parent, {
			{
				var _obj:Object = _s.lookup(_name);
				if ((_obj != null) && (!_pos.isValid() || (_obj._scopePos() <= _pos))) {
					return {_0: _s, _1: _obj};
				};
			};
		});
		return {_0: null, _1: (null : Object)};
	}

	/**
		// Lookup returns the object in scope s with the given name if such an
		// object exists; otherwise the result is nil.
	**/
	@:keep
	static public function lookup(_s:Ref<Scope>, _name:GoString):Object {
		return _resolve(_name, _s._elems[_name]);
	}

	/**
		// Child returns the i'th child scope for 0 <= i < NumChildren().
	**/
	@:keep
	static public function child(_s:Ref<Scope>, _i:GoInt):Ref<Scope> {
		return _s._children[(_i : GoInt)];
	}

	/**
		// NumChildren returns the number of scopes nested in s.
	**/
	@:keep
	static public function numChildren(_s:Ref<Scope>):GoInt {
		return (_s._children.length);
	}

	/**
		// Names returns the scope's element names in sorted order.
	**/
	@:keep
	static public function names(_s:Ref<Scope>):Slice<GoString> {
		var _names = new Slice<GoString>((_s._elems.length : GoInt).toBasic(), 0, ...[for (i in 0...(_s._elems.length : GoInt).toBasic()) ("" : GoString)]);
		var _i:GoInt = (0 : GoInt);
		for (_name => _ in _s._elems) {
			_names[(_i : GoInt)] = _name;
			_i++;
		};
		stdgo.sort.Sort.strings(_names);
		return _names;
	}

	/**
		// Len returns the number of scope elements.
	**/
	@:keep
	static public function len(_s:Ref<Scope>):GoInt {
		return (_s._elems.length);
	}

	/**
		// Parent returns the scope's containing (parent) scope.
	**/
	@:keep
	static public function parent(_s:Ref<Scope>):Ref<Scope> {
		return _s._parent;
	}
}

class T_lazyObject_asInterface {
	@:keep
	public function _setScopePos(_pos:stdgo.go.token.Token.Pos):Void
		__self__.value._setScopePos(_pos);

	@:keep
	public function _scopePos():stdgo.go.token.Token.Pos
		return __self__.value._scopePos();

	@:keep
	public function _sameId(_pkg:Ref<Package>, _name:GoString):Bool
		return __self__.value._sameId(_pkg, _name);

	@:keep
	public function _setParent(_0:Ref<Scope>):Void
		__self__.value._setParent(_0);

	@:keep
	public function _setColor(_color:T_color):Void
		__self__.value._setColor(_color);

	@:keep
	public function _setOrder(_0:GoUInt32):Void
		__self__.value._setOrder(_0);

	@:keep
	public function _setType(_0:Type):Void
		__self__.value._setType(_0);

	@:keep
	public function _color():T_color
		return __self__.value._color();

	@:keep
	public function _order():GoUInt32
		return __self__.value._order();

	@:keep
	public function string():GoString
		return __self__.value.string();

	@:keep
	public function id():GoString
		return __self__.value.id();

	@:keep
	public function exported():Bool
		return __self__.value.exported();

	@:keep
	public function type():Type
		return __self__.value.type();

	@:keep
	public function name():GoString
		return __self__.value.name();

	@:keep
	public function pkg():Ref<Package>
		return __self__.value.pkg();

	@:keep
	public function pos():stdgo.go.token.Token.Pos
		return __self__.value.pos();

	/**
		// stub implementations so *lazyObject implements Object and we can
		// store them directly into Scope.elems.
	**/
	@:keep
	public function parent():Ref<Scope>
		return __self__.value.parent();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_lazyObject>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_lazyObject_asInterface) class T_lazyObject_static_extension {
	@:keep
	static public function _setScopePos(_:Ref<T_lazyObject>, _pos:stdgo.go.token.Token.Pos):Void {
		throw Go.toInterface(("unreachable" : GoString));
	}

	@:keep
	static public function _scopePos(_:Ref<T_lazyObject>):stdgo.go.token.Token.Pos {
		throw Go.toInterface(("unreachable" : GoString));
	}

	@:keep
	static public function _sameId(_:Ref<T_lazyObject>, _pkg:Ref<Package>, _name:GoString):Bool {
		throw Go.toInterface(("unreachable" : GoString));
	}

	@:keep
	static public function _setParent(_:Ref<T_lazyObject>, _0:Ref<Scope>):Void {
		throw Go.toInterface(("unreachable" : GoString));
	}

	@:keep
	static public function _setColor(_:Ref<T_lazyObject>, _color:T_color):Void {
		throw Go.toInterface(("unreachable" : GoString));
	}

	@:keep
	static public function _setOrder(_:Ref<T_lazyObject>, _0:GoUInt32):Void {
		throw Go.toInterface(("unreachable" : GoString));
	}

	@:keep
	static public function _setType(_:Ref<T_lazyObject>, _0:Type):Void {
		throw Go.toInterface(("unreachable" : GoString));
	}

	@:keep
	static public function _color(_:Ref<T_lazyObject>):T_color {
		throw Go.toInterface(("unreachable" : GoString));
	}

	@:keep
	static public function _order(_:Ref<T_lazyObject>):GoUInt32 {
		throw Go.toInterface(("unreachable" : GoString));
	}

	@:keep
	static public function string(_:Ref<T_lazyObject>):GoString {
		throw Go.toInterface(("unreachable" : GoString));
	}

	@:keep
	static public function id(_:Ref<T_lazyObject>):GoString {
		throw Go.toInterface(("unreachable" : GoString));
	}

	@:keep
	static public function exported(_:Ref<T_lazyObject>):Bool {
		throw Go.toInterface(("unreachable" : GoString));
	}

	@:keep
	static public function type(_:Ref<T_lazyObject>):Type {
		throw Go.toInterface(("unreachable" : GoString));
	}

	@:keep
	static public function name(_:Ref<T_lazyObject>):GoString {
		throw Go.toInterface(("unreachable" : GoString));
	}

	@:keep
	static public function pkg(_:Ref<T_lazyObject>):Ref<Package> {
		throw Go.toInterface(("unreachable" : GoString));
	}

	@:keep
	static public function pos(_:Ref<T_lazyObject>):stdgo.go.token.Token.Pos {
		throw Go.toInterface(("unreachable" : GoString));
	}

	/**
		// stub implementations so *lazyObject implements Object and we can
		// store them directly into Scope.elems.
	**/
	@:keep
	static public function parent(_:Ref<T_lazyObject>):Ref<Scope> {
		throw Go.toInterface(("unreachable" : GoString));
	}
}

class Selection_asInterface {
	@:keep
	public function string():GoString
		return __self__.value.string();

	/**
		// Indirect reports whether any pointer indirection was required to get from
		// x to f in x.f.
	**/
	@:keep
	public function indirect():Bool
		return __self__.value.indirect();

	/**
		// Index describes the path from x to f in x.f.
		// The last index entry is the field or method index of the type declaring f;
		// either:
		//
		//  1. the list of declared methods of a named type; or
		//  2. the list of methods of an interface type; or
		//  3. the list of fields of a struct type.
		//
		// The earlier index entries are the indices of the embedded fields implicitly
		// traversed to get from (the type of) x to f, starting at embedding depth 0.
	**/
	@:keep
	public function index():Slice<GoInt>
		return __self__.value.index();

	/**
		// Type returns the type of x.f, which may be different from the type of f.
		// See Selection for more information.
	**/
	@:keep
	public function type():Type
		return __self__.value.type();

	/**
		// Obj returns the object denoted by x.f; a *Var for
		// a field selection, and a *Func in all other cases.
	**/
	@:keep
	public function obj():Object
		return __self__.value.obj();

	/**
		// Recv returns the type of x in x.f.
	**/
	@:keep
	public function recv():Type
		return __self__.value.recv();

	/**
		// Kind returns the selection kind.
	**/
	@:keep
	public function kind():SelectionKind
		return __self__.value.kind();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Selection>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Selection_asInterface) class Selection_static_extension {
	@:keep
	static public function string(_s:Ref<Selection>):GoString {
		return selectionString(_s, null);
	}

	/**
		// Indirect reports whether any pointer indirection was required to get from
		// x to f in x.f.
	**/
	@:keep
	static public function indirect(_s:Ref<Selection>):Bool {
		return _s._indirect;
	}

	/**
		// Index describes the path from x to f in x.f.
		// The last index entry is the field or method index of the type declaring f;
		// either:
		//
		//  1. the list of declared methods of a named type; or
		//  2. the list of methods of an interface type; or
		//  3. the list of fields of a struct type.
		//
		// The earlier index entries are the indices of the embedded fields implicitly
		// traversed to get from (the type of) x to f, starting at embedding depth 0.
	**/
	@:keep
	static public function index(_s:Ref<Selection>):Slice<GoInt> {
		return _s._index;
	}

	/**
		// Type returns the type of x.f, which may be different from the type of f.
		// See Selection for more information.
	**/
	@:keep
	static public function type(_s:Ref<Selection>):Type {
		if (_s._kind == ((1 : SelectionKind))) {
			var _sig:Signature = ((Go.typeAssert((Go.toInterface((Go.typeAssert((Go.toInterface(_s._obj) : Ref<Func>)) : Ref<Func>)
				._object._typ) : Ref<Signature>)) : Ref<Signature>) == null ? null : (Go.typeAssert((Go.toInterface((Go.typeAssert((Go.toInterface(_s._obj) : Ref<Func>)) : Ref<Func>)
					._object._typ) : Ref<Signature>)) : Ref<Signature>).__copy__());
			var _recv:Var = (_sig._recv == null ? null : _sig._recv.__copy__());
			_recv._object._typ = _s._recv;
			_sig._recv = (_recv : Ref<Var>);
			return Go.asInterface((_sig : Ref<Signature>));
		} else if (_s._kind == ((2 : SelectionKind))) {
			var _sig:Signature = ((Go.typeAssert((Go.toInterface((Go.typeAssert((Go.toInterface(_s._obj) : Ref<Func>)) : Ref<Func>)
				._object._typ) : Ref<Signature>)) : Ref<Signature>) == null ? null : (Go.typeAssert((Go.toInterface((Go.typeAssert((Go.toInterface(_s._obj) : Ref<Func>)) : Ref<Func>)
					._object._typ) : Ref<Signature>)) : Ref<Signature>).__copy__());
			var _arg0:Var = (_sig._recv == null ? null : _sig._recv.__copy__());
			_sig._recv = null;
			_arg0._object._typ = _s._recv;
			var _params:Slice<Ref<Var>> = (null : Slice<Ref<Var>>);
			if (_sig._params != null) {
				_params = _sig._params._vars;
			};
			_sig._params = newTuple(...((new Slice<Ref<Var>>(0, 0, (_arg0 : Ref<Var>)) : Slice<Ref<Var>>).__append__(..._params.__toArray__())).__toArray__());
			return Go.asInterface((_sig : Ref<Signature>));
		};
		return _s._obj.type();
	}

	/**
		// Obj returns the object denoted by x.f; a *Var for
		// a field selection, and a *Func in all other cases.
	**/
	@:keep
	static public function obj(_s:Ref<Selection>):Object {
		return _s._obj;
	}

	/**
		// Recv returns the type of x in x.f.
	**/
	@:keep
	static public function recv(_s:Ref<Selection>):Type {
		return _s._recv;
	}

	/**
		// Kind returns the selection kind.
	**/
	@:keep
	static public function kind(_s:Ref<Selection>):SelectionKind {
		return _s._kind;
	}
}

class Signature_asInterface {
	@:keep
	public function string():GoString
		return __self__.value.string();

	@:keep
	public function underlying():Type
		return __self__.value.underlying();

	/**
		// Variadic reports whether the signature s is variadic.
	**/
	@:keep
	public function variadic():Bool
		return __self__.value.variadic();

	/**
		// Results returns the results of signature s, or nil.
	**/
	@:keep
	public function results():Ref<Tuple>
		return __self__.value.results();

	/**
		// Params returns the parameters of signature s, or nil.
	**/
	@:keep
	public function params():Ref<Tuple>
		return __self__.value.params();

	/**
		// RecvTypeParams returns the receiver type parameters of signature s, or nil.
	**/
	@:keep
	public function recvTypeParams():Ref<TypeParamList>
		return __self__.value.recvTypeParams();

	/**
		// TypeParams returns the type parameters of signature s, or nil.
	**/
	@:keep
	public function typeParams():Ref<TypeParamList>
		return __self__.value.typeParams();

	/**
		// Recv returns the receiver of signature s (if a method), or nil if a
		// function. It is ignored when comparing signatures for identity.
		//
		// For an abstract method, Recv returns the enclosing interface either
		// as a *Named or an *Interface. Due to embedding, an interface may
		// contain methods whose receiver type is a different interface.
	**/
	@:keep
	public function recv():Ref<Var>
		return __self__.value.recv();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Signature>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Signature_asInterface) class Signature_static_extension {
	@:keep
	static public function string(_t:Ref<Signature>):GoString {
		return typeString(Go.asInterface(_t), null);
	}

	@:keep
	static public function underlying(_t:Ref<Signature>):Type {
		return Go.asInterface(_t);
	}

	/**
		// Variadic reports whether the signature s is variadic.
	**/
	@:keep
	static public function variadic(_s:Ref<Signature>):Bool {
		return _s._variadic;
	}

	/**
		// Results returns the results of signature s, or nil.
	**/
	@:keep
	static public function results(_s:Ref<Signature>):Ref<Tuple> {
		return _s._results;
	}

	/**
		// Params returns the parameters of signature s, or nil.
	**/
	@:keep
	static public function params(_s:Ref<Signature>):Ref<Tuple> {
		return _s._params;
	}

	/**
		// RecvTypeParams returns the receiver type parameters of signature s, or nil.
	**/
	@:keep
	static public function recvTypeParams(_s:Ref<Signature>):Ref<TypeParamList> {
		return _s._rparams;
	}

	/**
		// TypeParams returns the type parameters of signature s, or nil.
	**/
	@:keep
	static public function typeParams(_s:Ref<Signature>):Ref<TypeParamList> {
		return _s._tparams;
	}

	/**
		// Recv returns the receiver of signature s (if a method), or nil if a
		// function. It is ignored when comparing signatures for identity.
		//
		// For an abstract method, Recv returns the enclosing interface either
		// as a *Named or an *Interface. Due to embedding, an interface may
		// contain methods whose receiver type is a different interface.
	**/
	@:keep
	static public function recv(_s:Ref<Signature>):Ref<Var> {
		return _s._recv;
	}
}

class StdSizes_asInterface {
	@:keep
	public function sizeof(t:Type):GoInt64
		return __self__.value.sizeof(t);

	@:keep
	public function offsetsof(_fields:Slice<Ref<Var>>):Slice<GoInt64>
		return __self__.value.offsetsof(_fields);

	@:keep
	public function alignof_(t:Type):GoInt64
		return __self__.value.alignof_(t);

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<StdSizes>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.StdSizes_asInterface) class StdSizes_static_extension {
	@:keep
	static public function sizeof(_s:Ref<StdSizes>, t:Type):GoInt64 {
		{
			final __type__ = _under(t);
			if (Go.typeEquals((__type__ : Ref<Basic>))) {
				var _t:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
					.value;
				_assert(_isTyped(t));
				var _k:BasicKind = _t._kind;
				if ((_k : GoInt) < (_basicSizes.length)) {
					{
						var _s:GoUInt8 = _basicSizes[(_k : GoInt)];
						if (_s > (0 : GoUInt8)) {
							return (_s : GoInt64);
						};
					};
				};
				if (_k == ((17 : BasicKind))) {
					return _s.wordSize * ("2" : GoInt64);
				};
			} else if (Go.typeEquals((__type__ : Ref<Array_>))) {
				var _t:Ref<Array_> = __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__() == null ? (null : Ref<Array_>) : __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__()
					.value;
				var _n:GoInt64 = _t._len;
				if (_n <= ("0" : GoInt64)) {
					return ("0" : GoInt64);
				};
				var _a:GoInt64 = _s.alignof_(_t._elem);
				var _z:GoInt64 = _s.sizeof(_t._elem);
				return (_align(_z, _a) * (_n - (("1" : GoInt64) : GoInt64))) + _z;
			} else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
				var _t:Ref<Slice_> = __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__() == null ? (null : Ref<Slice_>) : __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__()
					.value;
				return _s.wordSize * ("3" : GoInt64);
			} else if (Go.typeEquals((__type__ : Ref<Struct>))) {
				var _t:Ref<Struct> = __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__() == null ? (null : Ref<Struct>) : __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__()
					.value;
				var _n:GoInt = _t.numFields();
				if (_n == ((0 : GoInt))) {
					return ("0" : GoInt64);
				};
				var _offsets = _s.offsetsof(_t._fields);
				return _offsets[(_n - (1 : GoInt) : GoInt)] + _s.sizeof(_t._fields[(_n - (1 : GoInt) : GoInt)]._object._typ);
			} else if (Go.typeEquals((__type__ : Ref<Interface>))) {
				var _t:Ref<Interface> = __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__() == null ? (null : Ref<Interface>) : __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__()
					.value;
				_assert(!_isTypeParam(t));
				return _s.wordSize * ("2" : GoInt64);
			} else if (Go.typeEquals((__type__ : Ref<TypeParam>)) || Go.typeEquals((__type__ : Ref<Union>))) {
				var _t:Type = __type__ == null ? (null : Type) : cast __type__;
				_unreachable();
			};
		};
		return _s.wordSize;
	}

	@:keep
	static public function offsetsof(_s:Ref<StdSizes>, _fields:Slice<Ref<Var>>):Slice<GoInt64> {
		var _offsets = new Slice<GoInt64>((_fields.length : GoInt).toBasic(), 0, ...[for (i in 0...(_fields.length : GoInt).toBasic()) (0 : GoInt64)]);
		var _o:GoInt64 = (0 : GoInt64);
		for (_i => _f in _fields) {
			var _a:GoInt64 = _s.alignof_(_f._object._typ);
			_o = _align(_o, _a);
			_offsets[(_i : GoInt)] = _o;
			_o = _o + (_s.sizeof(_f._object._typ));
		};
		return _offsets;
	}

	@:keep
	static public function alignof_(_s:Ref<StdSizes>, t:Type):GoInt64 {
		{
			final __type__ = _under(t);
			if (Go.typeEquals((__type__ : Ref<Array_>))) {
				var _t:Ref<Array_> = __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__() == null ? (null : Ref<Array_>) : __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__()
					.value;
				return _s.alignof_(_t._elem);
			} else if (Go.typeEquals((__type__ : Ref<Struct>))) {
				var _t:Ref<Struct> = __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__() == null ? (null : Ref<Struct>) : __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__()
					.value;
				if ((_t._fields.length == (0 : GoInt)) && _isSyncAtomicAlign64(t)) {
					return ("8" : GoInt64);
				};
				var _max:GoInt64 = (("1" : GoInt64) : GoInt64);
				for (_0 => _f in _t._fields) {
					{
						var _a:GoInt64 = _s.alignof_(_f._object._typ);
						if (_a > _max) {
							_max = _a;
						};
					};
				};
				return _max;
			} else if (Go.typeEquals((__type__ : Ref<Slice_>)) || Go.typeEquals((__type__ : Ref<Interface>))) {
				var _t:Type = __type__ == null ? (null : Type) : cast __type__;
				_assert(!_isTypeParam(t));
				return _s.wordSize;
			} else if (Go.typeEquals((__type__ : Ref<Basic>))) {
				var _t:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
					.value;
				if (_t.info() & (32 : BasicInfo) != ((0 : BasicInfo))) {
					return _s.wordSize;
				};
			} else if (Go.typeEquals((__type__ : Ref<TypeParam>)) || Go.typeEquals((__type__ : Ref<Union>))) {
				var _t:Type = __type__ == null ? (null : Type) : cast __type__;
				_unreachable();
			};
		};
		var _a:GoInt64 = _s.sizeof(t);
		if (_a < ("1":GoInt64)) {
			return ("1" : GoInt64);
		};
		if (_isComplex(t)) {
			_a = _a / (("2" : GoInt64));
		};
		if (_a > _s.maxAlign) {
			return _s.maxAlign;
		};
		return _a;
	}
}

class Slice__asInterface {
	@:keep
	public function string():GoString
		return __self__.value.string();

	@:keep
	public function underlying():Type
		return __self__.value.underlying();

	/**
		// Elem returns the element type of slice s.
	**/
	@:keep
	public function elem():Type
		return __self__.value.elem();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Slice_>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Slice__asInterface) class Slice__static_extension {
	@:keep
	static public function string(_t:Ref<Slice_>):GoString {
		return typeString(Go.asInterface(_t), null);
	}

	@:keep
	static public function underlying(_t:Ref<Slice_>):Type {
		return Go.asInterface(_t);
	}

	/**
		// Elem returns the element type of slice s.
	**/
	@:keep
	static public function elem(_s:Ref<Slice_>):Type {
		return _s._elem;
	}
}

class Struct_asInterface {
	@:keep
	public function _markComplete():Void
		__self__.value._markComplete();

	@:keep
	public function string():GoString
		return __self__.value.string();

	@:keep
	public function underlying():Type
		return __self__.value.underlying();

	/**
		// Tag returns the i'th field tag for 0 <= i < NumFields().
	**/
	@:keep
	public function tag(_i:GoInt):GoString
		return __self__.value.tag(_i);

	/**
		// Field returns the i'th field for 0 <= i < NumFields().
	**/
	@:keep
	public function field(_i:GoInt):Ref<Var>
		return __self__.value.field(_i);

	/**
		// NumFields returns the number of fields in the struct (including blank and embedded fields).
	**/
	@:keep
	public function numFields():GoInt
		return __self__.value.numFields();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Struct>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Struct_asInterface) class Struct_static_extension {
	@:keep
	static public function _markComplete(_s:Ref<Struct>):Void {
		if (_s._fields == null) {
			_s._fields = new Slice<Ref<Var>>((0 : GoInt).toBasic(), 0, ...[for (i in 0...(0 : GoInt).toBasic()) (null : Ref<Var>)]);
		};
	}

	@:keep
	static public function string(_t:Ref<Struct>):GoString {
		return typeString(Go.asInterface(_t), null);
	}

	@:keep
	static public function underlying(_t:Ref<Struct>):Type {
		return Go.asInterface(_t);
	}

	/**
		// Tag returns the i'th field tag for 0 <= i < NumFields().
	**/
	@:keep
	static public function tag(_s:Ref<Struct>, _i:GoInt):GoString {
		if (_i < (_s._tags.length)) {
			return _s._tags[(_i : GoInt)];
		};
		return Go.str();
	}

	/**
		// Field returns the i'th field for 0 <= i < NumFields().
	**/
	@:keep
	static public function field(_s:Ref<Struct>, _i:GoInt):Ref<Var> {
		return _s._fields[(_i : GoInt)];
	}

	/**
		// NumFields returns the number of fields in the struct (including blank and embedded fields).
	**/
	@:keep
	static public function numFields(_s:Ref<Struct>):GoInt {
		return (_s._fields.length);
	}
}

class T_subster_asInterface {
	@:keep
	public function _termlist(_in:Slice<Ref<Term>>):{var _0:Slice<Ref<Term>>; var _1:Bool;}
		return __self__.value._termlist(_in);

	@:keep
	public function _typeList(_in:Slice<Type>):{var _0:Slice<Type>; var _1:Bool;}
		return __self__.value._typeList(_in);

	@:keep
	public function _funcList(_in:Slice<Ref<Func>>):{var _0:Slice<Ref<Func>>; var _1:Bool;}
		return __self__.value._funcList(_in);

	@:keep
	public function _func_(_f:Ref<Func>):Ref<Func>
		return __self__.value._func_(_f);

	@:keep
	public function _varList(_in:Slice<Ref<Var>>):{var _0:Slice<Ref<Var>>; var _1:Bool;}
		return __self__.value._varList(_in);

	@:keep
	public function _tuple(_t:Ref<Tuple>):Ref<Tuple>
		return __self__.value._tuple(_t);

	@:keep
	public function _var_(_v:Ref<Var>):Ref<Var>
		return __self__.value._var_(_v);

	/**
		// typOrNil is like typ but if the argument is nil it is replaced with Typ[Invalid].
		// A nil type may appear in pathological cases such as type T[P any] []func(_ T([]_))
		// where an array/slice element is accessed before it is set up.
	**/
	@:keep
	public function _typOrNil(_typ:Type):Type
		return __self__.value._typOrNil(_typ);

	@:keep
	public function _typ(_typ:Type):Type
		return __self__.value._typ(_typ);

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_subster>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_subster_asInterface) class T_subster_static_extension {
	@:keep
	static public function _termlist(_subst:Ref<T_subster>, _in:Slice<Ref<Term>>):{var _0:Slice<Ref<Term>>; var _1:Bool;} {
		var _out:Slice<Ref<Term>> = (null : Slice<Ref<Term>>),
			_copied:Bool = false;
		_out = _in;
		for (_i => _t in _in) {
			{
				var _u:Type = _subst._typ(_t._typ);
				if (Go.toInterface(_u) != (Go.toInterface(_t._typ))) {
					if (!_copied) {
						var _new = new Slice<Ref<Term>>((_in.length : GoInt).toBasic(), 0,
							...[for (i in 0...(_in.length : GoInt).toBasic()) (null : Ref<Term>)]);
						Go.copySlice(_new, _out);
						_out = _new;
						_copied = true;
					};
					_out[(_i : GoInt)] = newTerm(_t._tilde, _u);
				};
			};
		};
		return {_0: _out, _1: _copied};
	}

	@:keep
	static public function _typeList(_subst:Ref<T_subster>, _in:Slice<Type>):{var _0:Slice<Type>; var _1:Bool;} {
		var _out:Slice<Type> = (null : Slice<Type>), _copied:Bool = false;
		_out = _in;
		for (_i => _t in _in) {
			{
				var _u:Type = _subst._typ(_t);
				if (Go.toInterface(_u) != (Go.toInterface(_t))) {
					if (!_copied) {
						var _new = new Slice<Type>((_in.length : GoInt).toBasic(), 0, ...[for (i in 0...(_in.length : GoInt).toBasic()) (null : Type)]);
						Go.copySlice(_new, _out);
						_out = _new;
						_copied = true;
					};
					_out[(_i : GoInt)] = _u;
				};
			};
		};
		return {_0: _out, _1: _copied};
	}

	@:keep
	static public function _funcList(_subst:Ref<T_subster>, _in:Slice<Ref<Func>>):{var _0:Slice<Ref<Func>>; var _1:Bool;} {
		var _out:Slice<Ref<Func>> = (null : Slice<Ref<Func>>),
			_copied:Bool = false;
		_out = _in;
		for (_i => _f in _in) {
			{
				var _g = _subst._func_(_f);
				if (_g != (_f)) {
					if (!_copied) {
						var _new = new Slice<Ref<Func>>((_in.length : GoInt).toBasic(), 0,
							...[for (i in 0...(_in.length : GoInt).toBasic()) (null : Ref<Func>)]);
						Go.copySlice(_new, _out);
						_out = _new;
						_copied = true;
					};
					_out[(_i : GoInt)] = _g;
				};
			};
		};
		return {_0: _out, _1: _copied};
	}

	@:keep
	static public function _func_(_subst:Ref<T_subster>, _f:Ref<Func>):Ref<Func> {
		if (_f != null) {
			{
				var _typ:Type = _subst._typ(_f._object._typ);
				if (Go.toInterface(_typ) != (Go.toInterface(_f._object._typ))) {
					return _substFunc(_f, _typ);
				};
			};
		};
		return _f;
	}

	@:keep
	static public function _varList(_subst:Ref<T_subster>, _in:Slice<Ref<Var>>):{var _0:Slice<Ref<Var>>; var _1:Bool;} {
		var _out:Slice<Ref<Var>> = (null : Slice<Ref<Var>>),
			_copied:Bool = false;
		_out = _in;
		for (_i => _v in _in) {
			{
				var _w = _subst._var_(_v);
				if (_w != (_v)) {
					if (!_copied) {
						var _new = new Slice<Ref<Var>>((_in.length : GoInt).toBasic(), 0,
							...[for (i in 0...(_in.length : GoInt).toBasic()) (null : Ref<Var>)]);
						Go.copySlice(_new, _out);
						_out = _new;
						_copied = true;
					};
					_out[(_i : GoInt)] = _w;
				};
			};
		};
		return {_0: _out, _1: _copied};
	}

	@:keep
	static public function _tuple(_subst:Ref<T_subster>, _t:Ref<Tuple>):Ref<Tuple> {
		if (_t != null) {
			{
				var __tmp__ = _subst._varList(_t._vars),
					_vars:Slice<Ref<Var>> = __tmp__._0,
					_copied:Bool = __tmp__._1;
				if (_copied) {
					return (({_vars: _vars} : Tuple) : Ref<Tuple>);
				};
			};
		};
		return _t;
	}

	@:keep
	static public function _var_(_subst:Ref<T_subster>, _v:Ref<Var>):Ref<Var> {
		if (_v != null) {
			{
				var _typ:Type = _subst._typ(_v._object._typ);
				if (Go.toInterface(_typ) != (Go.toInterface(_v._object._typ))) {
					return _substVar(_v, _typ);
				};
			};
		};
		return _v;
	}

	/**
		// typOrNil is like typ but if the argument is nil it is replaced with Typ[Invalid].
		// A nil type may appear in pathological cases such as type T[P any] []func(_ T([]_))
		// where an array/slice element is accessed before it is set up.
	**/
	@:keep
	static public function _typOrNil(_subst:Ref<T_subster>, _typ:Type):Type {
		if (_typ == null) {
			return Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
		};
		return _subst._typ(_typ);
	}

	@:keep
	static public function _typ(_subst:Ref<T_subster>, _typ:Type):Type {
		var __deferstack__:Array<Void->Void> = [];
		{
			final __type__ = _typ;
			if (__type__ == null) {
				var _t:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
				throw Go.toInterface(("nil typ" : GoString));
			} else if (Go.typeEquals((__type__ : Ref<Basic>))) {
				var _t:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
					.value;
			} else if (Go.typeEquals((__type__ : Ref<Array_>))) {
				var _t:Ref<Array_> = __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__() == null ? (null : Ref<Array_>) : __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__()
					.value;
				var _elem:Type = _subst._typOrNil(_t._elem);
				if (Go.toInterface(_elem) != (Go.toInterface(_t._elem))) {
					return Go.asInterface((({_len: _t._len, _elem: _elem} : Array_) : Ref<Array_>));
				};
			} else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
				var _t:Ref<Slice_> = __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__() == null ? (null : Ref<Slice_>) : __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__()
					.value;
				var _elem:Type = _subst._typOrNil(_t._elem);
				if (Go.toInterface(_elem) != (Go.toInterface(_t._elem))) {
					return Go.asInterface((({_elem: _elem} : Slice_) : Ref<Slice_>));
				};
			} else if (Go.typeEquals((__type__ : Ref<Struct>))) {
				var _t:Ref<Struct> = __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__() == null ? (null : Ref<Struct>) : __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__()
					.value;
				{
					var __tmp__ = _subst._varList(_t._fields),
						_fields:Slice<Ref<Var>> = __tmp__._0,
						_copied:Bool = __tmp__._1;
					if (_copied) {
						var _s = (({_fields: _fields, _tags: _t._tags} : Struct) : Ref<Struct>);
						_s._markComplete();
						return Go.asInterface(_s);
					};
				};
			} else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
				var _t:Ref<Pointer_> = __type__ == null ? (null : Ref<Pointer_>) : __type__.__underlying__() == null ? (null : Ref<Pointer_>) : __type__ == null ? (null : Ref<Pointer_>) : __type__.__underlying__()
					.value;
				var _base:Type = _subst._typ(_t._base);
				if (Go.toInterface(_base) != (Go.toInterface(_t._base))) {
					return Go.asInterface((({_base: _base} : Pointer_) : Ref<Pointer_>));
				};
			} else if (Go.typeEquals((__type__ : Ref<Tuple>))) {
				var _t:Ref<Tuple> = __type__ == null ? (null : Ref<Tuple>) : __type__.__underlying__() == null ? (null : Ref<Tuple>) : __type__ == null ? (null : Ref<Tuple>) : __type__.__underlying__()
					.value;
				return Go.asInterface(_subst._tuple(_t));
			} else if (Go.typeEquals((__type__ : Ref<Signature>))) {
				var _t:Ref<Signature> = __type__ == null ? (null : Ref<Signature>) : __type__.__underlying__() == null ? (null : Ref<Signature>) : __type__ == null ? (null : Ref<Signature>) : __type__.__underlying__()
					.value;
				var _recv = _t._recv;
				var _params = _subst._tuple(_t._params);
				var _results = _subst._tuple(_t._results);
				if ((_params != _t._params) || (_results != _t._results)) {
					return Go.asInterface((({
						_rparams: _t._rparams,
						_tparams: _t._tparams,
						_recv: _recv,
						_params: _params,
						_results: _results,
						_variadic: _t._variadic
					} : Signature) : Ref<Signature>));
				};
			} else if (Go.typeEquals((__type__ : Ref<Union>))) {
				var _t:Ref<Union> = __type__ == null ? (null : Ref<Union>) : __type__.__underlying__() == null ? (null : Ref<Union>) : __type__ == null ? (null : Ref<Union>) : __type__.__underlying__()
					.value;
				var __tmp__ = _subst._termlist(_t._terms),
					_terms:Slice<Ref<Term>> = __tmp__._0,
					_copied:Bool = __tmp__._1;
				if (_copied) {
					return Go.asInterface(((new Union(_terms) : Union) : Ref<Union>));
				};
			} else if (Go.typeEquals((__type__ : Ref<Interface>))) {
				var _t:Ref<Interface> = __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__() == null ? (null : Ref<Interface>) : __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__()
					.value;
				var __tmp__ = _subst._funcList(_t._methods),
					_methods:Slice<Ref<Func>> = __tmp__._0,
					_mcopied:Bool = __tmp__._1;
				var __tmp__ = _subst._typeList(_t._embeddeds),
					_embeddeds:Slice<Type> = __tmp__._0,
					_ecopied:Bool = __tmp__._1;
				if (_mcopied || _ecopied) {
					var _iface = _subst._check._newInterface();
					_iface._embeddeds = _embeddeds;
					_iface._implicit = _t._implicit;
					_iface._complete = _t._complete;
					{
						var __tmp__ = _replaceRecvType(_methods, Go.asInterface(_t), Go.asInterface(_iface));
						_iface._methods = __tmp__._0;
					};
					return Go.asInterface(_iface);
				};
			} else if (Go.typeEquals((__type__ : Ref<Map_>))) {
				var _t:Ref<Map_> = __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__() == null ? (null : Ref<Map_>) : __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__()
					.value;
				var _key:Type = _subst._typ(_t._key);
				var _elem:Type = _subst._typ(_t._elem);
				if ((Go.toInterface(_key) != Go.toInterface(_t._key)) || (Go.toInterface(_elem) != Go.toInterface(_t._elem))) {
					return Go.asInterface((({_key: _key, _elem: _elem} : Map_) : Ref<Map_>));
				};
			} else if (Go.typeEquals((__type__ : Ref<Chan>))) {
				var _t:Ref<Chan> = __type__ == null ? (null : Ref<Chan>) : __type__.__underlying__() == null ? (null : Ref<Chan>) : __type__ == null ? (null : Ref<Chan>) : __type__.__underlying__()
					.value;
				var _elem:Type = _subst._typ(_t._elem);
				if (Go.toInterface(_elem) != (Go.toInterface(_t._elem))) {
					return Go.asInterface((({_dir: _t._dir, _elem: _elem} : Chan) : Ref<Chan>));
				};
			} else if (Go.typeEquals((__type__ : Ref<Named>))) {
				var _t:Ref<Named> = __type__ == null ? (null : Ref<Named>) : __type__.__underlying__() == null ? (null : Ref<Named>) : __type__ == null ? (null : Ref<Named>) : __type__.__underlying__()
					.value;
				var _dump = function(_0:GoString, _1:haxe.Rest<AnyInterface>):Void {};
				if ((_subst._check != null) && false) {
					_subst._check._indent++;
					__deferstack__.unshift(() -> {
						var a = function():Void {
							_subst._check._indent--;
						};
						a();
					});
					_dump = function(_format:GoString, _args:haxe.Rest<AnyInterface>):Void {
						_subst._check._trace(_subst._pos, _format, ..._args.__toArray__());
					};
				};
				var _orig = _t.origin();
				var _n:GoInt = _orig.typeParams().len();
				if (_n == ((0 : GoInt))) {
					_dump((">>> %s is not parameterized" : GoString), Go.toInterface(Go.asInterface(_t)));
					{
						for (defer in __deferstack__) {
							defer();
						};
						return Go.asInterface(_t);
					};
				};
				var _newTArgs:Slice<Type> = (null : Slice<Type>);
				if (_t.typeArgs().len() != (_n)) {
					{
						for (defer in __deferstack__) {
							defer();
						};
						return Go.asInterface(typ[((0 : BasicKind) : GoInt)]);
					};
				};
				_dump((">>> %s already instantiated" : GoString), Go.toInterface(Go.asInterface(_t)));
				for (_i => _targ in _t.typeArgs()._list()) {
					_dump((">>> %d targ = %s" : GoString), Go.toInterface(_i), Go.toInterface(_targ));
					var _new_targ:Type = _subst._typ(_targ);
					if (Go.toInterface(_new_targ) != (Go.toInterface(_targ))) {
						_dump((">>> substituted %d targ %s => %s" : GoString), Go.toInterface(_i), Go.toInterface(_targ), Go.toInterface(_new_targ));
						if (_newTArgs == null) {
							_newTArgs = new Slice<Type>((_n : GoInt).toBasic(), 0, ...[for (i in 0...(_n : GoInt).toBasic()) (null : Type)]);
							Go.copySlice(_newTArgs, _t.typeArgs()._list());
						};
						_newTArgs[(_i : GoInt)] = _new_targ;
					};
				};
				if (_newTArgs == null) {
					_dump((">>> nothing to substitute in %s" : GoString), Go.toInterface(Go.asInterface(_t)));
					{
						for (defer in __deferstack__) {
							defer();
						};
						return Go.asInterface(_t);
					};
				};
				{
					for (defer in __deferstack__) {
						defer();
					};
					return _subst._check._instance(_subst._pos, Go.asInterface(_orig), _newTArgs, _subst._expanding, _subst._ctxt);
				};
			} else if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
				var _t:Ref<TypeParam> = __type__ == null ? (null : Ref<TypeParam>) : __type__.__underlying__() == null ? (null : Ref<TypeParam>) : __type__ == null ? (null : Ref<TypeParam>) : __type__.__underlying__()
					.value;
				{
					for (defer in __deferstack__) {
						defer();
					};
					return _subst._smap._lookup(_t);
				};
			} else {
				var _t:Type = __type__ == null ? (null : Type) : cast __type__;
				throw Go.toInterface(("unimplemented" : GoString));
			};
		};
		{
			for (defer in __deferstack__) {
				defer();
			};
			return _typ;
		};
		try {
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return (null : Type);
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return (null : Type);
		};
	}
}

class Tuple_asInterface {
	@:keep
	public function string():GoString
		return __self__.value.string();

	@:keep
	public function underlying():Type
		return __self__.value.underlying();

	/**
		// At returns the i'th variable of tuple t.
	**/
	@:keep
	public function at(_i:GoInt):Ref<Var>
		return __self__.value.at(_i);

	/**
		// Len returns the number variables of tuple t.
	**/
	@:keep
	public function len():GoInt
		return __self__.value.len();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Tuple>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Tuple_asInterface) class Tuple_static_extension {
	@:keep
	static public function string(_t:Ref<Tuple>):GoString {
		return typeString(Go.asInterface(_t), null);
	}

	@:keep
	static public function underlying(_t:Ref<Tuple>):Type {
		return Go.asInterface(_t);
	}

	/**
		// At returns the i'th variable of tuple t.
	**/
	@:keep
	static public function at(_t:Ref<Tuple>, _i:GoInt):Ref<Var> {
		return _t._vars[(_i : GoInt)];
	}

	/**
		// Len returns the number variables of tuple t.
	**/
	@:keep
	static public function len(_t:Ref<Tuple>):GoInt {
		if (_t != null) {
			return (_t._vars.length);
		};
		return (0 : GoInt);
	}
}

class TypeParamList_asInterface {
	/**
		// list is for internal use where we expect a []*TypeParam.
		// TODO(rfindley): list should probably be eliminated: we can pass around a
		// TypeParamList instead.
	**/
	@:keep
	public function _list():Slice<Ref<TypeParam>>
		return __self__.value._list();

	/**
		// At returns the i'th type parameter in the list.
	**/
	@:keep
	public function at(_i:GoInt):Ref<TypeParam>
		return __self__.value.at(_i);

	/**
		// Len returns the number of type parameters in the list.
		// It is safe to call on a nil receiver.
	**/
	@:keep
	public function len():GoInt
		return __self__.value.len();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<TypeParamList>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.TypeParamList_asInterface) class TypeParamList_static_extension {
	/**
		// list is for internal use where we expect a []*TypeParam.
		// TODO(rfindley): list should probably be eliminated: we can pass around a
		// TypeParamList instead.
	**/
	@:keep
	static public function _list(_l:Ref<TypeParamList>):Slice<Ref<TypeParam>> {
		if (_l == null) {
			return (null : Slice<Ref<TypeParam>>);
		};
		return _l._tparams;
	}

	/**
		// At returns the i'th type parameter in the list.
	**/
	@:keep
	static public function at(_l:Ref<TypeParamList>, _i:GoInt):Ref<TypeParam> {
		return _l._tparams[(_i : GoInt)];
	}

	/**
		// Len returns the number of type parameters in the list.
		// It is safe to call on a nil receiver.
	**/
	@:keep
	static public function len(_l:Ref<TypeParamList>):GoInt {
		return (_l._list().length);
	}
}

class TypeList_asInterface {
	/**
		// list is for internal use where we expect a []Type.
		// TODO(rfindley): list should probably be eliminated: we can pass around a
		// TypeList instead.
	**/
	@:keep
	public function _list():Slice<Type>
		return __self__.value._list();

	/**
		// At returns the i'th type in the list.
	**/
	@:keep
	public function at(_i:GoInt):Type
		return __self__.value.at(_i);

	/**
		// Len returns the number of types in the list.
		// It is safe to call on a nil receiver.
	**/
	@:keep
	public function len():GoInt
		return __self__.value.len();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<TypeList>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.TypeList_asInterface) class TypeList_static_extension {
	/**
		// list is for internal use where we expect a []Type.
		// TODO(rfindley): list should probably be eliminated: we can pass around a
		// TypeList instead.
	**/
	@:keep
	static public function _list(_l:Ref<TypeList>):Slice<Type> {
		if (_l == null) {
			return (null : Slice<Type>);
		};
		return _l._types;
	}

	/**
		// At returns the i'th type in the list.
	**/
	@:keep
	static public function at(_l:Ref<TypeList>, _i:GoInt):Type {
		return _l._types[(_i : GoInt)];
	}

	/**
		// Len returns the number of types in the list.
		// It is safe to call on a nil receiver.
	**/
	@:keep
	static public function len(_l:Ref<TypeList>):GoInt {
		return (_l._list().length);
	}
}

class TypeParam_asInterface {
	/**
		// underIs calls f with the underlying types of the specific type terms
		// of t's constraint and reports whether all calls to f returned true.
		// If there are no specific terms, underIs returns the result of f(nil).
	**/
	@:keep
	public function _underIs(_f:Type->Bool):Bool
		return __self__.value._underIs(_f);

	/**
		// is calls f with the specific type terms of t's constraint and reports whether
		// all calls to f returned true. If there are no specific terms, is
		// returns the result of f(nil).
	**/
	@:keep
	public function _is(_f:Ref<T_term>->Bool):Bool
		return __self__.value._is(_f);

	/**
		// iface returns the constraint interface of t.
	**/
	@:keep
	public function _iface():Ref<Interface>
		return __self__.value._iface();

	@:keep
	public function _cleanup():Void
		__self__.value._cleanup();

	@:keep
	public function string():GoString
		return __self__.value.string();

	@:keep
	public function underlying():Type
		return __self__.value.underlying();

	/**
		// SetConstraint sets the type constraint for t.
		//
		// It must be called by users of NewTypeParam after the bound's underlying is
		// fully defined, and before using the type parameter in any way other than to
		// form other types. Once SetConstraint returns the receiver, t is safe for
		// concurrent use.
	**/
	@:keep
	public function setConstraint(_bound:Type):Void
		__self__.value.setConstraint(_bound);

	/**
		// Constraint returns the type constraint specified for t.
	**/
	@:keep
	public function constraint():Type
		return __self__.value.constraint();

	/**
		// Obj returns the type name for t.
	**/
	@:keep
	public function obj():Ref<TypeName>
		return __self__.value.obj();

	/**
		// Index returns the index of the type param within its param list, or -1 if
		// the type parameter has not yet been bound to a type.
	**/
	@:keep
	public function index():GoInt
		return __self__.value.index();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<TypeParam>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.TypeParam_asInterface) class TypeParam_static_extension {
	/**
		// underIs calls f with the underlying types of the specific type terms
		// of t's constraint and reports whether all calls to f returned true.
		// If there are no specific terms, underIs returns the result of f(nil).
	**/
	@:keep
	static public function _underIs(_t:Ref<TypeParam>, _f:Type->Bool):Bool {
		return _t._iface()._typeSet()._underIs(_f);
	}

	/**
		// is calls f with the specific type terms of t's constraint and reports whether
		// all calls to f returned true. If there are no specific terms, is
		// returns the result of f(nil).
	**/
	@:keep
	static public function _is(_t:Ref<TypeParam>, _f:Ref<T_term>->Bool):Bool {
		return _t._iface()._typeSet()._is(_f);
	}

	/**
		// iface returns the constraint interface of t.
	**/
	@:keep
	static public function _iface(_t:Ref<TypeParam>):Ref<Interface> {
		var _bound:Type = _t._bound;
		var _ityp:Ref<Interface> = (null : Ref<Interface>);
		{
			final __type__ = _under(_bound);
			if (Go.typeEquals((__type__ : Ref<Basic>))) {
				var _u:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
					.value;
				if (_u == (typ[((0 : BasicKind) : GoInt)])) {
					return (_emptyInterface : Ref<Interface>);
				};
			} else if (Go.typeEquals((__type__ : Ref<Interface>))) {
				var _u:Ref<Interface> = __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__() == null ? (null : Ref<Interface>) : __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__()
					.value;
				if (_isTypeParam(_bound)) {
					return (_emptyInterface : Ref<Interface>);
				};
				_ityp = _u;
			};
		};
		if (_ityp == null) {
			_ityp = newInterfaceType((null : Slice<Ref<Func>>), (new Slice<Type>(0, 0, _bound) : Slice<Type>));
			_ityp._implicit = true;
			_t._bound = Go.asInterface(_ityp);
		};
		if (_ityp._tset == null) {
			var _pos:stdgo.go.token.Token.Pos = _t._obj._object._pos;
			{
				var __tmp__ = try {
					{value: (Go.typeAssert((Go.toInterface(_bound) : Ref<Named>)) : Ref<Named>), ok: true};
				} catch (_) {
					{value: (null : Ref<Named>), ok: false};
				}, _n = __tmp__.value, _10 = __tmp__.ok;
				if (_n != null) {
					_pos = _n._obj._object._pos;
				};
			};
			_computeInterfaceTypeSet(_t._check, _pos, _ityp);
		};
		return _ityp;
	}

	@:keep
	static public function _cleanup(_t:Ref<TypeParam>):Void {
		_t._iface();
		_t._check = null;
	}

	@:keep
	static public function string(_t:Ref<TypeParam>):GoString {
		return typeString(Go.asInterface(_t), null);
	}

	@:keep
	static public function underlying(_t:Ref<TypeParam>):Type {
		return Go.asInterface(_t._iface());
	}

	/**
		// SetConstraint sets the type constraint for t.
		//
		// It must be called by users of NewTypeParam after the bound's underlying is
		// fully defined, and before using the type parameter in any way other than to
		// form other types. Once SetConstraint returns the receiver, t is safe for
		// concurrent use.
	**/
	@:keep
	static public function setConstraint(_t:Ref<TypeParam>, _bound:Type):Void {
		if (_bound == null) {
			throw Go.toInterface(("nil constraint" : GoString));
		};
		_t._bound = _bound;
		_t._iface();
	}

	/**
		// Constraint returns the type constraint specified for t.
	**/
	@:keep
	static public function constraint(_t:Ref<TypeParam>):Type {
		return _t._bound;
	}

	/**
		// Obj returns the type name for t.
	**/
	@:keep
	static public function obj(_t:Ref<TypeParam>):Ref<TypeName> {
		return _t._obj;
	}

	/**
		// Index returns the index of the type param within its param list, or -1 if
		// the type parameter has not yet been bound to a type.
	**/
	@:keep
	static public function index(_t:Ref<TypeParam>):GoInt {
		return _t._index;
	}
}

class T__TypeSet_asInterface {
	/**
		// underIs calls f with the underlying types of the specific type terms
		// of s and reports whether all calls to f returned true. If there are
		// no specific terms, underIs returns the result of f(nil).
	**/
	@:keep
	public function _underIs(_f:Type->Bool):Bool
		return __self__.value._underIs(_f);

	/**
		// is calls f with the specific type terms of s and reports whether
		// all calls to f returned true. If there are no specific terms, is
		// returns the result of f(nil).
	**/
	@:keep
	public function _is(_f:Ref<T_term>->Bool):Bool
		return __self__.value._is(_f);

	/**
		// subsetOf reports whether s1 ⊆ s2.
	**/
	@:keep
	public function _subsetOf(_s2:Ref<T__TypeSet>):Bool
		return __self__.value._subsetOf(_s2);

	/**
		// hasTerms reports whether the type set has specific type terms.
	**/
	@:keep
	public function _hasTerms():Bool
		return __self__.value._hasTerms();

	@:keep
	public function string():GoString
		return __self__.value.string();

	/**
		// LookupMethod returns the index of and method with matching package and name, or (-1, nil).
	**/
	@:keep
	public function lookupMethod(_pkg:Ref<Package>, _name:GoString, _foldCase:Bool):{var _0:GoInt; var _1:Ref<Func>;}
		return __self__.value.lookupMethod(_pkg, _name, _foldCase);

	/**
		// Method returns the i'th method of type set s for 0 <= i < s.NumMethods().
		// The methods are ordered by their unique ID.
	**/
	@:keep
	public function method(_i:GoInt):Ref<Func>
		return __self__.value.method(_i);

	/**
		// NumMethods returns the number of methods available.
	**/
	@:keep
	public function numMethods():GoInt
		return __self__.value.numMethods();

	/**
		// IsComparable reports whether each type in the set is comparable.
	**/
	@:keep
	public function isComparable(_seen:GoMap<Type, Bool>):Bool
		return __self__.value.isComparable(_seen);

	/**
		// IsMethodSet reports whether the interface t is fully described by its method set.
	**/
	@:keep
	public function isMethodSet():Bool
		return __self__.value.isMethodSet();

	/**
		// IsAll reports whether type set s is the set of all types (corresponding to the empty interface).
	**/
	@:keep
	public function isAll():Bool
		return __self__.value.isAll();

	/**
		// IsEmpty reports whether type set s is the empty set.
	**/
	@:keep
	public function isEmpty():Bool
		return __self__.value.isEmpty();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T__TypeSet>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T__TypeSet_asInterface) class T__TypeSet_static_extension {
	/**
		// underIs calls f with the underlying types of the specific type terms
		// of s and reports whether all calls to f returned true. If there are
		// no specific terms, underIs returns the result of f(nil).
	**/
	@:keep
	static public function _underIs(_s:Ref<T__TypeSet>, _f:Type->Bool):Bool {
		if (!_s._hasTerms()) {
			return _f((null : Type));
		};
		for (_0 => _t in _s._terms) {
			_assert(_t._typ != null);
			var _u:Type = _t._typ;
			if (!_t._tilde) {
				_u = _under(_u);
			};
			if (false) {
				_assert(identical(_u, _under(_u)));
			};
			if (!_f(_u)) {
				return false;
			};
		};
		return true;
	}

	/**
		// is calls f with the specific type terms of s and reports whether
		// all calls to f returned true. If there are no specific terms, is
		// returns the result of f(nil).
	**/
	@:keep
	static public function _is(_s:Ref<T__TypeSet>, _f:Ref<T_term>->Bool):Bool {
		if (!_s._hasTerms()) {
			return _f((null : Ref<T_term>));
		};
		for (_0 => _t in _s._terms) {
			_assert(_t._typ != null);
			if (!_f(_t)) {
				return false;
			};
		};
		return true;
	}

	/**
		// subsetOf reports whether s1 ⊆ s2.
	**/
	@:keep
	static public function _subsetOf(_s1:Ref<T__TypeSet>, _s2:Ref<T__TypeSet>):Bool {
		return _s1._terms._subsetOf(_s2._terms);
	}

	/**
		// hasTerms reports whether the type set has specific type terms.
	**/
	@:keep
	static public function _hasTerms(_s:Ref<T__TypeSet>):Bool {
		return !_s._terms._isEmpty() && !_s._terms._isAll();
	}

	@:keep
	static public function string(_s:Ref<T__TypeSet>):GoString {
		if (_s.isEmpty()) {
			return ("∅" : GoString);
		} else if (_s.isAll()) {
			return ("𝓤" : GoString);
		};
		var _hasMethods:Bool = (_s._methods.length) > (0 : GoInt);
		var _hasTerms:Bool = _s._hasTerms();
		var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
		_buf.writeByte((123 : GoUInt8));
		if (_s._comparable) {
			_buf.writeString(("comparable" : GoString));
			if (_hasMethods || _hasTerms) {
				_buf.writeString(("; " : GoString));
			};
		};
		for (_i => _m in _s._methods) {
			if (_i > (0 : GoInt)) {
				_buf.writeString(("; " : GoString));
			};
			_buf.writeString((_m.string() : GoString));
		};
		if (_hasMethods && _hasTerms) {
			_buf.writeString(("; " : GoString));
		};
		if (_hasTerms) {
			_buf.writeString((_s._terms.string() : GoString));
		};
		_buf.writeString(("}" : GoString));
		return (_buf.string() : GoString);
	}

	/**
		// LookupMethod returns the index of and method with matching package and name, or (-1, nil).
	**/
	@:keep
	static public function lookupMethod(_s:Ref<T__TypeSet>, _pkg:Ref<Package>, _name:GoString, _foldCase:Bool):{var _0:GoInt; var _1:Ref<Func>;} {
		return _lookupMethod(_s._methods, _pkg, _name, _foldCase);
	}

	/**
		// Method returns the i'th method of type set s for 0 <= i < s.NumMethods().
		// The methods are ordered by their unique ID.
	**/
	@:keep
	static public function method(_s:Ref<T__TypeSet>, _i:GoInt):Ref<Func> {
		return _s._methods[(_i : GoInt)];
	}

	/**
		// NumMethods returns the number of methods available.
	**/
	@:keep
	static public function numMethods(_s:Ref<T__TypeSet>):GoInt {
		return (_s._methods.length);
	}

	/**
		// IsComparable reports whether each type in the set is comparable.
	**/
	@:keep
	static public function isComparable(_s:Ref<T__TypeSet>, _seen:GoMap<Type, Bool>):Bool {
		if (_s._terms._isAll()) {
			return _s._comparable;
		};
		return _s._is(function(_t:Ref<T_term>):Bool {
			return (_t != null) && _comparable(_t._typ, false, _seen, null);
		});
	}

	/**
		// IsMethodSet reports whether the interface t is fully described by its method set.
	**/
	@:keep
	static public function isMethodSet(_s:Ref<T__TypeSet>):Bool {
		return !_s._comparable && _s._terms._isAll();
	}

	/**
		// IsAll reports whether type set s is the set of all types (corresponding to the empty interface).
	**/
	@:keep
	static public function isAll(_s:Ref<T__TypeSet>):Bool {
		return _s.isMethodSet() && (_s._methods.length == (0 : GoInt));
	}

	/**
		// IsEmpty reports whether type set s is the empty set.
	**/
	@:keep
	static public function isEmpty(_s:Ref<T__TypeSet>):Bool {
		return _s._terms._isEmpty();
	}
}

class T_typeWriter_asInterface {
	@:keep
	public function _signature(_sig:Ref<Signature>):Void
		__self__.value._signature(_sig);

	@:keep
	public function _tuple(_tup:Ref<Tuple>, _variadic:Bool):Void
		__self__.value._tuple(_tup, _variadic);

	@:keep
	public function _typeName(_obj:Ref<TypeName>):Void
		__self__.value._typeName(_obj);

	@:keep
	public function _tParamList(_list:Slice<Ref<TypeParam>>):Void
		__self__.value._tParamList(_list);

	@:keep
	public function _typeList(_list:Slice<Type>):Void
		__self__.value._typeList(_list);

	/**
		// typeSet writes a canonical hash for an interface type set.
	**/
	@:keep
	public function _typeSet(_s:Ref<T__TypeSet>):Void
		__self__.value._typeSet(_s);

	@:keep
	public function _typ(_typ:Type):Void
		__self__.value._typ(_typ);

	@:keep
	public function _error(_msg:GoString):Void
		__self__.value._error(_msg);

	@:keep
	public function _string(_s:GoString):Void
		__self__.value._string(_s);

	@:keep
	public function _byte(_b:GoByte):Void
		__self__.value._byte(_b);

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_typeWriter>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_typeWriter_asInterface) class T_typeWriter_static_extension {
	@:keep
	static public function _signature(_w:Ref<T_typeWriter>, _sig:Ref<Signature>):Void {
		var __deferstack__:Array<Void->Void> = [];
		if (_sig.typeParams().len() != ((0 : GoInt))) {
			if (_w._ctxt != null) {
				_assert(_w._tparams == null);
				_w._tparams = _sig.typeParams();
				__deferstack__.unshift(() -> {
					var a = function():Void {
						_w._tparams = null;
					};
					a();
				});
			};
			_w._tParamList(_sig.typeParams()._list());
		};
		try {
			_w._tuple(_sig._params, _sig._variadic);
			var _n:GoInt = _sig._results.len();
			if (_n == ((0 : GoInt))) {
				{
					for (defer in __deferstack__) {
						defer();
					};
					return;
				};
			};
			_w._byte((32 : GoUInt8));
			if ((_n == (1 : GoInt)) && ((_w._ctxt != null) || (_sig._results._vars[(0 : GoInt)]._object._name == Go.str()))) {
				_w._typ(_sig._results._vars[(0 : GoInt)]._object._typ);
				{
					for (defer in __deferstack__) {
						defer();
					};
					return;
				};
			};
			_w._tuple(_sig._results, false);
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return;
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return;
		};
	}

	@:keep
	static public function _tuple(_w:Ref<T_typeWriter>, _tup:Ref<Tuple>, _variadic:Bool):Void {
		_w._byte((40 : GoUInt8));
		if (_tup != null) {
			for (_i => _v in _tup._vars) {
				if (_i > (0 : GoInt)) {
					_w._byte((44 : GoUInt8));
				};
				if ((_w._ctxt == null) && (_v._object._name != Go.str())) {
					_w._string(_v._object._name);
					_w._byte((32 : GoUInt8));
				};
				var _typ:Type = _v._object._typ;
				if (_variadic && (_i == (_tup._vars.length - (1 : GoInt)))) {
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_typ) : Ref<Slice_>)) : Ref<Slice_>), ok: true};
						} catch (_) {
							{value: (null : Ref<Slice_>), ok: false};
						}, _s = __tmp__.value, _ok = __tmp__.ok;
						if (_ok) {
							_w._string(("..." : GoString));
							_typ = _s._elem;
						} else {
							{
								var __tmp__ = try {
									{value: (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Basic>)) : Ref<Basic>), ok: true};
								} catch (_) {
									{value: (null : Ref<Basic>), ok: false};
								}, _t = __tmp__.value, _0 = __tmp__.ok;
								if ((_t == null) || (_t._kind != (17 : BasicKind))) {
									_w._error(("expected string type" : GoString));
									continue;
								};
							};
							_w._typ(_typ);
							_w._string(("..." : GoString));
							continue;
						};
					};
				};
				_w._typ(_typ);
			};
		};
		_w._byte((41 : GoUInt8));
	}

	@:keep
	static public function _typeName(_w:Ref<T_typeWriter>, _obj:Ref<TypeName>):Void {
		if (_obj._object._pkg != null) {
			_writePackage(_w._buf, _obj._object._pkg, _w._qf);
		};
		_w._string(_obj._object._name);
	}

	@:keep
	static public function _tParamList(_w:Ref<T_typeWriter>, _list:Slice<Ref<TypeParam>>):Void {
		_w._byte((91 : GoUInt8));
		var _prev:Type = (null : Type);
		for (_i => _tpar in _list) {
			if (_tpar == null) {
				_w._error(("nil type parameter" : GoString));
				continue;
			};
			if (_i > (0 : GoInt)) {
				if (Go.toInterface(_tpar._bound) != (Go.toInterface(_prev))) {
					_w._byte((32 : GoUInt8));
					_w._typ(_prev);
				};
				_w._byte((44 : GoUInt8));
			};
			_prev = _tpar._bound;
			_w._typ(Go.asInterface(_tpar));
		};
		if (_prev != null) {
			_w._byte((32 : GoUInt8));
			_w._typ(_prev);
		};
		_w._byte((93 : GoUInt8));
	}

	@:keep
	static public function _typeList(_w:Ref<T_typeWriter>, _list:Slice<Type>):Void {
		_w._byte((91 : GoUInt8));
		for (_i => _typ in _list) {
			if (_i > (0 : GoInt)) {
				_w._byte((44 : GoUInt8));
			};
			_w._typ(_typ);
		};
		_w._byte((93 : GoUInt8));
	}

	/**
		// typeSet writes a canonical hash for an interface type set.
	**/
	@:keep
	static public function _typeSet(_w:Ref<T_typeWriter>, _s:Ref<T__TypeSet>):Void {
		_assert(_w._ctxt != null);
		var _first:Bool = true;
		for (_0 => _m in _s._methods) {
			if (!_first) {
				_w._byte((59 : GoUInt8));
			};
			_first = false;
			_w._string(_m._object._name);
			_w._signature((Go.typeAssert((Go.toInterface(_m._object._typ) : Ref<Signature>)) : Ref<Signature>));
		};
		if (_s._terms._isAll()) {} else if (_s._terms._isEmpty()) {
			_w._string((_s._terms.string() : GoString));
		} else {
			var _termHashes:Slice<GoString> = (null : Slice<GoString>);
			for (_1 => T_term_static_extension in _s._terms) {
				var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
				if (T_term_static_extension._tilde) {
					_buf.writeByte((126 : GoUInt8));
				};
				_newTypeHasher((_buf : Ref<stdgo.bytes.Bytes.Buffer>), _w._ctxt)._typ(T_term_static_extension._typ);
				_termHashes = _termHashes.__appendref__((_buf.string() : GoString));
			};
			stdgo.sort.Sort.strings(_termHashes);
			if (!_first) {
				_w._byte((59 : GoUInt8));
			};
			_w._string(stdgo.strings.Strings.join(_termHashes, ("|" : GoString)));
		};
	}

	@:keep
	static public function _typ(_w:Ref<T_typeWriter>, _typ:Type):Void {
		var __deferstack__:Array<Void->Void> = [];
		if (_w._seen[_typ]) {
			_w._error(("cycle to " : GoString) + _goTypeName(_typ));
			return;
		};
		try {
			_w._seen[_typ] = true;
			{
				var _a0 = _w._seen;
				var _a1 = _typ;
				__deferstack__.unshift(() -> if (_a0 != null) _a0.__remove__(_a1));
			};
			{
				final __type__ = _typ;
				{
					var __bool__ = true;
					while (__bool__) {
						__bool__ = false;
						if (__type__ == null) {
							var _t:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
							_w._error(("nil" : GoString));
						} else if (Go.typeEquals((__type__ : Ref<Basic>))) {
							var _t:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
								.value;
							if (stdgo.go.token.Token.isExported(_t._name)) {
								{
									var __tmp__ = try {
										{value: (Go.typeAssert((Go.toInterface(unsafe._scope.lookup(_t._name)) : Ref<TypeName>)) : Ref<TypeName>), ok: true};
									} catch (_) {
										{value: (null : Ref<TypeName>), ok: false};
									}, _obj = __tmp__.value, _0 = __tmp__.ok;
									if (_obj != null) {
										_w._typeName(_obj);
										break;
									};
								};
							};
							_w._string(_t._name);
						} else if (Go.typeEquals((__type__ : Ref<Array_>))) {
							var _t:Ref<Array_> = __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__() == null ? (null : Ref<Array_>) : __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__()
								.value;
							_w._byte((91 : GoUInt8));
							_w._string(stdgo.strconv.Strconv.formatInt(_t._len, (10 : GoInt)));
							_w._byte((93 : GoUInt8));
							_w._typ(_t._elem);
						} else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
							var _t:Ref<Slice_> = __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__() == null ? (null : Ref<Slice_>) : __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__()
								.value;
							_w._string(("[]" : GoString));
							_w._typ(_t._elem);
						} else if (Go.typeEquals((__type__ : Ref<Struct>))) {
							var _t:Ref<Struct> = __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__() == null ? (null : Ref<Struct>) : __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__()
								.value;
							_w._string(("struct{" : GoString));
							for (_i => _f in _t._fields) {
								if (_i > (0 : GoInt)) {
									_w._byte((59 : GoUInt8));
								};
								if (!_f._embedded) {
									_w._string(_f._object._name);
									_w._byte((32 : GoUInt8));
								};
								_w._typ(_f._object._typ);
								{
									var _tag:GoString = _t.tag(_i);
									if (_tag != (Go.str())) {
										_w._byte((32 : GoUInt8));
										_w._string(stdgo.strconv.Strconv.quote(_tag));
									};
								};
							};
							_w._byte((125 : GoUInt8));
						} else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
							var _t:Ref<Pointer_> = __type__ == null ? (null : Ref<Pointer_>) : __type__.__underlying__() == null ? (null : Ref<Pointer_>) : __type__ == null ? (null : Ref<Pointer_>) : __type__.__underlying__()
								.value;
							_w._byte((42 : GoUInt8));
							_w._typ(_t._base);
						} else if (Go.typeEquals((__type__ : Ref<Tuple>))) {
							var _t:Ref<Tuple> = __type__ == null ? (null : Ref<Tuple>) : __type__.__underlying__() == null ? (null : Ref<Tuple>) : __type__ == null ? (null : Ref<Tuple>) : __type__.__underlying__()
								.value;
							_w._tuple(_t, false);
						} else if (Go.typeEquals((__type__ : Ref<Signature>))) {
							var _t:Ref<Signature> = __type__ == null ? (null : Ref<Signature>) : __type__.__underlying__() == null ? (null : Ref<Signature>) : __type__ == null ? (null : Ref<Signature>) : __type__.__underlying__()
								.value;
							_w._string(("func" : GoString));
							_w._signature(_t);
						} else if (Go.typeEquals((__type__ : Ref<Union>))) {
							var _t:Ref<Union> = __type__ == null ? (null : Ref<Union>) : __type__.__underlying__() == null ? (null : Ref<Union>) : __type__ == null ? (null : Ref<Union>) : __type__.__underlying__()
								.value;
							if (_t.len() == ((0 : GoInt))) {
								_w._error(("empty union" : GoString));
								break;
							};
							for (_i => _t in _t._terms) {
								if (_i > (0 : GoInt)) {
									_w._byte((124 : GoUInt8));
								};
								if (_t._tilde) {
									_w._byte((126 : GoUInt8));
								};
								_w._typ(_t._typ);
							};
						} else if (Go.typeEquals((__type__ : Ref<Interface>))) {
							var _t:Ref<Interface> = __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__() == null ? (null : Ref<Interface>) : __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__()
								.value;
							if (_w._ctxt == null) {
								if (Go.toInterface(Go.asInterface(_t)) == (Go.toInterface(_universeAny.type()))) {
									_w._string(("any" : GoString));
									break;
								};
								if (Go.toInterface(Go.asInterface(_t)) == (Go.toInterface((Go.typeAssert((Go.toInterface(_universeComparable.type()) : Ref<Named>)) : Ref<Named>)
									._underlying))) {
									_w._string(("interface{comparable}" : GoString));
									break;
								};
							};
							if (_t._implicit) {
								if ((_t._methods.length == (0 : GoInt)) && (_t._embeddeds.length == (1 : GoInt))) {
									_w._typ(_t._embeddeds[(0 : GoInt)]);
									break;
								};
								_w._string(("/* implicit */ " : GoString));
							};
							_w._string(("interface{" : GoString));
							var _first:Bool = true;
							if (_w._ctxt != null) {
								_w._typeSet(_t._typeSet());
							} else {
								for (_11 => _m in _t._methods) {
									if (!_first) {
										_w._byte((59 : GoUInt8));
									};
									_first = false;
									_w._string(_m._object._name);
									_w._signature((Go.typeAssert((Go.toInterface(_m._object._typ) : Ref<Signature>)) : Ref<Signature>));
								};
								for (_14 => _typ in _t._embeddeds) {
									if (!_first) {
										_w._byte((59 : GoUInt8));
									};
									_first = false;
									_w._typ(_typ);
								};
							};
							_w._byte((125 : GoUInt8));
						} else if (Go.typeEquals((__type__ : Ref<Map_>))) {
							var _t:Ref<Map_> = __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__() == null ? (null : Ref<Map_>) : __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__()
								.value;
							_w._string(("map[" : GoString));
							_w._typ(_t._key);
							_w._byte((93 : GoUInt8));
							_w._typ(_t._elem);
						} else if (Go.typeEquals((__type__ : Ref<Chan>))) {
							var _t:Ref<Chan> = __type__ == null ? (null : Ref<Chan>) : __type__.__underlying__() == null ? (null : Ref<Chan>) : __type__ == null ? (null : Ref<Chan>) : __type__.__underlying__()
								.value;
							var _s:GoString = ("" : GoString);
							var _parens:Bool = false;
							if (_t._dir == ((0 : ChanDir))) {
								_s = ("chan " : GoString);
								{
									var __tmp__ = try {
										{value: (Go.typeAssert((Go.toInterface(_t._elem) : Ref<Chan>)) : Ref<Chan>), ok: true};
									} catch (_) {
										{value: (null : Ref<Chan>), ok: false};
									}, _c = __tmp__.value, _17 = __tmp__.ok;
									if ((_c != null) && (_c._dir == (2 : ChanDir))) {
										_parens = true;
									};
								};
							} else if (_t._dir == ((1 : ChanDir))) {
								_s = ("chan<- " : GoString);
							} else if (_t._dir == ((2 : ChanDir))) {
								_s = ("<-chan " : GoString);
							} else {
								_w._error(("unknown channel direction" : GoString));
							};
							_w._string(_s);
							if (_parens) {
								_w._byte((40 : GoUInt8));
							};
							_w._typ(_t._elem);
							if (_parens) {
								_w._byte((41 : GoUInt8));
							};
						} else if (Go.typeEquals((__type__ : Ref<Named>))) {
							var _t:Ref<Named> = __type__ == null ? (null : Ref<Named>) : __type__.__underlying__() == null ? (null : Ref<Named>) : __type__ == null ? (null : Ref<Named>) : __type__.__underlying__()
								.value;
							if (_w._ctxt != null) {
								_w._string(stdgo.strconv.Strconv.itoa(_w._ctxt._getID(Go.asInterface(_t))));
							};
							_w._typeName(_t._obj);
							if (_t._inst != null) {
								_w._typeList(_t._inst._targs._list());
							} else if ((_w._ctxt == null) && (_t.typeParams().len() != (0 : GoInt))) {
								_w._tParamList(_t.typeParams()._list());
							};
						} else if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
							var _t:Ref<TypeParam> = __type__ == null ? (null : Ref<TypeParam>) : __type__.__underlying__() == null ? (null : Ref<TypeParam>) : __type__ == null ? (null : Ref<TypeParam>) : __type__.__underlying__()
								.value;
							if (_t._obj == null) {
								_w._error(("unnamed type parameter" : GoString));
								break;
							};
							{
								var _i:GoInt = _tparamIndex(_w._tparams._list(), _t);
								if (_i >= (0 : GoInt)) {
									_w._string(stdgo.fmt.Fmt.sprintf(("$$%d" : GoString), Go.toInterface(_i)));
								} else {
									_w._string(_t._obj._object._name);
									if (_w._debug || (_w._ctxt != null)) {
										_w._string(_subscript(_t._id));
									};
								};
							};
						} else {
							var _t:Type = __type__ == null ? (null : Type) : cast __type__;
							_w._string((_t.string() : GoString));
						};
						break;
					};
				};
			};
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return;
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return;
		};
	}

	@:keep
	static public function _error(_w:Ref<T_typeWriter>, _msg:GoString):Void {
		if (_w._ctxt != null) {
			throw Go.toInterface(_msg);
		};
		_w._buf.writeString((("<" : GoString) + _msg) + (">" : GoString));
	}

	@:keep
	static public function _string(_w:Ref<T_typeWriter>, _s:GoString):Void {
		_w._buf.writeString(_s);
	}

	@:keep
	static public function _byte(_w:Ref<T_typeWriter>, _b:GoByte):Void {
		if (_w._ctxt != null) {
			if (_b == ((32 : GoUInt8))) {
				_b = (35 : GoUInt8);
			};
			_w._buf.writeByte(_b);
			return;
		};
		_w._buf.writeByte(_b);
		if ((_b == (44 : GoUInt8)) || (_b == (59 : GoUInt8))) {
			_w._buf.writeByte((32 : GoUInt8));
		};
	}
}

class T_term_asInterface {
	/**
		// disjoint reports whether x ∩ y == ∅.
		// x.typ and y.typ must not be nil.
	**/
	@:keep
	public function _disjoint(_y:Ref<T_term>):Bool
		return __self__.value._disjoint(_y);

	/**
		// subsetOf reports whether x ⊆ y.
	**/
	@:keep
	public function _subsetOf(_y:Ref<T_term>):Bool
		return __self__.value._subsetOf(_y);

	/**
		// includes reports whether t ∈ x.
	**/
	@:keep
	public function _includes(_t:Type):Bool
		return __self__.value._includes(_t);

	/**
		// intersect returns the intersection x ∩ y.
	**/
	@:keep
	public function _intersect(_y:Ref<T_term>):Ref<T_term>
		return __self__.value._intersect(_y);

	/**
		// union returns the union x ∪ y: zero, one, or two non-nil terms.
	**/
	@:keep
	public function _union(_y:Ref<T_term>):{var _0:Ref<T_term>; var _1:Ref<T_term>;}
		return __self__.value._union(_y);

	/**
		// equal reports whether x and y represent the same type set.
	**/
	@:keep
	public function _equal(_y:Ref<T_term>):Bool
		return __self__.value._equal(_y);

	@:keep
	public function string():GoString
		return __self__.value.string();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_term>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_term_asInterface) class T_term_static_extension {
	/**
		// disjoint reports whether x ∩ y == ∅.
		// x.typ and y.typ must not be nil.
	**/
	@:keep
	static public function _disjoint(_x:Ref<T_term>, _y:Ref<T_term>):Bool {
		if (false && ((_x._typ == null) || (_y._typ == null))) {
			throw Go.toInterface(("invalid argument(s)" : GoString));
		};
		var _ux:Type = _x._typ;
		if (_y._tilde) {
			_ux = _under(_ux);
		};
		var _uy:Type = _y._typ;
		if (_x._tilde) {
			_uy = _under(_uy);
		};
		return !identical(_ux, _uy);
	}

	/**
		// subsetOf reports whether x ⊆ y.
	**/
	@:keep
	static public function _subsetOf(_x:Ref<T_term>, _y:Ref<T_term>):Bool {
		if (_x == null) {
			return true;
		} else if (_y == null) {
			return false;
		} else if (_y._typ == null) {
			return true;
		} else if (_x._typ == null) {
			return false;
		};
		if (_x._disjoint(_y)) {
			return false;
		};
		return !_x._tilde || _y._tilde;
	}

	/**
		// includes reports whether t ∈ x.
	**/
	@:keep
	static public function _includes(_x:Ref<T_term>, _t:Type):Bool {
		if (_x == null) {
			return false;
		} else if (_x._typ == null) {
			return true;
		};
		var _u:Type = _t;
		if (_x._tilde) {
			_u = _under(_u);
		};
		return identical(_x._typ, _u);
	}

	/**
		// intersect returns the intersection x ∩ y.
	**/
	@:keep
	static public function _intersect(_x:Ref<T_term>, _y:Ref<T_term>):Ref<T_term> {
		if ((_x == null) || (_y == null)) {
			return (null : Ref<T_term>);
		} else if (_x._typ == null) {
			return _y;
		} else if (_y._typ == null) {
			return _x;
		};
		if (_x._disjoint(_y)) {
			return (null : Ref<T_term>);
		};
		if (!_x._tilde || _y._tilde) {
			return _x;
		};
		return _y;
	}

	/**
		// union returns the union x ∪ y: zero, one, or two non-nil terms.
	**/
	@:keep
	static public function _union(_x:Ref<T_term>, _y:Ref<T_term>):{var _0:Ref<T_term>; var _1:Ref<T_term>;} {
		var _0:Ref<T_term> = (null : Ref<T_term>),
			_1:Ref<T_term> = (null : Ref<T_term>);
		if ((_x == null) && (_y == null)) {
			return {_0: (null : Ref<T_term>), _1: (null : Ref<T_term>)};
		} else if (_x == null) {
			return {_0: _y, _1: (null : Ref<T_term>)};
		} else if (_y == null) {
			return {_0: _x, _1: (null : Ref<T_term>)};
		} else if (_x._typ == null) {
			return {_0: _x, _1: (null : Ref<T_term>)};
		} else if (_y._typ == null) {
			return {_0: _y, _1: (null : Ref<T_term>)};
		};
		if (_x._disjoint(_y)) {
			return {_0: _x, _1: _y};
		};
		if (_x._tilde || !_y._tilde) {
			return {_0: _x, _1: (null : Ref<T_term>)};
		};
		return {_0: _y, _1: (null : Ref<T_term>)};
	}

	/**
		// equal reports whether x and y represent the same type set.
	**/
	@:keep
	static public function _equal(_x:Ref<T_term>, _y:Ref<T_term>):Bool {
		if ((_x == null) || (_y == null)) {
			return _x == (_y);
		} else if ((_x._typ == null) || (_y._typ == null)) {
			return Go.toInterface(_x._typ) == (Go.toInterface(_y._typ));
		};
		return (_x._tilde == _y._tilde) && identical(_x._typ, _y._typ);
	}

	@:keep
	static public function string(_x:Ref<T_term>):GoString {
		if (_x == null) {
			return ("∅" : GoString);
		} else if (_x._typ == null) {
			return ("𝓤" : GoString);
		} else if (_x._tilde) {
			return ("~" : GoString) + (_x._typ.string() : GoString);
		} else {
			return (_x._typ.string() : GoString);
		};
	}
}

class T_unifier_asInterface {
	/**
		// nify implements the core unification algorithm which is an
		// adapted version of Checker.identical. For changes to that
		// code the corresponding changes should be made here.
		// Must not be called directly from outside the unifier.
	**/
	@:keep
	public function _nify(_x:Type, _y:Type, _p:Ref<T_ifacePair>):Bool
		return __self__.value._nify(_x, _y, _p);

	@:keep
	public function _nifyEq(_x:Type, _y:Type, _p:Ref<T_ifacePair>):Bool
		return __self__.value._nifyEq(_x, _y, _p);

	/**
		// join unifies the i'th type parameter of x with the j'th type parameter of y.
		// If both type parameters already have a type associated with them and they are
		// not joined, join fails and returns false.
	**/
	@:keep
	public function _join(_i:GoInt, _j:GoInt):Bool
		return __self__.value._join(_i, _j);

	@:keep
	public function _tracef(_format:GoString, _args:haxe.Rest<AnyInterface>):Void
		__self__.value._tracef(_format, ..._args);

	/**
		// unify attempts to unify x and y and reports whether it succeeded.
	**/
	@:keep
	public function _unify(_x:Type, _y:Type):Bool
		return __self__.value._unify(_x, _y);

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_unifier>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_unifier_asInterface) class T_unifier_static_extension {
	/**
		// nify implements the core unification algorithm which is an
		// adapted version of Checker.identical. For changes to that
		// code the corresponding changes should be made here.
		// Must not be called directly from outside the unifier.
	**/
	@:keep
	static public function _nify(_u:Ref<T_unifier>, _x:Type, _y:Type, _p:Ref<T_ifacePair>):Bool {
		var __deferstack__:Array<Void->Void> = [];
		var _result:Bool = false;
		if (false) {
			_u._tracef(("%s ≡ %s" : GoString), Go.toInterface(_x), Go.toInterface(_y));
		};
		try {
			if (_u._depth >= (50 : GoInt)) {
				if (false) {
					_u._tracef(("depth %d >= %d" : GoString), Go.toInterface(_u._depth), Go.toInterface((50 : GoInt)));
				};
				if (true) {
					throw Go.toInterface(("unification reached recursion depth limit" : GoString));
				};
				return false;
			};
			_u._depth++;
			__deferstack__.unshift(() -> {
				var a = function():Void {
					_u._depth--;
					if (false && !_result) {
						_u._tracef(("%s ≢ %s" : GoString), Go.toInterface(_x), Go.toInterface(_y));
					};
				};
				a();
			});
			if (!_u._exact) {
				{
					var __tmp__ = try {
						{value: (Go.typeAssert((Go.toInterface(_x) : Ref<Named>)) : Ref<Named>), ok: true};
					} catch (_) {
						{value: (null : Ref<Named>), ok: false};
					}, _nx = __tmp__.value, _0 = __tmp__.ok;
					if ((_nx != null) && !_hasName(_y)) {
						if (false) {
							_u._tracef(("under %s ≡ %s" : GoString), Go.toInterface(Go.asInterface(_nx)), Go.toInterface(_y));
						};
						{
							for (defer in __deferstack__) {
								defer();
							};
							return _u._nify(_nx._under(), _y, _p);
						};
					} else {
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Named>)) : Ref<Named>), ok: true};
						} catch (_) {
							{value: (null : Ref<Named>), ok: false};
						}, _ny = __tmp__.value, _1 = __tmp__.ok;
						if ((_ny != null) && !_hasName(_x)) {
							if (false) {
								_u._tracef(("%s ≡ under %s" : GoString), Go.toInterface(_x), Go.toInterface(Go.asInterface(_ny)));
							};
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _u._nify(_x, _ny._under(), _p);
							};
						};
					};
				};
			};
			{
				var _0:GoInt = _u._x._index(_x),
					_1:GoInt = _u._y._index(_y),
					_j:GoInt = _1,
					_i:GoInt = _0;
				if ((_i >= (0 : GoInt)) && (_j >= (0 : GoInt))) {
					if (_u._join(_i, _j)) {
						{
							for (defer in __deferstack__) {
								defer();
							};
							return true;
						};
					};
					{
						for (defer in __deferstack__) {
							defer();
						};
						return _u._nifyEq(_u._x._at(_i), _u._y._at(_j), _p);
					};
				} else if (_i >= (0 : GoInt)) {
					{
						var _tx:Type = _u._x._at(_i);
						if (_tx != null) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _u._nifyEq(_tx, _y, _p);
							};
						};
					};
					_u._x._set(_i, _y);
					{
						for (defer in __deferstack__) {
							defer();
						};
						return true;
					};
				} else if (_j >= (0 : GoInt)) {
					{
						var _ty:Type = _u._y._at(_j);
						if (_ty != null) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _u._nifyEq(_x, _ty, _p);
							};
						};
					};
					_u._y._set(_j, _x);
					{
						for (defer in __deferstack__) {
							defer();
						};
						return true;
					};
				};
			};
			if (true && !_u._exact) {
				if (_isTypeParam(_x) && !_hasName(_y)) {
					{
						var _cx:Type = _coreType(_x);
						if (_cx != null) {
							if (false) {
								_u._tracef(("core %s ≡ %s" : GoString), Go.toInterface(_x), Go.toInterface(_y));
							};
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _u._nify(_cx, _y, _p);
							};
						};
					};
				} else if (_isTypeParam(_y) && !_hasName(_x)) {
					{
						var _cy:Type = _coreType(_y);
						if (_cy != null) {
							if (false) {
								_u._tracef(("%s ≡ core %s" : GoString), Go.toInterface(_x), Go.toInterface(_y));
							};
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _u._nify(_x, _cy, _p);
							};
						};
					};
				};
			};
			{
				final __type__ = _x;
				if (Go.typeEquals((__type__ : Ref<Basic>))) {
					var _x:Ref<Basic> = __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__() == null ? (null : Ref<Basic>) : __type__ == null ? (null : Ref<Basic>) : __type__.__underlying__()
						.value;
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Basic>)) : Ref<Basic>), ok: true};
						} catch (_) {
							{value: (null : Ref<Basic>), ok: false};
						}, _y = __tmp__.value, _ok = __tmp__.ok;
						if (_ok) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _x._kind == (_y._kind);
							};
						};
					};
				} else if (Go.typeEquals((__type__ : Ref<Array_>))) {
					var _x:Ref<Array_> = __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__() == null ? (null : Ref<Array_>) : __type__ == null ? (null : Ref<Array_>) : __type__.__underlying__()
						.value;
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Array_>)) : Ref<Array_>), ok: true};
						} catch (_) {
							{value: (null : Ref<Array_>), ok: false};
						}, _y = __tmp__.value, _ok = __tmp__.ok;
						if (_ok) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return (((_x._len < (("0" : GoInt64) : GoInt64)) || (_y._len < (("0" : GoInt64) : GoInt64)))
									|| (_x._len == _y._len))
									&& _u._nify(_x._elem, _y._elem, _p);
							};
						};
					};
				} else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
					var _x:Ref<Slice_> = __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__() == null ? (null : Ref<Slice_>) : __type__ == null ? (null : Ref<Slice_>) : __type__.__underlying__()
						.value;
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Slice_>)) : Ref<Slice_>), ok: true};
						} catch (_) {
							{value: (null : Ref<Slice_>), ok: false};
						}, _y = __tmp__.value, _ok = __tmp__.ok;
						if (_ok) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _u._nify(_x._elem, _y._elem, _p);
							};
						};
					};
				} else if (Go.typeEquals((__type__ : Ref<Struct>))) {
					var _x:Ref<Struct> = __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__() == null ? (null : Ref<Struct>) : __type__ == null ? (null : Ref<Struct>) : __type__.__underlying__()
						.value;
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Struct>)) : Ref<Struct>), ok: true};
						} catch (_) {
							{value: (null : Ref<Struct>), ok: false};
						}, _y = __tmp__.value, _ok = __tmp__.ok;
						if (_ok) {
							if (_x.numFields() == (_y.numFields())) {
								for (_i => _f in _x._fields) {
									var _g = _y._fields[(_i : GoInt)];
									if ((((_f._embedded != _g._embedded) || (_x.tag(_i) != _y.tag(_i)))
										|| !_f._sameId(_g._object._pkg, _g._object._name))
										|| !_u._nify(_f._object._typ, _g._object._typ, _p)) {
										{
											for (defer in __deferstack__) {
												defer();
											};
											return false;
										};
									};
								};
								{
									for (defer in __deferstack__) {
										defer();
									};
									return true;
								};
							};
						};
					};
				} else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
					var _x:Ref<Pointer_> = __type__ == null ? (null : Ref<Pointer_>) : __type__.__underlying__() == null ? (null : Ref<Pointer_>) : __type__ == null ? (null : Ref<Pointer_>) : __type__.__underlying__()
						.value;
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Pointer_>)) : Ref<Pointer_>), ok: true};
						} catch (_) {
							{value: (null : Ref<Pointer_>), ok: false};
						}, _y = __tmp__.value, _ok = __tmp__.ok;
						if (_ok) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _u._nify(_x._base, _y._base, _p);
							};
						};
					};
				} else if (Go.typeEquals((__type__ : Ref<Tuple>))) {
					var _x:Ref<Tuple> = __type__ == null ? (null : Ref<Tuple>) : __type__.__underlying__() == null ? (null : Ref<Tuple>) : __type__ == null ? (null : Ref<Tuple>) : __type__.__underlying__()
						.value;
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Tuple>)) : Ref<Tuple>), ok: true};
						} catch (_) {
							{value: (null : Ref<Tuple>), ok: false};
						}, _y = __tmp__.value, _ok = __tmp__.ok;
						if (_ok) {
							if (_x.len() == (_y.len())) {
								if (_x != null) {
									for (_i => _v in _x._vars) {
										var _w = _y._vars[(_i : GoInt)];
										if (!_u._nify(_v._object._typ, _w._object._typ, _p)) {
											{
												for (defer in __deferstack__) {
													defer();
												};
												return false;
											};
										};
									};
								};
								{
									for (defer in __deferstack__) {
										defer();
									};
									return true;
								};
							};
						};
					};
				} else if (Go.typeEquals((__type__ : Ref<Signature>))) {
					var _x:Ref<Signature> = __type__ == null ? (null : Ref<Signature>) : __type__.__underlying__() == null ? (null : Ref<Signature>) : __type__ == null ? (null : Ref<Signature>) : __type__.__underlying__()
						.value;
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Signature>)) : Ref<Signature>), ok: true};
						} catch (_) {
							{value: (null : Ref<Signature>), ok: false};
						}, _y = __tmp__.value, _ok = __tmp__.ok;
						if (_ok) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return ((_x._variadic == _y._variadic)
									&& _u._nify(Go.asInterface(_x._params), Go.asInterface(_y._params), _p))
									&& _u._nify(Go.asInterface(_x._results), Go.asInterface(_y._results), _p);
							};
						};
					};
				} else if (Go.typeEquals((__type__ : Ref<Interface>))) {
					var _x:Ref<Interface> = __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__() == null ? (null : Ref<Interface>) : __type__ == null ? (null : Ref<Interface>) : __type__.__underlying__()
						.value;
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Interface>)) : Ref<Interface>), ok: true};
						} catch (_) {
							{value: (null : Ref<Interface>), ok: false};
						}, _y = __tmp__.value, _ok = __tmp__.ok;
						if (_ok) {
							var _xset = _x._typeSet();
							var _yset = _y._typeSet();
							if (_xset._comparable != (_yset._comparable)) {
								{
									for (defer in __deferstack__) {
										defer();
									};
									return false;
								};
							};
							if (!_xset._terms._equal(_yset._terms)) {
								{
									for (defer in __deferstack__) {
										defer();
									};
									return false;
								};
							};
							var _a = _xset._methods;
							var _b = _yset._methods;
							if ((_a.length) == ((_b.length))) {
								var _q = ((new T_ifacePair(_x, _y, _p) : T_ifacePair) : Ref<T_ifacePair>);
								while (_p != null) {
									if (_p._identical(_q)) {
										{
											for (defer in __deferstack__) {
												defer();
											};
											return true;
										};
									};
									_p = _p._prev;
								};
								if (false) {
									_assertSortedMethods(_a);
									_assertSortedMethods(_b);
								};
								for (_i => _f in _a) {
									var _g = _b[(_i : GoInt)];
									if ((_f.id() != _g.id()) || !_u._nify(_f._object._typ, _g._object._typ, _q)) {
										{
											for (defer in __deferstack__) {
												defer();
											};
											return false;
										};
									};
								};
								{
									for (defer in __deferstack__) {
										defer();
									};
									return true;
								};
							};
						};
					};
				} else if (Go.typeEquals((__type__ : Ref<Map_>))) {
					var _x:Ref<Map_> = __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__() == null ? (null : Ref<Map_>) : __type__ == null ? (null : Ref<Map_>) : __type__.__underlying__()
						.value;
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Map_>)) : Ref<Map_>), ok: true};
						} catch (_) {
							{value: (null : Ref<Map_>), ok: false};
						}, _y = __tmp__.value, _ok = __tmp__.ok;
						if (_ok) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return _u._nify(_x._key, _y._key, _p) && _u._nify(_x._elem, _y._elem, _p);
							};
						};
					};
				} else if (Go.typeEquals((__type__ : Ref<Chan>))) {
					var _x:Ref<Chan> = __type__ == null ? (null : Ref<Chan>) : __type__.__underlying__() == null ? (null : Ref<Chan>) : __type__ == null ? (null : Ref<Chan>) : __type__.__underlying__()
						.value;
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Chan>)) : Ref<Chan>), ok: true};
						} catch (_) {
							{value: (null : Ref<Chan>), ok: false};
						}, _y = __tmp__.value, _ok = __tmp__.ok;
						if (_ok) {
							{
								for (defer in __deferstack__) {
									defer();
								};
								return (!_u._exact || (_x._dir == _y._dir)) && _u._nify(_x._elem, _y._elem, _p);
							};
						};
					};
				} else if (Go.typeEquals((__type__ : Ref<Named>))) {
					var _x:Ref<Named> = __type__ == null ? (null : Ref<Named>) : __type__.__underlying__() == null ? (null : Ref<Named>) : __type__ == null ? (null : Ref<Named>) : __type__.__underlying__()
						.value;
					{
						var __tmp__ = try {
							{value: (Go.typeAssert((Go.toInterface(_y) : Ref<Named>)) : Ref<Named>), ok: true};
						} catch (_) {
							{value: (null : Ref<Named>), ok: false};
						}, _y = __tmp__.value, _ok = __tmp__.ok;
						if (_ok) {
							var _xargs = _x.typeArgs()._list();
							var _yargs = _y.typeArgs()._list();
							if ((_xargs.length) != ((_yargs.length))) {
								{
									for (defer in __deferstack__) {
										defer();
									};
									return false;
								};
							};
							if ((_x._obj._object._pkg == _y._obj._object._pkg) && (_x._obj._object._name == _y._obj._object._name)) {
								for (_i => _x in _xargs) {
									if (!_u._nify(_x, _yargs[(_i : GoInt)], _p)) {
										{
											for (defer in __deferstack__) {
												defer();
											};
											return false;
										};
									};
								};
								{
									for (defer in __deferstack__) {
										defer();
									};
									return true;
								};
							};
						};
					};
				} else if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
					var _x:Ref<TypeParam> = __type__ == null ? (null : Ref<TypeParam>) : __type__.__underlying__() == null ? (null : Ref<TypeParam>) : __type__ == null ? (null : Ref<TypeParam>) : __type__.__underlying__()
						.value;
					{
						for (defer in __deferstack__) {
							defer();
						};
						return Go.toInterface(Go.asInterface(_x)) == (Go.toInterface(_y));
					};
				} else if (__type__ == null) {
					var _x:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
				} else {
					var _x:Type = __type__ == null ? (null : Type) : cast __type__;
					throw Go.toInterface(_sprintf(null, null, true, ("u.nify(%s, %s), u.x.tparams = %s" : GoString), Go.toInterface(_x), Go.toInterface(_y),
						Go.toInterface(_u._x._tparams)));
				};
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				return false;
			};
			for (defer in __deferstack__) {
				defer();
			};
			{
				for (defer in __deferstack__) {
					defer();
				};
				if (Go.recover_exception != null)
					throw Go.recover_exception;
				return _result;
			};
		} catch (__exception__) {
			if (!(__exception__.native is AnyInterfaceData))
				throw __exception__;
			Go.recover_exception = __exception__.native;
			for (defer in __deferstack__) {
				defer();
			};
			if (Go.recover_exception != null)
				throw Go.recover_exception;
			return _result;
		};
	}

	@:keep
	static public function _nifyEq(_u:Ref<T_unifier>, _x:Type, _y:Type, _p:Ref<T_ifacePair>):Bool {
		return (Go.toInterface(_x) == Go.toInterface(_y)) || _u._nify(_x, _y, _p);
	}

	/**
		// join unifies the i'th type parameter of x with the j'th type parameter of y.
		// If both type parameters already have a type associated with them and they are
		// not joined, join fails and returns false.
	**/
	@:keep
	static public function _join(_u:Ref<T_unifier>, _i:GoInt, _j:GoInt):Bool {
		if (false) {
			_u._tracef(("%s ⇄ %s" : GoString), Go.toInterface(Go.asInterface(_u._x._tparams[(_i : GoInt)])),
				Go.toInterface(Go.asInterface(_u._y._tparams[(_j : GoInt)])));
		};
		var _ti:GoInt = _u._x._indices[(_i : GoInt)];
		var _tj:GoInt = _u._y._indices[(_j : GoInt)];
		{
			var __switchIndex__ = -1;
			while (true) {
				if ((_ti == (0 : GoInt)) && (_tj == (0 : GoInt))) {
					_u._types = _u._types.__appendref__((null : Type));
					_u._x._indices[(_i : GoInt)] = -(_u._types.length);
					_u._y._indices[(_j : GoInt)] = -(_u._types.length);
					break;
				} else if (_ti == ((0 : GoInt))) {
					_u._x._indices[(_i : GoInt)] = _tj;
					break;
				} else if (_tj == ((0 : GoInt))) {
					_u._y._indices[(_j : GoInt)] = _ti;
					break;
				} else if (_ti == (_tj)) {
					break;
					break;
				} else if ((_ti > (0 : GoInt)) && (_tj > (0 : GoInt))) {
					return false;
					break;
				} else if (_ti > (0 : GoInt)) {
					_u._y._setIndex(_j, _ti);
					break;
				} else {
					_u._x._setIndex(_i, _tj);
				};
				break;
			};
		};
		return true;
	}

	@:keep
	static public function _tracef(_u:Ref<T_unifier>, _format:GoString, _args:haxe.Rest<AnyInterface>):Void {
		var _args = new Slice<AnyInterface>(0, 0, ..._args);
		stdgo.fmt.Fmt.println(Go.toInterface(stdgo.strings.Strings.repeat((".  " : GoString), _u._depth)
			+ _sprintf(null, null, true, _format, ..._args.__toArray__())));
	}

	/**
		// unify attempts to unify x and y and reports whether it succeeded.
	**/
	@:keep
	static public function _unify(_u:Ref<T_unifier>, _x:Type, _y:Type):Bool {
		return _u._nify(_x, _y, null);
	}
}

class T_tparamsList_asInterface {
	/**
		// types returns the list of inferred types (via unification) for the type parameters
		// described by d, and an index. If all types were inferred, the returned index is < 0.
		// Otherwise, it is the index of the first type parameter which couldn't be inferred;
		// i.e., for which list[index] is nil.
	**/
	@:keep
	public function _types():{var _0:Slice<Type>; var _1:GoInt;}
		return __self__.value._types();

	/**
		// unknowns returns the number of type parameters for which no type has been set yet.
	**/
	@:keep
	public function _unknowns():GoInt
		return __self__.value._unknowns();

	/**
		// set sets the type typ for the i'th type parameter;
		// typ must not be nil and it must not have been set before.
	**/
	@:keep
	public function _set(_i:GoInt, _typ:Type):Void
		__self__.value._set(_i, _typ);

	/**
		// at returns the type set for the i'th type parameter; or nil.
	**/
	@:keep
	public function _at(_i:GoInt):Type
		return __self__.value._at(_i);

	/**
		// setIndex sets the type slot index for the i'th type parameter
		// (and all its joined parameters) to tj. The type parameter
		// must have a (possibly nil) type slot associated with it.
	**/
	@:keep
	public function _setIndex(_i:GoInt, _tj:GoInt):Void
		__self__.value._setIndex(_i, _tj);

	/**
		// If typ is a type parameter of d, index returns the type parameter index.
		// Otherwise, the result is < 0.
	**/
	@:keep
	public function _index(_typ:Type):GoInt
		return __self__.value._index(_typ);

	/**
		// init initializes d with the given type parameters.
		// The type parameters must be in the order in which they appear in their declaration
		// (this ensures that the tparams indices match the respective type parameter index).
	**/
	@:keep
	public function _init(_tparams:Slice<Ref<TypeParam>>):Void
		__self__.value._init(_tparams);

	/**
		// String returns a string representation for a tparamsList. For debugging.
	**/
	@:keep
	public function string():GoString
		return __self__.value.string();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_tparamsList>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_tparamsList_asInterface) class T_tparamsList_static_extension {
	/**
		// types returns the list of inferred types (via unification) for the type parameters
		// described by d, and an index. If all types were inferred, the returned index is < 0.
		// Otherwise, it is the index of the first type parameter which couldn't be inferred;
		// i.e., for which list[index] is nil.
	**/
	@:keep
	static public function _types(_d:Ref<T_tparamsList>):{var _0:Slice<Type>; var _1:GoInt;} {
		var _list:Slice<Type> = (null : Slice<Type>),
			_index:GoInt = (0 : GoInt);
		_list = new Slice<Type>((_d._tparams.length : GoInt).toBasic(), 0, ...[for (i in 0...(_d._tparams.length : GoInt).toBasic()) (null : Type)]);
		_index = (-1 : GoInt);
		for (_i in 0..._d._tparams.length.toBasic()) {
			var _t:Type = _d._at(_i);
			_list[(_i : GoInt)] = _t;
			if ((_index < (0:GoInt)) && (_t == null)) {
				_index = _i;
			};
		};
		return {_0: _list, _1: _index};
	}

	/**
		// unknowns returns the number of type parameters for which no type has been set yet.
	**/
	@:keep
	static public function _unknowns(_d:Ref<T_tparamsList>):GoInt {
		var _n:GoInt = (0 : GoInt);
		for (_0 => _ti in _d._indices) {
			if (_ti <= (0 : GoInt)) {
				_n++;
			};
		};
		return _n;
	}

	/**
		// set sets the type typ for the i'th type parameter;
		// typ must not be nil and it must not have been set before.
	**/
	@:keep
	static public function _set(_d:Ref<T_tparamsList>, _i:GoInt, _typ:Type):Void {
		_assert(_typ != null);
		var _u = _d._unifier;
		if (false) {
			_u._tracef(("%s ➞ %s" : GoString), Go.toInterface(Go.asInterface(_d._tparams[(_i : GoInt)])), Go.toInterface(_typ));
		};
		{
			var _ti:GoInt = _d._indices[(_i : GoInt)];
			if (_ti < (0:GoInt)) {
				_u._types[(-_ti - (1 : GoInt) : GoInt)] = _typ;
				_d._setIndex(_i, -_ti);
			} else if (_ti == ((0 : GoInt))) {
				_u._types = _u._types.__appendref__(_typ);
				_d._indices[(_i : GoInt)] = (_u._types.length);
			} else {
				throw Go.toInterface(("type already set" : GoString));
			};
		};
	}

	/**
		// at returns the type set for the i'th type parameter; or nil.
	**/
	@:keep
	static public function _at(_d:Ref<T_tparamsList>, _i:GoInt):Type {
		{
			var _ti:GoInt = _d._indices[(_i : GoInt)];
			if (_ti > (0 : GoInt)) {
				return _d._unifier._types[(_ti - (1 : GoInt) : GoInt)];
			};
		};
		return (null : Type);
	}

	/**
		// setIndex sets the type slot index for the i'th type parameter
		// (and all its joined parameters) to tj. The type parameter
		// must have a (possibly nil) type slot associated with it.
	**/
	@:keep
	static public function _setIndex(_d:Ref<T_tparamsList>, _i:GoInt, _tj:GoInt):Void {
		var _ti:GoInt = _d._indices[(_i : GoInt)];
		_assert((_ti != (0 : GoInt)) && (_tj != (0 : GoInt)));
		for (_k => _tk in _d._indices) {
			if (_tk == (_ti)) {
				_d._indices[(_k : GoInt)] = _tj;
			};
		};
	}

	/**
		// If typ is a type parameter of d, index returns the type parameter index.
		// Otherwise, the result is < 0.
	**/
	@:keep
	static public function _index(_d:Ref<T_tparamsList>, _typ:Type):GoInt {
		{
			var __tmp__ = try {
				{value: (Go.typeAssert((Go.toInterface(_typ) : Ref<TypeParam>)) : Ref<TypeParam>), ok: true};
			} catch (_) {
				{value: (null : Ref<TypeParam>), ok: false};
			}, _tpar = __tmp__.value, _ok = __tmp__.ok;
			if (_ok) {
				return _tparamIndex(_d._tparams, _tpar);
			};
		};
		return (-1 : GoInt);
	}

	/**
		// init initializes d with the given type parameters.
		// The type parameters must be in the order in which they appear in their declaration
		// (this ensures that the tparams indices match the respective type parameter index).
	**/
	@:keep
	static public function _init(_d:Ref<T_tparamsList>, _tparams:Slice<Ref<TypeParam>>):Void {
		if ((_tparams.length) == ((0 : GoInt))) {
			return;
		};
		if (false) {
			for (_i => _tpar in _tparams) {
				_assert(_i == (_tpar._index));
			};
		};
		_d._tparams = _tparams;
		_d._indices = new Slice<GoInt>((_tparams.length : GoInt).toBasic(), 0, ...[for (i in 0...(_tparams.length : GoInt).toBasic()) (0 : GoInt)]);
	}

	/**
		// String returns a string representation for a tparamsList. For debugging.
	**/
	@:keep
	static public function string(_d:Ref<T_tparamsList>):GoString {
		var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
		var _w = _newTypeWriter((_buf : Ref<stdgo.bytes.Bytes.Buffer>), null);
		_w._byte((91 : GoUInt8));
		for (_i => _tpar in _d._tparams) {
			if (_i > (0 : GoInt)) {
				_w._string((", " : GoString));
			};
			_w._typ(Go.asInterface(_tpar));
			_w._string((": " : GoString));
			_w._typ(_d._at(_i));
		};
		_w._byte((93 : GoUInt8));
		return (_buf.string() : GoString);
	}
}

class Union_asInterface {
	@:keep
	public function string():GoString
		return __self__.value.string();

	@:keep
	public function underlying():Type
		return __self__.value.underlying();

	@:keep
	public function term(_i:GoInt):Ref<Term>
		return __self__.value.term(_i);

	@:keep
	public function len():GoInt
		return __self__.value.len();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Union>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Union_asInterface) class Union_static_extension {
	@:keep
	static public function string(_u:Ref<Union>):GoString {
		return typeString(Go.asInterface(_u), null);
	}

	@:keep
	static public function underlying(_u:Ref<Union>):Type {
		return Go.asInterface(_u);
	}

	@:keep
	static public function term(_u:Ref<Union>, _i:GoInt):Ref<Term> {
		return _u._terms[(_i : GoInt)];
	}

	@:keep
	static public function len(_u:Ref<Union>):GoInt {
		return (_u._terms.length);
	}
}

class T_atPos_asInterface {
	@:keep
	public function pos():stdgo.go.token.Token.Pos
		return __self__.value.pos();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_atPos>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_atPos_asInterface) class T_atPos_static_extension {
	@:keep
	static public function pos(_s:T_atPos):stdgo.go.token.Token.Pos {
		return (_s : stdgo.go.token.Token.Pos);
	}
}

class T_nodeSet_asInterface {
	@:keep
	public function _add(_p:Ref<T_graphNode>):Void
		__self__.value._add(_p);

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_nodeSet>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_nodeSet_asInterface) class T_nodeSet_static_extension {
	@:keep
	static public function _add(_s:Ref<T_nodeSet>, _p:Ref<T_graphNode>):Void {
		if (_s == null) {
			_s = (new GoObjectMap<Ref<T_graphNode>, Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("T_nodeSet",
				[], null, false, {
					get: () -> null
				}))) : T_nodeSet);
		};
		(_s)[_p] = true;
	}
}

class T_nodeQueue_asInterface {
	@:keep
	public function pop():AnyInterface
		return __self__.value.pop();

	@:keep
	public function push(_x:AnyInterface):Void
		__self__.value.push(_x);

	@:keep
	public function less(_i:GoInt, _j:GoInt):Bool
		return __self__.value.less(_i, _j);

	@:keep
	public function swap(_i:GoInt, _j:GoInt):Void
		__self__.value.swap(_i, _j);

	@:keep
	public function len():GoInt
		return __self__.value.len();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_nodeQueue>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_nodeQueue_asInterface) class T_nodeQueue_static_extension {
	@:keep
	static public function pop(_a:Ref<T_nodeQueue>):AnyInterface {
		var _n:GoInt = (_a.length);
		var _x = (_a)[(_n - (1 : GoInt) : GoInt)];
		_x._index = (-1 : GoInt);
		_a.__setData__(((_a).__slice__(0, _n - (1 : GoInt)) : T_nodeQueue));
		return Go.toInterface(Go.asInterface(_x));
	}

	@:keep
	static public function push(_a:Ref<T_nodeQueue>, _x:AnyInterface):Void {
		throw Go.toInterface(("unreachable" : GoString));
	}

	@:keep
	static public function less(_a:T_nodeQueue, _i:GoInt, _j:GoInt):Bool {
		var _0 = _a[(_i : GoInt)], _1 = _a[(_j : GoInt)], _y = _1, _x = _0;
		return (_x._ndeps < _y._ndeps) || ((_x._ndeps == _y._ndeps) && (_x._obj._order() < _y._obj._order()));
	}

	@:keep
	static public function swap(_a:T_nodeQueue, _i:GoInt, _j:GoInt):Void {
		var _0 = _a[(_i : GoInt)], _1 = _a[(_j : GoInt)], _y = _1, _x = _0;
		{
			final __tmp__0 = _y;
			final __tmp__1 = _x;
			_a[(_i : GoInt)] = __tmp__0;
			_a[(_j : GoInt)] = __tmp__1;
		};
		{
			final __tmp__0 = _j;
			final __tmp__1 = _i;
			_x._index = __tmp__0;
			_y._index = __tmp__1;
		};
	}

	@:keep
	static public function len(_a:T_nodeQueue):GoInt {
		return (_a.length);
	}
}

class T_methodSet_asInterface {
	@:keep
	public function _addOne(_f:Ref<Func>, _index:Slice<GoInt>, _indirect:Bool, _multiples:Bool):T_methodSet
		return __self__.value._addOne(_f, _index, _indirect, _multiples);

	/**
		// Add adds all functions in list to the method set s.
		// If multiples is set, every function in list appears multiple times
		// and is treated as a collision.
	**/
	@:keep
	public function _add(_list:Slice<Ref<Func>>, _index:Slice<GoInt>, _indirect:Bool, _multiples:Bool):T_methodSet
		return __self__.value._add(_list, _index, _indirect, _multiples);

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_methodSet>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_methodSet_asInterface) class T_methodSet_static_extension {
	@:keep
	static public function _addOne(_s:T_methodSet, _f:Ref<Func>, _index:Slice<GoInt>, _indirect:Bool, _multiples:Bool):T_methodSet {
		if (_s == null) {
			_s = (new GoObjectMap<GoString, Ref<Selection>>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("T_methodSet",
				[], null, false, {
				get: () -> null
			}))) : T_methodSet);
		};
		var _key:GoString = _f.id();
		if (!_multiples) {
			{
				var __tmp__ = (_s != null
					&& _s.__exists__(_key) ? {value: _s[_key], ok: true} : {value: (null : Ref<Selection>), ok: false}),
					_0:Ref<Selection> = __tmp__.value,
					_found:Bool = __tmp__.ok;
				if (!_found && (_indirect || !_f._hasPtrRecv())) {
					_s[_key] = ((new Selection((1 : SelectionKind), (null : Type), Go.asInterface(_f), _index, _indirect) : Selection) : Ref<Selection>);
					return _s;
				};
			};
		};
		_s[_key] = null;
		return _s;
	}

	/**
		// Add adds all functions in list to the method set s.
		// If multiples is set, every function in list appears multiple times
		// and is treated as a collision.
	**/
	@:keep
	static public function _add(_s:T_methodSet, _list:Slice<Ref<Func>>, _index:Slice<GoInt>, _indirect:Bool, _multiples:Bool):T_methodSet {
		if ((_list.length) == ((0 : GoInt))) {
			return _s;
		};
		for (_i => _f in _list) {
			_s = _s._addOne(_f, _concat(_index, _i), _indirect, _multiples);
		};
		return _s;
	}
}

class T_color_asInterface {
	@:keep
	public function string():GoString
		return __self__.value.string();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_color>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_color_asInterface) class T_color_static_extension {
	@:keep
	static public function string(_c:T_color):GoString {
		if (_c == ((("0" : GoUInt32) : T_color))) {
			return ("white" : GoString);
		} else if (_c == ((("1" : GoUInt32) : T_color))) {
			return ("black" : GoString);
		} else {
			return ("grey" : GoString);
		};
	}
}

class T_objset_asInterface {
	/**
		// insert attempts to insert an object obj into objset s.
		// If s already contains an alternative object alt with
		// the same name, insert leaves s unchanged and returns alt.
		// Otherwise it inserts obj and returns nil.
	**/
	@:keep
	public function _insert(_obj:Object):Object
		return __self__.value._insert(_obj);

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_objset>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_objset_asInterface) class T_objset_static_extension {
	/**
		// insert attempts to insert an object obj into objset s.
		// If s already contains an alternative object alt with
		// the same name, insert leaves s unchanged and returns alt.
		// Otherwise it inserts obj and returns nil.
	**/
	@:keep
	static public function _insert(_s:Ref<T_objset>, _obj:Object):Object {
		var _id:GoString = _obj.id();
		{
			var _alt:Object = (_s)[_id];
			if (_alt != null) {
				return _alt;
			};
		};
		if (_s == null) {
			_s = (new GoObjectMap<GoString, Object>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({get: () ->
				stdgo.internal.reflect.Reflect.GoType.basic(string_kind)},
				{get: () -> stdgo.internal.reflect.Reflect.GoType.named("Object", [], null, false, {get: () -> null})}))) : GoMap<GoString, Object>);
		};
		(_s)[_id] = _obj;
		return (null : Object);
	}
}

class T_inSourceOrder_asInterface {
	@:keep
	public function swap(_i:GoInt, _j:GoInt):Void
		__self__.value.swap(_i, _j);

	@:keep
	public function less(_i:GoInt, _j:GoInt):Bool
		return __self__.value.less(_i, _j);

	@:keep
	public function len():GoInt
		return __self__.value.len();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_inSourceOrder>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_inSourceOrder_asInterface) class T_inSourceOrder_static_extension {
	@:keep
	static public function swap(_a:T_inSourceOrder, _i:GoInt, _j:GoInt):Void {
		{
			final __tmp__0 = _a[(_j : GoInt)];
			final __tmp__1 = _a[(_i : GoInt)];
			_a[(_i : GoInt)] = __tmp__0;
			_a[(_j : GoInt)] = __tmp__1;
		};
	}

	@:keep
	static public function less(_a:T_inSourceOrder, _i:GoInt, _j:GoInt):Bool {
		return _a[(_i : GoInt)]._order() < _a[(_j : GoInt)]._order();
	}

	@:keep
	static public function len(_a:T_inSourceOrder):GoInt {
		return (_a.length);
	}
}

class T_substMap_asInterface {
	@:keep
	public function _lookup(_tpar:Ref<TypeParam>):Type
		return __self__.value._lookup(_tpar);

	@:keep
	public function _empty():Bool
		return __self__.value._empty();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_substMap>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_substMap_asInterface) class T_substMap_static_extension {
	@:keep
	static public function _lookup(_m:T_substMap, _tpar:Ref<TypeParam>):Type {
		{
			var _t:Type = _m[_tpar];
			if (_t != null) {
				return _t;
			};
		};
		return Go.asInterface(_tpar);
	}

	@:keep
	static public function _empty(_m:T_substMap):Bool {
		return (_m.length) == ((0 : GoInt));
	}
}

class T_termlist_asInterface {
	/**
		// subsetOf reports whether xl ⊆ yl.
	**/
	@:keep
	public function _subsetOf(_yl:T_termlist):Bool
		return __self__.value._subsetOf(_yl);

	/**
		// supersetOf reports whether y ⊆ xl.
	**/
	@:keep
	public function _supersetOf(_y:Ref<T_term>):Bool
		return __self__.value._supersetOf(_y);

	/**
		// includes reports whether t ∈ xl.
	**/
	@:keep
	public function _includes(_t:Type):Bool
		return __self__.value._includes(_t);

	/**
		// equal reports whether xl and yl represent the same type set.
	**/
	@:keep
	public function _equal(_yl:T_termlist):Bool
		return __self__.value._equal(_yl);

	/**
		// intersect returns the intersection xl ∩ yl.
	**/
	@:keep
	public function _intersect(_yl:T_termlist):T_termlist
		return __self__.value._intersect(_yl);

	/**
		// union returns the union xl ∪ yl.
	**/
	@:keep
	public function _union(_yl:T_termlist):T_termlist
		return __self__.value._union(_yl);

	/**
		// norm returns the normal form of xl.
	**/
	@:keep
	public function _norm():T_termlist
		return __self__.value._norm();

	/**
		// isAll reports whether the termlist xl represents the set of all types.
	**/
	@:keep
	public function _isAll():Bool
		return __self__.value._isAll();

	/**
		// isEmpty reports whether the termlist xl represents the empty set of types.
	**/
	@:keep
	public function _isEmpty():Bool
		return __self__.value._isEmpty();

	/**
		// String prints the termlist exactly (without normalization).
	**/
	@:keep
	public function string():GoString
		return __self__.value.string();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_termlist>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_termlist_asInterface) class T_termlist_static_extension {
	/**
		// subsetOf reports whether xl ⊆ yl.
	**/
	@:keep
	static public function _subsetOf(_xl:T_termlist, _yl:T_termlist):Bool {
		if (_yl._isEmpty()) {
			return _xl._isEmpty();
		};
		for (_0 => _x in _xl) {
			if (!_yl._supersetOf(_x)) {
				return false;
			};
		};
		return true;
	}

	/**
		// supersetOf reports whether y ⊆ xl.
	**/
	@:keep
	static public function _supersetOf(_xl:T_termlist, _y:Ref<T_term>):Bool {
		for (_0 => _x in _xl) {
			if (_y._subsetOf(_x)) {
				return true;
			};
		};
		return false;
	}

	/**
		// includes reports whether t ∈ xl.
	**/
	@:keep
	static public function _includes(_xl:T_termlist, _t:Type):Bool {
		for (_0 => _x in _xl) {
			if (_x._includes(_t)) {
				return true;
			};
		};
		return false;
	}

	/**
		// equal reports whether xl and yl represent the same type set.
	**/
	@:keep
	static public function _equal(_xl:T_termlist, _yl:T_termlist):Bool {
		return _xl._subsetOf(_yl) && _yl._subsetOf(_xl);
	}

	/**
		// intersect returns the intersection xl ∩ yl.
	**/
	@:keep
	static public function _intersect(_xl:T_termlist, _yl:T_termlist):T_termlist {
		if (_xl._isEmpty() || _yl._isEmpty()) {
			return null;
		};
		var _rl:T_termlist = new T_termlist(0, 0);
		for (_0 => _x in _xl) {
			for (_1 => _y in _yl) {
				{
					var _r = _x._intersect(_y);
					if (_r != null) {
						_rl = _rl.__appendref__(_r);
					};
				};
			};
		};
		return _rl._norm();
	}

	/**
		// union returns the union xl ∪ yl.
	**/
	@:keep
	static public function _union(_xl:T_termlist, _yl:T_termlist):T_termlist {
		return (_xl.__append__(..._yl.__toArray__()))._norm();
	}

	/**
		// norm returns the normal form of xl.
	**/
	@:keep
	static public function _norm(_xl:T_termlist):T_termlist {
		var _used = new Slice<Bool>((_xl.length : GoInt).toBasic(), 0, ...[for (i in 0...(_xl.length : GoInt).toBasic()) false]);
		var _rl:T_termlist = new T_termlist(0, 0);
		for (_i => _xi in _xl) {
			if ((_xi == null) || _used[(_i : GoInt)]) {
				continue;
			};
			{
				var _j:GoInt = _i + (1 : GoInt);
				Go.cfor(_j < (_xl.length), _j++, {
					var _xj = _xl[(_j : GoInt)];
					if ((_xj == null) || _used[(_j : GoInt)]) {
						continue;
					};
					{
						var __tmp__ = _xi._union(_xj),
							_u1:Ref<T_term> = __tmp__._0,
							_u2:Ref<T_term> = __tmp__._1;
						if (_u2 == null) {
							if (_u1._typ == null) {
								return _allTermlist;
							};
							_xi = _u1;
							_used[(_j : GoInt)] = true;
						};
					};
				});
			};
			_rl = _rl.__appendref__(_xi);
		};
		return _rl;
	}

	/**
		// isAll reports whether the termlist xl represents the set of all types.
	**/
	@:keep
	static public function _isAll(_xl:T_termlist):Bool {
		for (_0 => _x in _xl) {
			if ((_x != null) && (_x._typ == null)) {
				return true;
			};
		};
		return false;
	}

	/**
		// isEmpty reports whether the termlist xl represents the empty set of types.
	**/
	@:keep
	static public function _isEmpty(_xl:T_termlist):Bool {
		for (_0 => _x in _xl) {
			if (_x != null) {
				return false;
			};
		};
		return true;
	}

	/**
		// String prints the termlist exactly (without normalization).
	**/
	@:keep
	static public function string(_xl:T_termlist):GoString {
		if ((_xl.length) == ((0 : GoInt))) {
			return ("∅" : GoString);
		};
		var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
		for (_i => _x in _xl) {
			if (_i > (0 : GoInt)) {
				_buf.writeString((" | " : GoString));
			};
			_buf.writeString((_x.string() : GoString));
		};
		return (_buf.string() : GoString);
	}
}

class T_byUniqueMethodName_asInterface {
	@:keep
	public function swap(_i:GoInt, _j:GoInt):Void
		__self__.value.swap(_i, _j);

	@:keep
	public function less(_i:GoInt, _j:GoInt):Bool
		return __self__.value.less(_i, _j);

	@:keep
	public function len():GoInt
		return __self__.value.len();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<T_byUniqueMethodName>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.T_byUniqueMethodName_asInterface) class T_byUniqueMethodName_static_extension {
	@:keep
	static public function swap(_a:T_byUniqueMethodName, _i:GoInt, _j:GoInt):Void {
		{
			final __tmp__0 = _a[(_j : GoInt)];
			final __tmp__1 = _a[(_i : GoInt)];
			_a[(_i : GoInt)] = __tmp__0;
			_a[(_j : GoInt)] = __tmp__1;
		};
	}

	@:keep
	static public function less(_a:T_byUniqueMethodName, _i:GoInt, _j:GoInt):Bool {
		return _a[(_i : GoInt)].id() < _a[(_j : GoInt)].id();
	}

	@:keep
	static public function len(_a:T_byUniqueMethodName):GoInt {
		return (_a.length);
	}
}

class Term_asInterface {
	@:keep
	public function string():GoString
		return __self__.value.string();

	@:keep
	public function type():Type
		return __self__.value.type();

	@:keep
	public function tilde():Bool
		return __self__.value.tilde();

	public function new(__self__, __type__) {
		this.__self__ = __self__;
		this.__type__ = __type__;
	}

	public function __underlying__()
		return new AnyInterface((__type__.kind() == stdgo.reflect.Reflect.ptr
			&& !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic),
			__type__);

	var __self__:Pointer<Term>;
	var __type__:stdgo.internal.reflect.Reflect._Type;
}

@:keep @:allow(stdgo.go.types.Types.Term_asInterface) class Term_static_extension {
	@:keep
	static public function string(_t:Ref<Term>):GoString {
		return ({_tilde: _t._tilde, _typ: _t._typ}.string(): GoString);
	}

	@:keep
	static public function type(_t:Ref<Term>):Type {
		return _t._typ;
	}

	@:keep
	static public function tilde(_t:Ref<Term>):Bool {
		return _t._tilde;
	}
}
