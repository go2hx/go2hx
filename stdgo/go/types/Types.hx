package stdgo.go.types;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
/**
    // Package types declares the data types and implements
    // the algorithms for type-checking of Go packages. Use
    // Config.Check to invoke the type checker for a package.
    // Alternatively, create a new type checker with NewChecker
    // and invoke it incrementally by calling Checker.Files.
    //
    // Type-checking consists of several interdependent phases:
    //
    // Name resolution maps each identifier (ast.Ident) in the program to the
    // language object (Object) it denotes.
    // Use Info.{Defs,Uses,Implicits} for the results of name resolution.
    //
    // Constant folding computes the exact constant value (constant.Value)
    // for every expression (ast.Expr) that is a compile-time constant.
    // Use Info.Types[expr].Value for the results of constant folding.
    //
    // Type inference computes the type (Type) of every expression (ast.Expr)
    // and checks for compliance with the language specification.
    // Use Info.Types[expr].Type for the results of type inference.
    //
    // For a tutorial, see https://golang.org/s/types-tutorial.
**/
private var __go2hxdoc__package : Bool;
/**
    
    
    
**/
var _cgoPrefixes : stdgo.GoArray<stdgo.GoString> = (new stdgo.GoArray<stdgo.GoString>(("_Ciconst_" : stdgo.GoString), ("_Cfconst_" : stdgo.GoString), ("_Csconst_" : stdgo.GoString), ("_Ctype_" : stdgo.GoString), ("_Cvar_" : stdgo.GoString), ("_Cfpvar_fp_" : stdgo.GoString), ("_Cfunc_" : stdgo.GoString), ("_Cmacro_" : stdgo.GoString)) : stdgo.GoArray<stdgo.GoString>);
/**
    
    
    
**/
var _errBadCgo : stdgo.Error = stdgo.errors.Errors.new_(("cannot use FakeImportC and go115UsesCgo together" : stdgo.GoString));
/**
    
    
    
**/
var _op2str1 : stdgo.GoArray<stdgo.GoString> = {
        var s:stdgo.GoArray<stdgo.GoString> = new stdgo.GoArray<stdgo.GoString>(...[for (i in 0 ... 20) ""]);
        s[19] = ("bitwise complement" : stdgo.GoString);
        s;
    };
/**
    // This is only used for operations that may cause overflow.
    
    
**/
var _op2str2 : stdgo.GoArray<stdgo.GoString> = {
        var s:stdgo.GoArray<stdgo.GoString> = new stdgo.GoArray<stdgo.GoString>(...[for (i in 0 ... 21) ""]);
        s[12] = ("addition" : stdgo.GoString);
        s[13] = ("subtraction" : stdgo.GoString);
        s[19] = ("bitwise XOR" : stdgo.GoString);
        s[14] = ("multiplication" : stdgo.GoString);
        s[20] = ("shift" : stdgo.GoString);
        s;
    };
/**
    
    
    
**/
var _gccgoArchSizes : stdgo.GoMap<stdgo.GoString, stdgo.Ref<stdgo.go.types.Types.StdSizes>> = ({
        final x = new stdgo.GoMap.GoStringMap<stdgo.Ref<stdgo.go.types.Types.StdSizes>>();
        x.__defaultValue__ = () -> (null : stdgo.Ref<stdgo.go.types.Types.StdSizes>);
        @:mergeBlock {
            x.set(("386" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((4i64 : stdgo.GoInt64), (4i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("alpha" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("amd64" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("amd64p32" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((4i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("arm" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((4i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("armbe" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((4i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("arm64" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("arm64be" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("ia64" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("loong64" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("m68k" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((4i64 : stdgo.GoInt64), (2i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("mips" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((4i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("mipsle" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((4i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("mips64" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("mips64le" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("mips64p32" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((4i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("mips64p32le" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((4i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("nios2" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((4i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("ppc" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((4i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("ppc64" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("ppc64le" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("riscv" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((4i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("riscv64" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("s390" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((4i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("s390x" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("sh" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((4i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("shbe" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((4i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("sparc" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((4i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("sparc64" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("wasm" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
        };
        x;
    } : stdgo.GoMap<stdgo.GoString, stdgo.Ref<stdgo.go.types.Types.StdSizes>>);
/**
    
    
    
**/
var _operandModeString : stdgo.GoArray<stdgo.GoString> = {
        var s:stdgo.GoArray<stdgo.GoString> = new stdgo.GoArray<stdgo.GoString>(...[for (i in 0 ... 11) ""]);
        s[0] = ("invalid operand" : stdgo.GoString);
        s[1] = ("no value" : stdgo.GoString);
        s[2] = ("built-in" : stdgo.GoString);
        s[3] = ("type" : stdgo.GoString);
        s[4] = ("constant" : stdgo.GoString);
        s[5] = ("variable" : stdgo.GoString);
        s[6] = ("map index expression" : stdgo.GoString);
        s[7] = ("value" : stdgo.GoString);
        s[8] = ("comma, ok expression" : stdgo.GoString);
        s[9] = ("comma, error expression" : stdgo.GoString);
        s[10] = ("cgo function" : stdgo.GoString);
        s;
    };
/**
    
    
    
**/
var _basicSizes : stdgo.GoArray<stdgo.GoUInt8> = {
        var s:stdgo.GoArray<stdgo.GoUInt8> = new stdgo.GoArray<stdgo.GoUInt8>(...[for (i in 0 ... 17) 0]);
        s[1] = (1 : stdgo.GoUInt8);
        s[3] = (1 : stdgo.GoUInt8);
        s[4] = (2 : stdgo.GoUInt8);
        s[5] = (4 : stdgo.GoUInt8);
        s[6] = (8 : stdgo.GoUInt8);
        s[8] = (1 : stdgo.GoUInt8);
        s[9] = (2 : stdgo.GoUInt8);
        s[10] = (4 : stdgo.GoUInt8);
        s[11] = (8 : stdgo.GoUInt8);
        s[13] = (4 : stdgo.GoUInt8);
        s[14] = (8 : stdgo.GoUInt8);
        s[15] = (8 : stdgo.GoUInt8);
        s[16] = (16 : stdgo.GoUInt8);
        s;
    };
/**
    // common architecture word sizes and alignments
    
    
**/
var _gcArchSizes : stdgo.GoMap<stdgo.GoString, stdgo.Ref<stdgo.go.types.Types.StdSizes>> = ({
        final x = new stdgo.GoMap.GoStringMap<stdgo.Ref<stdgo.go.types.Types.StdSizes>>();
        x.__defaultValue__ = () -> (null : stdgo.Ref<stdgo.go.types.Types.StdSizes>);
        @:mergeBlock {
            x.set(("386" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((4i64 : stdgo.GoInt64), (4i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("amd64" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("amd64p32" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((4i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("arm" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((4i64 : stdgo.GoInt64), (4i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("arm64" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("loong64" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("mips" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((4i64 : stdgo.GoInt64), (4i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("mipsle" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((4i64 : stdgo.GoInt64), (4i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("mips64" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("mips64le" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("ppc64" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("ppc64le" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("riscv64" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("s390x" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("sparc64" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("wasm" : stdgo.GoString), (new stdgo.go.types.Types.StdSizes((8i64 : stdgo.GoInt64), (8i64 : stdgo.GoInt64)) : stdgo.go.types.Types.StdSizes));
        };
        x;
    } : stdgo.GoMap<stdgo.GoString, stdgo.Ref<stdgo.go.types.Types.StdSizes>>);
/**
    // stdSizes is used if Config.Sizes == nil.
    
    
**/
var _stdSizes : stdgo.go.types.Types.Sizes = sizesFor(("gc" : stdgo.GoString), ("amd64" : stdgo.GoString));
/**
    // allTermlist represents the set of all types.
    // It is in normal form.
    
    
**/
var _allTermlist : stdgo.go.types.Types.T_termlist = (new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_term>>(1, 1, (stdgo.Go.setRef(({} : stdgo.go.types.Types.T_term)) : stdgo.Ref<stdgo.go.types.Types.T_term>)) : stdgo.go.types.Types.T_termlist);
/**
    // topTypeSet may be used as type set for the empty interface.
    
    
**/
var _topTypeSet : stdgo.go.types.Types.T__TypeSet = ({ _terms : _allTermlist } : stdgo.go.types.Types.T__TypeSet);
/**
    // emptyInterface represents the empty (completed) interface
    
    
**/
var _emptyInterface : stdgo.go.types.Types.Interface = ({ _complete : true, _tset : (stdgo.Go.setRef(_topTypeSet) : stdgo.Ref<stdgo.go.types.Types.T__TypeSet>) } : stdgo.go.types.Types.Interface);
/**
    // Typ contains the predeclared *Basic types indexed by their
    // corresponding BasicKind.
    //
    // The *Basic type for Typ[Byte] will have the name "uint8".
    // Use Universe.Lookup("byte").Type() to obtain the specific
    // alias basic type named "byte" (and analogous for "rune").
    
    
**/
var typ : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Basic>> = {
        var s = new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Basic>>(26, 0);
        s[0] = (new stdgo.go.types.Types.Basic((0 : stdgo.go.types.Types.BasicKind), (0 : stdgo.go.types.Types.BasicInfo), ("invalid type" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[1] = (new stdgo.go.types.Types.Basic((1 : stdgo.go.types.Types.BasicKind), (1 : stdgo.go.types.Types.BasicInfo), ("bool" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[2] = (new stdgo.go.types.Types.Basic((2 : stdgo.go.types.Types.BasicKind), (2 : stdgo.go.types.Types.BasicInfo), ("int" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[3] = (new stdgo.go.types.Types.Basic((3 : stdgo.go.types.Types.BasicKind), (2 : stdgo.go.types.Types.BasicInfo), ("int8" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[4] = (new stdgo.go.types.Types.Basic((4 : stdgo.go.types.Types.BasicKind), (2 : stdgo.go.types.Types.BasicInfo), ("int16" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[5] = (new stdgo.go.types.Types.Basic((5 : stdgo.go.types.Types.BasicKind), (2 : stdgo.go.types.Types.BasicInfo), ("int32" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[6] = (new stdgo.go.types.Types.Basic((6 : stdgo.go.types.Types.BasicKind), (2 : stdgo.go.types.Types.BasicInfo), ("int64" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[7] = (new stdgo.go.types.Types.Basic((7 : stdgo.go.types.Types.BasicKind), (6 : stdgo.go.types.Types.BasicInfo), ("uint" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[8] = (new stdgo.go.types.Types.Basic((8 : stdgo.go.types.Types.BasicKind), (6 : stdgo.go.types.Types.BasicInfo), ("uint8" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[9] = (new stdgo.go.types.Types.Basic((9 : stdgo.go.types.Types.BasicKind), (6 : stdgo.go.types.Types.BasicInfo), ("uint16" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[10] = (new stdgo.go.types.Types.Basic((10 : stdgo.go.types.Types.BasicKind), (6 : stdgo.go.types.Types.BasicInfo), ("uint32" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[11] = (new stdgo.go.types.Types.Basic((11 : stdgo.go.types.Types.BasicKind), (6 : stdgo.go.types.Types.BasicInfo), ("uint64" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[12] = (new stdgo.go.types.Types.Basic((12 : stdgo.go.types.Types.BasicKind), (6 : stdgo.go.types.Types.BasicInfo), ("uintptr" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[13] = (new stdgo.go.types.Types.Basic((13 : stdgo.go.types.Types.BasicKind), (8 : stdgo.go.types.Types.BasicInfo), ("float32" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[14] = (new stdgo.go.types.Types.Basic((14 : stdgo.go.types.Types.BasicKind), (8 : stdgo.go.types.Types.BasicInfo), ("float64" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[15] = (new stdgo.go.types.Types.Basic((15 : stdgo.go.types.Types.BasicKind), (16 : stdgo.go.types.Types.BasicInfo), ("complex64" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[16] = (new stdgo.go.types.Types.Basic((16 : stdgo.go.types.Types.BasicKind), (16 : stdgo.go.types.Types.BasicInfo), ("complex128" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[17] = (new stdgo.go.types.Types.Basic((17 : stdgo.go.types.Types.BasicKind), (32 : stdgo.go.types.Types.BasicInfo), ("string" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[18] = (new stdgo.go.types.Types.Basic((18 : stdgo.go.types.Types.BasicKind), (0 : stdgo.go.types.Types.BasicInfo), ("Pointer" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[19] = (new stdgo.go.types.Types.Basic((19 : stdgo.go.types.Types.BasicKind), (65 : stdgo.go.types.Types.BasicInfo), ("untyped bool" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[20] = (new stdgo.go.types.Types.Basic((20 : stdgo.go.types.Types.BasicKind), (66 : stdgo.go.types.Types.BasicInfo), ("untyped int" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[21] = (new stdgo.go.types.Types.Basic((21 : stdgo.go.types.Types.BasicKind), (66 : stdgo.go.types.Types.BasicInfo), ("untyped rune" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[22] = (new stdgo.go.types.Types.Basic((22 : stdgo.go.types.Types.BasicKind), (72 : stdgo.go.types.Types.BasicInfo), ("untyped float" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[23] = (new stdgo.go.types.Types.Basic((23 : stdgo.go.types.Types.BasicKind), (80 : stdgo.go.types.Types.BasicInfo), ("untyped complex" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[24] = (new stdgo.go.types.Types.Basic((24 : stdgo.go.types.Types.BasicKind), (96 : stdgo.go.types.Types.BasicInfo), ("untyped string" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s[25] = (new stdgo.go.types.Types.Basic((25 : stdgo.go.types.Types.BasicKind), (64 : stdgo.go.types.Types.BasicInfo), ("untyped nil" : stdgo.GoString)) : stdgo.go.types.Types.Basic);
        s;
    };
/**
    
    
    
**/
var _aliases : stdgo.GoArray<stdgo.Ref<stdgo.go.types.Types.Basic>> = (new stdgo.GoArray<stdgo.Ref<stdgo.go.types.Types.Basic>>((new stdgo.go.types.Types.Basic((8 : stdgo.go.types.Types.BasicKind), (6 : stdgo.go.types.Types.BasicInfo), ("byte" : stdgo.GoString)) : stdgo.go.types.Types.Basic), (new stdgo.go.types.Types.Basic((5 : stdgo.go.types.Types.BasicKind), (2 : stdgo.go.types.Types.BasicInfo), ("rune" : stdgo.GoString)) : stdgo.go.types.Types.Basic)) : stdgo.GoArray<stdgo.Ref<stdgo.go.types.Types.Basic>>);
/**
    
    
    
**/
var _predeclaredConsts : stdgo.GoArray<T__struct_6> = (new stdgo.GoArray<T__struct_6>(({ _name : ("true" : stdgo.GoString), _kind : (19 : stdgo.go.types.Types.BasicKind), _val : stdgo.go.constant.Constant.makeBool(true) } : T__struct_6), ({ _name : ("false" : stdgo.GoString), _kind : (19 : stdgo.go.types.Types.BasicKind), _val : stdgo.go.constant.Constant.makeBool(false) } : T__struct_6), ({ _name : ("iota" : stdgo.GoString), _kind : (20 : stdgo.go.types.Types.BasicKind), _val : stdgo.go.constant.Constant.makeInt64((0i64 : stdgo.GoInt64)) } : T__struct_6)) : stdgo.GoArray<T__struct_6>);
/**
    
    
    
**/
var _predeclaredFuncs : stdgo.GoArray<T__struct_7> = {
        var s:stdgo.GoArray<T__struct_7> = new stdgo.GoArray<T__struct_7>(...[for (i in 0 ... 28) ({ _name : ("" : stdgo.GoString), _nargs : (0 : stdgo.GoInt), _variadic : false, _kind : ((0 : stdgo.GoInt) : stdgo.go.types.Types.T_exprKind) } : T__struct_7)]);
        s[0] = ({ _name : ("append" : stdgo.GoString), _nargs : (1 : stdgo.GoInt), _variadic : true, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[1] = ({ _name : ("cap" : stdgo.GoString), _nargs : (1 : stdgo.GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[2] = ({ _name : ("clear" : stdgo.GoString), _nargs : (1 : stdgo.GoInt), _variadic : false, _kind : (2 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[3] = ({ _name : ("close" : stdgo.GoString), _nargs : (1 : stdgo.GoInt), _variadic : false, _kind : (2 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[4] = ({ _name : ("complex" : stdgo.GoString), _nargs : (2 : stdgo.GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[5] = ({ _name : ("copy" : stdgo.GoString), _nargs : (2 : stdgo.GoInt), _variadic : false, _kind : (2 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[6] = ({ _name : ("delete" : stdgo.GoString), _nargs : (2 : stdgo.GoInt), _variadic : false, _kind : (2 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[7] = ({ _name : ("imag" : stdgo.GoString), _nargs : (1 : stdgo.GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[8] = ({ _name : ("len" : stdgo.GoString), _nargs : (1 : stdgo.GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[9] = ({ _name : ("make" : stdgo.GoString), _nargs : (1 : stdgo.GoInt), _variadic : true, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[10] = ({ _name : ("max" : stdgo.GoString), _nargs : (1 : stdgo.GoInt), _variadic : true, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[11] = ({ _name : ("min" : stdgo.GoString), _nargs : (1 : stdgo.GoInt), _variadic : true, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[12] = ({ _name : ("new" : stdgo.GoString), _nargs : (1 : stdgo.GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[13] = ({ _name : ("panic" : stdgo.GoString), _nargs : (1 : stdgo.GoInt), _variadic : false, _kind : (2 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[14] = ({ _name : ("print" : stdgo.GoString), _nargs : (0 : stdgo.GoInt), _variadic : true, _kind : (2 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[15] = ({ _name : ("println" : stdgo.GoString), _nargs : (0 : stdgo.GoInt), _variadic : true, _kind : (2 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[16] = ({ _name : ("real" : stdgo.GoString), _nargs : (1 : stdgo.GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[17] = ({ _name : ("recover" : stdgo.GoString), _nargs : (0 : stdgo.GoInt), _variadic : false, _kind : (2 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[18] = ({ _name : ("Add" : stdgo.GoString), _nargs : (2 : stdgo.GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[19] = ({ _name : ("Alignof" : stdgo.GoString), _nargs : (1 : stdgo.GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[20] = ({ _name : ("Offsetof" : stdgo.GoString), _nargs : (1 : stdgo.GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[21] = ({ _name : ("Sizeof" : stdgo.GoString), _nargs : (1 : stdgo.GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[22] = ({ _name : ("Slice" : stdgo.GoString), _nargs : (2 : stdgo.GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[23] = ({ _name : ("SliceData" : stdgo.GoString), _nargs : (1 : stdgo.GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[24] = ({ _name : ("String" : stdgo.GoString), _nargs : (2 : stdgo.GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[25] = ({ _name : ("StringData" : stdgo.GoString), _nargs : (1 : stdgo.GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[26] = ({ _name : ("assert" : stdgo.GoString), _nargs : (1 : stdgo.GoInt), _variadic : false, _kind : (2 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[27] = ({ _name : ("trace" : stdgo.GoString), _nargs : (0 : stdgo.GoInt), _variadic : true, _kind : (2 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s;
    };
/**
    // Go versions that introduced language changes.
    
    // no version specified
**/
var _go0_0 : stdgo.go.types.Types.T_version = (new stdgo.go.types.Types.T_version((0 : stdgo.GoInt), (0 : stdgo.GoInt)) : stdgo.go.types.Types.T_version);
/**
    // Go versions that introduced language changes.
    
    
**/
var _go1_9 : stdgo.go.types.Types.T_version = (new stdgo.go.types.Types.T_version((1 : stdgo.GoInt), (9 : stdgo.GoInt)) : stdgo.go.types.Types.T_version);
/**
    // Go versions that introduced language changes.
    
    
**/
var _go1_13 : stdgo.go.types.Types.T_version = (new stdgo.go.types.Types.T_version((1 : stdgo.GoInt), (13 : stdgo.GoInt)) : stdgo.go.types.Types.T_version);
/**
    // Go versions that introduced language changes.
    
    
**/
var _go1_14 : stdgo.go.types.Types.T_version = (new stdgo.go.types.Types.T_version((1 : stdgo.GoInt), (14 : stdgo.GoInt)) : stdgo.go.types.Types.T_version);
/**
    // Go versions that introduced language changes.
    
    
**/
var _go1_17 : stdgo.go.types.Types.T_version = (new stdgo.go.types.Types.T_version((1 : stdgo.GoInt), (17 : stdgo.GoInt)) : stdgo.go.types.Types.T_version);
/**
    // Go versions that introduced language changes.
    
    
**/
var _go1_18 : stdgo.go.types.Types.T_version = (new stdgo.go.types.Types.T_version((1 : stdgo.GoInt), (18 : stdgo.GoInt)) : stdgo.go.types.Types.T_version);
/**
    // Go versions that introduced language changes.
    
    
**/
var _go1_20 : stdgo.go.types.Types.T_version = (new stdgo.go.types.Types.T_version((1 : stdgo.GoInt), (20 : stdgo.GoInt)) : stdgo.go.types.Types.T_version);
/**
    // Go versions that introduced language changes.
    
    
**/
var _go1_21 : stdgo.go.types.Types.T_version = (new stdgo.go.types.Types.T_version((1 : stdgo.GoInt), (21 : stdgo.GoInt)) : stdgo.go.types.Types.T_version);
/**
    
    
    
**/
var _assignOps : stdgo.GoMap<stdgo.go.token.Token.Token, stdgo.go.token.Token.Token> = ({
        final x = new stdgo.GoMap.GoIntMap<stdgo.go.token.Token.Token>();
        x.__defaultValue__ = () -> ((0 : stdgo.GoInt) : stdgo.go.token.Token.Token);
        @:mergeBlock {
            x.set((23 : stdgo.go.token.Token.Token), (12 : stdgo.go.token.Token.Token));
            x.set((24 : stdgo.go.token.Token.Token), (13 : stdgo.go.token.Token.Token));
            x.set((25 : stdgo.go.token.Token.Token), (14 : stdgo.go.token.Token.Token));
            x.set((26 : stdgo.go.token.Token.Token), (15 : stdgo.go.token.Token.Token));
            x.set((27 : stdgo.go.token.Token.Token), (16 : stdgo.go.token.Token.Token));
            x.set((28 : stdgo.go.token.Token.Token), (17 : stdgo.go.token.Token.Token));
            x.set((29 : stdgo.go.token.Token.Token), (18 : stdgo.go.token.Token.Token));
            x.set((30 : stdgo.go.token.Token.Token), (19 : stdgo.go.token.Token.Token));
            x.set((31 : stdgo.go.token.Token.Token), (20 : stdgo.go.token.Token.Token));
            x.set((32 : stdgo.go.token.Token.Token), (21 : stdgo.go.token.Token.Token));
            x.set((33 : stdgo.go.token.Token.Token), (22 : stdgo.go.token.Token.Token));
        };
        x;
    } : stdgo.GoMap<stdgo.go.token.Token.Token, stdgo.go.token.Token.Token>);
/**
    
    
    
**/
var _myInt : stdgo.go.types.Types.Type_ = {
        var a = function():Type_ {
            var _tname = newTypeName(_nopos, null, ("myInt" : stdgo.GoString), (null : stdgo.go.types.Types.Type_));
            return stdgo.Go.asInterface(newNamed(_tname, stdgo.Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]), (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>)));
        };
        a();
    };
/**
    
    
    
**/
var _testTerms : stdgo.GoMap<stdgo.GoString, stdgo.Ref<stdgo.go.types.Types.T_term>> = ({
        final x = new stdgo.GoMap.GoStringMap<stdgo.Ref<stdgo.go.types.Types.T_term>>();
        x.__defaultValue__ = () -> (null : stdgo.Ref<stdgo.go.types.Types.T_term>);
        @:mergeBlock {
            x.set(("∅" : stdgo.GoString), (null : stdgo.Ref<stdgo.go.types.Types.T_term>));
            x.set(("𝓤" : stdgo.GoString), (new stdgo.go.types.Types.T_term() : stdgo.go.types.Types.T_term));
            x.set(("int" : stdgo.GoString), (new stdgo.go.types.Types.T_term(false, stdgo.Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])) : stdgo.go.types.Types.T_term));
            x.set(("~int" : stdgo.GoString), (new stdgo.go.types.Types.T_term(true, stdgo.Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])) : stdgo.go.types.Types.T_term));
            x.set(("string" : stdgo.GoString), (new stdgo.go.types.Types.T_term(false, stdgo.Go.asInterface(typ[((17 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])) : stdgo.go.types.Types.T_term));
            x.set(("~string" : stdgo.GoString), (new stdgo.go.types.Types.T_term(true, stdgo.Go.asInterface(typ[((17 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])) : stdgo.go.types.Types.T_term));
            x.set(("myInt" : stdgo.GoString), (new stdgo.go.types.Types.T_term(false, _myInt) : stdgo.go.types.Types.T_term));
        };
        x;
    } : stdgo.GoMap<stdgo.GoString, stdgo.Ref<stdgo.go.types.Types.T_term>>);
/**
    
    
    
**/
var _parseGoVersionTests : stdgo.Slice<T__struct_8> = (new stdgo.Slice<T__struct_8>(3, 3, ({ _in : ("go1.21" : stdgo.GoString), _out : (new stdgo.go.types.Types.T_version((1 : stdgo.GoInt), (21 : stdgo.GoInt)) : stdgo.go.types.Types.T_version) } : T__struct_8), ({ _in : ("go1.21.0" : stdgo.GoString), _out : (new stdgo.go.types.Types.T_version((1 : stdgo.GoInt), (21 : stdgo.GoInt)) : stdgo.go.types.Types.T_version) } : T__struct_8), ({ _in : ("go1.21rc2" : stdgo.GoString), _out : (new stdgo.go.types.Types.T_version((1 : stdgo.GoInt), (21 : stdgo.GoInt)) : stdgo.go.types.Types.T_version) } : T__struct_8)) : stdgo.Slice<T__struct_8>);
/**
    
    
    // type is invalid
**/
final invalid : stdgo.go.types.Types.BasicKind = (25 : stdgo.go.types.Types.BasicKind);
/**
    // predeclared types
    
    
**/
final bool_ = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final int_ = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final int8 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final int16 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final int32 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final int64 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final uint = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final uint8 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final uint16 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final uint32 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final uint64 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final uintptr = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final float32 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final float64 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final complex64 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final complex128 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final string = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final unsafePointer = (25 : stdgo.go.types.Types.BasicKind);
/**
    // types for untyped values
    
    
**/
final untypedBool = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final untypedInt = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final untypedRune = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final untypedFloat = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final untypedComplex = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final untypedString = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final untypedNil = (25 : stdgo.go.types.Types.BasicKind);
/**
    // aliases
    
    
**/
final byte : stdgo.go.types.Types.BasicKind = (8 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final rune : stdgo.go.types.Types.BasicKind = (5 : stdgo.go.types.Types.BasicKind);
/**
    // Properties of basic types.
    
    
**/
final isBoolean : stdgo.go.types.Types.BasicInfo = (64 : stdgo.go.types.Types.BasicInfo);
/**
    // Properties of basic types.
    
    
**/
final isInteger = (64 : stdgo.go.types.Types.BasicInfo);
/**
    // Properties of basic types.
    
    
**/
final isUnsigned = (64 : stdgo.go.types.Types.BasicInfo);
/**
    // Properties of basic types.
    
    
**/
final isFloat = (64 : stdgo.go.types.Types.BasicInfo);
/**
    // Properties of basic types.
    
    
**/
final isComplex = (64 : stdgo.go.types.Types.BasicInfo);
/**
    // Properties of basic types.
    
    
**/
final isString = (64 : stdgo.go.types.Types.BasicInfo);
/**
    // Properties of basic types.
    
    
**/
final isUntyped = (64 : stdgo.go.types.Types.BasicInfo);
/**
    // Properties of basic types.
    
    
**/
final isOrdered : stdgo.go.types.Types.BasicInfo = (42 : stdgo.go.types.Types.BasicInfo);
/**
    // Properties of basic types.
    
    
**/
final isNumeric : stdgo.go.types.Types.BasicInfo = (26 : stdgo.go.types.Types.BasicInfo);
/**
    // Properties of basic types.
    
    
**/
final isConstType : stdgo.go.types.Types.BasicInfo = (59 : stdgo.go.types.Types.BasicInfo);
/**
    // The direction of a channel is indicated by one of these constants.
    
    
**/
final sendRecv : stdgo.go.types.Types.ChanDir = (2 : stdgo.go.types.Types.ChanDir);
/**
    // The direction of a channel is indicated by one of these constants.
    
    
**/
final sendOnly = (2 : stdgo.go.types.Types.ChanDir);
/**
    // The direction of a channel is indicated by one of these constants.
    
    
**/
final recvOnly = (2 : stdgo.go.types.Types.ChanDir);
/**
    // nopos indicates an unknown position
    
    
**/
var _nopos : stdgo.go.token.Token.Pos = ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos);
/**
    // debugging/development support
    
    // leave on during development
**/
final _debug : Bool = false;
/**
    
    
    
**/
final _invalidArg : stdgo.GoString = ("invalid argument: " : stdgo.GoString);
/**
    
    
    
**/
final _invalidOp : stdgo.GoString = ("invalid operation: " : stdgo.GoString);
/**
    
    
    
**/
var _unaryOpPredicates : T_opPredicates = (null : stdgo.go.types.Types.T_opPredicates);
/**
    
    
    
**/
var _binaryOpPredicates : T_opPredicates = (null : stdgo.go.types.Types.T_opPredicates);
/**
    
    
    
**/
final _conversion : stdgo.go.types.Types.T_exprKind = (2 : stdgo.go.types.Types.T_exprKind);
/**
    
    
    
**/
final _expression = (2 : stdgo.go.types.Types.T_exprKind);
/**
    
    
    
**/
final _statement = (2 : stdgo.go.types.Types.T_exprKind);
/**
    // If enableReverseTypeInference is set, uninstantiated and
    // partially instantiated generic functions may be assigned
    // (incl. returned) to variables of function type and type
    // inference will attempt to infer the missing type arguments.
    // Available with go1.21.
    
    // disable for debugging
**/
final _enableReverseTypeInference : Bool = true;
/**
    // Shared empty method set.
    
    
**/
var _emptyMethodSet : MethodSet = ({} : stdgo.go.types.Types.MethodSet);
/**
    
    
    // tparams, underlying type and methods might be unavailable
**/
final _unresolved : stdgo.go.types.Types.T_namedState = (2u32 : stdgo.go.types.Types.T_namedState);
/**
    
    
    // resolve has run; methods might be incomplete (for instances)
**/
final _resolved = (2u32 : stdgo.go.types.Types.T_namedState);
/**
    
    
    // all data is known
**/
final _complete = (2u32 : stdgo.go.types.Types.T_namedState);
/**
    // An object may be painted in one of three colors.
    // Color values other than white or black are considered grey.
    
    
**/
final _white : stdgo.go.types.Types.T_color = (2u32 : stdgo.go.types.Types.T_color);
/**
    // An object may be painted in one of three colors.
    // Color values other than white or black are considered grey.
    
    
**/
final _black = (2u32 : stdgo.go.types.Types.T_color);
/**
    // An object may be painted in one of three colors.
    // Color values other than white or black are considered grey.
    
    // must be > white and black
**/
final _grey = (2u32 : stdgo.go.types.Types.T_color);
/**
    
    
    // operand is invalid
**/
final _invalid : stdgo.go.types.Types.T_operandMode = (10 : stdgo.go.types.Types.T_operandMode);
/**
    
    
    // operand represents no value (result of a function call w/o result)
**/
final _novalue = (10 : stdgo.go.types.Types.T_operandMode);
/**
    
    
    // operand is a built-in function
**/
final _builtin = (10 : stdgo.go.types.Types.T_operandMode);
/**
    
    
    // operand is a type
**/
final _typexpr = (10 : stdgo.go.types.Types.T_operandMode);
/**
    
    
    // operand is a constant; the operand's typ is a Basic type
**/
final _constant_ = (10 : stdgo.go.types.Types.T_operandMode);
/**
    
    
    // operand is an addressable variable
**/
final _variable = (10 : stdgo.go.types.Types.T_operandMode);
/**
    
    
    // operand is a map index expression (acts like a variable on lhs, commaok on rhs of an assignment)
**/
final _mapindex = (10 : stdgo.go.types.Types.T_operandMode);
/**
    
    
    // operand is a computed value
**/
final _value = (10 : stdgo.go.types.Types.T_operandMode);
/**
    
    
    // like value, but operand may be used in a comma,ok expression
**/
final _commaok = (10 : stdgo.go.types.Types.T_operandMode);
/**
    
    
    // like commaok, but second value is error, not boolean
**/
final _commaerr = (10 : stdgo.go.types.Types.T_operandMode);
/**
    
    
    // operand is a cgo function
**/
final _cgofunc = (10 : stdgo.go.types.Types.T_operandMode);
/**
    
    
    // x.f is a struct field selector
**/
final fieldVal : stdgo.go.types.Types.SelectionKind = (2 : stdgo.go.types.Types.SelectionKind);
/**
    
    
    // x.f is a method selector
**/
final methodVal = (2 : stdgo.go.types.Types.SelectionKind);
/**
    
    
    // x.f is a method expression
**/
final methodExpr = (2 : stdgo.go.types.Types.SelectionKind);
/**
    // permissible control-flow statements
    
    
**/
final _breakOk : stdgo.go.types.Types.T_stmtContext = (16u32 : stdgo.go.types.Types.T_stmtContext);
/**
    
    
    
**/
final _continueOk = (16u32 : stdgo.go.types.Types.T_stmtContext);
/**
    
    
    
**/
final _fallthroughOk = (16u32 : stdgo.go.types.Types.T_stmtContext);
/**
    // additional context information
    
    
**/
final _finalSwitchCase = (16u32 : stdgo.go.types.Types.T_stmtContext);
/**
    
    
    
**/
final _inTypeSwitch = (16u32 : stdgo.go.types.Types.T_stmtContext);
/**
    // termSep is the separator used between individual terms.
    
    
**/
final _termSep : stdgo.GoString = (" | " : stdgo.GoString);
/**
    // Note: This is a uint32 rather than a uint64 because the
    // respective 64 bit atomic instructions are not available
    // on all platforms.
    
    
**/
var _lastID : stdgo.GoUInt32 = (0 : stdgo.GoUInt32);
/**
    // invalidTypeSet is a singleton type set to signal an invalid type set
    // due to an error. It's also a valid empty type set, so consumers of
    // type sets may choose to ignore it.
    
    
**/
var _invalidTypeSet : T__TypeSet = ({} : stdgo.go.types.Types.T__TypeSet);
/**
    // Upper limit for recursion depth. Used to catch infinite recursions
    // due to implementation issues (e.g., see issues go.dev/issue/48619, go.dev/issue/48656).
    
    
**/
final _unificationDepthLimit : stdgo.GoUInt64 = (50i64 : stdgo.GoUInt64);
/**
    // Whether to panic when unificationDepthLimit is reached.
    // If disabled, a recursion depth overflow results in a (quiet)
    // unification failure.
    
    
**/
final _panicAtUnificationDepthLimit : Bool = true;
/**
    // If enableCoreTypeUnification is set, unification will consider
    // the core types, if any, of non-local (unbound) type parameters.
    
    
**/
final _enableCoreTypeUnification : Bool = true;
/**
    // If traceInference is set, unification will print a trace of its operation.
    // Interpretation of trace:
    //   x ≡ y    attempt to unify types x and y
    //   p ➞ y    type parameter p is set to type y (p is inferred to be y)
    //   p ⇄ q    type parameters p and q match (p is inferred to be q and vice versa)
    //   x ≢ y    types x and y cannot be unified
    //   [p, q, ...] ➞ [x, y, ...]    mapping from type parameters to types
    
    
**/
final _traceInference : Bool = false;
/**
    // If assign is set, we are unifying types involved in an assignment:
    // they may match inexactly at the top, but element types must match
    // exactly.
    
    
**/
final _assign : stdgo.go.types.Types.T_unifyMode = (2u32 : stdgo.go.types.Types.T_unifyMode);
/**
    // If exact is set, types unify if they are identical (or can be
    // made identical with suitable arguments for type parameters).
    // Otherwise, a named type and a type literal unify if their
    // underlying types unify, channel directions are ignored, and
    // if there is an interface, the other type must implement the
    // interface.
    
    
**/
final _exact = (2u32 : stdgo.go.types.Types.T_unifyMode);
/**
    // Avoid excessive type-checking times due to quadratic termlist operations.
    
    
**/
final _maxTermCount : stdgo.GoUInt64 = (100i64 : stdgo.GoUInt64);
/**
    // The Universe scope contains all predeclared objects of Go.
    // It is the outermost scope of any chain of nested scopes.
    
    
**/
var universe : stdgo.Ref<Scope> = (null : stdgo.Ref<stdgo.go.types.Types.Scope>);
/**
    // The Unsafe package is the package returned by an importer
    // for the import path "unsafe".
    
    
**/
var unsafe : stdgo.Ref<Package> = (null : stdgo.Ref<stdgo.go.types.Types.Package>);
/**
    
    
    
**/
var _universeIota : Object = (null : stdgo.go.types.Types.Object);
/**
    
    
    // uint8 alias, but has name "byte"
**/
var _universeByte : Type_ = (null : stdgo.go.types.Types.Type_);
/**
    
    
    // int32 alias, but has name "rune"
**/
var _universeRune : Type_ = (null : stdgo.go.types.Types.Type_);
/**
    
    
    
**/
var _universeAny : Object = (null : stdgo.go.types.Types.Object);
/**
    
    
    
**/
var _universeError : Type_ = (null : stdgo.go.types.Types.Type_);
/**
    
    
    
**/
var _universeComparable : Object = (null : stdgo.go.types.Types.Object);
/**
    // universe scope
    
    
**/
final __Append : stdgo.go.types.Types.T_builtinId = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __Cap = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __Clear = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __Close = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __Complex = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __Copy = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __Delete = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __Imag = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __Len = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __Make = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __Max = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __Min = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __New = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __Panic = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __Print = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __Println = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __Real = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __Recover = (27 : stdgo.go.types.Types.T_builtinId);
/**
    // package unsafe
    
    
**/
final __Add = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __Alignof = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __Offsetof = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __Sizeof = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __Slice = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __SliceData = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __String = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __StringData = (27 : stdgo.go.types.Types.T_builtinId);
/**
    // testing support
    
    
**/
final __Assert = (27 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
final __Trace = (27 : stdgo.go.types.Types.T_builtinId);
/**
    // An Importer resolves import paths to Packages.
    //
    // CAUTION: This interface does not support the import of locally
    // vendored packages. See https://golang.org/s/go15vendor.
    // If possible, external implementations should implement ImporterFrom.
    
    
**/
typedef Importer = stdgo.StructType & {
    /**
        // Import returns the imported package for the given import path.
        // The semantics is like for ImporterFrom.ImportFrom except that
        // dir and mode are ignored (since they are not present).
        
        
    **/
    public dynamic function import_(_path:stdgo.GoString):{ var _0 : stdgo.Ref<Package>; var _1 : stdgo.Error; };
};
/**
    // An ImporterFrom resolves import paths to packages; it
    // supports vendoring per https://golang.org/s/go15vendor.
    // Use go/importer to obtain an ImporterFrom implementation.
    
    
**/
typedef ImporterFrom = stdgo.StructType & {
    > Importer,
    /**
        // ImportFrom returns the imported package for the given import
        // path when imported by a package file located in dir.
        // If the import failed, besides returning an error, ImportFrom
        // is encouraged to cache and return a package anyway, if one
        // was created. This will reduce package inconsistencies and
        // follow-on type checker errors due to the missing package.
        // The mode value must be 0; it is reserved for future use.
        // Two calls to ImportFrom with the same path and dir must
        // return the same package.
        
        
    **/
    public dynamic function importFrom(_path:stdgo.GoString, _dir:stdgo.GoString, _mode:ImportMode):{ var _0 : stdgo.Ref<Package>; var _1 : stdgo.Error; };
};
/**
    
    
    
**/
typedef T_cleaner = stdgo.StructType & {
    /**
        
        
        
    **/
    public dynamic function _cleanup():Void;
};
/**
    
    
    
**/
typedef T_decl = stdgo.StructType & {
    /**
        
        
        
    **/
    public dynamic function _node():stdgo.go.ast.Ast.Node;
};
/**
    // The positioner interface is used to extract the position of type-checker
    // errors.
    
    
**/
typedef T_positioner = stdgo.StructType & {
    /**
        
        
        
    **/
    public dynamic function pos():stdgo.go.token.Token.Pos;
};
/**
    // A dependency is an object that may be a dependency in an initialization
    // expression. Only constants, variables, and functions can be dependencies.
    // Constants are here because constant expression cycles are reported during
    // initialization order computation.
    
    
**/
typedef T_dependency = stdgo.StructType & {
    > Object,
    /**
        
        
        
    **/
    public dynamic function _isDependency():Void;
};
/**
    // An Object describes a named language entity such as a package,
    // constant, type, variable, function (incl. methods), or label.
    // All objects implement the Object interface.
    
    
**/
typedef Object = stdgo.StructType & {
    /**
        
        
        // scope in which this object is declared; nil for methods and struct fields
    **/
    public dynamic function parent():stdgo.Ref<Scope>;
    /**
        
        
        // position of object identifier in declaration
    **/
    public dynamic function pos():stdgo.go.token.Token.Pos;
    /**
        
        
        // package to which this object belongs; nil for labels and objects in the Universe scope
    **/
    public dynamic function pkg():stdgo.Ref<Package>;
    /**
        
        
        // package local object name
    **/
    public dynamic function name():stdgo.GoString;
    /**
        
        
        // object type
    **/
    public dynamic function type():Type_;
    /**
        
        
        // reports whether the name starts with a capital letter
    **/
    public dynamic function exported():Bool;
    /**
        
        
        // object name if exported, qualified name if not exported (see func Id)
    **/
    public dynamic function id():stdgo.GoString;
    /**
        // String returns a human-readable string of the object.
        
        
    **/
    public dynamic function string():stdgo.GoString;
    /**
        // order reflects a package-level object's source order: if object
        // a is before object b in the source, then a.order() < b.order().
        // order returns a value > 0 for package-level objects; it returns
        // 0 for all other objects (including objects in file scopes).
        
        
    **/
    public dynamic function _order():stdgo.GoUInt32;
    /**
        // color returns the object's color.
        
        
    **/
    public dynamic function _color():T_color;
    /**
        // setType sets the type of the object.
        
        
    **/
    public dynamic function _setType(_0:Type_):Void;
    /**
        // setOrder sets the order number of the object. It must be > 0.
        
        
    **/
    public dynamic function _setOrder(_0:stdgo.GoUInt32):Void;
    /**
        // setColor sets the object's color. It must not be white.
        
        
    **/
    public dynamic function _setColor(_color:T_color):Void;
    /**
        // setParent sets the parent scope of the object.
        
        
    **/
    public dynamic function _setParent(_0:stdgo.Ref<Scope>):Void;
    /**
        // sameId reports whether obj.Id() and Id(pkg, name) are the same.
        
        
    **/
    public dynamic function _sameId(_pkg:stdgo.Ref<Package>, _name:stdgo.GoString):Bool;
    /**
        // scopePos returns the start position of the scope of this Object
        
        
    **/
    public dynamic function _scopePos():stdgo.go.token.Token.Pos;
    /**
        // setScopePos sets the start position of the scope for this Object.
        
        
    **/
    public dynamic function _setScopePos(_pos:stdgo.go.token.Token.Pos):Void;
};
/**
    // Sizes defines the sizing functions for package unsafe.
    
    
**/
typedef Sizes = stdgo.StructType & {
    /**
        // Alignof returns the alignment of a variable of type T.
        // Alignof must implement the alignment guarantees required by the spec.
        // The result must be >= 1.
        
        
    **/
    public dynamic function alignof_(t:Type_):stdgo.GoInt64;
    /**
        // Offsetsof returns the offsets of the given struct fields, in bytes.
        // Offsetsof must implement the offset guarantees required by the spec.
        // A negative entry in the result indicates that the struct is too large.
        
        
    **/
    public dynamic function offsetsof(_fields:stdgo.Slice<stdgo.Ref<Var>>):stdgo.Slice<stdgo.GoInt64>;
    /**
        // Sizeof returns the size of a variable of type T.
        // Sizeof must implement the size guarantees required by the spec.
        // A negative result indicates that T is too large.
        
        
    **/
    public dynamic function sizeof(t:Type_):stdgo.GoInt64;
};
/**
    // A Type represents a type of Go.
    // All types implement the Type interface.
    
    
**/
typedef Type_ = stdgo.StructType & {
    /**
        // Underlying returns the underlying type of a type.
        
        
    **/
    public dynamic function underlying():Type_;
    /**
        // String returns a string representation of a type.
        
        
    **/
    public dynamic function string():stdgo.GoString;
};
/**
    // An Error describes a type-checking error; it implements the error interface.
    // A "soft" error is an error that still permits a valid interpretation of a
    // package (such as "unused variable"); "hard" errors may lead to unpredictable
    // behavior if ignored.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Error_static_extension) class Error {
    public var fset : stdgo.Ref<stdgo.go.token.Token.FileSet> = (null : stdgo.Ref<stdgo.go.token.Token.FileSet>);
    public var pos : stdgo.go.token.Token.Pos = ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos);
    public var msg : stdgo.GoString = "";
    public var soft : Bool = false;
    /**
        // go116code is a future API, unexported as the set of error codes is large
        // and likely to change significantly during experimentation. Tools wishing
        // to preview this feature may read go116code using reflection (see
        // errorcodes_test.go), but beware that there is no guarantee of future
        // compatibility.
    **/
    public var _go116code : stdgo.internal.types.errors.Errors.Code = ((0 : stdgo.GoInt) : stdgo.internal.types.errors.Errors.Code);
    public var _go116start : stdgo.go.token.Token.Pos = ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos);
    public var _go116end : stdgo.go.token.Token.Pos = ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos);
    public function new(?fset:stdgo.Ref<stdgo.go.token.Token.FileSet>, ?pos:stdgo.go.token.Token.Pos, ?msg:stdgo.GoString, ?soft:Bool, ?_go116code:stdgo.internal.types.errors.Errors.Code, ?_go116start:stdgo.go.token.Token.Pos, ?_go116end:stdgo.go.token.Token.Pos) {
        if (fset != null) this.fset = fset;
        if (pos != null) this.pos = pos;
        if (msg != null) this.msg = msg;
        if (soft != null) this.soft = soft;
        if (_go116code != null) this._go116code = _go116code;
        if (_go116start != null) this._go116start = _go116start;
        if (_go116end != null) this._go116end = _go116end;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Error(fset, pos, msg, soft, _go116code, _go116start, _go116end);
    }
}
/**
    // An ArgumentError holds an error associated with an argument index.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.ArgumentError_static_extension) class ArgumentError {
    public var index : stdgo.GoInt = 0;
    public var err : stdgo.Error = (null : stdgo.Error);
    public function new(?index:stdgo.GoInt, ?err:stdgo.Error) {
        if (index != null) this.index = index;
        if (err != null) this.err = err;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new ArgumentError(index, err);
    }
}
/**
    // A Config specifies the configuration for type checking.
    // The zero value for Config is a ready-to-use default configuration.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Config_static_extension) class Config {
    /**
        // Context is the context used for resolving global identifiers. If nil, the
        // type checker will initialize this field with a newly created context.
    **/
    public var context : stdgo.Ref<stdgo.go.types.Types.Context> = (null : stdgo.Ref<stdgo.go.types.Types.Context>);
    /**
        // GoVersion describes the accepted Go language version. The string must
        // start with a prefix of the form "go%d.%d" (e.g. "go1.20", "go1.21rc1", or
        // "go1.21.0") or it must be empty; an empty string disables Go language
        // version checks. If the format is invalid, invoking the type checker will
        // result in an error.
    **/
    public var goVersion : stdgo.GoString = "";
    /**
        // If IgnoreFuncBodies is set, function bodies are not
        // type-checked.
    **/
    public var ignoreFuncBodies : Bool = false;
    /**
        // If FakeImportC is set, `import "C"` (for packages requiring Cgo)
        // declares an empty "C" package and errors are omitted for qualified
        // identifiers referring to package C (which won't find an object).
        // This feature is intended for the standard library cmd/api tool.
        //
        // Caution: Effects may be unpredictable due to follow-on errors.
        //          Do not use casually!
    **/
    public var fakeImportC : Bool = false;
    /**
        // If go115UsesCgo is set, the type checker expects the
        // _cgo_gotypes.go file generated by running cmd/cgo to be
        // provided as a package source file. Qualified identifiers
        // referring to package C will be resolved to cgo-provided
        // declarations within _cgo_gotypes.go.
        //
        // It is an error to set both FakeImportC and go115UsesCgo.
    **/
    public var _go115UsesCgo : Bool = false;
    /**
        // If _Trace is set, a debug trace is printed to stdout.
    **/
    public var __Trace : Bool = false;
    /**
        // If Error != nil, it is called with each error found
        // during type checking; err has dynamic type Error.
        // Secondary errors (for instance, to enumerate all types
        // involved in an invalid recursive type declaration) have
        // error strings that start with a '\t' character.
        // If Error == nil, type-checking stops with the first
        // error found.
    **/
    public var error : stdgo.Error -> Void = null;
    /**
        // An importer is used to import packages referred to from
        // import declarations.
        // If the installed importer implements ImporterFrom, the type
        // checker calls ImportFrom instead of Import.
        // The type checker reports an error if an importer is needed
        // but none was installed.
    **/
    public var importer : stdgo.go.types.Types.Importer = (null : stdgo.go.types.Types.Importer);
    /**
        // If Sizes != nil, it provides the sizing functions for package unsafe.
        // Otherwise SizesFor("gc", "amd64") is used instead.
    **/
    public var sizes : stdgo.go.types.Types.Sizes = (null : stdgo.go.types.Types.Sizes);
    /**
        // If DisableUnusedImportCheck is set, packages are not checked
        // for unused imports.
    **/
    public var disableUnusedImportCheck : Bool = false;
    /**
        // If a non-empty _ErrorURL format string is provided, it is used
        // to format an error URL link that is appended to the first line
        // of an error message. ErrorURL must be a format string containing
        // exactly one "%s" format, e.g. "[go.dev/e/%s]".
    **/
    public var __ErrorURL : stdgo.GoString = "";
    public function new(?context:stdgo.Ref<stdgo.go.types.Types.Context>, ?goVersion:stdgo.GoString, ?ignoreFuncBodies:Bool, ?fakeImportC:Bool, ?_go115UsesCgo:Bool, ?__Trace:Bool, ?error:stdgo.Error -> Void, ?importer:stdgo.go.types.Types.Importer, ?sizes:stdgo.go.types.Types.Sizes, ?disableUnusedImportCheck:Bool, ?__ErrorURL:stdgo.GoString) {
        if (context != null) this.context = context;
        if (goVersion != null) this.goVersion = goVersion;
        if (ignoreFuncBodies != null) this.ignoreFuncBodies = ignoreFuncBodies;
        if (fakeImportC != null) this.fakeImportC = fakeImportC;
        if (_go115UsesCgo != null) this._go115UsesCgo = _go115UsesCgo;
        if (__Trace != null) this.__Trace = __Trace;
        if (error != null) this.error = error;
        if (importer != null) this.importer = importer;
        if (sizes != null) this.sizes = sizes;
        if (disableUnusedImportCheck != null) this.disableUnusedImportCheck = disableUnusedImportCheck;
        if (__ErrorURL != null) this.__ErrorURL = __ErrorURL;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Config(
context,
goVersion,
ignoreFuncBodies,
fakeImportC,
_go115UsesCgo,
__Trace,
error,
importer,
sizes,
disableUnusedImportCheck,
__ErrorURL);
    }
}
/**
    // Info holds result type information for a type-checked package.
    // Only the information for which a map is provided is collected.
    // If the package has type errors, the collected information may
    // be incomplete.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Info_static_extension) class Info {
    /**
        // Types maps expressions to their types, and for constant
        // expressions, also their values. Invalid expressions are
        // omitted.
        //
        // For (possibly parenthesized) identifiers denoting built-in
        // functions, the recorded signatures are call-site specific:
        // if the call result is not a constant, the recorded type is
        // an argument-specific signature. Otherwise, the recorded type
        // is invalid.
        //
        // The Types map does not record the type of every identifier,
        // only those that appear where an arbitrary expression is
        // permitted. For instance, the identifier f in a selector
        // expression x.f is found only in the Selections map, the
        // identifier z in a variable declaration 'var z int' is found
        // only in the Defs map, and identifiers denoting packages in
        // qualified identifiers are collected in the Uses map.
    **/
    public var types : stdgo.GoMap<stdgo.go.ast.Ast.Expr, stdgo.go.types.Types.TypeAndValue> = (null : stdgo.GoMap<stdgo.go.ast.Ast.Expr, stdgo.go.types.Types.TypeAndValue>);
    /**
        // Instances maps identifiers denoting generic types or functions to their
        // type arguments and instantiated type.
        //
        // For example, Instances will map the identifier for 'T' in the type
        // instantiation T[int, string] to the type arguments [int, string] and
        // resulting instantiated *Named type. Given a generic function
        // func F[A any](A), Instances will map the identifier for 'F' in the call
        // expression F(int(1)) to the inferred type arguments [int], and resulting
        // instantiated *Signature.
        //
        // Invariant: Instantiating Uses[id].Type() with Instances[id].TypeArgs
        // results in an equivalent of Instances[id].Type.
    **/
    public var instances : stdgo.GoMap<stdgo.Ref<stdgo.go.ast.Ast.Ident>, stdgo.go.types.Types.Instance> = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.ast.Ast.Ident>, stdgo.go.types.Types.Instance>);
    /**
        // Defs maps identifiers to the objects they define (including
        // package names, dots "." of dot-imports, and blank "_" identifiers).
        // For identifiers that do not denote objects (e.g., the package name
        // in package clauses, or symbolic variables t in t := x.(type) of
        // type switch headers), the corresponding objects are nil.
        //
        // For an embedded field, Defs returns the field *Var it defines.
        //
        // Invariant: Defs[id] == nil || Defs[id].Pos() == id.Pos()
    **/
    public var defs : stdgo.GoMap<stdgo.Ref<stdgo.go.ast.Ast.Ident>, stdgo.go.types.Types.Object> = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.ast.Ast.Ident>, stdgo.go.types.Types.Object>);
    /**
        // Uses maps identifiers to the objects they denote.
        //
        // For an embedded field, Uses returns the *TypeName it denotes.
        //
        // Invariant: Uses[id].Pos() != id.Pos()
    **/
    public var uses : stdgo.GoMap<stdgo.Ref<stdgo.go.ast.Ast.Ident>, stdgo.go.types.Types.Object> = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.ast.Ast.Ident>, stdgo.go.types.Types.Object>);
    /**
        // Implicits maps nodes to their implicitly declared objects, if any.
        // The following node and object types may appear:
        //
        //     node               declared object
        //
        //     *ast.ImportSpec    *PkgName for imports without renames
        //     *ast.CaseClause    type-specific *Var for each type switch case clause (incl. default)
        //     *ast.Field         anonymous parameter *Var (incl. unnamed results)
        //
    **/
    public var implicits : stdgo.GoMap<stdgo.go.ast.Ast.Node, stdgo.go.types.Types.Object> = (null : stdgo.GoMap<stdgo.go.ast.Ast.Node, stdgo.go.types.Types.Object>);
    /**
        // Selections maps selector expressions (excluding qualified identifiers)
        // to their corresponding selections.
    **/
    public var selections : stdgo.GoMap<stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>, stdgo.Ref<stdgo.go.types.Types.Selection>> = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>, stdgo.Ref<stdgo.go.types.Types.Selection>>);
    /**
        // Scopes maps ast.Nodes to the scopes they define. Package scopes are not
        // associated with a specific node but with all files belonging to a package.
        // Thus, the package scope can be found in the type-checked Package object.
        // Scopes nest, with the Universe scope being the outermost scope, enclosing
        // the package scope, which contains (one or more) files scopes, which enclose
        // function scopes which in turn enclose statement and function literal scopes.
        // Note that even though package-level functions are declared in the package
        // scope, the function scopes are embedded in the file scope of the file
        // containing the function declaration.
        //
        // The following node types may appear in Scopes:
        //
        //     *ast.File
        //     *ast.FuncType
        //     *ast.TypeSpec
        //     *ast.BlockStmt
        //     *ast.IfStmt
        //     *ast.SwitchStmt
        //     *ast.TypeSwitchStmt
        //     *ast.CaseClause
        //     *ast.CommClause
        //     *ast.ForStmt
        //     *ast.RangeStmt
        //
    **/
    public var scopes : stdgo.GoMap<stdgo.go.ast.Ast.Node, stdgo.Ref<stdgo.go.types.Types.Scope>> = (null : stdgo.GoMap<stdgo.go.ast.Ast.Node, stdgo.Ref<stdgo.go.types.Types.Scope>>);
    /**
        // InitOrder is the list of package-level initializers in the order in which
        // they must be executed. Initializers referring to variables related by an
        // initialization dependency appear in topological order, the others appear
        // in source order. Variables without an initialization expression do not
        // appear in this list.
    **/
    public var initOrder : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Initializer>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Initializer>>);
    public function new(?types:stdgo.GoMap<stdgo.go.ast.Ast.Expr, stdgo.go.types.Types.TypeAndValue>, ?instances:stdgo.GoMap<stdgo.Ref<stdgo.go.ast.Ast.Ident>, stdgo.go.types.Types.Instance>, ?defs:stdgo.GoMap<stdgo.Ref<stdgo.go.ast.Ast.Ident>, stdgo.go.types.Types.Object>, ?uses:stdgo.GoMap<stdgo.Ref<stdgo.go.ast.Ast.Ident>, stdgo.go.types.Types.Object>, ?implicits:stdgo.GoMap<stdgo.go.ast.Ast.Node, stdgo.go.types.Types.Object>, ?selections:stdgo.GoMap<stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>, stdgo.Ref<stdgo.go.types.Types.Selection>>, ?scopes:stdgo.GoMap<stdgo.go.ast.Ast.Node, stdgo.Ref<stdgo.go.types.Types.Scope>>, ?initOrder:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Initializer>>) {
        if (types != null) this.types = types;
        if (instances != null) this.instances = instances;
        if (defs != null) this.defs = defs;
        if (uses != null) this.uses = uses;
        if (implicits != null) this.implicits = implicits;
        if (selections != null) this.selections = selections;
        if (scopes != null) this.scopes = scopes;
        if (initOrder != null) this.initOrder = initOrder;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Info(types, instances, defs, uses, implicits, selections, scopes, initOrder);
    }
}
/**
    // TypeAndValue reports the type and value (for constants)
    // of the corresponding expression.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.TypeAndValue_static_extension) class TypeAndValue {
    public var _mode : stdgo.go.types.Types.T_operandMode = ((0 : stdgo.GoUInt8) : stdgo.go.types.Types.T_operandMode);
    public var type : stdgo.go.types.Types.Type_ = (null : stdgo.go.types.Types.Type_);
    public var value : stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
    public function new(?_mode:stdgo.go.types.Types.T_operandMode, ?type:stdgo.go.types.Types.Type_, ?value:stdgo.go.constant.Constant.Value) {
        if (_mode != null) this._mode = _mode;
        if (type != null) this.type = type;
        if (value != null) this.value = value;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new TypeAndValue(_mode, type, value);
    }
}
/**
    // Instance reports the type arguments and instantiated type for type and
    // function instantiations. For type instantiations, Type will be of dynamic
    // type *Named. For function instantiations, Type will be of dynamic type
    // *Signature.
    
    
**/
@:structInit class Instance {
    public var typeArgs : stdgo.Ref<stdgo.go.types.Types.TypeList> = (null : stdgo.Ref<stdgo.go.types.Types.TypeList>);
    public var type : stdgo.go.types.Types.Type_ = (null : stdgo.go.types.Types.Type_);
    public function new(?typeArgs:stdgo.Ref<stdgo.go.types.Types.TypeList>, ?type:stdgo.go.types.Types.Type_) {
        if (typeArgs != null) this.typeArgs = typeArgs;
        if (type != null) this.type = type;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Instance(typeArgs, type);
    }
}
/**
    // An Initializer describes a package-level variable, or a list of variables in case
    // of a multi-valued initialization expression, and the corresponding initialization
    // expression.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Initializer_static_extension) class Initializer {
    public var lhs : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>);
    public var rhs : stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
    public function new(?lhs:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>, ?rhs:stdgo.go.ast.Ast.Expr) {
        if (lhs != null) this.lhs = lhs;
        if (rhs != null) this.rhs = rhs;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Initializer(lhs, rhs);
    }
}
/**
    // An Array represents an array type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Array__static_extension) class Array_ {
    public var _len : stdgo.GoInt64 = 0;
    public var _elem : stdgo.go.types.Types.Type_ = (null : stdgo.go.types.Types.Type_);
    public function new(?_len:stdgo.GoInt64, ?_elem:stdgo.go.types.Types.Type_) {
        if (_len != null) this._len = _len;
        if (_elem != null) this._elem = _elem;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Array_(_len, _elem);
    }
}
/**
    // A Basic represents a basic type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Basic_static_extension) class Basic {
    public var _kind : stdgo.go.types.Types.BasicKind = ((0 : stdgo.GoInt) : stdgo.go.types.Types.BasicKind);
    public var _info : stdgo.go.types.Types.BasicInfo = ((0 : stdgo.GoInt) : stdgo.go.types.Types.BasicInfo);
    public var _name : stdgo.GoString = "";
    public function new(?_kind:stdgo.go.types.Types.BasicKind, ?_info:stdgo.go.types.Types.BasicInfo, ?_name:stdgo.GoString) {
        if (_kind != null) this._kind = _kind;
        if (_info != null) this._info = _info;
        if (_name != null) this._name = _name;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Basic(_kind, _info, _name);
    }
}
/**
    // A Chan represents a channel type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Chan_static_extension) class Chan {
    public var _dir : stdgo.go.types.Types.ChanDir = ((0 : stdgo.GoInt) : stdgo.go.types.Types.ChanDir);
    public var _elem : stdgo.go.types.Types.Type_ = (null : stdgo.go.types.Types.Type_);
    public function new(?_dir:stdgo.go.types.Types.ChanDir, ?_elem:stdgo.go.types.Types.Type_) {
        if (_dir != null) this._dir = _dir;
        if (_elem != null) this._elem = _elem;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Chan(_dir, _elem);
    }
}
/**
    // exprInfo stores information about an untyped expression.
    
    
**/
@:structInit @:private class T_exprInfo {
    public var _isLhs : Bool = false;
    public var _mode : stdgo.go.types.Types.T_operandMode = ((0 : stdgo.GoUInt8) : stdgo.go.types.Types.T_operandMode);
    public var _typ : stdgo.Ref<stdgo.go.types.Types.Basic> = (null : stdgo.Ref<stdgo.go.types.Types.Basic>);
    public var _val : stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
    public function new(?_isLhs:Bool, ?_mode:stdgo.go.types.Types.T_operandMode, ?_typ:stdgo.Ref<stdgo.go.types.Types.Basic>, ?_val:stdgo.go.constant.Constant.Value) {
        if (_isLhs != null) this._isLhs = _isLhs;
        if (_mode != null) this._mode = _mode;
        if (_typ != null) this._typ = _typ;
        if (_val != null) this._val = _val;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_exprInfo(_isLhs, _mode, _typ, _val);
    }
}
/**
    // An environment represents the environment within which an object is
    // type-checked.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_environment_static_extension) class T_environment {
    public var _decl : stdgo.Ref<stdgo.go.types.Types.T_declInfo> = (null : stdgo.Ref<stdgo.go.types.Types.T_declInfo>);
    public var _scope : stdgo.Ref<stdgo.go.types.Types.Scope> = (null : stdgo.Ref<stdgo.go.types.Types.Scope>);
    public var _pos : stdgo.go.token.Token.Pos = ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos);
    public var _iota : stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
    public var _errpos : stdgo.go.types.Types.T_positioner = (null : stdgo.go.types.Types.T_positioner);
    public var _inTParamList : Bool = false;
    public var _sig : stdgo.Ref<stdgo.go.types.Types.Signature> = (null : stdgo.Ref<stdgo.go.types.Types.Signature>);
    public var _isPanic : stdgo.GoMap<stdgo.Ref<stdgo.go.ast.Ast.CallExpr>, Bool> = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.ast.Ast.CallExpr>, Bool>);
    public var _hasLabel : Bool = false;
    public var _hasCallOrRecv : Bool = false;
    public function new(?_decl:stdgo.Ref<stdgo.go.types.Types.T_declInfo>, ?_scope:stdgo.Ref<stdgo.go.types.Types.Scope>, ?_pos:stdgo.go.token.Token.Pos, ?_iota:stdgo.go.constant.Constant.Value, ?_errpos:stdgo.go.types.Types.T_positioner, ?_inTParamList:Bool, ?_sig:stdgo.Ref<stdgo.go.types.Types.Signature>, ?_isPanic:stdgo.GoMap<stdgo.Ref<stdgo.go.ast.Ast.CallExpr>, Bool>, ?_hasLabel:Bool, ?_hasCallOrRecv:Bool) {
        if (_decl != null) this._decl = _decl;
        if (_scope != null) this._scope = _scope;
        if (_pos != null) this._pos = _pos;
        if (_iota != null) this._iota = _iota;
        if (_errpos != null) this._errpos = _errpos;
        if (_inTParamList != null) this._inTParamList = _inTParamList;
        if (_sig != null) this._sig = _sig;
        if (_isPanic != null) this._isPanic = _isPanic;
        if (_hasLabel != null) this._hasLabel = _hasLabel;
        if (_hasCallOrRecv != null) this._hasCallOrRecv = _hasCallOrRecv;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_environment(_decl, _scope, _pos, _iota, _errpos, _inTParamList, _sig, _isPanic, _hasLabel, _hasCallOrRecv);
    }
}
/**
    // An importKey identifies an imported package by import path and source directory
    // (directory containing the file containing the import). In practice, the directory
    // may always be the same, or may not matter. Given an (import path, directory), an
    // importer must always return the same package (but given two different import paths,
    // an importer may still return the same package by mapping them to the same package
    // paths).
    
    
**/
@:structInit @:private class T_importKey {
    public var _path : stdgo.GoString = "";
    public var _dir : stdgo.GoString = "";
    public function new(?_path:stdgo.GoString, ?_dir:stdgo.GoString) {
        if (_path != null) this._path = _path;
        if (_dir != null) this._dir = _dir;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_importKey(_path, _dir);
    }
}
/**
    // A dotImportKey describes a dot-imported object in the given scope.
    
    
**/
@:structInit @:private class T_dotImportKey {
    public var _scope : stdgo.Ref<stdgo.go.types.Types.Scope> = (null : stdgo.Ref<stdgo.go.types.Types.Scope>);
    public var _name : stdgo.GoString = "";
    public function new(?_scope:stdgo.Ref<stdgo.go.types.Types.Scope>, ?_name:stdgo.GoString) {
        if (_scope != null) this._scope = _scope;
        if (_name != null) this._name = _name;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_dotImportKey(_scope, _name);
    }
}
/**
    // An action describes a (delayed) action.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_action_static_extension) class T_action {
    public var _f : () -> Void = null;
    public var _desc : stdgo.Ref<stdgo.go.types.Types.T_actionDesc> = (null : stdgo.Ref<stdgo.go.types.Types.T_actionDesc>);
    public function new(?_f:() -> Void, ?_desc:stdgo.Ref<stdgo.go.types.Types.T_actionDesc>) {
        if (_f != null) this._f = _f;
        if (_desc != null) this._desc = _desc;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_action(_f, _desc);
    }
}
/**
    // An actionDesc provides information on an action.
    // For debugging only.
    
    
**/
@:structInit @:private class T_actionDesc {
    public var _pos : stdgo.go.types.Types.T_positioner = (null : stdgo.go.types.Types.T_positioner);
    public var _format : stdgo.GoString = "";
    public var _args : stdgo.Slice<stdgo.AnyInterface> = (null : stdgo.Slice<stdgo.AnyInterface>);
    public function new(?_pos:stdgo.go.types.Types.T_positioner, ?_format:stdgo.GoString, ?_args:stdgo.Slice<stdgo.AnyInterface>) {
        if (_pos != null) this._pos = _pos;
        if (_format != null) this._format = _format;
        if (_args != null) this._args = _args;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_actionDesc(_pos, _format, _args);
    }
}
/**
    // A Checker maintains the state of the type checker.
    // It must be created with NewChecker.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Checker_static_extension) class Checker {
    /**
        // package information
        // (initialized by NewChecker, valid for the life-time of checker)
    **/
    public var _conf : stdgo.Ref<stdgo.go.types.Types.Config> = (null : stdgo.Ref<stdgo.go.types.Types.Config>);
    public var _ctxt : stdgo.Ref<stdgo.go.types.Types.Context> = (null : stdgo.Ref<stdgo.go.types.Types.Context>);
    public var _fset : stdgo.Ref<stdgo.go.token.Token.FileSet> = (null : stdgo.Ref<stdgo.go.token.Token.FileSet>);
    public var _pkg : stdgo.Ref<stdgo.go.types.Types.Package> = (null : stdgo.Ref<stdgo.go.types.Types.Package>);
    @:embedded
    public var info : stdgo.Ref<stdgo.go.types.Types.Info> = (null : stdgo.Ref<stdgo.go.types.Types.Info>);
    public var _version : stdgo.go.types.Types.T_version = ({} : stdgo.go.types.Types.T_version);
    public var _nextID : stdgo.GoUInt64 = 0;
    public var _objMap : stdgo.GoMap<stdgo.go.types.Types.Object, stdgo.Ref<stdgo.go.types.Types.T_declInfo>> = (null : stdgo.GoMap<stdgo.go.types.Types.Object, stdgo.Ref<stdgo.go.types.Types.T_declInfo>>);
    public var _impMap : stdgo.GoMap<stdgo.go.types.Types.T_importKey, stdgo.Ref<stdgo.go.types.Types.Package>> = (null : stdgo.GoMap<stdgo.go.types.Types.T_importKey, stdgo.Ref<stdgo.go.types.Types.Package>>);
    public var _valids : stdgo.go.types.Types.T_instanceLookup = ({} : stdgo.go.types.Types.T_instanceLookup);
    /**
        // pkgPathMap maps package names to the set of distinct import paths we've
        // seen for that name, anywhere in the import graph. It is used for
        // disambiguating package names in error messages.
        //
        // pkgPathMap is allocated lazily, so that we don't pay the price of building
        // it on the happy path. seenPkgMap tracks the packages that we've already
        // walked.
    **/
    public var _pkgPathMap : stdgo.GoMap<stdgo.GoString, stdgo.GoMap<stdgo.GoString, Bool>> = (null : stdgo.GoMap<stdgo.GoString, stdgo.GoMap<stdgo.GoString, Bool>>);
    public var _seenPkgMap : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Package>, Bool> = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Package>, Bool>);
    /**
        // information collected during type-checking of a set of package files
        // (initialized by Files, valid only for the duration of check.Files;
        // maps and lists are allocated on demand)
    **/
    public var _files : stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.File>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.File>>);
    public var _posVers : stdgo.GoMap<stdgo.Ref<stdgo.go.token.Token.File>, stdgo.go.types.Types.T_version> = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.token.Token.File>, stdgo.go.types.Types.T_version>);
    public var _imports : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.PkgName>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.PkgName>>);
    public var _dotImportMap : stdgo.GoMap<stdgo.go.types.Types.T_dotImportKey, stdgo.Ref<stdgo.go.types.Types.PkgName>> = (null : stdgo.GoMap<stdgo.go.types.Types.T_dotImportKey, stdgo.Ref<stdgo.go.types.Types.PkgName>>);
    public var _recvTParamMap : stdgo.GoMap<stdgo.Ref<stdgo.go.ast.Ast.Ident>, stdgo.Ref<stdgo.go.types.Types.TypeParam>> = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.ast.Ast.Ident>, stdgo.Ref<stdgo.go.types.Types.TypeParam>>);
    public var _brokenAliases : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, Bool> = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, Bool>);
    public var _unionTypeSets : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Union>, stdgo.Ref<stdgo.go.types.Types.T__TypeSet>> = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Union>, stdgo.Ref<stdgo.go.types.Types.T__TypeSet>>);
    public var _mono : stdgo.go.types.Types.T_monoGraph = ({} : stdgo.go.types.Types.T_monoGraph);
    public var _firstErr : stdgo.Error = (null : stdgo.Error);
    public var _methods : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>> = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>>);
    public var _untyped : stdgo.GoMap<stdgo.go.ast.Ast.Expr, stdgo.go.types.Types.T_exprInfo> = (null : stdgo.GoMap<stdgo.go.ast.Ast.Expr, stdgo.go.types.Types.T_exprInfo>);
    public var _delayed : stdgo.Slice<stdgo.go.types.Types.T_action> = (null : stdgo.Slice<stdgo.go.types.Types.T_action>);
    public var _objPath : stdgo.Slice<stdgo.go.types.Types.Object> = (null : stdgo.Slice<stdgo.go.types.Types.Object>);
    public var _cleaners : stdgo.Slice<stdgo.go.types.Types.T_cleaner> = (null : stdgo.Slice<stdgo.go.types.Types.T_cleaner>);
    /**
        // environment within which the current object is type-checked (valid only
        // for the duration of type-checking a specific object)
    **/
    @:embedded
    public var _environment : stdgo.go.types.Types.T_environment = ({} : stdgo.go.types.Types.T_environment);
    /**
        // debugging
    **/
    public var _indent : stdgo.GoInt = 0;
    public function new(?_conf:stdgo.Ref<stdgo.go.types.Types.Config>, ?_ctxt:stdgo.Ref<stdgo.go.types.Types.Context>, ?_fset:stdgo.Ref<stdgo.go.token.Token.FileSet>, ?_pkg:stdgo.Ref<stdgo.go.types.Types.Package>, ?info:stdgo.Ref<stdgo.go.types.Types.Info>, ?_version:stdgo.go.types.Types.T_version, ?_nextID:stdgo.GoUInt64, ?_objMap:stdgo.GoMap<stdgo.go.types.Types.Object, stdgo.Ref<stdgo.go.types.Types.T_declInfo>>, ?_impMap:stdgo.GoMap<stdgo.go.types.Types.T_importKey, stdgo.Ref<stdgo.go.types.Types.Package>>, ?_valids:stdgo.go.types.Types.T_instanceLookup, ?_pkgPathMap:stdgo.GoMap<stdgo.GoString, stdgo.GoMap<stdgo.GoString, Bool>>, ?_seenPkgMap:stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Package>, Bool>, ?_files:stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.File>>, ?_posVers:stdgo.GoMap<stdgo.Ref<stdgo.go.token.Token.File>, stdgo.go.types.Types.T_version>, ?_imports:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.PkgName>>, ?_dotImportMap:stdgo.GoMap<stdgo.go.types.Types.T_dotImportKey, stdgo.Ref<stdgo.go.types.Types.PkgName>>, ?_recvTParamMap:stdgo.GoMap<stdgo.Ref<stdgo.go.ast.Ast.Ident>, stdgo.Ref<stdgo.go.types.Types.TypeParam>>, ?_brokenAliases:stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, Bool>, ?_unionTypeSets:stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Union>, stdgo.Ref<stdgo.go.types.Types.T__TypeSet>>, ?_mono:stdgo.go.types.Types.T_monoGraph, ?_firstErr:stdgo.Error, ?_methods:stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>>, ?_untyped:stdgo.GoMap<stdgo.go.ast.Ast.Expr, stdgo.go.types.Types.T_exprInfo>, ?_delayed:stdgo.Slice<stdgo.go.types.Types.T_action>, ?_objPath:stdgo.Slice<stdgo.go.types.Types.Object>, ?_cleaners:stdgo.Slice<stdgo.go.types.Types.T_cleaner>, ?_environment:stdgo.go.types.Types.T_environment, ?_indent:stdgo.GoInt) {
        if (_conf != null) this._conf = _conf;
        if (_ctxt != null) this._ctxt = _ctxt;
        if (_fset != null) this._fset = _fset;
        if (_pkg != null) this._pkg = _pkg;
        if (info != null) this.info = info;
        if (_version != null) this._version = _version;
        if (_nextID != null) this._nextID = _nextID;
        if (_objMap != null) this._objMap = _objMap;
        if (_impMap != null) this._impMap = _impMap;
        if (_valids != null) this._valids = _valids;
        if (_pkgPathMap != null) this._pkgPathMap = _pkgPathMap;
        if (_seenPkgMap != null) this._seenPkgMap = _seenPkgMap;
        if (_files != null) this._files = _files;
        if (_posVers != null) this._posVers = _posVers;
        if (_imports != null) this._imports = _imports;
        if (_dotImportMap != null) this._dotImportMap = _dotImportMap;
        if (_recvTParamMap != null) this._recvTParamMap = _recvTParamMap;
        if (_brokenAliases != null) this._brokenAliases = _brokenAliases;
        if (_unionTypeSets != null) this._unionTypeSets = _unionTypeSets;
        if (_mono != null) this._mono = _mono;
        if (_firstErr != null) this._firstErr = _firstErr;
        if (_methods != null) this._methods = _methods;
        if (_untyped != null) this._untyped = _untyped;
        if (_delayed != null) this._delayed = _delayed;
        if (_objPath != null) this._objPath = _objPath;
        if (_cleaners != null) this._cleaners = _cleaners;
        if (_environment != null) this._environment = _environment;
        if (_indent != null) this._indent = _indent;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    @:embedded
    public function objectOf(_id:stdgo.Ref<stdgo.go.ast.Ast.Ident>):stdgo.go.types.Types.Object return info.objectOf(_id);
    @:embedded
    public function typeOf(_e:stdgo.go.ast.Ast.Expr):stdgo.go.types.Types.Type_ return info.typeOf(_e);
    @:embedded
    public function _lookup(__0:stdgo.GoString):stdgo.go.types.Types.Object return _environment._lookup(__0);
    @:embedded
    public function _recordTypes():Bool return info._recordTypes();
    public function __copy__() {
        return new Checker(
_conf,
_ctxt,
_fset,
_pkg,
info,
_version,
_nextID,
_objMap,
_impMap,
_valids,
_pkgPathMap,
_seenPkgMap,
_files,
_posVers,
_imports,
_dotImportMap,
_recvTParamMap,
_brokenAliases,
_unionTypeSets,
_mono,
_firstErr,
_methods,
_untyped,
_delayed,
_objPath,
_cleaners,
_environment,
_indent);
    }
}
/**
    // A posVers records that the file starting at pos declares the Go version vers.
    
    
**/
@:structInit @:private class T_posVers {
    public var _pos : stdgo.go.token.Token.Pos = ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos);
    public var _vers : stdgo.go.types.Types.T_version = ({} : stdgo.go.types.Types.T_version);
    public function new(?_pos:stdgo.go.token.Token.Pos, ?_vers:stdgo.go.types.Types.T_version) {
        if (_pos != null) this._pos = _pos;
        if (_vers != null) this._vers = _vers;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_posVers(_pos, _vers);
    }
}
/**
    // A bailout panic is used for early termination.
    
    
**/
@:structInit @:private class T_bailout {
    public function new() {}
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_bailout();
    }
}
/**
    // A Context is an opaque type checking context. It may be used to share
    // identical type instances across type-checked packages or calls to
    // Instantiate. Contexts are safe for concurrent use.
    //
    // The use of a shared context does not guarantee that identical instances are
    // deduplicated in all cases.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Context_static_extension) class Context {
    public var _mu : stdgo.sync.Sync.Mutex = ({} : stdgo.sync.Sync.Mutex);
    public var _typeMap : stdgo.GoMap<stdgo.GoString, stdgo.Slice<stdgo.go.types.Types.T_ctxtEntry>> = (null : stdgo.GoMap<stdgo.GoString, stdgo.Slice<stdgo.go.types.Types.T_ctxtEntry>>);
    public var _nextID : stdgo.GoInt = 0;
    public var _originIDs : stdgo.GoMap<stdgo.go.types.Types.Type_, stdgo.GoInt> = (null : stdgo.GoMap<stdgo.go.types.Types.Type_, stdgo.GoInt>);
    public function new(?_mu:stdgo.sync.Sync.Mutex, ?_typeMap:stdgo.GoMap<stdgo.GoString, stdgo.Slice<stdgo.go.types.Types.T_ctxtEntry>>, ?_nextID:stdgo.GoInt, ?_originIDs:stdgo.GoMap<stdgo.go.types.Types.Type_, stdgo.GoInt>) {
        if (_mu != null) this._mu = _mu;
        if (_typeMap != null) this._typeMap = _typeMap;
        if (_nextID != null) this._nextID = _nextID;
        if (_originIDs != null) this._originIDs = _originIDs;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Context(_mu, _typeMap, _nextID, _originIDs);
    }
}
/**
    
    
    
**/
@:structInit @:private class T_ctxtEntry {
    public var _orig : stdgo.go.types.Types.Type_ = (null : stdgo.go.types.Types.Type_);
    public var _targs : stdgo.Slice<stdgo.go.types.Types.Type_> = (null : stdgo.Slice<stdgo.go.types.Types.Type_>);
    public var _instance : stdgo.go.types.Types.Type_ = (null : stdgo.go.types.Types.Type_);
    public function new(?_orig:stdgo.go.types.Types.Type_, ?_targs:stdgo.Slice<stdgo.go.types.Types.Type_>, ?_instance:stdgo.go.types.Types.Type_) {
        if (_orig != null) this._orig = _orig;
        if (_targs != null) this._targs = _targs;
        if (_instance != null) this._instance = _instance;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_ctxtEntry(_orig, _targs, _instance);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_importDecl_static_extension) class T_importDecl {
    public var _spec : stdgo.Ref<stdgo.go.ast.Ast.ImportSpec> = (null : stdgo.Ref<stdgo.go.ast.Ast.ImportSpec>);
    public function new(?_spec:stdgo.Ref<stdgo.go.ast.Ast.ImportSpec>) {
        if (_spec != null) this._spec = _spec;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_importDecl(_spec);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_constDecl_static_extension) class T_constDecl {
    public var _spec : stdgo.Ref<stdgo.go.ast.Ast.ValueSpec> = (null : stdgo.Ref<stdgo.go.ast.Ast.ValueSpec>);
    public var _iota : stdgo.GoInt = 0;
    public var _typ : stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
    public var _init : stdgo.Slice<stdgo.go.ast.Ast.Expr> = (null : stdgo.Slice<stdgo.go.ast.Ast.Expr>);
    public var _inherited : Bool = false;
    public function new(?_spec:stdgo.Ref<stdgo.go.ast.Ast.ValueSpec>, ?_iota:stdgo.GoInt, ?_typ:stdgo.go.ast.Ast.Expr, ?_init:stdgo.Slice<stdgo.go.ast.Ast.Expr>, ?_inherited:Bool) {
        if (_spec != null) this._spec = _spec;
        if (_iota != null) this._iota = _iota;
        if (_typ != null) this._typ = _typ;
        if (_init != null) this._init = _init;
        if (_inherited != null) this._inherited = _inherited;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_constDecl(_spec, _iota, _typ, _init, _inherited);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_varDecl_static_extension) class T_varDecl {
    public var _spec : stdgo.Ref<stdgo.go.ast.Ast.ValueSpec> = (null : stdgo.Ref<stdgo.go.ast.Ast.ValueSpec>);
    public function new(?_spec:stdgo.Ref<stdgo.go.ast.Ast.ValueSpec>) {
        if (_spec != null) this._spec = _spec;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_varDecl(_spec);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_typeDecl_static_extension) class T_typeDecl {
    public var _spec : stdgo.Ref<stdgo.go.ast.Ast.TypeSpec> = (null : stdgo.Ref<stdgo.go.ast.Ast.TypeSpec>);
    public function new(?_spec:stdgo.Ref<stdgo.go.ast.Ast.TypeSpec>) {
        if (_spec != null) this._spec = _spec;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_typeDecl(_spec);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_funcDecl_static_extension) class T_funcDecl {
    public var _decl : stdgo.Ref<stdgo.go.ast.Ast.FuncDecl> = (null : stdgo.Ref<stdgo.go.ast.Ast.FuncDecl>);
    public function new(?_decl:stdgo.Ref<stdgo.go.ast.Ast.FuncDecl>) {
        if (_decl != null) this._decl = _decl;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_funcDecl(_decl);
    }
}
/**
    // An error_ represents a type-checking error.
    // To report an error_, call Checker.report.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_error__static_extension) class T_error_ {
    public var _desc : stdgo.Slice<stdgo.go.types.Types.T_errorDesc> = (null : stdgo.Slice<stdgo.go.types.Types.T_errorDesc>);
    public var _code : stdgo.internal.types.errors.Errors.Code = ((0 : stdgo.GoInt) : stdgo.internal.types.errors.Errors.Code);
    public var _soft : Bool = false;
    public function new(?_desc:stdgo.Slice<stdgo.go.types.Types.T_errorDesc>, ?_code:stdgo.internal.types.errors.Errors.Code, ?_soft:Bool) {
        if (_desc != null) this._desc = _desc;
        if (_code != null) this._code = _code;
        if (_soft != null) this._soft = _soft;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_error_(_desc, _code, _soft);
    }
}
/**
    // An errorDesc describes part of a type-checking error.
    
    
**/
@:structInit @:private class T_errorDesc {
    public var _posn : stdgo.go.types.Types.T_positioner = (null : stdgo.go.types.Types.T_positioner);
    public var _format : stdgo.GoString = "";
    public var _args : stdgo.Slice<stdgo.AnyInterface> = (null : stdgo.Slice<stdgo.AnyInterface>);
    public function new(?_posn:stdgo.go.types.Types.T_positioner, ?_format:stdgo.GoString, ?_args:stdgo.Slice<stdgo.AnyInterface>) {
        if (_posn != null) this._posn = _posn;
        if (_format != null) this._format = _format;
        if (_args != null) this._args = _args;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_errorDesc(_posn, _format, _args);
    }
}
/**
    // posSpan holds a position range along with a highlighted position within that
    // range. This is used for positioning errors, with pos by convention being the
    // first position in the source where the error is known to exist, and start
    // and end defining the full span of syntax being considered when the error was
    // detected. Invariant: start <= pos < end || start == pos == end.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_posSpan_static_extension) class T_posSpan {
    public var _start : stdgo.go.token.Token.Pos = ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos);
    public var _pos : stdgo.go.token.Token.Pos = ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos);
    public var _end : stdgo.go.token.Token.Pos = ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos);
    public function new(?_start:stdgo.go.token.Token.Pos, ?_pos:stdgo.go.token.Token.Pos, ?_end:stdgo.go.token.Token.Pos) {
        if (_start != null) this._start = _start;
        if (_pos != null) this._pos = _pos;
        if (_end != null) this._end = _end;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_posSpan(_start, _pos, _end);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_tpWalker_static_extension) class T_tpWalker {
    public var _tparams : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>);
    public var _seen : stdgo.GoMap<stdgo.go.types.Types.Type_, Bool> = (null : stdgo.GoMap<stdgo.go.types.Types.Type_, Bool>);
    public function new(?_tparams:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>, ?_seen:stdgo.GoMap<stdgo.go.types.Types.Type_, Bool>) {
        if (_tparams != null) this._tparams = _tparams;
        if (_seen != null) this._seen = _seen;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_tpWalker(_tparams, _seen);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_cycleFinder_static_extension) class T_cycleFinder {
    public var _tparams : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>);
    public var _inferred : stdgo.Slice<stdgo.go.types.Types.Type_> = (null : stdgo.Slice<stdgo.go.types.Types.Type_>);
    public var _seen : stdgo.GoMap<stdgo.go.types.Types.Type_, Bool> = (null : stdgo.GoMap<stdgo.go.types.Types.Type_, Bool>);
    public function new(?_tparams:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>, ?_inferred:stdgo.Slice<stdgo.go.types.Types.Type_>, ?_seen:stdgo.GoMap<stdgo.go.types.Types.Type_, Bool>) {
        if (_tparams != null) this._tparams = _tparams;
        if (_inferred != null) this._inferred = _inferred;
        if (_seen != null) this._seen = _seen;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_cycleFinder(_tparams, _inferred, _seen);
    }
}
/**
    // A graphNode represents a node in the object dependency graph.
    // Each node p in n.pred represents an edge p->n, and each node
    // s in n.succ represents an edge n->s; with a->b indicating that
    // a depends on b.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_graphNode_static_extension) class T_graphNode {
    public var _obj : stdgo.go.types.Types.T_dependency = (null : stdgo.go.types.Types.T_dependency);
    public var _pred : stdgo.go.types.Types.T_nodeSet = (null : stdgo.go.types.Types.T_nodeSet);
    public var _succ : stdgo.go.types.Types.T_nodeSet = (null : stdgo.go.types.Types.T_nodeSet);
    public var _index : stdgo.GoInt = 0;
    public var _ndeps : stdgo.GoInt = 0;
    public function new(?_obj:stdgo.go.types.Types.T_dependency, ?_pred:stdgo.go.types.Types.T_nodeSet, ?_succ:stdgo.go.types.Types.T_nodeSet, ?_index:stdgo.GoInt, ?_ndeps:stdgo.GoInt) {
        if (_obj != null) this._obj = _obj;
        if (_pred != null) this._pred = _pred;
        if (_succ != null) this._succ = _succ;
        if (_index != null) this._index = _index;
        if (_ndeps != null) this._ndeps = _ndeps;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_graphNode(_obj, _pred, _succ, _index, _ndeps);
    }
}
/**
    // An Interface represents an interface type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Interface_static_extension) class Interface {
    public var _check : stdgo.Ref<stdgo.go.types.Types.Checker> = (null : stdgo.Ref<stdgo.go.types.Types.Checker>);
    public var _methods : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>);
    public var _embeddeds : stdgo.Slice<stdgo.go.types.Types.Type_> = (null : stdgo.Slice<stdgo.go.types.Types.Type_>);
    public var _embedPos : stdgo.Ref<stdgo.Slice<stdgo.go.token.Token.Pos>> = (null : stdgo.Ref<stdgo.Slice<stdgo.go.token.Token.Pos>>);
    public var _implicit : Bool = false;
    public var _complete : Bool = false;
    public var _tset : stdgo.Ref<stdgo.go.types.Types.T__TypeSet> = (null : stdgo.Ref<stdgo.go.types.Types.T__TypeSet>);
    public function new(?_check:stdgo.Ref<stdgo.go.types.Types.Checker>, ?_methods:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>, ?_embeddeds:stdgo.Slice<stdgo.go.types.Types.Type_>, ?_embedPos:stdgo.Ref<stdgo.Slice<stdgo.go.token.Token.Pos>>, ?_implicit:Bool, ?_complete:Bool, ?_tset:stdgo.Ref<stdgo.go.types.Types.T__TypeSet>) {
        if (_check != null) this._check = _check;
        if (_methods != null) this._methods = _methods;
        if (_embeddeds != null) this._embeddeds = _embeddeds;
        if (_embedPos != null) this._embedPos = _embedPos;
        if (_implicit != null) this._implicit = _implicit;
        if (_complete != null) this._complete = _complete;
        if (_tset != null) this._tset = _tset;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Interface(_check, _methods, _embeddeds, _embedPos, _implicit, _complete, _tset);
    }
}
/**
    // A block tracks label declarations in a block and its enclosing blocks.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_block_static_extension) class T_block {
    public var _parent : stdgo.Ref<stdgo.go.types.Types.T_block> = (null : stdgo.Ref<stdgo.go.types.Types.T_block>);
    public var _lstmt : stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt> = (null : stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>);
    public var _labels : stdgo.GoMap<stdgo.GoString, stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>> = (null : stdgo.GoMap<stdgo.GoString, stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>>);
    public function new(?_parent:stdgo.Ref<stdgo.go.types.Types.T_block>, ?_lstmt:stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>, ?_labels:stdgo.GoMap<stdgo.GoString, stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>>) {
        if (_parent != null) this._parent = _parent;
        if (_lstmt != null) this._lstmt = _lstmt;
        if (_labels != null) this._labels = _labels;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_block(_parent, _lstmt, _labels);
    }
}
/**
    // embeddedType represents an embedded type
    
    
**/
@:structInit @:private class T_embeddedType {
    public var _typ : stdgo.go.types.Types.Type_ = (null : stdgo.go.types.Types.Type_);
    public var _index : stdgo.Slice<stdgo.GoInt> = (null : stdgo.Slice<stdgo.GoInt>);
    public var _indirect : Bool = false;
    public var _multiples : Bool = false;
    public function new(?_typ:stdgo.go.types.Types.Type_, ?_index:stdgo.Slice<stdgo.GoInt>, ?_indirect:Bool, ?_multiples:Bool) {
        if (_typ != null) this._typ = _typ;
        if (_index != null) this._index = _index;
        if (_indirect != null) this._indirect = _indirect;
        if (_multiples != null) this._multiples = _multiples;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_embeddedType(_typ, _index, _indirect, _multiples);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_instanceLookup_static_extension) class T_instanceLookup {
    /**
        // buf is used to avoid allocating the map m in the common case of a small
        // number of instances.
    **/
    public var _buf : stdgo.GoArray<stdgo.Ref<stdgo.go.types.Types.Named>> = new stdgo.GoArray<stdgo.Ref<stdgo.go.types.Types.Named>>(...[for (i in 0 ... 3) (null : stdgo.Ref<stdgo.go.types.Types.Named>)]);
    public var _m : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Named>, stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Named>>> = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Named>, stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Named>>>);
    public function new(?_buf:stdgo.GoArray<stdgo.Ref<stdgo.go.types.Types.Named>>, ?_m:stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Named>, stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Named>>>) {
        if (_buf != null) this._buf = _buf;
        if (_m != null) this._m = _m;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_instanceLookup(_buf, _m);
    }
}
/**
    // A Map represents a map type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Map__static_extension) class Map_ {
    public var _key : stdgo.go.types.Types.Type_ = (null : stdgo.go.types.Types.Type_);
    public var _elem : stdgo.go.types.Types.Type_ = (null : stdgo.go.types.Types.Type_);
    public function new(?_key:stdgo.go.types.Types.Type_, ?_elem:stdgo.go.types.Types.Type_) {
        if (_key != null) this._key = _key;
        if (_elem != null) this._elem = _elem;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Map_(_key, _elem);
    }
}
/**
    // A MethodSet is an ordered set of concrete or abstract (interface) methods;
    // a method is a MethodVal selection, and they are ordered by ascending m.Obj().Id().
    // The zero value for a MethodSet is a ready-to-use empty method set.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.MethodSet_static_extension) class MethodSet {
    public var _list : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Selection>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Selection>>);
    public function new(?_list:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Selection>>) {
        if (_list != null) this._list = _list;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new MethodSet(_list);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_monoGraph_static_extension) class T_monoGraph {
    public var _vertices : stdgo.Slice<stdgo.go.types.Types.T_monoVertex> = (null : stdgo.Slice<stdgo.go.types.Types.T_monoVertex>);
    public var _edges : stdgo.Slice<stdgo.go.types.Types.T_monoEdge> = (null : stdgo.Slice<stdgo.go.types.Types.T_monoEdge>);
    /**
        // canon maps method receiver type parameters to their respective
        // receiver type's type parameters.
    **/
    public var _canon : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeParam>, stdgo.Ref<stdgo.go.types.Types.TypeParam>> = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeParam>, stdgo.Ref<stdgo.go.types.Types.TypeParam>>);
    /**
        // nameIdx maps a defined type or (canonical) type parameter to its
        // vertex index.
    **/
    public var _nameIdx : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, stdgo.GoInt> = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, stdgo.GoInt>);
    public function new(?_vertices:stdgo.Slice<stdgo.go.types.Types.T_monoVertex>, ?_edges:stdgo.Slice<stdgo.go.types.Types.T_monoEdge>, ?_canon:stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeParam>, stdgo.Ref<stdgo.go.types.Types.TypeParam>>, ?_nameIdx:stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, stdgo.GoInt>) {
        if (_vertices != null) this._vertices = _vertices;
        if (_edges != null) this._edges = _edges;
        if (_canon != null) this._canon = _canon;
        if (_nameIdx != null) this._nameIdx = _nameIdx;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_monoGraph(_vertices, _edges, _canon, _nameIdx);
    }
}
/**
    
    
    
**/
@:structInit @:private class T_monoVertex {
    public var _weight : stdgo.GoInt = 0;
    public var _pre : stdgo.GoInt = 0;
    public var _len : stdgo.GoInt = 0;
    /**
        // obj is the defined type or type parameter represented by this
        // vertex.
    **/
    public var _obj : stdgo.Ref<stdgo.go.types.Types.TypeName> = (null : stdgo.Ref<stdgo.go.types.Types.TypeName>);
    public function new(?_weight:stdgo.GoInt, ?_pre:stdgo.GoInt, ?_len:stdgo.GoInt, ?_obj:stdgo.Ref<stdgo.go.types.Types.TypeName>) {
        if (_weight != null) this._weight = _weight;
        if (_pre != null) this._pre = _pre;
        if (_len != null) this._len = _len;
        if (_obj != null) this._obj = _obj;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_monoVertex(_weight, _pre, _len, _obj);
    }
}
/**
    
    
    
**/
@:structInit @:private class T_monoEdge {
    public var _dst : stdgo.GoInt = 0;
    public var _src : stdgo.GoInt = 0;
    public var _weight : stdgo.GoInt = 0;
    public var _pos : stdgo.go.token.Token.Pos = ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos);
    public var _typ : stdgo.go.types.Types.Type_ = (null : stdgo.go.types.Types.Type_);
    public function new(?_dst:stdgo.GoInt, ?_src:stdgo.GoInt, ?_weight:stdgo.GoInt, ?_pos:stdgo.go.token.Token.Pos, ?_typ:stdgo.go.types.Types.Type_) {
        if (_dst != null) this._dst = _dst;
        if (_src != null) this._src = _src;
        if (_weight != null) this._weight = _weight;
        if (_pos != null) this._pos = _pos;
        if (_typ != null) this._typ = _typ;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_monoEdge(_dst, _src, _weight, _pos, _typ);
    }
}
/**
    // A Named represents a named (defined) type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Named_static_extension) class Named {
    public var _check : stdgo.Ref<stdgo.go.types.Types.Checker> = (null : stdgo.Ref<stdgo.go.types.Types.Checker>);
    public var _obj : stdgo.Ref<stdgo.go.types.Types.TypeName> = (null : stdgo.Ref<stdgo.go.types.Types.TypeName>);
    /**
        // fromRHS holds the type (on RHS of declaration) this *Named type is derived
        // from (for cycle reporting). Only used by validType, and therefore does not
        // require synchronization.
    **/
    public var _fromRHS : stdgo.go.types.Types.Type_ = (null : stdgo.go.types.Types.Type_);
    /**
        // information for instantiated types; nil otherwise
    **/
    public var _inst : stdgo.Ref<stdgo.go.types.Types.T_instance> = (null : stdgo.Ref<stdgo.go.types.Types.T_instance>);
    public var _mu : stdgo.sync.Sync.Mutex = ({} : stdgo.sync.Sync.Mutex);
    public var _state_ : stdgo.GoUInt32 = 0;
    public var _underlying : stdgo.go.types.Types.Type_ = (null : stdgo.go.types.Types.Type_);
    public var _tparams : stdgo.Ref<stdgo.go.types.Types.TypeParamList> = (null : stdgo.Ref<stdgo.go.types.Types.TypeParamList>);
    /**
        // methods declared for this type (not the method set of this type)
        // Signatures are type-checked lazily.
        // For non-instantiated types, this is a fully populated list of methods. For
        // instantiated types, methods are individually expanded when they are first
        // accessed.
    **/
    public var _methods : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>);
    /**
        // loader may be provided to lazily load type parameters, underlying type, and methods.
    **/
    public var _loader : stdgo.Ref<stdgo.go.types.Types.Named> -> { var _0 : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>; var _1 : stdgo.go.types.Types.Type_; var _2 : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>; } = null;
    public function new(?_check:stdgo.Ref<stdgo.go.types.Types.Checker>, ?_obj:stdgo.Ref<stdgo.go.types.Types.TypeName>, ?_fromRHS:stdgo.go.types.Types.Type_, ?_inst:stdgo.Ref<stdgo.go.types.Types.T_instance>, ?_mu:stdgo.sync.Sync.Mutex, ?_state_:stdgo.GoUInt32, ?_underlying:stdgo.go.types.Types.Type_, ?_tparams:stdgo.Ref<stdgo.go.types.Types.TypeParamList>, ?_methods:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>, ?_loader:stdgo.Ref<stdgo.go.types.Types.Named> -> { var _0 : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>; var _1 : stdgo.go.types.Types.Type_; var _2 : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>; }) {
        if (_check != null) this._check = _check;
        if (_obj != null) this._obj = _obj;
        if (_fromRHS != null) this._fromRHS = _fromRHS;
        if (_inst != null) this._inst = _inst;
        if (_mu != null) this._mu = _mu;
        if (_state_ != null) this._state_ = _state_;
        if (_underlying != null) this._underlying = _underlying;
        if (_tparams != null) this._tparams = _tparams;
        if (_methods != null) this._methods = _methods;
        if (_loader != null) this._loader = _loader;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Named(_check, _obj, _fromRHS, _inst, _mu, _state_, _underlying, _tparams, _methods, _loader);
    }
}
/**
    // instance holds information that is only necessary for instantiated named
    // types.
    
    
**/
@:structInit @:private class T_instance {
    public var _orig : stdgo.Ref<stdgo.go.types.Types.Named> = (null : stdgo.Ref<stdgo.go.types.Types.Named>);
    public var _targs : stdgo.Ref<stdgo.go.types.Types.TypeList> = (null : stdgo.Ref<stdgo.go.types.Types.TypeList>);
    public var _expandedMethods : stdgo.GoInt = 0;
    public var _ctxt : stdgo.Ref<stdgo.go.types.Types.Context> = (null : stdgo.Ref<stdgo.go.types.Types.Context>);
    public function new(?_orig:stdgo.Ref<stdgo.go.types.Types.Named>, ?_targs:stdgo.Ref<stdgo.go.types.Types.TypeList>, ?_expandedMethods:stdgo.GoInt, ?_ctxt:stdgo.Ref<stdgo.go.types.Types.Context>) {
        if (_orig != null) this._orig = _orig;
        if (_targs != null) this._targs = _targs;
        if (_expandedMethods != null) this._expandedMethods = _expandedMethods;
        if (_ctxt != null) this._ctxt = _ctxt;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_instance(_orig, _targs, _expandedMethods, _ctxt);
    }
}
/**
    // An object implements the common parts of an Object.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_object_static_extension) class T_object {
    public var _parent : stdgo.Ref<stdgo.go.types.Types.Scope> = (null : stdgo.Ref<stdgo.go.types.Types.Scope>);
    public var _pos : stdgo.go.token.Token.Pos = ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos);
    public var _pkg : stdgo.Ref<stdgo.go.types.Types.Package> = (null : stdgo.Ref<stdgo.go.types.Types.Package>);
    public var _name : stdgo.GoString = "";
    public var _typ : stdgo.go.types.Types.Type_ = (null : stdgo.go.types.Types.Type_);
    public var _order_ : stdgo.GoUInt32 = 0;
    public var _color_ : stdgo.go.types.Types.T_color = ((0 : stdgo.GoUInt32) : stdgo.go.types.Types.T_color);
    public var _scopePos_ : stdgo.go.token.Token.Pos = ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos);
    public function new(?_parent:stdgo.Ref<stdgo.go.types.Types.Scope>, ?_pos:stdgo.go.token.Token.Pos, ?_pkg:stdgo.Ref<stdgo.go.types.Types.Package>, ?_name:stdgo.GoString, ?_typ:stdgo.go.types.Types.Type_, ?_order_:stdgo.GoUInt32, ?_color_:stdgo.go.types.Types.T_color, ?_scopePos_:stdgo.go.token.Token.Pos) {
        if (_parent != null) this._parent = _parent;
        if (_pos != null) this._pos = _pos;
        if (_pkg != null) this._pkg = _pkg;
        if (_name != null) this._name = _name;
        if (_typ != null) this._typ = _typ;
        if (_order_ != null) this._order_ = _order_;
        if (_color_ != null) this._color_ = _color_;
        if (_scopePos_ != null) this._scopePos_ = _scopePos_;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_object(_parent, _pos, _pkg, _name, _typ, _order_, _color_, _scopePos_);
    }
}
/**
    // A PkgName represents an imported Go package.
    // PkgNames don't have a type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.PkgName_static_extension) class PkgName {
    @:embedded
    public var _object : stdgo.go.types.Types.T_object = ({} : stdgo.go.types.Types.T_object);
    public var _imported : stdgo.Ref<stdgo.go.types.Types.Package> = (null : stdgo.Ref<stdgo.go.types.Types.Package>);
    public var _used : Bool = false;
    public function new(?_object:stdgo.go.types.Types.T_object, ?_imported:stdgo.Ref<stdgo.go.types.Types.Package>, ?_used:Bool) {
        if (_object != null) this._object = _object;
        if (_imported != null) this._imported = _imported;
        if (_used != null) this._used = _used;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    @:embedded
    public function exported():Bool return _object.exported();
    @:embedded
    public function id():stdgo.GoString return _object.id();
    @:embedded
    public function name():stdgo.GoString return _object.name();
    @:embedded
    public function parent():stdgo.Ref<stdgo.go.types.Types.Scope> return _object.parent();
    @:embedded
    public function pkg():stdgo.Ref<stdgo.go.types.Types.Package> return _object.pkg();
    @:embedded
    public function pos():stdgo.go.token.Token.Pos return _object.pos();
    @:embedded
    public function type():stdgo.go.types.Types.Type_ return _object.type();
    @:embedded
    public function _color():stdgo.go.types.Types.T_color return _object._color();
    @:embedded
    public function _less(_b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return _object._less(_b);
    @:embedded
    public function _order():stdgo.GoUInt32 return _object._order();
    @:embedded
    public function _sameId(_pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return _object._sameId(_pkg_, _name_);
    @:embedded
    public function _scopePos():stdgo.go.token.Token.Pos return _object._scopePos();
    @:embedded
    public function _setColor(__0:stdgo.go.types.Types.T_color) _object._setColor(__0);
    @:embedded
    public function _setOrder(__0:stdgo.GoUInt32) _object._setOrder(__0);
    @:embedded
    public function _setParent(__0:stdgo.Ref<stdgo.go.types.Types.Scope>) _object._setParent(__0);
    @:embedded
    public function _setScopePos(_p:stdgo.go.token.Token.Pos) _object._setScopePos(_p);
    @:embedded
    public function _setType(__0:stdgo.go.types.Types.Type_) _object._setType(__0);
    public function __copy__() {
        return new PkgName(_object, _imported, _used);
    }
}
/**
    // A Const represents a declared constant.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Const_static_extension) class Const {
    @:embedded
    public var _object : stdgo.go.types.Types.T_object = ({} : stdgo.go.types.Types.T_object);
    public var _val : stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
    public function new(?_object:stdgo.go.types.Types.T_object, ?_val:stdgo.go.constant.Constant.Value) {
        if (_object != null) this._object = _object;
        if (_val != null) this._val = _val;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    @:embedded
    public function exported():Bool return _object.exported();
    @:embedded
    public function id():stdgo.GoString return _object.id();
    @:embedded
    public function name():stdgo.GoString return _object.name();
    @:embedded
    public function parent():stdgo.Ref<stdgo.go.types.Types.Scope> return _object.parent();
    @:embedded
    public function pkg():stdgo.Ref<stdgo.go.types.Types.Package> return _object.pkg();
    @:embedded
    public function pos():stdgo.go.token.Token.Pos return _object.pos();
    @:embedded
    public function type():stdgo.go.types.Types.Type_ return _object.type();
    @:embedded
    public function _color():stdgo.go.types.Types.T_color return _object._color();
    @:embedded
    public function _less(_b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return _object._less(_b);
    @:embedded
    public function _order():stdgo.GoUInt32 return _object._order();
    @:embedded
    public function _sameId(_pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return _object._sameId(_pkg_, _name_);
    @:embedded
    public function _scopePos():stdgo.go.token.Token.Pos return _object._scopePos();
    @:embedded
    public function _setColor(__0:stdgo.go.types.Types.T_color) _object._setColor(__0);
    @:embedded
    public function _setOrder(__0:stdgo.GoUInt32) _object._setOrder(__0);
    @:embedded
    public function _setParent(__0:stdgo.Ref<stdgo.go.types.Types.Scope>) _object._setParent(__0);
    @:embedded
    public function _setScopePos(_p:stdgo.go.token.Token.Pos) _object._setScopePos(_p);
    @:embedded
    public function _setType(__0:stdgo.go.types.Types.Type_) _object._setType(__0);
    public function __copy__() {
        return new Const(_object, _val);
    }
}
/**
    // A TypeName represents a name for a (defined or alias) type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.TypeName_static_extension) class TypeName {
    @:embedded
    public var _object : stdgo.go.types.Types.T_object = ({} : stdgo.go.types.Types.T_object);
    public function new(?_object:stdgo.go.types.Types.T_object) {
        if (_object != null) this._object = _object;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    @:embedded
    public function exported():Bool return _object.exported();
    @:embedded
    public function id():stdgo.GoString return _object.id();
    @:embedded
    public function name():stdgo.GoString return _object.name();
    @:embedded
    public function parent():stdgo.Ref<stdgo.go.types.Types.Scope> return _object.parent();
    @:embedded
    public function pkg():stdgo.Ref<stdgo.go.types.Types.Package> return _object.pkg();
    @:embedded
    public function pos():stdgo.go.token.Token.Pos return _object.pos();
    @:embedded
    public function type():stdgo.go.types.Types.Type_ return _object.type();
    @:embedded
    public function _color():stdgo.go.types.Types.T_color return _object._color();
    @:embedded
    public function _less(_b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return _object._less(_b);
    @:embedded
    public function _order():stdgo.GoUInt32 return _object._order();
    @:embedded
    public function _sameId(_pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return _object._sameId(_pkg_, _name_);
    @:embedded
    public function _scopePos():stdgo.go.token.Token.Pos return _object._scopePos();
    @:embedded
    public function _setColor(__0:stdgo.go.types.Types.T_color) _object._setColor(__0);
    @:embedded
    public function _setOrder(__0:stdgo.GoUInt32) _object._setOrder(__0);
    @:embedded
    public function _setParent(__0:stdgo.Ref<stdgo.go.types.Types.Scope>) _object._setParent(__0);
    @:embedded
    public function _setScopePos(_p:stdgo.go.token.Token.Pos) _object._setScopePos(_p);
    @:embedded
    public function _setType(__0:stdgo.go.types.Types.Type_) _object._setType(__0);
    public function __copy__() {
        return new TypeName(_object);
    }
}
/**
    // A Variable represents a declared variable (including function parameters and results, and struct fields).
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Var_static_extension) class Var {
    @:embedded
    public var _object : stdgo.go.types.Types.T_object = ({} : stdgo.go.types.Types.T_object);
    public var _embedded : Bool = false;
    public var _isField : Bool = false;
    public var _used : Bool = false;
    public var _origin : stdgo.Ref<stdgo.go.types.Types.Var> = (null : stdgo.Ref<stdgo.go.types.Types.Var>);
    public function new(?_object:stdgo.go.types.Types.T_object, ?_embedded:Bool, ?_isField:Bool, ?_used:Bool, ?_origin:stdgo.Ref<stdgo.go.types.Types.Var>) {
        if (_object != null) this._object = _object;
        if (_embedded != null) this._embedded = _embedded;
        if (_isField != null) this._isField = _isField;
        if (_used != null) this._used = _used;
        if (_origin != null) this._origin = _origin;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    @:embedded
    public function exported():Bool return _object.exported();
    @:embedded
    public function id():stdgo.GoString return _object.id();
    @:embedded
    public function name():stdgo.GoString return _object.name();
    @:embedded
    public function parent():stdgo.Ref<stdgo.go.types.Types.Scope> return _object.parent();
    @:embedded
    public function pkg():stdgo.Ref<stdgo.go.types.Types.Package> return _object.pkg();
    @:embedded
    public function pos():stdgo.go.token.Token.Pos return _object.pos();
    @:embedded
    public function type():stdgo.go.types.Types.Type_ return _object.type();
    @:embedded
    public function _color():stdgo.go.types.Types.T_color return _object._color();
    @:embedded
    public function _less(_b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return _object._less(_b);
    @:embedded
    public function _order():stdgo.GoUInt32 return _object._order();
    @:embedded
    public function _sameId(_pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return _object._sameId(_pkg_, _name_);
    @:embedded
    public function _scopePos():stdgo.go.token.Token.Pos return _object._scopePos();
    @:embedded
    public function _setColor(__0:stdgo.go.types.Types.T_color) _object._setColor(__0);
    @:embedded
    public function _setOrder(__0:stdgo.GoUInt32) _object._setOrder(__0);
    @:embedded
    public function _setParent(__0:stdgo.Ref<stdgo.go.types.Types.Scope>) _object._setParent(__0);
    @:embedded
    public function _setScopePos(_p:stdgo.go.token.Token.Pos) _object._setScopePos(_p);
    @:embedded
    public function _setType(__0:stdgo.go.types.Types.Type_) _object._setType(__0);
    public function __copy__() {
        return new Var(_object, _embedded, _isField, _used, _origin);
    }
}
/**
    // A Func represents a declared function, concrete method, or abstract
    // (interface) method. Its Type() is always a *Signature.
    // An abstract method may belong to many interfaces due to embedding.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Func_static_extension) class Func {
    @:embedded
    public var _object : stdgo.go.types.Types.T_object = ({} : stdgo.go.types.Types.T_object);
    public var _hasPtrRecv_ : Bool = false;
    public var _origin : stdgo.Ref<stdgo.go.types.Types.Func> = (null : stdgo.Ref<stdgo.go.types.Types.Func>);
    public function new(?_object:stdgo.go.types.Types.T_object, ?_hasPtrRecv_:Bool, ?_origin:stdgo.Ref<stdgo.go.types.Types.Func>) {
        if (_object != null) this._object = _object;
        if (_hasPtrRecv_ != null) this._hasPtrRecv_ = _hasPtrRecv_;
        if (_origin != null) this._origin = _origin;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    @:embedded
    public function exported():Bool return _object.exported();
    @:embedded
    public function id():stdgo.GoString return _object.id();
    @:embedded
    public function name():stdgo.GoString return _object.name();
    @:embedded
    public function parent():stdgo.Ref<stdgo.go.types.Types.Scope> return _object.parent();
    @:embedded
    public function pkg():stdgo.Ref<stdgo.go.types.Types.Package> return _object.pkg();
    @:embedded
    public function pos():stdgo.go.token.Token.Pos return _object.pos();
    @:embedded
    public function type():stdgo.go.types.Types.Type_ return _object.type();
    @:embedded
    public function _color():stdgo.go.types.Types.T_color return _object._color();
    @:embedded
    public function _less(_b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return _object._less(_b);
    @:embedded
    public function _order():stdgo.GoUInt32 return _object._order();
    @:embedded
    public function _sameId(_pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return _object._sameId(_pkg_, _name_);
    @:embedded
    public function _scopePos():stdgo.go.token.Token.Pos return _object._scopePos();
    @:embedded
    public function _setColor(__0:stdgo.go.types.Types.T_color) _object._setColor(__0);
    @:embedded
    public function _setOrder(__0:stdgo.GoUInt32) _object._setOrder(__0);
    @:embedded
    public function _setParent(__0:stdgo.Ref<stdgo.go.types.Types.Scope>) _object._setParent(__0);
    @:embedded
    public function _setScopePos(_p:stdgo.go.token.Token.Pos) _object._setScopePos(_p);
    @:embedded
    public function _setType(__0:stdgo.go.types.Types.Type_) _object._setType(__0);
    public function __copy__() {
        return new Func(_object, _hasPtrRecv_, _origin);
    }
}
/**
    // A Label represents a declared label.
    // Labels don't have a type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Label_static_extension) class Label {
    @:embedded
    public var _object : stdgo.go.types.Types.T_object = ({} : stdgo.go.types.Types.T_object);
    public var _used : Bool = false;
    public function new(?_object:stdgo.go.types.Types.T_object, ?_used:Bool) {
        if (_object != null) this._object = _object;
        if (_used != null) this._used = _used;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    @:embedded
    public function exported():Bool return _object.exported();
    @:embedded
    public function id():stdgo.GoString return _object.id();
    @:embedded
    public function name():stdgo.GoString return _object.name();
    @:embedded
    public function parent():stdgo.Ref<stdgo.go.types.Types.Scope> return _object.parent();
    @:embedded
    public function pkg():stdgo.Ref<stdgo.go.types.Types.Package> return _object.pkg();
    @:embedded
    public function pos():stdgo.go.token.Token.Pos return _object.pos();
    @:embedded
    public function type():stdgo.go.types.Types.Type_ return _object.type();
    @:embedded
    public function _color():stdgo.go.types.Types.T_color return _object._color();
    @:embedded
    public function _less(_b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return _object._less(_b);
    @:embedded
    public function _order():stdgo.GoUInt32 return _object._order();
    @:embedded
    public function _sameId(_pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return _object._sameId(_pkg_, _name_);
    @:embedded
    public function _scopePos():stdgo.go.token.Token.Pos return _object._scopePos();
    @:embedded
    public function _setColor(__0:stdgo.go.types.Types.T_color) _object._setColor(__0);
    @:embedded
    public function _setOrder(__0:stdgo.GoUInt32) _object._setOrder(__0);
    @:embedded
    public function _setParent(__0:stdgo.Ref<stdgo.go.types.Types.Scope>) _object._setParent(__0);
    @:embedded
    public function _setScopePos(_p:stdgo.go.token.Token.Pos) _object._setScopePos(_p);
    @:embedded
    public function _setType(__0:stdgo.go.types.Types.Type_) _object._setType(__0);
    public function __copy__() {
        return new Label(_object, _used);
    }
}
/**
    // A Builtin represents a built-in function.
    // Builtins don't have a valid type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Builtin_static_extension) class Builtin {
    @:embedded
    public var _object : stdgo.go.types.Types.T_object = ({} : stdgo.go.types.Types.T_object);
    public var _id : stdgo.go.types.Types.T_builtinId = ((0 : stdgo.GoInt) : stdgo.go.types.Types.T_builtinId);
    public function new(?_object:stdgo.go.types.Types.T_object, ?_id:stdgo.go.types.Types.T_builtinId) {
        if (_object != null) this._object = _object;
        if (_id != null) this._id = _id;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    @:embedded
    public function exported():Bool return _object.exported();
    @:embedded
    public function id():stdgo.GoString return _object.id();
    @:embedded
    public function name():stdgo.GoString return _object.name();
    @:embedded
    public function parent():stdgo.Ref<stdgo.go.types.Types.Scope> return _object.parent();
    @:embedded
    public function pkg():stdgo.Ref<stdgo.go.types.Types.Package> return _object.pkg();
    @:embedded
    public function pos():stdgo.go.token.Token.Pos return _object.pos();
    @:embedded
    public function type():stdgo.go.types.Types.Type_ return _object.type();
    @:embedded
    public function _color():stdgo.go.types.Types.T_color return _object._color();
    @:embedded
    public function _less(_b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return _object._less(_b);
    @:embedded
    public function _order():stdgo.GoUInt32 return _object._order();
    @:embedded
    public function _sameId(_pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return _object._sameId(_pkg_, _name_);
    @:embedded
    public function _scopePos():stdgo.go.token.Token.Pos return _object._scopePos();
    @:embedded
    public function _setColor(__0:stdgo.go.types.Types.T_color) _object._setColor(__0);
    @:embedded
    public function _setOrder(__0:stdgo.GoUInt32) _object._setOrder(__0);
    @:embedded
    public function _setParent(__0:stdgo.Ref<stdgo.go.types.Types.Scope>) _object._setParent(__0);
    @:embedded
    public function _setScopePos(_p:stdgo.go.token.Token.Pos) _object._setScopePos(_p);
    @:embedded
    public function _setType(__0:stdgo.go.types.Types.Type_) _object._setType(__0);
    public function __copy__() {
        return new Builtin(_object, _id);
    }
}
/**
    // Nil represents the predeclared value nil.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Nil_static_extension) class Nil {
    @:embedded
    public var _object : stdgo.go.types.Types.T_object = ({} : stdgo.go.types.Types.T_object);
    public function new(?_object:stdgo.go.types.Types.T_object) {
        if (_object != null) this._object = _object;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    @:embedded
    public function exported():Bool return _object.exported();
    @:embedded
    public function id():stdgo.GoString return _object.id();
    @:embedded
    public function name():stdgo.GoString return _object.name();
    @:embedded
    public function parent():stdgo.Ref<stdgo.go.types.Types.Scope> return _object.parent();
    @:embedded
    public function pkg():stdgo.Ref<stdgo.go.types.Types.Package> return _object.pkg();
    @:embedded
    public function pos():stdgo.go.token.Token.Pos return _object.pos();
    @:embedded
    public function type():stdgo.go.types.Types.Type_ return _object.type();
    @:embedded
    public function _color():stdgo.go.types.Types.T_color return _object._color();
    @:embedded
    public function _less(_b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return _object._less(_b);
    @:embedded
    public function _order():stdgo.GoUInt32 return _object._order();
    @:embedded
    public function _sameId(_pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return _object._sameId(_pkg_, _name_);
    @:embedded
    public function _scopePos():stdgo.go.token.Token.Pos return _object._scopePos();
    @:embedded
    public function _setColor(__0:stdgo.go.types.Types.T_color) _object._setColor(__0);
    @:embedded
    public function _setOrder(__0:stdgo.GoUInt32) _object._setOrder(__0);
    @:embedded
    public function _setParent(__0:stdgo.Ref<stdgo.go.types.Types.Scope>) _object._setParent(__0);
    @:embedded
    public function _setScopePos(_p:stdgo.go.token.Token.Pos) _object._setScopePos(_p);
    @:embedded
    public function _setType(__0:stdgo.go.types.Types.Type_) _object._setType(__0);
    public function __copy__() {
        return new Nil(_object);
    }
}
/**
    // An operand represents an intermediate value during type checking.
    // Operands have an (addressing) mode, the expression evaluating to
    // the operand, the operand's type, a value for constants, and an id
    // for built-in functions.
    // The zero value of operand is a ready to use invalid operand.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_operand_static_extension) class T_operand {
    public var _mode : stdgo.go.types.Types.T_operandMode = ((0 : stdgo.GoUInt8) : stdgo.go.types.Types.T_operandMode);
    public var _expr : stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
    public var _typ : stdgo.go.types.Types.Type_ = (null : stdgo.go.types.Types.Type_);
    public var _val : stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
    public var _id : stdgo.go.types.Types.T_builtinId = ((0 : stdgo.GoInt) : stdgo.go.types.Types.T_builtinId);
    public function new(?_mode:stdgo.go.types.Types.T_operandMode, ?_expr:stdgo.go.ast.Ast.Expr, ?_typ:stdgo.go.types.Types.Type_, ?_val:stdgo.go.constant.Constant.Value, ?_id:stdgo.go.types.Types.T_builtinId) {
        if (_mode != null) this._mode = _mode;
        if (_expr != null) this._expr = _expr;
        if (_typ != null) this._typ = _typ;
        if (_val != null) this._val = _val;
        if (_id != null) this._id = _id;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_operand(_mode, _expr, _typ, _val, _id);
    }
}
/**
    // A Package describes a Go package.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Package_static_extension) class Package {
    public var _path : stdgo.GoString = "";
    public var _name : stdgo.GoString = "";
    public var _scope : stdgo.Ref<stdgo.go.types.Types.Scope> = (null : stdgo.Ref<stdgo.go.types.Types.Scope>);
    public var _imports : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Package>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Package>>);
    public var _complete : Bool = false;
    public var _fake : Bool = false;
    public var _cgo : Bool = false;
    public var _goVersion : stdgo.GoString = "";
    public function new(?_path:stdgo.GoString, ?_name:stdgo.GoString, ?_scope:stdgo.Ref<stdgo.go.types.Types.Scope>, ?_imports:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Package>>, ?_complete:Bool, ?_fake:Bool, ?_cgo:Bool, ?_goVersion:stdgo.GoString) {
        if (_path != null) this._path = _path;
        if (_name != null) this._name = _name;
        if (_scope != null) this._scope = _scope;
        if (_imports != null) this._imports = _imports;
        if (_complete != null) this._complete = _complete;
        if (_fake != null) this._fake = _fake;
        if (_cgo != null) this._cgo = _cgo;
        if (_goVersion != null) this._goVersion = _goVersion;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Package(_path, _name, _scope, _imports, _complete, _fake, _cgo, _goVersion);
    }
}
/**
    // A Pointer represents a pointer type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Pointer__static_extension) class Pointer_ {
    public var _base : stdgo.go.types.Types.Type_ = (null : stdgo.go.types.Types.Type_);
    public function new(?_base:stdgo.go.types.Types.Type_) {
        if (_base != null) this._base = _base;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Pointer_(_base);
    }
}
/**
    // An ifacePair is a node in a stack of interface type pairs compared for identity.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_ifacePair_static_extension) class T_ifacePair {
    public var _x : stdgo.Ref<stdgo.go.types.Types.Interface> = (null : stdgo.Ref<stdgo.go.types.Types.Interface>);
    public var _y : stdgo.Ref<stdgo.go.types.Types.Interface> = (null : stdgo.Ref<stdgo.go.types.Types.Interface>);
    public var _prev : stdgo.Ref<stdgo.go.types.Types.T_ifacePair> = (null : stdgo.Ref<stdgo.go.types.Types.T_ifacePair>);
    public function new(?_x:stdgo.Ref<stdgo.go.types.Types.Interface>, ?_y:stdgo.Ref<stdgo.go.types.Types.Interface>, ?_prev:stdgo.Ref<stdgo.go.types.Types.T_ifacePair>) {
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_prev != null) this._prev = _prev;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_ifacePair(_x, _y, _prev);
    }
}
/**
    // A comparer is used to compare types.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_comparer_static_extension) class T_comparer {
    public var _ignoreTags : Bool = false;
    public var _ignoreInvalids : Bool = false;
    public function new(?_ignoreTags:Bool, ?_ignoreInvalids:Bool) {
        if (_ignoreTags != null) this._ignoreTags = _ignoreTags;
        if (_ignoreInvalids != null) this._ignoreInvalids = _ignoreInvalids;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_comparer(_ignoreTags, _ignoreInvalids);
    }
}
/**
    // A declInfo describes a package-level const, type, var, or func declaration.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_declInfo_static_extension) class T_declInfo {
    public var _file : stdgo.Ref<stdgo.go.types.Types.Scope> = (null : stdgo.Ref<stdgo.go.types.Types.Scope>);
    public var _lhs : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>);
    public var _vtyp : stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
    public var _init : stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
    public var _inherited : Bool = false;
    public var _tdecl : stdgo.Ref<stdgo.go.ast.Ast.TypeSpec> = (null : stdgo.Ref<stdgo.go.ast.Ast.TypeSpec>);
    public var _fdecl : stdgo.Ref<stdgo.go.ast.Ast.FuncDecl> = (null : stdgo.Ref<stdgo.go.ast.Ast.FuncDecl>);
    /**
        // The deps field tracks initialization expression dependencies.
    **/
    public var _deps : stdgo.GoMap<stdgo.go.types.Types.Object, Bool> = (null : stdgo.GoMap<stdgo.go.types.Types.Object, Bool>);
    public function new(?_file:stdgo.Ref<stdgo.go.types.Types.Scope>, ?_lhs:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>, ?_vtyp:stdgo.go.ast.Ast.Expr, ?_init:stdgo.go.ast.Ast.Expr, ?_inherited:Bool, ?_tdecl:stdgo.Ref<stdgo.go.ast.Ast.TypeSpec>, ?_fdecl:stdgo.Ref<stdgo.go.ast.Ast.FuncDecl>, ?_deps:stdgo.GoMap<stdgo.go.types.Types.Object, Bool>) {
        if (_file != null) this._file = _file;
        if (_lhs != null) this._lhs = _lhs;
        if (_vtyp != null) this._vtyp = _vtyp;
        if (_init != null) this._init = _init;
        if (_inherited != null) this._inherited = _inherited;
        if (_tdecl != null) this._tdecl = _tdecl;
        if (_fdecl != null) this._fdecl = _fdecl;
        if (_deps != null) this._deps = _deps;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_declInfo(_file, _lhs, _vtyp, _init, _inherited, _tdecl, _fdecl, _deps);
    }
}
/**
    // A Scope maintains a set of objects and links to its containing
    // (parent) and contained (children) scopes. Objects may be inserted
    // and looked up by name. The zero value for Scope is a ready-to-use
    // empty scope.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Scope_static_extension) class Scope {
    public var _parent : stdgo.Ref<stdgo.go.types.Types.Scope> = (null : stdgo.Ref<stdgo.go.types.Types.Scope>);
    public var _children : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Scope>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Scope>>);
    public var _number : stdgo.GoInt = 0;
    public var _elems : stdgo.GoMap<stdgo.GoString, stdgo.go.types.Types.Object> = (null : stdgo.GoMap<stdgo.GoString, stdgo.go.types.Types.Object>);
    public var _pos : stdgo.go.token.Token.Pos = ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos);
    public var _end : stdgo.go.token.Token.Pos = ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos);
    public var _comment : stdgo.GoString = "";
    public var _isFunc : Bool = false;
    public function new(?_parent:stdgo.Ref<stdgo.go.types.Types.Scope>, ?_children:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Scope>>, ?_number:stdgo.GoInt, ?_elems:stdgo.GoMap<stdgo.GoString, stdgo.go.types.Types.Object>, ?_pos:stdgo.go.token.Token.Pos, ?_end:stdgo.go.token.Token.Pos, ?_comment:stdgo.GoString, ?_isFunc:Bool) {
        if (_parent != null) this._parent = _parent;
        if (_children != null) this._children = _children;
        if (_number != null) this._number = _number;
        if (_elems != null) this._elems = _elems;
        if (_pos != null) this._pos = _pos;
        if (_end != null) this._end = _end;
        if (_comment != null) this._comment = _comment;
        if (_isFunc != null) this._isFunc = _isFunc;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Scope(_parent, _children, _number, _elems, _pos, _end, _comment, _isFunc);
    }
}
/**
    // A lazyObject represents an imported Object that has not been fully
    // resolved yet by its importer.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_lazyObject_static_extension) class T_lazyObject {
    public var _parent : stdgo.Ref<stdgo.go.types.Types.Scope> = (null : stdgo.Ref<stdgo.go.types.Types.Scope>);
    public var _resolve : () -> stdgo.go.types.Types.Object = null;
    public var _obj : stdgo.go.types.Types.Object = (null : stdgo.go.types.Types.Object);
    public var _once : stdgo.sync.Sync.Once = ({} : stdgo.sync.Sync.Once);
    public function new(?_parent:stdgo.Ref<stdgo.go.types.Types.Scope>, ?_resolve:() -> stdgo.go.types.Types.Object, ?_obj:stdgo.go.types.Types.Object, ?_once:stdgo.sync.Sync.Once) {
        if (_parent != null) this._parent = _parent;
        if (_resolve != null) this._resolve = _resolve;
        if (_obj != null) this._obj = _obj;
        if (_once != null) this._once = _once;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_lazyObject(_parent, _resolve, _obj, _once);
    }
}
/**
    // A Selection describes a selector expression x.f.
    // For the declarations:
    //
    //	type T struct{ x int; E }
    //	type E struct{}
    //	func (e E) m() {}
    //	var p *T
    //
    // the following relations exist:
    //
    //	Selector    Kind          Recv    Obj    Type       Index     Indirect
    //
    //	p.x         FieldVal      T       x      int        {0}       true
    //	p.m         MethodVal     *T      m      func()     {1, 0}    true
    //	T.m         MethodExpr    T       m      func(T)    {1, 0}    false
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Selection_static_extension) class Selection {
    public var _kind : stdgo.go.types.Types.SelectionKind = ((0 : stdgo.GoInt) : stdgo.go.types.Types.SelectionKind);
    public var _recv : stdgo.go.types.Types.Type_ = (null : stdgo.go.types.Types.Type_);
    public var _obj : stdgo.go.types.Types.Object = (null : stdgo.go.types.Types.Object);
    public var _index : stdgo.Slice<stdgo.GoInt> = (null : stdgo.Slice<stdgo.GoInt>);
    public var _indirect : Bool = false;
    public function new(?_kind:stdgo.go.types.Types.SelectionKind, ?_recv:stdgo.go.types.Types.Type_, ?_obj:stdgo.go.types.Types.Object, ?_index:stdgo.Slice<stdgo.GoInt>, ?_indirect:Bool) {
        if (_kind != null) this._kind = _kind;
        if (_recv != null) this._recv = _recv;
        if (_obj != null) this._obj = _obj;
        if (_index != null) this._index = _index;
        if (_indirect != null) this._indirect = _indirect;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Selection(_kind, _recv, _obj, _index, _indirect);
    }
}
/**
    // A Signature represents a (non-builtin) function or method type.
    // The receiver is ignored when comparing signatures for identity.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Signature_static_extension) class Signature {
    /**
        // We need to keep the scope in Signature (rather than passing it around
        // and store it in the Func Object) because when type-checking a function
        // literal we call the general type checker which returns a general Type.
        // We then unpack the *Signature and use the scope for the literal body.
    **/
    public var _rparams : stdgo.Ref<stdgo.go.types.Types.TypeParamList> = (null : stdgo.Ref<stdgo.go.types.Types.TypeParamList>);
    public var _tparams : stdgo.Ref<stdgo.go.types.Types.TypeParamList> = (null : stdgo.Ref<stdgo.go.types.Types.TypeParamList>);
    public var _scope : stdgo.Ref<stdgo.go.types.Types.Scope> = (null : stdgo.Ref<stdgo.go.types.Types.Scope>);
    public var _recv : stdgo.Ref<stdgo.go.types.Types.Var> = (null : stdgo.Ref<stdgo.go.types.Types.Var>);
    public var _params : stdgo.Ref<stdgo.go.types.Types.Tuple> = (null : stdgo.Ref<stdgo.go.types.Types.Tuple>);
    public var _results : stdgo.Ref<stdgo.go.types.Types.Tuple> = (null : stdgo.Ref<stdgo.go.types.Types.Tuple>);
    public var _variadic : Bool = false;
    public function new(?_rparams:stdgo.Ref<stdgo.go.types.Types.TypeParamList>, ?_tparams:stdgo.Ref<stdgo.go.types.Types.TypeParamList>, ?_scope:stdgo.Ref<stdgo.go.types.Types.Scope>, ?_recv:stdgo.Ref<stdgo.go.types.Types.Var>, ?_params:stdgo.Ref<stdgo.go.types.Types.Tuple>, ?_results:stdgo.Ref<stdgo.go.types.Types.Tuple>, ?_variadic:Bool) {
        if (_rparams != null) this._rparams = _rparams;
        if (_tparams != null) this._tparams = _tparams;
        if (_scope != null) this._scope = _scope;
        if (_recv != null) this._recv = _recv;
        if (_params != null) this._params = _params;
        if (_results != null) this._results = _results;
        if (_variadic != null) this._variadic = _variadic;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Signature(_rparams, _tparams, _scope, _recv, _params, _results, _variadic);
    }
}
/**
    // StdSizes is a convenience type for creating commonly used Sizes.
    // It makes the following simplifying assumptions:
    //
    //   - The size of explicitly sized basic types (int16, etc.) is the
    //     specified size.
    //   - The size of strings and interfaces is 2*WordSize.
    //   - The size of slices is 3*WordSize.
    //   - The size of an array of n elements corresponds to the size of
    //     a struct of n consecutive fields of the array's element type.
    //   - The size of a struct is the offset of the last field plus that
    //     field's size. As with all element types, if the struct is used
    //     in an array its size must first be aligned to a multiple of the
    //     struct's alignment.
    //   - All other types have size WordSize.
    //   - Arrays and structs are aligned per spec definition; all other
    //     types are naturally aligned with a maximum alignment MaxAlign.
    //
    // *StdSizes implements Sizes.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.StdSizes_static_extension) class StdSizes {
    public var wordSize : stdgo.GoInt64 = 0;
    public var maxAlign : stdgo.GoInt64 = 0;
    public function new(?wordSize:stdgo.GoInt64, ?maxAlign:stdgo.GoInt64) {
        if (wordSize != null) this.wordSize = wordSize;
        if (maxAlign != null) this.maxAlign = maxAlign;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new StdSizes(wordSize, maxAlign);
    }
}
/**
    // A Slice represents a slice type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Slice__static_extension) class Slice_ {
    public var _elem : stdgo.go.types.Types.Type_ = (null : stdgo.go.types.Types.Type_);
    public function new(?_elem:stdgo.go.types.Types.Type_) {
        if (_elem != null) this._elem = _elem;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Slice_(_elem);
    }
}
/**
    // A valueMap maps a case value (of a basic Go type) to a list of positions
    // where the same case value appeared, together with the corresponding case
    // types.
    // Since two case values may have the same "underlying" value but different
    // types we need to also check the value's types (e.g., byte(1) vs myByte(1))
    // when the switch expression is of interface type.
    
    
**/
@:structInit @:private class T_valueType {
    public var _pos : stdgo.go.token.Token.Pos = ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos);
    public var _typ : stdgo.go.types.Types.Type_ = (null : stdgo.go.types.Types.Type_);
    public function new(?_pos:stdgo.go.token.Token.Pos, ?_typ:stdgo.go.types.Types.Type_) {
        if (_pos != null) this._pos = _pos;
        if (_typ != null) this._typ = _typ;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_valueType(_pos, _typ);
    }
}
/**
    // A Struct represents a struct type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Struct_static_extension) class Struct {
    public var _fields : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>);
    public var _tags : stdgo.Slice<stdgo.GoString> = (null : stdgo.Slice<stdgo.GoString>);
    public function new(?_fields:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>, ?_tags:stdgo.Slice<stdgo.GoString>) {
        if (_fields != null) this._fields = _fields;
        if (_tags != null) this._tags = _tags;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Struct(_fields, _tags);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_subster_static_extension) class T_subster {
    public var _pos : stdgo.go.token.Token.Pos = ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos);
    public var _smap : stdgo.go.types.Types.T_substMap = (null : stdgo.go.types.Types.T_substMap);
    public var _check : stdgo.Ref<stdgo.go.types.Types.Checker> = (null : stdgo.Ref<stdgo.go.types.Types.Checker>);
    public var _expanding : stdgo.Ref<stdgo.go.types.Types.Named> = (null : stdgo.Ref<stdgo.go.types.Types.Named>);
    public var _ctxt : stdgo.Ref<stdgo.go.types.Types.Context> = (null : stdgo.Ref<stdgo.go.types.Types.Context>);
    public function new(?_pos:stdgo.go.token.Token.Pos, ?_smap:stdgo.go.types.Types.T_substMap, ?_check:stdgo.Ref<stdgo.go.types.Types.Checker>, ?_expanding:stdgo.Ref<stdgo.go.types.Types.Named>, ?_ctxt:stdgo.Ref<stdgo.go.types.Types.Context>) {
        if (_pos != null) this._pos = _pos;
        if (_smap != null) this._smap = _smap;
        if (_check != null) this._check = _check;
        if (_expanding != null) this._expanding = _expanding;
        if (_ctxt != null) this._ctxt = _ctxt;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_subster(_pos, _smap, _check, _expanding, _ctxt);
    }
}
/**
    // A Tuple represents an ordered list of variables; a nil *Tuple is a valid (empty) tuple.
    // Tuples are used as components of signatures and to represent the type of multiple
    // assignments; they are not first class types of Go.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Tuple_static_extension) class Tuple {
    public var _vars : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>);
    public function new(?_vars:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>) {
        if (_vars != null) this._vars = _vars;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Tuple(_vars);
    }
}
/**
    // TypeParamList holds a list of type parameters.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.TypeParamList_static_extension) class TypeParamList {
    public var _tparams : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>);
    public function new(?_tparams:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>) {
        if (_tparams != null) this._tparams = _tparams;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new TypeParamList(_tparams);
    }
}
/**
    // TypeList holds a list of types.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.TypeList_static_extension) class TypeList {
    public var _types : stdgo.Slice<stdgo.go.types.Types.Type_> = (null : stdgo.Slice<stdgo.go.types.Types.Type_>);
    public function new(?_types:stdgo.Slice<stdgo.go.types.Types.Type_>) {
        if (_types != null) this._types = _types;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new TypeList(_types);
    }
}
/**
    // A TypeParam represents a type parameter type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.TypeParam_static_extension) class TypeParam {
    public var _check : stdgo.Ref<stdgo.go.types.Types.Checker> = (null : stdgo.Ref<stdgo.go.types.Types.Checker>);
    public var _id : stdgo.GoUInt64 = 0;
    public var _obj : stdgo.Ref<stdgo.go.types.Types.TypeName> = (null : stdgo.Ref<stdgo.go.types.Types.TypeName>);
    public var _index : stdgo.GoInt = 0;
    public var _bound : stdgo.go.types.Types.Type_ = (null : stdgo.go.types.Types.Type_);
    public function new(?_check:stdgo.Ref<stdgo.go.types.Types.Checker>, ?_id:stdgo.GoUInt64, ?_obj:stdgo.Ref<stdgo.go.types.Types.TypeName>, ?_index:stdgo.GoInt, ?_bound:stdgo.go.types.Types.Type_) {
        if (_check != null) this._check = _check;
        if (_id != null) this._id = _id;
        if (_obj != null) this._obj = _obj;
        if (_index != null) this._index = _index;
        if (_bound != null) this._bound = _bound;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new TypeParam(_check, _id, _obj, _index, _bound);
    }
}
/**
    // A _TypeSet represents the type set of an interface.
    // Because of existing language restrictions, methods can be "factored out"
    // from the terms. The actual type set is the intersection of the type set
    // implied by the methods and the type set described by the terms and the
    // comparable bit. To test whether a type is included in a type set
    // ("implements" relation), the type must implement all methods _and_ be
    // an element of the type set described by the terms and the comparable bit.
    // If the term list describes the set of all types and comparable is true,
    // only comparable types are meant; in all other cases comparable is false.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T__TypeSet_static_extension) class T__TypeSet {
    public var _methods : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>);
    public var _terms : stdgo.go.types.Types.T_termlist = new stdgo.go.types.Types.T_termlist(0, 0);
    public var _comparable : Bool = false;
    public function new(?_methods:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>, ?_terms:stdgo.go.types.Types.T_termlist, ?_comparable:Bool) {
        if (_methods != null) this._methods = _methods;
        if (_terms != null) this._terms = _terms;
        if (_comparable != null) this._comparable = _comparable;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T__TypeSet(_methods, _terms, _comparable);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_typeWriter_static_extension) class T_typeWriter {
    public var _buf : stdgo.Ref<stdgo.bytes.Bytes.Buffer> = (null : stdgo.Ref<stdgo.bytes.Bytes.Buffer>);
    public var _seen : stdgo.GoMap<stdgo.go.types.Types.Type_, Bool> = (null : stdgo.GoMap<stdgo.go.types.Types.Type_, Bool>);
    public var _qf : stdgo.go.types.Types.Qualifier = (null : stdgo.go.types.Types.Qualifier);
    public var _ctxt : stdgo.Ref<stdgo.go.types.Types.Context> = (null : stdgo.Ref<stdgo.go.types.Types.Context>);
    public var _tparams : stdgo.Ref<stdgo.go.types.Types.TypeParamList> = (null : stdgo.Ref<stdgo.go.types.Types.TypeParamList>);
    public var _paramNames : Bool = false;
    public var _tpSubscripts : Bool = false;
    public var _pkgInfo : Bool = false;
    public function new(?_buf:stdgo.Ref<stdgo.bytes.Bytes.Buffer>, ?_seen:stdgo.GoMap<stdgo.go.types.Types.Type_, Bool>, ?_qf:stdgo.go.types.Types.Qualifier, ?_ctxt:stdgo.Ref<stdgo.go.types.Types.Context>, ?_tparams:stdgo.Ref<stdgo.go.types.Types.TypeParamList>, ?_paramNames:Bool, ?_tpSubscripts:Bool, ?_pkgInfo:Bool) {
        if (_buf != null) this._buf = _buf;
        if (_seen != null) this._seen = _seen;
        if (_qf != null) this._qf = _qf;
        if (_ctxt != null) this._ctxt = _ctxt;
        if (_tparams != null) this._tparams = _tparams;
        if (_paramNames != null) this._paramNames = _paramNames;
        if (_tpSubscripts != null) this._tpSubscripts = _tpSubscripts;
        if (_pkgInfo != null) this._pkgInfo = _pkgInfo;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_typeWriter(_buf, _seen, _qf, _ctxt, _tparams, _paramNames, _tpSubscripts, _pkgInfo);
    }
}
/**
    // A term describes elementary type sets:
    //
    //	 ∅:  (*term)(nil)     == ∅                      // set of no types (empty set)
    //	 𝓤:  &term{}          == 𝓤                      // set of all types (𝓤niverse)
    //	 T:  &term{false, T}  == {T}                    // set of type T
    //	~t:  &term{true, t}   == {t' | under(t') == t}  // set of types with underlying type t
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_term_static_extension) class T_term {
    public var _tilde : Bool = false;
    public var _typ : stdgo.go.types.Types.Type_ = (null : stdgo.go.types.Types.Type_);
    public function new(?_tilde:Bool, ?_typ:stdgo.go.types.Types.Type_) {
        if (_tilde != null) this._tilde = _tilde;
        if (_typ != null) this._typ = _typ;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_term(_tilde, _typ);
    }
}
/**
    // A unifier maintains a list of type parameters and
    // corresponding types inferred for each type parameter.
    // A unifier is created by calling newUnifier.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_unifier_static_extension) class T_unifier {
    /**
        // handles maps each type parameter to its inferred type through
        // an indirection *Type called (inferred type) "handle".
        // Initially, each type parameter has its own, separate handle,
        // with a nil (i.e., not yet inferred) type.
        // After a type parameter P is unified with a type parameter Q,
        // P and Q share the same handle (and thus type). This ensures
        // that inferring the type for a given type parameter P will
        // automatically infer the same type for all other parameters
        // unified (joined) with P.
    **/
    public var _handles : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeParam>, stdgo.Ref<stdgo.go.types.Types.Type_>> = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeParam>, stdgo.Ref<stdgo.go.types.Types.Type_>>);
    public var _depth : stdgo.GoInt = 0;
    public var _enableInterfaceInference : Bool = false;
    public function new(?_handles:stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeParam>, stdgo.Ref<stdgo.go.types.Types.Type_>>, ?_depth:stdgo.GoInt, ?_enableInterfaceInference:Bool) {
        if (_handles != null) this._handles = _handles;
        if (_depth != null) this._depth = _depth;
        if (_enableInterfaceInference != null) this._enableInterfaceInference = _enableInterfaceInference;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_unifier(_handles, _depth, _enableInterfaceInference);
    }
}
/**
    // A Union represents a union of terms embedded in an interface.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Union_static_extension) class Union {
    public var _terms : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Term>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Term>>);
    public function new(?_terms:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Term>>) {
        if (_terms != null) this._terms = _terms;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Union(_terms);
    }
}
/**
    // A version represents a released Go version.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_version_static_extension) class T_version {
    public var _major : stdgo.GoInt = 0;
    public var _minor : stdgo.GoInt = 0;
    public function new(?_major:stdgo.GoInt, ?_minor:stdgo.GoInt) {
        if (_major != null) this._major = _major;
        if (_minor != null) this._minor = _minor;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_version(_major, _minor);
    }
}
class T__struct_0_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T__struct_0>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T__struct_0_asInterface) class T__struct_0_static_extension {

}
@:local @:using(stdgo.go.types.Types.T__struct_0_static_extension) typedef T__struct_0 = {
    public var _in : stdgo.GoString;
    public var _want : stdgo.GoString;
};
class T__struct_1_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T__struct_1>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T__struct_1_asInterface) class T__struct_1_static_extension {

}
@:local @:using(stdgo.go.types.Types.T__struct_1_static_extension) typedef T__struct_1 = {
    public var _val : stdgo.AnyInterface;
    public var __32bit : stdgo.GoUIntptr;
    public var __64bit : stdgo.GoUIntptr;
};
class T__struct_2_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T__struct_2>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T__struct_2_asInterface) class T__struct_2_static_extension {

}
@:local @:using(stdgo.go.types.Types.T__struct_2_static_extension) typedef T__struct_2 = {
    public var _xl : stdgo.GoString;
    public var _want : stdgo.GoString;
};
class T__struct_3_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T__struct_3>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T__struct_3_asInterface) class T__struct_3_static_extension {

}
@:local @:using(stdgo.go.types.Types.T__struct_3_static_extension) typedef T__struct_3 = {
    public var _xl : stdgo.GoString;
    public var _yl : stdgo.GoString;
    public var _want : stdgo.GoString;
};
class T__struct_4_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T__struct_4>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T__struct_4_asInterface) class T__struct_4_static_extension {

}
@:local @:using(stdgo.go.types.Types.T__struct_4_static_extension) typedef T__struct_4 = {
    public var _xl : stdgo.GoString;
    public var _yl : stdgo.GoString;
    public var _want : Bool;
};
class T__struct_5_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T__struct_5>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T__struct_5_asInterface) class T__struct_5_static_extension {

}
@:local @:using(stdgo.go.types.Types.T__struct_5_static_extension) typedef T__struct_5 = {
    public var _xl : stdgo.GoString;
    public var _typ : stdgo.GoString;
    public var _want : Bool;
};
class T__struct_6_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T__struct_6>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T__struct_6_asInterface) class T__struct_6_static_extension {

}
@:local @:using(stdgo.go.types.Types.T__struct_6_static_extension) typedef T__struct_6 = {
    public var _name : stdgo.GoString;
    public var _kind : stdgo.go.types.Types.BasicKind;
    public var _val : stdgo.go.constant.Constant.Value;
};
class T__struct_7_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T__struct_7>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T__struct_7_asInterface) class T__struct_7_static_extension {

}
@:local @:using(stdgo.go.types.Types.T__struct_7_static_extension) typedef T__struct_7 = {
    public var _name : stdgo.GoString;
    public var _nargs : stdgo.GoInt;
    public var _variadic : Bool;
    public var _kind : stdgo.go.types.Types.T_exprKind;
};
class T__struct_8_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T__struct_8>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T__struct_8_asInterface) class T__struct_8_static_extension {

}
@:local @:using(stdgo.go.types.Types.T__struct_8_static_extension) typedef T__struct_8 = {
    public var _in : stdgo.GoString;
    public var _out : stdgo.go.types.Types.T_version;
};
/**
    // ImportMode is reserved for future use.
**/
@:named typedef ImportMode = stdgo.GoInt;
/**
    // BasicKind describes the kind of basic type.
**/
@:named typedef BasicKind = stdgo.GoInt;
/**
    // BasicInfo is a set of flags describing properties of a basic type.
**/
@:named typedef BasicInfo = stdgo.GoInt;
/**
    // A ChanDir value indicates a channel direction.
**/
@:named typedef ChanDir = stdgo.GoInt;
/**
    // atPos wraps a token.Pos to implement the positioner interface.
**/
@:named @:using(stdgo.go.types.Types.T_atPos_static_extension) typedef T_atPos = stdgo.go.token.Token.Pos;
@:named typedef T_opPredicates = stdgo.GoMap<stdgo.go.token.Token.Token, stdgo.go.types.Types.Type_ -> Bool>;
/**
    // exprKind describes the kind of an expression; the kind
    // determines if an expression is valid in 'statement context'.
**/
@:named typedef T_exprKind = stdgo.GoInt;
@:named @:using(stdgo.go.types.Types.T_nodeSet_static_extension) typedef T_nodeSet = stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.T_graphNode>, Bool>;
/**
    // nodeQueue implements the container/heap interface;
    // a nodeQueue may be used as a priority queue.
**/
@:named @:using(stdgo.go.types.Types.T_nodeQueue_static_extension) typedef T_nodeQueue = stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_graphNode>>;
/**
    // A methodSet is a set of methods and name collisions.
    // A collision indicates that multiple methods with the
    // same unique id, or a field with that id appeared.
**/
@:named @:using(stdgo.go.types.Types.T_methodSet_static_extension) typedef T_methodSet = stdgo.GoMap<stdgo.GoString, stdgo.Ref<stdgo.go.types.Types.Selection>>;
/**
    // namedState represents the possible states that a named type may assume.
**/
@:named typedef T_namedState = stdgo.GoUInt32;
/**
    // color encodes the color of an object (see Checker.objDecl for details).
**/
@:named @:using(stdgo.go.types.Types.T_color_static_extension) typedef T_color = stdgo.GoUInt32;
/**
    // An objset is a set of objects identified by their unique id.
    // The zero value for objset is a ready-to-use empty objset.
**/
@:named @:using(stdgo.go.types.Types.T_objset_static_extension) typedef T_objset = stdgo.GoMap<stdgo.GoString, stdgo.go.types.Types.Object>;
/**
    // An operandMode specifies the (addressing) mode of an operand.
**/
@:named typedef T_operandMode = stdgo.GoUInt8;
/**
    // inSourceOrder implements the sort.Sort interface.
**/
@:named @:using(stdgo.go.types.Types.T_inSourceOrder_static_extension) typedef T_inSourceOrder = stdgo.Slice<stdgo.go.types.Types.Object>;
/**
    // SelectionKind describes the kind of a selector expression x.f
    // (excluding qualified identifiers).
**/
@:named typedef SelectionKind = stdgo.GoInt;
/**
    // stmtContext is a bitset describing which
    // control-flow statements are permissible,
    // and provides additional context information
    // for better error messages.
**/
@:named typedef T_stmtContext = stdgo.GoUInt;
/**
    // A valueMap maps a case value (of a basic Go type) to a list of positions
    // where the same case value appeared, together with the corresponding case
    // types.
    // Since two case values may have the same "underlying" value but different
    // types we need to also check the value's types (e.g., byte(1) vs myByte(1))
    // when the switch expression is of interface type.
**/
@:named typedef T_valueMap = stdgo.GoMap<stdgo.AnyInterface, stdgo.Slice<stdgo.go.types.Types.T_valueType>>;
@:named @:using(stdgo.go.types.Types.T_substMap_static_extension) typedef T_substMap = stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeParam>, stdgo.go.types.Types.Type_>;
/**
    // A termlist represents the type set represented by the union
    // t1 ∪ y2 ∪ ... tn of the type sets of the terms t1 to tn.
    // A termlist is in normal form if all terms are disjoint.
    // termlist operations don't require the operands to be in
    // normal form.
**/
@:named @:using(stdgo.go.types.Types.T_termlist_static_extension) typedef T_termlist = stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_term>>;
/**
    // byUniqueMethodName method lists can be sorted by their unique method names.
**/
@:named @:using(stdgo.go.types.Types.T_byUniqueMethodName_static_extension) typedef T_byUniqueMethodName = stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>;
/**
    // A Qualifier controls how named package-level objects are printed in
    // calls to TypeString, ObjectString, and SelectionString.
    //
    // These three formatting routines call the Qualifier for each
    // package-level object O, and if the Qualifier returns a non-empty
    // string p, the object is printed in the form p.O.
    // If it returns an empty string, only the object name O is printed.
    //
    // Using a nil Qualifier is equivalent to using (*Package).Path: the
    // object is qualified by the import path, e.g., "encoding/json.Marshal".
**/
@:named typedef Qualifier = stdgo.Ref<stdgo.go.types.Types.Package> -> stdgo.GoString;
/**
    // unifyMode controls the behavior of the unifier.
**/
@:named @:using(stdgo.go.types.Types.T_unifyMode_static_extension) typedef T_unifyMode = stdgo.GoUInt;
@:named @:using(stdgo.go.types.Types.T_typeParamsById_static_extension) typedef T_typeParamsById = stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>;
/**
    // A Term represents a term in a Union.
**/
@:named @:using(stdgo.go.types.Types.Term_static_extension) typedef Term = stdgo.go.types.Types.T_term;
/**
    // A builtinId is the id of a builtin function.
**/
@:named typedef T_builtinId = stdgo.GoInt;
function _srcimporter_setUsesCgo(_conf:stdgo.Ref<Config>):Void {
        _conf._go115UsesCgo = true;
    }
/**
    // AssertableTo reports whether a value of type V can be asserted to have type T.
    //
    // The behavior of AssertableTo is unspecified in three cases:
    //   - if T is Typ[Invalid]
    //   - if V is a generalized interface; i.e., an interface that may only be used
    //     as a type constraint in Go code
    //   - if T is an uninstantiated generic type
**/
function assertableTo(v:stdgo.Ref<Interface>, t:Type_):Bool {
        if (stdgo.Go.toInterface(t.underlying()) == (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
            return false;
        };
        return ((null : stdgo.Ref<stdgo.go.types.Types.Checker>) : stdgo.Ref<Checker>)._newAssertableTo(_nopos, stdgo.Go.asInterface(v), t, (null : stdgo.Pointer<stdgo.GoString>));
    }
/**
    // AssignableTo reports whether a value of type V is assignable to a variable
    // of type T.
    //
    // The behavior of AssignableTo is unspecified if V or T is Typ[Invalid] or an
    // uninstantiated generic type.
**/
function assignableTo(v:Type_, t:Type_):Bool {
        var _x:stdgo.go.types.Types.T_operand = ({ _mode : (7 : stdgo.go.types.Types.T_operandMode), _typ : v } : stdgo.go.types.Types.T_operand);
        var __tmp__ = _x._assignableTo(null, t, (null : stdgo.Pointer<stdgo.GoString>)), _ok:Bool = __tmp__._0, __0:stdgo.internal.types.errors.Errors.Code = __tmp__._1;
        return _ok;
    }
/**
    // ConvertibleTo reports whether a value of type V is convertible to a value of
    // type T.
    //
    // The behavior of ConvertibleTo is unspecified if V or T is Typ[Invalid] or an
    // uninstantiated generic type.
**/
function convertibleTo(v:Type_, t:Type_):Bool {
        var _x:stdgo.go.types.Types.T_operand = ({ _mode : (7 : stdgo.go.types.Types.T_operandMode), _typ : v } : stdgo.go.types.Types.T_operand);
        return _x._convertibleTo(null, t, (null : stdgo.Pointer<stdgo.GoString>));
    }
/**
    // Implements reports whether type V implements interface T.
    //
    // The behavior of Implements is unspecified if V is Typ[Invalid] or an uninstantiated
    // generic type.
**/
function implements_(v:Type_, t:stdgo.Ref<Interface>):Bool {
        if (t.empty()) {
            return true;
        };
        if (stdgo.Go.toInterface(v.underlying()) == (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
            return false;
        };
        return ((null : stdgo.Ref<stdgo.go.types.Types.Checker>) : stdgo.Ref<Checker>)._implements((0 : stdgo.go.token.Token.Pos), v, stdgo.Go.asInterface(t), false, (null : stdgo.Pointer<stdgo.GoString>));
    }
/**
    // Satisfies reports whether type V satisfies the constraint T.
    //
    // The behavior of Satisfies is unspecified if V is Typ[Invalid] or an uninstantiated
    // generic type.
**/
function satisfies(v:Type_, t:stdgo.Ref<Interface>):Bool {
        return ((null : stdgo.Ref<stdgo.go.types.Types.Checker>) : stdgo.Ref<Checker>)._implements((0 : stdgo.go.token.Token.Pos), v, stdgo.Go.asInterface(t), true, (null : stdgo.Pointer<stdgo.GoString>));
    }
/**
    // Identical reports whether x and y are identical types.
    // Receivers of Signature types are ignored.
**/
function identical(_x:Type_, _y:Type_):Bool {
        var _c:T_comparer = ({} : stdgo.go.types.Types.T_comparer);
        return _c._identical(_x, _y, null);
    }
/**
    // IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored.
    // Receivers of Signature types are ignored.
**/
function identicalIgnoreTags(_x:Type_, _y:Type_):Bool {
        var _c:T_comparer = ({} : stdgo.go.types.Types.T_comparer);
        _c._ignoreTags = true;
        return _c._identical(_x, _y, null);
    }
/**
    // NewArray returns a new array type for the given element type and length.
    // A negative length indicates an unknown length.
**/
function newArray(_elem:Type_, _len:stdgo.GoInt64):stdgo.Ref<Array_> {
        return (stdgo.Go.setRef(({ _len : _len, _elem : _elem } : stdgo.go.types.Types.Array_)) : stdgo.Ref<stdgo.go.types.Types.Array_>);
    }
/**
    // operandTypes returns the list of types for the given operands.
**/
function _operandTypes(_list:stdgo.Slice<stdgo.Ref<T_operand>>):stdgo.Slice<Type_> {
        var _res:stdgo.Slice<Type_> = (null : stdgo.Slice<stdgo.go.types.Types.Type_>);
        for (__0 => _x in _list) {
            _res = (_res.__append__(_x._typ));
        };
        return _res;
    }
/**
    // varTypes returns the list of types for the given variables.
**/
function _varTypes(_list:stdgo.Slice<stdgo.Ref<Var>>):stdgo.Slice<Type_> {
        var _res:stdgo.Slice<Type_> = (null : stdgo.Slice<stdgo.go.types.Types.Type_>);
        for (__0 => _x in _list) {
            _res = (_res.__append__(_x._object._typ));
        };
        return _res;
    }
function _measure(_x:stdgo.GoInt, _unit:stdgo.GoString):stdgo.GoString {
        if (_x != ((1 : stdgo.GoInt))) {
            _unit = _unit + (("s" : stdgo.GoString))?.__copy__();
        };
        return stdgo.fmt.Fmt.sprintf(("%d %s" : stdgo.GoString), stdgo.Go.toInterface(_x), stdgo.Go.toInterface(_unit))?.__copy__();
    }
/**
    // hasVarSize reports if the size of type t is variable due to type parameters
    // or if the type is infinitely-sized due to a cycle for which the type has not
    // yet been checked.
**/
function _hasVarSize(_t:Type_, _seen:stdgo.GoMap<stdgo.Ref<Named>, Bool>):Bool {
        var __deferstack__:Array<Void -> Void> = [];
        var _varSized:Bool = false;
        try {
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_t) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
                }, _named = __tmp__._0, __0 = __tmp__._1;
                if (_named != null && ((_named : Dynamic).__nil__ == null || !(_named : Dynamic).__nil__)) {
                    {
                        var __tmp__ = (_seen != null && _seen.exists(_named) ? { _0 : _seen[_named], _1 : true } : { _0 : false, _1 : false }), _v:Bool = __tmp__._0, _ok:Bool = __tmp__._1;
                        if (_ok) {
                            return _v;
                        };
                    };
                    if (_seen == null) {
                        _seen = ({
                            final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.types.Types.Named>, Bool>();
                            @:mergeBlock {};
                            cast x;
                        } : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Named>, Bool>);
                    };
                    _seen[_named] = true;
                    __deferstack__.unshift(() -> {
                        var a = function():Void {
                            _seen[_named] = _varSized;
                        };
                        a();
                    });
                };
            };
            {
                final __type__ = _under(_t);
                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Array_>))) {
                    var _u:stdgo.Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _hasVarSize(_u._elem, _seen);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Struct>))) {
                    var _u:stdgo.Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                    for (__9 => _f in _u._fields) {
                        if (_hasVarSize(_f._object._typ, _seen)) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return true;
                            };
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                    var _u:stdgo.Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _isTypeParam(_t);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Named>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Union>))) {
                    var _u:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                    _unreachable();
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return false;
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return _varSized;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return _varSized;
        };
    }
/**
    // makeSig makes a signature for the given argument and result types.
    // Default types are used for untyped arguments, and res may be nil.
**/
function _makeSig(_res:Type_, _args:haxe.Rest<Type_>):stdgo.Ref<Signature> {
        var _args = new stdgo.Slice<Type_>(_args.length, 0, ..._args);
        var _list = new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>((_args.length : stdgo.GoInt).toBasic(), 0);
        for (_i => _param in _args) {
            _list[(_i : stdgo.GoInt)] = newVar(_nopos, null, stdgo.Go.str()?.__copy__(), default_(_param));
        };
        var _params = newTuple(..._list.__toArray__());
        var _result:stdgo.Ref<Tuple> = (null : stdgo.Ref<stdgo.go.types.Types.Tuple>);
        if (_res != null) {
            _assert(!_isUntyped(_res));
            _result = newTuple(newVar(_nopos, null, stdgo.Go.str()?.__copy__(), _res));
        };
        return (stdgo.Go.setRef(({ _params : _params, _results : _result } : stdgo.go.types.Types.Signature)) : stdgo.Ref<stdgo.go.types.Types.Signature>);
    }
/**
    // arrayPtrDeref returns A if typ is of the form *A and A is an array;
    // otherwise it returns typ.
**/
function _arrayPtrDeref(_typ:Type_):Type_ {
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_typ) : stdgo.Ref<Pointer_>)) : stdgo.Ref<Pointer_>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>), _1 : false };
            }, _p = __tmp__._0, _ok = __tmp__._1;
            if (_ok) {
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_p._base)) : stdgo.Ref<Array_>)) : stdgo.Ref<Array_>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Array_>), _1 : false };
                    }, _a = __tmp__._0, __0 = __tmp__._1;
                    if (_a != null && ((_a : Dynamic).__nil__ == null || !(_a : Dynamic).__nil__)) {
                        return stdgo.Go.asInterface(_a);
                    };
                };
            };
        };
        return _typ;
    }
/**
    // unparen returns e with any enclosing parentheses stripped.
**/
function _unparen(_e:stdgo.go.ast.Ast.Expr):stdgo.go.ast.Ast.Expr {
        while (true) {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_e) : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>)) : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>), _1 : false };
            }, _p = __tmp__._0, _ok = __tmp__._1;
            if (!_ok) {
                return _e;
            };
            _e = _p.x;
        };
    }
/**
    // NewChan returns a new channel type for the given direction and element type.
**/
function newChan(_dir:ChanDir, _elem:Type_):stdgo.Ref<Chan> {
        return (stdgo.Go.setRef(({ _dir : _dir, _elem : _elem } : stdgo.go.types.Types.Chan)) : stdgo.Ref<stdgo.go.types.Types.Chan>);
    }
/**
    // NewChecker returns a new Checker instance for a given package.
    // Package files may be added incrementally via checker.Files.
**/
function newChecker(_conf:stdgo.Ref<Config>, _fset:stdgo.Ref<stdgo.go.token.Token.FileSet>, _pkg:stdgo.Ref<Package>, _info:stdgo.Ref<Info>):stdgo.Ref<Checker> {
        if (_conf == null || (_conf : Dynamic).__nil__) {
            _conf = (stdgo.Go.setRef(({} : stdgo.go.types.Types.Config)) : stdgo.Ref<stdgo.go.types.Types.Config>);
        };
        if (_info == null || (_info : Dynamic).__nil__) {
            _info = (stdgo.Go.setRef(({} : stdgo.go.types.Types.Info)) : stdgo.Ref<stdgo.go.types.Types.Info>);
        };
        return (stdgo.Go.setRef(({ _conf : _conf, _ctxt : _conf.context, _fset : _fset, _pkg : _pkg, info : _info, _objMap : ({
            final x = new stdgo.GoMap.GoObjectMap<stdgo.go.types.Types.Object, stdgo.Ref<stdgo.go.types.Types.T_declInfo>>();
            x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Object", [], stdgo.internal.reflect.Reflect.GoType.named("Object", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
            x.__defaultValue__ = () -> (null : stdgo.Ref<stdgo.go.types.Types.T_declInfo>);
            @:mergeBlock {};
            cast x;
        } : stdgo.GoMap<stdgo.go.types.Types.Object, stdgo.Ref<stdgo.go.types.Types.T_declInfo>>), _impMap : ({
            final x = new stdgo.GoMap.GoObjectMap<stdgo.go.types.Types.T_importKey, stdgo.Ref<stdgo.go.types.Types.Package>>();
            x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.T_importKey", [], stdgo.internal.reflect.Reflect.GoType.structType([{ name : "_path", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.basic(string_kind) }, optional : false }, { name : "_dir", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.basic(string_kind) }, optional : false }]), false, { get : () -> null }));
            x.__defaultValue__ = () -> (null : stdgo.Ref<stdgo.go.types.Types.Package>);
            @:mergeBlock {};
            cast x;
        } : stdgo.GoMap<stdgo.go.types.Types.T_importKey, stdgo.Ref<stdgo.go.types.Types.Package>>) } : stdgo.go.types.Types.Checker)) : stdgo.Ref<stdgo.go.types.Types.Checker>);
    }
function _instantiatedIdent(_expr:stdgo.go.ast.Ast.Expr):stdgo.Ref<stdgo.go.ast.Ast.Ident> {
        var _selOrIdent:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
        {
            final __type__ = _expr;
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IndexExpr>))) {
                var _e:stdgo.Ref<stdgo.go.ast.Ast.IndexExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IndexExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IndexExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IndexExpr>) : __type__.__underlying__().value;
                _selOrIdent = _e.x;
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IndexListExpr>))) {
                var _e:stdgo.Ref<stdgo.go.ast.Ast.IndexListExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IndexListExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IndexListExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IndexListExpr>) : __type__.__underlying__().value;
                _selOrIdent = _e.x;
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.Ident>))) {
                var _e:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                _selOrIdent = _e;
            };
        };
        {
            final __type__ = _selOrIdent;
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.Ident>))) {
                var _x:stdgo.Ref<stdgo.go.ast.Ast.Ident> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__().value;
                return _x;
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>))) {
                var _x:stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__().value;
                return _x.sel;
            };
        };
        throw stdgo.Go.toInterface(("instantiated ident not found" : stdgo.GoString));
    }
/**
    // representableConst reports whether x can be represented as
    // value of the given basic type and for the configuration
    // provided (only needed for int/uint sizes).
    //
    // If rounded != nil, *rounded is set to the rounded value of x for
    // representable floating-point and complex values, and to an Int
    // value for integer values; it is left alone otherwise.
    // It is ok to provide the addressof the first argument for rounded.
    //
    // The check parameter may be nil if representableConst is invoked
    // (indirectly) through an exported API call (AssignableTo, ConvertibleTo)
    // because we don't need the Checker's config for those calls.
**/
function _representableConst(_x:stdgo.go.constant.Constant.Value, _check:stdgo.Ref<Checker>, _typ:stdgo.Ref<Basic>, _rounded:stdgo.Ref<stdgo.go.constant.Constant.Value>):Bool {
        if (_x.kind() == ((0 : stdgo.go.constant.Constant.Kind))) {
            return true;
        };
        var _conf:stdgo.Ref<Config> = (null : stdgo.Ref<stdgo.go.types.Types.Config>);
        if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
            _conf = _check._conf;
        };
        var _sizeof:stdgo.go.types.Types.Type_ -> stdgo.GoInt64 = function(t:Type_):stdgo.GoInt64 {
            var _s:stdgo.GoInt64 = _conf._sizeof(t);
            return _s;
        };
        if (_isInteger(stdgo.Go.asInterface(_typ))) {
            var _x:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.toInt(_x);
            if (_x.kind() != ((3 : stdgo.go.constant.Constant.Kind))) {
                return false;
            };
            if (_rounded != null && ((_rounded : Dynamic).__nil__ == null || !(_rounded : Dynamic).__nil__)) {
                {
                    var __tmp__ = _x;
                    _rounded.exactString = __tmp__.exactString;
                    _rounded.kind = __tmp__.kind;
                    _rounded.string = __tmp__.string;
                    _rounded._implementsValue = __tmp__._implementsValue;
                };
            };
            {
                var __tmp__ = stdgo.go.constant.Constant.int64Val(_x), _x:stdgo.GoInt64 = __tmp__._0, _ok:Bool = __tmp__._1;
                if (_ok) {
                    {
                        final __value__ = _typ._kind;
                        if (__value__ == ((2 : stdgo.go.types.Types.BasicKind))) {
                            var _s:stdgo.GoUInt = (_sizeof(stdgo.Go.asInterface(_typ)) : stdgo.GoUInt) * (8u32 : stdgo.GoUInt);
                            return ((((-1i64 : stdgo.GoInt64) : stdgo.GoInt64) << (_s - (1u32 : stdgo.GoUInt))) <= _x) && (_x <= ((((1i64 : stdgo.GoInt64) : stdgo.GoInt64) << (_s - (1u32 : stdgo.GoUInt))) - (1i64 : stdgo.GoInt64)));
                        } else if (__value__ == ((3 : stdgo.go.types.Types.BasicKind))) {
                            {};
                            return ((-128i64 : stdgo.GoInt64) <= _x) && (_x <= (127i64 : stdgo.GoInt64));
                        } else if (__value__ == ((4 : stdgo.go.types.Types.BasicKind))) {
                            {};
                            return ((-32768i64 : stdgo.GoInt64) <= _x) && (_x <= (32767i64 : stdgo.GoInt64));
                        } else if (__value__ == ((5 : stdgo.go.types.Types.BasicKind))) {
                            {};
                            return ((-2147483648i64 : stdgo.GoInt64) <= _x) && (_x <= (2147483647i64 : stdgo.GoInt64));
                        } else if (__value__ == ((6 : stdgo.go.types.Types.BasicKind)) || __value__ == ((20 : stdgo.go.types.Types.BasicKind))) {
                            return true;
                        } else if (__value__ == ((7 : stdgo.go.types.Types.BasicKind)) || __value__ == ((12 : stdgo.go.types.Types.BasicKind))) {
                            {
                                var _s:stdgo.GoUInt = (_sizeof(stdgo.Go.asInterface(_typ)) : stdgo.GoUInt) * (8u32 : stdgo.GoUInt);
                                if (_s < (64u32 : stdgo.GoUInt)) {
                                    return ((0i64 : stdgo.GoInt64) <= _x) && (_x <= ((((1i64 : stdgo.GoInt64) : stdgo.GoInt64) << _s) - (1i64 : stdgo.GoInt64)));
                                };
                            };
                            return (0i64 : stdgo.GoInt64) <= _x;
                        } else if (__value__ == ((8 : stdgo.go.types.Types.BasicKind))) {
                            {};
                            return ((0i64 : stdgo.GoInt64) <= _x) && (_x <= (255i64 : stdgo.GoInt64));
                        } else if (__value__ == ((9 : stdgo.go.types.Types.BasicKind))) {
                            {};
                            return ((0i64 : stdgo.GoInt64) <= _x) && (_x <= (65535i64 : stdgo.GoInt64));
                        } else if (__value__ == ((10 : stdgo.go.types.Types.BasicKind))) {
                            {};
                            return ((0i64 : stdgo.GoInt64) <= _x) && (_x <= (4294967295i64 : stdgo.GoInt64));
                        } else if (__value__ == ((11 : stdgo.go.types.Types.BasicKind))) {
                            return (0i64 : stdgo.GoInt64) <= _x;
                        } else {
                            _unreachable();
                        };
                    };
                };
            };
            {
                var _n:stdgo.GoInt = stdgo.go.constant.Constant.bitLen(_x);
                {
                    final __value__ = _typ._kind;
                    if (__value__ == ((7 : stdgo.go.types.Types.BasicKind)) || __value__ == ((12 : stdgo.go.types.Types.BasicKind))) {
                        var _s:stdgo.GoUInt = (_sizeof(stdgo.Go.asInterface(_typ)) : stdgo.GoUInt) * (8u32 : stdgo.GoUInt);
                        return (stdgo.go.constant.Constant.sign(_x) >= (0 : stdgo.GoInt)) && (_n <= (_s : stdgo.GoInt));
                    } else if (__value__ == ((11 : stdgo.go.types.Types.BasicKind))) {
                        return (stdgo.go.constant.Constant.sign(_x) >= (0 : stdgo.GoInt)) && (_n <= (64 : stdgo.GoInt));
                    } else if (__value__ == ((20 : stdgo.go.types.Types.BasicKind))) {
                        return true;
                    };
                };
            };
        } else if (_isFloat(stdgo.Go.asInterface(_typ))) {
            var _x:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.toFloat(_x);
            if (_x.kind() != ((4 : stdgo.go.constant.Constant.Kind))) {
                return false;
            };
            {
                final __value__ = _typ._kind;
                if (__value__ == ((13 : stdgo.go.types.Types.BasicKind))) {
                    if (_rounded == null || (_rounded : Dynamic).__nil__) {
                        return _fitsFloat32(_x);
                    };
                    var _r:stdgo.go.constant.Constant.Value = _roundFloat32(_x);
                    if (_r != null) {
                        {
                            var __tmp__ = _r;
                            _rounded.exactString = __tmp__.exactString;
                            _rounded.kind = __tmp__.kind;
                            _rounded.string = __tmp__.string;
                            _rounded._implementsValue = __tmp__._implementsValue;
                        };
                        return true;
                    };
                } else if (__value__ == ((14 : stdgo.go.types.Types.BasicKind))) {
                    if (_rounded == null || (_rounded : Dynamic).__nil__) {
                        return _fitsFloat64(_x);
                    };
                    var _r:stdgo.go.constant.Constant.Value = _roundFloat64(_x);
                    if (_r != null) {
                        {
                            var __tmp__ = _r;
                            _rounded.exactString = __tmp__.exactString;
                            _rounded.kind = __tmp__.kind;
                            _rounded.string = __tmp__.string;
                            _rounded._implementsValue = __tmp__._implementsValue;
                        };
                        return true;
                    };
                } else if (__value__ == ((22 : stdgo.go.types.Types.BasicKind))) {
                    return true;
                } else {
                    _unreachable();
                };
            };
        } else if (_isComplex(stdgo.Go.asInterface(_typ))) {
            var _x:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.toComplex(_x);
            if (_x.kind() != ((5 : stdgo.go.constant.Constant.Kind))) {
                return false;
            };
            {
                final __value__ = _typ._kind;
                if (__value__ == ((15 : stdgo.go.types.Types.BasicKind))) {
                    if (_rounded == null || (_rounded : Dynamic).__nil__) {
                        return _fitsFloat32(stdgo.go.constant.Constant.real(_x)) && _fitsFloat32(stdgo.go.constant.Constant.imag(_x));
                    };
                    var _re:stdgo.go.constant.Constant.Value = _roundFloat32(stdgo.go.constant.Constant.real(_x));
                    var _im:stdgo.go.constant.Constant.Value = _roundFloat32(stdgo.go.constant.Constant.imag(_x));
                    if ((_re != null) && (_im != null)) {
                        {
                            var __tmp__ = stdgo.go.constant.Constant.binaryOp(_re, (12 : stdgo.go.token.Token.Token), stdgo.go.constant.Constant.makeImag(_im));
                            _rounded.exactString = __tmp__.exactString;
                            _rounded.kind = __tmp__.kind;
                            _rounded.string = __tmp__.string;
                            _rounded._implementsValue = __tmp__._implementsValue;
                        };
                        return true;
                    };
                } else if (__value__ == ((16 : stdgo.go.types.Types.BasicKind))) {
                    if (_rounded == null || (_rounded : Dynamic).__nil__) {
                        return _fitsFloat64(stdgo.go.constant.Constant.real(_x)) && _fitsFloat64(stdgo.go.constant.Constant.imag(_x));
                    };
                    var _re:stdgo.go.constant.Constant.Value = _roundFloat64(stdgo.go.constant.Constant.real(_x));
                    var _im:stdgo.go.constant.Constant.Value = _roundFloat64(stdgo.go.constant.Constant.imag(_x));
                    if ((_re != null) && (_im != null)) {
                        {
                            var __tmp__ = stdgo.go.constant.Constant.binaryOp(_re, (12 : stdgo.go.token.Token.Token), stdgo.go.constant.Constant.makeImag(_im));
                            _rounded.exactString = __tmp__.exactString;
                            _rounded.kind = __tmp__.kind;
                            _rounded.string = __tmp__.string;
                            _rounded._implementsValue = __tmp__._implementsValue;
                        };
                        return true;
                    };
                } else if (__value__ == ((23 : stdgo.go.types.Types.BasicKind))) {
                    return true;
                } else {
                    _unreachable();
                };
            };
        } else if (_isString(stdgo.Go.asInterface(_typ))) {
            return _x.kind() == ((2 : stdgo.go.constant.Constant.Kind));
        } else if (_isBoolean(stdgo.Go.asInterface(_typ))) {
            return _x.kind() == ((1 : stdgo.go.constant.Constant.Kind));
        };
        return false;
    }
function _fitsFloat32(_x:stdgo.go.constant.Constant.Value):Bool {
        var __tmp__ = stdgo.go.constant.Constant.float32Val(_x), _f32:stdgo.GoFloat32 = __tmp__._0, __0:Bool = __tmp__._1;
        var _f:stdgo.GoFloat64 = (_f32 : stdgo.GoFloat64);
        return !stdgo.math.Math.isInf(_f, (0 : stdgo.GoInt));
    }
function _roundFloat32(_x:stdgo.go.constant.Constant.Value):stdgo.go.constant.Constant.Value {
        var __tmp__ = stdgo.go.constant.Constant.float32Val(_x), _f32:stdgo.GoFloat32 = __tmp__._0, __0:Bool = __tmp__._1;
        var _f:stdgo.GoFloat64 = (_f32 : stdgo.GoFloat64);
        if (!stdgo.math.Math.isInf(_f, (0 : stdgo.GoInt))) {
            return stdgo.go.constant.Constant.makeFloat64(_f);
        };
        return (null : stdgo.go.constant.Constant.Value);
    }
function _fitsFloat64(_x:stdgo.go.constant.Constant.Value):Bool {
        var __tmp__ = stdgo.go.constant.Constant.float64Val(_x), _f:stdgo.GoFloat64 = __tmp__._0, __0:Bool = __tmp__._1;
        return !stdgo.math.Math.isInf(_f, (0 : stdgo.GoInt));
    }
function _roundFloat64(_x:stdgo.go.constant.Constant.Value):stdgo.go.constant.Constant.Value {
        var __tmp__ = stdgo.go.constant.Constant.float64Val(_x), _f:stdgo.GoFloat64 = __tmp__._0, __0:Bool = __tmp__._1;
        if (!stdgo.math.Math.isInf(_f, (0 : stdgo.GoInt))) {
            return stdgo.go.constant.Constant.makeFloat64(_f);
        };
        return (null : stdgo.go.constant.Constant.Value);
    }
/**
    // NewContext creates a new Context.
**/
function newContext():stdgo.Ref<Context> {
        return (stdgo.Go.setRef(({ _typeMap : ({
            final x = new stdgo.GoMap.GoStringMap<stdgo.Slice<stdgo.go.types.Types.T_ctxtEntry>>();
            x.__defaultValue__ = () -> (null : stdgo.Slice<stdgo.go.types.Types.T_ctxtEntry>);
            @:mergeBlock {};
            x;
        } : stdgo.GoMap<stdgo.GoString, stdgo.Slice<stdgo.go.types.Types.T_ctxtEntry>>), _originIDs : ({
            final x = new stdgo.GoMap.GoObjectMap<stdgo.go.types.Types.Type_, stdgo.GoInt>();
            x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Type_", [], stdgo.internal.reflect.Reflect.GoType.named("Type_", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
            x.__defaultValue__ = () -> (0 : stdgo.GoInt);
            @:mergeBlock {};
            cast x;
        } : stdgo.GoMap<stdgo.go.types.Types.Type_, stdgo.GoInt>) } : stdgo.go.types.Types.Context)) : stdgo.Ref<stdgo.go.types.Types.Context>);
    }
function testContextHashCollisions(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        if (false) {
            _t.skip(stdgo.Go.toInterface(("hash collisions are expected, and would fail debug assertions" : stdgo.GoString)));
        };
        var __0:Type_ = (null : stdgo.go.types.Types.Type_), __1:Type_ = (null : stdgo.go.types.Types.Type_), __2:Type_ = (null : stdgo.go.types.Types.Type_), _unaryP:Type_ = __2, _nullaryQ:Type_ = __1, _nullaryP:Type_ = __0;
        {
            var _tparam = newTypeParam(newTypeName(_nopos, null, ("P" : stdgo.GoString), (null : stdgo.go.types.Types.Type_)), stdgo.Go.asInterface((stdgo.Go.setRef(_emptyInterface) : stdgo.Ref<stdgo.go.types.Types.Interface>)));
            _nullaryP = stdgo.Go.asInterface(newSignatureType(null, (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>), (new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>(1, 1, _tparam) : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>), null, null, false));
        };
        {
            var _tparam = newTypeParam(newTypeName(_nopos, null, ("Q" : stdgo.GoString), (null : stdgo.go.types.Types.Type_)), stdgo.Go.asInterface((stdgo.Go.setRef(_emptyInterface) : stdgo.Ref<stdgo.go.types.Types.Interface>)));
            _nullaryQ = stdgo.Go.asInterface(newSignatureType(null, (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>), (new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>(1, 1, _tparam) : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>), null, null, false));
        };
        {
            var _tparam = newTypeParam(newTypeName(_nopos, null, ("P" : stdgo.GoString), (null : stdgo.go.types.Types.Type_)), stdgo.Go.asInterface((stdgo.Go.setRef(_emptyInterface) : stdgo.Ref<stdgo.go.types.Types.Interface>)));
            var _params = newTuple(newVar(_nopos, null, ("_" : stdgo.GoString), stdgo.Go.asInterface(_tparam)));
            _unaryP = stdgo.Go.asInterface(newSignatureType(null, (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>), (new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>(1, 1, _tparam) : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>), _params, null, false));
        };
        var _ctxt = newContext();
        var _inst = newSignatureType(null, (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>), (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>), null, null, false);
        {
            var _got:stdgo.go.types.Types.Type_ = _ctxt._update(stdgo.Go.str()?.__copy__(), _nullaryP, (new stdgo.Slice<stdgo.go.types.Types.Type_>(1, 1, stdgo.Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])) : stdgo.Slice<stdgo.go.types.Types.Type_>), stdgo.Go.asInterface(_inst));
            if (stdgo.Go.toInterface(_got) != (stdgo.Go.toInterface(stdgo.Go.asInterface(_inst)))) {
                _t.error(stdgo.Go.toInterface(("bad" : stdgo.GoString)));
            };
        };
        {
            var _got:stdgo.go.types.Types.Type_ = _ctxt._lookup(stdgo.Go.str()?.__copy__(), _unaryP, (new stdgo.Slice<stdgo.go.types.Types.Type_>(1, 1, stdgo.Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])) : stdgo.Slice<stdgo.go.types.Types.Type_>));
            if (_got != null) {
                _t.error(stdgo.Go.toInterface(("bad" : stdgo.GoString)));
            };
        };
        {
            var _got:stdgo.go.types.Types.Type_ = _ctxt._lookup(stdgo.Go.str()?.__copy__(), _nullaryQ, (new stdgo.Slice<stdgo.go.types.Types.Type_>(1, 1, stdgo.Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])) : stdgo.Slice<stdgo.go.types.Types.Type_>));
            if (stdgo.Go.toInterface(_got) != (stdgo.Go.toInterface(stdgo.Go.asInterface(_inst)))) {
                _t.error(stdgo.Go.toInterface(("bad" : stdgo.GoString)));
            };
        };
        {
            var _got:stdgo.go.types.Types.Type_ = _ctxt._lookup(stdgo.Go.str()?.__copy__(), _nullaryQ, (new stdgo.Slice<stdgo.go.types.Types.Type_>(1, 1, stdgo.Go.asInterface(typ[((17 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])) : stdgo.Slice<stdgo.go.types.Types.Type_>));
            if (_got != null) {
                _t.error(stdgo.Go.toInterface(("bad" : stdgo.GoString)));
            };
        };
    }
function _isUintptr(_typ:Type_):Bool {
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_typ)) : stdgo.Ref<Basic>)) : stdgo.Ref<Basic>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Basic>), _1 : false };
        }, _t = __tmp__._0, __0 = __tmp__._1;
        return ((_t != null) && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) && (_t._kind == (12 : stdgo.go.types.Types.BasicKind));
    }
function _isUnsafePointer(_typ:Type_):Bool {
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_typ)) : stdgo.Ref<Basic>)) : stdgo.Ref<Basic>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Basic>), _1 : false };
        }, _t = __tmp__._0, __0 = __tmp__._1;
        return ((_t != null) && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) && (_t._kind == (18 : stdgo.go.types.Types.BasicKind));
    }
function _isPointer(_typ:Type_):Bool {
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_typ)) : stdgo.Ref<Pointer_>)) : stdgo.Ref<Pointer_>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>), _1 : false };
        }, __0 = __tmp__._0, _ok = __tmp__._1;
        return _ok;
    }
function _isBytesOrRunes(_typ:Type_):Bool {
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_typ)) : stdgo.Ref<Slice_>)) : stdgo.Ref<Slice_>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Slice_>), _1 : false };
            }, _s = __tmp__._0, __0 = __tmp__._1;
            if (_s != null && ((_s : Dynamic).__nil__ == null || !(_s : Dynamic).__nil__)) {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_s._elem)) : stdgo.Ref<Basic>)) : stdgo.Ref<Basic>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Basic>), _1 : false };
                }, _t = __tmp__._0, __1 = __tmp__._1;
                return ((_t != null) && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) && ((_t._kind == (8 : stdgo.go.types.Types.BasicKind)) || (_t._kind == (5 : stdgo.go.types.Types.BasicKind)));
            };
        };
        return false;
    }
/**
    // pathString returns a string of the form a->b-> ... ->g for a path [a, b, ... g].
**/
function _pathString(_path:stdgo.Slice<Object>):stdgo.GoString {
        var _s:stdgo.GoString = ("" : stdgo.GoString);
        for (_i => _p in _path) {
            if (_i > (0 : stdgo.GoInt)) {
                _s = _s + (("->" : stdgo.GoString))?.__copy__();
            };
            _s = _s + (_p.name())?.__copy__();
        };
        return _s?.__copy__();
    }
/**
    // firstInSrc reports the index of the object with the "smallest"
    // source position in path. path must not be empty.
**/
function _firstInSrc(_path:stdgo.Slice<Object>):stdgo.GoInt {
        var __0:stdgo.GoInt = (0 : stdgo.GoInt), __1:stdgo.go.token.Token.Pos = _path[(0 : stdgo.GoInt)].pos(), _pos:stdgo.go.token.Token.Pos = __1, _fst:stdgo.GoInt = __0;
        for (_i => _t in (_path.__slice__((1 : stdgo.GoInt)) : stdgo.Slice<stdgo.go.types.Types.Object>)) {
            if (_cmpPos(_t.pos(), _pos) < (0 : stdgo.GoInt)) {
                {
                    final __tmp__0 = _i + (1 : stdgo.GoInt);
                    final __tmp__1 = _t.pos();
                    _fst = __tmp__0;
                    _pos = __tmp__1;
                };
            };
        };
        return _fst;
    }
function _assert(_p:Bool):Void {
        if (!_p) {
            var _msg:stdgo.GoString = ("assertion failed" : stdgo.GoString);
            {
                var __tmp__ = stdgo.runtime.Runtime.caller((1 : stdgo.GoInt)), __0:stdgo.GoUIntptr = __tmp__._0, _file:stdgo.GoString = __tmp__._1, _line:stdgo.GoInt = __tmp__._2, _ok:Bool = __tmp__._3;
                if (_ok) {
                    _msg = stdgo.fmt.Fmt.sprintf(("%s:%d: %s" : stdgo.GoString), stdgo.Go.toInterface(_file), stdgo.Go.toInterface(_line), stdgo.Go.toInterface(_msg))?.__copy__();
                };
            };
            throw stdgo.Go.toInterface(_msg);
        };
    }
function _unreachable():Void {
        throw stdgo.Go.toInterface(("unreachable" : stdgo.GoString));
    }
function _sprintf(_fset:stdgo.Ref<stdgo.go.token.Token.FileSet>, _qf:Qualifier, _tpSubscripts:Bool, _format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):stdgo.GoString {
        var _args = new stdgo.Slice<stdgo.AnyInterface>(_args.length, 0, ..._args);
        for (_i => _arg in _args) {
            {
                final __type__ = _arg;
                if (__type__ == null) {
                    var _a:stdgo.AnyInterface = __type__ == null ? (null : stdgo.AnyInterface) : __type__.__underlying__();
                    _arg = stdgo.Go.toInterface(("<nil>" : stdgo.GoString));
                } else if (stdgo.Go.typeEquals((__type__ : T_operand))) {
                    var _a:stdgo.go.types.Types.T_operand = __type__ == null ? ({} : stdgo.go.types.Types.T_operand) : __type__.__underlying__() == null ? ({} : stdgo.go.types.Types.T_operand) : __type__ == null ? ({} : stdgo.go.types.Types.T_operand) : __type__.__underlying__().value;
                    throw stdgo.Go.toInterface(("got operand instead of *operand" : stdgo.GoString));
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<T_operand>))) {
                    var _a:stdgo.Ref<stdgo.go.types.Types.T_operand> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.T_operand>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.T_operand>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.T_operand>) : __type__.__underlying__().value;
                    _arg = stdgo.Go.toInterface(_operandString(_a, _qf));
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.go.token.Token.Pos))) {
                    var _a:stdgo.go.token.Token.Pos = __type__ == null ? ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos) : __type__.__underlying__() == null ? ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos) : __type__ == null ? ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos) : __type__.__underlying__().value;
                    if (_fset != null && ((_fset : Dynamic).__nil__ == null || !(_fset : Dynamic).__nil__)) {
                        _arg = stdgo.Go.toInterface((_fset.position(_a).string() : stdgo.GoString));
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.go.ast.Ast.Expr))) {
                    var _a:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : __type__.__underlying__() == null ? (null : stdgo.go.ast.Ast.Expr) : __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : __type__.__underlying__().value;
                    _arg = stdgo.Go.toInterface(exprString(_a));
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Slice<stdgo.go.ast.Ast.Expr>))) {
                    var _a:stdgo.Slice<stdgo.go.ast.Ast.Expr> = __type__ == null ? (null : stdgo.Slice<stdgo.go.ast.Ast.Expr>) : __type__.__underlying__() == null ? (null : stdgo.Slice<stdgo.go.ast.Ast.Expr>) : __type__ == null ? (null : stdgo.Slice<stdgo.go.ast.Ast.Expr>) : __type__.__underlying__().value;
                    var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
                    _buf.writeByte((91 : stdgo.GoUInt8));
                    _writeExprList((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.bytes.Bytes.Buffer>), _a);
                    _buf.writeByte((93 : stdgo.GoUInt8));
                    _arg = stdgo.Go.toInterface((_buf.string() : stdgo.GoString));
                } else if (stdgo.Go.typeEquals((__type__ : Object))) {
                    var _a:stdgo.go.types.Types.Object = __type__ == null ? (null : stdgo.go.types.Types.Object) : __type__.__underlying__() == null ? (null : stdgo.go.types.Types.Object) : __type__ == null ? (null : stdgo.go.types.Types.Object) : __type__.__underlying__().value;
                    _arg = stdgo.Go.toInterface(objectString(_a, _qf));
                } else if (stdgo.Go.typeEquals((__type__ : Type_))) {
                    var _a:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : __type__.__underlying__() == null ? (null : stdgo.go.types.Types.Type_) : __type__ == null ? (null : stdgo.go.types.Types.Type_) : __type__.__underlying__().value;
                    var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
                    var _w = _newTypeWriter((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.bytes.Bytes.Buffer>), _qf);
                    _w._tpSubscripts = _tpSubscripts;
                    _w._typ(_a);
                    _arg = stdgo.Go.toInterface((_buf.string() : stdgo.GoString));
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Slice<Type_>))) {
                    var _a:stdgo.Slice<stdgo.go.types.Types.Type_> = __type__ == null ? (null : stdgo.Slice<stdgo.go.types.Types.Type_>) : __type__.__underlying__() == null ? (null : stdgo.Slice<stdgo.go.types.Types.Type_>) : __type__ == null ? (null : stdgo.Slice<stdgo.go.types.Types.Type_>) : __type__.__underlying__().value;
                    var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
                    var _w = _newTypeWriter((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.bytes.Bytes.Buffer>), _qf);
                    _w._tpSubscripts = _tpSubscripts;
                    _buf.writeByte((91 : stdgo.GoUInt8));
                    for (_i => _x in _a) {
                        if (_i > (0 : stdgo.GoInt)) {
                            _buf.writeString((", " : stdgo.GoString));
                        };
                        _w._typ(_x);
                    };
                    _buf.writeByte((93 : stdgo.GoUInt8));
                    _arg = stdgo.Go.toInterface((_buf.string() : stdgo.GoString));
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Slice<stdgo.Ref<TypeParam>>))) {
                    var _a:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>> = __type__ == null ? (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>) : __type__.__underlying__() == null ? (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>) : __type__ == null ? (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>) : __type__.__underlying__().value;
                    var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
                    var _w = _newTypeWriter((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.bytes.Bytes.Buffer>), _qf);
                    _w._tpSubscripts = _tpSubscripts;
                    _buf.writeByte((91 : stdgo.GoUInt8));
                    for (_i => _x in _a) {
                        if (_i > (0 : stdgo.GoInt)) {
                            _buf.writeString((", " : stdgo.GoString));
                        };
                        _w._typ(stdgo.Go.asInterface(_x));
                    };
                    _buf.writeByte((93 : stdgo.GoUInt8));
                    _arg = stdgo.Go.toInterface((_buf.string() : stdgo.GoString));
                };
            };
            _args[(_i : stdgo.GoInt)] = _arg;
        };
        return stdgo.fmt.Fmt.sprintf(_format?.__copy__(), ..._args.__toArray__())?.__copy__();
    }
/**
    // newErrorf creates a new error_ for later reporting with check.report.
**/
function _newErrorf(_at:T_positioner, _code:Code, _format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):stdgo.Ref<T_error_> {
        var _args = new stdgo.Slice<stdgo.AnyInterface>(_args.length, 0, ..._args);
        return (stdgo.Go.setRef(({ _desc : (new stdgo.Slice<stdgo.go.types.Types.T_errorDesc>(1, 1, (new stdgo.go.types.Types.T_errorDesc(_at, _format?.__copy__(), _args) : stdgo.go.types.Types.T_errorDesc)) : stdgo.Slice<stdgo.go.types.Types.T_errorDesc>), _code : _code } : stdgo.go.types.Types.T_error_)) : stdgo.Ref<stdgo.go.types.Types.T_error_>);
    }
/**
    // inNode creates a posSpan for the given node.
    // Invariant: node.Pos() <= pos < node.End() (node.End() is the position of the
    // first byte after node within the source).
**/
function _inNode(_node:stdgo.go.ast.Ast.Node, _pos:stdgo.go.token.Token.Pos):T_posSpan {
        var __0:stdgo.go.token.Token.Pos = _node.pos(), __1:stdgo.go.token.Token.Pos = _node.end(), _end:stdgo.go.token.Token.Pos = __1, _start:stdgo.go.token.Token.Pos = __0;
        if (false) {
            _assert((_start <= _pos) && (_pos < _end));
        };
        return (new stdgo.go.types.Types.T_posSpan(_start, _pos, _end) : stdgo.go.types.Types.T_posSpan);
    }
/**
    // spanOf extracts an error span from the given positioner. By default this is
    // the trivial span starting and ending at pos, but this span is expanded when
    // the argument naturally corresponds to a span of source code.
**/
function _spanOf(_at:T_positioner):T_posSpan {
        {
            final __type__ = _at;
            if (__type__ == null) {
                var _x:stdgo.AnyInterface = __type__ == null ? (null : stdgo.AnyInterface) : cast __type__;
                throw stdgo.Go.toInterface(("nil positioner" : stdgo.GoString));
            } else if (stdgo.Go.typeEquals((__type__ : T_posSpan))) {
                var _x:stdgo.go.types.Types.T_posSpan = __type__ == null ? ({} : stdgo.go.types.Types.T_posSpan) : __type__.__underlying__() == null ? ({} : stdgo.go.types.Types.T_posSpan) : __type__ == null ? ({} : stdgo.go.types.Types.T_posSpan) : __type__.__underlying__().value;
                return _x?.__copy__();
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.go.ast.Ast.Node))) {
                var _x:stdgo.go.ast.Ast.Node = __type__ == null ? (null : stdgo.go.ast.Ast.Node) : cast __type__;
                var _pos:stdgo.go.token.Token.Pos = _x.pos();
                return (new stdgo.go.types.Types.T_posSpan(_pos, _pos, _x.end()) : stdgo.go.types.Types.T_posSpan);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<T_operand>))) {
                var _x:stdgo.Ref<stdgo.go.types.Types.T_operand> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.T_operand>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.T_operand>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.T_operand>) : __type__.__underlying__().value;
                if (_x._expr != null) {
                    var _pos:stdgo.go.token.Token.Pos = _x.pos();
                    return (new stdgo.go.types.Types.T_posSpan(_pos, _pos, _x._expr.end()) : stdgo.go.types.Types.T_posSpan);
                };
                return (new stdgo.go.types.Types.T_posSpan(_nopos, _nopos, _nopos) : stdgo.go.types.Types.T_posSpan);
            } else {
                var _x:stdgo.go.types.Types.T_positioner = __type__ == null ? (null : stdgo.go.types.Types.T_positioner) : cast __type__;
                var _pos:stdgo.go.token.Token.Pos = _at.pos();
                return (new stdgo.go.types.Types.T_posSpan(_pos, _pos, _pos) : stdgo.go.types.Types.T_posSpan);
            };
        };
    }
/**
    // stripAnnotations removes internal (type) annotations from s.
**/
function _stripAnnotations(_s:stdgo.GoString):stdgo.GoString {
        var _buf:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
        for (__0 => _r in _s) {
            if ((_r < (8320 : stdgo.GoInt32)) || ((8330 : stdgo.GoInt32) <= _r)) {
                _buf.writeRune(_r);
            };
        };
        if (_buf.len() < (_s.length)) {
            return (_buf.string() : stdgo.GoString)?.__copy__();
        };
        return _s?.__copy__();
    }
function testError(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        var _err:T_error_ = ({} : stdgo.go.types.Types.T_error_);
        var _want:stdgo.GoString = ("no error" : stdgo.GoString);
        {
            var _got:stdgo.GoString = (_err.string() : stdgo.GoString)?.__copy__();
            if (_got != (_want)) {
                _t.errorf(("empty error: got %q, want %q" : stdgo.GoString), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_want));
            };
        };
        _want = ("0: foo 42" : stdgo.GoString);
        _err._errorf(_nopos, ("foo %d" : stdgo.GoString), stdgo.Go.toInterface((42 : stdgo.GoInt)));
        {
            var _got:stdgo.GoString = (_err.string() : stdgo.GoString)?.__copy__();
            if (_got != (_want)) {
                _t.errorf(("simple error: got %q, want %q" : stdgo.GoString), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_want));
            };
        };
        _want = ("0: foo 42\n\tbar 43" : stdgo.GoString);
        _err._errorf(_nopos, ("bar %d" : stdgo.GoString), stdgo.Go.toInterface((43 : stdgo.GoInt)));
        {
            var _got:stdgo.GoString = (_err.string() : stdgo.GoString)?.__copy__();
            if (_got != (_want)) {
                _t.errorf(("simple error: got %q, want %q" : stdgo.GoString), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_want));
            };
        };
    }
function testStripAnnotations(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        for (__0 => _test in (new stdgo.Slice<T__struct_0>(5, 5, ({ _in : stdgo.Go.str()?.__copy__(), _want : stdgo.Go.str()?.__copy__() } : T__struct_0), ({ _in : ("   " : stdgo.GoString), _want : ("   " : stdgo.GoString) } : T__struct_0), ({ _in : ("foo" : stdgo.GoString), _want : ("foo" : stdgo.GoString) } : T__struct_0), ({ _in : ("foo₀" : stdgo.GoString), _want : ("foo" : stdgo.GoString) } : T__struct_0), ({ _in : ("foo(T₀)" : stdgo.GoString), _want : ("foo(T)" : stdgo.GoString) } : T__struct_0)) : stdgo.Slice<T__struct_0>)) {
            var _got:stdgo.GoString = _stripAnnotations(_test._in?.__copy__())?.__copy__();
            if (_got != (_test._want)) {
                _t.errorf(("%q: got %q; want %q" : stdgo.GoString), stdgo.Go.toInterface(_test._in), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_test._want));
            };
        };
    }
/**
    // Eval returns the type and, if constant, the value for the
    // expression expr, evaluated at position pos of package pkg,
    // which must have been derived from type-checking an AST with
    // complete position information relative to the provided file
    // set.
    //
    // The meaning of the parameters fset, pkg, and pos is the
    // same as in CheckExpr. An error is returned if expr cannot
    // be parsed successfully, or the resulting expr AST cannot be
    // type-checked.
**/
function eval(_fset:stdgo.Ref<stdgo.go.token.Token.FileSet>, _pkg:stdgo.Ref<Package>, _pos:stdgo.go.token.Token.Pos, _expr:stdgo.GoString):{ var _0 : TypeAndValue; var _1 : stdgo.Error; } {
        var _0:TypeAndValue = ({} : stdgo.go.types.Types.TypeAndValue), _err:stdgo.Error = (null : stdgo.Error);
        var __tmp__ = stdgo.go.parser.Parser.parseExprFrom(_fset, ("eval" : stdgo.GoString), stdgo.Go.toInterface(_expr), (0u32 : stdgo.go.parser.Parser.Mode)), _node:stdgo.go.ast.Ast.Expr = __tmp__._0, _err:stdgo.Error = __tmp__._1;
        if (_err != null) {
            return { _0 : (new stdgo.go.types.Types.TypeAndValue() : stdgo.go.types.Types.TypeAndValue), _1 : _err };
        };
        var _info = (stdgo.Go.setRef(({ types : ({
            final x = new stdgo.GoMap.GoObjectMap<stdgo.go.ast.Ast.Expr, stdgo.go.types.Types.TypeAndValue>();
            x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.ast.Ast.Expr", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }));
            x.__defaultValue__ = () -> ({} : stdgo.go.types.Types.TypeAndValue);
            @:mergeBlock {};
            cast x;
        } : stdgo.GoMap<stdgo.go.ast.Ast.Expr, stdgo.go.types.Types.TypeAndValue>) } : stdgo.go.types.Types.Info)) : stdgo.Ref<stdgo.go.types.Types.Info>);
        _err = checkExpr(_fset, _pkg, _pos, _node, _info);
        return { _0 : (_info.types[_node] ?? ({} : stdgo.go.types.Types.TypeAndValue))?.__copy__(), _1 : _err };
    }
/**
    // CheckExpr type checks the expression expr as if it had appeared at position
    // pos of package pkg. Type information about the expression is recorded in
    // info. The expression may be an identifier denoting an uninstantiated generic
    // function or type.
    //
    // If pkg == nil, the Universe scope is used and the provided
    // position pos is ignored. If pkg != nil, and pos is invalid,
    // the package scope is used. Otherwise, pos must belong to the
    // package.
    //
    // An error is returned if pos is not within the package or
    // if the node cannot be type-checked.
    //
    // Note: Eval and CheckExpr should not be used instead of running Check
    // to compute types and values, but in addition to Check, as these
    // functions ignore the context in which an expression is used (e.g., an
    // assignment). Thus, top-level untyped constants will return an
    // untyped type rather than the respective context-specific type.
**/
function checkExpr(_fset:stdgo.Ref<stdgo.go.token.Token.FileSet>, _pkg:stdgo.Ref<Package>, _pos:stdgo.go.token.Token.Pos, _expr:stdgo.go.ast.Ast.Expr, _info:stdgo.Ref<Info>):stdgo.Error {
        var __deferstack__:Array<Void -> Void> = [];
        var _err:stdgo.Error = (null : stdgo.Error);
        try {
            var _scope:stdgo.Ref<Scope> = (null : stdgo.Ref<stdgo.go.types.Types.Scope>);
            if (_pkg == null || (_pkg : Dynamic).__nil__) {
                _scope = universe;
                _pos = _nopos;
            } else if (!_pos.isValid()) {
                _scope = _pkg._scope;
            } else {
                for (__0 => _fscope in _pkg._scope._children) {
                    {
                        _scope = _fscope.innermost(_pos);
                        if (_scope != null && ((_scope : Dynamic).__nil__ == null || !(_scope : Dynamic).__nil__)) {
                            break;
                        };
                    };
                };
                if (((_scope == null) || (_scope : Dynamic).__nil__) || false) {
                    var _s = _scope;
                    while (((_s != null) && ((_s : Dynamic).__nil__ == null || !(_s : Dynamic).__nil__)) && (_s != _pkg._scope)) {
                        _s = _s._parent;
                    };
                    if (_s == null || (_s : Dynamic).__nil__) {
                        return stdgo.fmt.Fmt.errorf(("no position %s found in package %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_fset.position(_pos))), stdgo.Go.toInterface(_pkg._name));
                    };
                };
            };
            var _check = newChecker(null, _fset, _pkg, _info);
            _check._pkg._scope = _scope;
            _check._environment._pos = _pos;
            {
                var _a0 = (stdgo.Go.setRef(_err) : stdgo.Ref<stdgo.Error>);
                __deferstack__.unshift(() -> _check._handleBailout(_a0));
            };
            var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
            _check._rawExpr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _expr, (null : stdgo.go.types.Types.Type_), true);
            _check._processDelayed((0 : stdgo.GoInt));
            _check._recordUntyped();
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return (null : stdgo.Error);
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return _err;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return _err;
        };
    }
/**
    // opName returns the name of the operation if x is an operation
    // that might overflow; otherwise it returns the empty string.
**/
function _opName(_e:stdgo.go.ast.Ast.Expr):stdgo.GoString {
        {
            final __type__ = _e;
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>))) {
                var _e:stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__().value;
                if ((_e.op : stdgo.GoInt) < (_op2str2.length)) {
                    return _op2str2[(_e.op : stdgo.GoInt)]?.__copy__();
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>))) {
                var _e:stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__().value;
                if ((_e.op : stdgo.GoInt) < (_op2str1.length)) {
                    return _op2str1[(_e.op : stdgo.GoInt)]?.__copy__();
                };
            };
        };
        return stdgo.Go.str()?.__copy__();
    }
/**
    // If typ is a type parameter, underIs returns the result of typ.underIs(f).
    // Otherwise, underIs returns the result of f(under(typ)).
**/
function _underIs(_typ:Type_, _f:Type_ -> Bool):Bool {
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_typ) : stdgo.Ref<TypeParam>)) : stdgo.Ref<TypeParam>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>), _1 : false };
            }, _tpar = __tmp__._0, __0 = __tmp__._1;
            if (_tpar != null && ((_tpar : Dynamic).__nil__ == null || !(_tpar : Dynamic).__nil__)) {
                return _tpar._underIs(_f);
            };
        };
        return _f(_under(_typ));
    }
function _isShift(_op:stdgo.go.token.Token.Token):Bool {
        return (_op == (20 : stdgo.go.token.Token.Token)) || (_op == (21 : stdgo.go.token.Token.Token));
    }
function _isComparison(_op:stdgo.go.token.Token.Token):Bool {
        {
            final __value__ = _op;
            if (__value__ == ((39 : stdgo.go.token.Token.Token)) || __value__ == ((44 : stdgo.go.token.Token.Token)) || __value__ == ((40 : stdgo.go.token.Token.Token)) || __value__ == ((45 : stdgo.go.token.Token.Token)) || __value__ == ((41 : stdgo.go.token.Token.Token)) || __value__ == ((46 : stdgo.go.token.Token.Token))) {
                return true;
            };
        };
        return false;
    }
/**
    // keyVal maps a complex, float, integer, string or boolean constant value
    // to the corresponding complex128, float64, int64, uint64, string, or bool
    // Go value if possible; otherwise it returns x.
    // A complex constant that can be represented as a float (such as 1.2 + 0i)
    // is returned as a floating point value; if a floating point value can be
    // represented as an integer (such as 1.0) it is returned as an integer value.
    // This ensures that constants of different kind but equal value (such as
    // 1.0 + 0i, 1.0, 1) result in the same value.
**/
function _keyVal(_x:stdgo.go.constant.Constant.Value):stdgo.AnyInterface {
        {
            var __switchIndex__ = -1;
            var __run__ = true;
            while (__run__) {
                __run__ = false;
                {
                    final __value__ = _x.kind();
                    if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (__value__ == (5 : stdgo.go.constant.Constant.Kind)))) {
                        var _f:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.toFloat(_x);
                        if (_f.kind() != ((4 : stdgo.go.constant.Constant.Kind))) {
                            var __tmp__ = stdgo.go.constant.Constant.float64Val(stdgo.go.constant.Constant.real(_x)), _r:stdgo.GoFloat64 = __tmp__._0, __0:Bool = __tmp__._1;
                            var __tmp__ = stdgo.go.constant.Constant.float64Val(stdgo.go.constant.Constant.imag(_x)), _i:stdgo.GoFloat64 = __tmp__._0, __1:Bool = __tmp__._1;
                            return stdgo.Go.toInterface(new stdgo.GoComplex128(_r, _i));
                        };
                        _x = _f;
                        @:fallthrough {
                            __switchIndex__ = 1;
                            __run__ = true;
                            continue;
                        };
                        break;
                    } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && (__value__ == (4 : stdgo.go.constant.Constant.Kind)))) {
                        var _i:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.toInt(_x);
                        if (_i.kind() != ((3 : stdgo.go.constant.Constant.Kind))) {
                            var __tmp__ = stdgo.go.constant.Constant.float64Val(_x), _v:stdgo.GoFloat64 = __tmp__._0, __2:Bool = __tmp__._1;
                            return stdgo.Go.toInterface(_v);
                        };
                        _x = _i;
                        @:fallthrough {
                            __switchIndex__ = 2;
                            __run__ = true;
                            continue;
                        };
                        break;
                    } else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && (__value__ == (3 : stdgo.go.constant.Constant.Kind)))) {
                        {
                            var __tmp__ = stdgo.go.constant.Constant.int64Val(_x), _v:stdgo.GoInt64 = __tmp__._0, _ok:Bool = __tmp__._1;
                            if (_ok) {
                                return stdgo.Go.toInterface(_v);
                            };
                        };
                        {
                            var __tmp__ = stdgo.go.constant.Constant.uint64Val(_x), _v:stdgo.GoUInt64 = __tmp__._0, _ok:Bool = __tmp__._1;
                            if (_ok) {
                                return stdgo.Go.toInterface(_v);
                            };
                        };
                        break;
                        break;
                    } else if (__switchIndex__ == 3 || (__switchIndex__ == -1 && (__value__ == (2 : stdgo.go.constant.Constant.Kind)))) {
                        return stdgo.Go.toInterface(stdgo.go.constant.Constant.stringVal(_x));
                        break;
                        break;
                    } else if (__switchIndex__ == 4 || (__switchIndex__ == -1 && (__value__ == (1 : stdgo.go.constant.Constant.Kind)))) {
                        return stdgo.Go.toInterface(stdgo.go.constant.Constant.boolVal(_x));
                        break;
                        break;
                    };
                };
                break;
            };
        };
        return stdgo.Go.toInterface(_x);
    }
/**
    // ExprString returns the (possibly shortened) string representation for x.
    // Shortened representations are suitable for user interfaces but may not
    // necessarily follow Go syntax.
**/
function exprString(_x:stdgo.go.ast.Ast.Expr):stdgo.GoString {
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        writeExpr((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.bytes.Bytes.Buffer>), _x);
        return (_buf.string() : stdgo.GoString)?.__copy__();
    }
/**
    // WriteExpr writes the (possibly shortened) string representation for x to buf.
    // Shortened representations are suitable for user interfaces but may not
    // necessarily follow Go syntax.
**/
function writeExpr(_buf:stdgo.Ref<stdgo.bytes.Bytes.Buffer>, _x:stdgo.go.ast.Ast.Expr):Void {
        {
            final __type__ = _x;
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.Ident>))) {
                var _x:stdgo.Ref<stdgo.go.ast.Ast.Ident> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__().value;
                _buf.writeString(_x.name?.__copy__());
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.Ellipsis>))) {
                var _x:stdgo.Ref<stdgo.go.ast.Ast.Ellipsis> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__.__underlying__().value;
                _buf.writeString(("..." : stdgo.GoString));
                if (_x.elt != null) {
                    writeExpr(_buf, _x.elt);
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BasicLit>))) {
                var _x:stdgo.Ref<stdgo.go.ast.Ast.BasicLit> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BasicLit>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BasicLit>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BasicLit>) : __type__.__underlying__().value;
                _buf.writeString(_x.value?.__copy__());
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.FuncLit>))) {
                var _x:stdgo.Ref<stdgo.go.ast.Ast.FuncLit> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.FuncLit>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.FuncLit>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.FuncLit>) : __type__.__underlying__().value;
                _buf.writeByte((40 : stdgo.GoUInt8));
                writeExpr(_buf, stdgo.Go.asInterface(_x.type));
                _buf.writeString((" literal)" : stdgo.GoString));
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.CompositeLit>))) {
                var _x:stdgo.Ref<stdgo.go.ast.Ast.CompositeLit> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CompositeLit>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CompositeLit>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CompositeLit>) : __type__.__underlying__().value;
                writeExpr(_buf, _x.type);
                _buf.writeByte((123 : stdgo.GoUInt8));
                if ((_x.elts.length) > (0 : stdgo.GoInt)) {
                    _buf.writeString(("…" : stdgo.GoString));
                };
                _buf.writeByte((125 : stdgo.GoUInt8));
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>))) {
                var _x:stdgo.Ref<stdgo.go.ast.Ast.ParenExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__().value;
                _buf.writeByte((40 : stdgo.GoUInt8));
                writeExpr(_buf, _x.x);
                _buf.writeByte((41 : stdgo.GoUInt8));
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>))) {
                var _x:stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__().value;
                writeExpr(_buf, _x.x);
                _buf.writeByte((46 : stdgo.GoUInt8));
                _buf.writeString(_x.sel.name?.__copy__());
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IndexExpr>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IndexListExpr>))) {
                var _x:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                var _ix = stdgo.go.internal.typeparams.Typeparams.unpackIndexExpr(_x);
                writeExpr(_buf, _ix.indexListExpr.x);
                _buf.writeByte((91 : stdgo.GoUInt8));
                _writeExprList(_buf, _ix.indexListExpr.indices);
                _buf.writeByte((93 : stdgo.GoUInt8));
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SliceExpr>))) {
                var _x:stdgo.Ref<stdgo.go.ast.Ast.SliceExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SliceExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SliceExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SliceExpr>) : __type__.__underlying__().value;
                writeExpr(_buf, _x.x);
                _buf.writeByte((91 : stdgo.GoUInt8));
                if (_x.low != null) {
                    writeExpr(_buf, _x.low);
                };
                _buf.writeByte((58 : stdgo.GoUInt8));
                if (_x.high != null) {
                    writeExpr(_buf, _x.high);
                };
                if (_x.slice3) {
                    _buf.writeByte((58 : stdgo.GoUInt8));
                    if (_x.max != null) {
                        writeExpr(_buf, _x.max);
                    };
                };
                _buf.writeByte((93 : stdgo.GoUInt8));
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.TypeAssertExpr>))) {
                var _x:stdgo.Ref<stdgo.go.ast.Ast.TypeAssertExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.TypeAssertExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.TypeAssertExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.TypeAssertExpr>) : __type__.__underlying__().value;
                writeExpr(_buf, _x.x);
                _buf.writeString((".(" : stdgo.GoString));
                writeExpr(_buf, _x.type);
                _buf.writeByte((41 : stdgo.GoUInt8));
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>))) {
                var _x:stdgo.Ref<stdgo.go.ast.Ast.CallExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>) : __type__.__underlying__().value;
                writeExpr(_buf, _x.fun);
                _buf.writeByte((40 : stdgo.GoUInt8));
                _writeExprList(_buf, _x.args);
                if (_x.ellipsis.isValid()) {
                    _buf.writeString(("..." : stdgo.GoString));
                };
                _buf.writeByte((41 : stdgo.GoUInt8));
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>))) {
                var _x:stdgo.Ref<stdgo.go.ast.Ast.StarExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__().value;
                _buf.writeByte((42 : stdgo.GoUInt8));
                writeExpr(_buf, _x.x);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>))) {
                var _x:stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__().value;
                _buf.writeString((_x.op.string() : stdgo.GoString)?.__copy__());
                writeExpr(_buf, _x.x);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>))) {
                var _x:stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__().value;
                writeExpr(_buf, _x.x);
                _buf.writeByte((32 : stdgo.GoUInt8));
                _buf.writeString((_x.op.string() : stdgo.GoString)?.__copy__());
                _buf.writeByte((32 : stdgo.GoUInt8));
                writeExpr(_buf, _x.y);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ArrayType>))) {
                var _x:stdgo.Ref<stdgo.go.ast.Ast.ArrayType> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ArrayType>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ArrayType>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ArrayType>) : __type__.__underlying__().value;
                _buf.writeByte((91 : stdgo.GoUInt8));
                if (_x.len != null) {
                    writeExpr(_buf, _x.len);
                };
                _buf.writeByte((93 : stdgo.GoUInt8));
                writeExpr(_buf, _x.elt);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.StructType>))) {
                var _x:stdgo.Ref<stdgo.go.ast.Ast.StructType> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.StructType>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.StructType>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.StructType>) : __type__.__underlying__().value;
                _buf.writeString(("struct{" : stdgo.GoString));
                _writeFieldList(_buf, _x.fields.list, ("; " : stdgo.GoString), false);
                _buf.writeByte((125 : stdgo.GoUInt8));
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.FuncType>))) {
                var _x:stdgo.Ref<stdgo.go.ast.Ast.FuncType> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.FuncType>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.FuncType>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.FuncType>) : __type__.__underlying__().value;
                _buf.writeString(("func" : stdgo.GoString));
                _writeSigExpr(_buf, _x);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.InterfaceType>))) {
                var _x:stdgo.Ref<stdgo.go.ast.Ast.InterfaceType> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.InterfaceType>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.InterfaceType>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.InterfaceType>) : __type__.__underlying__().value;
                _buf.writeString(("interface{" : stdgo.GoString));
                _writeFieldList(_buf, _x.methods.list, ("; " : stdgo.GoString), true);
                _buf.writeByte((125 : stdgo.GoUInt8));
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.MapType>))) {
                var _x:stdgo.Ref<stdgo.go.ast.Ast.MapType> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.MapType>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.MapType>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.MapType>) : __type__.__underlying__().value;
                _buf.writeString(("map[" : stdgo.GoString));
                writeExpr(_buf, _x.key);
                _buf.writeByte((93 : stdgo.GoUInt8));
                writeExpr(_buf, _x.value);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ChanType>))) {
                var _x:stdgo.Ref<stdgo.go.ast.Ast.ChanType> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ChanType>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ChanType>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ChanType>) : __type__.__underlying__().value;
                var _s:stdgo.GoString = ("" : stdgo.GoString);
                {
                    final __value__ = _x.dir;
                    if (__value__ == ((1 : stdgo.go.ast.Ast.ChanDir))) {
                        _s = ("chan<- " : stdgo.GoString);
                    } else if (__value__ == ((2 : stdgo.go.ast.Ast.ChanDir))) {
                        _s = ("<-chan " : stdgo.GoString);
                    } else {
                        _s = ("chan " : stdgo.GoString);
                    };
                };
                _buf.writeString(_s?.__copy__());
                writeExpr(_buf, _x.value);
            } else {
                var _x:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                stdgo.fmt.Fmt.fprintf(stdgo.Go.asInterface(_buf), ("(ast: %T)" : stdgo.GoString), stdgo.Go.toInterface(_x));
            };
        };
    }
function _writeSigExpr(_buf:stdgo.Ref<stdgo.bytes.Bytes.Buffer>, _sig:stdgo.Ref<stdgo.go.ast.Ast.FuncType>):Void {
        _buf.writeByte((40 : stdgo.GoUInt8));
        _writeFieldList(_buf, _sig.params.list, (", " : stdgo.GoString), false);
        _buf.writeByte((41 : stdgo.GoUInt8));
        var _res = _sig.results;
        var _n:stdgo.GoInt = _res.numFields();
        if (_n == ((0 : stdgo.GoInt))) {
            return;
        };
        _buf.writeByte((32 : stdgo.GoUInt8));
        if ((_n == (1 : stdgo.GoInt)) && (_res.list[(0 : stdgo.GoInt)].names.length == (0 : stdgo.GoInt))) {
            writeExpr(_buf, _res.list[(0 : stdgo.GoInt)].type);
            return;
        };
        _buf.writeByte((40 : stdgo.GoUInt8));
        _writeFieldList(_buf, _res.list, (", " : stdgo.GoString), false);
        _buf.writeByte((41 : stdgo.GoUInt8));
    }
function _writeFieldList(_buf:stdgo.Ref<stdgo.bytes.Bytes.Buffer>, _list:stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.Field>>, _sep:stdgo.GoString, _iface:Bool):Void {
        for (_i => _f in _list) {
            if (_i > (0 : stdgo.GoInt)) {
                _buf.writeString(_sep?.__copy__());
            };
            _writeIdentList(_buf, _f.names);
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_f.type) : stdgo.Ref<stdgo.go.ast.Ast.FuncType>)) : stdgo.Ref<stdgo.go.ast.Ast.FuncType>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.FuncType>), _1 : false };
                }, _sig = __tmp__._0, __0 = __tmp__._1;
                if (((_sig != null) && ((_sig : Dynamic).__nil__ == null || !(_sig : Dynamic).__nil__)) && _iface) {
                    _writeSigExpr(_buf, _sig);
                    continue;
                };
            };
            if ((_f.names.length) > (0 : stdgo.GoInt)) {
                _buf.writeByte((32 : stdgo.GoUInt8));
            };
            writeExpr(_buf, _f.type);
        };
    }
function _writeIdentList(_buf:stdgo.Ref<stdgo.bytes.Bytes.Buffer>, _list:stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.Ident>>):Void {
        for (_i => _x in _list) {
            if (_i > (0 : stdgo.GoInt)) {
                _buf.writeString((", " : stdgo.GoString));
            };
            _buf.writeString(_x.name?.__copy__());
        };
    }
function _writeExprList(_buf:stdgo.Ref<stdgo.bytes.Bytes.Buffer>, _list:stdgo.Slice<stdgo.go.ast.Ast.Expr>):Void {
        for (_i => _x in _list) {
            if (_i > (0 : stdgo.GoInt)) {
                _buf.writeString((", " : stdgo.GoString));
            };
            writeExpr(_buf, _x);
        };
    }
/**
    // containsNil reports whether list contains a nil entry.
**/
function _containsNil(_list:stdgo.Slice<Type_>):Bool {
        for (__0 => _t in _list) {
            if (_t == null) {
                return true;
            };
        };
        return false;
    }
/**
    // typeParamsString produces a string containing all the type parameter names
    // in list suitable for human consumption.
**/
function _typeParamsString(_list:stdgo.Slice<stdgo.Ref<TypeParam>>):stdgo.GoString {
        var _n:stdgo.GoInt = (_list.length);
        {
            final __value__ = _n;
            if (__value__ == ((0 : stdgo.GoInt))) {
                return stdgo.Go.str()?.__copy__();
            } else if (__value__ == ((1 : stdgo.GoInt))) {
                return _list[(0 : stdgo.GoInt)]._obj._object._name?.__copy__();
            } else if (__value__ == ((2 : stdgo.GoInt))) {
                return _list[(0 : stdgo.GoInt)]._obj._object._name + (" and " : stdgo.GoString)?.__copy__() + _list[(1 : stdgo.GoInt)]._obj._object._name?.__copy__()?.__copy__();
            };
        };
        var _buf:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
        for (_i => _tname in (_list.__slice__(0, _n - (1 : stdgo.GoInt)) : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>)) {
            if (_i > (0 : stdgo.GoInt)) {
                _buf.writeString((", " : stdgo.GoString));
            };
            _buf.writeString(_tname._obj._object._name?.__copy__());
        };
        _buf.writeString((", and " : stdgo.GoString));
        _buf.writeString(_list[(_n - (1 : stdgo.GoInt) : stdgo.GoInt)]._obj._object._name?.__copy__());
        return (_buf.string() : stdgo.GoString)?.__copy__();
    }
/**
    // isParameterized reports whether typ contains any of the type parameters of tparams.
    // If typ is a generic function, isParameterized ignores the type parameter declarations;
    // it only considers the signature proper (incoming and result parameters).
**/
function _isParameterized(_tparams:stdgo.Slice<stdgo.Ref<TypeParam>>, _typ:Type_):Bool {
        var _w:stdgo.go.types.Types.T_tpWalker = ({ _tparams : _tparams, _seen : ({
            final x = new stdgo.GoMap.GoObjectMap<stdgo.go.types.Types.Type_, Bool>();
            x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Type_", [], stdgo.internal.reflect.Reflect.GoType.named("Type_", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
            x.__defaultValue__ = () -> false;
            @:mergeBlock {};
            cast x;
        } : stdgo.GoMap<stdgo.go.types.Types.Type_, Bool>) } : stdgo.go.types.Types.T_tpWalker);
        return _w._isParameterized(_typ);
    }
/**
    // If the type parameter has a single specific type S, coreTerm returns (S, true).
    // Otherwise, if tpar has a core type T, it returns a term corresponding to that
    // core type and false. In that case, if any term of tpar has a tilde, the core
    // term has a tilde. In all other cases coreTerm returns (nil, false).
**/
function _coreTerm(_tpar:stdgo.Ref<TypeParam>):{ var _0 : stdgo.Ref<T_term>; var _1 : Bool; } {
        var _n:stdgo.GoInt = (0 : stdgo.GoInt);
        var _single:stdgo.Ref<T_term> = (null : stdgo.Ref<stdgo.go.types.Types.T_term>);
        var _tilde:Bool = false;
        _tpar._is(function(_t:stdgo.Ref<T_term>):Bool {
            if (_t == null || (_t : Dynamic).__nil__) {
                _assert(_n == ((0 : stdgo.GoInt)));
                return false;
            };
            _n++;
            _single = _t;
            if (_t._tilde) {
                _tilde = true;
            };
            return true;
        });
        if (_n == ((1 : stdgo.GoInt))) {
            if (false) {
                _assert(false && (stdgo.Go.toInterface(_under(_single._typ)) == stdgo.Go.toInterface(_coreType(stdgo.Go.asInterface(_tpar)))));
            };
            return { _0 : _single, _1 : true };
        };
        {
            var _typ:stdgo.go.types.Types.Type_ = _coreType(stdgo.Go.asInterface(_tpar));
            if (_typ != null) {
                return { _0 : (stdgo.Go.setRef((new stdgo.go.types.Types.T_term(_tilde, _typ) : stdgo.go.types.Types.T_term)) : stdgo.Ref<stdgo.go.types.Types.T_term>), _1 : false };
            };
        };
        return { _0 : (null : stdgo.Ref<stdgo.go.types.Types.T_term>), _1 : false };
    }
/**
    // killCycles walks through the given type parameters and looks for cycles
    // created by type parameters whose inferred types refer back to that type
    // parameter, either directly or indirectly. If such a cycle is detected,
    // it is killed by setting the corresponding inferred type to nil.
    //
    // TODO(gri) Determine if we can simply abort inference as soon as we have
    // found a single cycle.
**/
function _killCycles(_tparams:stdgo.Slice<stdgo.Ref<TypeParam>>, _inferred:stdgo.Slice<Type_>):Void {
        var _w:stdgo.go.types.Types.T_cycleFinder = (new stdgo.go.types.Types.T_cycleFinder(_tparams, _inferred, ({
            final x = new stdgo.GoMap.GoObjectMap<stdgo.go.types.Types.Type_, Bool>();
            x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Type_", [], stdgo.internal.reflect.Reflect.GoType.named("Type_", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
            x.__defaultValue__ = () -> false;
            @:mergeBlock {};
            cast x;
        } : stdgo.GoMap<stdgo.go.types.Types.Type_, Bool>)) : stdgo.go.types.Types.T_cycleFinder);
        for (__0 => _t in _tparams) {
            _w._typ(stdgo.Go.asInterface(_t));
        };
    }
/**
    // If tpar is a type parameter in list, tparamIndex returns the index
    // of the type parameter in list. Otherwise the result is < 0.
**/
function _tparamIndex(_list:stdgo.Slice<stdgo.Ref<TypeParam>>, _tpar:stdgo.Ref<TypeParam>):stdgo.GoInt {
        for (_i => _p in _list) {
            if (_p == (_tpar)) {
                return _i;
            };
        };
        return (-1 : stdgo.GoInt);
    }
/**
    // findPath returns the (reversed) list of objects []Object{to, ... from}
    // such that there is a path of object dependencies from 'from' to 'to'.
    // If there is no such path, the result is nil.
**/
function _findPath(_objMap:stdgo.GoMap<Object, stdgo.Ref<T_declInfo>>, _from:Object, _to:Object, _seen:stdgo.GoMap<Object, Bool>):stdgo.Slice<Object> {
        if ((_seen[_from] ?? false)) {
            return (null : stdgo.Slice<stdgo.go.types.Types.Object>);
        };
        _seen[_from] = true;
        for (_d => _ in (_objMap[_from] ?? (null : stdgo.Ref<stdgo.go.types.Types.T_declInfo>))._deps) {
            if (stdgo.Go.toInterface(_d) == (stdgo.Go.toInterface(_to))) {
                return (new stdgo.Slice<stdgo.go.types.Types.Object>(1, 1, _d) : stdgo.Slice<stdgo.go.types.Types.Object>);
            };
            {
                var p = _findPath(_objMap, _d, _to, _seen);
                if (p != null) {
                    return (p.__append__(_d));
                };
            };
        };
        return (null : stdgo.Slice<stdgo.go.types.Types.Object>);
    }
/**
    // dependencyGraph computes the object dependency graph from the given objMap,
    // with any function nodes removed. The resulting graph contains only constants
    // and variables.
**/
function _dependencyGraph(_objMap:stdgo.GoMap<Object, stdgo.Ref<T_declInfo>>):stdgo.Slice<stdgo.Ref<T_graphNode>> {
        var m = ({
            final x = new stdgo.GoMap.GoObjectMap<stdgo.go.types.Types.T_dependency, stdgo.Ref<stdgo.go.types.Types.T_graphNode>>();
            x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.T_dependency", [], stdgo.internal.reflect.Reflect.GoType.named("T_dependency", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
            x.__defaultValue__ = () -> (null : stdgo.Ref<stdgo.go.types.Types.T_graphNode>);
            @:mergeBlock {};
            cast x;
        } : stdgo.GoMap<stdgo.go.types.Types.T_dependency, stdgo.Ref<stdgo.go.types.Types.T_graphNode>>);
        for (_obj => _ in _objMap) {
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : T_dependency)) : T_dependency), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.go.types.Types.T_dependency), _1 : false };
                }, _obj = __tmp__._0, __0 = __tmp__._1;
                if (_obj != null) {
                    m[_obj] = (stdgo.Go.setRef(({ _obj : _obj } : stdgo.go.types.Types.T_graphNode)) : stdgo.Ref<stdgo.go.types.Types.T_graphNode>);
                };
            };
        };
        for (_obj => _n in m) {
            for (_d => _ in (_objMap[_obj] ?? (null : stdgo.Ref<stdgo.go.types.Types.T_declInfo>))._deps) {
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_d) : T_dependency)) : T_dependency), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.go.types.Types.T_dependency), _1 : false };
                    }, _d = __tmp__._0, __1 = __tmp__._1;
                    if (_d != null) {
                        var _d = (m[_d] ?? (null : stdgo.Ref<stdgo.go.types.Types.T_graphNode>));
                        _n._succ._add(_d);
                        _d._pred._add(_n);
                    };
                };
            };
        };
        var __0:stdgo.Slice<stdgo.Ref<T_graphNode>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_graphNode>>), __1:stdgo.Slice<stdgo.Ref<T_graphNode>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_graphNode>>), _funcG:stdgo.Slice<stdgo.Ref<T_graphNode>> = __1, g:stdgo.Slice<stdgo.Ref<T_graphNode>> = __0;
        for (__2 => _n in m) {
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_n._obj) : stdgo.Ref<Func>)) : stdgo.Ref<Func>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Func>), _1 : false };
                }, __3 = __tmp__._0, _ok = __tmp__._1;
                if (_ok) {
                    _funcG = (_funcG.__append__(_n));
                } else {
                    g = (g.__append__(_n));
                };
            };
        };
        stdgo.sort.Sort.slice(stdgo.Go.toInterface(_funcG), function(_i:stdgo.GoInt, _j:stdgo.GoInt):Bool {
            return _funcG[(_i : stdgo.GoInt)]._cost() < _funcG[(_j : stdgo.GoInt)]._cost();
        });
        for (__4 => _n in _funcG) {
            for (_p => _ in _n._pred) {
                if (_p != (_n)) {
                    for (_s => _ in _n._succ) {
                        if (_s != (_n)) {
                            _p._succ._add(_s);
                            _s._pred._add(_p);
                        };
                    };
                    if (_p._succ != null) _p._succ.remove(_n);
                };
            };
            for (_s => _ in _n._succ) {
                if (_s._pred != null) _s._pred.remove(_n);
            };
        };
        for (_i => _n in g) {
            _n._index = _i;
            _n._ndeps = (_n._succ.length);
        };
        return g;
    }
/**
    // Instantiate instantiates the type orig with the given type arguments targs.
    // orig must be a *Named or a *Signature type. If there is no error, the
    // resulting Type is an instantiated type of the same kind (either a *Named or
    // a *Signature). Methods attached to a *Named type are also instantiated, and
    // associated with a new *Func that has the same position as the original
    // method, but nil function scope.
    //
    // If ctxt is non-nil, it may be used to de-duplicate the instance against
    // previous instances with the same identity. As a special case, generic
    // *Signature origin types are only considered identical if they are pointer
    // equivalent, so that instantiating distinct (but possibly identical)
    // signatures will yield different instances. The use of a shared context does
    // not guarantee that identical instances are deduplicated in all cases.
    //
    // If validate is set, Instantiate verifies that the number of type arguments
    // and parameters match, and that the type arguments satisfy their
    // corresponding type constraints. If verification fails, the resulting error
    // may wrap an *ArgumentError indicating which type argument did not satisfy
    // its corresponding type parameter constraint, and why.
    //
    // If validate is not set, Instantiate does not verify the type argument count
    // or whether the type arguments satisfy their constraints. Instantiate is
    // guaranteed to not return an error, but may panic. Specifically, for
    // *Signature types, Instantiate will panic immediately if the type argument
    // count is incorrect; for *Named types, a panic may occur later inside the
    // *Named API.
**/
function instantiate(_ctxt:stdgo.Ref<Context>, _orig:Type_, _targs:stdgo.Slice<Type_>, _validate:Bool):{ var _0 : Type_; var _1 : stdgo.Error; } {
        if (_ctxt == null || (_ctxt : Dynamic).__nil__) {
            _ctxt = newContext();
        };
        if (_validate) {
            var _tparams:stdgo.Slice<stdgo.Ref<TypeParam>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>);
            {
                final __type__ = _orig;
                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Named>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                    _tparams = _t._check._environment._decl._tdecl.typeParams()._list();
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Signature>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Signature> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__().value;
                    _tparams = _t.typeParams()._list();
                };
            };
            if ((_targs.length) != ((_tparams.length))) {
                return { _0 : (null : stdgo.go.types.Types.Type_), _1 : stdgo.fmt.Fmt.errorf(("got %d type arguments but %s has %d type parameters" : stdgo.GoString), stdgo.Go.toInterface((_targs.length)), stdgo.Go.toInterface(_orig), stdgo.Go.toInterface((_tparams.length))) };
            };
            {
                var __tmp__ = ((null : stdgo.Ref<stdgo.go.types.Types.Checker>) : stdgo.Ref<Checker>)._verify(_nopos, _tparams, _targs, _ctxt), _i:stdgo.GoInt = __tmp__._0, _err:stdgo.Error = __tmp__._1;
                if (_err != null) {
                    return { _0 : (null : stdgo.go.types.Types.Type_), _1 : stdgo.Go.asInterface((stdgo.Go.setRef((new stdgo.go.types.Types.ArgumentError(_i, _err) : stdgo.go.types.Types.ArgumentError)) : stdgo.Ref<stdgo.go.types.Types.ArgumentError>)) };
                };
            };
        };
        var _inst:stdgo.go.types.Types.Type_ = ((null : stdgo.Ref<stdgo.go.types.Types.Checker>) : stdgo.Ref<Checker>)._instance(_nopos, _orig, _targs, null, _ctxt);
        return { _0 : _inst, _1 : (null : stdgo.Error) };
    }
/**
    // mentions reports whether type T "mentions" typ in an (embedded) element or term
    // of T (whether typ is in the type set of T or not). For better error messages.
**/
function _mentions(t:Type_, _typ:Type_):Bool {
        {
            final __type__ = t;
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                var t:stdgo.Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                for (__8 => _e in t._embeddeds) {
                    if (_mentions(_e, _typ)) {
                        return true;
                    };
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Union>))) {
                var t:stdgo.Ref<stdgo.go.types.Types.Union> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Union>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__().value;
                for (__9 => _t in t._terms) {
                    if (_mentions(_t._typ, _typ)) {
                        return true;
                    };
                };
            } else {
                var t:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                if (identical(t, _typ)) {
                    return true;
                };
            };
        };
        return false;
    }
/**
    // NewInterface returns a new interface for the given methods and embedded types.
    // NewInterface takes ownership of the provided methods and may modify their types
    // by setting missing receivers.
    //
    // Deprecated: Use NewInterfaceType instead which allows arbitrary embedded types.
**/
function newInterface(_methods:stdgo.Slice<stdgo.Ref<Func>>, _embeddeds:stdgo.Slice<stdgo.Ref<Named>>):stdgo.Ref<Interface> {
        var _tnames = new stdgo.Slice<stdgo.go.types.Types.Type_>((_embeddeds.length : stdgo.GoInt).toBasic(), 0);
        for (_i => _t in _embeddeds) {
            _tnames[(_i : stdgo.GoInt)] = stdgo.Go.asInterface(_t);
        };
        return newInterfaceType(_methods, _tnames);
    }
/**
    // NewInterfaceType returns a new interface for the given methods and embedded
    // types. NewInterfaceType takes ownership of the provided methods and may
    // modify their types by setting missing receivers.
    //
    // To avoid race conditions, the interface's type set should be computed before
    // concurrent use of the interface, by explicitly calling Complete.
**/
function newInterfaceType(_methods:stdgo.Slice<stdgo.Ref<Func>>, _embeddeds:stdgo.Slice<Type_>):stdgo.Ref<Interface> {
        if ((_methods.length == (0 : stdgo.GoInt)) && (_embeddeds.length == (0 : stdgo.GoInt))) {
            return (stdgo.Go.setRef(_emptyInterface) : stdgo.Ref<stdgo.go.types.Types.Interface>);
        };
        var _typ = ((null : stdgo.Ref<stdgo.go.types.Types.Checker>) : stdgo.Ref<Checker>)._newInterface();
        for (__8 => _m in _methods) {
            {
                var _sig = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_m._object._typ) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>);
                if (_sig._recv == null || (_sig._recv : Dynamic).__nil__) {
                    _sig._recv = newVar(_m._object._pos, _m._object._pkg, stdgo.Go.str()?.__copy__(), stdgo.Go.asInterface(_typ));
                };
            };
        };
        _sortMethods(_methods);
        _typ._methods = _methods;
        _typ._embeddeds = _embeddeds;
        _typ._complete = true;
        return _typ;
    }
/**
    // LookupFieldOrMethod looks up a field or method with given package and name
    // in T and returns the corresponding *Var or *Func, an index sequence, and a
    // bool indicating if there were any pointer indirections on the path to the
    // field or method. If addressable is set, T is the type of an addressable
    // variable (only matters for method lookups). T must not be nil.
    //
    // The last index entry is the field or method index in the (possibly embedded)
    // type where the entry was found, either:
    //
    //  1. the list of declared methods of a named type; or
    //  2. the list of all methods (method set) of an interface type; or
    //  3. the list of fields of a struct type.
    //
    // The earlier index entries are the indices of the embedded struct fields
    // traversed to get to the found entry, starting at depth 0.
    //
    // If no entry is found, a nil object is returned. In this case, the returned
    // index and indirect values have the following meaning:
    //
    //   - If index != nil, the index sequence points to an ambiguous entry
    //     (the same name appeared more than once at the same embedding level).
    //
    //   - If indirect is set, a method with a pointer receiver type was found
    //     but there was no pointer on the path from the actual receiver type to
    //     the method's formal receiver base type, nor was the receiver addressable.
**/
function lookupFieldOrMethod(t:Type_, _addressable:Bool, _pkg:stdgo.Ref<Package>, _name:stdgo.GoString):{ var _0 : Object; var _1 : stdgo.Slice<stdgo.GoInt>; var _2 : Bool; } {
        var _obj:Object = (null : stdgo.go.types.Types.Object), _index:stdgo.Slice<stdgo.GoInt> = (null : stdgo.Slice<stdgo.GoInt>), _indirect:Bool = false;
        if (t == null) {
            throw stdgo.Go.toInterface(("LookupFieldOrMethod on nil type" : stdgo.GoString));
        };
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(t) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
            }, _t = __tmp__._0, __0 = __tmp__._1;
            if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_t.underlying()) : stdgo.Ref<Pointer_>)) : stdgo.Ref<Pointer_>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>), _1 : false };
                    }, _p = __tmp__._0, __9 = __tmp__._1;
                    if (_p != null && ((_p : Dynamic).__nil__ == null || !(_p : Dynamic).__nil__)) {
                        {
                            var __tmp__ = _lookupFieldOrMethodImpl(stdgo.Go.asInterface(_p), false, _pkg, _name?.__copy__(), false);
                            _obj = __tmp__._0;
                            _index = __tmp__._1;
                            _indirect = __tmp__._2;
                        };
                        {
                            var __tmp__ = try {
                                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<Func>)) : stdgo.Ref<Func>), _1 : true };
                            } catch(_) {
                                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Func>), _1 : false };
                            }, __10 = __tmp__._0, _ok = __tmp__._1;
                            if (_ok) {
                                return { _0 : (null : stdgo.go.types.Types.Object), _1 : (null : stdgo.Slice<stdgo.GoInt>), _2 : false };
                            };
                        };
                        return { _0 : _obj, _1 : _index, _2 : _indirect };
                    };
                };
            };
        };
        {
            var __tmp__ = _lookupFieldOrMethodImpl(t, _addressable, _pkg, _name?.__copy__(), false);
            _obj = __tmp__._0;
            _index = __tmp__._1;
            _indirect = __tmp__._2;
        };
        {};
        if ((false && (_obj == null)) && _isTypeParam(t)) {
            {
                var _t:stdgo.go.types.Types.Type_ = _coreType(t);
                if (_t != null) {
                    {
                        var __tmp__ = _lookupFieldOrMethodImpl(_t, _addressable, _pkg, _name?.__copy__(), false);
                        _obj = __tmp__._0;
                        _index = __tmp__._1;
                        _indirect = __tmp__._2;
                    };
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<Var>)) : stdgo.Ref<Var>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Var>), _1 : false };
                        }, __11 = __tmp__._0, _ok = __tmp__._1;
                        if (!_ok) {
                            {
                                final __tmp__0 = (null : stdgo.go.types.Types.Object);
                                final __tmp__1 = (null : stdgo.Slice<stdgo.GoInt>);
                                final __tmp__2 = false;
                                _obj = __tmp__0;
                                _index = __tmp__1;
                                _indirect = __tmp__2;
                            };
                        };
                    };
                };
            };
        };
        return { _0 : _obj, _1 : _index, _2 : _indirect };
    }
/**
    // lookupFieldOrMethodImpl is the implementation of LookupFieldOrMethod.
    // Notably, in contrast to LookupFieldOrMethod, it won't find struct fields
    // in base types of defined (*Named) pointer types T. For instance, given
    // the declaration:
    //
    //	type T *struct{f int}
    //
    // lookupFieldOrMethodImpl won't find the field f in the defined (*Named) type T
    // (methods on T are not permitted in the first place).
    //
    // Thus, lookupFieldOrMethodImpl should only be called by LookupFieldOrMethod
    // and missingMethod (the latter doesn't care about struct fields).
    //
    // If foldCase is true, method names are considered equal if they are equal
    // with case folding.
    //
    // The resulting object may not be fully type-checked.
**/
function _lookupFieldOrMethodImpl(t:Type_, _addressable:Bool, _pkg:stdgo.Ref<Package>, _name:stdgo.GoString, _foldCase:Bool):{ var _0 : Object; var _1 : stdgo.Slice<stdgo.GoInt>; var _2 : Bool; } {
        var _obj:Object = (null : stdgo.go.types.Types.Object), _index:stdgo.Slice<stdgo.GoInt> = (null : stdgo.Slice<stdgo.GoInt>), _indirect:Bool = false;
        if (_name == (("_" : stdgo.GoString))) {
            return { _0 : _obj, _1 : _index, _2 : _indirect };
        };
        var __tmp__ = _deref(t), _typ:stdgo.go.types.Types.Type_ = __tmp__._0, _isPtr:Bool = __tmp__._1;
        if (_isPtr) {
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_typ)) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Interface>), _1 : false };
                }, __0 = __tmp__._0, _ok = __tmp__._1;
                if (_ok) {
                    return { _0 : _obj, _1 : _index, _2 : _indirect };
                };
            };
        };
        var _current = (new stdgo.Slice<stdgo.go.types.Types.T_embeddedType>(1, 1, (new stdgo.go.types.Types.T_embeddedType(_typ, (null : stdgo.Slice<stdgo.GoInt>), _isPtr, false) : stdgo.go.types.Types.T_embeddedType)) : stdgo.Slice<stdgo.go.types.Types.T_embeddedType>);
        var _seen:T_instanceLookup = ({} : stdgo.go.types.Types.T_instanceLookup);
        while ((_current.length) > (0 : stdgo.GoInt)) {
            var _next:stdgo.Slice<T_embeddedType> = (null : stdgo.Slice<stdgo.go.types.Types.T_embeddedType>);
            for (__1 => _e in _current) {
                var _typ:stdgo.go.types.Types.Type_ = _e._typ;
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_typ) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
                    }, _named = __tmp__._0, __2 = __tmp__._1;
                    if (_named != null && ((_named : Dynamic).__nil__ == null || !(_named : Dynamic).__nil__)) {
                        {
                            var _alt = _seen._lookup(_named);
                            if (_alt != null && ((_alt : Dynamic).__nil__ == null || !(_alt : Dynamic).__nil__)) {
                                continue;
                            };
                        };
                        _seen._add(_named);
                        {
                            var __tmp__ = _named._lookupMethod(_pkg, _name?.__copy__(), _foldCase), _i:stdgo.GoInt = __tmp__._0, _m:stdgo.Ref<stdgo.go.types.Types.Func> = __tmp__._1;
                            if (_m != null && ((_m : Dynamic).__nil__ == null || !(_m : Dynamic).__nil__)) {
                                _index = _concat(_e._index, _i);
                                if ((_obj != null) || _e._multiples) {
                                    return { _0 : (null : stdgo.go.types.Types.Object), _1 : _index, _2 : false };
                                };
                                _obj = stdgo.Go.asInterface(_m);
                                _indirect = _e._indirect;
                                continue;
                            };
                        };
                    };
                };
                {
                    final __type__ = _under(_typ);
                    if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Struct>))) {
                        var _t:stdgo.Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                        for (_i => _f in _t._fields) {
                            if (_f._sameId(_pkg, _name?.__copy__())) {
                                _assert(_f._object._typ != null);
                                _index = _concat(_e._index, _i);
                                if ((_obj != null) || _e._multiples) {
                                    return { _0 : (null : stdgo.go.types.Types.Object), _1 : _index, _2 : false };
                                };
                                _obj = stdgo.Go.asInterface(_f);
                                _indirect = _e._indirect;
                                continue;
                            };
                            if ((_obj == null) && _f._embedded) {
                                var __tmp__ = _deref(_f._object._typ), _typ:stdgo.go.types.Types.Type_ = __tmp__._0, _isPtr:Bool = __tmp__._1;
                                _next = (_next.__append__((new stdgo.go.types.Types.T_embeddedType(_typ, _concat(_e._index, _i), _e._indirect || _isPtr, _e._multiples) : stdgo.go.types.Types.T_embeddedType)));
                            };
                        };
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                        var _t:stdgo.Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                        {
                            var __tmp__ = _t._typeSet().lookupMethod(_pkg, _name?.__copy__(), _foldCase), _i:stdgo.GoInt = __tmp__._0, _m:stdgo.Ref<stdgo.go.types.Types.Func> = __tmp__._1;
                            if (_m != null && ((_m : Dynamic).__nil__ == null || !(_m : Dynamic).__nil__)) {
                                _assert(_m._object._typ != null);
                                _index = _concat(_e._index, _i);
                                if ((_obj != null) || _e._multiples) {
                                    return { _0 : (null : stdgo.go.types.Types.Object), _1 : _index, _2 : false };
                                };
                                _obj = stdgo.Go.asInterface(_m);
                                _indirect = _e._indirect;
                            };
                        };
                    };
                };
            };
            if (_obj != null) {
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<Func>)) : stdgo.Ref<Func>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Func>), _1 : false };
                    }, _f = __tmp__._0, __19 = __tmp__._1;
                    if (_f != null && ((_f : Dynamic).__nil__ == null || !(_f : Dynamic).__nil__)) {
                        if ((_f._hasPtrRecv() && !_indirect) && !_addressable) {
                            return { _0 : (null : stdgo.go.types.Types.Object), _1 : (null : stdgo.Slice<stdgo.GoInt>), _2 : true };
                        };
                    };
                };
                return { _0 : _obj, _1 : _index, _2 : _indirect };
            };
            _current = _consolidateMultiples(_next);
        };
        return { _0 : (null : stdgo.go.types.Types.Object), _1 : (null : stdgo.Slice<stdgo.GoInt>), _2 : false };
    }
/**
    // consolidateMultiples collects multiple list entries with the same type
    // into a single entry marked as containing multiples. The result is the
    // consolidated list.
**/
function _consolidateMultiples(_list:stdgo.Slice<T_embeddedType>):stdgo.Slice<T_embeddedType> {
        if ((_list.length) <= (1 : stdgo.GoInt)) {
            return _list;
        };
        var _n:stdgo.GoInt = (0 : stdgo.GoInt);
        var _prev = ({
            final x = new stdgo.GoMap.GoObjectMap<stdgo.go.types.Types.Type_, stdgo.GoInt>();
            x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Type_", [], stdgo.internal.reflect.Reflect.GoType.named("Type_", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
            x.__defaultValue__ = () -> (0 : stdgo.GoInt);
            @:mergeBlock {};
            cast x;
        } : stdgo.GoMap<stdgo.go.types.Types.Type_, stdgo.GoInt>);
        for (__0 => _e in _list) {
            {
                var __tmp__ = _lookupType(_prev, _e._typ), _i:stdgo.GoInt = __tmp__._0, _found:Bool = __tmp__._1;
                if (_found) {
                    _list[(_i : stdgo.GoInt)]._multiples = true;
                } else {
                    _prev[_e._typ] = _n;
                    _list[(_n : stdgo.GoInt)] = _e?.__copy__();
                    _n++;
                };
            };
        };
        return (_list.__slice__(0, _n) : stdgo.Slice<stdgo.go.types.Types.T_embeddedType>);
    }
function _lookupType(_m:stdgo.GoMap<Type_, stdgo.GoInt>, _typ:Type_):{ var _0 : stdgo.GoInt; var _1 : Bool; } {
        {
            var __tmp__ = (_m != null && _m.exists(_typ) ? { _0 : _m[_typ], _1 : true } : { _0 : (0 : stdgo.GoInt), _1 : false }), _i:stdgo.GoInt = __tmp__._0, _found:Bool = __tmp__._1;
            if (_found) {
                return { _0 : _i, _1 : true };
            };
        };
        for (_t => _i in _m) {
            if (identical(_t, _typ)) {
                return { _0 : _i, _1 : true };
            };
        };
        return { _0 : (0 : stdgo.GoInt), _1 : false };
    }
/**
    // MissingMethod returns (nil, false) if V implements T, otherwise it
    // returns a missing method required by T and whether it is missing or
    // just has the wrong type: either a pointer receiver or wrong signature.
    //
    // For non-interface types V, or if static is set, V implements T if all
    // methods of T are present in V. Otherwise (V is an interface and static
    // is not set), MissingMethod only checks that methods of T which are also
    // present in V have matching types (e.g., for a type assertion x.(T) where
    // x is of interface type V).
**/
function missingMethod(v:Type_, t:stdgo.Ref<Interface>, _static:Bool):{ var _0 : stdgo.Ref<Func>; var _1 : Bool; } {
        var _method:stdgo.Ref<Func> = (null : stdgo.Ref<stdgo.go.types.Types.Func>), _wrongType:Bool = false;
        return ((null : stdgo.Ref<stdgo.go.types.Types.Checker>) : stdgo.Ref<Checker>)._missingMethod(v, stdgo.Go.asInterface(t), _static, identical, (null : stdgo.Pointer<stdgo.GoString>));
    }
function _isInterfacePtr(t:Type_):Bool {
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(t)) : stdgo.Ref<Pointer_>)) : stdgo.Ref<Pointer_>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>), _1 : false };
        }, _p = __tmp__._0, __0 = __tmp__._1;
        return ((_p != null) && ((_p : Dynamic).__nil__ == null || !(_p : Dynamic).__nil__)) && isInterface(_p._base);
    }
/**
    // deref dereferences typ if it is a *Pointer (but not a *Named type
    // with an underlying pointer type!) and returns its base and true.
    // Otherwise it returns (typ, false).
**/
function _deref(_typ:Type_):{ var _0 : Type_; var _1 : Bool; } {
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_typ) : stdgo.Ref<Pointer_>)) : stdgo.Ref<Pointer_>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>), _1 : false };
            }, _p = __tmp__._0, __0 = __tmp__._1;
            if (_p != null && ((_p : Dynamic).__nil__ == null || !(_p : Dynamic).__nil__)) {
                if (_p._base == null) {
                    if (false) {
                        throw stdgo.Go.toInterface(("pointer with nil base type (possibly due to an invalid cyclic declaration)" : stdgo.GoString));
                    };
                    return { _0 : stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]), _1 : true };
                };
                return { _0 : _p._base, _1 : true };
            };
        };
        return { _0 : _typ, _1 : false };
    }
/**
    // derefStructPtr dereferences typ if it is a (named or unnamed) pointer to a
    // (named or unnamed) struct and returns its base. Otherwise it returns typ.
**/
function _derefStructPtr(_typ:Type_):Type_ {
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_typ)) : stdgo.Ref<Pointer_>)) : stdgo.Ref<Pointer_>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>), _1 : false };
            }, _p = __tmp__._0, __0 = __tmp__._1;
            if (_p != null && ((_p : Dynamic).__nil__ == null || !(_p : Dynamic).__nil__)) {
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_p._base)) : stdgo.Ref<Struct>)) : stdgo.Ref<Struct>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Struct>), _1 : false };
                    }, __1 = __tmp__._0, _ok = __tmp__._1;
                    if (_ok) {
                        return _p._base;
                    };
                };
            };
        };
        return _typ;
    }
/**
    // concat returns the result of concatenating list and i.
    // The result does not share its underlying array with list.
**/
function _concat(_list:stdgo.Slice<stdgo.GoInt>, _i:stdgo.GoInt):stdgo.Slice<stdgo.GoInt> {
        var _t:stdgo.Slice<stdgo.GoInt> = (null : stdgo.Slice<stdgo.GoInt>);
        _t = (_t.__append__(..._list.__toArray__()));
        return (_t.__append__(_i));
    }
/**
    // fieldIndex returns the index for the field with matching package and name, or a value < 0.
**/
function _fieldIndex(_fields:stdgo.Slice<stdgo.Ref<Var>>, _pkg:stdgo.Ref<Package>, _name:stdgo.GoString):stdgo.GoInt {
        if (_name != (("_" : stdgo.GoString))) {
            for (_i => _f in _fields) {
                if (_f._sameId(_pkg, _name?.__copy__())) {
                    return _i;
                };
            };
        };
        return (-1 : stdgo.GoInt);
    }
/**
    // lookupMethod returns the index of and method with matching package and name, or (-1, nil).
    // If foldCase is true, method names are considered equal if they are equal with case folding.
**/
function _lookupMethod(_methods:stdgo.Slice<stdgo.Ref<Func>>, _pkg:stdgo.Ref<Package>, _name:stdgo.GoString, _foldCase:Bool):{ var _0 : stdgo.GoInt; var _1 : stdgo.Ref<Func>; } {
        if (_name != (("_" : stdgo.GoString))) {
            for (_i => _m in _methods) {
                if (((_m._object._name == _name) || (_foldCase && stdgo.strings.Strings.equalFold(_m._object._name?.__copy__(), _name?.__copy__()))) && _m._sameId(_pkg, _m._object._name?.__copy__())) {
                    return { _0 : _i, _1 : _m };
                };
            };
        };
        return { _0 : (-1 : stdgo.GoInt), _1 : null };
    }
/**
    // NewMap returns a new map for the given key and element types.
**/
function newMap(_key:Type_, _elem:Type_):stdgo.Ref<Map_> {
        return (stdgo.Go.setRef(({ _key : _key, _elem : _elem } : stdgo.go.types.Types.Map_)) : stdgo.Ref<stdgo.go.types.Types.Map_>);
    }
/**
    // NewMethodSet returns the method set for the given type T.
    // It always returns a non-nil method set, even if it is empty.
**/
function newMethodSet(t:Type_):stdgo.Ref<MethodSet> {
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(t) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
            }, _t = __tmp__._0, __0 = __tmp__._1;
            if (((_t != null) && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) && _isPointer(stdgo.Go.asInterface(_t))) {
                return (stdgo.Go.setRef(_emptyMethodSet) : stdgo.Ref<stdgo.go.types.Types.MethodSet>);
            };
        };
        var _base:T_methodSet = (null : stdgo.go.types.Types.T_methodSet);
        var __tmp__ = _deref(t), _typ:stdgo.go.types.Types.Type_ = __tmp__._0, _isPtr:Bool = __tmp__._1;
        if (_isPtr && isInterface(_typ)) {
            return (stdgo.Go.setRef(_emptyMethodSet) : stdgo.Ref<stdgo.go.types.Types.MethodSet>);
        };
        var _current = (new stdgo.Slice<stdgo.go.types.Types.T_embeddedType>(1, 1, (new stdgo.go.types.Types.T_embeddedType(_typ, (null : stdgo.Slice<stdgo.GoInt>), _isPtr, false) : stdgo.go.types.Types.T_embeddedType)) : stdgo.Slice<stdgo.go.types.Types.T_embeddedType>);
        var _seen:T_instanceLookup = ({} : stdgo.go.types.Types.T_instanceLookup);
        while ((_current.length) > (0 : stdgo.GoInt)) {
            var _next:stdgo.Slice<T_embeddedType> = (null : stdgo.Slice<stdgo.go.types.Types.T_embeddedType>);
            var _fset:stdgo.GoMap<stdgo.GoString, Bool> = (null : stdgo.GoMap<stdgo.GoString, Bool>);
            var _mset:T_methodSet = (null : stdgo.go.types.Types.T_methodSet);
            for (__1 => _e in _current) {
                var _typ:stdgo.go.types.Types.Type_ = _e._typ;
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_typ) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
                    }, _named = __tmp__._0, __2 = __tmp__._1;
                    if (_named != null && ((_named : Dynamic).__nil__ == null || !(_named : Dynamic).__nil__)) {
                        {
                            var _alt = _seen._lookup(_named);
                            if (_alt != null && ((_alt : Dynamic).__nil__ == null || !(_alt : Dynamic).__nil__)) {
                                continue;
                            };
                        };
                        _seen._add(_named);
                        {
                            var _i:stdgo.GoInt = (0 : stdgo.GoInt);
                            stdgo.Go.cfor(_i < _named.numMethods(), _i++, {
                                _mset = _mset._addOne(_named.method(_i), _concat(_e._index, _i), _e._indirect, _e._multiples);
                            });
                        };
                    };
                };
                {
                    final __type__ = _under(_typ);
                    if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Struct>))) {
                        var _t:stdgo.Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                        for (_i => _f in _t._fields) {
                            if (_fset == null) {
                                _fset = ({
                                    final x = new stdgo.GoMap.GoStringMap<Bool>();
                                    x.__defaultValue__ = () -> false;
                                    @:mergeBlock {};
                                    x;
                                } : stdgo.GoMap<stdgo.GoString, Bool>);
                            };
                            _fset[_f.id()] = true;
                            if (_f._embedded) {
                                var __tmp__ = _deref(_f._object._typ), _typ:stdgo.go.types.Types.Type_ = __tmp__._0, _isPtr:Bool = __tmp__._1;
                                _next = (_next.__append__((new stdgo.go.types.Types.T_embeddedType(_typ, _concat(_e._index, _i), _e._indirect || _isPtr, _e._multiples) : stdgo.go.types.Types.T_embeddedType)));
                            };
                        };
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                        var _t:stdgo.Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                        _mset = _mset._add(_t._typeSet()._methods, _e._index, true, _e._multiples);
                    };
                };
            };
            for (_k => _m in _mset) {
                {
                    var __tmp__ = (_base != null && _base.exists(_k?.__copy__()) ? { _0 : _base[_k?.__copy__()], _1 : true } : { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Selection>), _1 : false }), __27:stdgo.Ref<stdgo.go.types.Types.Selection> = __tmp__._0, _found:Bool = __tmp__._1;
                    if (!_found) {
                        if ((_fset[_k] ?? false)) {
                            _m = null;
                        };
                        if (_base == null) {
                            _base = ({
                                final x = new stdgo.GoMap.GoStringMap<stdgo.Ref<stdgo.go.types.Types.Selection>>();
                                x.__defaultValue__ = () -> (null : stdgo.Ref<stdgo.go.types.Types.Selection>);
                                @:mergeBlock {};
                                x;
                            } : stdgo.GoMap<stdgo.GoString, stdgo.Ref<stdgo.go.types.Types.Selection>>);
                        };
                        _base[_k] = _m;
                    };
                };
            };
            for (_k => _ in _fset) {
                {
                    var __tmp__ = (_base != null && _base.exists(_k?.__copy__()) ? { _0 : _base[_k?.__copy__()], _1 : true } : { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Selection>), _1 : false }), __28:stdgo.Ref<stdgo.go.types.Types.Selection> = __tmp__._0, _found:Bool = __tmp__._1;
                    if (!_found) {
                        if (_base == null) {
                            _base = ({
                                final x = new stdgo.GoMap.GoStringMap<stdgo.Ref<stdgo.go.types.Types.Selection>>();
                                x.__defaultValue__ = () -> (null : stdgo.Ref<stdgo.go.types.Types.Selection>);
                                @:mergeBlock {};
                                x;
                            } : stdgo.GoMap<stdgo.GoString, stdgo.Ref<stdgo.go.types.Types.Selection>>);
                        };
                        _base[_k] = null;
                    };
                };
            };
            _current = _consolidateMultiples(_next);
        };
        if ((_base.length) == ((0 : stdgo.GoInt))) {
            return (stdgo.Go.setRef(_emptyMethodSet) : stdgo.Ref<stdgo.go.types.Types.MethodSet>);
        };
        var _list:stdgo.Slice<stdgo.Ref<Selection>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Selection>>);
        for (__29 => _m in _base) {
            if (_m != null && ((_m : Dynamic).__nil__ == null || !(_m : Dynamic).__nil__)) {
                _m._recv = t;
                _list = (_list.__append__(_m));
            };
        };
        stdgo.sort.Sort.slice(stdgo.Go.toInterface(_list), function(_i:stdgo.GoInt, _j:stdgo.GoInt):Bool {
            return _list[(_i : stdgo.GoInt)]._obj.id() < _list[(_j : stdgo.GoInt)]._obj.id();
        });
        return (stdgo.Go.setRef((new stdgo.go.types.Types.MethodSet(_list) : stdgo.go.types.Types.MethodSet)) : stdgo.Ref<stdgo.go.types.Types.MethodSet>);
    }
/**
    // NewNamed returns a new named type for the given type name, underlying type, and associated methods.
    // If the given type name obj doesn't have a type yet, its type is set to the returned named type.
    // The underlying type must not be a *Named.
**/
function newNamed(_obj:stdgo.Ref<TypeName>, _underlying:Type_, _methods:stdgo.Slice<stdgo.Ref<Func>>):stdgo.Ref<Named> {
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_underlying) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
            }, __0 = __tmp__._0, _ok = __tmp__._1;
            if (_ok) {
                throw stdgo.Go.toInterface(("underlying type must not be *Named" : stdgo.GoString));
            };
        };
        return ((null : stdgo.Ref<stdgo.go.types.Types.Checker>) : stdgo.Ref<Checker>)._newNamed(_obj, _underlying, _methods);
    }
/**
    // safeUnderlying returns the underlying type of typ without expanding
    // instances, to avoid infinite recursion.
    //
    // TODO(rfindley): eliminate this function or give it a better name.
**/
function _safeUnderlying(_typ:Type_):Type_ {
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_typ) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
            }, _t = __tmp__._0, __0 = __tmp__._1;
            if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                return _t._underlying;
            };
        };
        return _typ.underlying();
    }
function _isExported(_name:stdgo.GoString):Bool {
        var __tmp__ = stdgo.unicode.utf8.Utf8.decodeRuneInString(_name?.__copy__()), _ch:stdgo.GoInt32 = __tmp__._0, __0:stdgo.GoInt = __tmp__._1;
        return stdgo.unicode.Unicode.isUpper(_ch);
    }
/**
    // Id returns name if it is exported, otherwise it
    // returns the name qualified with the package path.
**/
function id(_pkg:stdgo.Ref<Package>, _name:stdgo.GoString):stdgo.GoString {
        if (_isExported(_name?.__copy__())) {
            return _name?.__copy__();
        };
        var _path:stdgo.GoString = ("_" : stdgo.GoString);
        if (((_pkg != null) && ((_pkg : Dynamic).__nil__ == null || !(_pkg : Dynamic).__nil__)) && (_pkg._path != stdgo.Go.str())) {
            _path = _pkg._path?.__copy__();
        };
        return _path + ("." : stdgo.GoString)?.__copy__() + _name?.__copy__()?.__copy__();
    }
/**
    // colorFor returns the (initial) color for an object depending on
    // whether its type t is known or not.
**/
function _colorFor(_t:Type_):T_color {
        if (_t != null) {
            return (1u32 : stdgo.go.types.Types.T_color);
        };
        return (0u32 : stdgo.go.types.Types.T_color);
    }
/**
    // NewPkgName returns a new PkgName object representing an imported package.
    // The remaining arguments set the attributes found with all Objects.
**/
function newPkgName(_pos:stdgo.go.token.Token.Pos, _pkg:stdgo.Ref<Package>, _name:stdgo.GoString, _imported:stdgo.Ref<Package>):stdgo.Ref<PkgName> {
        return (stdgo.Go.setRef((new stdgo.go.types.Types.PkgName((new stdgo.go.types.Types.T_object(null, _pos, _pkg, _name?.__copy__(), stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]), (0u32 : stdgo.GoUInt32), (1u32 : stdgo.go.types.Types.T_color), _nopos) : stdgo.go.types.Types.T_object), _imported, false) : stdgo.go.types.Types.PkgName)) : stdgo.Ref<stdgo.go.types.Types.PkgName>);
    }
/**
    // NewConst returns a new constant with value val.
    // The remaining arguments set the attributes found with all Objects.
**/
function newConst(_pos:stdgo.go.token.Token.Pos, _pkg:stdgo.Ref<Package>, _name:stdgo.GoString, _typ:Type_, _val:stdgo.go.constant.Constant.Value):stdgo.Ref<Const> {
        return (stdgo.Go.setRef((new stdgo.go.types.Types.Const((new stdgo.go.types.Types.T_object(null, _pos, _pkg, _name?.__copy__(), _typ, (0u32 : stdgo.GoUInt32), _colorFor(_typ), _nopos) : stdgo.go.types.Types.T_object), _val) : stdgo.go.types.Types.Const)) : stdgo.Ref<stdgo.go.types.Types.Const>);
    }
/**
    // NewTypeName returns a new type name denoting the given typ.
    // The remaining arguments set the attributes found with all Objects.
    //
    // The typ argument may be a defined (Named) type or an alias type.
    // It may also be nil such that the returned TypeName can be used as
    // argument for NewNamed, which will set the TypeName's type as a side-
    // effect.
**/
function newTypeName(_pos:stdgo.go.token.Token.Pos, _pkg:stdgo.Ref<Package>, _name:stdgo.GoString, _typ:Type_):stdgo.Ref<TypeName> {
        return (stdgo.Go.setRef((new stdgo.go.types.Types.TypeName((new stdgo.go.types.Types.T_object(null, _pos, _pkg, _name?.__copy__(), _typ, (0u32 : stdgo.GoUInt32), _colorFor(_typ), _nopos) : stdgo.go.types.Types.T_object)) : stdgo.go.types.Types.TypeName)) : stdgo.Ref<stdgo.go.types.Types.TypeName>);
    }
/**
    // NewTypeNameLazy returns a new defined type like NewTypeName, but it
    // lazily calls resolve to finish constructing the Named object.
**/
function __NewTypeNameLazy(_pos:stdgo.go.token.Token.Pos, _pkg:stdgo.Ref<Package>, _name:stdgo.GoString, _load:(_named:stdgo.Ref<Named>) -> { var _0 : stdgo.Slice<stdgo.Ref<TypeParam>>; var _1 : Type_; var _2 : stdgo.Slice<stdgo.Ref<Func>>; }):stdgo.Ref<TypeName> {
        var _obj = newTypeName(_pos, _pkg, _name?.__copy__(), (null : stdgo.go.types.Types.Type_));
        newNamed(_obj, (null : stdgo.go.types.Types.Type_), (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>))._loader = _load;
        return _obj;
    }
/**
    // NewVar returns a new variable.
    // The arguments set the attributes found with all Objects.
**/
function newVar(_pos:stdgo.go.token.Token.Pos, _pkg:stdgo.Ref<Package>, _name:stdgo.GoString, _typ:Type_):stdgo.Ref<Var> {
        return (stdgo.Go.setRef(({ _object : (new stdgo.go.types.Types.T_object(null, _pos, _pkg, _name?.__copy__(), _typ, (0u32 : stdgo.GoUInt32), _colorFor(_typ), _nopos) : stdgo.go.types.Types.T_object) } : stdgo.go.types.Types.Var)) : stdgo.Ref<stdgo.go.types.Types.Var>);
    }
/**
    // NewParam returns a new variable representing a function parameter.
**/
function newParam(_pos:stdgo.go.token.Token.Pos, _pkg:stdgo.Ref<Package>, _name:stdgo.GoString, _typ:Type_):stdgo.Ref<Var> {
        return (stdgo.Go.setRef(({ _object : (new stdgo.go.types.Types.T_object(null, _pos, _pkg, _name?.__copy__(), _typ, (0u32 : stdgo.GoUInt32), _colorFor(_typ), _nopos) : stdgo.go.types.Types.T_object), _used : true } : stdgo.go.types.Types.Var)) : stdgo.Ref<stdgo.go.types.Types.Var>);
    }
/**
    // NewField returns a new variable representing a struct field.
    // For embedded fields, the name is the unqualified type name
    // under which the field is accessible.
**/
function newField(_pos:stdgo.go.token.Token.Pos, _pkg:stdgo.Ref<Package>, _name:stdgo.GoString, _typ:Type_, _embedded:Bool):stdgo.Ref<Var> {
        return (stdgo.Go.setRef(({ _object : (new stdgo.go.types.Types.T_object(null, _pos, _pkg, _name?.__copy__(), _typ, (0u32 : stdgo.GoUInt32), _colorFor(_typ), _nopos) : stdgo.go.types.Types.T_object), _embedded : _embedded, _isField : true } : stdgo.go.types.Types.Var)) : stdgo.Ref<stdgo.go.types.Types.Var>);
    }
/**
    // NewFunc returns a new function with the given signature, representing
    // the function's type.
**/
function newFunc(_pos:stdgo.go.token.Token.Pos, _pkg:stdgo.Ref<Package>, _name:stdgo.GoString, _sig:stdgo.Ref<Signature>):stdgo.Ref<Func> {
        var _typ:Type_ = (null : stdgo.go.types.Types.Type_);
        if (_sig != null && ((_sig : Dynamic).__nil__ == null || !(_sig : Dynamic).__nil__)) {
            _typ = stdgo.Go.asInterface(_sig);
        };
        return (stdgo.Go.setRef((new stdgo.go.types.Types.Func((new stdgo.go.types.Types.T_object(null, _pos, _pkg, _name?.__copy__(), _typ, (0u32 : stdgo.GoUInt32), _colorFor(_typ), _nopos) : stdgo.go.types.Types.T_object), false, null) : stdgo.go.types.Types.Func)) : stdgo.Ref<stdgo.go.types.Types.Func>);
    }
/**
    // NewLabel returns a new label.
**/
function newLabel(_pos:stdgo.go.token.Token.Pos, _pkg:stdgo.Ref<Package>, _name:stdgo.GoString):stdgo.Ref<Label> {
        return (stdgo.Go.setRef((new stdgo.go.types.Types.Label(({ _pos : _pos, _pkg : _pkg, _name : _name?.__copy__(), _typ : stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]), _color_ : (1u32 : stdgo.go.types.Types.T_color) } : stdgo.go.types.Types.T_object), false) : stdgo.go.types.Types.Label)) : stdgo.Ref<stdgo.go.types.Types.Label>);
    }
function _newBuiltin(_id:T_builtinId):stdgo.Ref<Builtin> {
        return (stdgo.Go.setRef((new stdgo.go.types.Types.Builtin(({ _name : _predeclaredFuncs[(_id : stdgo.GoInt)]._name?.__copy__(), _typ : stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]), _color_ : (1u32 : stdgo.go.types.Types.T_color) } : stdgo.go.types.Types.T_object), _id) : stdgo.go.types.Types.Builtin)) : stdgo.Ref<stdgo.go.types.Types.Builtin>);
    }
function _writeObject(_buf:stdgo.Ref<stdgo.bytes.Bytes.Buffer>, _obj:Object, _qf:Qualifier):Void {
        var _tname:stdgo.Ref<TypeName> = (null : stdgo.Ref<stdgo.go.types.Types.TypeName>);
        var _typ:stdgo.go.types.Types.Type_ = _obj.type();
        {
            final __type__ = _obj;
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<PkgName>))) {
                var _obj:stdgo.Ref<stdgo.go.types.Types.PkgName> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.PkgName>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.PkgName>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.PkgName>) : __type__.__underlying__().value;
                stdgo.fmt.Fmt.fprintf(stdgo.Go.asInterface(_buf), ("package %s" : stdgo.GoString), stdgo.Go.toInterface(_obj.name()));
                {
                    var _path:stdgo.GoString = _obj._imported._path?.__copy__();
                    if ((_path != stdgo.Go.str()) && (_path != _obj._object._name)) {
                        stdgo.fmt.Fmt.fprintf(stdgo.Go.asInterface(_buf), (" (%q)" : stdgo.GoString), stdgo.Go.toInterface(_path));
                    };
                };
                return;
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Const>))) {
                var _obj:stdgo.Ref<stdgo.go.types.Types.Const> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Const>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Const>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Const>) : __type__.__underlying__().value;
                _buf.writeString(("const" : stdgo.GoString));
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeName>))) {
                var _obj:stdgo.Ref<stdgo.go.types.Types.TypeName> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeName>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__().value;
                _tname = _obj;
                _buf.writeString(("type" : stdgo.GoString));
                if (_isTypeParam(_typ)) {
                    _buf.writeString((" parameter" : stdgo.GoString));
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Var>))) {
                var _obj:stdgo.Ref<stdgo.go.types.Types.Var> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Var>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__().value;
                if (_obj._isField) {
                    _buf.writeString(("field" : stdgo.GoString));
                } else {
                    _buf.writeString(("var" : stdgo.GoString));
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Func>))) {
                var _obj:stdgo.Ref<stdgo.go.types.Types.Func> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Func>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__().value;
                _buf.writeString(("func " : stdgo.GoString));
                _writeFuncName(_buf, _obj, _qf);
                if (_typ != null) {
                    writeSignature(_buf, (stdgo.Go.typeAssert((stdgo.Go.toInterface(_typ) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>), _qf);
                };
                return;
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Label>))) {
                var _obj:stdgo.Ref<stdgo.go.types.Types.Label> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Label>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Label>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Label>) : __type__.__underlying__().value;
                _buf.writeString(("label" : stdgo.GoString));
                _typ = (null : stdgo.go.types.Types.Type_);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Builtin>))) {
                var _obj:stdgo.Ref<stdgo.go.types.Types.Builtin> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Builtin>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Builtin>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Builtin>) : __type__.__underlying__().value;
                _buf.writeString(("builtin" : stdgo.GoString));
                _typ = (null : stdgo.go.types.Types.Type_);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Nil>))) {
                var _obj:stdgo.Ref<stdgo.go.types.Types.Nil> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Nil>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Nil>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Nil>) : __type__.__underlying__().value;
                _buf.writeString(("nil" : stdgo.GoString));
                return;
            } else {
                var _obj:stdgo.go.types.Types.Object = __type__ == null ? (null : stdgo.go.types.Types.Object) : cast __type__;
                throw stdgo.Go.toInterface(stdgo.fmt.Fmt.sprintf(("writeObject(%T)" : stdgo.GoString), stdgo.Go.toInterface(_obj)));
            };
        };
        _buf.writeByte((32 : stdgo.GoUInt8));
        if (((_obj.pkg() != null) && ((_obj.pkg() : Dynamic).__nil__ == null || !(_obj.pkg() : Dynamic).__nil__)) && (stdgo.Go.toInterface(_obj.pkg()._scope.lookup(_obj.name()?.__copy__())) == stdgo.Go.toInterface(_obj))) {
            _buf.writeString(_packagePrefix(_obj.pkg(), _qf)?.__copy__());
        };
        _buf.writeString(_obj.name()?.__copy__());
        if (_typ == null) {
            return;
        };
        if (_tname != null && ((_tname : Dynamic).__nil__ == null || !(_tname : Dynamic).__nil__)) {
            {
                final __type__ = _typ;
                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                    return;
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Named>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                    if (_t._check._environment._decl._tdecl.typeParams().len() > (0 : stdgo.GoInt)) {
                        _newTypeWriter(_buf, _qf)._tParamList(_t._check._environment._decl._tdecl.typeParams()._list());
                    };
                };
            };
            if (_tname.isAlias()) {
                _buf.writeString((" =" : stdgo.GoString));
            } else {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_typ) : stdgo.Ref<TypeParam>)) : stdgo.Ref<TypeParam>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>), _1 : false };
                }, _t = __tmp__._0, __16 = __tmp__._1;
                if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                    _typ = _t._bound;
                } else {
                    _typ = _under(_typ);
                };
            };
        };
        if (stdgo.Go.toInterface(_obj) == (stdgo.Go.toInterface(_universeAny))) {
            _assert(identical(_typ, stdgo.Go.asInterface((stdgo.Go.setRef(_emptyInterface) : stdgo.Ref<stdgo.go.types.Types.Interface>))));
            _typ = stdgo.Go.asInterface((stdgo.Go.setRef(_emptyInterface) : stdgo.Ref<stdgo.go.types.Types.Interface>));
        };
        _buf.writeByte((32 : stdgo.GoUInt8));
        writeType(_buf, _typ, _qf);
    }
function _packagePrefix(_pkg:stdgo.Ref<Package>, _qf:Qualifier):stdgo.GoString {
        if (_pkg == null || (_pkg : Dynamic).__nil__) {
            return stdgo.Go.str()?.__copy__();
        };
        var _s:stdgo.GoString = ("" : stdgo.GoString);
        if (_qf != null) {
            _s = _qf(_pkg)?.__copy__();
        } else {
            _s = _pkg.path()?.__copy__();
        };
        if (_s != (stdgo.Go.str())) {
            _s = _s + (("." : stdgo.GoString))?.__copy__();
        };
        return _s?.__copy__();
    }
/**
    // ObjectString returns the string form of obj.
    // The Qualifier controls the printing of
    // package-level objects, and may be nil.
**/
function objectString(_obj:Object, _qf:Qualifier):stdgo.GoString {
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        _writeObject((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.bytes.Bytes.Buffer>), _obj, _qf);
        return (_buf.string() : stdgo.GoString)?.__copy__();
    }
function _writeFuncName(_buf:stdgo.Ref<stdgo.bytes.Bytes.Buffer>, _f:stdgo.Ref<Func>, _qf:Qualifier):Void {
        if (_f._object._typ != null) {
            var _sig = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_f._object._typ) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>);
            {
                var _recv = _sig.recv();
                if (_recv != null && ((_recv : Dynamic).__nil__ == null || !(_recv : Dynamic).__nil__)) {
                    _buf.writeByte((40 : stdgo.GoUInt8));
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_recv.type()) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Interface>), _1 : false };
                        }, __0 = __tmp__._0, _ok = __tmp__._1;
                        if (_ok) {
                            _buf.writeString(("interface" : stdgo.GoString));
                        } else {
                            writeType(_buf, _recv.type(), _qf);
                        };
                    };
                    _buf.writeByte((41 : stdgo.GoUInt8));
                    _buf.writeByte((46 : stdgo.GoUInt8));
                } else if (_f._object._pkg != null && ((_f._object._pkg : Dynamic).__nil__ == null || !(_f._object._pkg : Dynamic).__nil__)) {
                    _buf.writeString(_packagePrefix(_f._object._pkg, _qf)?.__copy__());
                };
            };
        };
        _buf.writeString(_f._object._name?.__copy__());
    }
/**
    // Operand string formats
    // (not all "untyped" cases can appear due to the type system,
    // but they fall out naturally here)
    //
    // mode       format
    //
    // invalid    <expr> (               <mode>                    )
    // novalue    <expr> (               <mode>                    )
    // builtin    <expr> (               <mode>                    )
    // typexpr    <expr> (               <mode>                    )
    //
    // constant   <expr> (<untyped kind> <mode>                    )
    // constant   <expr> (               <mode>       of type <typ>)
    // constant   <expr> (<untyped kind> <mode> <val>              )
    // constant   <expr> (               <mode> <val> of type <typ>)
    //
    // variable   <expr> (<untyped kind> <mode>                    )
    // variable   <expr> (               <mode>       of type <typ>)
    //
    // mapindex   <expr> (<untyped kind> <mode>                    )
    // mapindex   <expr> (               <mode>       of type <typ>)
    //
    // value      <expr> (<untyped kind> <mode>                    )
    // value      <expr> (               <mode>       of type <typ>)
    //
    // commaok    <expr> (<untyped kind> <mode>                    )
    // commaok    <expr> (               <mode>       of type <typ>)
    //
    // commaerr   <expr> (<untyped kind> <mode>                    )
    // commaerr   <expr> (               <mode>       of type <typ>)
    //
    // cgofunc    <expr> (<untyped kind> <mode>                    )
    // cgofunc    <expr> (               <mode>       of type <typ>)
**/
function _operandString(_x:stdgo.Ref<T_operand>, _qf:Qualifier):stdgo.GoString {
        if ((_x._mode == (7 : stdgo.go.types.Types.T_operandMode)) && (stdgo.Go.toInterface(_x._typ) == stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((25 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
            return ("nil" : stdgo.GoString);
        };
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        var _expr:stdgo.GoString = ("" : stdgo.GoString);
        if (_x._expr != null) {
            _expr = exprString(_x._expr)?.__copy__();
        } else {
            {
                final __value__ = _x._mode;
                if (__value__ == ((2 : stdgo.go.types.Types.T_operandMode))) {
                    _expr = _predeclaredFuncs[(_x._id : stdgo.GoInt)]._name?.__copy__();
                } else if (__value__ == ((3 : stdgo.go.types.Types.T_operandMode))) {
                    _expr = typeString(_x._typ, _qf)?.__copy__();
                } else if (__value__ == ((4 : stdgo.go.types.Types.T_operandMode))) {
                    _expr = (_x._val.string() : stdgo.GoString)?.__copy__();
                };
            };
        };
        if (_expr != (stdgo.Go.str())) {
            _buf.writeString(_expr?.__copy__());
            _buf.writeString((" (" : stdgo.GoString));
        };
        var _hasType:Bool = false;
        {
            var __switchIndex__ = -1;
            var __run__ = true;
            while (__run__) {
                __run__ = false;
                {
                    final __value__ = _x._mode;
                    if (__value__ == ((0 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((1 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((2 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((3 : stdgo.go.types.Types.T_operandMode))) {
                        break;
                    } else {
                        if (_x._typ != null) {
                            if (_isUntyped(_x._typ)) {
                                _buf.writeString((stdgo.Go.typeAssert((stdgo.Go.toInterface(_x._typ) : stdgo.Ref<Basic>)) : stdgo.Ref<Basic>)._name?.__copy__());
                                _buf.writeByte((32 : stdgo.GoUInt8));
                                break;
                            };
                            _hasType = true;
                        };
                    };
                };
                break;
            };
        };
        _buf.writeString(_operandModeString[(_x._mode : stdgo.GoInt)]?.__copy__());
        if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
            {
                var _s:stdgo.GoString = (_x._val.string() : stdgo.GoString)?.__copy__();
                if (_s != (_expr)) {
                    _buf.writeByte((32 : stdgo.GoUInt8));
                    _buf.writeString(_s?.__copy__());
                };
            };
        };
        if (_hasType) {
            if (stdgo.Go.toInterface(_x._typ) != (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                var _intro:stdgo.GoString = ("" : stdgo.GoString);
                if (_isGeneric(_x._typ)) {
                    _intro = (" of generic type " : stdgo.GoString);
                } else {
                    _intro = (" of type " : stdgo.GoString);
                };
                _buf.writeString(_intro?.__copy__());
                writeType((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.bytes.Bytes.Buffer>), _x._typ, _qf);
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_x._typ) : stdgo.Ref<TypeParam>)) : stdgo.Ref<TypeParam>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>), _1 : false };
                    }, _tpar = __tmp__._0, __0 = __tmp__._1;
                    if (_tpar != null && ((_tpar : Dynamic).__nil__ == null || !(_tpar : Dynamic).__nil__)) {
                        _buf.writeString((" constrained by " : stdgo.GoString));
                        writeType((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.bytes.Bytes.Buffer>), _tpar._bound, _qf);
                        if (_hasEmptyTypeset(stdgo.Go.asInterface(_tpar))) {
                            _buf.writeString((" with empty type set" : stdgo.GoString));
                        };
                    };
                };
            } else {
                _buf.writeString((" with invalid type" : stdgo.GoString));
            };
        };
        if (_expr != (stdgo.Go.str())) {
            _buf.writeByte((41 : stdgo.GoUInt8));
        };
        return (_buf.string() : stdgo.GoString)?.__copy__();
    }
/**
    // NewPackage returns a new Package for the given package path and name.
    // The package is not complete and contains no explicit imports.
**/
function newPackage(_path:stdgo.GoString, _name:stdgo.GoString):stdgo.Ref<Package> {
        var _scope = newScope(universe, _nopos, _nopos, stdgo.fmt.Fmt.sprintf(("package %q" : stdgo.GoString), stdgo.Go.toInterface(_path))?.__copy__());
        return (stdgo.Go.setRef(({ _path : _path?.__copy__(), _name : _name?.__copy__(), _scope : _scope } : stdgo.go.types.Types.Package)) : stdgo.Ref<stdgo.go.types.Types.Package>);
    }
/**
    // NewPointer returns a new pointer type for the given element (base) type.
**/
function newPointer(_elem:Type_):stdgo.Ref<Pointer_> {
        return (stdgo.Go.setRef(({ _base : _elem } : stdgo.go.types.Types.Pointer_)) : stdgo.Ref<stdgo.go.types.Types.Pointer_>);
    }
function _isBoolean(_t:Type_):Bool {
        return _isBasic(_t, (1 : stdgo.go.types.Types.BasicInfo));
    }
function _isInteger(_t:Type_):Bool {
        return _isBasic(_t, (2 : stdgo.go.types.Types.BasicInfo));
    }
function _isUnsigned(_t:Type_):Bool {
        return _isBasic(_t, (4 : stdgo.go.types.Types.BasicInfo));
    }
function _isFloat(_t:Type_):Bool {
        return _isBasic(_t, (8 : stdgo.go.types.Types.BasicInfo));
    }
function _isComplex(_t:Type_):Bool {
        return _isBasic(_t, (16 : stdgo.go.types.Types.BasicInfo));
    }
function _isNumeric(_t:Type_):Bool {
        return _isBasic(_t, (26 : stdgo.go.types.Types.BasicInfo));
    }
function _isString(_t:Type_):Bool {
        return _isBasic(_t, (32 : stdgo.go.types.Types.BasicInfo));
    }
function _isIntegerOrFloat(_t:Type_):Bool {
        return _isBasic(_t, (10 : stdgo.go.types.Types.BasicInfo));
    }
function _isConstType(_t:Type_):Bool {
        return _isBasic(_t, (59 : stdgo.go.types.Types.BasicInfo));
    }
/**
    // isBasic reports whether under(t) is a basic type with the specified info.
    // If t is a type parameter the result is false; i.e.,
    // isBasic does not look inside a type parameter.
**/
function _isBasic(_t:Type_, _info:BasicInfo):Bool {
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_t)) : stdgo.Ref<Basic>)) : stdgo.Ref<Basic>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Basic>), _1 : false };
        }, _u = __tmp__._0, __0 = __tmp__._1;
        return ((_u != null) && ((_u : Dynamic).__nil__ == null || !(_u : Dynamic).__nil__)) && ((_u._info & _info) != (0 : stdgo.go.types.Types.BasicInfo));
    }
function _allBoolean(_t:Type_):Bool {
        return _allBasic(_t, (1 : stdgo.go.types.Types.BasicInfo));
    }
function _allInteger(_t:Type_):Bool {
        return _allBasic(_t, (2 : stdgo.go.types.Types.BasicInfo));
    }
function _allUnsigned(_t:Type_):Bool {
        return _allBasic(_t, (4 : stdgo.go.types.Types.BasicInfo));
    }
function _allNumeric(_t:Type_):Bool {
        return _allBasic(_t, (26 : stdgo.go.types.Types.BasicInfo));
    }
function _allString(_t:Type_):Bool {
        return _allBasic(_t, (32 : stdgo.go.types.Types.BasicInfo));
    }
function _allOrdered(_t:Type_):Bool {
        return _allBasic(_t, (42 : stdgo.go.types.Types.BasicInfo));
    }
function _allNumericOrString(_t:Type_):Bool {
        return _allBasic(_t, (58 : stdgo.go.types.Types.BasicInfo));
    }
/**
    // allBasic reports whether under(t) is a basic type with the specified info.
    // If t is a type parameter, the result is true if isBasic(t, info) is true
    // for all specific types of the type parameter's type set.
    // allBasic(t, info) is an optimized version of isBasic(coreType(t), info).
**/
function _allBasic(_t:Type_, _info:BasicInfo):Bool {
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_t) : stdgo.Ref<TypeParam>)) : stdgo.Ref<TypeParam>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>), _1 : false };
            }, _tpar = __tmp__._0, __0 = __tmp__._1;
            if (_tpar != null && ((_tpar : Dynamic).__nil__ == null || !(_tpar : Dynamic).__nil__)) {
                return _tpar._is(function(_t:stdgo.Ref<T_term>):Bool {
                    return ((_t != null) && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) && _isBasic(_t._typ, _info);
                });
            };
        };
        return _isBasic(_t, _info);
    }
/**
    // hasName reports whether t has a name. This includes
    // predeclared types, defined types, and type parameters.
    // hasName may be called with types that are not fully set up.
**/
function _hasName(_t:Type_):Bool {
        {
            final __type__ = _t;
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Named>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeParam>))) {
                return true;
            };
        };
        return false;
    }
/**
    // isTypeLit reports whether t is a type literal.
    // This includes all non-defined types, but also basic types.
    // isTypeLit may be called with types that are not fully set up.
**/
function _isTypeLit(_t:Type_):Bool {
        {
            final __type__ = _t;
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Named>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeParam>))) {
                return false;
            };
        };
        return true;
    }
/**
    // isTyped reports whether t is typed; i.e., not an untyped
    // constant or boolean. isTyped may be called with types that
    // are not fully set up.
**/
function _isTyped(_t:Type_):Bool {
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_t) : stdgo.Ref<Basic>)) : stdgo.Ref<Basic>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Basic>), _1 : false };
        }, _b = __tmp__._0, __0 = __tmp__._1;
        return ((_b == null) || (_b : Dynamic).__nil__) || ((_b._info & (64 : stdgo.go.types.Types.BasicInfo)) == (0 : stdgo.go.types.Types.BasicInfo));
    }
/**
    // isUntyped(t) is the same as !isTyped(t).
**/
function _isUntyped(_t:Type_):Bool {
        return !_isTyped(_t);
    }
/**
    // IsInterface reports whether t is an interface type.
**/
function isInterface(_t:Type_):Bool {
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_t)) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Interface>), _1 : false };
        }, __0 = __tmp__._0, _ok = __tmp__._1;
        return _ok;
    }
/**
    // isNonTypeParamInterface reports whether t is an interface type but not a type parameter.
**/
function _isNonTypeParamInterface(_t:Type_):Bool {
        return !_isTypeParam(_t) && isInterface(_t);
    }
/**
    // isTypeParam reports whether t is a type parameter.
**/
function _isTypeParam(_t:Type_):Bool {
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_t) : stdgo.Ref<TypeParam>)) : stdgo.Ref<TypeParam>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>), _1 : false };
        }, __0 = __tmp__._0, _ok = __tmp__._1;
        return _ok;
    }
/**
    // hasEmptyTypeset reports whether t is a type parameter with an empty type set.
    // The function does not force the computation of the type set and so is safe to
    // use anywhere, but it may report a false negative if the type set has not been
    // computed yet.
**/
function _hasEmptyTypeset(_t:Type_):Bool {
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_t) : stdgo.Ref<TypeParam>)) : stdgo.Ref<TypeParam>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>), _1 : false };
            }, _tpar = __tmp__._0, __0 = __tmp__._1;
            if (((_tpar != null) && ((_tpar : Dynamic).__nil__ == null || !(_tpar : Dynamic).__nil__)) && (_tpar._bound != null)) {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_safeUnderlying(_tpar._bound)) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Interface>), _1 : false };
                }, _iface = __tmp__._0, __17 = __tmp__._1;
                return (((_iface != null) && ((_iface : Dynamic).__nil__ == null || !(_iface : Dynamic).__nil__)) && ((_iface._tset != null) && ((_iface._tset : Dynamic).__nil__ == null || !(_iface._tset : Dynamic).__nil__))) && _iface._tset.isEmpty();
            };
        };
        return false;
    }
/**
    // isGeneric reports whether a type is a generic, uninstantiated type
    // (generic signatures are not included).
    // TODO(gri) should we include signatures or assert that they are not present?
**/
function _isGeneric(_t:Type_):Bool {
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_t) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
        }, _named = __tmp__._0, __0 = __tmp__._1;
        return ((((_named != null) && ((_named : Dynamic).__nil__ == null || !(_named : Dynamic).__nil__)) && ((_named._obj != null) && ((_named._obj : Dynamic).__nil__ == null || !(_named._obj : Dynamic).__nil__))) && (_named._inst == null) || (_named._inst : Dynamic).__nil__) && (_named._check._environment._decl._tdecl.typeParams().len() > (0 : stdgo.GoInt));
    }
/**
    // Comparable reports whether values of type T are comparable.
**/
function comparable(t:Type_):Bool {
        return _comparable(t, true, (null : stdgo.GoMap<stdgo.go.types.Types.Type_, Bool>), null);
    }
/**
    // If dynamic is set, non-type parameter interfaces are always comparable.
    // If reportf != nil, it may be used to report why T is not comparable.
**/
function _comparable(t:Type_, _dynamic:Bool, _seen:stdgo.GoMap<Type_, Bool>, _reportf:(stdgo.GoString, haxe.Rest<stdgo.AnyInterface>) -> Void):Bool {
        if ((_seen[t] ?? false)) {
            return true;
        };
        if (_seen == null) {
            _seen = ({
                final x = new stdgo.GoMap.GoObjectMap<stdgo.go.types.Types.Type_, Bool>();
                x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Type_", [], stdgo.internal.reflect.Reflect.GoType.named("Type_", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
                x.__defaultValue__ = () -> false;
                @:mergeBlock {};
                cast x;
            } : stdgo.GoMap<stdgo.go.types.Types.Type_, Bool>);
        };
        _seen[t] = true;
        {
            final __type__ = _under(t);
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                var _t:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                return _t._kind != ((25 : stdgo.go.types.Types.BasicKind));
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Pointer_>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Chan>))) {
                var _t:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                return true;
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Struct>))) {
                var _t:stdgo.Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                for (__0 => _f in _t._fields) {
                    if (!_comparable(_f._object._typ, _dynamic, _seen, null)) {
                        if (_reportf != null) {
                            _reportf(("struct containing %s cannot be compared" : stdgo.GoString), stdgo.Go.toInterface(_f._object._typ));
                        };
                        return false;
                    };
                };
                return true;
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Array_>))) {
                var _t:stdgo.Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                if (!_comparable(_t._elem, _dynamic, _seen, null)) {
                    if (_reportf != null) {
                        _reportf(("%s cannot be compared" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_t)));
                    };
                    return false;
                };
                return true;
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                var _t:stdgo.Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                if ((_dynamic && !_isTypeParam(t)) || _t._typeSet().isComparable(_seen)) {
                    return true;
                };
                if (_reportf != null) {
                    if (_t._typeSet().isEmpty()) {
                        _reportf(("empty type set" : stdgo.GoString));
                    } else {
                        _reportf(("incomparable types in type set" : stdgo.GoString));
                    };
                };
            };
        };
        return false;
    }
/**
    // hasNil reports whether type t includes the nil value.
**/
function _hasNil(_t:Type_):Bool {
        {
            final __type__ = _under(_t);
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                var _u:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                return _u._kind == ((18 : stdgo.go.types.Types.BasicKind));
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Slice_>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Pointer_>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Signature>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Map_>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Chan>))) {
                var _u:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                return true;
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                var _u:stdgo.Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                return !_isTypeParam(_t) || _u._typeSet()._underIs(function(_u:Type_):Bool {
                    return (_u != null) && _hasNil(_u);
                });
            };
        };
        return false;
    }
/**
    // identicalOrigin reports whether x and y originated in the same declaration.
**/
function _indenticalOrigin(_x:stdgo.Ref<Named>, _y:stdgo.Ref<Named>):Bool {
        return _x.origin()._obj == (_y.origin()._obj);
    }
/**
    // identicalInstance reports if two type instantiations are identical.
    // Instantiations are identical if their origin and type arguments are
    // identical.
**/
function _identicalInstance(_xorig:Type_, _xargs:stdgo.Slice<Type_>, _yorig:Type_, _yargs:stdgo.Slice<Type_>):Bool {
        if ((_xargs.length) != ((_yargs.length))) {
            return false;
        };
        for (_i => _xa in _xargs) {
            if (!identical(_xa, _yargs[(_i : stdgo.GoInt)])) {
                return false;
            };
        };
        return identical(_xorig, _yorig);
    }
/**
    // Default returns the default "typed" type for an "untyped" type;
    // it returns the incoming type for all other types. The default type
    // for untyped nil is untyped nil.
**/
function default_(_t:Type_):Type_ {
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_t) : stdgo.Ref<Basic>)) : stdgo.Ref<Basic>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Basic>), _1 : false };
            }, _t = __tmp__._0, _ok = __tmp__._1;
            if (_ok) {
                {
                    final __value__ = _t._kind;
                    if (__value__ == ((19 : stdgo.go.types.Types.BasicKind))) {
                        return stdgo.Go.asInterface(typ[((1 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                    } else if (__value__ == ((20 : stdgo.go.types.Types.BasicKind))) {
                        return stdgo.Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                    } else if (__value__ == ((21 : stdgo.go.types.Types.BasicKind))) {
                        return _universeRune;
                    } else if (__value__ == ((22 : stdgo.go.types.Types.BasicKind))) {
                        return stdgo.Go.asInterface(typ[((14 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                    } else if (__value__ == ((23 : stdgo.go.types.Types.BasicKind))) {
                        return stdgo.Go.asInterface(typ[((16 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                    } else if (__value__ == ((24 : stdgo.go.types.Types.BasicKind))) {
                        return stdgo.Go.asInterface(typ[((17 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                    };
                };
            };
        };
        return _t;
    }
/**
    // maxType returns the "largest" type that encompasses both x and y.
    // If x and y are different untyped numeric types, the result is the type of x or y
    // that appears later in this list: integer, rune, floating-point, complex.
    // Otherwise, if x != y, the result is nil.
**/
function _maxType(_x:Type_, _y:Type_):Type_ {
        if (stdgo.Go.toInterface(_x) == (stdgo.Go.toInterface(_y))) {
            return _x;
        };
        if (((_isUntyped(_x) && _isUntyped(_y)) && _isNumeric(_x)) && _isNumeric(_y)) {
            if ((stdgo.Go.typeAssert((stdgo.Go.toInterface(_x) : stdgo.Ref<Basic>)) : stdgo.Ref<Basic>)._kind > (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Basic>)) : stdgo.Ref<Basic>)._kind) {
                return _x;
            };
            return _y;
        };
        return (null : stdgo.go.types.Types.Type_);
    }
function _validatedImportPath(_path:stdgo.GoString):{ var _0 : stdgo.GoString; var _1 : stdgo.Error; } {
        var __tmp__ = stdgo.strconv.Strconv.unquote(_path?.__copy__()), _s:stdgo.GoString = __tmp__._0, _err:stdgo.Error = __tmp__._1;
        if (_err != null) {
            return { _0 : stdgo.Go.str()?.__copy__(), _1 : _err };
        };
        if (_s == (stdgo.Go.str())) {
            return { _0 : stdgo.Go.str()?.__copy__(), _1 : stdgo.fmt.Fmt.errorf(("empty string" : stdgo.GoString)) };
        };
        {};
        for (__0 => _r in _s) {
            if ((!stdgo.unicode.Unicode.isGraphic(_r) || stdgo.unicode.Unicode.isSpace(_r)) || stdgo.strings.Strings.containsRune(("!\"#$%&\'()*,:;<=>?[\\]^{|}`�" : stdgo.GoString), _r)) {
                return { _0 : _s?.__copy__(), _1 : stdgo.fmt.Fmt.errorf(("invalid character %#U" : stdgo.GoString), stdgo.Go.toInterface(_r)) };
            };
        };
        return { _0 : _s?.__copy__(), _1 : (null : stdgo.Error) };
    }
/**
    // dir makes a good-faith attempt to return the directory
    // portion of path. If path is empty, the result is ".".
    // (Per the go/build package dependency tests, we cannot import
    // path/filepath and simply use filepath.Dir.)
**/
function _dir(_path:stdgo.GoString):stdgo.GoString {
        {
            var _i:stdgo.GoInt = stdgo.strings.Strings.lastIndexAny(_path?.__copy__(), ("/\\" : stdgo.GoString));
            if (_i > (0 : stdgo.GoInt)) {
                return (_path.__slice__(0, _i) : stdgo.GoString)?.__copy__();
            };
        };
        return ("." : stdgo.GoString);
    }
/**
    // hasBreak reports if s is or contains a break statement
    // referring to the label-ed statement or implicit-ly the
    // closest outer breakable statement.
**/
function _hasBreak(_s:stdgo.go.ast.Ast.Stmt, _label:stdgo.GoString, _implicit:Bool):Bool {
        {
            final __type__ = _s;
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BadStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.DeclStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.EmptyStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ExprStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SendStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IncDecStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.AssignStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.GoStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.DeferStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ReturnStmt>))) {
                var _s:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>))) {
                var _s:stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__().value;
                return _hasBreak(_s.stmt, _label?.__copy__(), _implicit);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>))) {
                var _s:stdgo.Ref<stdgo.go.ast.Ast.BranchStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__().value;
                if (_s.tok == ((61 : stdgo.go.token.Token.Token))) {
                    if (_s.label == null || (_s.label : Dynamic).__nil__) {
                        return _implicit;
                    };
                    if (_s.label.name == (_label)) {
                        return true;
                    };
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>))) {
                var _s:stdgo.Ref<stdgo.go.ast.Ast.BlockStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__().value;
                return _hasBreakList(_s.list, _label?.__copy__(), _implicit);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IfStmt>))) {
                var _s:stdgo.Ref<stdgo.go.ast.Ast.IfStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IfStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__().value;
                if (_hasBreak(stdgo.Go.asInterface(_s.body), _label?.__copy__(), _implicit) || ((_s.else_ != null) && _hasBreak(_s.else_, _label?.__copy__(), _implicit))) {
                    return true;
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.CaseClause>))) {
                var _s:stdgo.Ref<stdgo.go.ast.Ast.CaseClause> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CaseClause>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CaseClause>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CaseClause>) : __type__.__underlying__().value;
                return _hasBreakList(_s.body, _label?.__copy__(), _implicit);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SwitchStmt>))) {
                var _s:stdgo.Ref<stdgo.go.ast.Ast.SwitchStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__().value;
                if ((_label != stdgo.Go.str()) && _hasBreak(stdgo.Go.asInterface(_s.body), _label?.__copy__(), false)) {
                    return true;
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.TypeSwitchStmt>))) {
                var _s:stdgo.Ref<stdgo.go.ast.Ast.TypeSwitchStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__().value;
                if ((_label != stdgo.Go.str()) && _hasBreak(stdgo.Go.asInterface(_s.body), _label?.__copy__(), false)) {
                    return true;
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.CommClause>))) {
                var _s:stdgo.Ref<stdgo.go.ast.Ast.CommClause> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CommClause>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CommClause>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CommClause>) : __type__.__underlying__().value;
                return _hasBreakList(_s.body, _label?.__copy__(), _implicit);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SelectStmt>))) {
                var _s:stdgo.Ref<stdgo.go.ast.Ast.SelectStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__().value;
                if ((_label != stdgo.Go.str()) && _hasBreak(stdgo.Go.asInterface(_s.body), _label?.__copy__(), false)) {
                    return true;
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ForStmt>))) {
                var _s:stdgo.Ref<stdgo.go.ast.Ast.ForStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ForStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__().value;
                if ((_label != stdgo.Go.str()) && _hasBreak(stdgo.Go.asInterface(_s.body), _label?.__copy__(), false)) {
                    return true;
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.RangeStmt>))) {
                var _s:stdgo.Ref<stdgo.go.ast.Ast.RangeStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__.__underlying__().value;
                if ((_label != stdgo.Go.str()) && _hasBreak(stdgo.Go.asInterface(_s.body), _label?.__copy__(), false)) {
                    return true;
                };
            } else {
                var _s:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
                _unreachable();
            };
        };
        return false;
    }
function _hasBreakList(_list:stdgo.Slice<stdgo.go.ast.Ast.Stmt>, _label:stdgo.GoString, _implicit:Bool):Bool {
        for (__0 => _s in _list) {
            if (_hasBreak(_s, _label?.__copy__(), _implicit)) {
                return true;
            };
        };
        return false;
    }
/**
    // NewScope returns a new, empty scope contained in the given parent
    // scope, if any. The comment is for debugging only.
**/
function newScope(_parent:stdgo.Ref<Scope>, _pos:stdgo.go.token.Token.Pos, _end:stdgo.go.token.Token.Pos, _comment:stdgo.GoString):stdgo.Ref<Scope> {
        var _s = (stdgo.Go.setRef((new stdgo.go.types.Types.Scope(_parent, (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Scope>>), (0 : stdgo.GoInt), (null : stdgo.GoMap<stdgo.GoString, stdgo.go.types.Types.Object>), _pos, _end, _comment?.__copy__(), false) : stdgo.go.types.Types.Scope)) : stdgo.Ref<stdgo.go.types.Types.Scope>);
        if (((_parent != null) && ((_parent : Dynamic).__nil__ == null || !(_parent : Dynamic).__nil__)) && (_parent != universe)) {
            _parent._children = (_parent._children.__append__(_s));
            _s._number = (_parent._children.length);
        };
        return _s;
    }
/**
    // resolve returns the Object represented by obj, resolving lazy
    // objects as appropriate.
**/
function _resolve(_name:stdgo.GoString, _obj:Object):Object {
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<T_lazyObject>)) : stdgo.Ref<T_lazyObject>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.T_lazyObject>), _1 : false };
            }, _lazy = __tmp__._0, _ok = __tmp__._1;
            if (_ok) {
                _lazy._once.do_(function():Void {
                    var _obj:stdgo.go.types.Types.Object = _lazy._resolve();
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<T_lazyObject>)) : stdgo.Ref<T_lazyObject>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.T_lazyObject>), _1 : false };
                        }, __0 = __tmp__._0, _ok = __tmp__._1;
                        if (_ok) {
                            throw stdgo.Go.toInterface(("recursive lazy object" : stdgo.GoString));
                        };
                    };
                    if (_obj.name() != (_name)) {
                        throw stdgo.Go.toInterface(("lazy object has unexpected name" : stdgo.GoString));
                    };
                    if (_obj.parent() == null || (_obj.parent() : Dynamic).__nil__) {
                        _obj._setParent(_lazy._parent);
                    };
                    _lazy._obj = _obj;
                });
                _obj = _lazy._obj;
            };
        };
        return _obj;
    }
/**
    // SelectionString returns the string form of s.
    // The Qualifier controls the printing of
    // package-level objects, and may be nil.
    //
    // Examples:
    //
    //	"field (T) f int"
    //	"method (T) f(X) Y"
    //	"method expr (T) f(X) Y"
**/
function selectionString(_s:stdgo.Ref<Selection>, _qf:Qualifier):stdgo.GoString {
        var _k:stdgo.GoString = ("" : stdgo.GoString);
        {
            final __value__ = _s._kind;
            if (__value__ == ((0 : stdgo.go.types.Types.SelectionKind))) {
                _k = ("field " : stdgo.GoString);
            } else if (__value__ == ((1 : stdgo.go.types.Types.SelectionKind))) {
                _k = ("method " : stdgo.GoString);
            } else if (__value__ == ((2 : stdgo.go.types.Types.SelectionKind))) {
                _k = ("method expr " : stdgo.GoString);
            } else {
                _unreachable();
            };
        };
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        _buf.writeString(_k?.__copy__());
        _buf.writeByte((40 : stdgo.GoUInt8));
        writeType((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.bytes.Bytes.Buffer>), _s.recv(), _qf);
        stdgo.fmt.Fmt.fprintf(stdgo.Go.asInterface((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.bytes.Bytes.Buffer>)), (") %s" : stdgo.GoString), stdgo.Go.toInterface(_s._obj.name()));
        {
            var t:stdgo.go.types.Types.Type_ = _s.type();
            if (_s._kind == ((0 : stdgo.go.types.Types.SelectionKind))) {
                _buf.writeByte((32 : stdgo.GoUInt8));
                writeType((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.bytes.Bytes.Buffer>), t, _qf);
            } else {
                writeSignature((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.bytes.Bytes.Buffer>), (stdgo.Go.typeAssert((stdgo.Go.toInterface(t) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>), _qf);
            };
        };
        return (_buf.string() : stdgo.GoString)?.__copy__();
    }
/**
    // NewSignature returns a new function type for the given receiver, parameters,
    // and results, either of which may be nil. If variadic is set, the function
    // is variadic, it must have at least one parameter, and the last parameter
    // must be of unnamed slice type.
    //
    // Deprecated: Use NewSignatureType instead which allows for type parameters.
**/
function newSignature(_recv:stdgo.Ref<Var>, _params:stdgo.Ref<Tuple>, _results:stdgo.Ref<Tuple>, _variadic:Bool):stdgo.Ref<Signature> {
        return newSignatureType(_recv, (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>), (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>), _params, _results, _variadic);
    }
/**
    // NewSignatureType creates a new function type for the given receiver,
    // receiver type parameters, type parameters, parameters, and results. If
    // variadic is set, params must hold at least one parameter and the last
    // parameter's core type must be of unnamed slice or bytestring type.
    // If recv is non-nil, typeParams must be empty. If recvTypeParams is
    // non-empty, recv must be non-nil.
**/
function newSignatureType(_recv:stdgo.Ref<Var>, _recvTypeParams:stdgo.Slice<stdgo.Ref<TypeParam>>, _typeParams:stdgo.Slice<stdgo.Ref<TypeParam>>, _params:stdgo.Ref<Tuple>, _results:stdgo.Ref<Tuple>, _variadic:Bool):stdgo.Ref<Signature> {
        if (_variadic) {
            var _n:stdgo.GoInt = _params.len();
            if (_n == ((0 : stdgo.GoInt))) {
                throw stdgo.Go.toInterface(("variadic function must have at least one parameter" : stdgo.GoString));
            };
            var _core:stdgo.go.types.Types.Type_ = _coreString(_params.at(_n - (1 : stdgo.GoInt))._object._typ);
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_core) : stdgo.Ref<Slice_>)) : stdgo.Ref<Slice_>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Slice_>), _1 : false };
                }, __0 = __tmp__._0, _ok = __tmp__._1;
                if (!_ok && !_isString(_core)) {
                    throw stdgo.Go.toInterface(stdgo.fmt.Fmt.sprintf(("got %s, want variadic parameter with unnamed slice type or string as core type" : stdgo.GoString), stdgo.Go.toInterface((_core.string() : stdgo.GoString))));
                };
            };
        };
        var _sig = (stdgo.Go.setRef(({ _recv : _recv, _params : _params, _results : _results, _variadic : _variadic } : stdgo.go.types.Types.Signature)) : stdgo.Ref<stdgo.go.types.Types.Signature>);
        if ((_recvTypeParams.length) != ((0 : stdgo.GoInt))) {
            if (_recv == null || (_recv : Dynamic).__nil__) {
                throw stdgo.Go.toInterface(("function with receiver type parameters must have a receiver" : stdgo.GoString));
            };
            _sig._rparams = _bindTParams(_recvTypeParams);
        };
        if ((_typeParams.length) != ((0 : stdgo.GoInt))) {
            if (_recv != null && ((_recv : Dynamic).__nil__ == null || !(_recv : Dynamic).__nil__)) {
                throw stdgo.Go.toInterface(("function with type parameters cannot have a receiver" : stdgo.GoString));
            };
            _sig._tparams = _bindTParams(_typeParams);
        };
        return _sig;
    }
/**
    // Signal size changes of important structures.
**/
function testSizeof(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        {};
        var _tests:stdgo.Slice<T__struct_1> = (new stdgo.Slice<T__struct_1>(
25,
25,
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.Basic() : stdgo.go.types.Types.Basic))), __32bit : (16 : stdgo.GoUIntptr), __64bit : (32 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.Array_() : stdgo.go.types.Types.Array_))), __32bit : (16 : stdgo.GoUIntptr), __64bit : (24 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.Slice_() : stdgo.go.types.Types.Slice_))), __32bit : (8 : stdgo.GoUIntptr), __64bit : (16 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.Struct() : stdgo.go.types.Types.Struct))), __32bit : (24 : stdgo.GoUIntptr), __64bit : (48 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.Pointer_() : stdgo.go.types.Types.Pointer_))), __32bit : (8 : stdgo.GoUIntptr), __64bit : (16 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.Tuple() : stdgo.go.types.Types.Tuple))), __32bit : (12 : stdgo.GoUIntptr), __64bit : (24 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.Signature() : stdgo.go.types.Types.Signature))), __32bit : (28 : stdgo.GoUIntptr), __64bit : (56 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.Union() : stdgo.go.types.Types.Union))), __32bit : (12 : stdgo.GoUIntptr), __64bit : (24 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.Interface() : stdgo.go.types.Types.Interface))), __32bit : (40 : stdgo.GoUIntptr), __64bit : (80 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.Map_() : stdgo.go.types.Types.Map_))), __32bit : (16 : stdgo.GoUIntptr), __64bit : (32 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.Chan() : stdgo.go.types.Types.Chan))), __32bit : (12 : stdgo.GoUIntptr), __64bit : (24 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.Named() : stdgo.go.types.Types.Named))), __32bit : (60 : stdgo.GoUIntptr), __64bit : (112 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.TypeParam() : stdgo.go.types.Types.TypeParam))), __32bit : (28 : stdgo.GoUIntptr), __64bit : (48 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.T_term() : stdgo.go.types.Types.T_term))), __32bit : (12 : stdgo.GoUIntptr), __64bit : (24 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.PkgName() : stdgo.go.types.Types.PkgName))), __32bit : (48 : stdgo.GoUIntptr), __64bit : (88 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.Const() : stdgo.go.types.Types.Const))), __32bit : (48 : stdgo.GoUIntptr), __64bit : (88 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.TypeName() : stdgo.go.types.Types.TypeName))), __32bit : (40 : stdgo.GoUIntptr), __64bit : (72 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.Var() : stdgo.go.types.Types.Var))), __32bit : (48 : stdgo.GoUIntptr), __64bit : (88 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.Func() : stdgo.go.types.Types.Func))), __32bit : (48 : stdgo.GoUIntptr), __64bit : (88 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.Label() : stdgo.go.types.Types.Label))), __32bit : (44 : stdgo.GoUIntptr), __64bit : (80 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.Builtin() : stdgo.go.types.Types.Builtin))), __32bit : (44 : stdgo.GoUIntptr), __64bit : (80 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.Nil() : stdgo.go.types.Types.Nil))), __32bit : (40 : stdgo.GoUIntptr), __64bit : (72 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.Scope() : stdgo.go.types.Types.Scope))), __32bit : (44 : stdgo.GoUIntptr), __64bit : (88 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.Package() : stdgo.go.types.Types.Package))), __32bit : (44 : stdgo.GoUIntptr), __64bit : (88 : stdgo.GoUIntptr) } : T__struct_1),
({ _val : stdgo.Go.toInterface(stdgo.Go.asInterface((new stdgo.go.types.Types.T__TypeSet() : stdgo.go.types.Types.T__TypeSet))), __32bit : (28 : stdgo.GoUIntptr), __64bit : (56 : stdgo.GoUIntptr) } : T__struct_1)) : stdgo.Slice<T__struct_1>);
        for (__0 => _test in _tests) {
            var _got:stdgo.GoUIntptr = stdgo.reflect.Reflect.typeOf(_test._val).size();
            var _want:stdgo.GoUIntptr = _test.__32bit;
            if (false) {
                _want = _test.__64bit;
            };
            if (_got != (_want)) {
                _t.errorf(("unsafe.Sizeof(%T) = %d, want %d" : stdgo.GoString), _test._val, stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_want));
            };
        };
    }
function __IsSyncAtomicAlign64(t:Type_):Bool {
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(t) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
        }, _named = __tmp__._0, _ok = __tmp__._1;
        if (!_ok) {
            return false;
        };
        var _obj = _named._check._environment._decl._tdecl.name.obj();
        return ((_obj.name() == ("align64" : stdgo.GoString)) && ((_obj.pkg() != null) && ((_obj.pkg() : Dynamic).__nil__ == null || !(_obj.pkg() : Dynamic).__nil__))) && ((_obj.pkg().path() == ("sync/atomic" : stdgo.GoString)) || (_obj.pkg().path() == ("runtime/internal/atomic" : stdgo.GoString)));
    }
/**
    // SizesFor returns the Sizes used by a compiler for an architecture.
    // The result is nil if a compiler/architecture pair is not known.
    //
    // Supported architectures for compiler "gc":
    // "386", "amd64", "amd64p32", "arm", "arm64", "loong64", "mips", "mipsle",
    // "mips64", "mips64le", "ppc64", "ppc64le", "riscv64", "s390x", "sparc64", "wasm".
**/
function sizesFor(_compiler:stdgo.GoString, _arch:stdgo.GoString):Sizes {
        var _m:stdgo.GoMap<stdgo.GoString, stdgo.Ref<StdSizes>> = (null : stdgo.GoMap<stdgo.GoString, stdgo.Ref<stdgo.go.types.Types.StdSizes>>);
        {
            final __value__ = _compiler;
            if (__value__ == (("gc" : stdgo.GoString))) {
                _m = _gcArchSizes;
            } else if (__value__ == (("gccgo" : stdgo.GoString))) {
                _m = _gccgoArchSizes;
            } else {
                return (null : stdgo.go.types.Types.Sizes);
            };
        };
        var __tmp__ = (_m != null && _m.exists(_arch?.__copy__()) ? { _0 : _m[_arch?.__copy__()], _1 : true } : { _0 : (null : stdgo.Ref<stdgo.go.types.Types.StdSizes>), _1 : false }), _s:stdgo.Ref<stdgo.go.types.Types.StdSizes> = __tmp__._0, _ok:Bool = __tmp__._1;
        if (!_ok) {
            return (null : stdgo.go.types.Types.Sizes);
        };
        return stdgo.Go.asInterface(_s);
    }
/**
    // align returns the smallest y >= x such that y % a == 0.
    // a must be within 1 and 8 and it must be a power of 2.
    // The result may be negative due to overflow.
**/
function _align(_x:stdgo.GoInt64, _a:stdgo.GoInt64):stdgo.GoInt64 {
        _assert((((_x >= (0i64 : stdgo.GoInt64)) && ((1i64 : stdgo.GoInt64) <= _a)) && (_a <= (8i64 : stdgo.GoInt64))) && ((_a & (_a - (1i64 : stdgo.GoInt64))) == (0i64 : stdgo.GoInt64)));
        return ((_x + _a) - (1i64 : stdgo.GoInt64)) & ((_a - (1i64 : stdgo.GoInt64)) ^ (-1i32 : stdgo.GoInt));
    }
/**
    // NewSlice returns a new slice type for the given element type.
**/
function newSlice(_elem:Type_):stdgo.Ref<Slice_> {
        return (stdgo.Go.setRef(({ _elem : _elem } : stdgo.go.types.Types.Slice_)) : stdgo.Ref<stdgo.go.types.Types.Slice_>);
    }
function _trimTrailingEmptyStmts(_list:stdgo.Slice<stdgo.go.ast.Ast.Stmt>):stdgo.Slice<stdgo.go.ast.Ast.Stmt> {
        {
            var _i:stdgo.GoInt = (_list.length);
            stdgo.Go.cfor(_i > (0 : stdgo.GoInt), _i--, {
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_list[(_i - (1 : stdgo.GoInt) : stdgo.GoInt)]) : stdgo.Ref<stdgo.go.ast.Ast.EmptyStmt>)) : stdgo.Ref<stdgo.go.ast.Ast.EmptyStmt>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.EmptyStmt>), _1 : false };
                    }, __0 = __tmp__._0, _ok = __tmp__._1;
                    if (!_ok) {
                        return (_list.__slice__(0, _i) : stdgo.Slice<stdgo.go.ast.Ast.Stmt>);
                    };
                };
            });
        };
        return (null : stdgo.Slice<stdgo.go.ast.Ast.Stmt>);
    }
function _assignOp(_op:stdgo.go.token.Token.Token):stdgo.go.token.Token.Token {
        if (((23 : stdgo.go.token.Token.Token) <= _op) && (_op <= (33 : stdgo.go.token.Token.Token))) {
            return _op + (-11 : stdgo.go.token.Token.Token);
        };
        return (0 : stdgo.go.token.Token.Token);
    }
/**
    // goVal returns the Go value for val, or nil.
**/
function _goVal(_val:stdgo.go.constant.Constant.Value):stdgo.AnyInterface {
        if (_val == null) {
            return (null : stdgo.AnyInterface);
        };
        {
            final __value__ = _val.kind();
            if (__value__ == ((3 : stdgo.go.constant.Constant.Kind))) {
                {
                    var __tmp__ = stdgo.go.constant.Constant.int64Val(_val), _x:stdgo.GoInt64 = __tmp__._0, _ok:Bool = __tmp__._1;
                    if (_ok) {
                        return stdgo.Go.toInterface(_x);
                    };
                };
                {
                    var __tmp__ = stdgo.go.constant.Constant.uint64Val(_val), _x:stdgo.GoUInt64 = __tmp__._0, _ok:Bool = __tmp__._1;
                    if (_ok) {
                        return stdgo.Go.toInterface(_x);
                    };
                };
            } else if (__value__ == ((4 : stdgo.go.constant.Constant.Kind))) {
                {
                    var __tmp__ = stdgo.go.constant.Constant.float64Val(_val), _x:stdgo.GoFloat64 = __tmp__._0, _ok:Bool = __tmp__._1;
                    if (_ok) {
                        return stdgo.Go.toInterface(_x);
                    };
                };
            } else if (__value__ == ((2 : stdgo.go.constant.Constant.Kind))) {
                return stdgo.Go.toInterface(stdgo.go.constant.Constant.stringVal(_val));
            };
        };
        return (null : stdgo.AnyInterface);
    }
/**
    // rangeKeyVal returns the key and value type produced by a range clause
    // over an expression of type typ. If the range clause is not permitted
    // the results are nil.
**/
function _rangeKeyVal(_typ:Type_):{ var _0 : Type_; var _1 : Type_; } {
        var _key:Type_ = (null : stdgo.go.types.Types.Type_), _val:Type_ = (null : stdgo.go.types.Types.Type_);
        {
            final __type__ = _arrayPtrDeref(_typ);
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                var _typ:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                if (_isString(stdgo.Go.asInterface(_typ))) {
                    return { _0 : stdgo.Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]), _1 : _universeRune };
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Array_>))) {
                var _typ:stdgo.Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                return { _0 : stdgo.Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]), _1 : _typ._elem };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Slice_>))) {
                var _typ:stdgo.Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                return { _0 : stdgo.Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]), _1 : _typ._elem };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Map_>))) {
                var _typ:stdgo.Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                return { _0 : _typ._key, _1 : _typ._elem };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Chan>))) {
                var _typ:stdgo.Ref<stdgo.go.types.Types.Chan> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__().value;
                return { _0 : _typ._elem, _1 : stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]) };
            };
        };
        return { _0 : _key, _1 : _val };
    }
/**
    // NewStruct returns a new struct with the given fields and corresponding field tags.
    // If a field with index i has a tag, tags[i] must be that tag, but len(tags) may be
    // only as long as required to hold the tag with the largest index i. Consequently,
    // if no field has a tag, tags may be nil.
**/
function newStruct(_fields:stdgo.Slice<stdgo.Ref<Var>>, _tags:stdgo.Slice<stdgo.GoString>):stdgo.Ref<Struct> {
        var _fset:T_objset = (null : stdgo.go.types.Types.T_objset);
        for (__0 => _f in _fields) {
            if ((_f._object._name != ("_" : stdgo.GoString)) && (_fset._insert(stdgo.Go.asInterface(_f)) != null)) {
                throw stdgo.Go.toInterface(("multiple fields with the same name" : stdgo.GoString));
            };
        };
        if ((_tags.length) > (_fields.length)) {
            throw stdgo.Go.toInterface(("more tags than fields" : stdgo.GoString));
        };
        var _s = (stdgo.Go.setRef(({ _fields : _fields, _tags : _tags } : stdgo.go.types.Types.Struct)) : stdgo.Ref<stdgo.go.types.Types.Struct>);
        _s._markComplete();
        return _s;
    }
function _embeddedFieldIdent(_e:stdgo.go.ast.Ast.Expr):stdgo.Ref<stdgo.go.ast.Ast.Ident> {
        {
            final __type__ = _e;
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.Ident>))) {
                var _e:stdgo.Ref<stdgo.go.ast.Ast.Ident> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__().value;
                return _e;
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>))) {
                var _e:stdgo.Ref<stdgo.go.ast.Ast.StarExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_e.x) : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>)) : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>), _1 : false };
                    }, __0 = __tmp__._0, _ok = __tmp__._1;
                    if (!_ok) {
                        return _embeddedFieldIdent(_e.x);
                    };
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>))) {
                var _e:stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__().value;
                return _e.sel;
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IndexExpr>))) {
                var _e:stdgo.Ref<stdgo.go.ast.Ast.IndexExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IndexExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IndexExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IndexExpr>) : __type__.__underlying__().value;
                return _embeddedFieldIdent(_e.x);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IndexListExpr>))) {
                var _e:stdgo.Ref<stdgo.go.ast.Ast.IndexListExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IndexListExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IndexListExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IndexListExpr>) : __type__.__underlying__().value;
                return _embeddedFieldIdent(_e.x);
            };
        };
        return null;
    }
/**
    // makeSubstMap creates a new substitution map mapping tpars[i] to targs[i].
    // If targs[i] is nil, tpars[i] is not substituted.
**/
function _makeSubstMap(_tpars:stdgo.Slice<stdgo.Ref<TypeParam>>, _targs:stdgo.Slice<Type_>):T_substMap {
        _assert((_tpars.length) == ((_targs.length)));
        var _proj:stdgo.go.types.Types.T_substMap = ({
            final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.types.Types.TypeParam>, stdgo.go.types.Types.Type_>();
            @:mergeBlock {};
            cast x;
        } : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeParam>, stdgo.go.types.Types.Type_>);
        for (_i => _tpar in _tpars) {
            _proj[_tpar] = _targs[(_i : stdgo.GoInt)];
        };
        return _proj;
    }
/**
    // makeRenameMap is like makeSubstMap, but creates a map used to rename type
    // parameters in from with the type parameters in to.
**/
function _makeRenameMap(_from:stdgo.Slice<stdgo.Ref<TypeParam>>, _to:stdgo.Slice<stdgo.Ref<TypeParam>>):T_substMap {
        _assert((_from.length) == ((_to.length)));
        var _proj:stdgo.go.types.Types.T_substMap = ({
            final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.types.Types.TypeParam>, stdgo.go.types.Types.Type_>();
            @:mergeBlock {};
            cast x;
        } : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeParam>, stdgo.go.types.Types.Type_>);
        for (_i => _tpar in _from) {
            _proj[_tpar] = stdgo.Go.asInterface(_to[(_i : stdgo.GoInt)]);
        };
        return _proj;
    }
function _substVar(_v:stdgo.Ref<Var>, _typ:Type_):stdgo.Ref<Var> {
        var _copy:stdgo.go.types.Types.Var = (_v : stdgo.go.types.Types.Var)?.__copy__();
        _copy._object._typ = _typ;
        _copy._origin = _v.origin();
        return (stdgo.Go.setRef(_copy) : stdgo.Ref<stdgo.go.types.Types.Var>);
    }
function _substFunc(_f:stdgo.Ref<Func>, _typ:Type_):stdgo.Ref<Func> {
        var _copy:stdgo.go.types.Types.Func = (_f : stdgo.go.types.Types.Func)?.__copy__();
        _copy._object._typ = _typ;
        _copy._origin = _f.origin();
        return (stdgo.Go.setRef(_copy) : stdgo.Ref<stdgo.go.types.Types.Func>);
    }
/**
    // replaceRecvType updates any function receivers that have type old to have
    // type new. It does not modify the input slice; if modifications are required,
    // the input slice and any affected signatures will be copied before mutating.
    //
    // The resulting out slice contains the updated functions, and copied reports
    // if anything was modified.
**/
function _replaceRecvType(_in:stdgo.Slice<stdgo.Ref<Func>>, _old:Type_, _new:Type_):{ var _0 : stdgo.Slice<stdgo.Ref<Func>>; var _1 : Bool; } {
        var _out:stdgo.Slice<stdgo.Ref<Func>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>), _copied:Bool = false;
        _out = _in;
        for (_i => _method in _in) {
            var _sig = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_method.type()) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>);
            if (((_sig._recv != null) && ((_sig._recv : Dynamic).__nil__ == null || !(_sig._recv : Dynamic).__nil__)) && (stdgo.Go.toInterface(_sig._recv.type()) == stdgo.Go.toInterface(_old))) {
                if (!_copied) {
                    _out = new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>((_in.length : stdgo.GoInt).toBasic(), 0);
                    stdgo.Go.copySlice(_out, _in);
                    _copied = true;
                };
                var _newsig:stdgo.go.types.Types.Signature = (_sig : stdgo.go.types.Types.Signature)?.__copy__();
                _newsig._recv = _substVar(_sig._recv, _new);
                _out[(_i : stdgo.GoInt)] = _substFunc(_method, stdgo.Go.asInterface((stdgo.Go.setRef(_newsig) : stdgo.Ref<stdgo.go.types.Types.Signature>)));
            };
        };
        return { _0 : _out, _1 : _copied };
    }
/**
    // maketl makes a term list from a string of the term list.
**/
function _maketl(_s:stdgo.GoString):T_termlist {
        _s = stdgo.strings.Strings.replaceAll(_s?.__copy__(), (" " : stdgo.GoString), stdgo.Go.str()?.__copy__())?.__copy__();
        var _names = stdgo.strings.Strings.split(_s?.__copy__(), ("|" : stdgo.GoString));
        var _r:stdgo.go.types.Types.T_termlist = new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_term>>((_names.length : stdgo.GoInt).toBasic(), 0);
        for (_i => _n in _names) {
            _r[(_i : stdgo.GoInt)] = _testTerm(_n?.__copy__());
        };
        return _r;
    }
function testTermlistAll(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        if (!_allTermlist._isAll()) {
            _t.errorf(("allTermlist is not the set of all types" : stdgo.GoString));
        };
    }
function testTermlistString(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        for (__0 => _want in (new stdgo.Slice<stdgo.GoString>(
9,
9,
("∅" : stdgo.GoString),
("𝓤" : stdgo.GoString),
("int" : stdgo.GoString),
("~int" : stdgo.GoString),
("myInt" : stdgo.GoString),
("∅ | ∅" : stdgo.GoString),
("𝓤 | 𝓤" : stdgo.GoString),
("∅ | 𝓤 | int" : stdgo.GoString),
("∅ | 𝓤 | int | myInt" : stdgo.GoString)) : stdgo.Slice<stdgo.GoString>)) {
            {
                var _got:stdgo.GoString = (_maketl(_want?.__copy__()).string() : stdgo.GoString)?.__copy__();
                if (_got != (_want)) {
                    _t.errorf(("(%v).String() == %v" : stdgo.GoString), stdgo.Go.toInterface(_want), stdgo.Go.toInterface(_got));
                };
            };
        };
    }
function testTermlistIsEmpty(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        for (_test => _want in ({
            final x = new stdgo.GoMap.GoStringMap<Bool>();
            x.__defaultValue__ = () -> false;
            @:mergeBlock {
                x.set(("∅" : stdgo.GoString), true);
                x.set(("∅ | ∅" : stdgo.GoString), true);
                x.set(("∅ | ∅ | 𝓤" : stdgo.GoString), false);
                x.set(("∅ | ∅ | myInt" : stdgo.GoString), false);
                x.set(("𝓤" : stdgo.GoString), false);
                x.set(("𝓤 | int" : stdgo.GoString), false);
                x.set(("𝓤 | myInt | ∅" : stdgo.GoString), false);
            };
            x;
        } : stdgo.GoMap<stdgo.GoString, Bool>)) {
            var _xl:stdgo.go.types.Types.T_termlist = _maketl(_test?.__copy__());
            var _got:Bool = _xl._isEmpty();
            if (_got != (_want)) {
                _t.errorf(("(%v).isEmpty() == %v; want %v" : stdgo.GoString), stdgo.Go.toInterface(_test), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_want));
            };
        };
    }
function testTermlistIsAll(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        for (_test => _want in ({
            final x = new stdgo.GoMap.GoStringMap<Bool>();
            x.__defaultValue__ = () -> false;
            @:mergeBlock {
                x.set(("∅" : stdgo.GoString), false);
                x.set(("∅ | ∅" : stdgo.GoString), false);
                x.set(("int | ~string" : stdgo.GoString), false);
                x.set(("~int | myInt" : stdgo.GoString), false);
                x.set(("∅ | ∅ | 𝓤" : stdgo.GoString), true);
                x.set(("𝓤" : stdgo.GoString), true);
                x.set(("𝓤 | int" : stdgo.GoString), true);
                x.set(("myInt | 𝓤" : stdgo.GoString), true);
            };
            x;
        } : stdgo.GoMap<stdgo.GoString, Bool>)) {
            var _xl:stdgo.go.types.Types.T_termlist = _maketl(_test?.__copy__());
            var _got:Bool = _xl._isAll();
            if (_got != (_want)) {
                _t.errorf(("(%v).isAll() == %v; want %v" : stdgo.GoString), stdgo.Go.toInterface(_test), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_want));
            };
        };
    }
function testTermlistNorm(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        for (__0 => _test in (new stdgo.Slice<T__struct_2>(
12,
12,
({ _xl : ("∅" : stdgo.GoString), _want : ("∅" : stdgo.GoString) } : T__struct_2),
({ _xl : ("∅ | ∅" : stdgo.GoString), _want : ("∅" : stdgo.GoString) } : T__struct_2),
({ _xl : ("∅ | int" : stdgo.GoString), _want : ("int" : stdgo.GoString) } : T__struct_2),
({ _xl : ("∅ | myInt" : stdgo.GoString), _want : ("myInt" : stdgo.GoString) } : T__struct_2),
({ _xl : ("𝓤 | int" : stdgo.GoString), _want : ("𝓤" : stdgo.GoString) } : T__struct_2),
({ _xl : ("𝓤 | myInt" : stdgo.GoString), _want : ("𝓤" : stdgo.GoString) } : T__struct_2),
({ _xl : ("int | myInt" : stdgo.GoString), _want : ("int | myInt" : stdgo.GoString) } : T__struct_2),
({ _xl : ("~int | int" : stdgo.GoString), _want : ("~int" : stdgo.GoString) } : T__struct_2),
({ _xl : ("~int | myInt" : stdgo.GoString), _want : ("~int" : stdgo.GoString) } : T__struct_2),
({ _xl : ("int | ~string | int" : stdgo.GoString), _want : ("int | ~string" : stdgo.GoString) } : T__struct_2),
({ _xl : ("~int | string | 𝓤 | ~string | int" : stdgo.GoString), _want : ("𝓤" : stdgo.GoString) } : T__struct_2),
({ _xl : ("~int | string | myInt | ~string | int" : stdgo.GoString), _want : ("~int | ~string" : stdgo.GoString) } : T__struct_2)) : stdgo.Slice<T__struct_2>)) {
            var _xl:stdgo.go.types.Types.T_termlist = _maketl(_test._xl?.__copy__());
            var _got:stdgo.go.types.Types.T_termlist = _maketl(_test._xl?.__copy__())._norm();
            if ((_got.string() : stdgo.GoString) != (_test._want)) {
                _t.errorf(("(%v).norm() = %v; want %v" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_xl)), stdgo.Go.toInterface(stdgo.Go.asInterface(_got)), stdgo.Go.toInterface(_test._want));
            };
        };
    }
function testTermlistUnion(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        for (__0 => _test in (new stdgo.Slice<T__struct_3>(
14,
14,
({ _xl : ("∅" : stdgo.GoString), _yl : ("∅" : stdgo.GoString), _want : ("∅" : stdgo.GoString) } : T__struct_3),
({ _xl : ("∅" : stdgo.GoString), _yl : ("𝓤" : stdgo.GoString), _want : ("𝓤" : stdgo.GoString) } : T__struct_3),
({ _xl : ("∅" : stdgo.GoString), _yl : ("int" : stdgo.GoString), _want : ("int" : stdgo.GoString) } : T__struct_3),
({ _xl : ("𝓤" : stdgo.GoString), _yl : ("~int" : stdgo.GoString), _want : ("𝓤" : stdgo.GoString) } : T__struct_3),
({ _xl : ("int" : stdgo.GoString), _yl : ("~int" : stdgo.GoString), _want : ("~int" : stdgo.GoString) } : T__struct_3),
({ _xl : ("int" : stdgo.GoString), _yl : ("string" : stdgo.GoString), _want : ("int | string" : stdgo.GoString) } : T__struct_3),
({ _xl : ("int" : stdgo.GoString), _yl : ("myInt" : stdgo.GoString), _want : ("int | myInt" : stdgo.GoString) } : T__struct_3),
({ _xl : ("~int" : stdgo.GoString), _yl : ("myInt" : stdgo.GoString), _want : ("~int" : stdgo.GoString) } : T__struct_3),
({ _xl : ("int | string" : stdgo.GoString), _yl : ("~string" : stdgo.GoString), _want : ("int | ~string" : stdgo.GoString) } : T__struct_3),
({ _xl : ("~int | string" : stdgo.GoString), _yl : ("~string | int" : stdgo.GoString), _want : ("~int | ~string" : stdgo.GoString) } : T__struct_3),
({ _xl : ("~int | string | ∅" : stdgo.GoString), _yl : ("~string | int" : stdgo.GoString), _want : ("~int | ~string" : stdgo.GoString) } : T__struct_3),
({ _xl : ("~int | myInt | ∅" : stdgo.GoString), _yl : ("~string | int" : stdgo.GoString), _want : ("~int | ~string" : stdgo.GoString) } : T__struct_3),
({ _xl : ("~int | string | 𝓤" : stdgo.GoString), _yl : ("~string | int" : stdgo.GoString), _want : ("𝓤" : stdgo.GoString) } : T__struct_3),
({ _xl : ("~int | string | myInt" : stdgo.GoString), _yl : ("~string | int" : stdgo.GoString), _want : ("~int | ~string" : stdgo.GoString) } : T__struct_3)) : stdgo.Slice<T__struct_3>)) {
            var _xl:stdgo.go.types.Types.T_termlist = _maketl(_test._xl?.__copy__());
            var _yl:stdgo.go.types.Types.T_termlist = _maketl(_test._yl?.__copy__());
            var _got:stdgo.GoString = (_xl._union(_yl).string() : stdgo.GoString)?.__copy__();
            if (_got != (_test._want)) {
                _t.errorf(("(%v).union(%v) = %v; want %v" : stdgo.GoString), stdgo.Go.toInterface(_test._xl), stdgo.Go.toInterface(_test._yl), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_test._want));
            };
        };
    }
function testTermlistIntersect(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        for (__0 => _test in (new stdgo.Slice<T__struct_3>(
16,
16,
({ _xl : ("∅" : stdgo.GoString), _yl : ("∅" : stdgo.GoString), _want : ("∅" : stdgo.GoString) } : T__struct_3),
({ _xl : ("∅" : stdgo.GoString), _yl : ("𝓤" : stdgo.GoString), _want : ("∅" : stdgo.GoString) } : T__struct_3),
({ _xl : ("∅" : stdgo.GoString), _yl : ("int" : stdgo.GoString), _want : ("∅" : stdgo.GoString) } : T__struct_3),
({ _xl : ("∅" : stdgo.GoString), _yl : ("myInt" : stdgo.GoString), _want : ("∅" : stdgo.GoString) } : T__struct_3),
({ _xl : ("𝓤" : stdgo.GoString), _yl : ("~int" : stdgo.GoString), _want : ("~int" : stdgo.GoString) } : T__struct_3),
({ _xl : ("𝓤" : stdgo.GoString), _yl : ("myInt" : stdgo.GoString), _want : ("myInt" : stdgo.GoString) } : T__struct_3),
({ _xl : ("int" : stdgo.GoString), _yl : ("~int" : stdgo.GoString), _want : ("int" : stdgo.GoString) } : T__struct_3),
({ _xl : ("int" : stdgo.GoString), _yl : ("string" : stdgo.GoString), _want : ("∅" : stdgo.GoString) } : T__struct_3),
({ _xl : ("int" : stdgo.GoString), _yl : ("myInt" : stdgo.GoString), _want : ("∅" : stdgo.GoString) } : T__struct_3),
({ _xl : ("~int" : stdgo.GoString), _yl : ("myInt" : stdgo.GoString), _want : ("myInt" : stdgo.GoString) } : T__struct_3),
({ _xl : ("int | string" : stdgo.GoString), _yl : ("~string" : stdgo.GoString), _want : ("string" : stdgo.GoString) } : T__struct_3),
({ _xl : ("~int | string" : stdgo.GoString), _yl : ("~string | int" : stdgo.GoString), _want : ("int | string" : stdgo.GoString) } : T__struct_3),
({ _xl : ("~int | string | ∅" : stdgo.GoString), _yl : ("~string | int" : stdgo.GoString), _want : ("int | string" : stdgo.GoString) } : T__struct_3),
({ _xl : ("~int | myInt | ∅" : stdgo.GoString), _yl : ("~string | int" : stdgo.GoString), _want : ("int" : stdgo.GoString) } : T__struct_3),
({ _xl : ("~int | string | 𝓤" : stdgo.GoString), _yl : ("~string | int" : stdgo.GoString), _want : ("int | ~string" : stdgo.GoString) } : T__struct_3),
({ _xl : ("~int | string | myInt" : stdgo.GoString), _yl : ("~string | int" : stdgo.GoString), _want : ("int | string" : stdgo.GoString) } : T__struct_3)) : stdgo.Slice<T__struct_3>)) {
            var _xl:stdgo.go.types.Types.T_termlist = _maketl(_test._xl?.__copy__());
            var _yl:stdgo.go.types.Types.T_termlist = _maketl(_test._yl?.__copy__());
            var _got:stdgo.GoString = (_xl._intersect(_yl).string() : stdgo.GoString)?.__copy__();
            if (_got != (_test._want)) {
                _t.errorf(("(%v).intersect(%v) = %v; want %v" : stdgo.GoString), stdgo.Go.toInterface(_test._xl), stdgo.Go.toInterface(_test._yl), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_test._want));
            };
        };
    }
function testTermlistEqual(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        for (__0 => _test in (new stdgo.Slice<T__struct_4>(
9,
9,
({ _xl : ("∅" : stdgo.GoString), _yl : ("∅" : stdgo.GoString), _want : true } : T__struct_4),
({ _xl : ("∅" : stdgo.GoString), _yl : ("𝓤" : stdgo.GoString), _want : false } : T__struct_4),
({ _xl : ("𝓤" : stdgo.GoString), _yl : ("𝓤" : stdgo.GoString), _want : true } : T__struct_4),
({ _xl : ("𝓤 | int" : stdgo.GoString), _yl : ("𝓤" : stdgo.GoString), _want : true } : T__struct_4),
({ _xl : ("𝓤 | int" : stdgo.GoString), _yl : ("string | 𝓤" : stdgo.GoString), _want : true } : T__struct_4),
({ _xl : ("𝓤 | myInt" : stdgo.GoString), _yl : ("string | 𝓤" : stdgo.GoString), _want : true } : T__struct_4),
({ _xl : ("int | ~string" : stdgo.GoString), _yl : ("string | int" : stdgo.GoString), _want : false } : T__struct_4),
({ _xl : ("~int | string" : stdgo.GoString), _yl : ("string | myInt" : stdgo.GoString), _want : false } : T__struct_4),
({ _xl : ("int | ~string | ∅" : stdgo.GoString), _yl : ("string | int | ~string" : stdgo.GoString), _want : true } : T__struct_4)) : stdgo.Slice<T__struct_4>)) {
            var _xl:stdgo.go.types.Types.T_termlist = _maketl(_test._xl?.__copy__());
            var _yl:stdgo.go.types.Types.T_termlist = _maketl(_test._yl?.__copy__());
            var _got:Bool = _xl._equal(_yl);
            if (_got != (_test._want)) {
                _t.errorf(("(%v).equal(%v) = %v; want %v" : stdgo.GoString), stdgo.Go.toInterface(_test._xl), stdgo.Go.toInterface(_test._yl), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_test._want));
            };
        };
    }
function testTermlistIncludes(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        for (__0 => _test in (new stdgo.Slice<T__struct_5>(
11,
11,
({ _xl : ("∅" : stdgo.GoString), _typ : ("int" : stdgo.GoString), _want : false } : T__struct_5),
({ _xl : ("𝓤" : stdgo.GoString), _typ : ("int" : stdgo.GoString), _want : true } : T__struct_5),
({ _xl : ("~int" : stdgo.GoString), _typ : ("int" : stdgo.GoString), _want : true } : T__struct_5),
({ _xl : ("int" : stdgo.GoString), _typ : ("string" : stdgo.GoString), _want : false } : T__struct_5),
({ _xl : ("~int" : stdgo.GoString), _typ : ("string" : stdgo.GoString), _want : false } : T__struct_5),
({ _xl : ("~int" : stdgo.GoString), _typ : ("myInt" : stdgo.GoString), _want : true } : T__struct_5),
({ _xl : ("int | string" : stdgo.GoString), _typ : ("string" : stdgo.GoString), _want : true } : T__struct_5),
({ _xl : ("~int | string" : stdgo.GoString), _typ : ("int" : stdgo.GoString), _want : true } : T__struct_5),
({ _xl : ("~int | string" : stdgo.GoString), _typ : ("myInt" : stdgo.GoString), _want : true } : T__struct_5),
({ _xl : ("~int | myInt | ∅" : stdgo.GoString), _typ : ("myInt" : stdgo.GoString), _want : true } : T__struct_5),
({ _xl : ("myInt | ∅ | 𝓤" : stdgo.GoString), _typ : ("int" : stdgo.GoString), _want : true } : T__struct_5)) : stdgo.Slice<T__struct_5>)) {
            var _xl:stdgo.go.types.Types.T_termlist = _maketl(_test._xl?.__copy__());
            var _yl:stdgo.go.types.Types.Type_ = _testTerm(_test._typ?.__copy__())._typ;
            var _got:Bool = _xl._includes(_yl);
            if (_got != (_test._want)) {
                _t.errorf(("(%v).includes(%v) = %v; want %v" : stdgo.GoString), stdgo.Go.toInterface(_test._xl), stdgo.Go.toInterface(_yl), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_test._want));
            };
        };
    }
function testTermlistSupersetOf(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        for (__0 => _test in (new stdgo.Slice<T__struct_5>(
21,
21,
({ _xl : ("∅" : stdgo.GoString), _typ : ("∅" : stdgo.GoString), _want : true } : T__struct_5),
({ _xl : ("∅" : stdgo.GoString), _typ : ("𝓤" : stdgo.GoString), _want : false } : T__struct_5),
({ _xl : ("∅" : stdgo.GoString), _typ : ("int" : stdgo.GoString), _want : false } : T__struct_5),
({ _xl : ("𝓤" : stdgo.GoString), _typ : ("∅" : stdgo.GoString), _want : true } : T__struct_5),
({ _xl : ("𝓤" : stdgo.GoString), _typ : ("𝓤" : stdgo.GoString), _want : true } : T__struct_5),
({ _xl : ("𝓤" : stdgo.GoString), _typ : ("int" : stdgo.GoString), _want : true } : T__struct_5),
({ _xl : ("𝓤" : stdgo.GoString), _typ : ("~int" : stdgo.GoString), _want : true } : T__struct_5),
({ _xl : ("𝓤" : stdgo.GoString), _typ : ("myInt" : stdgo.GoString), _want : true } : T__struct_5),
({ _xl : ("~int" : stdgo.GoString), _typ : ("int" : stdgo.GoString), _want : true } : T__struct_5),
({ _xl : ("~int" : stdgo.GoString), _typ : ("~int" : stdgo.GoString), _want : true } : T__struct_5),
({ _xl : ("~int" : stdgo.GoString), _typ : ("myInt" : stdgo.GoString), _want : true } : T__struct_5),
({ _xl : ("int" : stdgo.GoString), _typ : ("~int" : stdgo.GoString), _want : false } : T__struct_5),
({ _xl : ("myInt" : stdgo.GoString), _typ : ("~int" : stdgo.GoString), _want : false } : T__struct_5),
({ _xl : ("int" : stdgo.GoString), _typ : ("string" : stdgo.GoString), _want : false } : T__struct_5),
({ _xl : ("~int" : stdgo.GoString), _typ : ("string" : stdgo.GoString), _want : false } : T__struct_5),
({ _xl : ("int | string" : stdgo.GoString), _typ : ("string" : stdgo.GoString), _want : true } : T__struct_5),
({ _xl : ("int | string" : stdgo.GoString), _typ : ("~string" : stdgo.GoString), _want : false } : T__struct_5),
({ _xl : ("~int | string" : stdgo.GoString), _typ : ("int" : stdgo.GoString), _want : true } : T__struct_5),
({ _xl : ("~int | string" : stdgo.GoString), _typ : ("myInt" : stdgo.GoString), _want : true } : T__struct_5),
({ _xl : ("~int | string | ∅" : stdgo.GoString), _typ : ("string" : stdgo.GoString), _want : true } : T__struct_5),
({ _xl : ("~string | ∅ | 𝓤" : stdgo.GoString), _typ : ("myInt" : stdgo.GoString), _want : true } : T__struct_5)) : stdgo.Slice<T__struct_5>)) {
            var _xl:stdgo.go.types.Types.T_termlist = _maketl(_test._xl?.__copy__());
            var _y = _testTerm(_test._typ?.__copy__());
            var _got:Bool = _xl._supersetOf(_y);
            if (_got != (_test._want)) {
                _t.errorf(("(%v).supersetOf(%v) = %v; want %v" : stdgo.GoString), stdgo.Go.toInterface(_test._xl), stdgo.Go.toInterface(stdgo.Go.asInterface(_y)), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_test._want));
            };
        };
    }
function testTermlistSubsetOf(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        for (__0 => _test in (new stdgo.Slice<T__struct_4>(
16,
16,
({ _xl : ("∅" : stdgo.GoString), _yl : ("∅" : stdgo.GoString), _want : true } : T__struct_4),
({ _xl : ("∅" : stdgo.GoString), _yl : ("𝓤" : stdgo.GoString), _want : true } : T__struct_4),
({ _xl : ("𝓤" : stdgo.GoString), _yl : ("∅" : stdgo.GoString), _want : false } : T__struct_4),
({ _xl : ("𝓤" : stdgo.GoString), _yl : ("𝓤" : stdgo.GoString), _want : true } : T__struct_4),
({ _xl : ("int" : stdgo.GoString), _yl : ("int | string" : stdgo.GoString), _want : true } : T__struct_4),
({ _xl : ("~int" : stdgo.GoString), _yl : ("int | string" : stdgo.GoString), _want : false } : T__struct_4),
({ _xl : ("~int" : stdgo.GoString), _yl : ("myInt | string" : stdgo.GoString), _want : false } : T__struct_4),
({ _xl : ("myInt" : stdgo.GoString), _yl : ("~int | string" : stdgo.GoString), _want : true } : T__struct_4),
({ _xl : ("~int" : stdgo.GoString), _yl : ("string | string | int | ~int" : stdgo.GoString), _want : true } : T__struct_4),
({ _xl : ("myInt" : stdgo.GoString), _yl : ("string | string | ~int" : stdgo.GoString), _want : true } : T__struct_4),
({ _xl : ("int | string" : stdgo.GoString), _yl : ("string" : stdgo.GoString), _want : false } : T__struct_4),
({ _xl : ("int | string" : stdgo.GoString), _yl : ("string | int" : stdgo.GoString), _want : true } : T__struct_4),
({ _xl : ("int | ~string" : stdgo.GoString), _yl : ("string | int" : stdgo.GoString), _want : false } : T__struct_4),
({ _xl : ("myInt | ~string" : stdgo.GoString), _yl : ("string | int | 𝓤" : stdgo.GoString), _want : true } : T__struct_4),
({ _xl : ("int | ~string" : stdgo.GoString), _yl : ("string | int | ∅ | string" : stdgo.GoString), _want : false } : T__struct_4),
({ _xl : ("int | myInt" : stdgo.GoString), _yl : ("string | ~int | ∅ | string" : stdgo.GoString), _want : true } : T__struct_4)) : stdgo.Slice<T__struct_4>)) {
            var _xl:stdgo.go.types.Types.T_termlist = _maketl(_test._xl?.__copy__());
            var _yl:stdgo.go.types.Types.T_termlist = _maketl(_test._yl?.__copy__());
            var _got:Bool = _xl._subsetOf(_yl);
            if (_got != (_test._want)) {
                _t.errorf(("(%v).subsetOf(%v) = %v; want %v" : stdgo.GoString), stdgo.Go.toInterface(_test._xl), stdgo.Go.toInterface(_test._yl), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_test._want));
            };
        };
    }
function testZeroTok(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        var _zero:stdgo.go.token.Token.Token = ((0 : stdgo.GoInt) : stdgo.go.token.Token.Token);
        if ((0 : stdgo.go.token.Token.Token) != (_zero)) {
            _t.errorf(("%s == %d; want 0" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface((0 : stdgo.go.token.Token.Token))), stdgo.Go.toInterface(stdgo.Go.asInterface(_zero)));
        };
    }
function testAssignOp(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        {
            var _i:stdgo.GoInt = (0 : stdgo.GoInt);
            stdgo.Go.cfor(_i < (256 : stdgo.GoInt), _i++, {
                var _tok:stdgo.go.token.Token.Token = (_i : stdgo.go.token.Token.Token);
                var _got:stdgo.go.token.Token.Token = _assignOp(_tok);
                var _want:stdgo.go.token.Token.Token = (_assignOps[_tok] ?? ((0 : stdgo.GoInt) : stdgo.go.token.Token.Token));
                if (_got != (_want)) {
                    _t.errorf(("for assignOp(%s): got %s; want %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_tok)), stdgo.Go.toInterface(stdgo.Go.asInterface(_got)), stdgo.Go.toInterface(stdgo.Go.asInterface(_want)));
                };
            });
        };
    }
/**
    // NewTuple returns a new tuple for the given variables.
**/
function newTuple(_x:haxe.Rest<stdgo.Ref<Var>>):stdgo.Ref<Tuple> {
        var _x = new stdgo.Slice<stdgo.Ref<Var>>(_x.length, 0, ..._x);
        if ((_x.length) > (0 : stdgo.GoInt)) {
            return (stdgo.Go.setRef(({ _vars : _x } : stdgo.go.types.Types.Tuple)) : stdgo.Ref<stdgo.go.types.Types.Tuple>);
        };
        return null;
    }
/**
    // newTypeList returns a new TypeList with the types in list.
**/
function _newTypeList(_list:stdgo.Slice<Type_>):stdgo.Ref<TypeList> {
        if ((_list.length) == ((0 : stdgo.GoInt))) {
            return null;
        };
        return (stdgo.Go.setRef((new stdgo.go.types.Types.TypeList(_list) : stdgo.go.types.Types.TypeList)) : stdgo.Ref<stdgo.go.types.Types.TypeList>);
    }
function _bindTParams(_list:stdgo.Slice<stdgo.Ref<TypeParam>>):stdgo.Ref<TypeParamList> {
        if ((_list.length) == ((0 : stdgo.GoInt))) {
            return null;
        };
        for (_i => _typ in _list) {
            if (_typ._index >= (0 : stdgo.GoInt)) {
                throw stdgo.Go.toInterface(("type parameter bound more than once" : stdgo.GoString));
            };
            _typ._index = _i;
        };
        return (stdgo.Go.setRef(({ _tparams : _list } : stdgo.go.types.Types.TypeParamList)) : stdgo.Ref<stdgo.go.types.Types.TypeParamList>);
    }
/**
    // nextID returns a value increasing monotonically by 1 with
    // each call, starting with 1. It may be called concurrently.
**/
function _nextID():stdgo.GoUInt64 {
        return (stdgo.sync.atomic_.Atomic_.addUint32(stdgo.Go.pointer(_lastID), (1u32 : stdgo.GoUInt32)) : stdgo.GoUInt64);
    }
/**
    // NewTypeParam returns a new TypeParam. Type parameters may be set on a Named
    // or Signature type by calling SetTypeParams. Setting a type parameter on more
    // than one type will result in a panic.
    //
    // The constraint argument can be nil, and set later via SetConstraint. If the
    // constraint is non-nil, it must be fully defined.
**/
function newTypeParam(_obj:stdgo.Ref<TypeName>, _constraint:Type_):stdgo.Ref<TypeParam> {
        return ((null : stdgo.Ref<stdgo.go.types.Types.Checker>) : stdgo.Ref<Checker>)._newTypeParam(_obj, _constraint);
    }
/**
    // computeInterfaceTypeSet may be called with check == nil.
**/
function _computeInterfaceTypeSet(_check:stdgo.Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _ityp:stdgo.Ref<Interface>):stdgo.Ref<T__TypeSet> {
        var __deferstack__:Array<Void -> Void> = [];
        try {
            if (_ityp._tset != null && ((_ityp._tset : Dynamic).__nil__ == null || !(_ityp._tset : Dynamic).__nil__)) {
                return _ityp._tset;
            };
            if (!_ityp._complete) {
                return (stdgo.Go.setRef(_topTypeSet) : stdgo.Ref<stdgo.go.types.Types.T__TypeSet>);
            };
            if (((_check != null) && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) && _check._conf.__Trace) {
                if (!_pos.isValid() && (_ityp._methods.length > (0 : stdgo.GoInt))) {
                    _pos = _ityp._methods[(0 : stdgo.GoInt)]._object._pos;
                };
                _check._trace(_pos, ("-- type set for %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_ityp)));
                _check._indent++;
                __deferstack__.unshift(() -> {
                    var a = function():Void {
                        _check._indent--;
                        _check._trace(_pos, ("=> %s " : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_ityp._typeSet())));
                    };
                    a();
                });
            };
            _ityp._tset = (stdgo.Go.setRef(({ _terms : _allTermlist } : stdgo.go.types.Types.T__TypeSet)) : stdgo.Ref<stdgo.go.types.Types.T__TypeSet>);
            var _unionSets:stdgo.GoMap<stdgo.Ref<Union>, stdgo.Ref<T__TypeSet>> = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Union>, stdgo.Ref<stdgo.go.types.Types.T__TypeSet>>);
            if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
                if (_check._unionTypeSets == null) {
                    _check._unionTypeSets = ({
                        final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.types.Types.Union>, stdgo.Ref<stdgo.go.types.Types.T__TypeSet>>();
                        @:mergeBlock {};
                        cast x;
                    } : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Union>, stdgo.Ref<stdgo.go.types.Types.T__TypeSet>>);
                };
                _unionSets = _check._unionTypeSets;
            } else {
                _unionSets = ({
                    final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.types.Types.Union>, stdgo.Ref<stdgo.go.types.Types.T__TypeSet>>();
                    @:mergeBlock {};
                    cast x;
                } : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Union>, stdgo.Ref<stdgo.go.types.Types.T__TypeSet>>);
            };
            var _seen:T_objset = (null : stdgo.go.types.Types.T_objset);
            var _allMethods:stdgo.Slice<stdgo.Ref<Func>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>);
            var _mpos = ({
                final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.types.Types.Func>, stdgo.go.token.Token.Pos>();
                @:mergeBlock {};
                cast x;
            } : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Func>, stdgo.go.token.Token.Pos>);
            var _addMethod = function(_pos:stdgo.go.token.Token.Pos, _m:stdgo.Ref<Func>, _explicit:Bool):Void {
                {
                    var _other:stdgo.go.types.Types.Object = _seen._insert(stdgo.Go.asInterface(_m));
                    if (_other == null) {
                        _allMethods = (_allMethods.__append__(_m));
                        _mpos[_m] = _pos;
                    } else if (_explicit) {
                        if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
                            _check._errorf(stdgo.Go.asInterface((_pos : T_atPos)), (10 : stdgo.internal.types.errors.Errors.Code), ("duplicate method %s" : stdgo.GoString), stdgo.Go.toInterface(_m._object._name));
                            _check._errorf(stdgo.Go.asInterface((_mpos[(stdgo.Go.typeAssert((stdgo.Go.toInterface(_other) : stdgo.Ref<Func>)) : stdgo.Ref<Func>)] ?? ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos) : T_atPos)), (10 : stdgo.internal.types.errors.Errors.Code), ("\tother declaration of %s" : stdgo.GoString), stdgo.Go.toInterface(_m._object._name));
                        };
                    } else {
                        if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
                            _check._later(function():Void {
                                if (!_check._allowVersion(_m._object._pkg, stdgo.Go.asInterface((_pos : T_atPos)), _go1_14?.__copy__()) || !identical(_m._object._typ, _other.type())) {
                                    _check._errorf(stdgo.Go.asInterface((_pos : T_atPos)), (10 : stdgo.internal.types.errors.Errors.Code), ("duplicate method %s" : stdgo.GoString), stdgo.Go.toInterface(_m._object._name));
                                    _check._errorf(stdgo.Go.asInterface((_mpos[(stdgo.Go.typeAssert((stdgo.Go.toInterface(_other) : stdgo.Ref<Func>)) : stdgo.Ref<Func>)] ?? ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos) : T_atPos)), (10 : stdgo.internal.types.errors.Errors.Code), ("\tother declaration of %s" : stdgo.GoString), stdgo.Go.toInterface(_m._object._name));
                                };
                            })._describef(stdgo.Go.asInterface((_pos : T_atPos)), ("duplicate method check for %s" : stdgo.GoString), stdgo.Go.toInterface(_m._object._name));
                        };
                    };
                };
            };
            for (__104 => _m in _ityp._methods) {
                _addMethod(_m._object._pos, _m, true);
            };
            var _allTerms:stdgo.go.types.Types.T_termlist = _allTermlist;
            var _allComparable:Bool = false;
            for (_i => _typ in _ityp._embeddeds) {
                var _pos:stdgo.go.token.Token.Pos = ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos);
                if (_ityp._embedPos != null && ((_ityp._embedPos : Dynamic).__nil__ == null || !(_ityp._embedPos : Dynamic).__nil__)) {
                    _pos = ((_ityp._embedPos : stdgo.Slice<stdgo.go.token.Token.Pos>))[(_i : stdgo.GoInt)];
                };
                var _comparable:Bool = false;
                var _terms:T_termlist = new stdgo.go.types.Types.T_termlist(0, 0);
                {
                    final __type__ = _under(_typ);
                    if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                        var _u:stdgo.Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                        _assert(!_isTypeParam(_typ));
                        var _tset = _computeInterfaceTypeSet(_check, _pos, _u);
                        if ((((_check != null) && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) && _check._isImportedConstraint(_typ)) && !_check._verifyVersionf(stdgo.Go.asInterface((_pos : T_atPos)), _go1_18?.__copy__(), ("embedding constraint interface %s" : stdgo.GoString), stdgo.Go.toInterface(_typ))) {
                            continue;
                        };
                        _comparable = _tset._comparable;
                        for (__145 => _m in _tset._methods) {
                            _addMethod(_pos, _m, false);
                        };
                        _terms = _tset._terms;
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Union>))) {
                        var _u:stdgo.Ref<stdgo.go.types.Types.Union> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Union>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__().value;
                        if (((_check != null) && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) && !_check._verifyVersionf(stdgo.Go.asInterface((_pos : T_atPos)), _go1_18?.__copy__(), ("embedding interface element %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_u)))) {
                            continue;
                        };
                        var _tset = _computeUnionTypeSet(_check, _unionSets, _pos, _u);
                        if (_tset == ((stdgo.Go.setRef(_invalidTypeSet) : stdgo.Ref<stdgo.go.types.Types.T__TypeSet>))) {
                            continue;
                        };
                        _assert(!_tset._comparable);
                        _assert((_tset._methods.length) == ((0 : stdgo.GoInt)));
                        _terms = _tset._terms;
                    } else {
                        var _u:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                        if (stdgo.Go.toInterface(_u) == (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                            continue;
                        };
                        if (((_check != null) && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) && !_check._verifyVersionf(stdgo.Go.asInterface((_pos : T_atPos)), _go1_18?.__copy__(), ("embedding non-interface type %s" : stdgo.GoString), stdgo.Go.toInterface(_typ))) {
                            continue;
                        };
                        _terms = (new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_term>>(1, 1, (new stdgo.go.types.Types.T_term(false, _typ) : stdgo.go.types.Types.T_term)) : stdgo.go.types.Types.T_termlist);
                    };
                };
                {
                    var __tmp__ = _intersectTermLists(_allTerms, _allComparable, _terms, _comparable);
                    _allTerms = __tmp__._0;
                    _allComparable = __tmp__._1;
                };
            };
            _ityp._embedPos = (null : stdgo.Ref<stdgo.Slice<stdgo.go.token.Token.Pos>>);
            _ityp._tset._comparable = _allComparable;
            if ((_allMethods.length) != ((0 : stdgo.GoInt))) {
                _sortMethods(_allMethods);
                _ityp._tset._methods = _allMethods;
            };
            _ityp._tset._terms = _allTerms;
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _ityp._tset;
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return (null : stdgo.Ref<stdgo.go.types.Types.T__TypeSet>);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return (null : stdgo.Ref<stdgo.go.types.Types.T__TypeSet>);
        };
    }
/**
    // intersectTermLists computes the intersection of two term lists and respective comparable bits.
    // xcomp, ycomp are valid only if xterms.isAll() and yterms.isAll() respectively.
**/
function _intersectTermLists(_xterms:T_termlist, _xcomp:Bool, _yterms:T_termlist, _ycomp:Bool):{ var _0 : T_termlist; var _1 : Bool; } {
        var _terms:stdgo.go.types.Types.T_termlist = _xterms._intersect(_yterms);
        var _comp:Bool = _xcomp || _ycomp;
        if (_comp && !_terms._isAll()) {
            var _i:stdgo.GoInt = (0 : stdgo.GoInt);
            for (__0 => _t in _terms) {
                _assert(_t._typ != null);
                if (_comparable(_t._typ, false, (null : stdgo.GoMap<stdgo.go.types.Types.Type_, Bool>), null)) {
                    _terms[(_i : stdgo.GoInt)] = _t;
                    _i++;
                };
            };
            _terms = (_terms.__slice__(0, _i) : stdgo.go.types.Types.T_termlist);
            if (!_terms._isAll()) {
                _comp = false;
            };
        };
        _assert(!_comp || _terms._isAll());
        return { _0 : _terms, _1 : _comp };
    }
function _sortMethods(_list:stdgo.Slice<stdgo.Ref<Func>>):Void {
        stdgo.sort.Sort.sort(stdgo.Go.asInterface((_list : T_byUniqueMethodName)));
    }
function _assertSortedMethods(_list:stdgo.Slice<stdgo.Ref<Func>>):Void {
        if (true) {
            throw stdgo.Go.toInterface(("assertSortedMethods called outside debug mode" : stdgo.GoString));
        };
        if (!stdgo.sort.Sort.isSorted(stdgo.Go.asInterface((_list : T_byUniqueMethodName)))) {
            throw stdgo.Go.toInterface(("methods not sorted" : stdgo.GoString));
        };
    }
/**
    // computeUnionTypeSet may be called with check == nil.
    // The result is &invalidTypeSet if the union overflows.
**/
function _computeUnionTypeSet(_check:stdgo.Ref<Checker>, _unionSets:stdgo.GoMap<stdgo.Ref<Union>, stdgo.Ref<T__TypeSet>>, _pos:stdgo.go.token.Token.Pos, _utyp:stdgo.Ref<Union>):stdgo.Ref<T__TypeSet> {
        {
            var __tmp__ = (_unionSets != null && _unionSets.exists(_utyp) ? { _0 : _unionSets[_utyp], _1 : true } : { _0 : (null : stdgo.Ref<stdgo.go.types.Types.T__TypeSet>), _1 : false }), _tset:stdgo.Ref<stdgo.go.types.Types.T__TypeSet> = __tmp__._0, __0:Bool = __tmp__._1;
            if (_tset != null && ((_tset : Dynamic).__nil__ == null || !(_tset : Dynamic).__nil__)) {
                return _tset;
            };
        };
        _unionSets[_utyp] = (stdgo.Go.setRef(({} : stdgo.go.types.Types.T__TypeSet)) : stdgo.Ref<stdgo.go.types.Types.T__TypeSet>);
        var _allTerms:T_termlist = new stdgo.go.types.Types.T_termlist(0, 0);
        for (__1 => _t in _utyp._terms) {
            var _terms:T_termlist = new stdgo.go.types.Types.T_termlist(0, 0);
            var _u:stdgo.go.types.Types.Type_ = _under(_t._typ);
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_u) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Interface>), _1 : false };
                }, _ui = __tmp__._0, __2 = __tmp__._1;
                if (_ui != null && ((_ui : Dynamic).__nil__ == null || !(_ui : Dynamic).__nil__)) {
                    _assert(!_isTypeParam(_t._typ));
                    _terms = _computeInterfaceTypeSet(_check, _pos, _ui)._terms;
                } else if (stdgo.Go.toInterface(_u) == (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                    continue;
                } else {
                    if (_t._tilde && !identical(_t._typ, _u)) {
                        _t = null;
                    };
                    _terms = (new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_term>>(1, 1, (({
                        final e = _t;
                        ({ _tilde : e._tilde, _typ : e._typ } : stdgo.go.types.Types.T_term);
                    }))) : stdgo.go.types.Types.T_termlist);
                };
            };
            _allTerms = _allTerms._union(_terms);
            if ((_allTerms.length) > (100 : stdgo.GoInt)) {
                if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
                    _check._errorf(stdgo.Go.asInterface((_pos : T_atPos)), (141 : stdgo.internal.types.errors.Errors.Code), ("cannot handle more than %d union terms (implementation limitation)" : stdgo.GoString), stdgo.Go.toInterface((100 : stdgo.GoInt)));
                };
                _unionSets[_utyp] = (stdgo.Go.setRef(_invalidTypeSet) : stdgo.Ref<stdgo.go.types.Types.T__TypeSet>);
                return (_unionSets[_utyp] ?? (null : stdgo.Ref<stdgo.go.types.Types.T__TypeSet>));
            };
        };
        (_unionSets[_utyp] ?? (null : stdgo.Ref<stdgo.go.types.Types.T__TypeSet>))._terms = _allTerms;
        return (_unionSets[_utyp] ?? (null : stdgo.Ref<stdgo.go.types.Types.T__TypeSet>));
    }
function testInvalidTypeSet(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        if (!_invalidTypeSet.isEmpty()) {
            _t.error(stdgo.Go.toInterface(("invalidTypeSet is not empty" : stdgo.GoString)));
        };
    }
function testTypeSetString(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        for (_body => _want in ({
            final x = new stdgo.GoMap.GoStringMap<stdgo.GoString>();
            x.__defaultValue__ = () -> ("" : stdgo.GoString);
            @:mergeBlock {
                x.set(("{}" : stdgo.GoString), ("𝓤" : stdgo.GoString));
                x.set(("{int}" : stdgo.GoString), ("{int}" : stdgo.GoString));
                x.set(("{~int}" : stdgo.GoString), ("{~int}" : stdgo.GoString));
                x.set(("{int|string}" : stdgo.GoString), ("{int | string}" : stdgo.GoString));
                x.set(("{int; string}" : stdgo.GoString), ("∅" : stdgo.GoString));
                x.set(("{comparable}" : stdgo.GoString), ("{comparable}" : stdgo.GoString));
                x.set(("{comparable; int}" : stdgo.GoString), ("{int}" : stdgo.GoString));
                x.set(("{~int; comparable}" : stdgo.GoString), ("{~int}" : stdgo.GoString));
                x.set(("{int|string; comparable}" : stdgo.GoString), ("{int | string}" : stdgo.GoString));
                x.set(("{comparable; int; string}" : stdgo.GoString), ("∅" : stdgo.GoString));
                x.set(("{m()}" : stdgo.GoString), ("{func (p.T).m()}" : stdgo.GoString));
                x.set(("{m1(); m2() int }" : stdgo.GoString), ("{func (p.T).m1(); func (p.T).m2() int}" : stdgo.GoString));
                x.set(("{error}" : stdgo.GoString), ("{func (error).Error() string}" : stdgo.GoString));
                x.set(("{m(); comparable}" : stdgo.GoString), ("{comparable; func (p.T).m()}" : stdgo.GoString));
                x.set(("{m1(); comparable; m2() int }" : stdgo.GoString), ("{comparable; func (p.T).m1(); func (p.T).m2() int}" : stdgo.GoString));
                x.set(("{comparable; error}" : stdgo.GoString), ("{comparable; func (error).Error() string}" : stdgo.GoString));
                x.set(("{m(); comparable; int|float32|string}" : stdgo.GoString), ("{func (p.T).m(); int | float32 | string}" : stdgo.GoString));
                x.set(("{m1(); int; m2(); comparable }" : stdgo.GoString), ("{func (p.T).m1(); func (p.T).m2(); int}" : stdgo.GoString));
                x.set(("{E}; type E interface{}" : stdgo.GoString), ("𝓤" : stdgo.GoString));
                x.set(("{E}; type E interface{int;string}" : stdgo.GoString), ("∅" : stdgo.GoString));
                x.set(("{E}; type E interface{comparable}" : stdgo.GoString), ("{comparable}" : stdgo.GoString));
            };
            x;
        } : stdgo.GoMap<stdgo.GoString, stdgo.GoString>)) {
            var _src:stdgo.GoString = ("package p; type T interface" : stdgo.GoString) + _body?.__copy__()?.__copy__();
            var _fset = stdgo.go.token.Token.newFileSet();
            var __tmp__ = stdgo.go.parser.Parser.parseFile(_fset, ("p.go" : stdgo.GoString), stdgo.Go.toInterface(_src), (32u32 : stdgo.go.parser.Parser.Mode)), _file:stdgo.Ref<stdgo.go.ast.Ast.File> = __tmp__._0, _err:stdgo.Error = __tmp__._1;
            if (_file == null || (_file : Dynamic).__nil__) {
                _t.fatalf(("%s: %v (invalid test case)" : stdgo.GoString), stdgo.Go.toInterface(_body), stdgo.Go.toInterface(_err));
            };
            var _conf:Config = ({} : stdgo.go.types.Types.Config);
            var __tmp__ = _conf.check(_file.name.name?.__copy__(), _fset, (new stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.File>>(1, 1, _file) : stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.File>>), null), _pkg:stdgo.Ref<stdgo.go.types.Types.Package> = __tmp__._0, _err:stdgo.Error = __tmp__._1;
            if (_err != null) {
                _t.fatalf(("%s: %v (invalid test case)" : stdgo.GoString), stdgo.Go.toInterface(_body), stdgo.Go.toInterface(_err));
            };
            var _obj:stdgo.go.types.Types.Object = _pkg._scope.lookup(("T" : stdgo.GoString));
            if (_obj == null) {
                _t.fatalf(("%s: T not found (invalid test case)" : stdgo.GoString), stdgo.Go.toInterface(_body));
            };
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_obj.type())) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Interface>), _1 : false };
            }, t = __tmp__._0, _ok = __tmp__._1;
            if (!_ok) {
                _t.fatalf(("%s: %v is not an interface (invalid test case)" : stdgo.GoString), stdgo.Go.toInterface(_body), stdgo.Go.toInterface(_obj));
            };
            var _got:stdgo.GoString = (t._typeSet().string() : stdgo.GoString)?.__copy__();
            if (_got != (_want)) {
                _t.errorf(("%s: got %s; want %s" : stdgo.GoString), stdgo.Go.toInterface(_body), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_want));
            };
        };
    }
/**
    // RelativeTo returns a Qualifier that fully qualifies members of
    // all packages other than pkg.
**/
function relativeTo(_pkg:stdgo.Ref<Package>):Qualifier {
        if (_pkg == null || (_pkg : Dynamic).__nil__) {
            return null;
        };
        return function(_other:stdgo.Ref<Package>):stdgo.GoString {
            if (_pkg == (_other)) {
                return stdgo.Go.str()?.__copy__();
            };
            return _other.path()?.__copy__();
        };
    }
/**
    // TypeString returns the string representation of typ.
    // The Qualifier controls the printing of
    // package-level objects, and may be nil.
**/
function typeString(_typ:Type_, _qf:Qualifier):stdgo.GoString {
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        writeType((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.bytes.Bytes.Buffer>), _typ, _qf);
        return (_buf.string() : stdgo.GoString)?.__copy__();
    }
/**
    // WriteType writes the string representation of typ to buf.
    // The Qualifier controls the printing of
    // package-level objects, and may be nil.
**/
function writeType(_buf:stdgo.Ref<stdgo.bytes.Bytes.Buffer>, _typ:Type_, _qf:Qualifier):Void {
        _newTypeWriter(_buf, _qf)._typ(_typ);
    }
/**
    // WriteSignature writes the representation of the signature sig to buf,
    // without a leading "func" keyword. The Qualifier controls the printing
    // of package-level objects, and may be nil.
**/
function writeSignature(_buf:stdgo.Ref<stdgo.bytes.Bytes.Buffer>, _sig:stdgo.Ref<Signature>, _qf:Qualifier):Void {
        _newTypeWriter(_buf, _qf)._signature(_sig);
    }
function _newTypeWriter(_buf:stdgo.Ref<stdgo.bytes.Bytes.Buffer>, _qf:Qualifier):stdgo.Ref<T_typeWriter> {
        return (stdgo.Go.setRef((new stdgo.go.types.Types.T_typeWriter(_buf, ({
            final x = new stdgo.GoMap.GoObjectMap<stdgo.go.types.Types.Type_, Bool>();
            x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Type_", [], stdgo.internal.reflect.Reflect.GoType.named("Type_", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
            x.__defaultValue__ = () -> false;
            @:mergeBlock {};
            cast x;
        } : stdgo.GoMap<stdgo.go.types.Types.Type_, Bool>), _qf, null, null, true, false, false) : stdgo.go.types.Types.T_typeWriter)) : stdgo.Ref<stdgo.go.types.Types.T_typeWriter>);
    }
function _newTypeHasher(_buf:stdgo.Ref<stdgo.bytes.Bytes.Buffer>, _ctxt:stdgo.Ref<Context>):stdgo.Ref<T_typeWriter> {
        _assert(_ctxt != null && ((_ctxt : Dynamic).__nil__ == null || !(_ctxt : Dynamic).__nil__));
        return (stdgo.Go.setRef((new stdgo.go.types.Types.T_typeWriter(_buf, ({
            final x = new stdgo.GoMap.GoObjectMap<stdgo.go.types.Types.Type_, Bool>();
            x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Type_", [], stdgo.internal.reflect.Reflect.GoType.named("Type_", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
            x.__defaultValue__ = () -> false;
            @:mergeBlock {};
            cast x;
        } : stdgo.GoMap<stdgo.go.types.Types.Type_, Bool>), null, _ctxt, null, false, false, false) : stdgo.go.types.Types.T_typeWriter)) : stdgo.Ref<stdgo.go.types.Types.T_typeWriter>);
    }
/**
    // subscript returns the decimal (utf8) representation of x using subscript digits.
**/
function _subscript(_x:stdgo.GoUInt64):stdgo.GoString {
        {};
        var _buf:stdgo.GoArray<stdgo.GoByte> = new stdgo.GoArray<stdgo.GoUInt8>(...[for (i in 0 ... 96) (0 : stdgo.GoUInt8)]);
        var _i:stdgo.GoInt = (_buf.length);
        while (true) {
            _i = _i - ((3 : stdgo.GoInt));
            stdgo.unicode.utf8.Utf8.encodeRune((_buf.__slice__(_i) : stdgo.Slice<stdgo.GoUInt8>), (8320 : stdgo.GoInt32) + (_x % (10i64 : stdgo.GoUInt64) : stdgo.GoRune));
            _x = _x / ((10i64 : stdgo.GoUInt64));
            if (_x == ((0i64 : stdgo.GoUInt64))) {
                break;
            };
        };
        return ((_buf.__slice__(_i) : stdgo.Slice<stdgo.GoUInt8>) : stdgo.GoString)?.__copy__();
    }
function testTermString(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        for (_want => _x in _testTerms) {
            {
                var _got:stdgo.GoString = (_x.string() : stdgo.GoString)?.__copy__();
                if (_got != (_want)) {
                    _t.errorf(("%v.String() == %v; want %v" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_want));
                };
            };
        };
    }
function _split(_s:stdgo.GoString, _n:stdgo.GoInt):stdgo.Slice<stdgo.GoString> {
        var _r = stdgo.strings.Strings.split(_s?.__copy__(), (" " : stdgo.GoString));
        if ((_r.length) != (_n)) {
            throw stdgo.Go.toInterface(("invalid test case: " : stdgo.GoString) + _s?.__copy__());
        };
        return _r;
    }
function _testTerm(_name:stdgo.GoString):stdgo.Ref<T_term> {
        var __tmp__ = (_testTerms != null && _testTerms.exists(_name?.__copy__()) ? { _0 : _testTerms[_name?.__copy__()], _1 : true } : { _0 : (null : stdgo.Ref<stdgo.go.types.Types.T_term>), _1 : false }), _r:stdgo.Ref<stdgo.go.types.Types.T_term> = __tmp__._0, _ok:Bool = __tmp__._1;
        if (!_ok) {
            throw stdgo.Go.toInterface(("invalid test argument: " : stdgo.GoString) + _name?.__copy__());
        };
        return _r;
    }
function testTermEqual(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        for (__0 => _test in (new stdgo.Slice<stdgo.GoString>(
14,
14,
("∅ ∅ T" : stdgo.GoString),
("𝓤 𝓤 T" : stdgo.GoString),
("int int T" : stdgo.GoString),
("~int ~int T" : stdgo.GoString),
("myInt myInt T" : stdgo.GoString),
("∅ 𝓤 F" : stdgo.GoString),
("∅ int F" : stdgo.GoString),
("∅ ~int F" : stdgo.GoString),
("𝓤 int F" : stdgo.GoString),
("𝓤 ~int F" : stdgo.GoString),
("𝓤 myInt F" : stdgo.GoString),
("int ~int F" : stdgo.GoString),
("int myInt F" : stdgo.GoString),
("~int myInt F" : stdgo.GoString)) : stdgo.Slice<stdgo.GoString>)) {
            var _args = _split(_test?.__copy__(), (3 : stdgo.GoInt));
            var _x = _testTerm(_args[(0 : stdgo.GoInt)]?.__copy__());
            var _y = _testTerm(_args[(1 : stdgo.GoInt)]?.__copy__());
            var _want:Bool = _args[(2 : stdgo.GoInt)] == (("T" : stdgo.GoString));
            {
                var _got:Bool = _x._equal(_y);
                if (_got != (_want)) {
                    _t.errorf(("%v.equal(%v) = %v; want %v" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(stdgo.Go.asInterface(_y)), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_want));
                };
            };
            {
                final __tmp__0 = _y;
                final __tmp__1 = _x;
                _x = __tmp__0;
                _y = __tmp__1;
            };
            {
                var _got:Bool = _x._equal(_y);
                if (_got != (_want)) {
                    _t.errorf(("%v.equal(%v) = %v; want %v" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(stdgo.Go.asInterface(_y)), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_want));
                };
            };
        };
    }
function testTermUnion(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        for (__0 => _test in (new stdgo.Slice<stdgo.GoString>(
29,
29,
("∅ ∅ ∅ ∅" : stdgo.GoString),
("∅ 𝓤 𝓤 ∅" : stdgo.GoString),
("∅ int int ∅" : stdgo.GoString),
("∅ ~int ~int ∅" : stdgo.GoString),
("∅ myInt myInt ∅" : stdgo.GoString),
("𝓤 𝓤 𝓤 ∅" : stdgo.GoString),
("𝓤 int 𝓤 ∅" : stdgo.GoString),
("𝓤 ~int 𝓤 ∅" : stdgo.GoString),
("𝓤 myInt 𝓤 ∅" : stdgo.GoString),
("int int int ∅" : stdgo.GoString),
("int ~int ~int ∅" : stdgo.GoString),
("int string int string" : stdgo.GoString),
("int ~string int ~string" : stdgo.GoString),
("int myInt int myInt" : stdgo.GoString),
("~int ~string ~int ~string" : stdgo.GoString),
("~int myInt ~int ∅" : stdgo.GoString),
("𝓤 ∅ 𝓤 ∅" : stdgo.GoString),
("int ∅ int ∅" : stdgo.GoString),
("~int ∅ ~int ∅" : stdgo.GoString),
("myInt ∅ myInt ∅" : stdgo.GoString),
("int 𝓤 𝓤 ∅" : stdgo.GoString),
("~int 𝓤 𝓤 ∅" : stdgo.GoString),
("myInt 𝓤 𝓤 ∅" : stdgo.GoString),
("~int int ~int ∅" : stdgo.GoString),
("string int string int" : stdgo.GoString),
("~string int ~string int" : stdgo.GoString),
("myInt int myInt int" : stdgo.GoString),
("~string ~int ~string ~int" : stdgo.GoString),
("myInt ~int ~int ∅" : stdgo.GoString)) : stdgo.Slice<stdgo.GoString>)) {
            var _args = _split(_test?.__copy__(), (4 : stdgo.GoInt));
            var _x = _testTerm(_args[(0 : stdgo.GoInt)]?.__copy__());
            var _y = _testTerm(_args[(1 : stdgo.GoInt)]?.__copy__());
            var _want1 = _testTerm(_args[(2 : stdgo.GoInt)]?.__copy__());
            var _want2 = _testTerm(_args[(3 : stdgo.GoInt)]?.__copy__());
            {
                var __tmp__ = _x._union(_y), _got1:stdgo.Ref<stdgo.go.types.Types.T_term> = __tmp__._0, _got2:stdgo.Ref<stdgo.go.types.Types.T_term> = __tmp__._1;
                if (!_got1._equal(_want1) || !_got2._equal(_want2)) {
                    _t.errorf(("%v.union(%v) = %v, %v; want %v, %v" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(stdgo.Go.asInterface(_y)), stdgo.Go.toInterface(stdgo.Go.asInterface(_got1)), stdgo.Go.toInterface(stdgo.Go.asInterface(_got2)), stdgo.Go.toInterface(stdgo.Go.asInterface(_want1)), stdgo.Go.toInterface(stdgo.Go.asInterface(_want2)));
                };
            };
        };
    }
function testTermIntersection(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        for (__0 => _test in (new stdgo.Slice<stdgo.GoString>(
16,
16,
("∅ ∅ ∅" : stdgo.GoString),
("∅ 𝓤 ∅" : stdgo.GoString),
("∅ int ∅" : stdgo.GoString),
("∅ ~int ∅" : stdgo.GoString),
("∅ myInt ∅" : stdgo.GoString),
("𝓤 𝓤 𝓤" : stdgo.GoString),
("𝓤 int int" : stdgo.GoString),
("𝓤 ~int ~int" : stdgo.GoString),
("𝓤 myInt myInt" : stdgo.GoString),
("int int int" : stdgo.GoString),
("int ~int int" : stdgo.GoString),
("int string ∅" : stdgo.GoString),
("int ~string ∅" : stdgo.GoString),
("int string ∅" : stdgo.GoString),
("~int ~string ∅" : stdgo.GoString),
("~int myInt myInt" : stdgo.GoString)) : stdgo.Slice<stdgo.GoString>)) {
            var _args = _split(_test?.__copy__(), (3 : stdgo.GoInt));
            var _x = _testTerm(_args[(0 : stdgo.GoInt)]?.__copy__());
            var _y = _testTerm(_args[(1 : stdgo.GoInt)]?.__copy__());
            var _want = _testTerm(_args[(2 : stdgo.GoInt)]?.__copy__());
            {
                var _got = _x._intersect(_y);
                if (!_got._equal(_want)) {
                    _t.errorf(("%v.intersect(%v) = %v; want %v" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(stdgo.Go.asInterface(_y)), stdgo.Go.toInterface(stdgo.Go.asInterface(_got)), stdgo.Go.toInterface(stdgo.Go.asInterface(_want)));
                };
            };
            {
                final __tmp__0 = _y;
                final __tmp__1 = _x;
                _x = __tmp__0;
                _y = __tmp__1;
            };
            {
                var _got = _x._intersect(_y);
                if (!_got._equal(_want)) {
                    _t.errorf(("%v.intersect(%v) = %v; want %v" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(stdgo.Go.asInterface(_y)), stdgo.Go.toInterface(stdgo.Go.asInterface(_got)), stdgo.Go.toInterface(stdgo.Go.asInterface(_want)));
                };
            };
        };
    }
function testTermIncludes(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        for (__0 => _test in (new stdgo.Slice<stdgo.GoString>(8, 8, ("∅ int F" : stdgo.GoString), ("𝓤 int T" : stdgo.GoString), ("int int T" : stdgo.GoString), ("~int int T" : stdgo.GoString), ("~int myInt T" : stdgo.GoString), ("string int F" : stdgo.GoString), ("~string int F" : stdgo.GoString), ("myInt int F" : stdgo.GoString)) : stdgo.Slice<stdgo.GoString>)) {
            var _args = _split(_test?.__copy__(), (3 : stdgo.GoInt));
            var _x = _testTerm(_args[(0 : stdgo.GoInt)]?.__copy__());
            var _y:stdgo.go.types.Types.Type_ = _testTerm(_args[(1 : stdgo.GoInt)]?.__copy__())._typ;
            var _want:Bool = _args[(2 : stdgo.GoInt)] == (("T" : stdgo.GoString));
            {
                var _got:Bool = _x._includes(_y);
                if (_got != (_want)) {
                    _t.errorf(("%v.includes(%v) = %v; want %v" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(_y), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_want));
                };
            };
        };
    }
function testTermSubsetOf(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        for (__0 => _test in (new stdgo.Slice<stdgo.GoString>(
17,
17,
("∅ ∅ T" : stdgo.GoString),
("𝓤 𝓤 T" : stdgo.GoString),
("int int T" : stdgo.GoString),
("~int ~int T" : stdgo.GoString),
("myInt myInt T" : stdgo.GoString),
("∅ 𝓤 T" : stdgo.GoString),
("∅ int T" : stdgo.GoString),
("∅ ~int T" : stdgo.GoString),
("∅ myInt T" : stdgo.GoString),
("𝓤 int F" : stdgo.GoString),
("𝓤 ~int F" : stdgo.GoString),
("𝓤 myInt F" : stdgo.GoString),
("int ~int T" : stdgo.GoString),
("int myInt F" : stdgo.GoString),
("~int myInt F" : stdgo.GoString),
("myInt int F" : stdgo.GoString),
("myInt ~int T" : stdgo.GoString)) : stdgo.Slice<stdgo.GoString>)) {
            var _args = _split(_test?.__copy__(), (3 : stdgo.GoInt));
            var _x = _testTerm(_args[(0 : stdgo.GoInt)]?.__copy__());
            var _y = _testTerm(_args[(1 : stdgo.GoInt)]?.__copy__());
            var _want:Bool = _args[(2 : stdgo.GoInt)] == (("T" : stdgo.GoString));
            {
                var _got:Bool = _x._subsetOf(_y);
                if (_got != (_want)) {
                    _t.errorf(("%v.subsetOf(%v) = %v; want %v" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(stdgo.Go.asInterface(_y)), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_want));
                };
            };
        };
    }
function testTermDisjoint(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        for (__0 => _test in (new stdgo.Slice<stdgo.GoString>(
10,
10,
("int int F" : stdgo.GoString),
("~int ~int F" : stdgo.GoString),
("int ~int F" : stdgo.GoString),
("int string T" : stdgo.GoString),
("int ~string T" : stdgo.GoString),
("int myInt T" : stdgo.GoString),
("~int ~string T" : stdgo.GoString),
("~int myInt F" : stdgo.GoString),
("string myInt T" : stdgo.GoString),
("~string myInt T" : stdgo.GoString)) : stdgo.Slice<stdgo.GoString>)) {
            var _args = _split(_test?.__copy__(), (3 : stdgo.GoInt));
            var _x = _testTerm(_args[(0 : stdgo.GoInt)]?.__copy__());
            var _y = _testTerm(_args[(1 : stdgo.GoInt)]?.__copy__());
            var _want:Bool = _args[(2 : stdgo.GoInt)] == (("T" : stdgo.GoString));
            {
                var _got:Bool = _x._disjoint(_y);
                if (_got != (_want)) {
                    _t.errorf(("%v.disjoint(%v) = %v; want %v" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(stdgo.Go.asInterface(_y)), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_want));
                };
            };
            {
                final __tmp__0 = _y;
                final __tmp__1 = _x;
                _x = __tmp__0;
                _y = __tmp__1;
            };
            {
                var _got:Bool = _x._disjoint(_y);
                if (_got != (_want)) {
                    _t.errorf(("%v.disjoint(%v) = %v; want %v" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(stdgo.Go.asInterface(_y)), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_want));
                };
            };
        };
    }
/**
    // goTypeName returns the Go type name for typ and
    // removes any occurrences of "types." from that name.
**/
function _goTypeName(_typ:Type_):stdgo.GoString {
        return stdgo.strings.Strings.replaceAll(stdgo.fmt.Fmt.sprintf(("%T" : stdgo.GoString), stdgo.Go.toInterface(_typ))?.__copy__(), ("types." : stdgo.GoString), stdgo.Go.str()?.__copy__())?.__copy__();
    }
/**
    // under returns the true expanded underlying type.
    // If it doesn't exist, the result is Typ[Invalid].
    // under must only be called when a type is known
    // to be fully set up.
**/
function _under(_t:Type_):Type_ {
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_t) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
            }, _t = __tmp__._0, __0 = __tmp__._1;
            if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                return _t._under();
            };
        };
        return _t.underlying();
    }
/**
    // If t is not a type parameter, coreType returns the underlying type.
    // If t is a type parameter, coreType returns the single underlying
    // type of all types in its type set if it exists, or nil otherwise. If the
    // type set contains only unrestricted and restricted channel types (with
    // identical element types), the single underlying type is the restricted
    // channel type if the restrictions are always the same, or nil otherwise.
**/
function _coreType(_t:Type_):Type_ {
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_t) : stdgo.Ref<TypeParam>)) : stdgo.Ref<TypeParam>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>), _1 : false };
        }, _tpar = __tmp__._0, __0 = __tmp__._1;
        if (_tpar == null || (_tpar : Dynamic).__nil__) {
            return _under(_t);
        };
        var _su:Type_ = (null : stdgo.go.types.Types.Type_);
        if (_tpar._underIs(function(_u:Type_):Bool {
            if (_u == null) {
                return false;
            };
            if (_su != null) {
                _u = _match(_su, _u);
                if (_u == null) {
                    return false;
                };
            };
            _su = _u;
            return true;
        })) {
            return _su;
        };
        return (null : stdgo.go.types.Types.Type_);
    }
/**
    // coreString is like coreType but also considers []byte
    // and strings as identical. In this case, if successful and we saw
    // a string, the result is of type (possibly untyped) string.
**/
function _coreString(_t:Type_):Type_ {
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_t) : stdgo.Ref<TypeParam>)) : stdgo.Ref<TypeParam>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>), _1 : false };
        }, _tpar = __tmp__._0, __0 = __tmp__._1;
        if (_tpar == null || (_tpar : Dynamic).__nil__) {
            return _under(_t);
        };
        var _su:Type_ = (null : stdgo.go.types.Types.Type_);
        var _hasString:Bool = false;
        if (_tpar._underIs(function(_u:Type_):Bool {
            if (_u == null) {
                return false;
            };
            if (_isString(_u)) {
                _u = stdgo.Go.asInterface(newSlice(_universeByte));
                _hasString = true;
            };
            if (_su != null) {
                _u = _match(_su, _u);
                if (_u == null) {
                    return false;
                };
            };
            _su = _u;
            return true;
        })) {
            if (_hasString) {
                return stdgo.Go.asInterface(typ[((17 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
            };
            return _su;
        };
        return (null : stdgo.go.types.Types.Type_);
    }
/**
    // If x and y are identical, match returns x.
    // If x and y are identical channels but for their direction
    // and one of them is unrestricted, match returns the channel
    // with the restricted direction.
    // In all other cases, match returns nil.
**/
function _match(_x:Type_, _y:Type_):Type_ {
        if (identical(_x, _y)) {
            return _x;
        };
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_x) : stdgo.Ref<Chan>)) : stdgo.Ref<Chan>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Chan>), _1 : false };
            }, _x = __tmp__._0, __0 = __tmp__._1;
            if (_x != null && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) {
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Chan>)) : stdgo.Ref<Chan>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Chan>), _1 : false };
                    }, _y = __tmp__._0, __1 = __tmp__._1;
                    if (((_y != null) && ((_y : Dynamic).__nil__ == null || !(_y : Dynamic).__nil__)) && identical(_x._elem, _y._elem)) {
                        if (_x._dir == ((0 : stdgo.go.types.Types.ChanDir))) {
                            return stdgo.Go.asInterface(_y);
                        } else if (_y._dir == ((0 : stdgo.go.types.Types.ChanDir))) {
                            return stdgo.Go.asInterface(_x);
                        };
                    };
                };
            };
        };
        return (null : stdgo.go.types.Types.Type_);
    }
/**
    // newUnifier returns a new unifier initialized with the given type parameter
    // and corresponding type argument lists. The type argument list may be shorter
    // than the type parameter list, and it may contain nil types. Matching type
    // parameters and arguments must have the same index.
**/
function _newUnifier(_tparams:stdgo.Slice<stdgo.Ref<TypeParam>>, _targs:stdgo.Slice<Type_>, _enableInterfaceInference:Bool):stdgo.Ref<T_unifier> {
        _assert((_tparams.length) >= (_targs.length));
        var _handles = ({
            final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.types.Types.TypeParam>, stdgo.Ref<stdgo.go.types.Types.Type_>>();
            @:mergeBlock {};
            cast x;
        } : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeParam>, stdgo.Ref<stdgo.go.types.Types.Type_>>);
        for (_i => _x in _tparams) {
            var _t:Type_ = (null : stdgo.go.types.Types.Type_);
            if (_i < (_targs.length)) {
                _t = _targs[(_i : stdgo.GoInt)];
            };
            _handles[_x] = (stdgo.Go.setRef(_t) : stdgo.Ref<stdgo.go.types.Types.Type_>);
        };
        return (stdgo.Go.setRef((new stdgo.go.types.Types.T_unifier(_handles, (0 : stdgo.GoInt), _enableInterfaceInference) : stdgo.go.types.Types.T_unifier)) : stdgo.Ref<stdgo.go.types.Types.T_unifier>);
    }
/**
    // asInterface returns the underlying type of x as an interface if
    // it is a non-type parameter interface. Otherwise it returns nil.
**/
function _asInterface(_x:Type_):stdgo.Ref<Interface> {
        var _i:stdgo.Ref<Interface> = (null : stdgo.Ref<stdgo.go.types.Types.Interface>);
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_x) : stdgo.Ref<TypeParam>)) : stdgo.Ref<TypeParam>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>), _1 : false };
            }, __0 = __tmp__._0, _ok = __tmp__._1;
            if (!_ok) {
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_x)) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Interface>), _1 : false };
                    };
                    _i = __tmp__._0;
                };
            };
        };
        return _i;
    }
/**
    // NewUnion returns a new Union type with the given terms.
    // It is an error to create an empty union; they are syntactically not possible.
**/
function newUnion(_terms:stdgo.Slice<stdgo.Ref<Term>>):stdgo.Ref<Union> {
        if ((_terms.length) == ((0 : stdgo.GoInt))) {
            throw stdgo.Go.toInterface(("empty union" : stdgo.GoString));
        };
        return (stdgo.Go.setRef((new stdgo.go.types.Types.Union(_terms) : stdgo.go.types.Types.Union)) : stdgo.Ref<stdgo.go.types.Types.Union>);
    }
/**
    // NewTerm returns a new union term.
**/
function newTerm(_tilde:Bool, _typ:Type_):stdgo.Ref<Term> {
        return (stdgo.Go.setRef((new stdgo.go.types.Types.Term(_tilde, _typ) : stdgo.go.types.Types.Term)) : stdgo.Ref<stdgo.go.types.Types.Term>);
    }
/**
    // parseUnion parses uexpr as a union of expressions.
    // The result is a Union type, or Typ[Invalid] for some errors.
**/
function _parseUnion(_check:stdgo.Ref<Checker>, _uexpr:stdgo.go.ast.Ast.Expr):Type_ {
        var __tmp__ = _flattenUnion((null : stdgo.Slice<stdgo.go.ast.Ast.Expr>), _uexpr), _blist:stdgo.Slice<stdgo.go.ast.Ast.Expr> = __tmp__._0, _tlist:stdgo.Slice<stdgo.go.ast.Ast.Expr> = __tmp__._1;
        _assert((_blist.length) == (_tlist.length - (1 : stdgo.GoInt)));
        var _terms:stdgo.Slice<stdgo.Ref<Term>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Term>>);
        var _u:Type_ = (null : stdgo.go.types.Types.Type_);
        for (_i => _x in _tlist) {
            var _term = _parseTilde(_check, _x);
            if ((_tlist.length == (1 : stdgo.GoInt)) && !_term._tilde) {
                return _term._typ;
            };
            if ((_terms.length) >= (100 : stdgo.GoInt)) {
                if (stdgo.Go.toInterface(_u) != (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                    _check._errorf(_x, (141 : stdgo.internal.types.errors.Errors.Code), ("cannot handle more than %d union terms (implementation limitation)" : stdgo.GoString), stdgo.Go.toInterface((100 : stdgo.GoInt)));
                    _u = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                };
            } else {
                _terms = (_terms.__append__(_term));
                _u = stdgo.Go.asInterface((stdgo.Go.setRef((new stdgo.go.types.Types.Union(_terms) : stdgo.go.types.Types.Union)) : stdgo.Ref<stdgo.go.types.Types.Union>));
            };
            if (_i > (0 : stdgo.GoInt)) {
                _check._recordTypeAndValue(_blist[(_i - (1 : stdgo.GoInt) : stdgo.GoInt)], (3 : stdgo.go.types.Types.T_operandMode), _u, (null : stdgo.go.constant.Constant.Value));
            };
        };
        if (stdgo.Go.toInterface(_u) == (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
            return _u;
        };
        _check._later(function():Void {
            for (_i => _t in _terms) {
                if (stdgo.Go.toInterface(_t._typ) == (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                    continue;
                };
                var _u:stdgo.go.types.Types.Type_ = _under(_t._typ);
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_u) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Interface>), _1 : false };
                }, _f = __tmp__._0, __24 = __tmp__._1;
                if (_t._tilde) {
                    if (_f != null && ((_f : Dynamic).__nil__ == null || !(_f : Dynamic).__nil__)) {
                        _check._errorf(_tlist[(_i : stdgo.GoInt)], (141 : stdgo.internal.types.errors.Errors.Code), ("invalid use of ~ (%s is an interface)" : stdgo.GoString), stdgo.Go.toInterface(_t._typ));
                        continue;
                    };
                    if (!identical(_u, _t._typ)) {
                        _check._errorf(_tlist[(_i : stdgo.GoInt)], (141 : stdgo.internal.types.errors.Errors.Code), ("invalid use of ~ (underlying type of %s is %s)" : stdgo.GoString), stdgo.Go.toInterface(_t._typ), stdgo.Go.toInterface(_u));
                        continue;
                    };
                };
                if (_f != null && ((_f : Dynamic).__nil__ == null || !(_f : Dynamic).__nil__)) {
                    var _tset = _f._typeSet();
                    if (_tset.numMethods() != ((0 : stdgo.GoInt))) {
                        _check._errorf(_tlist[(_i : stdgo.GoInt)], (141 : stdgo.internal.types.errors.Errors.Code), ("cannot use %s in union (%s contains methods)" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_t)), stdgo.Go.toInterface(stdgo.Go.asInterface(_t)));
                    } else if (stdgo.Go.toInterface(_t._typ) == (stdgo.Go.toInterface(_universeComparable.type()))) {
                        _check._error(_tlist[(_i : stdgo.GoInt)], (141 : stdgo.internal.types.errors.Errors.Code), ("cannot use comparable in union" : stdgo.GoString));
                    } else if (_tset._comparable) {
                        _check._errorf(_tlist[(_i : stdgo.GoInt)], (141 : stdgo.internal.types.errors.Errors.Code), ("cannot use %s in union (%s embeds comparable)" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_t)), stdgo.Go.toInterface(stdgo.Go.asInterface(_t)));
                    };
                    continue;
                };
                {
                    var _j:stdgo.GoInt = _overlappingTerm((_terms.__slice__(0, _i) : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Term>>), _t);
                    if (_j >= (0 : stdgo.GoInt)) {
                        _check._softErrorf(_tlist[(_i : stdgo.GoInt)], (141 : stdgo.internal.types.errors.Errors.Code), ("overlapping terms %s and %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_t)), stdgo.Go.toInterface(stdgo.Go.asInterface(_terms[(_j : stdgo.GoInt)])));
                    };
                };
            };
        })._describef(_uexpr, ("check term validity %s" : stdgo.GoString), stdgo.Go.toInterface(_uexpr));
        return _u;
    }
function _parseTilde(_check:stdgo.Ref<Checker>, _tx:stdgo.go.ast.Ast.Expr):stdgo.Ref<Term> {
        var _x:stdgo.go.ast.Ast.Expr = _tx;
        var _tilde:Bool = false;
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_x) : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>)) : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>), _1 : false };
            }, _op = __tmp__._0, __0 = __tmp__._1;
            if (((_op != null) && ((_op : Dynamic).__nil__ == null || !(_op : Dynamic).__nil__)) && (_op.op == (88 : stdgo.go.token.Token.Token))) {
                _x = _op.x;
                _tilde = true;
            };
        };
        var _typ:stdgo.go.types.Types.Type_ = _check._environment._sig._recv._object._typ(_x);
        if (_isTypeParam(_typ)) {
            if (_tilde) {
                _check._errorf(_x, (144 : stdgo.internal.types.errors.Errors.Code), ("type in term %s cannot be a type parameter" : stdgo.GoString), stdgo.Go.toInterface(_tx));
            } else {
                _check._error(_x, (144 : stdgo.internal.types.errors.Errors.Code), ("term cannot be a type parameter" : stdgo.GoString));
            };
            _typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
        };
        var _term = newTerm(_tilde, _typ);
        if (_tilde) {
            _check._recordTypeAndValue(_tx, (3 : stdgo.go.types.Types.T_operandMode), stdgo.Go.asInterface((stdgo.Go.setRef((new stdgo.go.types.Types.Union((new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Term>>(1, 1, _term) : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Term>>)) : stdgo.go.types.Types.Union)) : stdgo.Ref<stdgo.go.types.Types.Union>)), (null : stdgo.go.constant.Constant.Value));
        };
        return _term;
    }
/**
    // overlappingTerm reports the index of the term x in terms which is
    // overlapping (not disjoint) from y. The result is < 0 if there is no
    // such term. The type of term y must not be an interface, and terms
    // with an interface type are ignored in the terms list.
**/
function _overlappingTerm(_terms:stdgo.Slice<stdgo.Ref<Term>>, _y:stdgo.Ref<Term>):stdgo.GoInt {
        _assert(!isInterface(_y._typ));
        for (_i => _x in _terms) {
            if (isInterface(_x._typ)) {
                continue;
            };
            if (false) {
                if (((((_x == null) || (_x : Dynamic).__nil__) || (_x._typ == null)) || ((_y == null) || (_y : Dynamic).__nil__)) || (_y._typ == null)) {
                    throw stdgo.Go.toInterface(("empty or top union term" : stdgo.GoString));
                };
            };
            if (!(({
                final e = _x;
                ({ _tilde : e._tilde, _typ : e._typ } : stdgo.go.types.Types.T_term);
            }))._disjoint((({
                final e = _y;
                ({ _tilde : e._tilde, _typ : e._typ } : stdgo.go.types.Types.T_term);
            })))) {
                return _i;
            };
        };
        return (-1 : stdgo.GoInt);
    }
/**
    // flattenUnion walks a union type expression of the form A | B | C | ...,
    // extracting both the binary exprs (blist) and leaf types (tlist).
**/
function _flattenUnion(_list:stdgo.Slice<stdgo.go.ast.Ast.Expr>, _x:stdgo.go.ast.Ast.Expr):{ var _0 : stdgo.Slice<stdgo.go.ast.Ast.Expr>; var _1 : stdgo.Slice<stdgo.go.ast.Ast.Expr>; } {
        var _blist:stdgo.Slice<stdgo.go.ast.Ast.Expr> = (null : stdgo.Slice<stdgo.go.ast.Ast.Expr>), _tlist:stdgo.Slice<stdgo.go.ast.Ast.Expr> = (null : stdgo.Slice<stdgo.go.ast.Ast.Expr>);
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_x) : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>)) : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>), _1 : false };
            }, _o = __tmp__._0, __0 = __tmp__._1;
            if (((_o != null) && ((_o : Dynamic).__nil__ == null || !(_o : Dynamic).__nil__)) && (_o.op == (18 : stdgo.go.token.Token.Token))) {
                {
                    var __tmp__ = _flattenUnion(_list, _o.x);
                    _blist = __tmp__._0;
                    _tlist = __tmp__._1;
                };
                _blist = (_blist.__append__(stdgo.Go.asInterface(_o)));
                _x = _o.y;
            };
        };
        return { _0 : _blist, _1 : (_tlist.__append__(_x)) };
    }
function _defPredeclaredTypes():Void {
        for (__0 => _t in typ) {
            _def(stdgo.Go.asInterface(newTypeName(_nopos, null, _t._name?.__copy__(), stdgo.Go.asInterface(_t))));
        };
        for (__1 => _t in _aliases) {
            _def(stdgo.Go.asInterface(newTypeName(_nopos, null, _t._name?.__copy__(), stdgo.Go.asInterface(_t))));
        };
        _def(stdgo.Go.asInterface(newTypeName(_nopos, null, ("any" : stdgo.GoString), stdgo.Go.asInterface((stdgo.Go.setRef(({ _complete : true, _tset : (stdgo.Go.setRef(_topTypeSet) : stdgo.Ref<stdgo.go.types.Types.T__TypeSet>) } : stdgo.go.types.Types.Interface)) : stdgo.Ref<stdgo.go.types.Types.Interface>)))));
        {
            var _obj = newTypeName(_nopos, null, ("error" : stdgo.GoString), (null : stdgo.go.types.Types.Type_));
            _obj._setColor((1u32 : stdgo.go.types.Types.T_color));
            var _typ = newNamed(_obj, (null : stdgo.go.types.Types.Type_), (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>));
            var _recv = newVar(_nopos, null, stdgo.Go.str()?.__copy__(), stdgo.Go.asInterface(_typ));
            var _res = newVar(_nopos, null, stdgo.Go.str()?.__copy__(), stdgo.Go.asInterface(typ[((17 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]));
            var _sig = newSignatureType(_recv, (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>), (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>), null, newTuple(_res), false);
            var _err = newFunc(_nopos, null, ("Error" : stdgo.GoString), _sig);
            var _ityp = (stdgo.Go.setRef(({ _methods : (new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>(1, 1, _err) : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>), _complete : true } : stdgo.go.types.Types.Interface)) : stdgo.Ref<stdgo.go.types.Types.Interface>);
            _computeInterfaceTypeSet(null, _nopos, _ityp);
            _typ.setUnderlying(stdgo.Go.asInterface(_ityp));
            _def(stdgo.Go.asInterface(_obj));
        };
        {
            var _obj = newTypeName(_nopos, null, ("comparable" : stdgo.GoString), (null : stdgo.go.types.Types.Type_));
            _obj._setColor((1u32 : stdgo.go.types.Types.T_color));
            var _typ = newNamed(_obj, (null : stdgo.go.types.Types.Type_), (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>));
            var _ityp = (stdgo.Go.setRef(({ _complete : true, _tset : (stdgo.Go.setRef((new stdgo.go.types.Types.T__TypeSet((null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>), _allTermlist, true) : stdgo.go.types.Types.T__TypeSet)) : stdgo.Ref<stdgo.go.types.Types.T__TypeSet>) } : stdgo.go.types.Types.Interface)) : stdgo.Ref<stdgo.go.types.Types.Interface>);
            _typ.setUnderlying(stdgo.Go.asInterface(_ityp));
            _def(stdgo.Go.asInterface(_obj));
        };
    }
function _defPredeclaredConsts():Void {
        for (__0 => _c in _predeclaredConsts) {
            _def(stdgo.Go.asInterface(newConst(_nopos, null, _c._name?.__copy__(), stdgo.Go.asInterface(typ[(_c._kind : stdgo.GoInt)]), _c._val)));
        };
    }
function _defPredeclaredNil():Void {
        _def(stdgo.Go.asInterface((stdgo.Go.setRef((new stdgo.go.types.Types.Nil(({ _name : ("nil" : stdgo.GoString), _typ : stdgo.Go.asInterface(typ[((25 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]), _color_ : (1u32 : stdgo.go.types.Types.T_color) } : stdgo.go.types.Types.T_object)) : stdgo.go.types.Types.Nil)) : stdgo.Ref<stdgo.go.types.Types.Nil>)));
    }
function _defPredeclaredFuncs():Void {
        for (_i => _ in _predeclaredFuncs) {
            var _id:stdgo.go.types.Types.T_builtinId = (_i : T_builtinId);
            if ((_id == (26 : stdgo.go.types.Types.T_builtinId)) || (_id == (27 : stdgo.go.types.Types.T_builtinId))) {
                continue;
            };
            _def(stdgo.Go.asInterface(_newBuiltin(_id)));
        };
    }
/**
    // DefPredeclaredTestFuncs defines the assert and trace built-ins.
    // These built-ins are intended for debugging and testing of this
    // package only.
**/
function defPredeclaredTestFuncs():Void {
        if (universe.lookup(("assert" : stdgo.GoString)) != null) {
            return;
        };
        _def(stdgo.Go.asInterface(_newBuiltin((26 : stdgo.go.types.Types.T_builtinId))));
        _def(stdgo.Go.asInterface(_newBuiltin((27 : stdgo.go.types.Types.T_builtinId))));
    }
/**
    // Objects with names containing blanks are internal and not entered into
    // a scope. Objects with exported names are inserted in the unsafe package
    // scope; other objects are inserted in the universe scope.
**/
function _def(_obj:Object):Void {
        _assert(_obj._color() == ((1u32 : stdgo.go.types.Types.T_color)));
        var _name:stdgo.GoString = _obj.name()?.__copy__();
        if (stdgo.strings.Strings.contains(_name?.__copy__(), (" " : stdgo.GoString))) {
            return;
        };
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj.type()) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
            }, _typ = __tmp__._0, __0 = __tmp__._1;
            if (_typ != null && ((_typ : Dynamic).__nil__ == null || !(_typ : Dynamic).__nil__)) {
                _typ._obj = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<TypeName>)) : stdgo.Ref<TypeName>);
            };
        };
        var _scope = universe;
        if (_obj.exported()) {
            _scope = unsafe._scope;
            {
                final __type__ = _obj;
                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeName>))) {
                    var _obj:stdgo.Ref<stdgo.go.types.Types.TypeName> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeName>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__().value;
                    _obj._object._pkg = unsafe;
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Builtin>))) {
                    var _obj:stdgo.Ref<stdgo.go.types.Types.Builtin> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Builtin>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Builtin>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Builtin>) : __type__.__underlying__().value;
                    _obj._object._pkg = unsafe;
                } else {
                    var _obj:stdgo.go.types.Types.Object = __type__ == null ? (null : stdgo.go.types.Types.Object) : cast __type__;
                    _unreachable();
                };
            };
        };
        if (_scope.insert(_obj) != null) {
            throw stdgo.Go.toInterface(("double declaration of predeclared identifier" : stdgo.GoString));
        };
    }
/**
    // cmpPos compares the positions p and q and returns a result r as follows:
    //
    // r <  0: p is before q
    // r == 0: p and q are the same position (but may not be identical)
    // r >  0: p is after q
    //
    // If p and q are in different files, p is before q if the filename
    // of p sorts lexicographically before the filename of q.
**/
function _cmpPos(_p:stdgo.go.token.Token.Pos, _q:stdgo.go.token.Token.Pos):stdgo.GoInt {
        return (_p - _q : stdgo.GoInt);
    }
function cmpPos(_p:stdgo.go.token.Token.Pos, _q:stdgo.go.token.Token.Pos):stdgo.GoInt {
        return _cmpPos(_p, _q);
    }
/**
    // makeObjList returns the list of type name objects for the given
    // list of named types.
**/
function _makeObjList(_tlist:stdgo.Slice<stdgo.Ref<Named>>):stdgo.Slice<Object> {
        var _olist = new stdgo.Slice<stdgo.go.types.Types.Object>((_tlist.length : stdgo.GoInt).toBasic(), 0);
        for (_i => _t in _tlist) {
            _olist[(_i : stdgo.GoInt)] = stdgo.Go.asInterface(_t._obj);
        };
        return _olist;
    }
/**
    // parseGoVersion parses a Go version string (such as "go1.12")
    // and returns the version, or an error. If s is the empty
    // string, the version is 0.0.
**/
function _parseGoVersion(_s:stdgo.GoString):{ var _0 : T_version; var _1 : stdgo.Error; } {
        var _v:T_version = ({} : stdgo.go.types.Types.T_version), _err:stdgo.Error = (null : stdgo.Error);
        var _bad:() -> { var _0 : stdgo.go.types.Types.T_version; var _1 : stdgo.Error; } = function():{ var _0 : T_version; var _1 : stdgo.Error; } {
            return { _0 : (new stdgo.go.types.Types.T_version() : stdgo.go.types.Types.T_version), _1 : stdgo.fmt.Fmt.errorf(("invalid Go version syntax %q" : stdgo.GoString), stdgo.Go.toInterface(_s)) };
        };
        if (_s == (stdgo.Go.str())) {
            return { _0 : _v, _1 : _err };
        };
        if (!stdgo.strings.Strings.hasPrefix(_s?.__copy__(), ("go" : stdgo.GoString))) {
            return _bad();
        };
        _s = (_s.__slice__((("go" : stdgo.GoString).length)) : stdgo.GoString)?.__copy__();
        var _i:stdgo.GoInt = (0 : stdgo.GoInt);
        stdgo.Go.cfor(((_i < _s.length) && ((48 : stdgo.GoUInt8) <= _s[(_i : stdgo.GoInt)])) && (_s[(_i : stdgo.GoInt)] <= (57 : stdgo.GoUInt8)), _i++, {
            if ((_i >= (10 : stdgo.GoInt)) || ((_i == (0 : stdgo.GoInt)) && (_s[(_i : stdgo.GoInt)] == (48 : stdgo.GoUInt8)))) {
                return _bad();
            };
            _v._major = (((10 : stdgo.GoInt) * _v._major) + (_s[(_i : stdgo.GoInt)] : stdgo.GoInt)) - (48 : stdgo.GoInt);
        });
        if ((_i > (0 : stdgo.GoInt)) && (_i == (_s.length))) {
            return { _0 : _v, _1 : _err };
        };
        if ((_i == (0 : stdgo.GoInt)) || (_s[(_i : stdgo.GoInt)] != (46 : stdgo.GoUInt8))) {
            return _bad();
        };
        _s = (_s.__slice__(_i + (1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
        if (_s == (("0" : stdgo.GoString))) {
            return { _0 : _v, _1 : _err };
        };
        _i = (0 : stdgo.GoInt);
        stdgo.Go.cfor(((_i < _s.length) && ((48 : stdgo.GoUInt8) <= _s[(_i : stdgo.GoInt)])) && (_s[(_i : stdgo.GoInt)] <= (57 : stdgo.GoUInt8)), _i++, {
            if ((_i >= (10 : stdgo.GoInt)) || ((_i == (0 : stdgo.GoInt)) && (_s[(_i : stdgo.GoInt)] == (48 : stdgo.GoUInt8)))) {
                return _bad();
            };
            _v._minor = (((10 : stdgo.GoInt) * _v._minor) + (_s[(_i : stdgo.GoInt)] : stdgo.GoInt)) - (48 : stdgo.GoInt);
        });
        return { _0 : _v, _1 : _err };
    }
function testParseGoVersion(_t:stdgo.Ref<stdgo.testing.Testing.T_>):Void {
        for (__0 => _tt in _parseGoVersionTests) {
            {
                var __tmp__ = _parseGoVersion(_tt._in?.__copy__()), _out:stdgo.go.types.Types.T_version = __tmp__._0, _err:stdgo.Error = __tmp__._1;
                if ((stdgo.Go.toInterface(_out) != stdgo.Go.toInterface(_tt._out)) || (_err != null)) {
                    _t.errorf(("parseGoVersion(%q) = %v, %v, want %v, nil" : stdgo.GoString), stdgo.Go.toInterface(_tt._in), stdgo.Go.toInterface(stdgo.Go.asInterface(_out)), stdgo.Go.toInterface(_err), stdgo.Go.toInterface(stdgo.Go.asInterface(_tt._out)));
                };
            };
        };
    }
@:keep var _ = {
        try {
            _unaryOpPredicates = ({
                final x = new stdgo.GoMap.GoIntMap<stdgo.go.types.Types.Type_ -> Bool>();
                x.__defaultValue__ = () -> null;
                @:mergeBlock {
                    x.set((12 : stdgo.go.token.Token.Token), _allNumeric);
                    x.set((13 : stdgo.go.token.Token.Token), _allNumeric);
                    x.set((19 : stdgo.go.token.Token.Token), _allInteger);
                    x.set((43 : stdgo.go.token.Token.Token), _allBoolean);
                };
                x;
            } : stdgo.GoMap<stdgo.go.token.Token.Token, stdgo.go.types.Types.Type_ -> Bool>);
            _binaryOpPredicates = ({
                final x = new stdgo.GoMap.GoIntMap<stdgo.go.types.Types.Type_ -> Bool>();
                x.__defaultValue__ = () -> null;
                @:mergeBlock {
                    x.set((12 : stdgo.go.token.Token.Token), _allNumericOrString);
                    x.set((13 : stdgo.go.token.Token.Token), _allNumeric);
                    x.set((14 : stdgo.go.token.Token.Token), _allNumeric);
                    x.set((15 : stdgo.go.token.Token.Token), _allNumeric);
                    x.set((16 : stdgo.go.token.Token.Token), _allInteger);
                    x.set((17 : stdgo.go.token.Token.Token), _allInteger);
                    x.set((18 : stdgo.go.token.Token.Token), _allInteger);
                    x.set((19 : stdgo.go.token.Token.Token), _allInteger);
                    x.set((22 : stdgo.go.token.Token.Token), _allInteger);
                    x.set((34 : stdgo.go.token.Token.Token), _allBoolean);
                    x.set((35 : stdgo.go.token.Token.Token), _allBoolean);
                };
                x;
            } : stdgo.GoMap<stdgo.go.token.Token.Token, stdgo.go.types.Types.Type_ -> Bool>);
            universe = newScope(null, _nopos, _nopos, ("universe" : stdgo.GoString));
            unsafe = newPackage(("unsafe" : stdgo.GoString), ("unsafe" : stdgo.GoString));
            unsafe._complete = true;
            _defPredeclaredTypes();
            _defPredeclaredConsts();
            _defPredeclaredNil();
            _defPredeclaredFuncs();
            _universeIota = universe.lookup(("iota" : stdgo.GoString));
            _universeByte = universe.lookup(("byte" : stdgo.GoString)).type();
            _universeRune = universe.lookup(("rune" : stdgo.GoString)).type();
            _universeAny = universe.lookup(("any" : stdgo.GoString));
            _universeError = universe.lookup(("error" : stdgo.GoString)).type();
            _universeComparable = universe.lookup(("comparable" : stdgo.GoString));
        } catch(__exception__) if (__exception__.message != "__return__") throw __exception__;
        true;
    };
class Error_asInterface {
    /**
        // Error returns an error string formatted as follows:
        // filename:line:column: message
    **/
    @:keep
    public dynamic function error():stdgo.GoString return __self__.value.error();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Error>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Error_asInterface) class Error_static_extension {
    /**
        // Error returns an error string formatted as follows:
        // filename:line:column: message
    **/
    @:keep
    static public function error( _err:Error):stdgo.GoString {
        @:recv var _err:Error = _err?.__copy__();
        return stdgo.fmt.Fmt.sprintf(("%s: %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_err.fset.position(_err.pos))), stdgo.Go.toInterface(_err.msg))?.__copy__();
    }
}
class ArgumentError_asInterface {
    @:keep
    public dynamic function unwrap():stdgo.Error return __self__.value.unwrap();
    @:keep
    public dynamic function error():stdgo.GoString return __self__.value.error();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<ArgumentError>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.ArgumentError_asInterface) class ArgumentError_static_extension {
    @:keep
    static public function unwrap( _e:stdgo.Ref<ArgumentError>):stdgo.Error {
        @:recv var _e:stdgo.Ref<ArgumentError> = _e;
        return _e.err;
    }
    @:keep
    static public function error( _e:stdgo.Ref<ArgumentError>):stdgo.GoString {
        @:recv var _e:stdgo.Ref<ArgumentError> = _e;
        return _e.err.error()?.__copy__();
    }
}
class Config_asInterface {
    /**
        // sizeof returns the size of T.
        // If T is too large, the result is negative.
    **/
    @:keep
    public dynamic function _sizeof(t:Type_):stdgo.GoInt64 return __self__.value._sizeof(t);
    /**
        // offsetof returns the offset of the field specified via
        // the index sequence relative to T. All embedded fields
        // must be structs (rather than pointers to structs).
        // If the offset is too large (because T is too large),
        // the result is negative.
    **/
    @:keep
    public dynamic function _offsetof(t:Type_, _index:stdgo.Slice<stdgo.GoInt>):stdgo.GoInt64 return __self__.value._offsetof(t, _index);
    @:keep
    public dynamic function _offsetsof(t:stdgo.Ref<Struct>):stdgo.Slice<stdgo.GoInt64> return __self__.value._offsetsof(t);
    @:keep
    public dynamic function _alignof(t:Type_):stdgo.GoInt64 return __self__.value._alignof(t);
    /**
        // Check type-checks a package and returns the resulting package object and
        // the first error if any. Additionally, if info != nil, Check populates each
        // of the non-nil maps in the Info struct.
        //
        // The package is marked as complete if no errors occurred, otherwise it is
        // incomplete. See Config.Error for controlling behavior in the presence of
        // errors.
        //
        // The package is specified by a list of *ast.Files and corresponding
        // file set, and the package path the package is identified with.
        // The clean path must not be empty or dot (".").
    **/
    @:keep
    public dynamic function check(_path:stdgo.GoString, _fset:stdgo.Ref<stdgo.go.token.Token.FileSet>, _files:stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.File>>, _info:stdgo.Ref<Info>):{ var _0 : stdgo.Ref<Package>; var _1 : stdgo.Error; } return __self__.value.check(_path, _fset, _files, _info);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Config>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Config_asInterface) class Config_static_extension {
    /**
        // sizeof returns the size of T.
        // If T is too large, the result is negative.
    **/
    @:keep
    static public function _sizeof( _conf:stdgo.Ref<Config>, t:Type_):stdgo.GoInt64 {
        @:recv var _conf:stdgo.Ref<Config> = _conf;
        var _f:stdgo.go.types.Types.Type_ -> stdgo.GoInt64 = _stdSizes.sizeof;
        if (_conf.sizes != null) {
            _f = _conf.sizes.sizeof;
        };
        return _f(t);
    }
    /**
        // offsetof returns the offset of the field specified via
        // the index sequence relative to T. All embedded fields
        // must be structs (rather than pointers to structs).
        // If the offset is too large (because T is too large),
        // the result is negative.
    **/
    @:keep
    static public function _offsetof( _conf:stdgo.Ref<Config>, t:Type_, _index:stdgo.Slice<stdgo.GoInt>):stdgo.GoInt64 {
        @:recv var _conf:stdgo.Ref<Config> = _conf;
        var _offs:stdgo.GoInt64 = (0 : stdgo.GoInt64);
        for (__0 => _i in _index) {
            var _s = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(t)) : stdgo.Ref<Struct>)) : stdgo.Ref<Struct>);
            var _d:stdgo.GoInt64 = _conf._offsetsof(_s)[(_i : stdgo.GoInt)];
            if (_d < (0i64 : stdgo.GoInt64)) {
                return (-1i64 : stdgo.GoInt64);
            };
            _offs = _offs + (_d);
            if (_offs < (0i64 : stdgo.GoInt64)) {
                return (-1i64 : stdgo.GoInt64);
            };
            t = _s._fields[(_i : stdgo.GoInt)]._object._typ;
        };
        return _offs;
    }
    @:keep
    static public function _offsetsof( _conf:stdgo.Ref<Config>, t:stdgo.Ref<Struct>):stdgo.Slice<stdgo.GoInt64> {
        @:recv var _conf:stdgo.Ref<Config> = _conf;
        var _offsets:stdgo.Slice<stdgo.GoInt64> = (null : stdgo.Slice<stdgo.GoInt64>);
        if (t.numFields() > (0 : stdgo.GoInt)) {
            var _f = _stdSizes.offsetsof;
            if (_conf.sizes != null) {
                _f = _conf.sizes.offsetsof;
            };
            _offsets = _f(t._fields);
            if ((_offsets.length) != (t.numFields())) {
                throw stdgo.Go.toInterface(("implementation of offsetsof returned the wrong number of offsets" : stdgo.GoString));
            };
        };
        return _offsets;
    }
    @:keep
    static public function _alignof( _conf:stdgo.Ref<Config>, t:Type_):stdgo.GoInt64 {
        @:recv var _conf:stdgo.Ref<Config> = _conf;
        var _f:stdgo.go.types.Types.Type_ -> stdgo.GoInt64 = _stdSizes.alignof_;
        if (_conf.sizes != null) {
            _f = _conf.sizes.alignof_;
        };
        {
            var _a:stdgo.GoInt64 = _f(t);
            if (_a >= (1i64 : stdgo.GoInt64)) {
                return _a;
            };
        };
        throw stdgo.Go.toInterface(("implementation of alignof returned an alignment < 1" : stdgo.GoString));
    }
    /**
        // Check type-checks a package and returns the resulting package object and
        // the first error if any. Additionally, if info != nil, Check populates each
        // of the non-nil maps in the Info struct.
        //
        // The package is marked as complete if no errors occurred, otherwise it is
        // incomplete. See Config.Error for controlling behavior in the presence of
        // errors.
        //
        // The package is specified by a list of *ast.Files and corresponding
        // file set, and the package path the package is identified with.
        // The clean path must not be empty or dot (".").
    **/
    @:keep
    static public function check( _conf:stdgo.Ref<Config>, _path:stdgo.GoString, _fset:stdgo.Ref<stdgo.go.token.Token.FileSet>, _files:stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.File>>, _info:stdgo.Ref<Info>):{ var _0 : stdgo.Ref<Package>; var _1 : stdgo.Error; } {
        @:recv var _conf:stdgo.Ref<Config> = _conf;
        var _pkg = newPackage(_path?.__copy__(), stdgo.Go.str()?.__copy__());
        return { _0 : _pkg, _1 : newChecker(_conf, _fset, _pkg, _info).files(_files) };
    }
}
class Info_asInterface {
    /**
        // ObjectOf returns the object denoted by the specified id,
        // or nil if not found.
        //
        // If id is an embedded struct field, ObjectOf returns the field (*Var)
        // it defines, not the type (*TypeName) it uses.
        //
        // Precondition: the Uses and Defs maps are populated.
    **/
    @:keep
    public dynamic function objectOf(_id:stdgo.Ref<stdgo.go.ast.Ast.Ident>):Object return __self__.value.objectOf(_id);
    /**
        // TypeOf returns the type of expression e, or nil if not found.
        // Precondition: the Types, Uses and Defs maps are populated.
    **/
    @:keep
    public dynamic function typeOf(_e:stdgo.go.ast.Ast.Expr):Type_ return __self__.value.typeOf(_e);
    @:keep
    public dynamic function _recordTypes():Bool return __self__.value._recordTypes();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Info>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Info_asInterface) class Info_static_extension {
    /**
        // ObjectOf returns the object denoted by the specified id,
        // or nil if not found.
        //
        // If id is an embedded struct field, ObjectOf returns the field (*Var)
        // it defines, not the type (*TypeName) it uses.
        //
        // Precondition: the Uses and Defs maps are populated.
    **/
    @:keep
    static public function objectOf( _info:stdgo.Ref<Info>, _id:stdgo.Ref<stdgo.go.ast.Ast.Ident>):Object {
        @:recv var _info:stdgo.Ref<Info> = _info;
        {
            var _obj:stdgo.go.types.Types.Object = (_info.defs[_id] ?? (null : stdgo.go.types.Types.Object));
            if (_obj != null) {
                return _obj;
            };
        };
        return (_info.uses[_id] ?? (null : stdgo.go.types.Types.Object));
    }
    /**
        // TypeOf returns the type of expression e, or nil if not found.
        // Precondition: the Types, Uses and Defs maps are populated.
    **/
    @:keep
    static public function typeOf( _info:stdgo.Ref<Info>, _e:stdgo.go.ast.Ast.Expr):Type_ {
        @:recv var _info:stdgo.Ref<Info> = _info;
        {
            var __tmp__ = (_info.types != null && _info.types.exists(_e) ? { _0 : _info.types[_e], _1 : true } : { _0 : ({} : stdgo.go.types.Types.TypeAndValue), _1 : false }), _t:stdgo.go.types.Types.TypeAndValue = __tmp__._0, _ok:Bool = __tmp__._1;
            if (_ok) {
                return _t.type;
            };
        };
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_e) : stdgo.Ref<stdgo.go.ast.Ast.Ident>)) : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _1 : false };
            }, _id = __tmp__._0, __0 = __tmp__._1;
            if (_id != null && ((_id : Dynamic).__nil__ == null || !(_id : Dynamic).__nil__)) {
                {
                    var _obj:stdgo.go.types.Types.Object = _info.objectOf(_id);
                    if (_obj != null) {
                        return _obj.type();
                    };
                };
            };
        };
        return (null : stdgo.go.types.Types.Type_);
    }
    @:keep
    static public function _recordTypes( _info:stdgo.Ref<Info>):Bool {
        @:recv var _info:stdgo.Ref<Info> = _info;
        return _info.types != null;
    }
}
class TypeAndValue_asInterface {
    /**
        // HasOk reports whether the corresponding expression may be
        // used on the rhs of a comma-ok assignment.
    **/
    @:keep
    public dynamic function hasOk():Bool return __self__.value.hasOk();
    /**
        // Assignable reports whether the corresponding expression
        // is assignable to (provided a value of the right type).
    **/
    @:keep
    public dynamic function assignable():Bool return __self__.value.assignable();
    /**
        // Addressable reports whether the corresponding expression
        // is addressable (https://golang.org/ref/spec#Address_operators).
    **/
    @:keep
    public dynamic function addressable():Bool return __self__.value.addressable();
    /**
        // IsNil reports whether the corresponding expression denotes the
        // predeclared value nil.
    **/
    @:keep
    public dynamic function isNil():Bool return __self__.value.isNil();
    /**
        // IsValue reports whether the corresponding expression is a value.
        // Builtins are not considered values. Constant values have a non-
        // nil Value.
    **/
    @:keep
    public dynamic function isValue():Bool return __self__.value.isValue();
    /**
        // IsBuiltin reports whether the corresponding expression denotes
        // a (possibly parenthesized) built-in function.
    **/
    @:keep
    public dynamic function isBuiltin():Bool return __self__.value.isBuiltin();
    /**
        // IsType reports whether the corresponding expression specifies a type.
    **/
    @:keep
    public dynamic function isType():Bool return __self__.value.isType();
    /**
        // IsVoid reports whether the corresponding expression
        // is a function call without results.
    **/
    @:keep
    public dynamic function isVoid():Bool return __self__.value.isVoid();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<TypeAndValue>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.TypeAndValue_asInterface) class TypeAndValue_static_extension {
    /**
        // HasOk reports whether the corresponding expression may be
        // used on the rhs of a comma-ok assignment.
    **/
    @:keep
    static public function hasOk( _tv:TypeAndValue):Bool {
        @:recv var _tv:TypeAndValue = _tv?.__copy__();
        return (_tv._mode == (8 : stdgo.go.types.Types.T_operandMode)) || (_tv._mode == (6 : stdgo.go.types.Types.T_operandMode));
    }
    /**
        // Assignable reports whether the corresponding expression
        // is assignable to (provided a value of the right type).
    **/
    @:keep
    static public function assignable( _tv:TypeAndValue):Bool {
        @:recv var _tv:TypeAndValue = _tv?.__copy__();
        return (_tv._mode == (5 : stdgo.go.types.Types.T_operandMode)) || (_tv._mode == (6 : stdgo.go.types.Types.T_operandMode));
    }
    /**
        // Addressable reports whether the corresponding expression
        // is addressable (https://golang.org/ref/spec#Address_operators).
    **/
    @:keep
    static public function addressable( _tv:TypeAndValue):Bool {
        @:recv var _tv:TypeAndValue = _tv?.__copy__();
        return _tv._mode == ((5 : stdgo.go.types.Types.T_operandMode));
    }
    /**
        // IsNil reports whether the corresponding expression denotes the
        // predeclared value nil.
    **/
    @:keep
    static public function isNil( _tv:TypeAndValue):Bool {
        @:recv var _tv:TypeAndValue = _tv?.__copy__();
        return (_tv._mode == (7 : stdgo.go.types.Types.T_operandMode)) && (stdgo.Go.toInterface(_tv.type) == stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((25 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])));
    }
    /**
        // IsValue reports whether the corresponding expression is a value.
        // Builtins are not considered values. Constant values have a non-
        // nil Value.
    **/
    @:keep
    static public function isValue( _tv:TypeAndValue):Bool {
        @:recv var _tv:TypeAndValue = _tv?.__copy__();
        {
            final __value__ = _tv._mode;
            if (__value__ == ((4 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((5 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((6 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((7 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((8 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((9 : stdgo.go.types.Types.T_operandMode))) {
                return true;
            };
        };
        return false;
    }
    /**
        // IsBuiltin reports whether the corresponding expression denotes
        // a (possibly parenthesized) built-in function.
    **/
    @:keep
    static public function isBuiltin( _tv:TypeAndValue):Bool {
        @:recv var _tv:TypeAndValue = _tv?.__copy__();
        return _tv._mode == ((2 : stdgo.go.types.Types.T_operandMode));
    }
    /**
        // IsType reports whether the corresponding expression specifies a type.
    **/
    @:keep
    static public function isType( _tv:TypeAndValue):Bool {
        @:recv var _tv:TypeAndValue = _tv?.__copy__();
        return _tv._mode == ((3 : stdgo.go.types.Types.T_operandMode));
    }
    /**
        // IsVoid reports whether the corresponding expression
        // is a function call without results.
    **/
    @:keep
    static public function isVoid( _tv:TypeAndValue):Bool {
        @:recv var _tv:TypeAndValue = _tv?.__copy__();
        return _tv._mode == ((1 : stdgo.go.types.Types.T_operandMode));
    }
}
class Initializer_asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Initializer>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Initializer_asInterface) class Initializer_static_extension {
    @:keep
    static public function string( _init:stdgo.Ref<Initializer>):stdgo.GoString {
        @:recv var _init:stdgo.Ref<Initializer> = _init;
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        for (_i => _lhs in _init.lhs) {
            if (_i > (0 : stdgo.GoInt)) {
                _buf.writeString((", " : stdgo.GoString));
            };
            _buf.writeString(_lhs.name()?.__copy__());
        };
        _buf.writeString((" = " : stdgo.GoString));
        writeExpr((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.bytes.Bytes.Buffer>), _init.rhs);
        return (_buf.string() : stdgo.GoString)?.__copy__();
    }
}
class Array__asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type_ return __self__.value.underlying();
    /**
        // Elem returns element type of array a.
    **/
    @:keep
    public dynamic function elem():Type_ return __self__.value.elem();
    /**
        // Len returns the length of array a.
        // A negative result indicates an unknown length.
    **/
    @:keep
    public dynamic function len():stdgo.GoInt64 return __self__.value.len();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Array_>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Array__asInterface) class Array__static_extension {
    @:keep
    static public function string( _a:stdgo.Ref<Array_>):stdgo.GoString {
        @:recv var _a:stdgo.Ref<Array_> = _a;
        return typeString(stdgo.Go.asInterface(_a), null)?.__copy__();
    }
    @:keep
    static public function underlying( _a:stdgo.Ref<Array_>):Type_ {
        @:recv var _a:stdgo.Ref<Array_> = _a;
        return stdgo.Go.asInterface(_a);
    }
    /**
        // Elem returns element type of array a.
    **/
    @:keep
    static public function elem( _a:stdgo.Ref<Array_>):Type_ {
        @:recv var _a:stdgo.Ref<Array_> = _a;
        return _a._elem;
    }
    /**
        // Len returns the length of array a.
        // A negative result indicates an unknown length.
    **/
    @:keep
    static public function len( _a:stdgo.Ref<Array_>):stdgo.GoInt64 {
        @:recv var _a:stdgo.Ref<Array_> = _a;
        return _a._len;
    }
}
class Basic_asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type_ return __self__.value.underlying();
    /**
        // Name returns the name of basic type b.
    **/
    @:keep
    public dynamic function name():stdgo.GoString return __self__.value.name();
    /**
        // Info returns information about properties of basic type b.
    **/
    @:keep
    public dynamic function info():BasicInfo return __self__.value.info();
    /**
        // Kind returns the kind of basic type b.
    **/
    @:keep
    public dynamic function kind():BasicKind return __self__.value.kind();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Basic>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Basic_asInterface) class Basic_static_extension {
    @:keep
    static public function string( _b:stdgo.Ref<Basic>):stdgo.GoString {
        @:recv var _b:stdgo.Ref<Basic> = _b;
        return typeString(stdgo.Go.asInterface(_b), null)?.__copy__();
    }
    @:keep
    static public function underlying( _b:stdgo.Ref<Basic>):Type_ {
        @:recv var _b:stdgo.Ref<Basic> = _b;
        return stdgo.Go.asInterface(_b);
    }
    /**
        // Name returns the name of basic type b.
    **/
    @:keep
    static public function name( _b:stdgo.Ref<Basic>):stdgo.GoString {
        @:recv var _b:stdgo.Ref<Basic> = _b;
        return _b._name?.__copy__();
    }
    /**
        // Info returns information about properties of basic type b.
    **/
    @:keep
    static public function info( _b:stdgo.Ref<Basic>):BasicInfo {
        @:recv var _b:stdgo.Ref<Basic> = _b;
        return _b._info;
    }
    /**
        // Kind returns the kind of basic type b.
    **/
    @:keep
    static public function kind( _b:stdgo.Ref<Basic>):BasicKind {
        @:recv var _b:stdgo.Ref<Basic> = _b;
        return _b._kind;
    }
}
class Chan_asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type_ return __self__.value.underlying();
    /**
        // Elem returns the element type of channel c.
    **/
    @:keep
    public dynamic function elem():Type_ return __self__.value.elem();
    /**
        // Dir returns the direction of channel c.
    **/
    @:keep
    public dynamic function dir():ChanDir return __self__.value.dir();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Chan>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Chan_asInterface) class Chan_static_extension {
    @:keep
    static public function string( _c:stdgo.Ref<Chan>):stdgo.GoString {
        @:recv var _c:stdgo.Ref<Chan> = _c;
        return typeString(stdgo.Go.asInterface(_c), null)?.__copy__();
    }
    @:keep
    static public function underlying( _c:stdgo.Ref<Chan>):Type_ {
        @:recv var _c:stdgo.Ref<Chan> = _c;
        return stdgo.Go.asInterface(_c);
    }
    /**
        // Elem returns the element type of channel c.
    **/
    @:keep
    static public function elem( _c:stdgo.Ref<Chan>):Type_ {
        @:recv var _c:stdgo.Ref<Chan> = _c;
        return _c._elem;
    }
    /**
        // Dir returns the direction of channel c.
    **/
    @:keep
    static public function dir( _c:stdgo.Ref<Chan>):ChanDir {
        @:recv var _c:stdgo.Ref<Chan> = _c;
        return _c._dir;
    }
}
class T_environment_asInterface {
    /**
        // lookup looks up name in the current environment and returns the matching object, or nil.
    **/
    @:keep
    public dynamic function _lookup(_name:stdgo.GoString):Object return __self__.value._lookup(_name);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_environment>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_environment_asInterface) class T_environment_static_extension {
    /**
        // lookup looks up name in the current environment and returns the matching object, or nil.
    **/
    @:keep
    static public function _lookup( _env:stdgo.Ref<T_environment>, _name:stdgo.GoString):Object {
        @:recv var _env:stdgo.Ref<T_environment> = _env;
        var __tmp__ = _env._scope.lookupParent(_name?.__copy__(), _env._pos), __0:stdgo.Ref<stdgo.go.types.Types.Scope> = __tmp__._0, _obj:stdgo.go.types.Types.Object = __tmp__._1;
        return _obj;
    }
}
class T_action_asInterface {
    /**
        // If debug is set, describef sets a printf-formatted description for action a.
        // Otherwise, it is a no-op.
    **/
    @:keep
    public dynamic function _describef(_pos:T_positioner, _format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):Void __self__.value._describef(_pos, _format, ..._args);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_action>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_action_asInterface) class T_action_static_extension {
    /**
        // If debug is set, describef sets a printf-formatted description for action a.
        // Otherwise, it is a no-op.
    **/
    @:keep
    static public function _describef( _a:stdgo.Ref<T_action>, _pos:T_positioner, _format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):Void {
        var _args = new stdgo.Slice<stdgo.AnyInterface>(_args.length, 0, ..._args);
        @:recv var _a:stdgo.Ref<T_action> = _a;
        if (false) {
            _a._desc = (stdgo.Go.setRef((new stdgo.go.types.Types.T_actionDesc(_pos, _format?.__copy__(), _args) : stdgo.go.types.Types.T_actionDesc)) : stdgo.Ref<stdgo.go.types.Types.T_actionDesc>);
        };
    }
}
class Checker_asInterface {
    /**
        // verifyVersionf is like allowVersion but also accepts a format string and arguments
        // which are used to report a version error if allowVersion returns false. It uses the
        // current package.
    **/
    @:keep
    public dynamic function _verifyVersionf(_at:T_positioner, _v:T_version, _format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):Bool return __self__.value._verifyVersionf(_at, _v, _format, ..._args);
    /**
        // allowVersion reports whether the given package
        // is allowed to use version major.minor.
    **/
    @:keep
    public dynamic function _allowVersion(_pkg:stdgo.Ref<Package>, _at:T_positioner, _v:T_version):Bool return __self__.value._allowVersion(_pkg, _at, _v);
    /**
        // langCompat reports an error if the representation of a numeric
        // literal is not compatible with the current language version.
    **/
    @:keep
    public dynamic function _langCompat(_lit:stdgo.Ref<stdgo.go.ast.Ast.BasicLit>):Void __self__.value._langCompat(_lit);
    /**
        // validType0 checks if the given type is valid. If typ is a type parameter
        // its value is looked up in the type argument list of the instantiated
        // (enclosing) type, if it exists. Otherwise the type parameter must be from
        // an enclosing function and can be ignored.
        // The nest list describes the stack (the "nest in memory") of types which
        // contain (or embed in the case of interfaces) other types. For instance, a
        // struct named S which contains a field of named type F contains (the memory
        // of) F in S, leading to the nest S->F. If a type appears in its own nest
        // (say S->F->S) we have an invalid recursive type. The path list is the full
        // path of named types in a cycle, it is only needed for error reporting.
    **/
    @:keep
    public dynamic function _validType0(_typ:Type_, _nest:stdgo.Slice<stdgo.Ref<Named>>, _path:stdgo.Slice<stdgo.Ref<Named>>):Bool return __self__.value._validType0(_typ, _nest, _path);
    /**
        // validType verifies that the given type does not "expand" indefinitely
        // producing a cycle in the type graph.
        // (Cycles involving alias types, as in "type A = [10]A" are detected
        // earlier, via the objDecl cycle detection mechanism.)
    **/
    @:keep
    public dynamic function _validType(_typ:stdgo.Ref<Named>):Void __self__.value._validType(_typ);
    /**
        // typeList provides the list of types corresponding to the incoming expression list.
        // If an error occurred, the result is nil, but all list elements were type-checked.
    **/
    @:keep
    public dynamic function _typeList(_list:stdgo.Slice<stdgo.go.ast.Ast.Expr>):stdgo.Slice<Type_> return __self__.value._typeList(_list);
    /**
        // arrayLength type-checks the array length expression e
        // and returns the constant length >= 0, or a value < 0
        // to indicate an error (and thus an unknown length).
    **/
    @:keep
    public dynamic function _arrayLength(_e:stdgo.go.ast.Ast.Expr):stdgo.GoInt64 return __self__.value._arrayLength(_e);
    @:keep
    public dynamic function _instantiatedType(_ix:stdgo.Ref<stdgo.go.internal.typeparams.Typeparams.IndexExpr>, _def:stdgo.Ref<Named>):Type_ return __self__.value._instantiatedType(_ix, _def);
    /**
        // typInternal drives type checking of types.
        // Must only be called by definedType or genericType.
    **/
    @:keep
    public dynamic function _typInternal(_e0:stdgo.go.ast.Ast.Expr, _def:stdgo.Ref<Named>):Type_ return __self__.value._typInternal(_e0, _def);
    /**
        // genericType is like typ but the type must be an (uninstantiated) generic
        // type. If cause is non-nil and the type expression was a valid type but not
        // generic, cause will be populated with a message describing the error.
    **/
    @:keep
    public dynamic function _genericType(_e:stdgo.go.ast.Ast.Expr, _cause:stdgo.Pointer<stdgo.GoString>):Type_ return __self__.value._genericType(_e, _cause);
    /**
        // definedType is like typ but also accepts a type name def.
        // If def != nil, e is the type specification for the defined type def, declared
        // in a type declaration, and def.underlying will be set to the type of e before
        // any components of e are type-checked.
    **/
    @:keep
    public dynamic function _definedType(_e:stdgo.go.ast.Ast.Expr, _def:stdgo.Ref<Named>):Type_ return __self__.value._definedType(_e, _def);
    /**
        // validVarType reports an error if typ is a constraint interface.
        // The expression e is used for error reporting, if any.
    **/
    @:keep
    public dynamic function _validVarType(_e:stdgo.go.ast.Ast.Expr, _typ:Type_):Void __self__.value._validVarType(_e, _typ);
    /**
        // varType type-checks the type expression e and returns its type, or Typ[Invalid].
        // The type must not be an (uninstantiated) generic type and it must not be a
        // constraint interface.
    **/
    @:keep
    public dynamic function _varType(_e:stdgo.go.ast.Ast.Expr):Type_ return __self__.value._varType(_e);
    /**
        // typ type-checks the type expression e and returns its type, or Typ[Invalid].
        // The type must not be an (uninstantiated) generic type.
    **/
    @:keep
    public dynamic function _typ(_e:stdgo.go.ast.Ast.Expr):Type_ return __self__.value._typ(_e);
    /**
        // ident type-checks identifier e and initializes x with the value or type of e.
        // If an error occurred, x.mode is set to invalid.
        // For the meaning of def, see Checker.definedType, below.
        // If wantType is set, the identifier e is expected to denote a type.
    **/
    @:keep
    public dynamic function _ident(_x:stdgo.Ref<T_operand>, _e:stdgo.Ref<stdgo.go.ast.Ast.Ident>, _def:stdgo.Ref<Named>, _wantType:Bool):Void __self__.value._ident(_x, _e, _def, _wantType);
    /**
        // check may be nil
    **/
    @:keep
    public dynamic function _newTypeParam(_obj:stdgo.Ref<TypeName>, _constraint:Type_):stdgo.Ref<TypeParam> return __self__.value._newTypeParam(_obj, _constraint);
    /**
        // subst returns the type typ with its type parameters tpars replaced by the
        // corresponding type arguments targs, recursively. subst doesn't modify the
        // incoming type. If a substitution took place, the result type is different
        // from the incoming type.
        //
        // If expanding is non-nil, it is the instance type currently being expanded.
        // One of expanding or ctxt must be non-nil.
    **/
    @:keep
    public dynamic function _subst(_pos:stdgo.go.token.Token.Pos, _typ:Type_, _smap:T_substMap, _expanding:stdgo.Ref<Named>, _ctxt:stdgo.Ref<Context>):Type_ return __self__.value._subst(_pos, _typ, _smap, _expanding, _ctxt);
    @:keep
    public dynamic function _tag(_t:stdgo.Ref<stdgo.go.ast.Ast.BasicLit>):stdgo.GoString return __self__.value._tag(_t);
    @:keep
    public dynamic function _declareInSet(_oset:stdgo.Ref<T_objset>, _pos:stdgo.go.token.Token.Pos, _obj:Object):Bool return __self__.value._declareInSet(_oset, _pos, _obj);
    @:keep
    public dynamic function _structType(_styp:stdgo.Ref<Struct>, _e:stdgo.Ref<stdgo.go.ast.Ast.StructType>):Void __self__.value._structType(_styp, _e);
    /**
        // stmt typechecks statement s.
    **/
    @:keep
    public dynamic function _stmt(_ctxt:T_stmtContext, _s:stdgo.go.ast.Ast.Stmt):Void __self__.value._stmt(_ctxt, _s);
    /**
        // If the type switch expression is invalid, x is nil.
    **/
    @:keep
    public dynamic function _caseTypes(_x:stdgo.Ref<T_operand>, _types:stdgo.Slice<stdgo.go.ast.Ast.Expr>, _seen:stdgo.GoMap<Type_, stdgo.go.ast.Ast.Expr>):Type_ return __self__.value._caseTypes(_x, _types, _seen);
    /**
        // isNil reports whether the expression e denotes the predeclared value nil.
    **/
    @:keep
    public dynamic function _isNil(_e:stdgo.go.ast.Ast.Expr):Bool return __self__.value._isNil(_e);
    @:keep
    public dynamic function _caseValues(_x:stdgo.Ref<T_operand>, _values:stdgo.Slice<stdgo.go.ast.Ast.Expr>, _seen:T_valueMap):Void __self__.value._caseValues(_x, _values, _seen);
    @:keep
    public dynamic function _suspendedCall(_keyword:stdgo.GoString, _call:stdgo.Ref<stdgo.go.ast.Ast.CallExpr>):Void __self__.value._suspendedCall(_keyword, _call);
    @:keep
    public dynamic function _closeScope():Void __self__.value._closeScope();
    @:keep
    public dynamic function _openScope(_node:stdgo.go.ast.Ast.Node, _comment:stdgo.GoString):Void __self__.value._openScope(_node, _comment);
    @:keep
    public dynamic function _multipleDefaults(_list:stdgo.Slice<stdgo.go.ast.Ast.Stmt>):Void __self__.value._multipleDefaults(_list);
    @:keep
    public dynamic function _stmtList(_ctxt:T_stmtContext, _list:stdgo.Slice<stdgo.go.ast.Ast.Stmt>):Void __self__.value._stmtList(_ctxt, _list);
    @:keep
    public dynamic function _simpleStmt(_s:stdgo.go.ast.Ast.Stmt):Void __self__.value._simpleStmt(_s);
    @:keep
    public dynamic function _usage(_scope:stdgo.Ref<Scope>):Void __self__.value._usage(_scope);
    @:keep
    public dynamic function _funcBody(_decl:stdgo.Ref<T_declInfo>, _name:stdgo.GoString, _sig:stdgo.Ref<Signature>, _body:stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>, _iota:stdgo.go.constant.Constant.Value):Void __self__.value._funcBody(_decl, _name, _sig, _body, _iota);
    /**
        // collectParams declares the parameters of list in scope and returns the corresponding
        // variable list.
    **/
    @:keep
    public dynamic function _collectParams(_scope:stdgo.Ref<Scope>, _list:stdgo.Ref<stdgo.go.ast.Ast.FieldList>, _variadicOk:Bool):{ var _0 : stdgo.Slice<stdgo.Ref<Var>>; var _1 : Bool; } return __self__.value._collectParams(_scope, _list, _variadicOk);
    /**
        // funcType type-checks a function or method type.
    **/
    @:keep
    public dynamic function _funcType(_sig:stdgo.Ref<Signature>, _recvPar:stdgo.Ref<stdgo.go.ast.Ast.FieldList>, _ftyp:stdgo.Ref<stdgo.go.ast.Ast.FuncType>):Void __self__.value._funcType(_sig, _recvPar, _ftyp);
    @:keep
    public dynamic function _isTerminatingSwitch(_body:stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>, _label:stdgo.GoString):Bool return __self__.value._isTerminatingSwitch(_body, _label);
    @:keep
    public dynamic function _isTerminatingList(_list:stdgo.Slice<stdgo.go.ast.Ast.Stmt>, _label:stdgo.GoString):Bool return __self__.value._isTerminatingList(_list, _label);
    /**
        // isTerminating reports if s is a terminating statement.
        // If s is labeled, label is the label name; otherwise s
        // is "".
    **/
    @:keep
    public dynamic function _isTerminating(_s:stdgo.go.ast.Ast.Stmt, _label:stdgo.GoString):Bool return __self__.value._isTerminating(_s, _label);
    @:keep
    public dynamic function _errorUnusedPkg(_obj:stdgo.Ref<PkgName>):Void __self__.value._errorUnusedPkg(_obj);
    /**
        // unusedImports checks for unused imports.
    **/
    @:keep
    public dynamic function _unusedImports():Void __self__.value._unusedImports();
    /**
        // packageObjects typechecks all package objects, but not function bodies.
    **/
    @:keep
    public dynamic function _packageObjects():Void __self__.value._packageObjects();
    /**
        // resolveBaseTypeName returns the non-alias base type name for typ, and whether
        // there was a pointer indirection to get to it. The base type name must be declared
        // in package scope, and there can be at most one pointer indirection. If no such type
        // name exists, the returned base is nil.
    **/
    @:keep
    public dynamic function _resolveBaseTypeName(_seenPtr:Bool, _typ:stdgo.go.ast.Ast.Expr, _fileScopes:stdgo.Slice<stdgo.Ref<Scope>>):{ var _0 : Bool; var _1 : stdgo.Ref<TypeName>; } return __self__.value._resolveBaseTypeName(_seenPtr, _typ, _fileScopes);
    /**
        // unpackRecv unpacks a receiver type and returns its components: ptr indicates whether
        // rtyp is a pointer receiver, rname is the receiver type name, and tparams are its
        // type parameters, if any. The type parameters are only unpacked if unpackParams is
        // set. If rname is nil, the receiver is unusable (i.e., the source has a bug which we
        // cannot easily work around).
    **/
    @:keep
    public dynamic function _unpackRecv(_rtyp:stdgo.go.ast.Ast.Expr, _unpackParams:Bool):{ var _0 : Bool; var _1 : stdgo.Ref<stdgo.go.ast.Ast.Ident>; var _2 : stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.Ident>>; } return __self__.value._unpackRecv(_rtyp, _unpackParams);
    /**
        // collectObjects collects all file and package objects and inserts them
        // into their respective scopes. It also performs imports and associates
        // methods with receiver base type names.
    **/
    @:keep
    public dynamic function _collectObjects():Void __self__.value._collectObjects();
    @:keep
    public dynamic function _importPackage(_at:T_positioner, _path:stdgo.GoString, _dir:stdgo.GoString):stdgo.Ref<Package> return __self__.value._importPackage(_at, _path, _dir);
    /**
        // filename returns a filename suitable for debugging output.
    **/
    @:keep
    public dynamic function _filename(_fileNo:stdgo.GoInt):stdgo.GoString return __self__.value._filename(_fileNo);
    /**
        // declarePkgObj declares obj in the package scope, records its ident -> obj mapping,
        // and updates check.objMap. The object must not be a function or method.
    **/
    @:keep
    public dynamic function _declarePkgObj(_ident:stdgo.Ref<stdgo.go.ast.Ast.Ident>, _obj:Object, _d:stdgo.Ref<T_declInfo>):Void __self__.value._declarePkgObj(_ident, _obj, _d);
    /**
        // arityMatch checks that the lhs and rhs of a const or var decl
        // have the appropriate number of names and init exprs. For const
        // decls, init is the value spec providing the init exprs; for
        // var decls, init is nil (the init exprs are in s in this case).
    **/
    @:keep
    public dynamic function _arityMatch(_s:stdgo.Ref<stdgo.go.ast.Ast.ValueSpec>, _init:stdgo.Ref<stdgo.go.ast.Ast.ValueSpec>):Void __self__.value._arityMatch(_s, _init);
    /**
        // context returns the type-checker context.
    **/
    @:keep
    public dynamic function _context():stdgo.Ref<Context> return __self__.value._context();
    /**
        // newNamedInstance creates a new named instance for the given origin and type
        // arguments, recording pos as the position of its synthetic object (for error
        // reporting).
        //
        // If set, expanding is the named type instance currently being expanded, that
        // led to the creation of this instance.
    **/
    @:keep
    public dynamic function _newNamedInstance(_pos:stdgo.go.token.Token.Pos, _orig:stdgo.Ref<Named>, _targs:stdgo.Slice<Type_>, _expanding:stdgo.Ref<Named>):stdgo.Ref<Named> return __self__.value._newNamedInstance(_pos, _orig, _targs, _expanding);
    /**
        // newNamed is like NewNamed but with a *Checker receiver and additional orig argument.
    **/
    @:keep
    public dynamic function _newNamed(_obj:stdgo.Ref<TypeName>, _underlying:Type_, _methods:stdgo.Slice<stdgo.Ref<Func>>):stdgo.Ref<Named> return __self__.value._newNamed(_obj, _underlying, _methods);
    @:keep
    public dynamic function _reportInstanceLoop(_v:stdgo.GoInt):Void __self__.value._reportInstanceLoop(_v);
    @:keep
    public dynamic function _monomorph():Void __self__.value._monomorph();
    /**
        // newAssertableTo reports whether a value of type V can be asserted to have type T.
        // It also implements behavior for interfaces that currently are only permitted
        // in constraint position (we have not yet defined that behavior in the spec).
        // The underlying type of V must be an interface.
        // If the result is false and cause is not nil, *cause is set to the error cause.
    **/
    @:keep
    public dynamic function _newAssertableTo(_pos:stdgo.go.token.Token.Pos, v:Type_, t:Type_, _cause:stdgo.Pointer<stdgo.GoString>):Bool return __self__.value._newAssertableTo(_pos, v, t, _cause);
    /**
        // assertableTo reports whether a value of type V can be asserted to have type T.
        // The receiver may be nil if assertableTo is invoked through an exported API call
        // (such as AssertableTo), i.e., when all methods have been type-checked.
        // The underlying type of V must be an interface.
        // If the result is false and cause is not nil, *cause describes the error.
        // TODO(gri) replace calls to this function with calls to newAssertableTo.
    **/
    @:keep
    public dynamic function _assertableTo(v:Type_, t:Type_, _cause:stdgo.Pointer<stdgo.GoString>):Bool return __self__.value._assertableTo(v, t, _cause);
    /**
        // funcString returns a string of the form name + signature for f.
        // check may be nil.
    **/
    @:keep
    public dynamic function _funcString(_f:stdgo.Ref<Func>, _pkgInfo:Bool):stdgo.GoString return __self__.value._funcString(_f, _pkgInfo);
    /**
        // check may be nil.
    **/
    @:keep
    public dynamic function _interfacePtrError(t:Type_):stdgo.GoString return __self__.value._interfacePtrError(t);
    /**
        // missingMethod is like MissingMethod but accepts a *Checker as receiver,
        // a comparator equivalent for type comparison, and a *string for error causes.
        // The receiver may be nil if missingMethod is invoked through an exported
        // API call (such as MissingMethod), i.e., when all methods have been type-
        // checked.
        // The underlying type of T must be an interface; T (rather than its under-
        // lying type) is used for better error messages (reported through *cause).
        // The comparator is used to compare signatures.
        // If a method is missing and cause is not nil, *cause describes the error.
    **/
    @:keep
    public dynamic function _missingMethod(v:Type_, t:Type_, _static:Bool, _equivalent:(_x:Type_, _y:Type_) -> Bool, _cause:stdgo.Pointer<stdgo.GoString>):{ var _0 : stdgo.Ref<Func>; var _1 : Bool; } return __self__.value._missingMethod(v, t, _static, _equivalent, _cause);
    /**
        // blockBranches processes a block's statement list and returns the set of outgoing forward jumps.
        // all is the scope of all declared labels, parent the set of labels declared in the immediately
        // enclosing block, and lstmt is the labeled statement this block is associated with (or nil).
    **/
    @:keep
    public dynamic function _blockBranches(_all:stdgo.Ref<Scope>, _parent:stdgo.Ref<T_block>, _lstmt:stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>, _list:stdgo.Slice<stdgo.go.ast.Ast.Stmt>):stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>> return __self__.value._blockBranches(_all, _parent, _lstmt, _list);
    /**
        // labels checks correct label use in body.
    **/
    @:keep
    public dynamic function _labels(_body:stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>):Void __self__.value._labels(_body);
    @:keep
    public dynamic function _interfaceType(_ityp:stdgo.Ref<Interface>, _iface:stdgo.Ref<stdgo.go.ast.Ast.InterfaceType>, _def:stdgo.Ref<Named>):Void __self__.value._interfaceType(_ityp, _iface, _def);
    /**
        // check may be nil
    **/
    @:keep
    public dynamic function _newInterface():stdgo.Ref<Interface> return __self__.value._newInterface();
    /**
        // implements checks if V implements T. The receiver may be nil if implements
        // is called through an exported API call such as AssignableTo. If constraint
        // is set, T is a type constraint.
        //
        // If the provided cause is non-nil, it may be set to an error string
        // explaining why V does not implement (or satisfy, for constraints) T.
    **/
    @:keep
    public dynamic function _implements(_pos:stdgo.go.token.Token.Pos, v:Type_, t:Type_, _constraint:Bool, _cause:stdgo.Pointer<stdgo.GoString>):Bool return __self__.value._implements(_pos, v, t, _constraint, _cause);
    @:keep
    public dynamic function _verify(_pos:stdgo.go.token.Token.Pos, _tparams:stdgo.Slice<stdgo.Ref<TypeParam>>, _targs:stdgo.Slice<Type_>, _ctxt:stdgo.Ref<Context>):{ var _0 : stdgo.GoInt; var _1 : stdgo.Error; } return __self__.value._verify(_pos, _tparams, _targs, _ctxt);
    /**
        // validateTArgLen verifies that the length of targs and tparams matches,
        // reporting an error if not. If validation fails and check is nil,
        // validateTArgLen panics.
    **/
    @:keep
    public dynamic function _validateTArgLen(_pos:stdgo.go.token.Token.Pos, _ntparams:stdgo.GoInt, _ntargs:stdgo.GoInt):Bool return __self__.value._validateTArgLen(_pos, _ntparams, _ntargs);
    /**
        // instance instantiates the given original (generic) function or type with the
        // provided type arguments and returns the resulting instance. If an identical
        // instance exists already in the given contexts, it returns that instance,
        // otherwise it creates a new one.
        //
        // If expanding is non-nil, it is the Named instance type currently being
        // expanded. If ctxt is non-nil, it is the context associated with the current
        // type-checking pass or call to Instantiate. At least one of expanding or ctxt
        // must be non-nil.
        //
        // For Named types the resulting instance may be unexpanded.
    **/
    @:keep
    public dynamic function _instance(_pos:stdgo.go.token.Token.Pos, _orig:Type_, _targs:stdgo.Slice<Type_>, _expanding:stdgo.Ref<Named>, _ctxt:stdgo.Ref<Context>):Type_ return __self__.value._instance(_pos, _orig, _targs, _expanding, _ctxt);
    /**
        // reportCycle reports an error for the given cycle.
    **/
    @:keep
    public dynamic function _reportCycle(_cycle:stdgo.Slice<Object>):Void __self__.value._reportCycle(_cycle);
    /**
        // initOrder computes the Info.InitOrder for package variables.
    **/
    @:keep
    public dynamic function _initOrder():Void __self__.value._initOrder();
    /**
        // renameTParams renames the type parameters in the given type such that each type
        // parameter is given a new identity. renameTParams returns the new type parameters
        // and updated type. If the result type is unchanged from the argument type, none
        // of the type parameters in tparams occurred in the type.
        // If typ is a generic function, type parameters held with typ are not changed and
        // must be updated separately if desired.
        // The positions is only used for debug traces.
    **/
    @:keep
    public dynamic function _renameTParams(_pos:stdgo.go.token.Token.Pos, _tparams:stdgo.Slice<stdgo.Ref<TypeParam>>, _typ:Type_):{ var _0 : stdgo.Slice<stdgo.Ref<TypeParam>>; var _1 : Type_; } return __self__.value._renameTParams(_pos, _tparams, _typ);
    /**
        // infer attempts to infer the complete set of type arguments for generic function instantiation/call
        // based on the given type parameters tparams, type arguments targs, function parameters params, and
        // function arguments args, if any. There must be at least one type parameter, no more type arguments
        // than type parameters, and params and args must match in number (incl. zero).
        // If successful, infer returns the complete list of given and inferred type arguments, one for each
        // type parameter. Otherwise the result is nil and appropriate errors will be reported.
    **/
    @:keep
    public dynamic function _infer(_posn:T_positioner, _tparams:stdgo.Slice<stdgo.Ref<TypeParam>>, _targs:stdgo.Slice<Type_>, _params:stdgo.Ref<Tuple>, _args:stdgo.Slice<stdgo.Ref<T_operand>>):stdgo.Slice<Type_> return __self__.value._infer(_posn, _tparams, _targs, _params, _args);
    /**
        // indexedElts checks the elements (elts) of an array or slice composite literal
        // against the literal's element type (typ), and the element indices against
        // the literal length if known (length >= 0). It returns the length of the
        // literal (maximum index value + 1).
    **/
    @:keep
    public dynamic function _indexedElts(_elts:stdgo.Slice<stdgo.go.ast.Ast.Expr>, _typ:Type_, _length:stdgo.GoInt64):stdgo.GoInt64 return __self__.value._indexedElts(_elts, _typ, _length);
    @:keep
    public dynamic function _isValidIndex(_x:stdgo.Ref<T_operand>, _code:Code, _what:stdgo.GoString, _allowNegative:Bool):Bool return __self__.value._isValidIndex(_x, _code, _what, _allowNegative);
    /**
        // index checks an index expression for validity.
        // If max >= 0, it is the upper bound for index.
        // If the result typ is != Typ[Invalid], index is valid and typ is its (possibly named) integer type.
        // If the result val >= 0, index is valid and val is its constant int value.
    **/
    @:keep
    public dynamic function _index(_index:stdgo.go.ast.Ast.Expr, _max:stdgo.GoInt64):{ var _0 : Type_; var _1 : stdgo.GoInt64; } return __self__.value._index(_index, _max);
    /**
        // singleIndex returns the (single) index from the index expression e.
        // If the index is missing, or if there are multiple indices, an error
        // is reported and the result is nil.
    **/
    @:keep
    public dynamic function _singleIndex(_expr:stdgo.Ref<stdgo.go.internal.typeparams.Typeparams.IndexExpr>):stdgo.go.ast.Ast.Expr return __self__.value._singleIndex(_expr);
    @:keep
    public dynamic function _sliceExpr(_x:stdgo.Ref<T_operand>, _e:stdgo.Ref<stdgo.go.ast.Ast.SliceExpr>):Void __self__.value._sliceExpr(_x, _e);
    /**
        // If e is a valid function instantiation, indexExpr returns true.
        // In that case x represents the uninstantiated function value and
        // it is the caller's responsibility to instantiate the function.
    **/
    @:keep
    public dynamic function _indexExpr(_x:stdgo.Ref<T_operand>, _e:stdgo.Ref<stdgo.go.internal.typeparams.Typeparams.IndexExpr>):Bool return __self__.value._indexExpr(_x, _e);
    /**
        // singleValue reports an error if x describes a tuple and sets x.mode to invalid.
    **/
    @:keep
    public dynamic function _singleValue(_x:stdgo.Ref<T_operand>):Void __self__.value._singleValue(_x);
    /**
        // exclude reports an error if x.mode is in modeset and sets x.mode to invalid.
        // The modeset may contain any of 1<<novalue, 1<<builtin, 1<<typexpr.
    **/
    @:keep
    public dynamic function _exclude(_x:stdgo.Ref<T_operand>, _modeset:stdgo.GoUInt):Void __self__.value._exclude(_x, _modeset);
    /**
        // exprOrType typechecks expression or type e and initializes x with the expression value or type.
        // If allowGeneric is set, the operand type may be an uninstantiated parameterized type or function
        // value.
        // If an error occurred, x.mode is set to invalid.
    **/
    @:keep
    public dynamic function _exprOrType(_x:stdgo.Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _allowGeneric:Bool):Void __self__.value._exprOrType(_x, _e, _allowGeneric);
    /**
        // exprWithHint typechecks expression e and initializes x with the expression value;
        // hint is the type of a composite literal element.
        // If an error occurred, x.mode is set to invalid.
    **/
    @:keep
    public dynamic function _exprWithHint(_x:stdgo.Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _hint:Type_):Void __self__.value._exprWithHint(_x, _e, _hint);
    /**
        // multiExpr typechecks e and returns its value (or values) in list.
        // If allowCommaOk is set and e is a map index, comma-ok, or comma-err
        // expression, the result is a two-element list containing the value
        // of e, and an untyped bool value or an error value, respectively.
        // If an error occurred, list[0] is not valid.
    **/
    @:keep
    public dynamic function _multiExpr(_e:stdgo.go.ast.Ast.Expr, _allowCommaOk:Bool):{ var _0 : stdgo.Slice<stdgo.Ref<T_operand>>; var _1 : Bool; } return __self__.value._multiExpr(_e, _allowCommaOk);
    /**
        // genericExpr is like expr but the result may also be generic.
    **/
    @:keep
    public dynamic function _genericExpr(_x:stdgo.Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr):Void __self__.value._genericExpr(_x, _e);
    /**
        // expr typechecks expression e and initializes x with the expression value.
        // If a non-nil target type T is given and e is a generic function
        // or function call, T is used to infer the type arguments for e.
        // The result must be a single value.
        // If an error occurred, x.mode is set to invalid.
    **/
    @:keep
    public dynamic function _expr(t:Type_, _x:stdgo.Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr):Void __self__.value._expr(t, _x, _e);
    /**
        // typeAssertion checks x.(T). The type of x must be an interface.
    **/
    @:keep
    public dynamic function _typeAssertion(_e:stdgo.go.ast.Ast.Expr, _x:stdgo.Ref<T_operand>, t:Type_, _typeSwitch:Bool):Void __self__.value._typeAssertion(_e, _x, t, _typeSwitch);
    /**
        // exprInternal contains the core of type checking of expressions.
        // Must only be called by rawExpr.
        // (See rawExpr for an explanation of the parameters.)
    **/
    @:keep
    public dynamic function _exprInternal(t:Type_, _x:stdgo.Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _hint:Type_):T_exprKind return __self__.value._exprInternal(t, _x, _e, _hint);
    /**
        // If x is a generic type, or a generic function whose type arguments cannot be inferred
        // from a non-nil target type T, nonGeneric reports an error and invalidates x.mode and x.typ.
        // Otherwise it leaves x alone.
    **/
    @:keep
    public dynamic function _nonGeneric(t:Type_, _x:stdgo.Ref<T_operand>):Void __self__.value._nonGeneric(t, _x);
    /**
        // rawExpr typechecks expression e and initializes x with the expression
        // value or type. If an error occurred, x.mode is set to invalid.
        // If a non-nil target type T is given and e is a generic function
        // or function call, T is used to infer the type arguments for e.
        // If hint != nil, it is the type of a composite literal element.
        // If allowGeneric is set, the operand type may be an uninstantiated
        // parameterized type or function value.
    **/
    @:keep
    public dynamic function _rawExpr(t:Type_, _x:stdgo.Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _hint:Type_, _allowGeneric:Bool):T_exprKind return __self__.value._rawExpr(t, _x, _e, _hint, _allowGeneric);
    /**
        // matchTypes attempts to convert any untyped types x and y such that they match.
        // If an error occurs, x.mode is set to invalid.
    **/
    @:keep
    public dynamic function _matchTypes(_x:stdgo.Ref<T_operand>, _y:stdgo.Ref<T_operand>):Void __self__.value._matchTypes(_x, _y);
    /**
        // If e != nil, it must be the binary expression; it may be nil for non-constant expressions
        // (when invoked for an assignment operation where the binary expression is implicit).
    **/
    @:keep
    public dynamic function _binary(_x:stdgo.Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _lhs:stdgo.go.ast.Ast.Expr, _rhs:stdgo.go.ast.Ast.Expr, _op:stdgo.go.token.Token.Token, _opPos:stdgo.go.token.Token.Pos):Void __self__.value._binary(_x, _e, _lhs, _rhs, _op, _opPos);
    /**
        // If e != nil, it must be the shift expression; it may be nil for non-constant shifts.
    **/
    @:keep
    public dynamic function _shift(_x:stdgo.Ref<T_operand>, _y:stdgo.Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _op:stdgo.go.token.Token.Token):Void __self__.value._shift(_x, _y, _e, _op);
    /**
        // kindString returns the type kind as a string.
    **/
    @:keep
    public dynamic function _kindString(_typ:Type_):stdgo.GoString return __self__.value._kindString(_typ);
    /**
        // incomparableCause returns a more specific cause why typ is not comparable.
        // If there is no more specific cause, the result is "".
    **/
    @:keep
    public dynamic function _incomparableCause(_typ:Type_):stdgo.GoString return __self__.value._incomparableCause(_typ);
    /**
        // If switchCase is true, the operator op is ignored.
    **/
    @:keep
    public dynamic function _comparison(_x:stdgo.Ref<T_operand>, _y:stdgo.Ref<T_operand>, _op:stdgo.go.token.Token.Token, _switchCase:Bool):Void __self__.value._comparison(_x, _y, _op, _switchCase);
    /**
        // implicitTypeAndValue returns the implicit type of x when used in a context
        // where the target type is expected. If no such implicit conversion is
        // possible, it returns a nil Type and non-zero error code.
        //
        // If x is a constant operand, the returned constant.Value will be the
        // representation of x in this context.
    **/
    @:keep
    public dynamic function _implicitTypeAndValue(_x:stdgo.Ref<T_operand>, _target:Type_):{ var _0 : Type_; var _1 : stdgo.go.constant.Constant.Value; var _2 : Code; } return __self__.value._implicitTypeAndValue(_x, _target);
    /**
        // updateExprVal updates the value of x to val.
    **/
    @:keep
    public dynamic function _updateExprVal(_x:stdgo.go.ast.Ast.Expr, _val:stdgo.go.constant.Constant.Value):Void __self__.value._updateExprVal(_x, _val);
    @:keep
    public dynamic function _updateExprType0(_parent:stdgo.go.ast.Ast.Expr, _x:stdgo.go.ast.Ast.Expr, _typ:Type_, _final:Bool):Void __self__.value._updateExprType0(_parent, _x, _typ, _final);
    /**
        // updateExprType updates the type of x to typ and invokes itself
        // recursively for the operands of x, depending on expression kind.
        // If typ is still an untyped and not the final type, updateExprType
        // only updates the recorded untyped type for x and possibly its
        // operands. Otherwise (i.e., typ is not an untyped type anymore,
        // or it is the final type for x), the type and value are recorded.
        // Also, if x is a constant, it must be representable as a value of typ,
        // and if x is the (formerly untyped) lhs operand of a non-constant
        // shift, it must be an integer value.
    **/
    @:keep
    public dynamic function _updateExprType(_x:stdgo.go.ast.Ast.Expr, _typ:Type_, _final:Bool):Void __self__.value._updateExprType(_x, _typ, _final);
    /**
        // The unary expression e may be nil. It's passed in for better error messages only.
    **/
    @:keep
    public dynamic function _unary(_x:stdgo.Ref<T_operand>, _e:stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>):Void __self__.value._unary(_x, _e);
    @:keep
    public dynamic function _op(_m:T_opPredicates, _x:stdgo.Ref<T_operand>, _op:stdgo.go.token.Token.Token):Bool return __self__.value._op(_m, _x, _op);
    @:keep
    public dynamic function _versionErrorf(_at:T_positioner, _v:T_version, _format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):Void __self__.value._versionErrorf(_at, _v, _format, ..._args);
    @:keep
    public dynamic function _softErrorf(_at:T_positioner, _code:Code, _format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):Void __self__.value._softErrorf(_at, _code, _format, ..._args);
    @:keep
    public dynamic function _errorf(_at:T_positioner, _code:Code, _format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):Void __self__.value._errorf(_at, _code, _format, ..._args);
    @:keep
    public dynamic function _error(_at:T_positioner, _code:Code, _msg:stdgo.GoString):Void __self__.value._error(_at, _code, _msg);
    /**
        // Report records the error pointed to by errp, setting check.firstError if
        // necessary.
    **/
    @:keep
    public dynamic function _report(_errp:stdgo.Ref<T_error_>):Void __self__.value._report(_errp);
    /**
        // dump is only needed for debugging
    **/
    @:keep
    public dynamic function _dump(_format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):Void __self__.value._dump(_format, ..._args);
    @:keep
    public dynamic function _trace(_pos:stdgo.go.token.Token.Pos, _format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):Void __self__.value._trace(_pos, _format, ..._args);
    /**
        // check may be nil.
    **/
    @:keep
    public dynamic function _sprintf(_format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):stdgo.GoString return __self__.value._sprintf(_format, ..._args);
    /**
        // markImports recursively walks pkg and its imports, to record unique import
        // paths in pkgPathMap.
    **/
    @:keep
    public dynamic function _markImports(_pkg:stdgo.Ref<Package>):Void __self__.value._markImports(_pkg);
    @:keep
    public dynamic function _qualifier(_pkg:stdgo.Ref<Package>):stdgo.GoString return __self__.value._qualifier(_pkg);
    @:keep
    public dynamic function _declStmt(_d:stdgo.go.ast.Ast.Decl):Void __self__.value._declStmt(_d);
    @:keep
    public dynamic function _funcDecl(_obj:stdgo.Ref<Func>, _decl:stdgo.Ref<T_declInfo>):Void __self__.value._funcDecl(_obj, _decl);
    @:keep
    public dynamic function _checkFieldUniqueness(_base:stdgo.Ref<Named>):Void __self__.value._checkFieldUniqueness(_base);
    @:keep
    public dynamic function _collectMethods(_obj:stdgo.Ref<TypeName>):Void __self__.value._collectMethods(_obj);
    @:keep
    public dynamic function _declareTypeParams(_tparams:stdgo.Slice<stdgo.Ref<TypeParam>>, _names:stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.Ident>>):stdgo.Slice<stdgo.Ref<TypeParam>> return __self__.value._declareTypeParams(_tparams, _names);
    @:keep
    public dynamic function _bound(_x:stdgo.go.ast.Ast.Expr):Type_ return __self__.value._bound(_x);
    @:keep
    public dynamic function _collectTypeParams(_dst:stdgo.Ref<stdgo.Ref<TypeParamList>>, _list:stdgo.Ref<stdgo.go.ast.Ast.FieldList>):Void __self__.value._collectTypeParams(_dst, _list);
    @:keep
    public dynamic function _typeDecl(_obj:stdgo.Ref<TypeName>, _tdecl:stdgo.Ref<stdgo.go.ast.Ast.TypeSpec>, _def:stdgo.Ref<Named>):Void __self__.value._typeDecl(_obj, _tdecl, _def);
    /**
        // isImportedConstraint reports whether typ is an imported type constraint.
    **/
    @:keep
    public dynamic function _isImportedConstraint(_typ:Type_):Bool return __self__.value._isImportedConstraint(_typ);
    @:keep
    public dynamic function _varDecl(_obj:stdgo.Ref<Var>, _lhs:stdgo.Slice<stdgo.Ref<Var>>, _typ:stdgo.go.ast.Ast.Expr, _init:stdgo.go.ast.Ast.Expr):Void __self__.value._varDecl(_obj, _lhs, _typ, _init);
    @:keep
    public dynamic function _constDecl(_obj:stdgo.Ref<Const>, _typ:stdgo.go.ast.Ast.Expr, _init:stdgo.go.ast.Ast.Expr, _inherited:Bool):Void __self__.value._constDecl(_obj, _typ, _init, _inherited);
    @:keep
    public dynamic function _walkDecl(_d:stdgo.go.ast.Ast.Decl, _f:T_decl -> Void):Void __self__.value._walkDecl(_d, _f);
    @:keep
    public dynamic function _walkDecls(_decls:stdgo.Slice<stdgo.go.ast.Ast.Decl>, _f:T_decl -> Void):Void __self__.value._walkDecls(_decls, _f);
    /**
        // cycleError reports a declaration cycle starting with
        // the object in cycle that is "first" in the source.
    **/
    @:keep
    public dynamic function _cycleError(_cycle:stdgo.Slice<Object>):Void __self__.value._cycleError(_cycle);
    /**
        // validCycle checks if the cycle starting with obj is valid and
        // reports an error if it is not.
    **/
    @:keep
    public dynamic function _validCycle(_obj:Object):Bool return __self__.value._validCycle(_obj);
    /**
        // objDecl type-checks the declaration of obj in its respective (file) environment.
        // For the meaning of def, see Checker.definedType, in typexpr.go.
    **/
    @:keep
    public dynamic function _objDecl(_obj:Object, _def:stdgo.Ref<Named>):Void __self__.value._objDecl(_obj, _def);
    @:keep
    public dynamic function _declare(_scope:stdgo.Ref<Scope>, _id:stdgo.Ref<stdgo.go.ast.Ast.Ident>, _obj:Object, _pos:stdgo.go.token.Token.Pos):Void __self__.value._declare(_scope, _id, _obj, _pos);
    @:keep
    public dynamic function _reportAltDecl(_obj:Object):Void __self__.value._reportAltDecl(_obj);
    /**
        // conversion type-checks the conversion T(x).
        // The result is in x.
    **/
    @:keep
    public dynamic function _conversion(_x:stdgo.Ref<T_operand>, t:Type_):Void __self__.value._conversion(_x, t);
    /**
        // convertUntyped attempts to set the type of an untyped value to the target type.
    **/
    @:keep
    public dynamic function _convertUntyped(_x:stdgo.Ref<T_operand>, _target:Type_):Void __self__.value._convertUntyped(_x, _target);
    @:keep
    public dynamic function _invalidConversion(_code:Code, _x:stdgo.Ref<T_operand>, _target:Type_):Void __self__.value._invalidConversion(_code, _x, _target);
    /**
        // representation returns the representation of the constant operand x as the
        // basic type typ.
        //
        // If no such representation is possible, it returns a non-zero error code.
    **/
    @:keep
    public dynamic function _representation(_x:stdgo.Ref<T_operand>, _typ:stdgo.Ref<Basic>):{ var _0 : stdgo.go.constant.Constant.Value; var _1 : Code; } return __self__.value._representation(_x, _typ);
    /**
        // representable checks that a constant operand is representable in the given
        // basic type.
    **/
    @:keep
    public dynamic function _representable(_x:stdgo.Ref<T_operand>, _typ:stdgo.Ref<Basic>):Void __self__.value._representable(_x, _typ);
    /**
        // overflow checks that the constant x is representable by its type.
        // For untyped constants, it checks that the value doesn't become
        // arbitrarily large.
    **/
    @:keep
    public dynamic function _overflow(_x:stdgo.Ref<T_operand>, _opPos:stdgo.go.token.Token.Pos):Void __self__.value._overflow(_x, _opPos);
    @:keep
    public dynamic function _recordScope(_node:stdgo.go.ast.Ast.Node, _scope:stdgo.Ref<Scope>):Void __self__.value._recordScope(_node, _scope);
    @:keep
    public dynamic function _recordSelection(_x:stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>, _kind:SelectionKind, _recv:Type_, _obj:Object, _index:stdgo.Slice<stdgo.GoInt>, _indirect:Bool):Void __self__.value._recordSelection(_x, _kind, _recv, _obj, _index, _indirect);
    @:keep
    public dynamic function _recordImplicit(_node:stdgo.go.ast.Ast.Node, _obj:Object):Void __self__.value._recordImplicit(_node, _obj);
    @:keep
    public dynamic function _recordUse(_id:stdgo.Ref<stdgo.go.ast.Ast.Ident>, _obj:Object):Void __self__.value._recordUse(_id, _obj);
    @:keep
    public dynamic function _recordDef(_id:stdgo.Ref<stdgo.go.ast.Ast.Ident>, _obj:Object):Void __self__.value._recordDef(_id, _obj);
    /**
        // recordInstance records instantiation information into check.Info, if the
        // Instances map is non-nil. The given expr must be an ident, selector, or
        // index (list) expr with ident or selector operand.
        //
        // TODO(rfindley): the expr parameter is fragile. See if we can access the
        // instantiated identifier in some other way.
    **/
    @:keep
    public dynamic function _recordInstance(_expr:stdgo.go.ast.Ast.Expr, _targs:stdgo.Slice<Type_>, _typ:Type_):Void __self__.value._recordInstance(_expr, _targs, _typ);
    /**
        // recordCommaOkTypes updates recorded types to reflect that x is used in a commaOk context
        // (and therefore has tuple type).
    **/
    @:keep
    public dynamic function _recordCommaOkTypes(_x:stdgo.go.ast.Ast.Expr, _a:stdgo.Slice<stdgo.Ref<T_operand>>):Void __self__.value._recordCommaOkTypes(_x, _a);
    @:keep
    public dynamic function _recordBuiltinType(_f:stdgo.go.ast.Ast.Expr, _sig:stdgo.Ref<Signature>):Void __self__.value._recordBuiltinType(_f, _sig);
    @:keep
    public dynamic function _recordTypeAndValue(_x:stdgo.go.ast.Ast.Expr, _mode:T_operandMode, _typ:Type_, _val:stdgo.go.constant.Constant.Value):Void __self__.value._recordTypeAndValue(_x, _mode, _typ, _val);
    @:keep
    public dynamic function _recordUntyped():Void __self__.value._recordUntyped();
    @:keep
    public dynamic function _record(_x:stdgo.Ref<T_operand>):Void __self__.value._record(_x);
    /**
        // cleanup runs cleanup for all collected cleaners.
    **/
    @:keep
    public dynamic function _cleanup():Void __self__.value._cleanup();
    /**
        // processDelayed processes all delayed actions pushed after top.
    **/
    @:keep
    public dynamic function _processDelayed(_top:stdgo.GoInt):Void __self__.value._processDelayed(_top);
    @:keep
    public dynamic function _checkFiles(_files:stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.File>>):stdgo.Error return __self__.value._checkFiles(_files);
    /**
        // Files checks the provided files as part of the checker's package.
    **/
    @:keep
    public dynamic function files(_files:stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.File>>):stdgo.Error return __self__.value.files(_files);
    @:keep
    public dynamic function _handleBailout(_err:stdgo.Ref<stdgo.Error>):Void __self__.value._handleBailout(_err);
    /**
        // initFiles initializes the files-specific portion of checker.
        // The provided files must all belong to the same package.
    **/
    @:keep
    public dynamic function _initFiles(_files:stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.File>>):Void __self__.value._initFiles(_files);
    /**
        // needsCleanup records objects/types that implement the cleanup method
        // which will be called at the end of type-checking.
    **/
    @:keep
    public dynamic function _needsCleanup(_c:T_cleaner):Void __self__.value._needsCleanup(_c);
    /**
        // pop pops and returns the topmost object from the object path.
    **/
    @:keep
    public dynamic function _pop():Object return __self__.value._pop();
    /**
        // push pushes obj onto the object path and returns its index in the path.
    **/
    @:keep
    public dynamic function _push(_obj:Object):stdgo.GoInt return __self__.value._push(_obj);
    /**
        // later pushes f on to the stack of actions that will be processed later;
        // either at the end of the current statement, or in case of a local constant
        // or variable declaration, before the constant or variable is in scope
        // (so that f still sees the scope before any new declarations).
        // later returns the pushed action so one can provide a description
        // via action.describef for debugging, if desired.
    **/
    @:keep
    public dynamic function _later(_f:() -> Void):stdgo.Ref<T_action> return __self__.value._later(_f);
    @:keep
    public dynamic function _rememberUntyped(_e:stdgo.go.ast.Ast.Expr, _lhs:Bool, _mode:T_operandMode, _typ:stdgo.Ref<Basic>, _val:stdgo.go.constant.Constant.Value):Void __self__.value._rememberUntyped(_e, _lhs, _mode, _typ, _val);
    /**
        // isBrokenAlias reports whether alias doesn't have a determined type yet.
    **/
    @:keep
    public dynamic function _isBrokenAlias(_alias:stdgo.Ref<TypeName>):Bool return __self__.value._isBrokenAlias(_alias);
    /**
        // validAlias records that alias has the valid type typ (possibly Typ[Invalid]).
    **/
    @:keep
    public dynamic function _validAlias(_alias:stdgo.Ref<TypeName>, _typ:Type_):Void __self__.value._validAlias(_alias, _typ);
    /**
        // brokenAlias records that alias doesn't have a determined type yet.
        // It also sets alias.typ to Typ[Invalid].
    **/
    @:keep
    public dynamic function _brokenAlias(_alias:stdgo.Ref<TypeName>):Void __self__.value._brokenAlias(_alias);
    /**
        // addDeclDep adds the dependency edge (check.decl -> to) if check.decl exists
    **/
    @:keep
    public dynamic function _addDeclDep(_to:Object):Void __self__.value._addDeclDep(_to);
    @:keep
    public dynamic function _use1(_e:stdgo.go.ast.Ast.Expr, _lhs:Bool):Bool return __self__.value._use1(_e, _lhs);
    @:keep
    public dynamic function _useN(_args:stdgo.Slice<stdgo.go.ast.Ast.Expr>, _lhs:Bool):Bool return __self__.value._useN(_args, _lhs);
    /**
        // useLHS is like use, but doesn't "use" top-level identifiers.
        // It should be called instead of use if the arguments are
        // expressions on the lhs of an assignment.
    **/
    @:keep
    public dynamic function _useLHS(_args:haxe.Rest<stdgo.go.ast.Ast.Expr>):Bool return __self__.value._useLHS(..._args);
    /**
        // use type-checks each argument.
        // Useful to make sure expressions are evaluated
        // (and variables are "used") in the presence of
        // other errors. Arguments may be nil.
        // Reports if all arguments evaluated without error.
    **/
    @:keep
    public dynamic function _use(_args:haxe.Rest<stdgo.go.ast.Ast.Expr>):Bool return __self__.value._use(..._args);
    @:keep
    public dynamic function _selector(_x:stdgo.Ref<T_operand>, _e:stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>, _def:stdgo.Ref<Named>, _wantType:Bool):Void __self__.value._selector(_x, _e, _def, _wantType);
    /**
        // arguments type-checks arguments passed to a function call with the given signature.
        // The function and its arguments may be generic, and possibly partially instantiated.
        // targs and xlist are the function's type arguments (and corresponding expressions).
        // args are the function arguments. If an argument args[i] is a partially instantiated
        // generic function, atargs[i] and atxlist[i] are the corresponding type arguments
        // (and corresponding expressions).
        // If the callee is variadic, arguments adjusts its signature to match the provided
        // arguments. The type parameters and arguments of the callee and all its arguments
        // are used together to infer any missing type arguments, and the callee and argument
        // functions are instantiated as necessary.
        // The result signature is the (possibly adjusted and instantiated) function signature.
        // If an error occurred, the result signature is the incoming sig.
    **/
    @:keep
    public dynamic function _arguments(_call:stdgo.Ref<stdgo.go.ast.Ast.CallExpr>, _sig:stdgo.Ref<Signature>, _targs:stdgo.Slice<Type_>, _xlist:stdgo.Slice<stdgo.go.ast.Ast.Expr>, _args:stdgo.Slice<stdgo.Ref<T_operand>>, _atargs:stdgo.Slice<stdgo.Slice<Type_>>, _atxlist:stdgo.Slice<stdgo.Slice<stdgo.go.ast.Ast.Expr>>):stdgo.Ref<Signature> return __self__.value._arguments(_call, _sig, _targs, _xlist, _args, _atargs, _atxlist);
    /**
        // genericExprList is like exprList but result operands may be uninstantiated or partially
        // instantiated generic functions (where constraint information is insufficient to infer
        // the missing type arguments) for Go 1.21 and later.
        // For each non-generic or uninstantiated generic operand, the corresponding targsList and
        // xlistList elements do not exist (targsList and xlistList are nil) or the elements are nil.
        // For each partially instantiated generic function operand, the corresponding targsList and
        // xlistList elements are the operand's partial type arguments and type expression lists.
    **/
    @:keep
    public dynamic function _genericExprList(_elist:stdgo.Slice<stdgo.go.ast.Ast.Expr>):{ var _0 : stdgo.Slice<stdgo.Ref<T_operand>>; var _1 : stdgo.Slice<stdgo.Slice<Type_>>; var _2 : stdgo.Slice<stdgo.Slice<stdgo.go.ast.Ast.Expr>>; } return __self__.value._genericExprList(_elist);
    /**
        // exprList evaluates a list of expressions and returns the corresponding operands.
        // A single-element expression list may evaluate to multiple operands.
    **/
    @:keep
    public dynamic function _exprList(_elist:stdgo.Slice<stdgo.go.ast.Ast.Expr>):stdgo.Slice<stdgo.Ref<T_operand>> return __self__.value._exprList(_elist);
    @:keep
    public dynamic function _callExpr(_x:stdgo.Ref<T_operand>, _call:stdgo.Ref<stdgo.go.ast.Ast.CallExpr>):T_exprKind return __self__.value._callExpr(_x, _call);
    @:keep
    public dynamic function _instantiateSignature(_pos:stdgo.go.token.Token.Pos, _expr:stdgo.go.ast.Ast.Expr, _typ:stdgo.Ref<Signature>, _targs:stdgo.Slice<Type_>, _xlist:stdgo.Slice<stdgo.go.ast.Ast.Expr>):stdgo.Ref<Signature> return __self__.value._instantiateSignature(_pos, _expr, _typ, _targs, _xlist);
    /**
        // funcInst type-checks a function instantiation.
        // The incoming x must be a generic function.
        // If ix != nil, it provides some or all of the type arguments (ix.Indices).
        // If target type tsig != nil, the signature may be used to infer missing type
        // arguments of x, if any. At least one of tsig or inst must be provided.
        //
        // There are two modes of operation:
        //
        //  1. If infer == true, funcInst infers missing type arguments as needed and
        //     instantiates the function x. The returned results are nil.
        //
        //  2. If infer == false and inst provides all type arguments, funcInst
        //     instantiates the function x. The returned results are nil.
        //     If inst doesn't provide enough type arguments, funcInst returns the
        //     available arguments and the corresponding expression list; x remains
        //     unchanged.
        //
        // If an error (other than a version error) occurs in any case, it is reported
        // and x.mode is set to invalid.
    **/
    @:keep
    public dynamic function _funcInst(_tsig:stdgo.Ref<Signature>, _pos:stdgo.go.token.Token.Pos, _x:stdgo.Ref<T_operand>, _ix:stdgo.Ref<stdgo.go.internal.typeparams.Typeparams.IndexExpr>, _infer:Bool):{ var _0 : stdgo.Slice<Type_>; var _1 : stdgo.Slice<stdgo.go.ast.Ast.Expr>; } return __self__.value._funcInst(_tsig, _pos, _x, _ix, _infer);
    /**
        // applyTypeFunc applies f to x. If x is a type parameter,
        // the result is a type parameter constrained by an new
        // interface bound. The type bounds for that interface
        // are computed by applying f to each of the type bounds
        // of x. If any of these applications of f return nil,
        // applyTypeFunc returns nil.
        // If x is not a type parameter, the result is f(x).
    **/
    @:keep
    public dynamic function _applyTypeFunc(_f:Type_ -> Type_, _x:stdgo.Ref<T_operand>, _id:T_builtinId):Type_ return __self__.value._applyTypeFunc(_f, _x, _id);
    /**
        // builtin type-checks a call to the built-in specified by id and
        // reports whether the call is valid, with *x holding the result;
        // but x.expr is not set. If the call is invalid, the result is
        // false, and *x is undefined.
    **/
    @:keep
    public dynamic function _builtin(_x:stdgo.Ref<T_operand>, _call:stdgo.Ref<stdgo.go.ast.Ast.CallExpr>, _id:T_builtinId):Bool return __self__.value._builtin(_x, _call, _id);
    @:keep
    public dynamic function _shortVarDecl(_pos:T_positioner, _lhs:stdgo.Slice<stdgo.go.ast.Ast.Expr>, _rhs:stdgo.Slice<stdgo.go.ast.Ast.Expr>):Void __self__.value._shortVarDecl(_pos, _lhs, _rhs);
    /**
        // assignVars type-checks assignments of expressions orig_rhs to variables lhs.
    **/
    @:keep
    public dynamic function _assignVars(_lhs:stdgo.Slice<stdgo.go.ast.Ast.Expr>, _orig_rhs:stdgo.Slice<stdgo.go.ast.Ast.Expr>):Void __self__.value._assignVars(_lhs, _orig_rhs);
    /**
        // initVars type-checks assignments of initialization expressions orig_rhs
        // to variables lhs.
        // If returnStmt is non-nil, initVars type-checks the implicit assignment
        // of result expressions orig_rhs to function result parameters lhs.
    **/
    @:keep
    public dynamic function _initVars(_lhs:stdgo.Slice<stdgo.Ref<Var>>, _orig_rhs:stdgo.Slice<stdgo.go.ast.Ast.Expr>, _returnStmt:stdgo.go.ast.Ast.Stmt):Void __self__.value._initVars(_lhs, _orig_rhs, _returnStmt);
    @:keep
    public dynamic function _returnError(_at:T_positioner, _lhs:stdgo.Slice<stdgo.Ref<Var>>, _rhs:stdgo.Slice<stdgo.Ref<T_operand>>):Void __self__.value._returnError(_at, _lhs, _rhs);
    @:keep
    public dynamic function _assignError(_rhs:stdgo.Slice<stdgo.go.ast.Ast.Expr>, _l:stdgo.GoInt, _r:stdgo.GoInt):Void __self__.value._assignError(_rhs, _l, _r);
    /**
        // typesSummary returns a string of the form "(t1, t2, ...)" where the
        // ti's are user-friendly string representations for the given types.
        // If variadic is set and the last type is a slice, its string is of
        // the form "...E" where E is the slice's element type.
    **/
    @:keep
    public dynamic function _typesSummary(_list:stdgo.Slice<Type_>, _variadic:Bool):stdgo.GoString return __self__.value._typesSummary(_list, _variadic);
    /**
        // assignVar checks the assignment lhs = rhs (if x == nil), or lhs = x (if x != nil).
        // If x != nil, it must be the evaluation of rhs (and rhs will be ignored).
        // If the assignment check fails and x != nil, x.mode is set to invalid.
    **/
    @:keep
    public dynamic function _assignVar(_lhs:stdgo.go.ast.Ast.Expr, _rhs:stdgo.go.ast.Ast.Expr, _x:stdgo.Ref<T_operand>):Void __self__.value._assignVar(_lhs, _rhs, _x);
    /**
        // lhsVar checks a lhs variable in an assignment and returns its type.
        // lhsVar takes care of not counting a lhs identifier as a "use" of
        // that identifier. The result is nil if it is the blank identifier,
        // and Typ[Invalid] if it is an invalid lhs expression.
    **/
    @:keep
    public dynamic function _lhsVar(_lhs:stdgo.go.ast.Ast.Expr):Type_ return __self__.value._lhsVar(_lhs);
    /**
        // initVar checks the initialization lhs = x in a variable declaration.
        // If lhs doesn't have a type yet, it is given the type of x,
        // or Typ[Invalid] in case of an error.
        // If the initialization check fails, x.mode is set to invalid.
    **/
    @:keep
    public dynamic function _initVar(_lhs:stdgo.Ref<Var>, _x:stdgo.Ref<T_operand>, _context:stdgo.GoString):Void __self__.value._initVar(_lhs, _x, _context);
    @:keep
    public dynamic function _initConst(_lhs:stdgo.Ref<Const>, _x:stdgo.Ref<T_operand>):Void __self__.value._initConst(_lhs, _x);
    /**
        // assignment reports whether x can be assigned to a variable of type T,
        // if necessary by attempting to convert untyped values to the appropriate
        // type. context describes the context in which the assignment takes place.
        // Use T == nil to indicate assignment to an untyped blank identifier.
        // If the assignment check fails, x.mode is set to invalid.
    **/
    @:keep
    public dynamic function _assignment(_x:stdgo.Ref<T_operand>, t:Type_, _context:stdgo.GoString):Void __self__.value._assignment(_x, t, _context);
    @:embedded
    public dynamic function _recordTypes():Bool return __self__.value._recordTypes();
    @:embedded
    public dynamic function _lookup(__0:stdgo.GoString):stdgo.go.types.Types.Object return __self__.value._lookup(__0);
    @:embedded
    public dynamic function typeOf(_e:stdgo.go.ast.Ast.Expr):stdgo.go.types.Types.Type_ return __self__.value.typeOf(_e);
    @:embedded
    public dynamic function objectOf(_id:stdgo.Ref<stdgo.go.ast.Ast.Ident>):stdgo.go.types.Types.Object return __self__.value.objectOf(_id);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Checker>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Checker_asInterface) class Checker_static_extension {
    /**
        // verifyVersionf is like allowVersion but also accepts a format string and arguments
        // which are used to report a version error if allowVersion returns false. It uses the
        // current package.
    **/
    @:keep
    static public function _verifyVersionf( _check:stdgo.Ref<Checker>, _at:T_positioner, _v:T_version, _format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):Bool {
        var _args = new stdgo.Slice<stdgo.AnyInterface>(_args.length, 0, ..._args);
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if (!_check._allowVersion(_check._pkg, _at, _v?.__copy__())) {
            _check._versionErrorf(_at, _v?.__copy__(), _format?.__copy__(), ..._args.__toArray__());
            return false;
        };
        return true;
    }
    /**
        // allowVersion reports whether the given package
        // is allowed to use version major.minor.
    **/
    @:keep
    static public function _allowVersion( _check:stdgo.Ref<Checker>, _pkg:stdgo.Ref<Package>, _at:T_positioner, _v:T_version):Bool {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if (_pkg != (_check._pkg)) {
            return true;
        };
        if (_check._posVers != null) {
            {
                var __tmp__ = (_check._posVers != null && _check._posVers.exists(_check._fset.file(_at.pos())) ? { _0 : _check._posVers[_check._fset.file(_at.pos())], _1 : true } : { _0 : ({} : stdgo.go.types.Types.T_version), _1 : false }), _src:stdgo.go.types.Types.T_version = __tmp__._0, _ok:Bool = __tmp__._1;
                if (_ok && (_src._major >= (1 : stdgo.GoInt))) {
                    return !_src._before(_v?.__copy__());
                };
            };
        };
        return _check._version._equal(_go0_0?.__copy__()) || !_check._version._before(_v?.__copy__());
    }
    /**
        // langCompat reports an error if the representation of a numeric
        // literal is not compatible with the current language version.
    **/
    @:keep
    static public function _langCompat( _check:stdgo.Ref<Checker>, _lit:stdgo.Ref<stdgo.go.ast.Ast.BasicLit>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _s:stdgo.GoString = _lit.value?.__copy__();
        if ((_s.length <= (2 : stdgo.GoInt)) || _check._allowVersion(_check._pkg, stdgo.Go.asInterface(_lit), _go1_13?.__copy__())) {
            return;
        };
        if (stdgo.strings.Strings.contains(_s?.__copy__(), ("_" : stdgo.GoString))) {
            _check._versionErrorf(stdgo.Go.asInterface(_lit), _go1_13?.__copy__(), ("underscores in numeric literals" : stdgo.GoString));
            return;
        };
        if (_s[(0 : stdgo.GoInt)] != ((48 : stdgo.GoUInt8))) {
            return;
        };
        var _radix:stdgo.GoUInt8 = _s[(1 : stdgo.GoInt)];
        if ((_radix == (98 : stdgo.GoUInt8)) || (_radix == (66 : stdgo.GoUInt8))) {
            _check._versionErrorf(stdgo.Go.asInterface(_lit), _go1_13?.__copy__(), ("binary literals" : stdgo.GoString));
            return;
        };
        if ((_radix == (111 : stdgo.GoUInt8)) || (_radix == (79 : stdgo.GoUInt8))) {
            _check._versionErrorf(stdgo.Go.asInterface(_lit), _go1_13?.__copy__(), ("0o/0O-style octal literals" : stdgo.GoString));
            return;
        };
        if ((_lit.kind != (5 : stdgo.go.token.Token.Token)) && ((_radix == (120 : stdgo.GoUInt8)) || (_radix == (88 : stdgo.GoUInt8)))) {
            _check._versionErrorf(stdgo.Go.asInterface(_lit), _go1_13?.__copy__(), ("hexadecimal floating-point literals" : stdgo.GoString));
        };
    }
    /**
        // validType0 checks if the given type is valid. If typ is a type parameter
        // its value is looked up in the type argument list of the instantiated
        // (enclosing) type, if it exists. Otherwise the type parameter must be from
        // an enclosing function and can be ignored.
        // The nest list describes the stack (the "nest in memory") of types which
        // contain (or embed in the case of interfaces) other types. For instance, a
        // struct named S which contains a field of named type F contains (the memory
        // of) F in S, leading to the nest S->F. If a type appears in its own nest
        // (say S->F->S) we have an invalid recursive type. The path list is the full
        // path of named types in a cycle, it is only needed for error reporting.
    **/
    @:keep
    static public function _validType0( _check:stdgo.Ref<Checker>, _typ:Type_, _nest:stdgo.Slice<stdgo.Ref<Named>>, _path:stdgo.Slice<stdgo.Ref<Named>>):Bool {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        {
            final __type__ = _typ;
            {
                var __bool__ = true;
                while (__bool__) {
                    __bool__ = false;
                    if (__type__ == null) {
                        var _t:stdgo.AnyInterface = __type__ == null ? (null : stdgo.AnyInterface) : cast __type__;
                        if (false) {
                            throw stdgo.Go.toInterface(("validType0(nil)" : stdgo.GoString));
                        };
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Array_>))) {
                        var _t:stdgo.Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                        return _check._validType0(_t._elem, _nest, _path);
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Struct>))) {
                        var _t:stdgo.Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                        for (__8 => _f in _t._fields) {
                            if (!_check._validType0(_f._object._typ, _nest, _path)) {
                                return false;
                            };
                        };
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Union>))) {
                        var _t:stdgo.Ref<stdgo.go.types.Types.Union> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Union>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__().value;
                        for (__17 => _t in _t._terms) {
                            if (!_check._validType0(_t._typ, _nest, _path)) {
                                return false;
                            };
                        };
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                        var _t:stdgo.Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                        for (__34 => _etyp in _t._embeddeds) {
                            if (!_check._validType0(_etyp, _nest, _path)) {
                                return false;
                            };
                        };
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Named>))) {
                        var _t:stdgo.Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                        if (_check._valids._lookup(_t) != null && ((_check._valids._lookup(_t) : Dynamic).__nil__ == null || !(_check._valids._lookup(_t) : Dynamic).__nil__)) {
                            break;
                        };
                        if (stdgo.Go.toInterface(_t.underlying()) == (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                            return false;
                        };
                        for (__59 => _e in _nest) {
                            if (identical(stdgo.Go.asInterface(_e), stdgo.Go.asInterface(_t))) {
                                _assert(_t._obj._object._pkg == (_check._pkg));
                                _assert(_t.origin()._obj._object._pkg == (_check._pkg));
                                _t._underlying = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                                _t.origin()._underlying = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                                for (_start => _p in _path) {
                                    if (identical(stdgo.Go.asInterface(_p), stdgo.Go.asInterface(_t))) {
                                        _check._cycleError(_makeObjList((_path.__slice__(_start) : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Named>>)));
                                        return false;
                                    };
                                };
                                throw stdgo.Go.toInterface(("cycle start not found" : stdgo.GoString));
                            };
                        };
                        if (!_check._validType0(_t.origin()._fromRHS, (_nest.__append__(_t)), (_path.__append__(_t)))) {
                            return false;
                        };
                        _check._valids._add(_t);
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeParam>))) {
                        var _t:stdgo.Ref<stdgo.go.types.Types.TypeParam> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__().value;
                        if ((_nest.length) > (0 : stdgo.GoInt)) {
                            var _inst = _nest[((_nest.length) - (1 : stdgo.GoInt) : stdgo.GoInt)];
                            for (_i => _tparam in _inst._check._environment._decl._tdecl.typeParams()._list()) {
                                if ((_t == _tparam) && (_i < _inst.typeArgs().len())) {
                                    var _targ:stdgo.go.types.Types.Type_ = _inst.typeArgs().at(_i);
                                    return _check._validType0(_targ, (_nest.__slice__(0, (_nest.length) - (1 : stdgo.GoInt)) : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Named>>), _path);
                                };
                            };
                        };
                    };
                    break;
                };
            };
        };
        return true;
    }
    /**
        // validType verifies that the given type does not "expand" indefinitely
        // producing a cycle in the type graph.
        // (Cycles involving alias types, as in "type A = [10]A" are detected
        // earlier, via the objDecl cycle detection mechanism.)
    **/
    @:keep
    static public function _validType( _check:stdgo.Ref<Checker>, _typ:stdgo.Ref<Named>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _check._validType0(stdgo.Go.asInterface(_typ), (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Named>>), (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Named>>));
    }
    /**
        // typeList provides the list of types corresponding to the incoming expression list.
        // If an error occurred, the result is nil, but all list elements were type-checked.
    **/
    @:keep
    static public function _typeList( _check:stdgo.Ref<Checker>, _list:stdgo.Slice<stdgo.go.ast.Ast.Expr>):stdgo.Slice<Type_> {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _res = new stdgo.Slice<stdgo.go.types.Types.Type_>((_list.length : stdgo.GoInt).toBasic(), 0);
        for (_i => _x in _list) {
            var _t:stdgo.go.types.Types.Type_ = _check._varType(_x);
            if (stdgo.Go.toInterface(_t) == (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                _res = (null : stdgo.Slice<stdgo.go.types.Types.Type_>);
            };
            if (_res != null) {
                _res[(_i : stdgo.GoInt)] = _t;
            };
        };
        return _res;
    }
    /**
        // arrayLength type-checks the array length expression e
        // and returns the constant length >= 0, or a value < 0
        // to indicate an error (and thus an unknown length).
    **/
    @:keep
    static public function _arrayLength( _check:stdgo.Ref<Checker>, _e:stdgo.go.ast.Ast.Expr):stdgo.GoInt64 {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_e) : stdgo.Ref<stdgo.go.ast.Ast.Ident>)) : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _1 : false };
            }, _name = __tmp__._0, __0 = __tmp__._1;
            if (_name != null && ((_name : Dynamic).__nil__ == null || !(_name : Dynamic).__nil__)) {
                var _obj:stdgo.go.types.Types.Object = _check._lookup(_name.name?.__copy__());
                if (_obj == null) {
                    _check._errorf(stdgo.Go.asInterface(_name), (26 : stdgo.internal.types.errors.Errors.Code), ("undefined array length %s or missing type constraint" : stdgo.GoString), stdgo.Go.toInterface(_name.name));
                    return (-1i64 : stdgo.GoInt64);
                };
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<Const>)) : stdgo.Ref<Const>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Const>), _1 : false };
                    }, __17 = __tmp__._0, _ok = __tmp__._1;
                    if (!_ok) {
                        _check._errorf(stdgo.Go.asInterface(_name), (26 : stdgo.internal.types.errors.Errors.Code), ("invalid array length %s" : stdgo.GoString), stdgo.Go.toInterface(_name.name));
                        return (-1i64 : stdgo.GoInt64);
                    };
                };
            };
        };
        var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
        _check._expr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _e);
        if (_x._mode != ((4 : stdgo.go.types.Types.T_operandMode))) {
            if (_x._mode != ((0 : stdgo.go.types.Types.T_operandMode))) {
                _check._errorf(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>)), (26 : stdgo.internal.types.errors.Errors.Code), ("array length %s must be constant" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>))));
            };
            return (-1i64 : stdgo.GoInt64);
        };
        if (_isUntyped(_x._typ) || _isInteger(_x._typ)) {
            {
                var _val:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.toInt(_x._val);
                if (_val.kind() == ((3 : stdgo.go.constant.Constant.Kind))) {
                    if (_representableConst(_val, _check, typ[((2 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)], (null : stdgo.Ref<stdgo.go.constant.Constant.Value>))) {
                        {
                            var __tmp__ = stdgo.go.constant.Constant.int64Val(_val), _n:stdgo.GoInt64 = __tmp__._0, _ok:Bool = __tmp__._1;
                            if (_ok && (_n >= (0i64 : stdgo.GoInt64))) {
                                return _n;
                            };
                        };
                    };
                };
            };
        };
        var _msg:stdgo.GoString = ("" : stdgo.GoString);
        if (_isInteger(_x._typ)) {
            _msg = ("invalid array length %s" : stdgo.GoString);
        } else {
            _msg = ("array length %s must be integer" : stdgo.GoString);
        };
        _check._errorf(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>)), (26 : stdgo.internal.types.errors.Errors.Code), _msg?.__copy__(), stdgo.Go.toInterface(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>))));
        return (-1i64 : stdgo.GoInt64);
    }
    @:keep
    static public function _instantiatedType( _check:stdgo.Ref<Checker>, _ix:stdgo.Ref<stdgo.go.internal.typeparams.Typeparams.IndexExpr>, _def:stdgo.Ref<Named>):Type_ {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var __deferstack__:Array<Void -> Void> = [];
        var _res:Type_ = (null : stdgo.go.types.Types.Type_);
        try {
            if (_check._conf.__Trace) {
                _check._trace(_ix.pos(), ("-- instantiating type %s with %s" : stdgo.GoString), stdgo.Go.toInterface(_ix.indexListExpr.x), stdgo.Go.toInterface(_ix.indexListExpr.indices));
                _check._indent++;
                __deferstack__.unshift(() -> {
                    var a = function():Void {
                        _check._indent--;
                        _check._trace(_ix.pos(), ("=> %s" : stdgo.GoString), stdgo.Go.toInterface(_res));
                    };
                    a();
                });
            };
            var _cause:stdgo.GoString = ("" : stdgo.GoString);
            var _gtyp:stdgo.go.types.Types.Type_ = _check._genericType(_ix.indexListExpr.x, stdgo.Go.pointer(_cause));
            if (_cause != (stdgo.Go.str())) {
                _check._errorf(_ix.orig, (136 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: %s (%s)" : stdgo.GoString), stdgo.Go.toInterface(_ix.orig), stdgo.Go.toInterface(_cause));
            };
            if (stdgo.Go.toInterface(_gtyp) == (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return _gtyp;
                };
            };
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_gtyp) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
            }, _orig = __tmp__._0, __40 = __tmp__._1;
            if (_orig == null || (_orig : Dynamic).__nil__) {
                throw stdgo.Go.toInterface(stdgo.fmt.Fmt.sprintf(("%v: cannot instantiate %v" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_ix.pos())), stdgo.Go.toInterface(_gtyp)));
            };
            var _targs = _check._typeList(_ix.indexListExpr.indices);
            if (_targs == null) {
                _def._setUnderlying(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]));
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                };
            };
            var _inst = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_check._instance(_ix.pos(), stdgo.Go.asInterface(_orig), _targs, null, _check._context())) : stdgo.Ref<Named>)) : stdgo.Ref<Named>);
            _def._setUnderlying(stdgo.Go.asInterface(_inst));
            _check._later(function():Void {
                _check._recordInstance(_ix.orig, _inst.typeArgs()._list(), stdgo.Go.asInterface(_inst));
                if (_check._validateTArgLen(_ix.pos(), _inst._check._environment._decl._tdecl.typeParams().len(), _inst.typeArgs().len())) {
                    {
                        var __tmp__ = _check._verify(_ix.pos(), _inst._check._environment._decl._tdecl.typeParams()._list(), _inst.typeArgs()._list(), _check._context()), _i:stdgo.GoInt = __tmp__._0, _err:stdgo.Error = __tmp__._1;
                        if (_err != null) {
                            var _pos:stdgo.go.token.Token.Pos = _ix.pos();
                            if (_i < (_ix.indexListExpr.indices.length)) {
                                _pos = _ix.indexListExpr.indices[(_i : stdgo.GoInt)].pos();
                            };
                            _check._softErrorf(stdgo.Go.asInterface((_pos : T_atPos)), (139 : stdgo.internal.types.errors.Errors.Code), _err.error()?.__copy__());
                        } else {
                            _check._mono._recordInstance(_check._pkg, _ix.pos(), _inst._check._environment._decl._tdecl.typeParams()._list(), _inst.typeArgs()._list(), _ix.indexListExpr.indices);
                        };
                    };
                };
                _check._validType(_inst);
            })._describef(stdgo.Go.asInterface(_ix), ("resolve instance %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_inst)));
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return stdgo.Go.asInterface(_inst);
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return _res;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return _res;
        };
    }
    /**
        // typInternal drives type checking of types.
        // Must only be called by definedType or genericType.
    **/
    @:keep
    static public function _typInternal( _check:stdgo.Ref<Checker>, _e0:stdgo.go.ast.Ast.Expr, _def:stdgo.Ref<Named>):Type_ {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var __deferstack__:Array<Void -> Void> = [];
        var t:Type_ = (null : stdgo.go.types.Types.Type_);
        try {
            if (_check._conf.__Trace) {
                _check._trace(_e0.pos(), ("-- type %s" : stdgo.GoString), stdgo.Go.toInterface(_e0));
                _check._indent++;
                __deferstack__.unshift(() -> {
                    var a = function():Void {
                        _check._indent--;
                        var _under:Type_ = (null : stdgo.go.types.Types.Type_);
                        if (t != null) {
                            _under = _safeUnderlying(t);
                        };
                        if (stdgo.Go.toInterface(t) == (stdgo.Go.toInterface(_under))) {
                            _check._trace(_e0.pos(), ("=> %s // %s" : stdgo.GoString), stdgo.Go.toInterface(t), stdgo.Go.toInterface(_goTypeName(t)));
                        } else {
                            _check._trace(_e0.pos(), ("=> %s (under = %s) // %s" : stdgo.GoString), stdgo.Go.toInterface(t), stdgo.Go.toInterface(_under), stdgo.Go.toInterface(_goTypeName(t)));
                        };
                    };
                    a();
                });
            };
            {
                final __type__ = _e0;
                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BadExpr>))) {
                    var _e:stdgo.Ref<stdgo.go.ast.Ast.BadExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BadExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BadExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BadExpr>) : __type__.__underlying__().value;
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.Ident>))) {
                    var _e:stdgo.Ref<stdgo.go.ast.Ast.Ident> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__().value;
                    var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                    _check._ident((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _e, _def, true);
                    {
                        final __value__ = _x._mode;
                        if (__value__ == ((3 : stdgo.go.types.Types.T_operandMode))) {
                            var _typ:stdgo.go.types.Types.Type_ = _x._typ;
                            _def._setUnderlying(_typ);
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _typ;
                            };
                        } else if (__value__ == ((0 : stdgo.go.types.Types.T_operandMode))) {} else if (__value__ == ((1 : stdgo.go.types.Types.T_operandMode))) {
                            _check._errorf(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>)), (25 : stdgo.internal.types.errors.Errors.Code), ("%s used as type" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>))));
                        } else {
                            _check._errorf(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>)), (25 : stdgo.internal.types.errors.Errors.Code), ("%s is not a type" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>))));
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>))) {
                    var _e:stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__().value;
                    var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                    _check._selector((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _e, _def, true);
                    {
                        final __value__ = _x._mode;
                        if (__value__ == ((3 : stdgo.go.types.Types.T_operandMode))) {
                            var _typ:stdgo.go.types.Types.Type_ = _x._typ;
                            _def._setUnderlying(_typ);
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _typ;
                            };
                        } else if (__value__ == ((0 : stdgo.go.types.Types.T_operandMode))) {} else if (__value__ == ((1 : stdgo.go.types.Types.T_operandMode))) {
                            _check._errorf(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>)), (25 : stdgo.internal.types.errors.Errors.Code), ("%s used as type" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>))));
                        } else {
                            _check._errorf(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>)), (25 : stdgo.internal.types.errors.Errors.Code), ("%s is not a type" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>))));
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IndexExpr>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IndexListExpr>))) {
                    var _e:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                    var _ix = stdgo.go.internal.typeparams.Typeparams.unpackIndexExpr(_e);
                    _check._verifyVersionf(stdgo.Go.asInterface(_inNode(_e, _ix.indexListExpr.lbrack)), _go1_18?.__copy__(), ("type instantiation" : stdgo.GoString));
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _check._instantiatedType(_ix, _def);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>))) {
                    var _e:stdgo.Ref<stdgo.go.ast.Ast.ParenExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__().value;
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _check._definedType(_e.x, _def);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ArrayType>))) {
                    var _e:stdgo.Ref<stdgo.go.ast.Ast.ArrayType> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ArrayType>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ArrayType>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ArrayType>) : __type__.__underlying__().value;
                    if (_e.len == null) {
                        var _typ = (stdgo.Go.setRef(({} : stdgo.go.types.Types.Slice_)) : stdgo.Ref<stdgo.go.types.Types.Slice_>);
                        _def._setUnderlying(stdgo.Go.asInterface(_typ));
                        _typ._elem = _check._varType(_e.elt);
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return stdgo.Go.asInterface(_typ);
                        };
                    };
                    var _typ = (stdgo.Go.setRef(({} : stdgo.go.types.Types.Array_)) : stdgo.Ref<stdgo.go.types.Types.Array_>);
                    _def._setUnderlying(stdgo.Go.asInterface(_typ));
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_e.len) : stdgo.Ref<stdgo.go.ast.Ast.Ellipsis>)) : stdgo.Ref<stdgo.go.ast.Ast.Ellipsis>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.Ellipsis>), _1 : false };
                        }, __136 = __tmp__._0, _ok = __tmp__._1;
                        if (_ok) {
                            _check._error(_e.len, (77 : stdgo.internal.types.errors.Errors.Code), ("invalid use of [...] array (outside a composite literal)" : stdgo.GoString));
                            _typ._len = (-1i64 : stdgo.GoInt64);
                        } else {
                            _typ._len = _check._arrayLength(_e.len);
                        };
                    };
                    _typ._elem = _check._varType(_e.elt);
                    if (_typ._len >= (0i64 : stdgo.GoInt64)) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return stdgo.Go.asInterface(_typ);
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.Ellipsis>))) {
                    var _e:stdgo.Ref<stdgo.go.ast.Ast.Ellipsis> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__.__underlying__().value;
                    _check._error(stdgo.Go.asInterface(_e), (81 : stdgo.internal.types.errors.Errors.Code), ("invalid use of \'...\'" : stdgo.GoString));
                    _check._use(_e.elt);
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.StructType>))) {
                    var _e:stdgo.Ref<stdgo.go.ast.Ast.StructType> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.StructType>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.StructType>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.StructType>) : __type__.__underlying__().value;
                    var _typ = (stdgo.Go.setRef(({} : stdgo.go.types.Types.Struct)) : stdgo.Ref<stdgo.go.types.Types.Struct>);
                    _def._setUnderlying(stdgo.Go.asInterface(_typ));
                    _check._structType(_typ, _e);
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return stdgo.Go.asInterface(_typ);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>))) {
                    var _e:stdgo.Ref<stdgo.go.ast.Ast.StarExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__().value;
                    var _typ = (stdgo.Go.setRef(({} : stdgo.go.types.Types.Pointer_)) : stdgo.Ref<stdgo.go.types.Types.Pointer_>);
                    _typ._base = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                    _def._setUnderlying(stdgo.Go.asInterface(_typ));
                    _typ._base = _check._varType(_e.x);
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return stdgo.Go.asInterface(_typ);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.FuncType>))) {
                    var _e:stdgo.Ref<stdgo.go.ast.Ast.FuncType> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.FuncType>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.FuncType>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.FuncType>) : __type__.__underlying__().value;
                    var _typ = (stdgo.Go.setRef(({} : stdgo.go.types.Types.Signature)) : stdgo.Ref<stdgo.go.types.Types.Signature>);
                    _def._setUnderlying(stdgo.Go.asInterface(_typ));
                    _check._funcType(_typ, null, _e);
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return stdgo.Go.asInterface(_typ);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.InterfaceType>))) {
                    var _e:stdgo.Ref<stdgo.go.ast.Ast.InterfaceType> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.InterfaceType>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.InterfaceType>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.InterfaceType>) : __type__.__underlying__().value;
                    var _typ = _check._newInterface();
                    _def._setUnderlying(stdgo.Go.asInterface(_typ));
                    _check._interfaceType(_typ, _e, _def);
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return stdgo.Go.asInterface(_typ);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.MapType>))) {
                    var _e:stdgo.Ref<stdgo.go.ast.Ast.MapType> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.MapType>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.MapType>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.MapType>) : __type__.__underlying__().value;
                    var _typ = (stdgo.Go.setRef(({} : stdgo.go.types.Types.Map_)) : stdgo.Ref<stdgo.go.types.Types.Map_>);
                    _def._setUnderlying(stdgo.Go.asInterface(_typ));
                    _typ._key = _check._varType(_e.key);
                    _typ._elem = _check._varType(_e.value);
                    _check._later(function():Void {
                        if (!comparable(_typ._key)) {
                            var _why:stdgo.GoString = ("" : stdgo.GoString);
                            if (_isTypeParam(_typ._key)) {
                                _why = (" (missing comparable constraint)" : stdgo.GoString);
                            };
                            _check._errorf(_e.key, (28 : stdgo.internal.types.errors.Errors.Code), ("invalid map key type %s%s" : stdgo.GoString), stdgo.Go.toInterface(_typ._key), stdgo.Go.toInterface(_why));
                        };
                    })._describef(_e.key, ("check map key %s" : stdgo.GoString), stdgo.Go.toInterface(_typ._key));
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return stdgo.Go.asInterface(_typ);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ChanType>))) {
                    var _e:stdgo.Ref<stdgo.go.ast.Ast.ChanType> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ChanType>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ChanType>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ChanType>) : __type__.__underlying__().value;
                    var _typ = (stdgo.Go.setRef(({} : stdgo.go.types.Types.Chan)) : stdgo.Ref<stdgo.go.types.Types.Chan>);
                    _def._setUnderlying(stdgo.Go.asInterface(_typ));
                    var _dir:stdgo.go.types.Types.ChanDir = (0 : stdgo.go.types.Types.ChanDir);
                    {
                        final __value__ = _e.dir;
                        if (__value__ == ((3 : stdgo.go.ast.Ast.ChanDir))) {} else if (__value__ == ((1 : stdgo.go.ast.Ast.ChanDir))) {
                            _dir = (1 : stdgo.go.types.Types.ChanDir);
                        } else if (__value__ == ((2 : stdgo.go.ast.Ast.ChanDir))) {
                            _dir = (2 : stdgo.go.types.Types.ChanDir);
                        } else {
                            _check._errorf(stdgo.Go.asInterface(_e), (-1 : stdgo.internal.types.errors.Errors.Code), ("unknown channel direction %d" : stdgo.GoString), stdgo.Go.toInterface(_e.dir));
                        };
                    };
                    _typ._dir = _dir;
                    _typ._elem = _check._varType(_e.value);
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return stdgo.Go.asInterface(_typ);
                    };
                } else {
                    var _e:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                    _check._errorf(_e0, (25 : stdgo.internal.types.errors.Errors.Code), ("%s is not a type" : stdgo.GoString), stdgo.Go.toInterface(_e0));
                    _check._use(_e0);
                };
            };
            var _typ = typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)];
            _def._setUnderlying(stdgo.Go.asInterface(_typ));
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return stdgo.Go.asInterface(_typ);
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return t;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return t;
        };
    }
    /**
        // genericType is like typ but the type must be an (uninstantiated) generic
        // type. If cause is non-nil and the type expression was a valid type but not
        // generic, cause will be populated with a message describing the error.
    **/
    @:keep
    static public function _genericType( _check:stdgo.Ref<Checker>, _e:stdgo.go.ast.Ast.Expr, _cause:stdgo.Pointer<stdgo.GoString>):Type_ {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _typ:stdgo.go.types.Types.Type_ = _check._typInternal(_e, null);
        _assert(_isTyped(_typ));
        if ((stdgo.Go.toInterface(_typ) != stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]))) && !_isGeneric(_typ)) {
            if (_cause != null) {
                _cause.value = _check._sprintf(("%s is not a generic type" : stdgo.GoString), stdgo.Go.toInterface(_typ))?.__copy__();
            };
            _typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
        };
        _check._recordTypeAndValue(_e, (3 : stdgo.go.types.Types.T_operandMode), _typ, (null : stdgo.go.constant.Constant.Value));
        return _typ;
    }
    /**
        // definedType is like typ but also accepts a type name def.
        // If def != nil, e is the type specification for the defined type def, declared
        // in a type declaration, and def.underlying will be set to the type of e before
        // any components of e are type-checked.
    **/
    @:keep
    static public function _definedType( _check:stdgo.Ref<Checker>, _e:stdgo.go.ast.Ast.Expr, _def:stdgo.Ref<Named>):Type_ {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _typ:stdgo.go.types.Types.Type_ = _check._typInternal(_e, _def);
        _assert(_isTyped(_typ));
        if (_isGeneric(_typ)) {
            _check._errorf(_e, (137 : stdgo.internal.types.errors.Errors.Code), ("cannot use generic type %s without instantiation" : stdgo.GoString), stdgo.Go.toInterface(_typ));
            _typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
        };
        _check._recordTypeAndValue(_e, (3 : stdgo.go.types.Types.T_operandMode), _typ, (null : stdgo.go.constant.Constant.Value));
        return _typ;
    }
    /**
        // validVarType reports an error if typ is a constraint interface.
        // The expression e is used for error reporting, if any.
    **/
    @:keep
    static public function _validVarType( _check:stdgo.Ref<Checker>, _e:stdgo.go.ast.Ast.Expr, _typ:Type_):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if (_isTypeParam(_typ)) {
            return;
        };
        _check._later(function():Void {
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_typ)) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Interface>), _1 : false };
                }, _t = __tmp__._0, __8 = __tmp__._1;
                if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                    var _tset = _computeInterfaceTypeSet(_check, _e.pos(), _t);
                    if (!_tset.isMethodSet()) {
                        if (_tset._comparable) {
                            _check._softErrorf(_e, (142 : stdgo.internal.types.errors.Errors.Code), ("cannot use type %s outside a type constraint: interface is (or embeds) comparable" : stdgo.GoString), stdgo.Go.toInterface(_typ));
                        } else {
                            _check._softErrorf(_e, (142 : stdgo.internal.types.errors.Errors.Code), ("cannot use type %s outside a type constraint: interface contains type constraints" : stdgo.GoString), stdgo.Go.toInterface(_typ));
                        };
                    };
                };
            };
        })._describef(_e, ("check var type %s" : stdgo.GoString), stdgo.Go.toInterface(_typ));
    }
    /**
        // varType type-checks the type expression e and returns its type, or Typ[Invalid].
        // The type must not be an (uninstantiated) generic type and it must not be a
        // constraint interface.
    **/
    @:keep
    static public function _varType( _check:stdgo.Ref<Checker>, _e:stdgo.go.ast.Ast.Expr):Type_ {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _typ:stdgo.go.types.Types.Type_ = _check._definedType(_e, null);
        _check._validVarType(_e, _typ);
        return _typ;
    }
    /**
        // typ type-checks the type expression e and returns its type, or Typ[Invalid].
        // The type must not be an (uninstantiated) generic type.
    **/
    @:keep
    static public function _typ( _check:stdgo.Ref<Checker>, _e:stdgo.go.ast.Ast.Expr):Type_ {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        return _check._definedType(_e, null);
    }
    /**
        // ident type-checks identifier e and initializes x with the value or type of e.
        // If an error occurred, x.mode is set to invalid.
        // For the meaning of def, see Checker.definedType, below.
        // If wantType is set, the identifier e is expected to denote a type.
    **/
    @:keep
    static public function _ident( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _e:stdgo.Ref<stdgo.go.ast.Ast.Ident>, _def:stdgo.Ref<Named>, _wantType:Bool):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
        _x._expr = stdgo.Go.asInterface(_e);
        var __tmp__ = _check._pkg._scope.lookupParent(_e.name?.__copy__(), _check._environment._pos), _scope:stdgo.Ref<stdgo.go.types.Types.Scope> = __tmp__._0, _obj:stdgo.go.types.Types.Object = __tmp__._1;
        {
            final __value__ = _obj;
            if (__value__ == null) {
                if (_e.name == (("_" : stdgo.GoString))) {
                    {
                        var _tpar = (_check._recvTParamMap[_e] ?? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>));
                        if (_tpar != null && ((_tpar : Dynamic).__nil__ == null || !(_tpar : Dynamic).__nil__)) {
                            _x._mode = (3 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = stdgo.Go.asInterface(_tpar);
                        } else {
                            _check._error(stdgo.Go.asInterface(_e), (35 : stdgo.internal.types.errors.Errors.Code), ("cannot use _ as value or type" : stdgo.GoString));
                        };
                    };
                } else {
                    _check._errorf(stdgo.Go.asInterface(_e), (75 : stdgo.internal.types.errors.Errors.Code), ("undefined: %s" : stdgo.GoString), stdgo.Go.toInterface(_e.name));
                };
                return;
            } else if (stdgo.Go.toInterface(__value__) == (stdgo.Go.toInterface(_universeAny)) || stdgo.Go.toInterface(__value__) == (stdgo.Go.toInterface(_universeComparable))) {
                if (!_check._verifyVersionf(stdgo.Go.asInterface(_e), _go1_18?.__copy__(), ("predeclared %s" : stdgo.GoString), stdgo.Go.toInterface(_e.name))) {
                    return;
                };
            };
        };
        _check._recordUse(_e, _obj);
        var _typ:stdgo.go.types.Types.Type_ = _obj.type();
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<TypeName>)) : stdgo.Ref<TypeName>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeName>), _1 : false };
            }, __56 = __tmp__._0, _gotType = __tmp__._1;
            if ((_typ == null) || (_gotType && _wantType)) {
                _check._objDecl(_obj, _def);
                _typ = _obj.type();
            };
        };
        _assert(_typ != null);
        {
            var _pkgName = (_check._dotImportMap[(new stdgo.go.types.Types.T_dotImportKey(_scope, _obj.name()?.__copy__()) : stdgo.go.types.Types.T_dotImportKey)] ?? (null : stdgo.Ref<stdgo.go.types.Types.PkgName>));
            if (_pkgName != null && ((_pkgName : Dynamic).__nil__ == null || !(_pkgName : Dynamic).__nil__)) {
                _pkgName._used = true;
            };
        };
        {
            final __type__ = _obj;
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<PkgName>))) {
                var _obj:stdgo.Ref<stdgo.go.types.Types.PkgName> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.PkgName>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.PkgName>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.PkgName>) : __type__.__underlying__().value;
                _check._errorf(stdgo.Go.asInterface(_e), (4 : stdgo.internal.types.errors.Errors.Code), ("use of package %s not in selector" : stdgo.GoString), stdgo.Go.toInterface(_obj._object._name));
                return;
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Const>))) {
                var _obj:stdgo.Ref<stdgo.go.types.Types.Const> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Const>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Const>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Const>) : __type__.__underlying__().value;
                _check._addDeclDep(stdgo.Go.asInterface(_obj));
                if (stdgo.Go.toInterface(_typ) == (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                    return;
                };
                if (stdgo.Go.toInterface(stdgo.Go.asInterface(_obj)) == (stdgo.Go.toInterface(_universeIota))) {
                    if (_check._environment._iota == null) {
                        _check._error(stdgo.Go.asInterface(_e), (36 : stdgo.internal.types.errors.Errors.Code), ("cannot use iota outside constant declaration" : stdgo.GoString));
                        return;
                    };
                    _x._val = _check._environment._iota;
                } else {
                    _x._val = _obj._val;
                };
                _assert(_x._val != null);
                _x._mode = (4 : stdgo.go.types.Types.T_operandMode);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeName>))) {
                var _obj:stdgo.Ref<stdgo.go.types.Types.TypeName> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeName>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__().value;
                if (_check._isBrokenAlias(_obj)) {
                    _check._errorf(stdgo.Go.asInterface(_e), (11 : stdgo.internal.types.errors.Errors.Code), ("invalid use of type alias %s in recursive type (see go.dev/issue/50729)" : stdgo.GoString), stdgo.Go.toInterface(_obj._object._name));
                    return;
                };
                _x._mode = (3 : stdgo.go.types.Types.T_operandMode);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Var>))) {
                var _obj:stdgo.Ref<stdgo.go.types.Types.Var> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Var>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__().value;
                if (_obj._object._pkg == (_check._pkg)) {
                    _obj._used = true;
                };
                _check._addDeclDep(stdgo.Go.asInterface(_obj));
                if (stdgo.Go.toInterface(_typ) == (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                    return;
                };
                _x._mode = (5 : stdgo.go.types.Types.T_operandMode);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Func>))) {
                var _obj:stdgo.Ref<stdgo.go.types.Types.Func> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Func>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__().value;
                _check._addDeclDep(stdgo.Go.asInterface(_obj));
                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Builtin>))) {
                var _obj:stdgo.Ref<stdgo.go.types.Types.Builtin> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Builtin>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Builtin>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Builtin>) : __type__.__underlying__().value;
                _x._id = _obj._id;
                _x._mode = (2 : stdgo.go.types.Types.T_operandMode);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Nil>))) {
                var _obj:stdgo.Ref<stdgo.go.types.Types.Nil> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Nil>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Nil>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Nil>) : __type__.__underlying__().value;
                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
            } else {
                var _obj:stdgo.go.types.Types.Object = __type__ == null ? (null : stdgo.go.types.Types.Object) : cast __type__;
                _unreachable();
            };
        };
        _x._typ = _typ;
    }
    /**
        // check may be nil
    **/
    @:keep
    static public function _newTypeParam( _check:stdgo.Ref<Checker>, _obj:stdgo.Ref<TypeName>, _constraint:Type_):stdgo.Ref<TypeParam> {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _id:stdgo.GoUInt64 = _nextID();
        if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
            _check._nextID++;
            _id = _check._nextID;
        };
        var _typ = (stdgo.Go.setRef(({ _check : _check, _id : _id, _obj : _obj, _index : (-1 : stdgo.GoInt), _bound : _constraint } : stdgo.go.types.Types.TypeParam)) : stdgo.Ref<stdgo.go.types.Types.TypeParam>);
        if (_obj._object._typ == null) {
            _obj._object._typ = stdgo.Go.asInterface(_typ);
        };
        if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
            _check._needsCleanup(stdgo.Go.asInterface(_typ));
        } else if (_constraint != null) {
            _typ._iface();
        };
        return _typ;
    }
    /**
        // subst returns the type typ with its type parameters tpars replaced by the
        // corresponding type arguments targs, recursively. subst doesn't modify the
        // incoming type. If a substitution took place, the result type is different
        // from the incoming type.
        //
        // If expanding is non-nil, it is the instance type currently being expanded.
        // One of expanding or ctxt must be non-nil.
    **/
    @:keep
    static public function _subst( _check:stdgo.Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _typ:Type_, _smap:T_substMap, _expanding:stdgo.Ref<Named>, _ctxt:stdgo.Ref<Context>):Type_ {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _assert(((_expanding != null) && ((_expanding : Dynamic).__nil__ == null || !(_expanding : Dynamic).__nil__)) || ((_ctxt != null) && ((_ctxt : Dynamic).__nil__ == null || !(_ctxt : Dynamic).__nil__)));
        if (_smap._empty()) {
            return _typ;
        };
        {
            final __type__ = _typ;
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                var _t:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                return _typ;
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeParam>))) {
                var _t:stdgo.Ref<stdgo.go.types.Types.TypeParam> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__().value;
                return _smap._lookup(_t);
            };
        };
        var _subst:stdgo.go.types.Types.T_subster = ({ _pos : _pos, _smap : _smap, _check : _check, _expanding : _expanding, _ctxt : _ctxt } : stdgo.go.types.Types.T_subster);
        return _subst._expanding._obj._object._typ(_typ);
    }
    @:keep
    static public function _tag( _check:stdgo.Ref<Checker>, _t:stdgo.Ref<stdgo.go.ast.Ast.BasicLit>):stdgo.GoString {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
            if (_t.kind == ((9 : stdgo.go.token.Token.Token))) {
                {
                    var __tmp__ = stdgo.strconv.Strconv.unquote(_t.value?.__copy__()), _val:stdgo.GoString = __tmp__._0, _err:stdgo.Error = __tmp__._1;
                    if (_err == null) {
                        return _val?.__copy__();
                    };
                };
            };
            _check._errorf(stdgo.Go.asInterface(_t), (-1 : stdgo.internal.types.errors.Errors.Code), ("incorrect tag syntax: %q" : stdgo.GoString), stdgo.Go.toInterface(_t.value));
        };
        return stdgo.Go.str()?.__copy__();
    }
    @:keep
    static public function _declareInSet( _check:stdgo.Ref<Checker>, _oset:stdgo.Ref<T_objset>, _pos:stdgo.go.token.Token.Pos, _obj:Object):Bool {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        {
            var _alt:stdgo.go.types.Types.Object = _oset._insert(_obj);
            if (_alt != null) {
                _check._errorf(stdgo.Go.asInterface((_pos : T_atPos)), (10 : stdgo.internal.types.errors.Errors.Code), ("%s redeclared" : stdgo.GoString), stdgo.Go.toInterface(_obj.name()));
                _check._reportAltDecl(_alt);
                return false;
            };
        };
        return true;
    }
    @:keep
    static public function _structType( _check:stdgo.Ref<Checker>, _styp:stdgo.Ref<Struct>, _e:stdgo.Ref<stdgo.go.ast.Ast.StructType>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _list = _e.fields;
        if (_list == null || (_list : Dynamic).__nil__) {
            _styp._markComplete();
            return;
        };
        var _fields:stdgo.Slice<stdgo.Ref<Var>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>);
        var _tags:stdgo.Slice<stdgo.GoString> = (null : stdgo.Slice<stdgo.GoString>);
        var _fset:T_objset = (null : stdgo.go.types.Types.T_objset);
        var _typ:Type_ = (null : stdgo.go.types.Types.Type_);
        var _tag:stdgo.GoString = ("" : stdgo.GoString);
        var _add = function(_ident:stdgo.Ref<stdgo.go.ast.Ast.Ident>, _embedded:Bool, _pos:stdgo.go.token.Token.Pos):Void {
            if ((_tag != stdgo.Go.str()) && (_tags == null)) {
                _tags = new stdgo.Slice<stdgo.GoString>((_fields.length : stdgo.GoInt).toBasic(), 0).__setString__();
            };
            if (_tags != null) {
                _tags = (_tags.__append__(_tag?.__copy__()));
            };
            var _name:stdgo.GoString = _ident.name?.__copy__();
            var _fld = newField(_pos, _check._pkg, _name?.__copy__(), _typ, _embedded);
            if ((_name == ("_" : stdgo.GoString)) || _check._declareInSet((stdgo.Go.setRef(_fset) : stdgo.Ref<stdgo.go.types.Types.T_objset>), _pos, stdgo.Go.asInterface(_fld))) {
                _fields = (_fields.__append__(_fld));
                _check._recordDef(_ident, stdgo.Go.asInterface(_fld));
            };
        };
        var _addInvalid = function(_ident:stdgo.Ref<stdgo.go.ast.Ast.Ident>, _pos:stdgo.go.token.Token.Pos):Void {
            _typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
            _tag = stdgo.Go.str()?.__copy__();
            _add(_ident, true, _pos);
        };
        for (__0 => _f in _list.list) {
            _typ = _check._varType(_f.type);
            _tag = _check._tag(_f.tag)?.__copy__();
            if ((_f.names.length) > (0 : stdgo.GoInt)) {
                for (__17 => _name in _f.names) {
                    _add(_name, false, _name.pos());
                };
            } else {
                var _pos:stdgo.go.token.Token.Pos = _f.type.pos();
                var _name = _embeddedFieldIdent(_f.type);
                if (_name == null || (_name : Dynamic).__nil__) {
                    _check._errorf(_f.type, (-1 : stdgo.internal.types.errors.Errors.Code), ("embedded field type %s has no name" : stdgo.GoString), stdgo.Go.toInterface(_f.type));
                    _name = stdgo.go.ast.Ast.newIdent(("_" : stdgo.GoString));
                    _name.namePos = _pos;
                    _addInvalid(_name, _pos);
                    continue;
                };
                _add(_name, true, _name.pos());
                var _embeddedTyp:stdgo.go.types.Types.Type_ = _typ;
                var _embeddedPos:stdgo.go.ast.Ast.Expr = _f.type;
                _check._later(function():Void {
                    var __tmp__ = _deref(_embeddedTyp), _t:stdgo.go.types.Types.Type_ = __tmp__._0, _isPtr:Bool = __tmp__._1;
                    {
                        final __type__ = _under(_t);
                        {
                            var __bool__ = true;
                            while (__bool__) {
                                __bool__ = false;
                                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                                    var _u:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                                    if (stdgo.Go.toInterface(_t) == (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                                        return;
                                    };
                                    if (_u._kind == ((18 : stdgo.go.types.Types.BasicKind))) {
                                        _check._error(_embeddedPos, (30 : stdgo.internal.types.errors.Errors.Code), ("embedded field type cannot be unsafe.Pointer" : stdgo.GoString));
                                    };
                                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Pointer_>))) {
                                    var _u:stdgo.Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                                    _check._error(_embeddedPos, (30 : stdgo.internal.types.errors.Errors.Code), ("embedded field type cannot be a pointer" : stdgo.GoString));
                                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                                    var _u:stdgo.Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                                    if (_isTypeParam(_t)) {
                                        _check._error(_embeddedPos, (144 : stdgo.internal.types.errors.Errors.Code), ("embedded field type cannot be a (pointer to a) type parameter" : stdgo.GoString));
                                        break;
                                    };
                                    if (_isPtr) {
                                        _check._error(_embeddedPos, (30 : stdgo.internal.types.errors.Errors.Code), ("embedded field type cannot be a pointer to an interface" : stdgo.GoString));
                                    };
                                };
                                break;
                            };
                        };
                    };
                })._describef(_embeddedPos, ("check embedded type %s" : stdgo.GoString), stdgo.Go.toInterface(_embeddedTyp));
            };
        };
        _styp._fields = _fields;
        _styp._tags = _tags;
        _styp._markComplete();
    }
    /**
        // stmt typechecks statement s.
    **/
    @:keep
    static public function _stmt( _check:stdgo.Ref<Checker>, _ctxt:T_stmtContext, _s:stdgo.go.ast.Ast.Stmt):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            if (false) {
                {
                    var _a0 = _check._pkg._scope;
                    __deferstack__.unshift(() -> {
                        var a = function(_scope:stdgo.Ref<Scope>):Void {
                            {
                                var _p:stdgo.AnyInterface = ({
                                    final r = stdgo.Go.recover_exception;
                                    stdgo.Go.recover_exception = null;
                                    r;
                                });
                                if (_p != null) {
                                    throw stdgo.Go.toInterface(_p);
                                };
                            };
                            _assert(_scope == (_check._pkg._scope));
                        };
                        a(_a0);
                    });
                };
            };
            {
                var _a0 = (_check._delayed.length);
                __deferstack__.unshift(() -> _check._processDelayed(_a0));
            };
            var _inner:stdgo.go.types.Types.T_stmtContext = _ctxt & ((28u32 : stdgo.go.types.Types.T_stmtContext) ^ (-1i32 : stdgo.GoInt));
            {
                final __type__ = _s;
                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BadStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.EmptyStmt>))) {
                    var _s:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.DeclStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.DeclStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.DeclStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.DeclStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.DeclStmt>) : __type__.__underlying__().value;
                    _check._declStmt(_s.decl);
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__().value;
                    _check._environment._hasLabel = true;
                    _check._stmt(_ctxt, _s.stmt);
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ExprStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.ExprStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__().value;
                    var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                    var _kind:stdgo.go.types.Types.T_exprKind = _check._rawExpr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _s.x, (null : stdgo.go.types.Types.Type_), false);
                    var _msg:stdgo.GoString = ("" : stdgo.GoString);
                    var _code:Code = ((0 : stdgo.GoInt) : stdgo.internal.types.errors.Errors.Code);
                    {
                        final __value__ = _x._mode;
                        if (__value__ == ((2 : stdgo.go.types.Types.T_operandMode))) {
                            _msg = ("must be called" : stdgo.GoString);
                            _code = (82 : stdgo.internal.types.errors.Errors.Code);
                        } else if (__value__ == ((3 : stdgo.go.types.Types.T_operandMode))) {
                            _msg = ("is not an expression" : stdgo.GoString);
                            _code = (42 : stdgo.internal.types.errors.Errors.Code);
                        } else {
                            if (_kind == ((2 : stdgo.go.types.Types.T_exprKind))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return;
                                };
                            };
                            _msg = ("is not used" : stdgo.GoString);
                            _code = (100 : stdgo.internal.types.errors.Errors.Code);
                        };
                    };
                    _check._errorf(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>)), _code, ("%s %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>))), stdgo.Go.toInterface(_msg));
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SendStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.SendStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SendStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SendStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SendStmt>) : __type__.__underlying__().value;
                    var __0:T_operand = ({} : stdgo.go.types.Types.T_operand), __1:T_operand = ({} : stdgo.go.types.Types.T_operand), _val:T_operand = __1, _ch:T_operand = __0;
                    _check._expr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_ch) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _s.chan);
                    _check._expr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_val) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _s.value);
                    if ((_ch._mode == (0 : stdgo.go.types.Types.T_operandMode)) || (_val._mode == (0 : stdgo.go.types.Types.T_operandMode))) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return;
                        };
                    };
                    var _u:stdgo.go.types.Types.Type_ = _coreType(_ch._typ);
                    if (_u == null) {
                        _check._errorf(stdgo.Go.asInterface(_inNode(stdgo.Go.asInterface(_s), _s.arrow)), (59 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot send to %s: no core type" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface((stdgo.Go.setRef(_ch) : stdgo.Ref<stdgo.go.types.Types.T_operand>))));
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return;
                        };
                    };
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_u) : stdgo.Ref<Chan>)) : stdgo.Ref<Chan>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Chan>), _1 : false };
                    }, _uch = __tmp__._0, __88 = __tmp__._1;
                    if (_uch == null || (_uch : Dynamic).__nil__) {
                        _check._errorf(stdgo.Go.asInterface(_inNode(stdgo.Go.asInterface(_s), _s.arrow)), (59 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot send to non-channel %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface((stdgo.Go.setRef(_ch) : stdgo.Ref<stdgo.go.types.Types.T_operand>))));
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return;
                        };
                    };
                    if (_uch._dir == ((2 : stdgo.go.types.Types.ChanDir))) {
                        _check._errorf(stdgo.Go.asInterface(_inNode(stdgo.Go.asInterface(_s), _s.arrow)), (59 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot send to receive-only channel %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface((stdgo.Go.setRef(_ch) : stdgo.Ref<stdgo.go.types.Types.T_operand>))));
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return;
                        };
                    };
                    _check._assignment((stdgo.Go.setRef(_val) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _uch._elem, ("send" : stdgo.GoString));
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IncDecStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.IncDecStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IncDecStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IncDecStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IncDecStmt>) : __type__.__underlying__().value;
                    var _op:stdgo.go.token.Token.Token = ((0 : stdgo.GoInt) : stdgo.go.token.Token.Token);
                    {
                        final __value__ = _s.tok;
                        if (__value__ == ((37 : stdgo.go.token.Token.Token))) {
                            _op = (12 : stdgo.go.token.Token.Token);
                        } else if (__value__ == ((38 : stdgo.go.token.Token.Token))) {
                            _op = (13 : stdgo.go.token.Token.Token);
                        } else {
                            _check._errorf(stdgo.Go.asInterface(_inNode(stdgo.Go.asInterface(_s), _s.tokPos)), (-1 : stdgo.internal.types.errors.Errors.Code), ("unknown inc/dec operation %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_s.tok)));
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return;
                            };
                        };
                    };
                    var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                    _check._expr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _s.x);
                    if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return;
                        };
                    };
                    if (!_allNumeric(_x._typ)) {
                        _check._errorf(_s.x, (48 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: %s%s (non-numeric type %s)" : stdgo.GoString), stdgo.Go.toInterface(_s.x), stdgo.Go.toInterface(stdgo.Go.asInterface(_s.tok)), stdgo.Go.toInterface(_x._typ));
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return;
                        };
                    };
                    var y = (stdgo.Go.setRef(({ valuePos : _s.x.pos(), kind : (5 : stdgo.go.token.Token.Token), value : ("1" : stdgo.GoString) } : stdgo.go.ast.Ast.BasicLit)) : stdgo.Ref<stdgo.go.ast.Ast.BasicLit>);
                    _check._binary((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), (null : stdgo.go.ast.Ast.Expr), _s.x, stdgo.Go.asInterface(y), _op, _s.tokPos);
                    if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return;
                        };
                    };
                    _check._assignVar(_s.x, (null : stdgo.go.ast.Ast.Expr), (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>));
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.AssignStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.AssignStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__().value;
                    {
                        final __value__ = _s.tok;
                        if (__value__ == ((42 : stdgo.go.token.Token.Token)) || __value__ == ((47 : stdgo.go.token.Token.Token))) {
                            if ((_s.lhs.length) == ((0 : stdgo.GoInt))) {
                                _check._error(stdgo.Go.asInterface(_s), (-1 : stdgo.internal.types.errors.Errors.Code), ("missing lhs in assignment" : stdgo.GoString));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return;
                                };
                            };
                            if (_s.tok == ((47 : stdgo.go.token.Token.Token))) {
                                _check._shortVarDecl(stdgo.Go.asInterface(_inNode(stdgo.Go.asInterface(_s), _s.tokPos)), _s.lhs, _s.rhs);
                            } else {
                                _check._assignVars(_s.lhs, _s.rhs);
                            };
                        } else {
                            if ((_s.lhs.length != (1 : stdgo.GoInt)) || (_s.rhs.length != (1 : stdgo.GoInt))) {
                                _check._errorf(stdgo.Go.asInterface(_inNode(stdgo.Go.asInterface(_s), _s.tokPos)), (20 : stdgo.internal.types.errors.Errors.Code), ("assignment operation %s requires single-valued expressions" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_s.tok)));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return;
                                };
                            };
                            var _op:stdgo.go.token.Token.Token = _assignOp(_s.tok);
                            if (_op == ((0 : stdgo.go.token.Token.Token))) {
                                _check._errorf(stdgo.Go.asInterface((_s.tokPos : T_atPos)), (-1 : stdgo.internal.types.errors.Errors.Code), ("unknown assignment operation %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_s.tok)));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return;
                                };
                            };
                            var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                            _check._binary((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), (null : stdgo.go.ast.Ast.Expr), _s.lhs[(0 : stdgo.GoInt)], _s.rhs[(0 : stdgo.GoInt)], _op, _s.tokPos);
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return;
                                };
                            };
                            _check._assignVar(_s.lhs[(0 : stdgo.GoInt)], (null : stdgo.go.ast.Ast.Expr), (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>));
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.GoStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.GoStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.GoStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.GoStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.GoStmt>) : __type__.__underlying__().value;
                    _check._suspendedCall(("go" : stdgo.GoString), _s.call);
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.DeferStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.DeferStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.DeferStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.DeferStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.DeferStmt>) : __type__.__underlying__().value;
                    _check._suspendedCall(("defer" : stdgo.GoString), _s.call);
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ReturnStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.ReturnStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ReturnStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ReturnStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ReturnStmt>) : __type__.__underlying__().value;
                    var _res = _check._environment._sig._results;
                    if (((_s.results.length == (0 : stdgo.GoInt)) && (_res.len() > (0 : stdgo.GoInt))) && (_res._vars[(0 : stdgo.GoInt)]._object._name != stdgo.Go.str())) {
                        for (__233 => _obj in _res._vars) {
                            {
                                var _alt:stdgo.go.types.Types.Object = _check._lookup(_obj._object._name?.__copy__());
                                if ((_alt != null) && (stdgo.Go.toInterface(_alt) != stdgo.Go.toInterface(stdgo.Go.asInterface(_obj)))) {
                                    _check._errorf(stdgo.Go.asInterface(_s), (104 : stdgo.internal.types.errors.Errors.Code), ("result parameter %s not in scope at return" : stdgo.GoString), stdgo.Go.toInterface(_obj._object._name));
                                    _check._errorf(_alt, (104 : stdgo.internal.types.errors.Errors.Code), ("\tinner declaration of %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_obj)));
                                };
                            };
                        };
                    } else {
                        var _lhs:stdgo.Slice<stdgo.Ref<Var>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>);
                        if (_res.len() > (0 : stdgo.GoInt)) {
                            _lhs = _res._vars;
                        };
                        _check._initVars(_lhs, _s.results, stdgo.Go.asInterface(_s));
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.BranchStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__().value;
                    if (_s.label != null && ((_s.label : Dynamic).__nil__ == null || !(_s.label : Dynamic).__nil__)) {
                        _check._environment._hasLabel = true;
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return;
                        };
                    };
                    {
                        final __value__ = _s.tok;
                        if (__value__ == ((61 : stdgo.go.token.Token.Token))) {
                            if (_ctxt & (1u32 : stdgo.go.types.Types.T_stmtContext) == ((0u32 : stdgo.go.types.Types.T_stmtContext))) {
                                _check._error(stdgo.Go.asInterface(_s), (110 : stdgo.internal.types.errors.Errors.Code), ("break not in for, switch, or select statement" : stdgo.GoString));
                            };
                        } else if (__value__ == ((65 : stdgo.go.token.Token.Token))) {
                            if (_ctxt & (2u32 : stdgo.go.types.Types.T_stmtContext) == ((0u32 : stdgo.go.types.Types.T_stmtContext))) {
                                _check._error(stdgo.Go.asInterface(_s), (111 : stdgo.internal.types.errors.Errors.Code), ("continue not in for statement" : stdgo.GoString));
                            };
                        } else if (__value__ == ((69 : stdgo.go.token.Token.Token))) {
                            if (_ctxt & (4u32 : stdgo.go.types.Types.T_stmtContext) == ((0u32 : stdgo.go.types.Types.T_stmtContext))) {
                                var _msg:stdgo.GoString = ("" : stdgo.GoString);
                                if (_ctxt & (8u32 : stdgo.go.types.Types.T_stmtContext) != ((0u32 : stdgo.go.types.Types.T_stmtContext))) {
                                    _msg = ("cannot fallthrough final case in switch" : stdgo.GoString);
                                } else if (_ctxt & (16u32 : stdgo.go.types.Types.T_stmtContext) != ((0u32 : stdgo.go.types.Types.T_stmtContext))) {
                                    _msg = ("cannot fallthrough in type switch" : stdgo.GoString);
                                } else {
                                    _msg = ("fallthrough statement out of place" : stdgo.GoString);
                                };
                                _check._error(stdgo.Go.asInterface(_s), (112 : stdgo.internal.types.errors.Errors.Code), _msg?.__copy__());
                            };
                        } else {
                            _check._errorf(stdgo.Go.asInterface(_s), (-1 : stdgo.internal.types.errors.Errors.Code), ("branch statement: %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_s.tok)));
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.BlockStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__().value;
                    _check._openScope(stdgo.Go.asInterface(_s), ("block" : stdgo.GoString));
                    __deferstack__.unshift(() -> _check._closeScope());
                    _check._stmtList(_inner, _s.list);
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IfStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.IfStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IfStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__().value;
                    _check._openScope(stdgo.Go.asInterface(_s), ("if" : stdgo.GoString));
                    __deferstack__.unshift(() -> _check._closeScope());
                    _check._simpleStmt(_s.init);
                    var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                    _check._expr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _s.cond);
                    if ((_x._mode != (0 : stdgo.go.types.Types.T_operandMode)) && !_allBoolean(_x._typ)) {
                        _check._error(_s.cond, (105 : stdgo.internal.types.errors.Errors.Code), ("non-boolean condition in if statement" : stdgo.GoString));
                    };
                    _check._stmt(_inner, stdgo.Go.asInterface(_s.body));
                    {
                        final __type__ = _s.else_;
                        if (__type__ == null || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BadStmt>))) {} else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IfStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>))) {
                            _check._stmt(_inner, _s.else_);
                        } else {
                            _check._error(_s.else_, (-1 : stdgo.internal.types.errors.Errors.Code), ("invalid else branch in if statement" : stdgo.GoString));
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SwitchStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.SwitchStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__().value;
                    _inner = _inner | ((1u32 : stdgo.go.types.Types.T_stmtContext));
                    _check._openScope(stdgo.Go.asInterface(_s), ("switch" : stdgo.GoString));
                    __deferstack__.unshift(() -> _check._closeScope());
                    _check._simpleStmt(_s.init);
                    var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                    if (_s.tag != null) {
                        _check._expr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _s.tag);
                        _check._assignment((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), (null : stdgo.go.types.Types.Type_), ("switch expression" : stdgo.GoString));
                        if (((_x._mode != (0 : stdgo.go.types.Types.T_operandMode)) && !comparable(_x._typ)) && !_hasNil(_x._typ)) {
                            _check._errorf(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>)), (117 : stdgo.internal.types.errors.Errors.Code), ("cannot switch on %s (%s is not comparable)" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>))), stdgo.Go.toInterface(_x._typ));
                            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                        };
                    } else {
                        _x._mode = (4 : stdgo.go.types.Types.T_operandMode);
                        _x._typ = stdgo.Go.asInterface(typ[((1 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                        _x._val = stdgo.go.constant.Constant.makeBool(true);
                        _x._expr = stdgo.Go.asInterface((stdgo.Go.setRef(({ namePos : _s.body.lbrace, name : ("true" : stdgo.GoString) } : stdgo.go.ast.Ast.Ident)) : stdgo.Ref<stdgo.go.ast.Ast.Ident>));
                    };
                    _check._multipleDefaults(_s.body.list);
                    var _seen:stdgo.go.types.Types.T_valueMap = ({
                        final x = new stdgo.GoMap.GoAnyInterfaceMap<stdgo.Slice<stdgo.go.types.Types.T_valueType>>();
                        x.__defaultValue__ = () -> (null : stdgo.Slice<stdgo.go.types.Types.T_valueType>);
                        @:mergeBlock {};
                        cast x;
                    } : stdgo.GoMap<stdgo.AnyInterface, stdgo.Slice<stdgo.go.types.Types.T_valueType>>);
                    for (_i => _c in _s.body.list) {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_c) : stdgo.Ref<stdgo.go.ast.Ast.CaseClause>)) : stdgo.Ref<stdgo.go.ast.Ast.CaseClause>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.CaseClause>), _1 : false };
                        }, _clause = __tmp__._0, __450 = __tmp__._1;
                        if (_clause == null || (_clause : Dynamic).__nil__) {
                            _check._error(_c, (-1 : stdgo.internal.types.errors.Errors.Code), ("incorrect expression switch case" : stdgo.GoString));
                            continue;
                        };
                        _check._caseValues((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _clause.list, _seen);
                        _check._openScope(stdgo.Go.asInterface(_clause), ("case" : stdgo.GoString));
                        var _inner:stdgo.go.types.Types.T_stmtContext = _inner;
                        if ((_i + (1 : stdgo.GoInt)) < (_s.body.list.length)) {
                            _inner = _inner | ((4u32 : stdgo.go.types.Types.T_stmtContext));
                        } else {
                            _inner = _inner | ((8u32 : stdgo.go.types.Types.T_stmtContext));
                        };
                        _check._stmtList(_inner, _clause.body);
                        _check._closeScope();
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.TypeSwitchStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.TypeSwitchStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__().value;
                    _inner = _inner | ((17u32 : stdgo.go.types.Types.T_stmtContext));
                    _check._openScope(stdgo.Go.asInterface(_s), ("type switch" : stdgo.GoString));
                    __deferstack__.unshift(() -> _check._closeScope());
                    _check._simpleStmt(_s.init);
                    var _lhs:stdgo.Ref<stdgo.go.ast.Ast.Ident> = (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>);
                    var _rhs:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
                    {
                        final __type__ = _s.assign;
                        if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ExprStmt>))) {
                            var _guard:stdgo.Ref<stdgo.go.ast.Ast.ExprStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__().value;
                            _rhs = _guard.x;
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.AssignStmt>))) {
                            var _guard:stdgo.Ref<stdgo.go.ast.Ast.AssignStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__().value;
                            if (((_guard.lhs.length != (1 : stdgo.GoInt)) || (_guard.tok != (47 : stdgo.go.token.Token.Token))) || (_guard.rhs.length != (1 : stdgo.GoInt))) {
                                _check._error(stdgo.Go.asInterface(_s), (-1 : stdgo.internal.types.errors.Errors.Code), ("incorrect form of type switch guard" : stdgo.GoString));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return;
                                };
                            };
                            {
                                var __tmp__ = try {
                                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_guard.lhs[(0 : stdgo.GoInt)]) : stdgo.Ref<stdgo.go.ast.Ast.Ident>)) : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _1 : true };
                                } catch(_) {
                                    { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _1 : false };
                                };
                                _lhs = __tmp__._0;
                            };
                            if (_lhs == null || (_lhs : Dynamic).__nil__) {
                                _check._error(stdgo.Go.asInterface(_s), (-1 : stdgo.internal.types.errors.Errors.Code), ("incorrect form of type switch guard" : stdgo.GoString));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return;
                                };
                            };
                            if (_lhs.name == (("_" : stdgo.GoString))) {
                                _check._softErrorf(stdgo.Go.asInterface(_lhs), (19 : stdgo.internal.types.errors.Errors.Code), ("no new variable on left side of :=" : stdgo.GoString));
                                _lhs = null;
                            } else {
                                _check._recordDef(_lhs, (null : stdgo.go.types.Types.Object));
                            };
                            _rhs = _guard.rhs[(0 : stdgo.GoInt)];
                        } else {
                            var _guard:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
                            _check._error(stdgo.Go.asInterface(_s), (-1 : stdgo.internal.types.errors.Errors.Code), ("incorrect form of type switch guard" : stdgo.GoString));
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return;
                            };
                        };
                    };
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_rhs) : stdgo.Ref<stdgo.go.ast.Ast.TypeAssertExpr>)) : stdgo.Ref<stdgo.go.ast.Ast.TypeAssertExpr>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.TypeAssertExpr>), _1 : false };
                    }, _expr = __tmp__._0, __555 = __tmp__._1;
                    if (((_expr == null) || (_expr : Dynamic).__nil__) || (_expr.type != null)) {
                        _check._error(stdgo.Go.asInterface(_s), (-1 : stdgo.internal.types.errors.Errors.Code), ("incorrect form of type switch guard" : stdgo.GoString));
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return;
                        };
                    };
                    var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                    _check._expr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _expr.x);
                    if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return;
                        };
                    };
                    var _sx:stdgo.Ref<T_operand> = (null : stdgo.Ref<stdgo.go.types.Types.T_operand>);
                    if (_isTypeParam(_x._typ)) {
                        _check._errorf(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>)), (116 : stdgo.internal.types.errors.Errors.Code), ("cannot use type switch on type parameter value %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>))));
                    } else {
                        {
                            var __tmp__ = try {
                                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_x._typ)) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>), _1 : true };
                            } catch(_) {
                                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Interface>), _1 : false };
                            }, __580 = __tmp__._0, _ok = __tmp__._1;
                            if (_ok) {
                                _sx = (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>);
                            } else {
                                _check._errorf(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>)), (116 : stdgo.internal.types.errors.Errors.Code), ("%s is not an interface" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>))));
                            };
                        };
                    };
                    _check._multipleDefaults(_s.body.list);
                    var _lhsVars:stdgo.Slice<stdgo.Ref<Var>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>);
                    var _seen = ({
                        final x = new stdgo.GoMap.GoObjectMap<stdgo.go.types.Types.Type_, stdgo.go.ast.Ast.Expr>();
                        x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Type_", [], stdgo.internal.reflect.Reflect.GoType.named("Type_", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
                        x.__defaultValue__ = () -> (null : stdgo.go.ast.Ast.Expr);
                        @:mergeBlock {};
                        cast x;
                    } : stdgo.GoMap<stdgo.go.types.Types.Type_, stdgo.go.ast.Ast.Expr>);
                    for (__597 => _s in _s.body.list) {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_s) : stdgo.Ref<stdgo.go.ast.Ast.CaseClause>)) : stdgo.Ref<stdgo.go.ast.Ast.CaseClause>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.CaseClause>), _1 : false };
                        }, _clause = __tmp__._0, __598 = __tmp__._1;
                        if (_clause == null || (_clause : Dynamic).__nil__) {
                            _check._error(_s, (-1 : stdgo.internal.types.errors.Errors.Code), ("incorrect type switch case" : stdgo.GoString));
                            continue;
                        };
                        var t:stdgo.go.types.Types.Type_ = _check._caseTypes(_sx, _clause.list, _seen);
                        _check._openScope(stdgo.Go.asInterface(_clause), ("case" : stdgo.GoString));
                        if (_lhs != null && ((_lhs : Dynamic).__nil__ == null || !(_lhs : Dynamic).__nil__)) {
                            if ((_clause.list.length != (1 : stdgo.GoInt)) || (t == null)) {
                                t = _x._typ;
                            };
                            var _obj = newVar(_lhs.pos(), _check._pkg, _lhs.name?.__copy__(), t);
                            var _scopePos:stdgo.go.token.Token.Pos = _clause.pos() + (("default" : stdgo.GoString).length : stdgo.go.token.Token.Pos);
                            {
                                var _n:stdgo.GoInt = (_clause.list.length);
                                if (_n > (0 : stdgo.GoInt)) {
                                    _scopePos = _clause.list[(_n - (1 : stdgo.GoInt) : stdgo.GoInt)].end();
                                };
                            };
                            _check._declare(_check._pkg._scope, null, stdgo.Go.asInterface(_obj), _scopePos);
                            _check._recordImplicit(stdgo.Go.asInterface(_clause), stdgo.Go.asInterface(_obj));
                            _lhsVars = (_lhsVars.__append__(_obj));
                        };
                        _check._stmtList(_inner, _clause.body);
                        _check._closeScope();
                    };
                    if (_lhs != null && ((_lhs : Dynamic).__nil__ == null || !(_lhs : Dynamic).__nil__)) {
                        var _used:Bool = false;
                        for (__671 => _v in _lhsVars) {
                            if (_v._used) {
                                _used = true;
                            };
                            _v._used = true;
                        };
                        if (!_used) {
                            _check._softErrorf(stdgo.Go.asInterface(_lhs), (101 : stdgo.internal.types.errors.Errors.Code), ("%s declared and not used" : stdgo.GoString), stdgo.Go.toInterface(_lhs.name));
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SelectStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.SelectStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__().value;
                    _inner = _inner | ((1u32 : stdgo.go.types.Types.T_stmtContext));
                    _check._multipleDefaults(_s.body.list);
                    for (__688 => _s in _s.body.list) {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_s) : stdgo.Ref<stdgo.go.ast.Ast.CommClause>)) : stdgo.Ref<stdgo.go.ast.Ast.CommClause>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.CommClause>), _1 : false };
                        }, _clause = __tmp__._0, __689 = __tmp__._1;
                        if (_clause == null || (_clause : Dynamic).__nil__) {
                            continue;
                        };
                        var _valid:Bool = false;
                        var _rhs:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
                        {
                            final __type__ = _clause.comm;
                            if (__type__ == null || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SendStmt>))) {
                                var _s:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
                                _valid = true;
                            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.AssignStmt>))) {
                                var _s:stdgo.Ref<stdgo.go.ast.Ast.AssignStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__().value;
                                if ((_s.rhs.length) == ((1 : stdgo.GoInt))) {
                                    _rhs = _s.rhs[(0 : stdgo.GoInt)];
                                };
                            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ExprStmt>))) {
                                var _s:stdgo.Ref<stdgo.go.ast.Ast.ExprStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__().value;
                                _rhs = _s.x;
                            };
                        };
                        if (_rhs != null) {
                            {
                                var __tmp__ = try {
                                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_unparen(_rhs)) : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>)) : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>), _1 : true };
                                } catch(_) {
                                    { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>), _1 : false };
                                }, _x = __tmp__._0, __690 = __tmp__._1;
                                if (((_x != null) && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) && (_x.op == (36 : stdgo.go.token.Token.Token))) {
                                    _valid = true;
                                };
                            };
                        };
                        if (!_valid) {
                            _check._error(_clause.comm, (118 : stdgo.internal.types.errors.Errors.Code), ("select case must be send or receive (possibly with assignment)" : stdgo.GoString));
                            continue;
                        };
                        _check._openScope(_s, ("case" : stdgo.GoString));
                        if (_clause.comm != null) {
                            _check._stmt(_inner, _clause.comm);
                        };
                        _check._stmtList(_inner, _clause.body);
                        _check._closeScope();
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ForStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.ForStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ForStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__().value;
                    _inner = _inner | ((3u32 : stdgo.go.types.Types.T_stmtContext));
                    _check._openScope(stdgo.Go.asInterface(_s), ("for" : stdgo.GoString));
                    __deferstack__.unshift(() -> _check._closeScope());
                    _check._simpleStmt(_s.init);
                    if (_s.cond != null) {
                        var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                        _check._expr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _s.cond);
                        if ((_x._mode != (0 : stdgo.go.types.Types.T_operandMode)) && !_allBoolean(_x._typ)) {
                            _check._error(_s.cond, (105 : stdgo.internal.types.errors.Errors.Code), ("non-boolean condition in for statement" : stdgo.GoString));
                        };
                    };
                    _check._simpleStmt(_s.post);
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_s.post) : stdgo.Ref<stdgo.go.ast.Ast.AssignStmt>)) : stdgo.Ref<stdgo.go.ast.Ast.AssignStmt>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.AssignStmt>), _1 : false };
                        }, _s = __tmp__._0, __779 = __tmp__._1;
                        if (((_s != null) && ((_s : Dynamic).__nil__ == null || !(_s : Dynamic).__nil__)) && (_s.tok == (47 : stdgo.go.token.Token.Token))) {
                            _check._softErrorf(stdgo.Go.asInterface(_s), (106 : stdgo.internal.types.errors.Errors.Code), ("cannot declare in post statement" : stdgo.GoString));
                            _check._use(..._s.lhs.__toArray__());
                        };
                    };
                    _check._stmt(_inner, stdgo.Go.asInterface(_s.body));
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.RangeStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.RangeStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__.__underlying__().value;
                    _inner = _inner | ((3u32 : stdgo.go.types.Types.T_stmtContext));
                    var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                    _check._expr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _s.x);
                    var __0:Type_ = (null : stdgo.go.types.Types.Type_), __1:Type_ = (null : stdgo.go.types.Types.Type_), _val:Type_ = __1, _key:Type_ = __0;
                    if (_x._mode != ((0 : stdgo.go.types.Types.T_operandMode))) {
                        var _cause:stdgo.GoString = ("" : stdgo.GoString);
                        var _u:stdgo.go.types.Types.Type_ = _coreType(_x._typ);
                        {
                            final __type__ = _u;
                            if (__type__ == null) {
                                var _t:stdgo.AnyInterface = __type__ == null ? (null : stdgo.AnyInterface) : cast __type__;
                                _cause = _check._sprintf(("%s has no core type" : stdgo.GoString), stdgo.Go.toInterface(_x._typ))?.__copy__();
                            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Chan>))) {
                                var _t:stdgo.Ref<stdgo.go.types.Types.Chan> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__().value;
                                if (_s.value != null) {
                                    _check._softErrorf(_s.value, (108 : stdgo.internal.types.errors.Errors.Code), ("range over %s permits only one iteration variable" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>))));
                                };
                                if (_t._dir == ((1 : stdgo.go.types.Types.ChanDir))) {
                                    _cause = ("receive from send-only channel" : stdgo.GoString);
                                };
                            };
                        };
                        {
                            var __tmp__ = _rangeKeyVal(_u);
                            _key = __tmp__._0;
                            _val = __tmp__._1;
                        };
                        if ((_key == null) || (_cause != stdgo.Go.str())) {
                            if (_cause == (stdgo.Go.str())) {
                                _check._softErrorf(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>)), (109 : stdgo.internal.types.errors.Errors.Code), ("cannot range over %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>))));
                            } else {
                                _check._softErrorf(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>)), (109 : stdgo.internal.types.errors.Errors.Code), ("cannot range over %s (%s)" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>))), stdgo.Go.toInterface(_cause));
                            };
                        };
                    };
                    _check._openScope(stdgo.Go.asInterface(_s), ("range" : stdgo.GoString));
                    __deferstack__.unshift(() -> _check._closeScope());
                    var _lhs = (new stdgo.GoArray<stdgo.go.ast.Ast.Expr>(_s.key, _s.value) : stdgo.GoArray<stdgo.go.ast.Ast.Expr>);
                    var _rhs = (new stdgo.GoArray<stdgo.go.types.Types.Type_>(_key, _val) : stdgo.GoArray<stdgo.go.types.Types.Type_>);
                    if (_s.tok == ((47 : stdgo.go.token.Token.Token))) {
                        var _vars:stdgo.Slice<stdgo.Ref<Var>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>);
                        for (_i => _lhs in _lhs) {
                            if (_lhs == null) {
                                continue;
                            };
                            var _obj:stdgo.Ref<Var> = (null : stdgo.Ref<stdgo.go.types.Types.Var>);
                            {
                                var __tmp__ = try {
                                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_lhs) : stdgo.Ref<stdgo.go.ast.Ast.Ident>)) : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _1 : true };
                                } catch(_) {
                                    { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _1 : false };
                                }, _ident = __tmp__._0, __860 = __tmp__._1;
                                if (_ident != null && ((_ident : Dynamic).__nil__ == null || !(_ident : Dynamic).__nil__)) {
                                    var _name:stdgo.GoString = _ident.name?.__copy__();
                                    _obj = newVar(_ident.pos(), _check._pkg, _name?.__copy__(), (null : stdgo.go.types.Types.Type_));
                                    _check._recordDef(_ident, stdgo.Go.asInterface(_obj));
                                    if (_name != (("_" : stdgo.GoString))) {
                                        _vars = (_vars.__append__(_obj));
                                    };
                                } else {
                                    _check._errorf(_lhs, (-1 : stdgo.internal.types.errors.Errors.Code), ("cannot declare %s" : stdgo.GoString), stdgo.Go.toInterface(_lhs));
                                    _obj = newVar(_lhs.pos(), _check._pkg, ("_" : stdgo.GoString), (null : stdgo.go.types.Types.Type_));
                                };
                            };
                            {
                                var _typ:stdgo.go.types.Types.Type_ = _rhs[(_i : stdgo.GoInt)];
                                if (_typ != null) {
                                    _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                                    _x._expr = _lhs;
                                    _x._typ = _typ;
                                    _check._initVar(_obj, (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), ("range clause" : stdgo.GoString));
                                } else {
                                    _obj._object._typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                                    _obj._used = true;
                                };
                            };
                        };
                        if ((_vars.length) > (0 : stdgo.GoInt)) {
                            var _scopePos:stdgo.go.token.Token.Pos = _s.body.pos();
                            for (__901 => _obj in _vars) {
                                _check._declare(_check._pkg._scope, null, stdgo.Go.asInterface(_obj), _scopePos);
                            };
                        } else {
                            _check._error(stdgo.Go.asInterface(_inNode(stdgo.Go.asInterface(_s), _s.tokPos)), (19 : stdgo.internal.types.errors.Errors.Code), ("no new variables on left side of :=" : stdgo.GoString));
                        };
                    } else {
                        for (_i => _lhs in _lhs) {
                            if (_lhs == null) {
                                continue;
                            };
                            {
                                var _typ:stdgo.go.types.Types.Type_ = _rhs[(_i : stdgo.GoInt)];
                                if (_typ != null) {
                                    _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                                    _x._expr = _lhs;
                                    _x._typ = _typ;
                                    _check._assignVar(_lhs, (null : stdgo.go.ast.Ast.Expr), (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>));
                                };
                            };
                        };
                    };
                    _check._stmt(_inner, stdgo.Go.asInterface(_s.body));
                } else {
                    var _s:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
                    _check._error(_s, (-1 : stdgo.internal.types.errors.Errors.Code), ("invalid statement" : stdgo.GoString));
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return;
        };
    }
    /**
        // If the type switch expression is invalid, x is nil.
    **/
    @:keep
    static public function _caseTypes( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _types:stdgo.Slice<stdgo.go.ast.Ast.Expr>, _seen:stdgo.GoMap<Type_, stdgo.go.ast.Ast.Expr>):Type_ {
        stdgo.internal.Macro.controlFlow({
            @:recv var _check:stdgo.Ref<Checker> = _check;
            var t:Type_ = (null : stdgo.go.types.Types.Type_);
            var _dummy:T_operand = ({} : stdgo.go.types.Types.T_operand);
            @:label("L") for (__0 => _e in _types) {
                if (_check._isNil(_e)) {
                    t = (null : stdgo.go.types.Types.Type_);
                    _check._expr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_dummy) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _e);
                } else {
                    t = _check._varType(_e);
                    if (stdgo.Go.toInterface(t) == (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                        @:jump("L") continue;
                    };
                };
                for (_t => _other in _seen) {
                    if (((t == null) && (_t == null)) || (((t != null) && (_t != null)) && identical(t, _t))) {
                        var ts:stdgo.GoString = ("nil" : stdgo.GoString);
                        if (t != null) {
                            ts = typeString(t, _check._qualifier)?.__copy__();
                        };
                        _check._errorf(_e, (113 : stdgo.internal.types.errors.Errors.Code), ("duplicate case %s in type switch" : stdgo.GoString), stdgo.Go.toInterface(ts));
                        _check._error(_other, (113 : stdgo.internal.types.errors.Errors.Code), ("\tprevious case" : stdgo.GoString));
                        @:jump("L") continue;
                    };
                };
                _seen[t] = _e;
                if (((_x != null) && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) && (t != null)) {
                    _check._typeAssertion(_e, _x, t, true);
                };
            };
            return t;
        });
        throw "controlFlow did not return";
    }
    /**
        // isNil reports whether the expression e denotes the predeclared value nil.
    **/
    @:keep
    static public function _isNil( _check:stdgo.Ref<Checker>, _e:stdgo.go.ast.Ast.Expr):Bool {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_unparen(_e)) : stdgo.Ref<stdgo.go.ast.Ast.Ident>)) : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _1 : false };
            }, _name = __tmp__._0, __0 = __tmp__._1;
            if (_name != null && ((_name : Dynamic).__nil__ == null || !(_name : Dynamic).__nil__)) {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_check._lookup(_name.name?.__copy__())) : stdgo.Ref<Nil>)) : stdgo.Ref<Nil>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Nil>), _1 : false };
                }, __9 = __tmp__._0, _ok = __tmp__._1;
                return _ok;
            };
        };
        return false;
    }
    @:keep
    static public function _caseValues( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _values:stdgo.Slice<stdgo.go.ast.Ast.Expr>, _seen:T_valueMap):Void {
        stdgo.internal.Macro.controlFlow({
            @:recv var _check:stdgo.Ref<Checker> = _check;
            @:label("L") for (__0 => _e in _values) {
                var _v:T_operand = ({} : stdgo.go.types.Types.T_operand);
                _check._expr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_v) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _e);
                if ((_x._mode == (0 : stdgo.go.types.Types.T_operandMode)) || (_v._mode == (0 : stdgo.go.types.Types.T_operandMode))) {
                    @:jump("L") continue;
                };
                _check._convertUntyped((stdgo.Go.setRef(_v) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _x._typ);
                if (_v._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                    @:jump("L") continue;
                };
                var _res:stdgo.go.types.Types.T_operand = _v?.__copy__();
                _check._comparison((stdgo.Go.setRef(_res) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _x, (39 : stdgo.go.token.Token.Token), true);
                if (_res._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                    @:jump("L") continue;
                };
                if (_v._mode != ((4 : stdgo.go.types.Types.T_operandMode))) {
                    @:jump("L") continue;
                };
                {
                    var _val:stdgo.AnyInterface = _goVal(_v._val);
                    if (_val != null) {
                        for (__25 => _vt in (_seen[_val] ?? (null : stdgo.Slice<stdgo.go.types.Types.T_valueType>))) {
                            if (identical(_v._typ, _vt._typ)) {
                                _check._errorf(stdgo.Go.asInterface((stdgo.Go.setRef(_v) : stdgo.Ref<stdgo.go.types.Types.T_operand>)), (113 : stdgo.internal.types.errors.Errors.Code), ("duplicate case %s in expression switch" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface((stdgo.Go.setRef(_v) : stdgo.Ref<stdgo.go.types.Types.T_operand>))));
                                _check._error(stdgo.Go.asInterface((_vt._pos : T_atPos)), (113 : stdgo.internal.types.errors.Errors.Code), ("\tprevious case" : stdgo.GoString));
                                @:jump("L") continue;
                            };
                        };
                        _seen[_val] = ((_seen[_val] ?? (null : stdgo.Slice<stdgo.go.types.Types.T_valueType>)).__append__((new stdgo.go.types.Types.T_valueType(_v.pos(), _v._typ) : stdgo.go.types.Types.T_valueType)));
                    };
                };
            };
        });
    }
    @:keep
    static public function _suspendedCall( _check:stdgo.Ref<Checker>, _keyword:stdgo.GoString, _call:stdgo.Ref<stdgo.go.ast.Ast.CallExpr>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
        var _msg:stdgo.GoString = ("" : stdgo.GoString);
        var _code:Code = ((0 : stdgo.GoInt) : stdgo.internal.types.errors.Errors.Code);
        {
            final __value__ = _check._rawExpr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), stdgo.Go.asInterface(_call), (null : stdgo.go.types.Types.Type_), false);
            if (__value__ == ((0 : stdgo.go.types.Types.T_exprKind))) {
                _msg = ("requires function call, not conversion" : stdgo.GoString);
                _code = (129 : stdgo.internal.types.errors.Errors.Code);
                if (_keyword == (("go" : stdgo.GoString))) {
                    _code = (130 : stdgo.internal.types.errors.Errors.Code);
                };
            } else if (__value__ == ((1 : stdgo.go.types.Types.T_exprKind))) {
                _msg = ("discards result of" : stdgo.GoString);
                _code = (128 : stdgo.internal.types.errors.Errors.Code);
            } else if (__value__ == ((2 : stdgo.go.types.Types.T_exprKind))) {
                return;
            } else {
                _unreachable();
            };
        };
        _check._errorf(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>)), _code, ("%s %s %s" : stdgo.GoString), stdgo.Go.toInterface(_keyword), stdgo.Go.toInterface(_msg), stdgo.Go.toInterface(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>))));
    }
    @:keep
    static public function _closeScope( _check:stdgo.Ref<Checker>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _check._pkg._scope = _check._pkg._scope.parent();
    }
    @:keep
    static public function _openScope( _check:stdgo.Ref<Checker>, _node:stdgo.go.ast.Ast.Node, _comment:stdgo.GoString):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _scope = newScope(_check._pkg._scope, _node.pos(), _node.end(), _comment?.__copy__());
        _check._recordScope(_node, _scope);
        _check._pkg._scope = _scope;
    }
    @:keep
    static public function _multipleDefaults( _check:stdgo.Ref<Checker>, _list:stdgo.Slice<stdgo.go.ast.Ast.Stmt>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _first:stdgo.go.ast.Ast.Stmt = (null : stdgo.go.ast.Ast.Stmt);
        for (__0 => _s in _list) {
            var _d:stdgo.go.ast.Ast.Stmt = (null : stdgo.go.ast.Ast.Stmt);
            {
                final __type__ = _s;
                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.CaseClause>))) {
                    var _c:stdgo.Ref<stdgo.go.ast.Ast.CaseClause> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CaseClause>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CaseClause>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CaseClause>) : __type__.__underlying__().value;
                    if ((_c.list.length) == ((0 : stdgo.GoInt))) {
                        _d = _s;
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.CommClause>))) {
                    var _c:stdgo.Ref<stdgo.go.ast.Ast.CommClause> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CommClause>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CommClause>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CommClause>) : __type__.__underlying__().value;
                    if (_c.comm == null) {
                        _d = _s;
                    };
                } else {
                    var _c:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
                    _check._error(_s, (-1 : stdgo.internal.types.errors.Errors.Code), ("case/communication clause expected" : stdgo.GoString));
                };
            };
            if (_d != null) {
                if (_first != null) {
                    _check._errorf(_d, (114 : stdgo.internal.types.errors.Errors.Code), ("multiple defaults (first at %s)" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_check._fset.position(_first.pos()))));
                } else {
                    _first = _d;
                };
            };
        };
    }
    @:keep
    static public function _stmtList( _check:stdgo.Ref<Checker>, _ctxt:T_stmtContext, _list:stdgo.Slice<stdgo.go.ast.Ast.Stmt>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _ok:Bool = _ctxt & (4u32 : stdgo.go.types.Types.T_stmtContext) != ((0u32 : stdgo.go.types.Types.T_stmtContext));
        var _inner:stdgo.go.types.Types.T_stmtContext = _ctxt & ((4u32 : stdgo.go.types.Types.T_stmtContext) ^ (-1i32 : stdgo.GoInt));
        _list = _trimTrailingEmptyStmts(_list);
        for (_i => _s in _list) {
            var _inner:stdgo.go.types.Types.T_stmtContext = _inner;
            if (_ok && ((_i + (1 : stdgo.GoInt)) == (_list.length))) {
                _inner = _inner | ((4u32 : stdgo.go.types.Types.T_stmtContext));
            };
            _check._stmt(_inner, _s);
        };
    }
    @:keep
    static public function _simpleStmt( _check:stdgo.Ref<Checker>, _s:stdgo.go.ast.Ast.Stmt):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if (_s != null) {
            _check._stmt((0u32 : stdgo.go.types.Types.T_stmtContext), _s);
        };
    }
    @:keep
    static public function _usage( _check:stdgo.Ref<Checker>, _scope:stdgo.Ref<Scope>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _unused:stdgo.Slice<stdgo.Ref<Var>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>);
        for (_name => _elem in _scope._elems) {
            _elem = _resolve(_name?.__copy__(), _elem);
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_elem) : stdgo.Ref<Var>)) : stdgo.Ref<Var>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Var>), _1 : false };
                }, _v = __tmp__._0, __0 = __tmp__._1;
                if (((_v != null) && ((_v : Dynamic).__nil__ == null || !(_v : Dynamic).__nil__)) && !_v._used) {
                    _unused = (_unused.__append__(_v));
                };
            };
        };
        stdgo.sort.Sort.slice(stdgo.Go.toInterface(_unused), function(_i:stdgo.GoInt, _j:stdgo.GoInt):Bool {
            return _cmpPos(_unused[(_i : stdgo.GoInt)]._object._pos, _unused[(_j : stdgo.GoInt)]._object._pos) < (0 : stdgo.GoInt);
        });
        for (__1 => _v in _unused) {
            _check._softErrorf(stdgo.Go.asInterface(_v), (101 : stdgo.internal.types.errors.Errors.Code), ("%s declared and not used" : stdgo.GoString), stdgo.Go.toInterface(_v._object._name));
        };
        for (__10 => _scope in _scope._children) {
            if (!_scope._isFunc) {
                _check._usage(_scope);
            };
        };
    }
    @:keep
    static public function _funcBody( _check:stdgo.Ref<Checker>, _decl:stdgo.Ref<T_declInfo>, _name:stdgo.GoString, _sig:stdgo.Ref<Signature>, _body:stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>, _iota:stdgo.go.constant.Constant.Value):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            if (_check._conf.ignoreFuncBodies) {
                throw stdgo.Go.toInterface(("function body not ignored" : stdgo.GoString));
            };
            if (_check._conf.__Trace) {
                _check._trace(_body.pos(), ("-- %s: %s" : stdgo.GoString), stdgo.Go.toInterface(_name), stdgo.Go.toInterface(stdgo.Go.asInterface(_sig)));
            };
            _sig._scope._pos = _body.pos();
            _sig._scope._end = _body.end();
            {
                var _a0 = _check._environment;
                var _a1 = _check._indent;
                __deferstack__.unshift(() -> {
                    var a = function(_env:T_environment, _indent:stdgo.GoInt):Void {
                        _check._environment = _env?.__copy__();
                        _check._indent = _indent;
                    };
                    a(_a0?.__copy__(), _a1);
                });
            };
            _check._environment = ({ _decl : _decl, _scope : _sig._scope, _iota : _iota, _sig : _sig } : stdgo.go.types.Types.T_environment);
            _check._indent = (0 : stdgo.GoInt);
            _check._stmtList((0u32 : stdgo.go.types.Types.T_stmtContext), _body.list);
            if (_check._environment._hasLabel) {
                _check._labels(_body);
            };
            if ((_sig._results.len() > (0 : stdgo.GoInt)) && !_check._isTerminating(stdgo.Go.asInterface(_body), stdgo.Go.str()?.__copy__())) {
                _check._error(stdgo.Go.asInterface((_body.rbrace : T_atPos)), (102 : stdgo.internal.types.errors.Errors.Code), ("missing return" : stdgo.GoString));
            };
            _check._usage(_sig._scope);
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return;
        };
    }
    /**
        // collectParams declares the parameters of list in scope and returns the corresponding
        // variable list.
    **/
    @:keep
    static public function _collectParams( _check:stdgo.Ref<Checker>, _scope:stdgo.Ref<Scope>, _list:stdgo.Ref<stdgo.go.ast.Ast.FieldList>, _variadicOk:Bool):{ var _0 : stdgo.Slice<stdgo.Ref<Var>>; var _1 : Bool; } {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _params:stdgo.Slice<stdgo.Ref<Var>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>), _variadic:Bool = false;
        if (_list == null || (_list : Dynamic).__nil__) {
            return { _0 : _params, _1 : _variadic };
        };
        var __0:Bool = false, __1:Bool = false, _anonymous:Bool = __1, _named:Bool = __0;
        for (_i => _field in _list.list) {
            var _ftype:stdgo.go.ast.Ast.Expr = _field.type;
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_ftype) : stdgo.Ref<stdgo.go.ast.Ast.Ellipsis>)) : stdgo.Ref<stdgo.go.ast.Ast.Ellipsis>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.Ellipsis>), _1 : false };
                }, _t = __tmp__._0, __0 = __tmp__._1;
                if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                    _ftype = _t.elt;
                    if ((_variadicOk && (_i == (_list.list.length - (1 : stdgo.GoInt)))) && (_field.names.length <= (1 : stdgo.GoInt))) {
                        _variadic = true;
                    } else {
                        _check._softErrorf(stdgo.Go.asInterface(_t), (79 : stdgo.internal.types.errors.Errors.Code), ("can only use ... with final parameter in list" : stdgo.GoString));
                    };
                };
            };
            var _typ:stdgo.go.types.Types.Type_ = _check._varType(_ftype);
            if ((_field.names.length) > (0 : stdgo.GoInt)) {
                for (__17 => _name in _field.names) {
                    if (_name.name == (stdgo.Go.str())) {
                        _check._error(stdgo.Go.asInterface(_name), (-1 : stdgo.internal.types.errors.Errors.Code), ("anonymous parameter" : stdgo.GoString));
                    };
                    var _par = newParam(_name.pos(), _check._pkg, _name.name?.__copy__(), _typ);
                    _check._declare(_scope, _name, stdgo.Go.asInterface(_par), _scope._pos);
                    _params = (_params.__append__(_par));
                };
                _named = true;
            } else {
                var _par = newParam(_ftype.pos(), _check._pkg, stdgo.Go.str()?.__copy__(), _typ);
                _check._recordImplicit(stdgo.Go.asInterface(_field), stdgo.Go.asInterface(_par));
                _params = (_params.__append__(_par));
                _anonymous = true;
            };
        };
        if (_named && _anonymous) {
            _check._error(stdgo.Go.asInterface(_list), (-1 : stdgo.internal.types.errors.Errors.Code), ("list contains both named and anonymous parameters" : stdgo.GoString));
        };
        if (_variadic) {
            var _last = _params[((_params.length) - (1 : stdgo.GoInt) : stdgo.GoInt)];
            _last._object._typ = stdgo.Go.asInterface((stdgo.Go.setRef(({ _elem : _last._object._typ } : stdgo.go.types.Types.Slice_)) : stdgo.Ref<stdgo.go.types.Types.Slice_>));
            _check._recordTypeAndValue(_list.list[((_list.list.length) - (1 : stdgo.GoInt) : stdgo.GoInt)].type, (3 : stdgo.go.types.Types.T_operandMode), _last._object._typ, (null : stdgo.go.constant.Constant.Value));
        };
        return { _0 : _params, _1 : _variadic };
    }
    /**
        // funcType type-checks a function or method type.
    **/
    @:keep
    static public function _funcType( _check:stdgo.Ref<Checker>, _sig:stdgo.Ref<Signature>, _recvPar:stdgo.Ref<stdgo.go.ast.Ast.FieldList>, _ftyp:stdgo.Ref<stdgo.go.ast.Ast.FuncType>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            _check._openScope(stdgo.Go.asInterface(_ftyp), ("function" : stdgo.GoString));
            _check._pkg._scope._isFunc = true;
            _check._recordScope(stdgo.Go.asInterface(_ftyp), _check._pkg._scope);
            _sig._scope = _check._pkg._scope;
            __deferstack__.unshift(() -> _check._closeScope());
            if (((_recvPar != null) && ((_recvPar : Dynamic).__nil__ == null || !(_recvPar : Dynamic).__nil__)) && (_recvPar.list.length > (0 : stdgo.GoInt))) {
                var __tmp__ = _check._unpackRecv(_recvPar.list[(0 : stdgo.GoInt)].type, true), __56:Bool = __tmp__._0, _rname:stdgo.Ref<stdgo.go.ast.Ast.Ident> = __tmp__._1, _rparams:stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.Ident>> = __tmp__._2;
                if ((_rparams.length) > (0 : stdgo.GoInt)) {
                    var _tparams = _check._declareTypeParams((null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>), _rparams);
                    _sig._rparams = _bindTParams(_tparams);
                    for (_i => _p in _rparams) {
                        if (_p.name == (("_" : stdgo.GoString))) {
                            if (_check._recvTParamMap == null) {
                                _check._recvTParamMap = ({
                                    final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.ast.Ast.Ident>, stdgo.Ref<stdgo.go.types.Types.TypeParam>>();
                                    @:mergeBlock {};
                                    cast x;
                                } : stdgo.GoMap<stdgo.Ref<stdgo.go.ast.Ast.Ident>, stdgo.Ref<stdgo.go.types.Types.TypeParam>>);
                            };
                            _check._recvTParamMap[_p] = _tparams[(_i : stdgo.GoInt)];
                        };
                    };
                    var _recvTParams:stdgo.Slice<stdgo.Ref<TypeParam>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>);
                    if (_rname != null && ((_rname : Dynamic).__nil__ == null || !(_rname : Dynamic).__nil__)) {
                        {
                            var __tmp__ = try {
                                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_check._genericType(stdgo.Go.asInterface(_rname), (null : stdgo.Pointer<stdgo.GoString>))) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
                            } catch(_) {
                                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
                            }, _recv = __tmp__._0, __97 = __tmp__._1;
                            if (_recv != null && ((_recv : Dynamic).__nil__ == null || !(_recv : Dynamic).__nil__)) {
                                _recvTParams = _recv._check._environment._decl._tdecl.typeParams()._list();
                            };
                        };
                    };
                    if ((_tparams.length) == ((_recvTParams.length))) {
                        var _smap:stdgo.go.types.Types.T_substMap = _makeRenameMap(_recvTParams, _tparams);
                        for (_i => _tpar in _tparams) {
                            var _recvTPar = _recvTParams[(_i : stdgo.GoInt)];
                            _check._mono._recordCanon(_tpar, _recvTPar);
                            _tpar._bound = _check._subst(_tpar._obj._object._pos, _recvTPar._bound, _smap, null, _check._context());
                        };
                    } else if ((_tparams.length) < (_recvTParams.length)) {
                        var _got:stdgo.GoString = _measure((_tparams.length), ("type parameter" : stdgo.GoString))?.__copy__();
                        _check._errorf(stdgo.Go.asInterface(_recvPar), (31 : stdgo.internal.types.errors.Errors.Code), ("got %s, but receiver base type declares %d" : stdgo.GoString), stdgo.Go.toInterface(_got), stdgo.Go.toInterface((_recvTParams.length)));
                    };
                };
            };
            if (_ftyp.typeParams != null && ((_ftyp.typeParams : Dynamic).__nil__ == null || !(_ftyp.typeParams : Dynamic).__nil__)) {
                _check._collectTypeParams((stdgo.Go.setRef(_sig._tparams) : stdgo.Ref<stdgo.Ref<stdgo.go.types.Types.TypeParamList>>), _ftyp.typeParams);
                if (_recvPar != null && ((_recvPar : Dynamic).__nil__ == null || !(_recvPar : Dynamic).__nil__)) {
                    _check._error(stdgo.Go.asInterface(_ftyp.typeParams), (143 : stdgo.internal.types.errors.Errors.Code), ("methods cannot have type parameters" : stdgo.GoString));
                };
            };
            var _scope = newScope(_check._pkg._scope, _nopos, _nopos, ("function body (temp. scope)" : stdgo.GoString));
            var __tmp__ = _check._collectParams(_scope, _recvPar, false), _recvList:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>> = __tmp__._0, __194:Bool = __tmp__._1;
            var __tmp__ = _check._collectParams(_scope, _ftyp.params, true), _params:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>> = __tmp__._0, _variadic:Bool = __tmp__._1;
            var __tmp__ = _check._collectParams(_scope, _ftyp.results, false), _results:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>> = __tmp__._0, __211:Bool = __tmp__._1;
            _scope._squash(function(_obj:Object, _alt:Object):Void {
                _check._errorf(_obj, (10 : stdgo.internal.types.errors.Errors.Code), ("%s redeclared in this block" : stdgo.GoString), stdgo.Go.toInterface(_obj.name()));
                _check._reportAltDecl(_alt);
            });
            if (_recvPar != null && ((_recvPar : Dynamic).__nil__ == null || !(_recvPar : Dynamic).__nil__)) {
                var _recv:stdgo.Ref<Var> = (null : stdgo.Ref<stdgo.go.types.Types.Var>);
                {
                    var __switchIndex__ = -1;
                    var __run__ = true;
                    while (__run__) {
                        __run__ = false;
                        {
                            final __value__ = (_recvList.length);
                            if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (__value__ == (0 : stdgo.GoInt)))) {
                                _recv = newParam(_nopos, null, stdgo.Go.str()?.__copy__(), stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]));
                                break;
                                break;
                            } else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && (__value__ == (1 : stdgo.GoInt)))) {
                                _recv = _recvList[(0 : stdgo.GoInt)];
                                break;
                                break;
                            } else {
                                _check._error(stdgo.Go.asInterface(_recvList[((_recvList.length) - (1 : stdgo.GoInt) : stdgo.GoInt)]), (32 : stdgo.internal.types.errors.Errors.Code), ("method has multiple receivers" : stdgo.GoString));
                                @:fallthrough {
                                    __switchIndex__ = 2;
                                    __run__ = true;
                                    continue;
                                };
                            };
                        };
                        break;
                    };
                };
                _sig._recv = _recv;
                _check._later(function():Void {
                    var __tmp__ = _deref(_recv._object._typ), _rtyp:stdgo.go.types.Types.Type_ = __tmp__._0, __228:Bool = __tmp__._1;
                    if (stdgo.Go.toInterface(_rtyp) == (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                        return;
                    };
                    {
                        final __type__ = _rtyp;
                        {
                            var __bool__ = true;
                            while (__bool__) {
                                __bool__ = false;
                                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Named>))) {
                                    var t:stdgo.Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                                    if (((t.typeArgs() != null) && ((t.typeArgs() : Dynamic).__nil__ == null || !(t.typeArgs() : Dynamic).__nil__)) && (_sig.recvTypeParams() == null) || (_sig.recvTypeParams() : Dynamic).__nil__) {
                                        _check._errorf(stdgo.Go.asInterface(_recv), (32 : stdgo.internal.types.errors.Errors.Code), ("cannot define new methods on instantiated type %s" : stdgo.GoString), stdgo.Go.toInterface(_rtyp));
                                        break;
                                    };
                                    if (t._obj._object._pkg != (_check._pkg)) {
                                        _check._errorf(stdgo.Go.asInterface(_recv), (32 : stdgo.internal.types.errors.Errors.Code), ("cannot define new methods on non-local type %s" : stdgo.GoString), stdgo.Go.toInterface(_rtyp));
                                        break;
                                    };
                                    var _cause:stdgo.GoString = ("" : stdgo.GoString);
                                    {
                                        final __type__ = t._under();
                                        if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                                            var _u:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                                            if (_u._kind == ((18 : stdgo.go.types.Types.BasicKind))) {
                                                _cause = ("unsafe.Pointer" : stdgo.GoString);
                                            };
                                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Pointer_>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                                            var _u:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                                            _cause = ("pointer or interface type" : stdgo.GoString);
                                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeParam>))) {
                                            var _u:stdgo.Ref<stdgo.go.types.Types.TypeParam> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__().value;
                                            _unreachable();
                                        };
                                    };
                                    if (_cause != (stdgo.Go.str())) {
                                        _check._errorf(stdgo.Go.asInterface(_recv), (32 : stdgo.internal.types.errors.Errors.Code), ("invalid receiver type %s (%s)" : stdgo.GoString), stdgo.Go.toInterface(_rtyp), stdgo.Go.toInterface(_cause));
                                    };
                                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                                    var t:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                                    _check._errorf(stdgo.Go.asInterface(_recv), (32 : stdgo.internal.types.errors.Errors.Code), ("cannot define new methods on non-local type %s" : stdgo.GoString), stdgo.Go.toInterface(_rtyp));
                                } else {
                                    var t:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                                    _check._errorf(stdgo.Go.asInterface(_recv), (32 : stdgo.internal.types.errors.Errors.Code), ("invalid receiver type %s" : stdgo.GoString), stdgo.Go.toInterface(_recv._object._typ));
                                };
                                break;
                            };
                        };
                    };
                })._describef(stdgo.Go.asInterface(_recv), ("validate receiver %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_recv)));
            };
            _sig._params = newTuple(..._params.__toArray__());
            _sig._results = newTuple(..._results.__toArray__());
            _sig._variadic = _variadic;
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return;
        };
    }
    @:keep
    static public function _isTerminatingSwitch( _check:stdgo.Ref<Checker>, _body:stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>, _label:stdgo.GoString):Bool {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _hasDefault:Bool = false;
        for (__0 => _s in _body.list) {
            var _cc = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_s) : stdgo.Ref<stdgo.go.ast.Ast.CaseClause>)) : stdgo.Ref<stdgo.go.ast.Ast.CaseClause>);
            if (_cc.list == null) {
                _hasDefault = true;
            };
            if (!_check._isTerminatingList(_cc.body, stdgo.Go.str()?.__copy__()) || _hasBreakList(_cc.body, _label?.__copy__(), true)) {
                return false;
            };
        };
        return _hasDefault;
    }
    @:keep
    static public function _isTerminatingList( _check:stdgo.Ref<Checker>, _list:stdgo.Slice<stdgo.go.ast.Ast.Stmt>, _label:stdgo.GoString):Bool {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        {
            var _i:stdgo.GoInt = (_list.length) - (1 : stdgo.GoInt);
            stdgo.Go.cfor(_i >= (0 : stdgo.GoInt), _i--, {
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_list[(_i : stdgo.GoInt)]) : stdgo.Ref<stdgo.go.ast.Ast.EmptyStmt>)) : stdgo.Ref<stdgo.go.ast.Ast.EmptyStmt>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.EmptyStmt>), _1 : false };
                    }, __0 = __tmp__._0, _ok = __tmp__._1;
                    if (!_ok) {
                        return _check._isTerminating(_list[(_i : stdgo.GoInt)], _label?.__copy__());
                    };
                };
            });
        };
        return false;
    }
    /**
        // isTerminating reports if s is a terminating statement.
        // If s is labeled, label is the label name; otherwise s
        // is "".
    **/
    @:keep
    static public function _isTerminating( _check:stdgo.Ref<Checker>, _s:stdgo.go.ast.Ast.Stmt, _label:stdgo.GoString):Bool {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        {
            final __type__ = _s;
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BadStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.DeclStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.EmptyStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SendStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IncDecStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.AssignStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.GoStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.DeferStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.RangeStmt>))) {
                var _s:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>))) {
                var _s:stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__().value;
                return _check._isTerminating(_s.stmt, _s.label.name?.__copy__());
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ExprStmt>))) {
                var _s:stdgo.Ref<stdgo.go.ast.Ast.ExprStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_unparen(_s.x)) : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>)) : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>), _1 : false };
                    }, _call = __tmp__._0, _ok = __tmp__._1;
                    if (_ok && (_check._environment._isPanic[_call] ?? false)) {
                        return true;
                    };
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ReturnStmt>))) {
                var _s:stdgo.Ref<stdgo.go.ast.Ast.ReturnStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ReturnStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ReturnStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ReturnStmt>) : __type__.__underlying__().value;
                return true;
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>))) {
                var _s:stdgo.Ref<stdgo.go.ast.Ast.BranchStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__().value;
                if ((_s.tok == (73 : stdgo.go.token.Token.Token)) || (_s.tok == (69 : stdgo.go.token.Token.Token))) {
                    return true;
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>))) {
                var _s:stdgo.Ref<stdgo.go.ast.Ast.BlockStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__().value;
                return _check._isTerminatingList(_s.list, stdgo.Go.str()?.__copy__());
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IfStmt>))) {
                var _s:stdgo.Ref<stdgo.go.ast.Ast.IfStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IfStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__().value;
                if (((_s.else_ != null) && _check._isTerminating(stdgo.Go.asInterface(_s.body), stdgo.Go.str()?.__copy__())) && _check._isTerminating(_s.else_, stdgo.Go.str()?.__copy__())) {
                    return true;
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SwitchStmt>))) {
                var _s:stdgo.Ref<stdgo.go.ast.Ast.SwitchStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__().value;
                return _check._isTerminatingSwitch(_s.body, _label?.__copy__());
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.TypeSwitchStmt>))) {
                var _s:stdgo.Ref<stdgo.go.ast.Ast.TypeSwitchStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__().value;
                return _check._isTerminatingSwitch(_s.body, _label?.__copy__());
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SelectStmt>))) {
                var _s:stdgo.Ref<stdgo.go.ast.Ast.SelectStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__().value;
                for (__56 => _s in _s.body.list) {
                    var _cc = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_s) : stdgo.Ref<stdgo.go.ast.Ast.CommClause>)) : stdgo.Ref<stdgo.go.ast.Ast.CommClause>);
                    if (!_check._isTerminatingList(_cc.body, stdgo.Go.str()?.__copy__()) || _hasBreakList(_cc.body, _label?.__copy__(), true)) {
                        return false;
                    };
                };
                return true;
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ForStmt>))) {
                var _s:stdgo.Ref<stdgo.go.ast.Ast.ForStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ForStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__().value;
                if ((_s.cond == null) && !_hasBreak(stdgo.Go.asInterface(_s.body), _label?.__copy__(), true)) {
                    return true;
                };
            } else {
                var _s:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
                _unreachable();
            };
        };
        return false;
    }
    @:keep
    static public function _errorUnusedPkg( _check:stdgo.Ref<Checker>, _obj:stdgo.Ref<PkgName>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _path:stdgo.GoString = _obj._imported._path?.__copy__();
        var _elem:stdgo.GoString = _path?.__copy__();
        {
            var _i:stdgo.GoInt = stdgo.strings.Strings.lastIndex(_elem?.__copy__(), ("/" : stdgo.GoString));
            if (_i >= (0 : stdgo.GoInt)) {
                _elem = (_elem.__slice__(_i + (1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
            };
        };
        if (((_obj._object._name == stdgo.Go.str()) || (_obj._object._name == ("." : stdgo.GoString))) || (_obj._object._name == _elem)) {
            _check._softErrorf(stdgo.Go.asInterface(_obj), (8 : stdgo.internal.types.errors.Errors.Code), ("%q imported and not used" : stdgo.GoString), stdgo.Go.toInterface(_path));
        } else {
            _check._softErrorf(stdgo.Go.asInterface(_obj), (8 : stdgo.internal.types.errors.Errors.Code), ("%q imported as %s and not used" : stdgo.GoString), stdgo.Go.toInterface(_path), stdgo.Go.toInterface(_obj._object._name));
        };
    }
    /**
        // unusedImports checks for unused imports.
    **/
    @:keep
    static public function _unusedImports( _check:stdgo.Ref<Checker>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if (_check._conf.ignoreFuncBodies) {
            return;
        };
        for (__16 => _obj in _check._imports) {
            if (!_obj._used && (_obj._object._name != ("_" : stdgo.GoString))) {
                _check._errorUnusedPkg(_obj);
            };
        };
    }
    /**
        // packageObjects typechecks all package objects, but not function bodies.
    **/
    @:keep
    static public function _packageObjects( _check:stdgo.Ref<Checker>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _objList = new stdgo.Slice<stdgo.go.types.Types.Object>((_check._objMap.length : stdgo.GoInt).toBasic(), 0);
        var _i:stdgo.GoInt = (0 : stdgo.GoInt);
        for (_obj => _ in _check._objMap) {
            _objList[(_i : stdgo.GoInt)] = _obj;
            _i++;
        };
        stdgo.sort.Sort.sort(stdgo.Go.asInterface((_objList : T_inSourceOrder)));
        for (__16 => _obj in _objList) {
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<TypeName>)) : stdgo.Ref<TypeName>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeName>), _1 : false };
                }, _obj = __tmp__._0, __17 = __tmp__._1;
                if (((_obj != null) && ((_obj : Dynamic).__nil__ == null || !(_obj : Dynamic).__nil__)) && (_obj._object._typ != null)) {
                    _check._collectMethods(_obj);
                };
            };
        };
        var _aliasList:stdgo.Slice<stdgo.Ref<TypeName>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeName>>);
        var _othersList:stdgo.Slice<Object> = (null : stdgo.Slice<stdgo.go.types.Types.Object>);
        for (__26 => _obj in _objList) {
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<TypeName>)) : stdgo.Ref<TypeName>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeName>), _1 : false };
                }, _tname = __tmp__._0, __27 = __tmp__._1;
                if (_tname != null && ((_tname : Dynamic).__nil__ == null || !(_tname : Dynamic).__nil__)) {
                    if ((_check._objMap[stdgo.Go.asInterface(_tname)] ?? (null : stdgo.Ref<stdgo.go.types.Types.T_declInfo>))._tdecl.assign.isValid()) {
                        _aliasList = (_aliasList.__append__(_tname));
                    } else {
                        _check._objDecl(_obj, null);
                    };
                } else {
                    _othersList = (_othersList.__append__(_obj));
                };
            };
        };
        for (__44 => _obj in _aliasList) {
            _check._objDecl(stdgo.Go.asInterface(_obj), null);
        };
        for (__53 => _obj in _othersList) {
            _check._objDecl(_obj, null);
        };
        _check._methods = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>>);
    }
    /**
        // resolveBaseTypeName returns the non-alias base type name for typ, and whether
        // there was a pointer indirection to get to it. The base type name must be declared
        // in package scope, and there can be at most one pointer indirection. If no such type
        // name exists, the returned base is nil.
    **/
    @:keep
    static public function _resolveBaseTypeName( _check:stdgo.Ref<Checker>, _seenPtr:Bool, _typ:stdgo.go.ast.Ast.Expr, _fileScopes:stdgo.Slice<stdgo.Ref<Scope>>):{ var _0 : Bool; var _1 : stdgo.Ref<TypeName>; } {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _ptr:Bool = false, _base:stdgo.Ref<TypeName> = (null : stdgo.Ref<stdgo.go.types.Types.TypeName>);
        _ptr = _seenPtr;
        var _seen:stdgo.GoMap<stdgo.Ref<TypeName>, Bool> = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, Bool>);
        while (true) {
            _typ = _unparen(_typ);
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_typ) : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>)) : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>), _1 : false };
                }, _pexpr = __tmp__._0, __0 = __tmp__._1;
                if (_pexpr != null && ((_pexpr : Dynamic).__nil__ == null || !(_pexpr : Dynamic).__nil__)) {
                    if (_ptr) {
                        return { _0 : false, _1 : null };
                    };
                    _ptr = true;
                    _typ = _unparen(_pexpr.x);
                };
            };
            var _name:stdgo.GoString = ("" : stdgo.GoString);
            {
                final __type__ = _typ;
                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.Ident>))) {
                    var _typ:stdgo.Ref<stdgo.go.ast.Ast.Ident> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__().value;
                    _name = _typ.name?.__copy__();
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>))) {
                    var _typ:stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_typ.x) : stdgo.Ref<stdgo.go.ast.Ast.Ident>)) : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _1 : false };
                        }, _ident = __tmp__._0, __1 = __tmp__._1;
                        if (((_ident != null) && ((_ident : Dynamic).__nil__ == null || !(_ident : Dynamic).__nil__)) && (_ident.name == ("C" : stdgo.GoString))) {
                            var _obj:Object = (null : stdgo.go.types.Types.Object);
                            for (__2 => _scope in _fileScopes) {
                                if (_scope.contains(_ident.pos())) {
                                    _obj = _scope.lookup(_ident.name?.__copy__());
                                };
                            };
                            {
                                var __tmp__ = try {
                                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<PkgName>)) : stdgo.Ref<PkgName>), _1 : true };
                                } catch(_) {
                                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.PkgName>), _1 : false };
                                }, _pname = __tmp__._0, __3 = __tmp__._1;
                                if (_pname != null && ((_pname : Dynamic).__nil__ == null || !(_pname : Dynamic).__nil__)) {
                                    if (_pname._imported._cgo) {
                                        _name = ("_Ctype_" : stdgo.GoString) + _typ.sel.name?.__copy__()?.__copy__();
                                    };
                                };
                            };
                        };
                    };
                    if (_name == (stdgo.Go.str())) {
                        return { _0 : false, _1 : null };
                    };
                } else {
                    var _typ:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                    return { _0 : false, _1 : null };
                };
            };
            var _obj:stdgo.go.types.Types.Object = _check._pkg._scope.lookup(_name?.__copy__());
            if (_obj == null) {
                return { _0 : false, _1 : null };
            };
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<TypeName>)) : stdgo.Ref<TypeName>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeName>), _1 : false };
            }, _tname = __tmp__._0, __12 = __tmp__._1;
            if (_tname == null || (_tname : Dynamic).__nil__) {
                return { _0 : false, _1 : null };
            };
            if ((_seen[_tname] ?? false)) {
                return { _0 : false, _1 : null };
            };
            var _tdecl = (_check._objMap[stdgo.Go.asInterface(_tname)] ?? (null : stdgo.Ref<stdgo.go.types.Types.T_declInfo>))._tdecl;
            if (!_tdecl.assign.isValid()) {
                return { _0 : _ptr, _1 : _tname };
            };
            _typ = _tdecl.type;
            if (_seen == null) {
                _seen = ({
                    final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, Bool>();
                    @:mergeBlock {};
                    cast x;
                } : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, Bool>);
            };
            _seen[_tname] = true;
        };
    }
    /**
        // unpackRecv unpacks a receiver type and returns its components: ptr indicates whether
        // rtyp is a pointer receiver, rname is the receiver type name, and tparams are its
        // type parameters, if any. The type parameters are only unpacked if unpackParams is
        // set. If rname is nil, the receiver is unusable (i.e., the source has a bug which we
        // cannot easily work around).
    **/
    @:keep
    static public function _unpackRecv( _check:stdgo.Ref<Checker>, _rtyp:stdgo.go.ast.Ast.Expr, _unpackParams:Bool):{ var _0 : Bool; var _1 : stdgo.Ref<stdgo.go.ast.Ast.Ident>; var _2 : stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.Ident>>; } {
        stdgo.internal.Macro.controlFlow({
            @:recv var _check:stdgo.Ref<Checker> = _check;
            var _ptr:Bool = false, _rname:stdgo.Ref<stdgo.go.ast.Ast.Ident> = (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _tparams:stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.Ident>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.Ident>>);
            @:label("L") while (true) {
                {
                    final __type__ = _rtyp;
                    {
                        var __bool__ = true;
                        while (__bool__) {
                            __bool__ = false;
                            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>))) {
                                var _t:stdgo.Ref<stdgo.go.ast.Ast.ParenExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__().value;
                                _rtyp = _t.x;
                            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>))) {
                                var _t:stdgo.Ref<stdgo.go.ast.Ast.StarExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__().value;
                                _ptr = true;
                                _rtyp = _t.x;
                            } else {
                                var _t:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                                @:jump("L") break;
                            };
                            break;
                        };
                    };
                };
            };
            {
                final __type__ = _rtyp;
                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IndexExpr>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IndexListExpr>))) {
                    var _ix = stdgo.go.internal.typeparams.Typeparams.unpackIndexExpr(_rtyp);
                    _rtyp = _ix.indexListExpr.x;
                    if (_unpackParams) {
                        for (__0 => _arg in _ix.indexListExpr.indices) {
                            var _par:stdgo.Ref<stdgo.go.ast.Ast.Ident> = (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>);
                            {
                                final __type__ = _arg;
                                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.Ident>))) {
                                    var _arg:stdgo.Ref<stdgo.go.ast.Ast.Ident> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__().value;
                                    _par = _arg;
                                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BadExpr>))) {
                                    var _arg:stdgo.Ref<stdgo.go.ast.Ast.BadExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BadExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BadExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BadExpr>) : __type__.__underlying__().value;
                                } else if (__type__ == null) {
                                    var _arg:stdgo.AnyInterface = __type__ == null ? (null : stdgo.AnyInterface) : cast __type__;
                                    _check._error(_ix.orig, (-1 : stdgo.internal.types.errors.Errors.Code), ("parameterized receiver contains nil parameters" : stdgo.GoString));
                                } else {
                                    var _arg:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                                    _check._errorf(_arg, (131 : stdgo.internal.types.errors.Errors.Code), ("receiver type parameter %s must be an identifier" : stdgo.GoString), stdgo.Go.toInterface(_arg));
                                };
                            };
                            if (_par == null || (_par : Dynamic).__nil__) {
                                _par = (stdgo.Go.setRef(({ namePos : _arg.pos(), name : ("_" : stdgo.GoString) } : stdgo.go.ast.Ast.Ident)) : stdgo.Ref<stdgo.go.ast.Ast.Ident>);
                            };
                            _tparams = (_tparams.__append__(_par));
                        };
                    };
                };
            };
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_rtyp) : stdgo.Ref<stdgo.go.ast.Ast.Ident>)) : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _1 : false };
                }, _name = __tmp__._0, __17 = __tmp__._1;
                if (_name != null && ((_name : Dynamic).__nil__ == null || !(_name : Dynamic).__nil__)) {
                    _rname = _name;
                };
            };
            return { _0 : _ptr, _1 : _rname, _2 : _tparams };
        });
        throw "controlFlow did not return";
    }
    /**
        // collectObjects collects all file and package objects and inserts them
        // into their respective scopes. It also performs imports and associates
        // methods with receiver base type names.
    **/
    @:keep
    static public function _collectObjects( _check:stdgo.Ref<Checker>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _pkg = _check._pkg;
        var _pkgImports:stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Package>, Bool> = ({
            final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.types.Types.Package>, Bool>();
            @:mergeBlock {};
            cast x;
        } : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Package>, Bool>);
        for (__8 => _imp in _pkg._imports) {
            _pkgImports[_imp] = true;
        };
        {};
        var _methods:stdgo.Slice<T__collectObjects_39___localname___methodInfo> = (null : stdgo.Slice<stdgo.go.types.Types.T__collectObjects_39___localname___methodInfo>);
        var _fileScopes:stdgo.Slice<stdgo.Ref<Scope>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Scope>>);
        for (_fileNo => _file in _check._files) {
            _check._recordDef(_file.name, (null : stdgo.go.types.Types.Object));
            var __0:stdgo.go.token.Token.Pos = _file.pos(), __1:stdgo.go.token.Token.Pos = _file.end(), _end:stdgo.go.token.Token.Pos = __1, _pos:stdgo.go.token.Token.Pos = __0;
            {
                var _f = _check._fset.file(_file.pos());
                if (_f != null && ((_f : Dynamic).__nil__ == null || !(_f : Dynamic).__nil__)) {
                    {
                        final __tmp__0 = (_f.base() : stdgo.go.token.Token.Pos);
                        final __tmp__1 = (_f.base() + _f.size() : stdgo.go.token.Token.Pos);
                        _pos = __tmp__0;
                        _end = __tmp__1;
                    };
                };
            };
            var _fileScope = newScope(_pkg._scope, _pos, _end, _check._filename(_fileNo)?.__copy__());
            _fileScopes = (_fileScopes.__append__(_fileScope));
            _check._recordScope(stdgo.Go.asInterface(_file), _fileScope);
            var _fileDir:stdgo.GoString = _dir(_check._fset.position(_file.name.pos()).filename?.__copy__())?.__copy__();
            _check._walkDecls(_file.decls, function(_d:T_decl):Void {
                {
                    final __type__ = _d;
                    if (stdgo.Go.typeEquals((__type__ : T_importDecl))) {
                        var _d:stdgo.go.types.Types.T_importDecl = __type__ == null ? ({} : stdgo.go.types.Types.T_importDecl) : __type__.__underlying__() == null ? ({} : stdgo.go.types.Types.T_importDecl) : __type__ == null ? ({} : stdgo.go.types.Types.T_importDecl) : __type__.__underlying__().value;
                        if (_d._spec.path.value == (stdgo.Go.str())) {
                            return;
                        };
                        var __tmp__ = _validatedImportPath(_d._spec.path.value?.__copy__()), _path:stdgo.GoString = __tmp__._0, _err:stdgo.Error = __tmp__._1;
                        if (_err != null) {
                            _check._errorf(stdgo.Go.asInterface(_d._spec.path), (5 : stdgo.internal.types.errors.Errors.Code), ("invalid import path (%s)" : stdgo.GoString), stdgo.Go.toInterface(_err));
                            return;
                        };
                        var _imp = _check._importPackage(stdgo.Go.asInterface(_d._spec.path), _path?.__copy__(), _fileDir?.__copy__());
                        if (_imp == null || (_imp : Dynamic).__nil__) {
                            return;
                        };
                        var _name:stdgo.GoString = _imp._name?.__copy__();
                        if (_d._spec.name != null && ((_d._spec.name : Dynamic).__nil__ == null || !(_d._spec.name : Dynamic).__nil__)) {
                            _name = _d._spec.name.name?.__copy__();
                            if (_path == (("C" : stdgo.GoString))) {
                                _check._error(stdgo.Go.asInterface(_d._spec.name), (7 : stdgo.internal.types.errors.Errors.Code), ("cannot rename import \"C\"" : stdgo.GoString));
                                return;
                            };
                        };
                        if (_name == (("init" : stdgo.GoString))) {
                            _check._error(stdgo.Go.asInterface(_d._spec), (39 : stdgo.internal.types.errors.Errors.Code), ("cannot import package as init - init must be a func" : stdgo.GoString));
                            return;
                        };
                        if (!(_pkgImports[_imp] ?? false)) {
                            _pkgImports[_imp] = true;
                            _pkg._imports = (_pkg._imports.__append__(_imp));
                        };
                        var _pkgName = newPkgName(_d._spec.pos(), _pkg, _name?.__copy__(), _imp);
                        if (_d._spec.name != null && ((_d._spec.name : Dynamic).__nil__ == null || !(_d._spec.name : Dynamic).__nil__)) {
                            _check._recordDef(_d._spec.name, stdgo.Go.asInterface(_pkgName));
                        } else {
                            _check._recordImplicit(stdgo.Go.asInterface(_d._spec), stdgo.Go.asInterface(_pkgName));
                        };
                        if (_imp._fake) {
                            _pkgName._used = true;
                        };
                        _check._imports = (_check._imports.__append__(_pkgName));
                        if (_name == (("." : stdgo.GoString))) {
                            if (_check._dotImportMap == null) {
                                _check._dotImportMap = ({
                                    final x = new stdgo.GoMap.GoObjectMap<stdgo.go.types.Types.T_dotImportKey, stdgo.Ref<stdgo.go.types.Types.PkgName>>();
                                    x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.T_dotImportKey", [], stdgo.internal.reflect.Reflect.GoType.structType([{ name : "_scope", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.refType({ get : () -> stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Scope", [], stdgo.internal.reflect.Reflect.GoType.structType([{ name : "_parent", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.refType({ get : () -> stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Scope", [], stdgo.internal.reflect.Reflect.GoType.invalidType, false, { get : () -> null }) }) }, optional : false }, { name : "_children", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.sliceType({ get : () -> stdgo.internal.reflect.Reflect.GoType.refType({ get : () -> stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Scope", [], stdgo.internal.reflect.Reflect.GoType.invalidType, false, { get : () -> null }) }) }) }, optional : false }, { name : "_number", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.basic(int_kind) }, optional : false }, { name : "_elems", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.mapType({ get : () -> stdgo.internal.reflect.Reflect.GoType.basic(string_kind) }, { get : () -> stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Object", [], stdgo.internal.reflect.Reflect.GoType.named("Object", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }) }) }, optional : false }, { name : "_pos", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.token.Token.Pos", [], stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.token.Token.Pos", [], stdgo.internal.reflect.Reflect.GoType.invalidType, false, { get : () -> null }), false, { get : () -> null }) }, optional : false }, { name : "_end", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.token.Token.Pos", [], stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.token.Token.Pos", [], stdgo.internal.reflect.Reflect.GoType.invalidType, false, { get : () -> null }), false, { get : () -> null }) }, optional : false }, { name : "_comment", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.basic(string_kind) }, optional : false }, { name : "_isFunc", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind) }, optional : false }]), false, { get : () -> null }) }) }, optional : false }, { name : "_name", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.basic(string_kind) }, optional : false }]), false, { get : () -> null }));
                                    x.__defaultValue__ = () -> (null : stdgo.Ref<stdgo.go.types.Types.PkgName>);
                                    @:mergeBlock {};
                                    cast x;
                                } : stdgo.GoMap<stdgo.go.types.Types.T_dotImportKey, stdgo.Ref<stdgo.go.types.Types.PkgName>>);
                            };
                            for (_name => _obj in _imp._scope._elems) {
                                if (stdgo.go.token.Token.isExported(_name?.__copy__())) {
                                    {
                                        var _alt:stdgo.go.types.Types.Object = _fileScope.lookup(_name?.__copy__());
                                        if (_alt != null) {
                                            _check._errorf(stdgo.Go.asInterface(_d._spec.name), (10 : stdgo.internal.types.errors.Errors.Code), ("%s redeclared in this block" : stdgo.GoString), stdgo.Go.toInterface(_alt.name()));
                                            _check._reportAltDecl(_alt);
                                        } else {
                                            _fileScope._insert(_name?.__copy__(), _obj);
                                            _check._dotImportMap[(new stdgo.go.types.Types.T_dotImportKey(_fileScope, _name?.__copy__()) : stdgo.go.types.Types.T_dotImportKey)] = _pkgName;
                                        };
                                    };
                                };
                            };
                        } else {
                            _check._declare(_fileScope, null, stdgo.Go.asInterface(_pkgName), _nopos);
                        };
                    } else if (stdgo.Go.typeEquals((__type__ : T_constDecl))) {
                        var _d:stdgo.go.types.Types.T_constDecl = __type__ == null ? ({} : stdgo.go.types.Types.T_constDecl) : __type__.__underlying__() == null ? ({} : stdgo.go.types.Types.T_constDecl) : __type__ == null ? ({} : stdgo.go.types.Types.T_constDecl) : __type__.__underlying__().value;
                        for (_i => _name in _d._spec.names) {
                            var _obj = newConst(_name.pos(), _pkg, _name.name?.__copy__(), (null : stdgo.go.types.Types.Type_), stdgo.go.constant.Constant.makeInt64((_d._iota : stdgo.GoInt64)));
                            var _init:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
                            if (_i < (_d._init.length)) {
                                _init = _d._init[(_i : stdgo.GoInt)];
                            };
                            var _d = (stdgo.Go.setRef(({ _file : _fileScope, _vtyp : _d._typ, _init : _init, _inherited : _d._inherited } : stdgo.go.types.Types.T_declInfo)) : stdgo.Ref<stdgo.go.types.Types.T_declInfo>);
                            _check._declarePkgObj(_name, stdgo.Go.asInterface(_obj), _d);
                        };
                    } else if (stdgo.Go.typeEquals((__type__ : T_varDecl))) {
                        var _d:stdgo.go.types.Types.T_varDecl = __type__ == null ? ({} : stdgo.go.types.Types.T_varDecl) : __type__.__underlying__() == null ? ({} : stdgo.go.types.Types.T_varDecl) : __type__ == null ? ({} : stdgo.go.types.Types.T_varDecl) : __type__.__underlying__().value;
                        var _lhs = new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>((_d._spec.names.length : stdgo.GoInt).toBasic(), 0);
                        var _d1:stdgo.Ref<T_declInfo> = (null : stdgo.Ref<stdgo.go.types.Types.T_declInfo>);
                        if ((_d._spec.values.length) == ((1 : stdgo.GoInt))) {
                            _d1 = (stdgo.Go.setRef(({ _file : _fileScope, _lhs : _lhs, _vtyp : _d._spec.type, _init : _d._spec.values[(0 : stdgo.GoInt)] } : stdgo.go.types.Types.T_declInfo)) : stdgo.Ref<stdgo.go.types.Types.T_declInfo>);
                        };
                        for (_i => _name in _d._spec.names) {
                            var _obj = newVar(_name.pos(), _pkg, _name.name?.__copy__(), (null : stdgo.go.types.Types.Type_));
                            _lhs[(_i : stdgo.GoInt)] = _obj;
                            var _di = _d1;
                            if (_di == null || (_di : Dynamic).__nil__) {
                                var _init:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
                                if (_i < (_d._spec.values.length)) {
                                    _init = _d._spec.values[(_i : stdgo.GoInt)];
                                };
                                _di = (stdgo.Go.setRef(({ _file : _fileScope, _vtyp : _d._spec.type, _init : _init } : stdgo.go.types.Types.T_declInfo)) : stdgo.Ref<stdgo.go.types.Types.T_declInfo>);
                            };
                            _check._declarePkgObj(_name, stdgo.Go.asInterface(_obj), _di);
                        };
                    } else if (stdgo.Go.typeEquals((__type__ : T_typeDecl))) {
                        var _d:stdgo.go.types.Types.T_typeDecl = __type__ == null ? ({} : stdgo.go.types.Types.T_typeDecl) : __type__.__underlying__() == null ? ({} : stdgo.go.types.Types.T_typeDecl) : __type__ == null ? ({} : stdgo.go.types.Types.T_typeDecl) : __type__.__underlying__().value;
                        (_d._spec.typeParams.numFields() != (0 : stdgo.GoInt)) && _check._verifyVersionf(stdgo.Go.asInterface(_d._spec.typeParams.list[(0 : stdgo.GoInt)]), _go1_18?.__copy__(), ("type parameter" : stdgo.GoString));
                        var _obj = newTypeName(_d._spec.name.pos(), _pkg, _d._spec.name.name?.__copy__(), (null : stdgo.go.types.Types.Type_));
                        _check._declarePkgObj(_d._spec.name, stdgo.Go.asInterface(_obj), (stdgo.Go.setRef(({ _file : _fileScope, _tdecl : _d._spec } : stdgo.go.types.Types.T_declInfo)) : stdgo.Ref<stdgo.go.types.Types.T_declInfo>));
                    } else if (stdgo.Go.typeEquals((__type__ : T_funcDecl))) {
                        var _d:stdgo.go.types.Types.T_funcDecl = __type__ == null ? ({} : stdgo.go.types.Types.T_funcDecl) : __type__.__underlying__() == null ? ({} : stdgo.go.types.Types.T_funcDecl) : __type__ == null ? ({} : stdgo.go.types.Types.T_funcDecl) : __type__.__underlying__().value;
                        var _name:stdgo.GoString = _d._decl.name.name?.__copy__();
                        var _obj = newFunc(_d._decl.name.pos(), _pkg, _name?.__copy__(), null);
                        var _hasTParamError:Bool = false;
                        if (_d._decl.recv.numFields() == ((0 : stdgo.GoInt))) {
                            if (_d._decl.recv != null && ((_d._decl.recv : Dynamic).__nil__ == null || !(_d._decl.recv : Dynamic).__nil__)) {
                                _check._error(stdgo.Go.asInterface(_d._decl.recv), (31 : stdgo.internal.types.errors.Errors.Code), ("method has no receiver" : stdgo.GoString));
                            };
                            if ((_name == ("init" : stdgo.GoString)) || ((_name == ("main" : stdgo.GoString)) && (_check._pkg._name == ("main" : stdgo.GoString)))) {
                                var _code:stdgo.internal.types.errors.Errors.Code = (39 : stdgo.internal.types.errors.Errors.Code);
                                if (_name == (("main" : stdgo.GoString))) {
                                    _code = (40 : stdgo.internal.types.errors.Errors.Code);
                                };
                                if (_d._decl.type.typeParams.numFields() != ((0 : stdgo.GoInt))) {
                                    _check._softErrorf(stdgo.Go.asInterface(_d._decl.type.typeParams.list[(0 : stdgo.GoInt)]), _code, ("func %s must have no type parameters" : stdgo.GoString), stdgo.Go.toInterface(_name));
                                    _hasTParamError = true;
                                };
                                {
                                    var _t = _d._decl.type;
                                    if ((_t.params.numFields() != (0 : stdgo.GoInt)) || ((_t.results != null) && ((_t.results : Dynamic).__nil__ == null || !(_t.results : Dynamic).__nil__))) {
                                        _check._softErrorf(stdgo.Go.asInterface(_d._decl.name), _code, ("func %s must have no arguments and no return values" : stdgo.GoString), stdgo.Go.toInterface(_name));
                                    };
                                };
                            };
                            if (_name == (("init" : stdgo.GoString))) {
                                _obj._object._parent = _pkg._scope;
                                _check._recordDef(_d._decl.name, stdgo.Go.asInterface(_obj));
                                if (_d._decl.body == null || (_d._decl.body : Dynamic).__nil__) {
                                    _check._softErrorf(stdgo.Go.asInterface(_obj), (37 : stdgo.internal.types.errors.Errors.Code), ("missing function body" : stdgo.GoString));
                                };
                            } else {
                                _check._declare(_pkg._scope, _d._decl.name, stdgo.Go.asInterface(_obj), _nopos);
                            };
                        } else {
                            var __tmp__ = _check._unpackRecv(_d._decl.recv.list[(0 : stdgo.GoInt)].type, false), _ptr:Bool = __tmp__._0, _recv:stdgo.Ref<stdgo.go.ast.Ast.Ident> = __tmp__._1, __289:stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.Ident>> = __tmp__._2;
                            if (((_recv != null) && ((_recv : Dynamic).__nil__ == null || !(_recv : Dynamic).__nil__)) && (_name != ("_" : stdgo.GoString))) {
                                _methods = (_methods.__append__((new stdgo.go.types.Types.T__collectObjects_39___localname___methodInfo(_obj, _ptr, _recv) : stdgo.go.types.Types.T__collectObjects_39___localname___methodInfo)));
                            };
                            _check._recordDef(_d._decl.name, stdgo.Go.asInterface(_obj));
                        };
                        ((_d._decl.type.typeParams.numFields() != (0 : stdgo.GoInt)) && !_hasTParamError) && _check._verifyVersionf(stdgo.Go.asInterface(_d._decl.type.typeParams.list[(0 : stdgo.GoInt)]), _go1_18?.__copy__(), ("type parameter" : stdgo.GoString));
                        var _info = (stdgo.Go.setRef(({ _file : _fileScope, _fdecl : _d._decl } : stdgo.go.types.Types.T_declInfo)) : stdgo.Ref<stdgo.go.types.Types.T_declInfo>);
                        _check._objMap[stdgo.Go.asInterface(_obj)] = _info;
                        _obj._setOrder((_check._objMap.length : stdgo.GoUInt32));
                    };
                };
            });
        };
        for (__81 => _scope in _fileScopes) {
            for (_name => _obj in _scope._elems) {
                {
                    var _alt:stdgo.go.types.Types.Object = _pkg._scope.lookup(_name?.__copy__());
                    if (_alt != null) {
                        _obj = _resolve(_name?.__copy__(), _obj);
                        {
                            var __tmp__ = try {
                                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<PkgName>)) : stdgo.Ref<PkgName>), _1 : true };
                            } catch(_) {
                                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.PkgName>), _1 : false };
                            }, _pkg = __tmp__._0, _ok = __tmp__._1;
                            if (_ok) {
                                _check._errorf(_alt, (10 : stdgo.internal.types.errors.Errors.Code), ("%s already declared through import of %s" : stdgo.GoString), stdgo.Go.toInterface(_alt.name()), stdgo.Go.toInterface(stdgo.Go.asInterface(_pkg.imported())));
                                _check._reportAltDecl(stdgo.Go.asInterface(_pkg));
                            } else {
                                _check._errorf(_alt, (10 : stdgo.internal.types.errors.Errors.Code), ("%s already declared through dot-import of %s" : stdgo.GoString), stdgo.Go.toInterface(_alt.name()), stdgo.Go.toInterface(stdgo.Go.asInterface(_obj.pkg())));
                                _check._reportAltDecl(_obj);
                            };
                        };
                    };
                };
            };
        };
        if (_methods == null) {
            return;
        };
        _check._methods = ({
            final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>>();
            @:mergeBlock {};
            cast x;
        } : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>>);
        for (_i => _ in _methods) {
            var _m = (stdgo.Go.setRef(_methods[(_i : stdgo.GoInt)]) : stdgo.Ref<stdgo.go.types.Types.T__collectObjects_39___localname___methodInfo>);
            var __tmp__ = _check._resolveBaseTypeName(_m._ptr, stdgo.Go.asInterface(_m._recv), _fileScopes), _ptr:Bool = __tmp__._0, _base:stdgo.Ref<stdgo.go.types.Types.TypeName> = __tmp__._1;
            if (_base != null && ((_base : Dynamic).__nil__ == null || !(_base : Dynamic).__nil__)) {
                _m._obj._hasPtrRecv_ = _ptr;
                _check._methods[_base] = ((_check._methods[_base] ?? (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>)).__append__(_m._obj));
            };
        };
    }
    @:keep
    static public function _importPackage( _check:stdgo.Ref<Checker>, _at:T_positioner, _path:stdgo.GoString, _dir:stdgo.GoString):stdgo.Ref<Package> {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _key:stdgo.go.types.Types.T_importKey = (new stdgo.go.types.Types.T_importKey(_path?.__copy__(), _dir?.__copy__()) : stdgo.go.types.Types.T_importKey);
        var _imp = (_check._impMap[_key] ?? (null : stdgo.Ref<stdgo.go.types.Types.Package>));
        if (_imp != null && ((_imp : Dynamic).__nil__ == null || !(_imp : Dynamic).__nil__)) {
            return _imp;
        };
        if ((_path == ("C" : stdgo.GoString)) && (_check._conf.fakeImportC || _check._conf._go115UsesCgo)) {
            _imp = newPackage(("C" : stdgo.GoString), ("C" : stdgo.GoString));
            _imp._fake = true;
            _imp._cgo = _check._conf._go115UsesCgo;
        } else {
            var _err:stdgo.Error = (null : stdgo.Error);
            {
                var _importer:stdgo.go.types.Types.Importer = _check._conf.importer;
                if (_importer == null) {
                    _err = stdgo.fmt.Fmt.errorf(("Config.Importer not installed" : stdgo.GoString));
                } else {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_importer) : ImporterFrom)) : ImporterFrom), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.go.types.Types.ImporterFrom), _1 : false };
                    }, _importerFrom = __tmp__._0, _ok = __tmp__._1;
                    if (_ok) {
                        {
                            var __tmp__ = _importerFrom.importFrom(_path?.__copy__(), _dir?.__copy__(), (0 : stdgo.go.types.Types.ImportMode));
                            _imp = __tmp__._0;
                            _err = __tmp__._1;
                        };
                        if ((_imp == null) || (_imp : Dynamic).__nil__ && (_err == null)) {
                            _err = stdgo.fmt.Fmt.errorf(("Config.Importer.ImportFrom(%s, %s, 0) returned nil but no error" : stdgo.GoString), stdgo.Go.toInterface(_path), stdgo.Go.toInterface(_dir));
                        };
                    } else {
                        {
                            var __tmp__ = _importer.import_(_path?.__copy__());
                            _imp = __tmp__._0;
                            _err = __tmp__._1;
                        };
                        if ((_imp == null) || (_imp : Dynamic).__nil__ && (_err == null)) {
                            _err = stdgo.fmt.Fmt.errorf(("Config.Importer.Import(%s) returned nil but no error" : stdgo.GoString), stdgo.Go.toInterface(_path));
                        };
                    };
                };
            };
            if (((_err == null) && ((_imp != null) && ((_imp : Dynamic).__nil__ == null || !(_imp : Dynamic).__nil__))) && ((_imp._name == ("_" : stdgo.GoString)) || (_imp._name == stdgo.Go.str()))) {
                _err = stdgo.fmt.Fmt.errorf(("invalid package name: %q" : stdgo.GoString), stdgo.Go.toInterface(_imp._name));
                _imp = null;
            };
            if (_err != null) {
                _check._errorf(_at, (6 : stdgo.internal.types.errors.Errors.Code), ("could not import %s (%s)" : stdgo.GoString), stdgo.Go.toInterface(_path), stdgo.Go.toInterface(_err));
                if (_imp == null || (_imp : Dynamic).__nil__) {
                    var _name:stdgo.GoString = _path?.__copy__();
                    {
                        var _i:stdgo.GoInt = (_name.length);
                        if ((_i > (0 : stdgo.GoInt)) && (_name[(_i - (1 : stdgo.GoInt) : stdgo.GoInt)] == (47 : stdgo.GoUInt8))) {
                            _name = (_name.__slice__(0, _i - (1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                        };
                    };
                    {
                        var _i:stdgo.GoInt = stdgo.strings.Strings.lastIndex(_name?.__copy__(), ("/" : stdgo.GoString));
                        if (_i >= (0 : stdgo.GoInt)) {
                            _name = (_name.__slice__(_i + (1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                        };
                    };
                    _imp = newPackage(_path?.__copy__(), _name?.__copy__());
                };
                _imp._fake = true;
            };
        };
        if (_imp._complete || _imp._fake) {
            _check._impMap[_key] = _imp;
            if (_check._pkgPathMap != null) {
                _check._markImports(_imp);
            };
            return _imp;
        };
        return null;
    }
    /**
        // filename returns a filename suitable for debugging output.
    **/
    @:keep
    static public function _filename( _check:stdgo.Ref<Checker>, _fileNo:stdgo.GoInt):stdgo.GoString {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _file = _check._files[(_fileNo : stdgo.GoInt)];
        {
            var _pos:stdgo.go.token.Token.Pos = _file.pos();
            if (_pos.isValid()) {
                return _check._fset.file(_pos).name()?.__copy__();
            };
        };
        return stdgo.fmt.Fmt.sprintf(("file[%d]" : stdgo.GoString), stdgo.Go.toInterface(_fileNo))?.__copy__();
    }
    /**
        // declarePkgObj declares obj in the package scope, records its ident -> obj mapping,
        // and updates check.objMap. The object must not be a function or method.
    **/
    @:keep
    static public function _declarePkgObj( _check:stdgo.Ref<Checker>, _ident:stdgo.Ref<stdgo.go.ast.Ast.Ident>, _obj:Object, _d:stdgo.Ref<T_declInfo>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _assert(_ident.name == (_obj.name()));
        if (_ident.name == (("init" : stdgo.GoString))) {
            _check._error(stdgo.Go.asInterface(_ident), (39 : stdgo.internal.types.errors.Errors.Code), ("cannot declare init - must be func" : stdgo.GoString));
            return;
        };
        if ((_ident.name == ("main" : stdgo.GoString)) && (_check._pkg._name == ("main" : stdgo.GoString))) {
            _check._error(stdgo.Go.asInterface(_ident), (40 : stdgo.internal.types.errors.Errors.Code), ("cannot declare main - must be func" : stdgo.GoString));
            return;
        };
        _check._declare(_check._pkg._scope, _ident, _obj, _nopos);
        _check._objMap[_obj] = _d;
        _obj._setOrder((_check._objMap.length : stdgo.GoUInt32));
    }
    /**
        // arityMatch checks that the lhs and rhs of a const or var decl
        // have the appropriate number of names and init exprs. For const
        // decls, init is the value spec providing the init exprs; for
        // var decls, init is nil (the init exprs are in s in this case).
    **/
    @:keep
    static public function _arityMatch( _check:stdgo.Ref<Checker>, _s:stdgo.Ref<stdgo.go.ast.Ast.ValueSpec>, _init:stdgo.Ref<stdgo.go.ast.Ast.ValueSpec>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _l:stdgo.GoInt = (_s.names.length);
        var _r:stdgo.GoInt = (_s.values.length);
        if (_init != null && ((_init : Dynamic).__nil__ == null || !(_init : Dynamic).__nil__)) {
            _r = (_init.values.length);
        };
        {};
        if ((_init == null) || (_init : Dynamic).__nil__ && (_r == (0 : stdgo.GoInt))) {
            if (_s.type == null) {
                _check._error(stdgo.Go.asInterface(_s), (17 : stdgo.internal.types.errors.Errors.Code), ("missing type or init expr" : stdgo.GoString));
            };
        } else if (_l < _r) {
            if (_l < (_s.values.length)) {
                var _n:stdgo.go.ast.Ast.Expr = _s.values[(_l : stdgo.GoInt)];
                _check._errorf(_n, (17 : stdgo.internal.types.errors.Errors.Code), ("extra init expr %s" : stdgo.GoString), stdgo.Go.toInterface(_n));
            } else {
                _check._errorf(stdgo.Go.asInterface(_s), (17 : stdgo.internal.types.errors.Errors.Code), ("extra init expr at %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_check._fset.position(_init.pos()))));
            };
        } else if ((_l > _r) && (((_init != null) && ((_init : Dynamic).__nil__ == null || !(_init : Dynamic).__nil__)) || (_r != (1 : stdgo.GoInt)))) {
            var _n = _s.names[(_r : stdgo.GoInt)];
            _check._errorf(stdgo.Go.asInterface(_n), (17 : stdgo.internal.types.errors.Errors.Code), ("missing init expr for %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_n)));
        };
    }
    /**
        // context returns the type-checker context.
    **/
    @:keep
    static public function _context( _check:stdgo.Ref<Checker>):stdgo.Ref<Context> {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if (_check._ctxt == null || (_check._ctxt : Dynamic).__nil__) {
            _check._ctxt = newContext();
        };
        return _check._ctxt;
    }
    /**
        // newNamedInstance creates a new named instance for the given origin and type
        // arguments, recording pos as the position of its synthetic object (for error
        // reporting).
        //
        // If set, expanding is the named type instance currently being expanded, that
        // led to the creation of this instance.
    **/
    @:keep
    static public function _newNamedInstance( _check:stdgo.Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _orig:stdgo.Ref<Named>, _targs:stdgo.Slice<Type_>, _expanding:stdgo.Ref<Named>):stdgo.Ref<Named> {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _assert((_targs.length) > (0 : stdgo.GoInt));
        var _obj = newTypeName(_pos, _orig._obj._object._pkg, _orig._obj._object._name?.__copy__(), (null : stdgo.go.types.Types.Type_));
        var _inst = (stdgo.Go.setRef(({ _orig : _orig, _targs : _newTypeList(_targs) } : stdgo.go.types.Types.T_instance)) : stdgo.Ref<stdgo.go.types.Types.T_instance>);
        if (((_expanding != null) && ((_expanding : Dynamic).__nil__ == null || !(_expanding : Dynamic).__nil__)) && (_expanding._check._environment._decl._tdecl.name.obj()._object._pkg == _obj._object._pkg)) {
            _inst._ctxt = _expanding._inst._ctxt;
        };
        var _typ = (stdgo.Go.setRef(({ _check : _check, _obj : _obj, _inst : _inst } : stdgo.go.types.Types.Named)) : stdgo.Ref<stdgo.go.types.Types.Named>);
        _obj._object._typ = stdgo.Go.asInterface(_typ);
        if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
            _check._needsCleanup(stdgo.Go.asInterface(_typ));
        };
        return _typ;
    }
    /**
        // newNamed is like NewNamed but with a *Checker receiver and additional orig argument.
    **/
    @:keep
    static public function _newNamed( _check:stdgo.Ref<Checker>, _obj:stdgo.Ref<TypeName>, _underlying:Type_, _methods:stdgo.Slice<stdgo.Ref<Func>>):stdgo.Ref<Named> {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _typ = (stdgo.Go.setRef(({ _check : _check, _obj : _obj, _fromRHS : _underlying, _underlying : _underlying, _methods : _methods } : stdgo.go.types.Types.Named)) : stdgo.Ref<stdgo.go.types.Types.Named>);
        if (_obj._object._typ == null) {
            _obj._object._typ = stdgo.Go.asInterface(_typ);
        };
        if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
            _check._needsCleanup(stdgo.Go.asInterface(_typ));
        };
        return _typ;
    }
    @:keep
    static public function _reportInstanceLoop( _check:stdgo.Ref<Checker>, _v:stdgo.GoInt):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _stack:stdgo.Slice<stdgo.GoInt> = (null : stdgo.Slice<stdgo.GoInt>);
        var _seen = new stdgo.Slice<Bool>((_check._mono._vertices.length : stdgo.GoInt).toBasic(), 0);
        while (!_seen[(_v : stdgo.GoInt)]) {
            _stack = (_stack.__append__(_v));
            _seen[(_v : stdgo.GoInt)] = true;
            _v = _check._mono._edges[(_check._mono._vertices[(_v : stdgo.GoInt)]._pre : stdgo.GoInt)]._src;
        };
        while (_stack[(0 : stdgo.GoInt)] != (_v)) {
            _stack = (_stack.__slice__((1 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoInt>);
        };
        var _obj0 = _check._mono._vertices[(_v : stdgo.GoInt)]._obj;
        _check._error(stdgo.Go.asInterface(_obj0), (140 : stdgo.internal.types.errors.Errors.Code), ("instantiation cycle:" : stdgo.GoString));
        var _qf:stdgo.go.types.Types.Qualifier = relativeTo(_check._pkg);
        for (__48 => _v in _stack) {
            var _edge:stdgo.go.types.Types.T_monoEdge = _check._mono._edges[(_check._mono._vertices[(_v : stdgo.GoInt)]._pre : stdgo.GoInt)];
            var _obj = _check._mono._vertices[(_edge._dst : stdgo.GoInt)]._obj;
            {
                final __type__ = _obj.type();
                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Named>))) {
                    _check._errorf(stdgo.Go.asInterface((_edge._pos : T_atPos)), (140 : stdgo.internal.types.errors.Errors.Code), ("\t%s implicitly parameterized by %s" : stdgo.GoString), stdgo.Go.toInterface(_obj.name()), stdgo.Go.toInterface(typeString(_edge._typ, _qf)));
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeParam>))) {
                    _check._errorf(stdgo.Go.asInterface((_edge._pos : T_atPos)), (140 : stdgo.internal.types.errors.Errors.Code), ("\t%s instantiated as %s" : stdgo.GoString), stdgo.Go.toInterface(_obj.name()), stdgo.Go.toInterface(typeString(_edge._typ, _qf)));
                } else {
                    throw stdgo.Go.toInterface(("unexpected type" : stdgo.GoString));
                };
            };
        };
    }
    @:keep
    static public function _monomorph( _check:stdgo.Ref<Checker>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _again:Bool = true;
        while (_again) {
            _again = false;
            for (_i => _edge in _check._mono._edges) {
                var _src = (stdgo.Go.setRef(_check._mono._vertices[(_edge._src : stdgo.GoInt)]) : stdgo.Ref<stdgo.go.types.Types.T_monoVertex>);
                var _dst = (stdgo.Go.setRef(_check._mono._vertices[(_edge._dst : stdgo.GoInt)]) : stdgo.Ref<stdgo.go.types.Types.T_monoVertex>);
                var _w:stdgo.GoInt = _src._weight + _edge._weight;
                if (_w <= _dst._weight) {
                    continue;
                };
                _dst._pre = _i;
                _dst._len = _src._len + (1 : stdgo.GoInt);
                if (_dst._len == ((_check._mono._vertices.length))) {
                    _check._reportInstanceLoop(_edge._dst);
                    return;
                };
                _dst._weight = _w;
                _again = true;
            };
        };
    }
    /**
        // newAssertableTo reports whether a value of type V can be asserted to have type T.
        // It also implements behavior for interfaces that currently are only permitted
        // in constraint position (we have not yet defined that behavior in the spec).
        // The underlying type of V must be an interface.
        // If the result is false and cause is not nil, *cause is set to the error cause.
    **/
    @:keep
    static public function _newAssertableTo( _check:stdgo.Ref<Checker>, _pos:stdgo.go.token.Token.Pos, v:Type_, t:Type_, _cause:stdgo.Pointer<stdgo.GoString>):Bool {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if (isInterface(t)) {
            return true;
        };
        return _check._implements(_pos, t, v, false, _cause);
    }
    /**
        // assertableTo reports whether a value of type V can be asserted to have type T.
        // The receiver may be nil if assertableTo is invoked through an exported API call
        // (such as AssertableTo), i.e., when all methods have been type-checked.
        // The underlying type of V must be an interface.
        // If the result is false and cause is not nil, *cause describes the error.
        // TODO(gri) replace calls to this function with calls to newAssertableTo.
    **/
    @:keep
    static public function _assertableTo( _check:stdgo.Ref<Checker>, v:Type_, t:Type_, _cause:stdgo.Pointer<stdgo.GoString>):Bool {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if (isInterface(t)) {
            return true;
        };
        var __tmp__ = _check._missingMethod(t, v, false, identical, _cause), _m:stdgo.Ref<stdgo.go.types.Types.Func> = __tmp__._0, __8:Bool = __tmp__._1;
        return _m == null || (_m : Dynamic).__nil__;
    }
    /**
        // funcString returns a string of the form name + signature for f.
        // check may be nil.
    **/
    @:keep
    static public function _funcString( _check:stdgo.Ref<Checker>, _f:stdgo.Ref<Func>, _pkgInfo:Bool):stdgo.GoString {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _buf = stdgo.bytes.Bytes.newBufferString(_f._object._name?.__copy__());
        var _qf:Qualifier = (null : stdgo.go.types.Types.Qualifier);
        if (((_check != null) && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) && !_pkgInfo) {
            _qf = _check._qualifier;
        };
        var _w = _newTypeWriter(_buf, _qf);
        _w._pkgInfo = _pkgInfo;
        _w._paramNames = false;
        _w._signature((stdgo.Go.typeAssert((stdgo.Go.toInterface(_f._object._typ) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>));
        return (_buf.string() : stdgo.GoString)?.__copy__();
    }
    /**
        // check may be nil.
    **/
    @:keep
    static public function _interfacePtrError( _check:stdgo.Ref<Checker>, t:Type_):stdgo.GoString {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _assert(_isInterfacePtr(t));
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(t)) : stdgo.Ref<Pointer_>)) : stdgo.Ref<Pointer_>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>), _1 : false };
            }, _p = __tmp__._0, __0 = __tmp__._1;
            if (_isTypeParam(_p._base)) {
                return _check._sprintf(("type %s is pointer to type parameter, not type parameter" : stdgo.GoString), stdgo.Go.toInterface(t))?.__copy__();
            };
        };
        return _check._sprintf(("type %s is pointer to interface, not interface" : stdgo.GoString), stdgo.Go.toInterface(t))?.__copy__();
    }
    /**
        // missingMethod is like MissingMethod but accepts a *Checker as receiver,
        // a comparator equivalent for type comparison, and a *string for error causes.
        // The receiver may be nil if missingMethod is invoked through an exported
        // API call (such as MissingMethod), i.e., when all methods have been type-
        // checked.
        // The underlying type of T must be an interface; T (rather than its under-
        // lying type) is used for better error messages (reported through *cause).
        // The comparator is used to compare signatures.
        // If a method is missing and cause is not nil, *cause describes the error.
    **/
    @:keep
    static public function _missingMethod( _check:stdgo.Ref<Checker>, v:Type_, t:Type_, _static:Bool, _equivalent:(_x:Type_, _y:Type_) -> Bool, _cause:stdgo.Pointer<stdgo.GoString>):{ var _0 : stdgo.Ref<Func>; var _1 : Bool; } {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _method:stdgo.Ref<Func> = (null : stdgo.Ref<stdgo.go.types.Types.Func>), _wrongType:Bool = false;
        var _methods = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(t)) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>)._typeSet()._methods;
        if ((_methods.length) == ((0 : stdgo.GoInt))) {
            return { _0 : null, _1 : false };
        };
        {};
        var _state:stdgo.GoInt = (0 : stdgo.GoInt);
        var _m:stdgo.Ref<Func> = (null : stdgo.Ref<stdgo.go.types.Types.Func>);
        var _f:stdgo.Ref<Func> = (null : stdgo.Ref<stdgo.go.types.Types.Func>);
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(v)) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Interface>), _1 : false };
            }, _u = __tmp__._0, __8 = __tmp__._1;
            if (_u != null && ((_u : Dynamic).__nil__ == null || !(_u : Dynamic).__nil__)) {
                var _tset = _u._typeSet();
                for (__key__ => __value__ in _methods) {
                    _m = __value__;
                    {
                        var __tmp__ = _tset.lookupMethod(_m._object._pkg, _m._object._name?.__copy__(), false);
                        _f = __tmp__._1;
                    };
                    if (_f == null || (_f : Dynamic).__nil__) {
                        if (!_static) {
                            continue;
                        };
                        _state = (1 : stdgo.GoInt);
                        break;
                    };
                    if (!_equivalent(_f._object._typ, _m._object._typ)) {
                        _state = (3 : stdgo.GoInt);
                        break;
                    };
                };
            } else {
                for (__key__ => __value__ in _methods) {
                    _m = __value__;
                    var __tmp__ = _lookupFieldOrMethodImpl(v, false, _m._object._pkg, _m._object._name?.__copy__(), false), _obj:stdgo.go.types.Types.Object = __tmp__._0, _index:stdgo.Slice<stdgo.GoInt> = __tmp__._1, _indirect:Bool = __tmp__._2;
                    if (_obj == null) {
                        if (_index != null) {
                            _state = (4 : stdgo.GoInt);
                        } else if (_indirect) {
                            _state = (5 : stdgo.GoInt);
                        } else {
                            _state = (1 : stdgo.GoInt);
                            {
                                var __tmp__ = _lookupFieldOrMethodImpl(v, false, _m._object._pkg, _m._object._name?.__copy__(), true);
                                _obj = __tmp__._0;
                            };
                            {
                                var __tmp__ = try {
                                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<Func>)) : stdgo.Ref<Func>), _1 : true };
                                } catch(_) {
                                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Func>), _1 : false };
                                };
                                _f = __tmp__._0;
                            };
                            if (_f != null && ((_f : Dynamic).__nil__ == null || !(_f : Dynamic).__nil__)) {
                                _state = (2 : stdgo.GoInt);
                            };
                        };
                        break;
                    };
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<Func>)) : stdgo.Ref<Func>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Func>), _1 : false };
                        };
                        _f = __tmp__._0;
                    };
                    if (_f == null || (_f : Dynamic).__nil__) {
                        _state = (6 : stdgo.GoInt);
                        break;
                    };
                    if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
                        _check._objDecl(stdgo.Go.asInterface(_f), null);
                    };
                    if (!_equivalent(_f._object._typ, _m._object._typ)) {
                        _state = (3 : stdgo.GoInt);
                        break;
                    };
                };
            };
        };
        if (_state == ((0 : stdgo.GoInt))) {
            return { _0 : null, _1 : false };
        };
        if (_cause != null) {
            if (_f != null && ((_f : Dynamic).__nil__ == null || !(_f : Dynamic).__nil__)) {
                if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
                    _check._objDecl(stdgo.Go.asInterface(_f), null);
                };
            };
            {
                final __value__ = _state;
                if (__value__ == ((1 : stdgo.GoInt))) {
                    if (_isInterfacePtr(v)) {
                        _cause.value = ("(" : stdgo.GoString) + _check._interfacePtrError(v)?.__copy__() + (")" : stdgo.GoString)?.__copy__()?.__copy__();
                    } else if (_isInterfacePtr(t)) {
                        _cause.value = ("(" : stdgo.GoString) + _check._interfacePtrError(t)?.__copy__() + (")" : stdgo.GoString)?.__copy__()?.__copy__();
                    } else {
                        _cause.value = _check._sprintf(("(missing method %s)" : stdgo.GoString), stdgo.Go.toInterface(_m.name()))?.__copy__();
                    };
                } else if (__value__ == ((2 : stdgo.GoInt))) {
                    var __0:stdgo.GoString = _check._funcString(_f, false)?.__copy__(), __1:stdgo.GoString = _check._funcString(_m, false)?.__copy__(), _ms:stdgo.GoString = __1, _fs:stdgo.GoString = __0;
                    _cause.value = _check._sprintf(("(missing method %s)\n\t\thave %s\n\t\twant %s" : stdgo.GoString), stdgo.Go.toInterface(_m.name()), stdgo.Go.toInterface(_fs), stdgo.Go.toInterface(_ms))?.__copy__();
                } else if (__value__ == ((3 : stdgo.GoInt))) {
                    var __0:stdgo.GoString = _check._funcString(_f, false)?.__copy__(), __1:stdgo.GoString = _check._funcString(_m, false)?.__copy__(), _ms:stdgo.GoString = __1, _fs:stdgo.GoString = __0;
                    if (_fs == (_ms)) {
                        {
                            final __tmp__0 = _check._funcString(_f, true)?.__copy__();
                            final __tmp__1 = _check._funcString(_m, true)?.__copy__();
                            _fs = __tmp__0;
                            _ms = __tmp__1;
                        };
                    };
                    _cause.value = _check._sprintf(("(wrong type for method %s)\n\t\thave %s\n\t\twant %s" : stdgo.GoString), stdgo.Go.toInterface(_m.name()), stdgo.Go.toInterface(_fs), stdgo.Go.toInterface(_ms))?.__copy__();
                } else if (__value__ == ((4 : stdgo.GoInt))) {
                    _cause.value = _check._sprintf(("(ambiguous selector %s.%s)" : stdgo.GoString), stdgo.Go.toInterface(v), stdgo.Go.toInterface(_m.name()))?.__copy__();
                } else if (__value__ == ((5 : stdgo.GoInt))) {
                    _cause.value = _check._sprintf(("(method %s has pointer receiver)" : stdgo.GoString), stdgo.Go.toInterface(_m.name()))?.__copy__();
                } else if (__value__ == ((6 : stdgo.GoInt))) {
                    _cause.value = _check._sprintf(("(%s.%s is a field, not a method)" : stdgo.GoString), stdgo.Go.toInterface(v), stdgo.Go.toInterface(_m.name()))?.__copy__();
                } else {
                    _unreachable();
                };
            };
        };
        return { _0 : _m, _1 : (_state == (3 : stdgo.GoInt)) || (_state == (5 : stdgo.GoInt)) };
    }
    /**
        // blockBranches processes a block's statement list and returns the set of outgoing forward jumps.
        // all is the scope of all declared labels, parent the set of labels declared in the immediately
        // enclosing block, and lstmt is the labeled statement this block is associated with (or nil).
    **/
    @:keep
    static public function _blockBranches( _check:stdgo.Ref<Checker>, _all:stdgo.Ref<Scope>, _parent:stdgo.Ref<T_block>, _lstmt:stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>, _list:stdgo.Slice<stdgo.go.ast.Ast.Stmt>):stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>> {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _b = (stdgo.Go.setRef(({ _parent : _parent, _lstmt : _lstmt } : stdgo.go.types.Types.T_block)) : stdgo.Ref<stdgo.go.types.Types.T_block>);
        var __0:stdgo.go.token.Token.Pos = ((0 : stdgo.GoInt) : stdgo.go.token.Token.Pos), __1:stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>>), __2:stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>>), _badJumps:stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>> = __2, _fwdJumps:stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>> = __1, _varDeclPos:stdgo.go.token.Token.Pos = __0;
        var _recordVarDecl:stdgo.go.token.Token.Pos -> Void = function(_pos:stdgo.go.token.Token.Pos):Void {
            _varDeclPos = _pos;
            _badJumps = ((_badJumps.__slice__(0, (0 : stdgo.GoInt)) : stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>>).__append__(..._fwdJumps.__toArray__()));
        };
        var _jumpsOverVarDecl = function(_jmp:stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>):Bool {
            if (_varDeclPos.isValid()) {
                for (__0 => _bad in _badJumps) {
                    if (_jmp == (_bad)) {
                        return true;
                    };
                };
            };
            return false;
        };
        var _blockBranches = function(_lstmt:stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>, _list:stdgo.Slice<stdgo.go.ast.Ast.Stmt>):Void {
            _fwdJumps = (_fwdJumps.__append__(..._check._blockBranches(_all, _b, _lstmt, _list).__toArray__()));
        };
        var _stmtBranches:stdgo.go.ast.Ast.Stmt -> Void = null;
        _stmtBranches = function(_s:stdgo.go.ast.Ast.Stmt):Void {
            {
                final __type__ = _s;
                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.DeclStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.DeclStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.DeclStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.DeclStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.DeclStmt>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_s.decl) : stdgo.Ref<stdgo.go.ast.Ast.GenDecl>)) : stdgo.Ref<stdgo.go.ast.Ast.GenDecl>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.GenDecl>), _1 : false };
                        }, _d = __tmp__._0, __0 = __tmp__._1;
                        if (((_d != null) && ((_d : Dynamic).__nil__ == null || !(_d : Dynamic).__nil__)) && (_d.tok == (85 : stdgo.go.token.Token.Token))) {
                            _recordVarDecl(_d.pos());
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__().value;
                    {
                        var _name:stdgo.GoString = _s.label.name?.__copy__();
                        if (_name != (("_" : stdgo.GoString))) {
                            var _lbl = newLabel(_s.label.pos(), _check._pkg, _name?.__copy__());
                            {
                                var _alt:stdgo.go.types.Types.Object = _all.insert(stdgo.Go.asInterface(_lbl));
                                if (_alt != null) {
                                    _check._softErrorf(stdgo.Go.asInterface(_lbl), (120 : stdgo.internal.types.errors.Errors.Code), ("label %s already declared" : stdgo.GoString), stdgo.Go.toInterface(_name));
                                    _check._reportAltDecl(_alt);
                                } else {
                                    _b._insert(_s);
                                    _check._recordDef(_s.label, stdgo.Go.asInterface(_lbl));
                                };
                            };
                            var _i:stdgo.GoInt = (0 : stdgo.GoInt);
                            for (__33 => _jmp in _fwdJumps) {
                                if (_jmp.label.name == (_name)) {
                                    _lbl._used = true;
                                    _check._recordUse(_jmp.label, stdgo.Go.asInterface(_lbl));
                                    if (_jumpsOverVarDecl(_jmp)) {
                                        _check._softErrorf(stdgo.Go.asInterface(_jmp.label), (123 : stdgo.internal.types.errors.Errors.Code), ("goto %s jumps over variable declaration at line %d" : stdgo.GoString), stdgo.Go.toInterface(_name), stdgo.Go.toInterface(_check._fset.position(_varDeclPos).line));
                                    };
                                } else {
                                    _fwdJumps[(_i : stdgo.GoInt)] = _jmp;
                                    _i++;
                                };
                            };
                            _fwdJumps = (_fwdJumps.__slice__(0, _i) : stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>>);
                            _lstmt = _s;
                        };
                    };
                    _stmtBranches(_s.stmt);
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.BranchStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__().value;
                    if (_s.label == null || (_s.label : Dynamic).__nil__) {
                        return;
                    };
                    var _name:stdgo.GoString = _s.label.name?.__copy__();
                    {
                        final __value__ = _s.tok;
                        if (__value__ == ((61 : stdgo.go.token.Token.Token))) {
                            var _valid:Bool = false;
                            {
                                var _t = _b._enclosingTarget(_name?.__copy__());
                                if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                                    {
                                        final __type__ = _t.stmt;
                                        if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SwitchStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.TypeSwitchStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SelectStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ForStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.RangeStmt>))) {
                                            _valid = true;
                                        };
                                    };
                                };
                            };
                            if (!_valid) {
                                _check._errorf(stdgo.Go.asInterface(_s.label), (121 : stdgo.internal.types.errors.Errors.Code), ("invalid break label %s" : stdgo.GoString), stdgo.Go.toInterface(_name));
                                return;
                            };
                        } else if (__value__ == ((65 : stdgo.go.token.Token.Token))) {
                            var _valid:Bool = false;
                            {
                                var _t = _b._enclosingTarget(_name?.__copy__());
                                if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                                    {
                                        final __type__ = _t.stmt;
                                        if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ForStmt>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.RangeStmt>))) {
                                            _valid = true;
                                        };
                                    };
                                };
                            };
                            if (!_valid) {
                                _check._errorf(stdgo.Go.asInterface(_s.label), (121 : stdgo.internal.types.errors.Errors.Code), ("invalid continue label %s" : stdgo.GoString), stdgo.Go.toInterface(_name));
                                return;
                            };
                        } else if (__value__ == ((73 : stdgo.go.token.Token.Token))) {
                            if (_b._gotoTarget(_name?.__copy__()) == null || (_b._gotoTarget(_name?.__copy__()) : Dynamic).__nil__) {
                                _fwdJumps = (_fwdJumps.__append__(_s));
                                return;
                            };
                        } else {
                            _check._errorf(stdgo.Go.asInterface(_s), (-1 : stdgo.internal.types.errors.Errors.Code), ("branch statement: %s %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_s.tok)), stdgo.Go.toInterface(_name));
                            return;
                        };
                    };
                    var _obj:stdgo.go.types.Types.Object = _all.lookup(_name?.__copy__());
                    (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<Label>)) : stdgo.Ref<Label>)._used = true;
                    _check._recordUse(_s.label, _obj);
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.AssignStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.AssignStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__().value;
                    if (_s.tok == ((47 : stdgo.go.token.Token.Token))) {
                        _recordVarDecl(_s.pos());
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.BlockStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__().value;
                    _blockBranches(_lstmt, _s.list);
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IfStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.IfStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IfStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__().value;
                    _stmtBranches(stdgo.Go.asInterface(_s.body));
                    if (_s.else_ != null) {
                        _stmtBranches(_s.else_);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.CaseClause>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.CaseClause> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CaseClause>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CaseClause>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CaseClause>) : __type__.__underlying__().value;
                    _blockBranches(null, _s.body);
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SwitchStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.SwitchStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__().value;
                    _stmtBranches(stdgo.Go.asInterface(_s.body));
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.TypeSwitchStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.TypeSwitchStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__().value;
                    _stmtBranches(stdgo.Go.asInterface(_s.body));
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.CommClause>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.CommClause> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CommClause>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CommClause>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CommClause>) : __type__.__underlying__().value;
                    _blockBranches(null, _s.body);
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SelectStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.SelectStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__().value;
                    _stmtBranches(stdgo.Go.asInterface(_s.body));
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ForStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.ForStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ForStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__().value;
                    _stmtBranches(stdgo.Go.asInterface(_s.body));
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.RangeStmt>))) {
                    var _s:stdgo.Ref<stdgo.go.ast.Ast.RangeStmt> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__.__underlying__().value;
                    _stmtBranches(stdgo.Go.asInterface(_s.body));
                };
            };
        };
        for (__0 => _s in _list) {
            _stmtBranches(_s);
        };
        return _fwdJumps;
    }
    /**
        // labels checks correct label use in body.
    **/
    @:keep
    static public function _labels( _check:stdgo.Ref<Checker>, _body:stdgo.Ref<stdgo.go.ast.Ast.BlockStmt>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _all = newScope(null, _body.pos(), _body.end(), ("label" : stdgo.GoString));
        var _fwdJumps = _check._blockBranches(_all, null, null, _body.list);
        for (__8 => _jmp in _fwdJumps) {
            var _msg:stdgo.GoString = ("" : stdgo.GoString);
            var _code:Code = ((0 : stdgo.GoInt) : stdgo.internal.types.errors.Errors.Code);
            var _name:stdgo.GoString = _jmp.label.name?.__copy__();
            {
                var _alt:stdgo.go.types.Types.Object = _all.lookup(_name?.__copy__());
                if (_alt != null) {
                    _msg = ("goto %s jumps into block" : stdgo.GoString);
                    (stdgo.Go.typeAssert((stdgo.Go.toInterface(_alt) : stdgo.Ref<Label>)) : stdgo.Ref<Label>)._used = true;
                    _code = (124 : stdgo.internal.types.errors.Errors.Code);
                } else {
                    _msg = ("label %s not declared" : stdgo.GoString);
                    _code = (119 : stdgo.internal.types.errors.Errors.Code);
                };
            };
            _check._errorf(stdgo.Go.asInterface(_jmp.label), _code, _msg?.__copy__(), stdgo.Go.toInterface(_name));
        };
        for (_name => _obj in _all._elems) {
            _obj = _resolve(_name?.__copy__(), _obj);
            {
                var _lbl = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<Label>)) : stdgo.Ref<Label>);
                if (!_lbl._used) {
                    _check._softErrorf(stdgo.Go.asInterface(_lbl), (122 : stdgo.internal.types.errors.Errors.Code), ("label %s declared and not used" : stdgo.GoString), stdgo.Go.toInterface(_lbl._object._name));
                };
            };
        };
    }
    @:keep
    static public function _interfaceType( _check:stdgo.Ref<Checker>, _ityp:stdgo.Ref<Interface>, _iface:stdgo.Ref<stdgo.go.ast.Ast.InterfaceType>, _def:stdgo.Ref<Named>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _addEmbedded:(stdgo.go.token.Token.Pos, stdgo.go.types.Types.Type_) -> Void = function(_pos:stdgo.go.token.Token.Pos, _typ:Type_):Void {
            _ityp._embeddeds = (_ityp._embeddeds.__append__(_typ));
            if (_ityp._embedPos == null || (_ityp._embedPos : Dynamic).__nil__) {
                _ityp._embedPos = (stdgo.Go.setRef((null : stdgo.Slice<stdgo.go.token.Token.Pos>)) : stdgo.Ref<stdgo.Slice<stdgo.go.token.Token.Pos>>);
            };
            _ityp._embedPos.__setData__(((_ityp._embedPos : stdgo.Slice<stdgo.go.token.Token.Pos>).__append__(_pos)));
        };
        for (__0 => _f in _iface.methods.list) {
            if ((_f.names.length) == ((0 : stdgo.GoInt))) {
                _addEmbedded(_f.type.pos(), _parseUnion(_check, _f.type));
                continue;
            };
            var _name = _f.names[(0 : stdgo.GoInt)];
            if (_name.name == (("_" : stdgo.GoString))) {
                _check._error(stdgo.Go.asInterface(_name), (27 : stdgo.internal.types.errors.Errors.Code), ("methods must have a unique non-blank name" : stdgo.GoString));
                continue;
            };
            var _typ:stdgo.go.types.Types.Type_ = _check._environment._sig._recv._object._typ(_f.type);
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_typ) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Signature>), _1 : false };
            }, _sig = __tmp__._0, __17 = __tmp__._1;
            if (_sig == null || (_sig : Dynamic).__nil__) {
                if (stdgo.Go.toInterface(_typ) != (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                    _check._errorf(_f.type, (-1 : stdgo.internal.types.errors.Errors.Code), ("%s is not a method signature" : stdgo.GoString), stdgo.Go.toInterface(_typ));
                };
                continue;
            };
            if (_sig._tparams != null && ((_sig._tparams : Dynamic).__nil__ == null || !(_sig._tparams : Dynamic).__nil__)) {
                var _at:T_positioner = _f.type;
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_f.type) : stdgo.Ref<stdgo.go.ast.Ast.FuncType>)) : stdgo.Ref<stdgo.go.ast.Ast.FuncType>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.FuncType>), _1 : false };
                    }, _ftyp = __tmp__._0, __26 = __tmp__._1;
                    if (((_ftyp != null) && ((_ftyp : Dynamic).__nil__ == null || !(_ftyp : Dynamic).__nil__)) && ((_ftyp.typeParams != null) && ((_ftyp.typeParams : Dynamic).__nil__ == null || !(_ftyp.typeParams : Dynamic).__nil__))) {
                        _at = stdgo.Go.asInterface(_ftyp.typeParams);
                    };
                };
                _check._error(_at, (143 : stdgo.internal.types.errors.Errors.Code), ("methods cannot have type parameters" : stdgo.GoString));
            };
            var _recvTyp:Type_ = stdgo.Go.asInterface(_ityp);
            if (_def != null && ((_def : Dynamic).__nil__ == null || !(_def : Dynamic).__nil__)) {
                _recvTyp = stdgo.Go.asInterface(_def);
            };
            _sig._recv = newVar(_name.pos(), _check._pkg, stdgo.Go.str()?.__copy__(), _recvTyp);
            var _m = newFunc(_name.pos(), _check._pkg, _name.name?.__copy__(), _sig);
            _check._recordDef(_name, stdgo.Go.asInterface(_m));
            _ityp._methods = (_ityp._methods.__append__(_m));
        };
        _ityp._complete = true;
        if ((_ityp._methods.length == (0 : stdgo.GoInt)) && (_ityp._embeddeds.length == (0 : stdgo.GoInt))) {
            _ityp._tset = (stdgo.Go.setRef(_topTypeSet) : stdgo.Ref<stdgo.go.types.Types.T__TypeSet>);
            return;
        };
        _sortMethods(_ityp._methods);
        _check._later(function():Void {
            _computeInterfaceTypeSet(_check, _iface.pos(), _ityp);
        })._describef(stdgo.Go.asInterface(_iface), ("compute type set for %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_ityp)));
    }
    /**
        // check may be nil
    **/
    @:keep
    static public function _newInterface( _check:stdgo.Ref<Checker>):stdgo.Ref<Interface> {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _typ = (stdgo.Go.setRef(({ _check : _check } : stdgo.go.types.Types.Interface)) : stdgo.Ref<stdgo.go.types.Types.Interface>);
        if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
            _check._needsCleanup(stdgo.Go.asInterface(_typ));
        };
        return _typ;
    }
    /**
        // implements checks if V implements T. The receiver may be nil if implements
        // is called through an exported API call such as AssignableTo. If constraint
        // is set, T is a type constraint.
        //
        // If the provided cause is non-nil, it may be set to an error string
        // explaining why V does not implement (or satisfy, for constraints) T.
    **/
    @:keep
    static public function _implements( _check:stdgo.Ref<Checker>, _pos:stdgo.go.token.Token.Pos, v:Type_, t:Type_, _constraint:Bool, _cause:stdgo.Pointer<stdgo.GoString>):Bool {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var vu:stdgo.go.types.Types.Type_ = _under(v);
        var tu:stdgo.go.types.Types.Type_ = _under(t);
        if ((stdgo.Go.toInterface(vu) == stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]))) || (stdgo.Go.toInterface(tu) == stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
            return true;
        };
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(vu) : stdgo.Ref<Pointer_>)) : stdgo.Ref<Pointer_>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>), _1 : false };
            }, _p = __tmp__._0, __0 = __tmp__._1;
            if (((_p != null) && ((_p : Dynamic).__nil__ == null || !(_p : Dynamic).__nil__)) && (stdgo.Go.toInterface(_under(_p._base)) == stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                return true;
            };
        };
        var _verb:stdgo.GoString = ("implement" : stdgo.GoString);
        if (_constraint) {
            _verb = ("satisfy" : stdgo.GoString);
        };
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(tu) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Interface>), _1 : false };
        }, ti = __tmp__._0, __1 = __tmp__._1;
        if (ti == null || (ti : Dynamic).__nil__) {
            if (_cause != null) {
                var _detail:stdgo.GoString = ("" : stdgo.GoString);
                if (_isInterfacePtr(tu)) {
                    _detail = _check._sprintf(("type %s is pointer to interface, not interface" : stdgo.GoString), stdgo.Go.toInterface(t))?.__copy__();
                } else {
                    _detail = _check._sprintf(("%s is not an interface" : stdgo.GoString), stdgo.Go.toInterface(t))?.__copy__();
                };
                _cause.value = _check._sprintf(("%s does not %s %s (%s)" : stdgo.GoString), stdgo.Go.toInterface(v), stdgo.Go.toInterface(_verb), stdgo.Go.toInterface(t), stdgo.Go.toInterface(_detail))?.__copy__();
            };
            return false;
        };
        if (ti.empty()) {
            return true;
        };
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(vu) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Interface>), _1 : false };
        }, vi = __tmp__._0, __34 = __tmp__._1;
        if (((vi != null) && ((vi : Dynamic).__nil__ == null || !(vi : Dynamic).__nil__)) && vi._typeSet().isEmpty()) {
            return true;
        };
        if (ti._typeSet().isEmpty()) {
            if (_cause != null) {
                _cause.value = _check._sprintf(("cannot %s %s (empty type set)" : stdgo.GoString), stdgo.Go.toInterface(_verb), stdgo.Go.toInterface(t))?.__copy__();
            };
            return false;
        };
        {
            var __tmp__ = _check._missingMethod(v, t, true, identical, _cause), _m:stdgo.Ref<stdgo.go.types.Types.Func> = __tmp__._0, __67:Bool = __tmp__._1;
            if (_m != null && ((_m : Dynamic).__nil__ == null || !(_m : Dynamic).__nil__)) {
                if (_cause != null) {
                    _cause.value = _check._sprintf(("%s does not %s %s %s" : stdgo.GoString), stdgo.Go.toInterface(v), stdgo.Go.toInterface(_verb), stdgo.Go.toInterface(t), stdgo.Go.toInterface(_cause.value))?.__copy__();
                };
                return false;
            };
        };
        var _checkComparability:() -> Bool = function():Bool {
            if (!ti.isComparable()) {
                return true;
            };
            if (_comparable(v, false, (null : stdgo.GoMap<stdgo.go.types.Types.Type_, Bool>), null)) {
                return true;
            };
            if (_constraint && _comparable(v, true, (null : stdgo.GoMap<stdgo.go.types.Types.Type_, Bool>), null)) {
                if (((_check == null) || (_check : Dynamic).__nil__) || _check._allowVersion(_check._pkg, stdgo.Go.asInterface((_pos : T_atPos)), _go1_20?.__copy__())) {
                    return true;
                };
                if (_cause != null) {
                    _cause.value = _check._sprintf(("%s to %s comparable requires go1.20 or later" : stdgo.GoString), stdgo.Go.toInterface(v), stdgo.Go.toInterface(_verb))?.__copy__();
                };
                return false;
            };
            if (_cause != null) {
                _cause.value = _check._sprintf(("%s does not %s comparable" : stdgo.GoString), stdgo.Go.toInterface(v), stdgo.Go.toInterface(_verb))?.__copy__();
            };
            return false;
        };
        if (!ti._typeSet()._hasTerms()) {
            return _checkComparability();
        };
        if (vi != null && ((vi : Dynamic).__nil__ == null || !(vi : Dynamic).__nil__)) {
            if (!vi._typeSet()._subsetOf(ti._typeSet())) {
                if (_cause != null) {
                    _cause.value = _check._sprintf(("%s does not %s %s" : stdgo.GoString), stdgo.Go.toInterface(v), stdgo.Go.toInterface(_verb), stdgo.Go.toInterface(t))?.__copy__();
                };
                return false;
            };
            return _checkComparability();
        };
        var _alt:Type_ = (null : stdgo.go.types.Types.Type_);
        if (ti._typeSet()._is(function(_t:stdgo.Ref<T_term>):Bool {
            if (!_t._includes(v)) {
                if (((_alt == null) && !_t._tilde) && identical(_t._typ, _under(_t._typ))) {
                    var _tt:stdgo.go.types.Types.T_term = (_t : stdgo.go.types.Types.T_term)?.__copy__();
                    _tt._tilde = true;
                    if (_tt._includes(v)) {
                        _alt = _t._typ;
                    };
                };
                return true;
            };
            return false;
        })) {
            if (_cause != null) {
                var _detail:stdgo.GoString = ("" : stdgo.GoString);
                if (_alt != null) {
                    _detail = _check._sprintf(("possibly missing ~ for %s in %s" : stdgo.GoString), stdgo.Go.toInterface(_alt), stdgo.Go.toInterface(t))?.__copy__();
                } else if (_mentions(stdgo.Go.asInterface(ti), v)) {
                    _detail = _check._sprintf(("%s mentions %s, but %s is not in the type set of %s" : stdgo.GoString), stdgo.Go.toInterface(t), stdgo.Go.toInterface(v), stdgo.Go.toInterface(v), stdgo.Go.toInterface(t))?.__copy__();
                } else {
                    _detail = _check._sprintf(("%s missing in %s" : stdgo.GoString), stdgo.Go.toInterface(v), stdgo.Go.toInterface(stdgo.Go.asInterface(ti._typeSet()._terms)))?.__copy__();
                };
                _cause.value = _check._sprintf(("%s does not %s %s (%s)" : stdgo.GoString), stdgo.Go.toInterface(v), stdgo.Go.toInterface(_verb), stdgo.Go.toInterface(t), stdgo.Go.toInterface(_detail))?.__copy__();
            };
            return false;
        };
        return _checkComparability();
    }
    @:keep
    static public function _verify( _check:stdgo.Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _tparams:stdgo.Slice<stdgo.Ref<TypeParam>>, _targs:stdgo.Slice<Type_>, _ctxt:stdgo.Ref<Context>):{ var _0 : stdgo.GoInt; var _1 : stdgo.Error; } {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _smap:stdgo.go.types.Types.T_substMap = _makeSubstMap(_tparams, _targs);
        for (_i => _tpar in _tparams) {
            _tpar._iface();
            var _bound:stdgo.go.types.Types.Type_ = _check._subst(_pos, _tpar._bound, _smap, null, _ctxt);
            var _cause:stdgo.GoString = ("" : stdgo.GoString);
            if (!_check._implements(_pos, _targs[(_i : stdgo.GoInt)], _bound, true, stdgo.Go.pointer(_cause))) {
                return { _0 : _i, _1 : stdgo.errors.Errors.new_(_cause?.__copy__()) };
            };
        };
        return { _0 : (-1 : stdgo.GoInt), _1 : (null : stdgo.Error) };
    }
    /**
        // validateTArgLen verifies that the length of targs and tparams matches,
        // reporting an error if not. If validation fails and check is nil,
        // validateTArgLen panics.
    **/
    @:keep
    static public function _validateTArgLen( _check:stdgo.Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _ntparams:stdgo.GoInt, _ntargs:stdgo.GoInt):Bool {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if (_ntargs != (_ntparams)) {
            if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
                _check._errorf(stdgo.Go.asInterface((_pos : T_atPos)), (137 : stdgo.internal.types.errors.Errors.Code), ("got %d arguments but %d type parameters" : stdgo.GoString), stdgo.Go.toInterface(_ntargs), stdgo.Go.toInterface(_ntparams));
                return false;
            };
            throw stdgo.Go.toInterface(stdgo.fmt.Fmt.sprintf(("%v: got %d arguments but %d type parameters" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_pos)), stdgo.Go.toInterface(_ntargs), stdgo.Go.toInterface(_ntparams)));
        };
        return true;
    }
    /**
        // instance instantiates the given original (generic) function or type with the
        // provided type arguments and returns the resulting instance. If an identical
        // instance exists already in the given contexts, it returns that instance,
        // otherwise it creates a new one.
        //
        // If expanding is non-nil, it is the Named instance type currently being
        // expanded. If ctxt is non-nil, it is the context associated with the current
        // type-checking pass or call to Instantiate. At least one of expanding or ctxt
        // must be non-nil.
        //
        // For Named types the resulting instance may be unexpanded.
    **/
    @:keep
    static public function _instance( _check:stdgo.Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _orig:Type_, _targs:stdgo.Slice<Type_>, _expanding:stdgo.Ref<Named>, _ctxt:stdgo.Ref<Context>):Type_ {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _res:Type_ = (null : stdgo.go.types.Types.Type_);
        var _ctxts:stdgo.Slice<stdgo.Ref<Context>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Context>>);
        if (_expanding != null && ((_expanding : Dynamic).__nil__ == null || !(_expanding : Dynamic).__nil__)) {
            _ctxts = (_ctxts.__append__(_expanding._inst._ctxt));
        };
        if (_ctxt != null && ((_ctxt : Dynamic).__nil__ == null || !(_ctxt : Dynamic).__nil__)) {
            _ctxts = (_ctxts.__append__(_ctxt));
        };
        _assert((_ctxts.length) > (0 : stdgo.GoInt));
        var _hashes = new stdgo.Slice<stdgo.GoString>((_ctxts.length : stdgo.GoInt).toBasic(), 0).__setString__();
        for (_i => _ctxt in _ctxts) {
            _hashes[(_i : stdgo.GoInt)] = _ctxt._instanceHash(_orig, _targs)?.__copy__();
        };
        var _updateContexts:stdgo.go.types.Types.Type_ -> stdgo.go.types.Types.Type_ = function(_res:Type_):Type_ {
            {
                var _i:stdgo.GoInt = (_ctxts.length) - (1 : stdgo.GoInt);
                stdgo.Go.cfor(_i >= (0 : stdgo.GoInt), _i--, {
                    _res = _ctxts[(_i : stdgo.GoInt)]._update(_hashes[(_i : stdgo.GoInt)]?.__copy__(), _orig, _targs, _res);
                });
            };
            return _res;
        };
        for (_i => _ctxt in _ctxts) {
            {
                var _inst:stdgo.go.types.Types.Type_ = _ctxt._lookup(_hashes[(_i : stdgo.GoInt)]?.__copy__(), _orig, _targs);
                if (_inst != null) {
                    return _updateContexts(_inst);
                };
            };
        };
        {
            final __type__ = _orig;
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Named>))) {
                var _orig:stdgo.Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                _res = stdgo.Go.asInterface(_check._newNamedInstance(_pos, _orig, _targs, _expanding));
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Signature>))) {
                var _orig:stdgo.Ref<stdgo.go.types.Types.Signature> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__().value;
                _assert(_expanding == null || (_expanding : Dynamic).__nil__);
                var _tparams = _orig.typeParams();
                if (!_check._validateTArgLen(_pos, _tparams.len(), (_targs.length))) {
                    return stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                };
                if (_tparams.len() == ((0 : stdgo.GoInt))) {
                    return stdgo.Go.asInterface(_orig);
                };
                var _sig = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_check._subst(_pos, stdgo.Go.asInterface(_orig), _makeSubstMap(_tparams._list(), _targs), null, _ctxt)) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>);
                if (_sig == (_orig)) {
                    var _copy:stdgo.go.types.Types.Signature = (_sig : stdgo.go.types.Types.Signature)?.__copy__();
                    _sig = (stdgo.Go.setRef(_copy) : stdgo.Ref<stdgo.go.types.Types.Signature>);
                };
                _sig._tparams = null;
                _res = stdgo.Go.asInterface(_sig);
            } else {
                var _orig:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                throw stdgo.Go.toInterface(stdgo.fmt.Fmt.sprintf(("%v: cannot instantiate %v" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_pos)), stdgo.Go.toInterface(_orig)));
            };
        };
        return _updateContexts(_res);
    }
    /**
        // reportCycle reports an error for the given cycle.
    **/
    @:keep
    static public function _reportCycle( _check:stdgo.Ref<Checker>, _cycle:stdgo.Slice<Object>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _obj:stdgo.go.types.Types.Object = _cycle[(0 : stdgo.GoInt)];
        if ((_cycle.length) == ((1 : stdgo.GoInt))) {
            _check._errorf(_obj, (9 : stdgo.internal.types.errors.Errors.Code), ("initialization cycle: %s refers to itself" : stdgo.GoString), stdgo.Go.toInterface(_obj.name()));
            return;
        };
        _check._errorf(_obj, (9 : stdgo.internal.types.errors.Errors.Code), ("initialization cycle for %s" : stdgo.GoString), stdgo.Go.toInterface(_obj.name()));
        {
            var _i:stdgo.GoInt = (_cycle.length) - (1 : stdgo.GoInt);
            stdgo.Go.cfor(_i >= (0 : stdgo.GoInt), _i--, {
                _check._errorf(_obj, (9 : stdgo.internal.types.errors.Errors.Code), ("\t%s refers to" : stdgo.GoString), stdgo.Go.toInterface(_obj.name()));
                _obj = _cycle[(_i : stdgo.GoInt)];
            });
        };
        _check._errorf(_obj, (9 : stdgo.internal.types.errors.Errors.Code), ("\t%s" : stdgo.GoString), stdgo.Go.toInterface(_obj.name()));
    }
    /**
        // initOrder computes the Info.InitOrder for package variables.
    **/
    @:keep
    static public function _initOrder( _check:stdgo.Ref<Checker>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _check.info.initOrder = (_check.info.initOrder.__slice__(0, (0 : stdgo.GoInt)) : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Initializer>>);
        var _pq:stdgo.go.types.Types.T_nodeQueue = (_dependencyGraph(_check._objMap) : T_nodeQueue);
        stdgo.container.heap.Heap.init(stdgo.Go.asInterface((stdgo.Go.setRef(_pq) : stdgo.Ref<stdgo.go.types.Types.T_nodeQueue>)));
        {};
        if (false) {
            stdgo.fmt.Fmt.printf(("Computing initialization order for %s\n\n" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_check._pkg)));
            stdgo.fmt.Fmt.println(stdgo.Go.toInterface(("Object dependency graph:" : stdgo.GoString)));
            for (_obj => _d in _check._objMap) {
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : T_dependency)) : T_dependency), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.go.types.Types.T_dependency), _1 : false };
                    }, _obj = __tmp__._0, __40 = __tmp__._1;
                    if (_obj != null) {
                        if ((_d._deps.length) > (0 : stdgo.GoInt)) {
                            stdgo.fmt.Fmt.printf(("\t%s depends on\n" : stdgo.GoString), stdgo.Go.toInterface(_obj.name()));
                            for (_dep => _ in _d._deps) {
                                stdgo.fmt.Fmt.printf(("\t\t%s\n" : stdgo.GoString), stdgo.Go.toInterface(_dep.name()));
                            };
                        } else {
                            stdgo.fmt.Fmt.printf(("\t%s has no dependencies\n" : stdgo.GoString), stdgo.Go.toInterface(_obj.name()));
                        };
                    };
                };
            };
            stdgo.fmt.Fmt.println();
            stdgo.fmt.Fmt.println(stdgo.Go.toInterface(("Transposed object dependency graph (functions eliminated):" : stdgo.GoString)));
            for (__41 => _n in _pq) {
                stdgo.fmt.Fmt.printf(("\t%s depends on %d nodes\n" : stdgo.GoString), stdgo.Go.toInterface(_n._obj.name()), stdgo.Go.toInterface(_n._ndeps));
                for (_p => _ in _n._pred) {
                    stdgo.fmt.Fmt.printf(("\t\t%s is dependent\n" : stdgo.GoString), stdgo.Go.toInterface(_p._obj.name()));
                };
            };
            stdgo.fmt.Fmt.println();
            stdgo.fmt.Fmt.println(stdgo.Go.toInterface(("Processing nodes:" : stdgo.GoString)));
        };
        var _emitted = ({
            final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.types.Types.T_declInfo>, Bool>();
            @:mergeBlock {};
            cast x;
        } : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.T_declInfo>, Bool>);
        while ((_pq.length) > (0 : stdgo.GoInt)) {
            var _n = (stdgo.Go.typeAssert((stdgo.container.heap.Heap.pop(stdgo.Go.asInterface((stdgo.Go.setRef(_pq) : stdgo.Ref<stdgo.go.types.Types.T_nodeQueue>))) : stdgo.Ref<T_graphNode>)) : stdgo.Ref<T_graphNode>);
            if (false) {
                stdgo.fmt.Fmt.printf(("\t%s (src pos %d) depends on %d nodes now\n" : stdgo.GoString), stdgo.Go.toInterface(_n._obj.name()), stdgo.Go.toInterface(_n._obj._order()), stdgo.Go.toInterface(_n._ndeps));
            };
            if (_n._ndeps > (0 : stdgo.GoInt)) {
                var _cycle = _findPath(_check._objMap, _n._obj, _n._obj, ({
                    final x = new stdgo.GoMap.GoObjectMap<stdgo.go.types.Types.Object, Bool>();
                    x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Object", [], stdgo.internal.reflect.Reflect.GoType.named("Object", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
                    x.__defaultValue__ = () -> false;
                    @:mergeBlock {};
                    cast x;
                } : stdgo.GoMap<stdgo.go.types.Types.Object, Bool>));
                if (_cycle != null) {
                    _check._reportCycle(_cycle);
                };
            };
            for (_p => _ in _n._pred) {
                _p._ndeps--;
                stdgo.container.heap.Heap.fix(stdgo.Go.asInterface((stdgo.Go.setRef(_pq) : stdgo.Ref<stdgo.go.types.Types.T_nodeQueue>)), _p._index);
            };
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_n._obj) : stdgo.Ref<Var>)) : stdgo.Ref<Var>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Var>), _1 : false };
            }, _v = __tmp__._0, __58 = __tmp__._1;
            var _info = (_check._objMap[stdgo.Go.asInterface(_v)] ?? (null : stdgo.Ref<stdgo.go.types.Types.T_declInfo>));
            if (((_v == null) || (_v : Dynamic).__nil__) || !_info._hasInitializer()) {
                continue;
            };
            if ((_emitted[_info] ?? false)) {
                continue;
            };
            _emitted[_info] = true;
            var _infoLhs = _info._lhs;
            if (_infoLhs == null) {
                _infoLhs = (new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>(1, 1, _v) : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>);
            };
            var _init = (stdgo.Go.setRef((new stdgo.go.types.Types.Initializer(_infoLhs, _info._init) : stdgo.go.types.Types.Initializer)) : stdgo.Ref<stdgo.go.types.Types.Initializer>);
            _check.info.initOrder = (_check.info.initOrder.__append__(_init));
        };
        if (false) {
            stdgo.fmt.Fmt.println();
            stdgo.fmt.Fmt.println(stdgo.Go.toInterface(("Initialization order:" : stdgo.GoString)));
            for (__91 => _init in _check.info.initOrder) {
                stdgo.fmt.Fmt.printf(("\t%s\n" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_init)));
            };
            stdgo.fmt.Fmt.println();
        };
    }
    /**
        // renameTParams renames the type parameters in the given type such that each type
        // parameter is given a new identity. renameTParams returns the new type parameters
        // and updated type. If the result type is unchanged from the argument type, none
        // of the type parameters in tparams occurred in the type.
        // If typ is a generic function, type parameters held with typ are not changed and
        // must be updated separately if desired.
        // The positions is only used for debug traces.
    **/
    @:keep
    static public function _renameTParams( _check:stdgo.Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _tparams:stdgo.Slice<stdgo.Ref<TypeParam>>, _typ:Type_):{ var _0 : stdgo.Slice<stdgo.Ref<TypeParam>>; var _1 : Type_; } {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if ((_tparams.length) == ((0 : stdgo.GoInt))) {
            return { _0 : (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>), _1 : _typ };
        };
        var _tparams2 = new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>((_tparams.length : stdgo.GoInt).toBasic(), 0);
        for (_i => _tparam in _tparams) {
            var _tname = newTypeName(_tparam._check._environment._decl._tdecl.name.obj().pos(), _tparam._check._environment._decl._tdecl.name.obj().pkg(), _tparam._check._environment._decl._tdecl.name.obj().name()?.__copy__(), (null : stdgo.go.types.Types.Type_));
            _tparams2[(_i : stdgo.GoInt)] = newTypeParam(_tname, (null : stdgo.go.types.Types.Type_));
            _tparams2[(_i : stdgo.GoInt)]._index = _tparam._index;
        };
        var _renameMap:stdgo.go.types.Types.T_substMap = _makeRenameMap(_tparams, _tparams2);
        for (_i => _tparam in _tparams) {
            _tparams2[(_i : stdgo.GoInt)]._bound = _check._subst(_pos, _tparam._bound, _renameMap, null, _check._context());
        };
        return { _0 : _tparams2, _1 : _check._subst(_pos, _typ, _renameMap, null, _check._context()) };
    }
    /**
        // infer attempts to infer the complete set of type arguments for generic function instantiation/call
        // based on the given type parameters tparams, type arguments targs, function parameters params, and
        // function arguments args, if any. There must be at least one type parameter, no more type arguments
        // than type parameters, and params and args must match in number (incl. zero).
        // If successful, infer returns the complete list of given and inferred type arguments, one for each
        // type parameter. Otherwise the result is nil and appropriate errors will be reported.
    **/
    @:keep
    static public function _infer( _check:stdgo.Ref<Checker>, _posn:T_positioner, _tparams:stdgo.Slice<stdgo.Ref<TypeParam>>, _targs:stdgo.Slice<Type_>, _params:stdgo.Ref<Tuple>, _args:stdgo.Slice<stdgo.Ref<T_operand>>):stdgo.Slice<Type_> {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var __deferstack__:Array<Void -> Void> = [];
        var _inferred:stdgo.Slice<Type_> = (null : stdgo.Slice<stdgo.go.types.Types.Type_>);
        try {
            if (false) {
                __deferstack__.unshift(() -> {
                    var a = function():Void {
                        _assert((_inferred == null) || ((_inferred.length == (_tparams.length)) && !_containsNil(_inferred)));
                    };
                    a();
                });
            };
            if (false) {
                _check._dump(("== infer : %s%s ➞ %s" : stdgo.GoString), stdgo.Go.toInterface(_tparams), stdgo.Go.toInterface(stdgo.Go.asInterface(_params)), stdgo.Go.toInterface(_targs));
                __deferstack__.unshift(() -> {
                    var a = function():Void {
                        _check._dump(("=> %s ➞ %s\n" : stdgo.GoString), stdgo.Go.toInterface(_tparams), stdgo.Go.toInterface(_inferred));
                    };
                    a();
                });
            };
            var _n:stdgo.GoInt = (_tparams.length);
            _assert((_n > (0 : stdgo.GoInt)) && (_targs.length <= _n));
            _assert(_params.len() == ((_args.length)));
            if ((_targs.length == _n) && !_containsNil(_targs)) {
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return _targs;
                };
            };
            if ((_targs.length) < _n) {
                var _targs2 = new stdgo.Slice<stdgo.go.types.Types.Type_>((_n : stdgo.GoInt).toBasic(), 0);
                stdgo.Go.copySlice(_targs2, _targs);
                _targs = _targs2;
            };
            if (_params.len() > (0 : stdgo.GoInt)) {
                var _smap:stdgo.go.types.Types.T_substMap = _makeSubstMap(_tparams, _targs);
                _params = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_check._subst(_nopos, stdgo.Go.asInterface(_params), _smap, null, _check._context())) : stdgo.Ref<Tuple>)) : stdgo.Ref<Tuple>);
            };
            var _u = _newUnifier(_tparams, _targs, _check._allowVersion(_check._pkg, _posn, _go1_21?.__copy__()));
            var _errorf = function(_kind:stdgo.GoString, _tpar:Type_, _targ:Type_, _arg:stdgo.Ref<T_operand>):Void {
                var _targs = _u._inferred(_tparams);
                if (_targs[(0 : stdgo.GoInt)] == null) {
                    var _allFailed:Bool = true;
                    for (__40 => _targ in _targs) {
                        if (_targ != null) {
                            _allFailed = false;
                            break;
                        };
                    };
                    if (_allFailed) {
                        _check._errorf(stdgo.Go.asInterface(_arg), (138 : stdgo.internal.types.errors.Errors.Code), ("%s %s of %s does not match %s (cannot infer %s)" : stdgo.GoString), stdgo.Go.toInterface(_kind), stdgo.Go.toInterface(_targ), stdgo.Go.toInterface(_arg._expr), stdgo.Go.toInterface(_tpar), stdgo.Go.toInterface(_typeParamsString(_tparams)));
                        return;
                    };
                };
                var _smap:stdgo.go.types.Types.T_substMap = _makeSubstMap(_tparams, _targs);
                var _inferred:stdgo.go.types.Types.Type_ = _check._subst(_arg.pos(), _tpar, _smap, null, _check._context());
                if (stdgo.Go.toInterface(_inferred) != (stdgo.Go.toInterface(_tpar))) {
                    _check._errorf(stdgo.Go.asInterface(_arg), (138 : stdgo.internal.types.errors.Errors.Code), ("%s %s of %s does not match inferred type %s for %s" : stdgo.GoString), stdgo.Go.toInterface(_kind), stdgo.Go.toInterface(_targ), stdgo.Go.toInterface(_arg._expr), stdgo.Go.toInterface(_inferred), stdgo.Go.toInterface(_tpar));
                } else {
                    _check._errorf(stdgo.Go.asInterface(_arg), (138 : stdgo.internal.types.errors.Errors.Code), ("%s %s of %s does not match %s" : stdgo.GoString), stdgo.Go.toInterface(_kind), stdgo.Go.toInterface(_targ), stdgo.Go.toInterface(_arg._expr), stdgo.Go.toInterface(_tpar));
                };
            };
            var _untyped:stdgo.Slice<stdgo.GoInt> = (null : stdgo.Slice<stdgo.GoInt>);
            if (false) {
                _u._tracef(("== function parameters: %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_params)));
                _u._tracef(("-- function arguments : %s" : stdgo.GoString), stdgo.Go.toInterface(_args));
            };
            for (_i => _arg in _args) {
                if (_arg._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                    continue;
                };
                var _par = _params.at(_i);
                if (_isParameterized(_tparams, _par._object._typ) || _isParameterized(_tparams, _arg._typ)) {
                    if (_isTyped(_arg._typ)) {
                        if (!_u._unify(_par._object._typ, _arg._typ, (1u32 : stdgo.go.types.Types.T_unifyMode))) {
                            _errorf(("type" : stdgo.GoString), _par._object._typ, _arg._typ, _arg);
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return (null : stdgo.Slice<stdgo.go.types.Types.Type_>);
                            };
                        };
                    } else {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_par._object._typ) : stdgo.Ref<TypeParam>)) : stdgo.Ref<TypeParam>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>), _1 : false };
                        }, __40 = __tmp__._0, _ok = __tmp__._1;
                        if (_ok && !_arg._isNil()) {
                            _untyped = (_untyped.__append__(_i));
                        };
                    };
                };
            };
            if (false) {
                var _inferred = _u._inferred(_tparams);
                _u._tracef(("=> %s ➞ %s\n" : stdgo.GoString), stdgo.Go.toInterface(_tparams), stdgo.Go.toInterface(_inferred));
            };
            if (false) {
                _u._tracef(("== type parameters: %s" : stdgo.GoString), stdgo.Go.toInterface(_tparams));
            };
            {
                var _i:stdgo.GoInt = (0 : stdgo.GoInt);
                stdgo.Go.cfor(true, _i++, {
                    var _nn:stdgo.GoInt = _u._unknowns();
                    if (false) {
                        if (_i > (0 : stdgo.GoInt)) {
                            stdgo.fmt.Fmt.println();
                        };
                        _u._tracef(("-- iteration %d" : stdgo.GoString), stdgo.Go.toInterface(_i));
                    };
                    for (__41 => _tpar in _tparams) {
                        var _tx:stdgo.go.types.Types.Type_ = _u._at(_tpar);
                        var __tmp__ = _coreTerm(_tpar), _core:stdgo.Ref<stdgo.go.types.Types.T_term> = __tmp__._0, _single:Bool = __tmp__._1;
                        if (false) {
                            _u._tracef(("-- type parameter %s = %s: core(%s) = %s, single = %v" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_tpar)), stdgo.Go.toInterface(_tx), stdgo.Go.toInterface(stdgo.Go.asInterface(_tpar)), stdgo.Go.toInterface(stdgo.Go.asInterface(_core)), stdgo.Go.toInterface(_single));
                        };
                        if (_core != null && ((_core : Dynamic).__nil__ == null || !(_core : Dynamic).__nil__)) {
                            if (_tx != null) {
                                if (!_u._unify(_tx, _core._typ, (0u32 : stdgo.go.types.Types.T_unifyMode))) {
                                    _check._errorf(_posn, (138 : stdgo.internal.types.errors.Errors.Code), ("%s (type %s) does not satisfy %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_tpar)), stdgo.Go.toInterface(_tx), stdgo.Go.toInterface(_tpar.constraint()));
                                    {
                                        for (defer in __deferstack__) {
                                            defer();
                                        };
                                        return (null : stdgo.Slice<stdgo.go.types.Types.Type_>);
                                    };
                                };
                            } else if (_single && !_core._tilde) {
                                _u._set(_tpar, _core._typ);
                            };
                        } else {
                            if (_tx != null) {
                                var _cause:stdgo.GoString = ("" : stdgo.GoString);
                                var _constraint = _tpar._iface();
                                {
                                    var __tmp__ = _check._missingMethod(_tx, stdgo.Go.asInterface(_constraint), true, function(_x:Type_, _y:Type_):Bool {
                                        return _u._unify(_x, _y, (2u32 : stdgo.go.types.Types.T_unifyMode));
                                    }, stdgo.Go.pointer(_cause)), _m:stdgo.Ref<stdgo.go.types.Types.Func> = __tmp__._0, __74:Bool = __tmp__._1;
                                    if (_m != null && ((_m : Dynamic).__nil__ == null || !(_m : Dynamic).__nil__)) {
                                        _check._errorf(_posn, (138 : stdgo.internal.types.errors.Errors.Code), ("%s (type %s) does not satisfy %s %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_tpar)), stdgo.Go.toInterface(_tx), stdgo.Go.toInterface(_tpar.constraint()), stdgo.Go.toInterface(_cause));
                                        {
                                            for (defer in __deferstack__) {
                                                defer();
                                            };
                                            return (null : stdgo.Slice<stdgo.go.types.Types.Type_>);
                                        };
                                    };
                                };
                            };
                        };
                    };
                    if (_u._unknowns() == (_nn)) {
                        break;
                    };
                });
            };
            if (false) {
                var _inferred = _u._inferred(_tparams);
                _u._tracef(("=> %s ➞ %s\n" : stdgo.GoString), stdgo.Go.toInterface(_tparams), stdgo.Go.toInterface(_inferred));
            };
            if (false) {
                _u._tracef(("== untyped arguments: %v" : stdgo.GoString), stdgo.Go.toInterface(_untyped));
            };
            var _maxUntyped:stdgo.GoMap<stdgo.Ref<TypeParam>, Type_> = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeParam>, stdgo.go.types.Types.Type_>);
            for (__91 => _index in _untyped) {
                var _tpar = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_params.at(_index)._object._typ) : stdgo.Ref<TypeParam>)) : stdgo.Ref<TypeParam>);
                if (_u._at(_tpar) == null) {
                    var _arg = _args[(_index : stdgo.GoInt)];
                    if (_maxUntyped == null) {
                        _maxUntyped = ({
                            final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.types.Types.TypeParam>, stdgo.go.types.Types.Type_>();
                            @:mergeBlock {};
                            cast x;
                        } : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeParam>, stdgo.go.types.Types.Type_>);
                    };
                    var _max:stdgo.go.types.Types.Type_ = (_maxUntyped[_tpar] ?? (null : stdgo.go.types.Types.Type_));
                    if (_max == null) {
                        _max = _arg._typ;
                    } else {
                        var _m:stdgo.go.types.Types.Type_ = _maxType(_max, _arg._typ);
                        if (_m == null) {
                            _check._errorf(stdgo.Go.asInterface(_arg), (138 : stdgo.internal.types.errors.Errors.Code), ("mismatched types %s and %s (cannot infer %s)" : stdgo.GoString), stdgo.Go.toInterface(_max), stdgo.Go.toInterface(_arg._typ), stdgo.Go.toInterface(stdgo.Go.asInterface(_tpar)));
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return (null : stdgo.Slice<stdgo.go.types.Types.Type_>);
                            };
                        };
                        _max = _m;
                    };
                    _maxUntyped[_tpar] = _max;
                };
            };
            for (_tpar => _typ in _maxUntyped) {
                var _d:stdgo.go.types.Types.Type_ = default_(_typ);
                _assert(_isTyped(_d));
                _u._set(_tpar, _d);
            };
            _inferred = _u._inferred(_tparams);
            if (false) {
                for (_i => _targ in _targs) {
                    _assert((_targ == null) || (stdgo.Go.toInterface(_inferred[(_i : stdgo.GoInt)]) == stdgo.Go.toInterface(_targ)));
                };
            };
            _killCycles(_tparams, _inferred);
            var _dirty:stdgo.Slice<stdgo.GoInt> = (null : stdgo.Slice<stdgo.GoInt>);
            for (_i => _typ in _inferred) {
                if ((_typ != null) && ((_i >= _targs.length) || (_targs[(_i : stdgo.GoInt)] == null))) {
                    _dirty = (_dirty.__append__(_i));
                };
            };
            while ((_dirty.length) > (0 : stdgo.GoInt)) {
                if (false) {
                    _u._tracef(("-- simplify %s ➞ %s" : stdgo.GoString), stdgo.Go.toInterface(_tparams), stdgo.Go.toInterface(_inferred));
                };
                var _smap:stdgo.go.types.Types.T_substMap = _makeSubstMap(_tparams, _inferred);
                var _n:stdgo.GoInt = (0 : stdgo.GoInt);
                for (__104 => _index in _dirty) {
                    var _t0:stdgo.go.types.Types.Type_ = _inferred[(_index : stdgo.GoInt)];
                    {
                        var _t1:stdgo.go.types.Types.Type_ = _check._subst(_nopos, _t0, _smap, null, _check._context());
                        if (stdgo.Go.toInterface(_t1) != (stdgo.Go.toInterface(_t0))) {
                            {
                                var __tmp__ = try {
                                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_t1) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>), _1 : true };
                                } catch(_) {
                                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Signature>), _1 : false };
                                }, _sig = __tmp__._0, __121 = __tmp__._1;
                                if ((((_sig != null) && ((_sig : Dynamic).__nil__ == null || !(_sig : Dynamic).__nil__)) && (_sig.typeParams().len() > (0 : stdgo.GoInt))) && !_isParameterized(_tparams, stdgo.Go.asInterface(_sig))) {
                                    _sig._tparams = null;
                                };
                            };
                            _inferred[(_index : stdgo.GoInt)] = _t1;
                            _dirty[(_n : stdgo.GoInt)] = _index;
                            _n++;
                        };
                    };
                };
                _dirty = (_dirty.__slice__(0, _n) : stdgo.Slice<stdgo.GoInt>);
            };
            for (_i => _typ in _inferred) {
                if ((_typ == null) || _isParameterized(_tparams, _typ)) {
                    var _obj = _tparams[(_i : stdgo.GoInt)]._obj;
                    _check._errorf(_posn, (138 : stdgo.internal.types.errors.Errors.Code), ("cannot infer %s (%s)" : stdgo.GoString), stdgo.Go.toInterface(_obj._object._name), stdgo.Go.toInterface(stdgo.Go.asInterface(_obj._object._pos)));
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return (null : stdgo.Slice<stdgo.go.types.Types.Type_>);
                    };
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _inferred;
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return _inferred;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return _inferred;
        };
    }
    /**
        // indexedElts checks the elements (elts) of an array or slice composite literal
        // against the literal's element type (typ), and the element indices against
        // the literal length if known (length >= 0). It returns the length of the
        // literal (maximum index value + 1).
    **/
    @:keep
    static public function _indexedElts( _check:stdgo.Ref<Checker>, _elts:stdgo.Slice<stdgo.go.ast.Ast.Expr>, _typ:Type_, _length:stdgo.GoInt64):stdgo.GoInt64 {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _visited = ({
            final x = new stdgo.GoMap.GoInt64Map<Bool>();
            x.__defaultValue__ = () -> false;
            @:mergeBlock {};
            x;
        } : stdgo.GoMap<stdgo.GoInt64, Bool>);
        var __0:stdgo.GoInt64 = (0 : stdgo.GoInt64), __1:stdgo.GoInt64 = (0 : stdgo.GoInt64), _max:stdgo.GoInt64 = __1, _index:stdgo.GoInt64 = __0;
        for (__0 => _e in _elts) {
            var _validIndex:Bool = false;
            var _eval:stdgo.go.ast.Ast.Expr = _e;
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_e) : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>)) : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>), _1 : false };
                }, _kv = __tmp__._0, __1 = __tmp__._1;
                if (_kv != null && ((_kv : Dynamic).__nil__ == null || !(_kv : Dynamic).__nil__)) {
                    {
                        var __tmp__ = _check._index(_kv.key, _length), _typ:stdgo.go.types.Types.Type_ = __tmp__._0, _i:stdgo.GoInt64 = __tmp__._1;
                        if (stdgo.Go.toInterface(_typ) != (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                            if (_i >= (0i64 : stdgo.GoInt64)) {
                                _index = _i;
                                _validIndex = true;
                            } else {
                                _check._errorf(_e, (62 : stdgo.internal.types.errors.Errors.Code), ("index %s must be integer constant" : stdgo.GoString), stdgo.Go.toInterface(_kv.key));
                            };
                        };
                    };
                    _eval = _kv.value;
                } else if ((_length >= (0i64 : stdgo.GoInt64)) && (_index >= _length)) {
                    _check._errorf(_e, (63 : stdgo.internal.types.errors.Errors.Code), ("index %d is out of bounds (>= %d)" : stdgo.GoString), stdgo.Go.toInterface(_index), stdgo.Go.toInterface(_length));
                } else {
                    _validIndex = true;
                };
            };
            if (_validIndex) {
                if ((_visited[_index] ?? false)) {
                    _check._errorf(_e, (60 : stdgo.internal.types.errors.Errors.Code), ("duplicate index %d in array or slice literal" : stdgo.GoString), stdgo.Go.toInterface(_index));
                };
                _visited[_index] = true;
            };
            _index++;
            if (_index > _max) {
                _max = _index;
            };
            var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
            _check._exprWithHint((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _eval, _typ);
            _check._assignment((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _typ, ("array or slice literal" : stdgo.GoString));
        };
        return _max;
    }
    @:keep
    static public function _isValidIndex( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _code:Code, _what:stdgo.GoString, _allowNegative:Bool):Bool {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
            return false;
        };
        _check._convertUntyped(_x, stdgo.Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]));
        if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
            return false;
        };
        if (!_allInteger(_x._typ)) {
            _check._errorf(stdgo.Go.asInterface(_x), _code, ("invalid argument: %s %s must be integer" : stdgo.GoString), stdgo.Go.toInterface(_what), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
            return false;
        };
        if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
            if (!_allowNegative && (stdgo.go.constant.Constant.sign(_x._val) < (0 : stdgo.GoInt))) {
                _check._errorf(stdgo.Go.asInterface(_x), _code, ("invalid argument: %s %s must not be negative" : stdgo.GoString), stdgo.Go.toInterface(_what), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                return false;
            };
            if (!_representableConst(_x._val, _check, typ[((2 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)], (stdgo.Go.setRef(_x._val) : stdgo.Ref<stdgo.go.constant.Constant.Value>))) {
                _check._errorf(stdgo.Go.asInterface(_x), _code, ("invalid argument: %s %s overflows int" : stdgo.GoString), stdgo.Go.toInterface(_what), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                return false;
            };
        };
        return true;
    }
    /**
        // index checks an index expression for validity.
        // If max >= 0, it is the upper bound for index.
        // If the result typ is != Typ[Invalid], index is valid and typ is its (possibly named) integer type.
        // If the result val >= 0, index is valid and val is its constant int value.
    **/
    @:keep
    static public function _index( _check:stdgo.Ref<Checker>, _index:stdgo.go.ast.Ast.Expr, _max:stdgo.GoInt64):{ var _0 : Type_; var _1 : stdgo.GoInt64; } {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _typ:Type_ = (null : stdgo.go.types.Types.Type_), _val:stdgo.GoInt64 = (0 : stdgo.GoInt64);
        _typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
        _val = (-1i64 : stdgo.GoInt64);
        var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
        _check._expr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _index);
        if (!_check._isValidIndex((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), (52 : stdgo.internal.types.errors.Errors.Code), ("index" : stdgo.GoString), false)) {
            return { _0 : _typ, _1 : _val };
        };
        if (_x._mode != ((4 : stdgo.go.types.Types.T_operandMode))) {
            return { _0 : _x._typ, _1 : (-1i64 : stdgo.GoInt64) };
        };
        if (_x._val.kind() == ((0 : stdgo.go.constant.Constant.Kind))) {
            return { _0 : _typ, _1 : _val };
        };
        var __tmp__ = stdgo.go.constant.Constant.int64Val(_x._val), _v:stdgo.GoInt64 = __tmp__._0, _ok:Bool = __tmp__._1;
        _assert(_ok);
        if ((_max >= (0i64 : stdgo.GoInt64)) && (_v >= _max)) {
            _check._errorf(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>)), (52 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: index %s out of bounds [0:%d]" : stdgo.GoString), stdgo.Go.toInterface((_x._val.string() : stdgo.GoString)), stdgo.Go.toInterface(_max));
            return { _0 : _typ, _1 : _val };
        };
        return { _0 : _x._typ, _1 : _v };
    }
    /**
        // singleIndex returns the (single) index from the index expression e.
        // If the index is missing, or if there are multiple indices, an error
        // is reported and the result is nil.
    **/
    @:keep
    static public function _singleIndex( _check:stdgo.Ref<Checker>, _expr:stdgo.Ref<stdgo.go.internal.typeparams.Typeparams.IndexExpr>):stdgo.go.ast.Ast.Expr {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if ((_expr.indexListExpr.indices.length) == ((0 : stdgo.GoInt))) {
            _check._errorf(_expr.orig, (-1 : stdgo.internal.types.errors.Errors.Code), ("index expression %v with 0 indices" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_expr)));
            return (null : stdgo.go.ast.Ast.Expr);
        };
        if ((_expr.indexListExpr.indices.length) > (1 : stdgo.GoInt)) {
            _check._error(_expr.indexListExpr.indices[(1 : stdgo.GoInt)], (52 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: more than one index" : stdgo.GoString));
        };
        return _expr.indexListExpr.indices[(0 : stdgo.GoInt)];
    }
    @:keep
    static public function _sliceExpr( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _e:stdgo.Ref<stdgo.go.ast.Ast.SliceExpr>):Void {
        stdgo.internal.Macro.controlFlow({
            @:recv var _check:stdgo.Ref<Checker> = _check;
            _check._expr((null : stdgo.go.types.Types.Type_), _x, _e.x);
            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                _check._use(_e.low, _e.high, _e.max);
                return;
            };
            var _valid:Bool = false;
            var _length:stdgo.GoInt64 = (-1i64 : stdgo.GoInt64);
            {
                final __type__ = _coreString(_x._typ);
                if (__type__ == null) {
                    var _u:stdgo.AnyInterface = __type__ == null ? (null : stdgo.AnyInterface) : cast __type__;
                    _check._errorf(stdgo.Go.asInterface(_x), (54 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot slice %s: %s has no core type" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(_x._typ));
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                    return;
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                    var _u:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                    if (_isString(stdgo.Go.asInterface(_u))) {
                        if (_e.slice3) {
                            var _at:stdgo.go.ast.Ast.Expr = _e.max;
                            if (_at == null) {
                                _at = stdgo.Go.asInterface(_e);
                            };
                            _check._error(_at, (55 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: 3-index slice of string" : stdgo.GoString));
                            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                            return;
                        };
                        _valid = true;
                        if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
                            _length = (stdgo.go.constant.Constant.stringVal(_x._val).length : stdgo.GoInt64);
                        };
                        if (_isUntyped(_x._typ)) {
                            _x._typ = stdgo.Go.asInterface(typ[((17 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Array_>))) {
                    var _u:stdgo.Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                    _valid = true;
                    _length = _u._len;
                    if (_x._mode != ((5 : stdgo.go.types.Types.T_operandMode))) {
                        _check._errorf(stdgo.Go.asInterface(_x), (54 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot slice %s (value not addressable)" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                        _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                        return;
                    };
                    _x._typ = stdgo.Go.asInterface((stdgo.Go.setRef(({ _elem : _u._elem } : stdgo.go.types.Types.Slice_)) : stdgo.Ref<stdgo.go.types.Types.Slice_>));
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Pointer_>))) {
                    var _u:stdgo.Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_u._base)) : stdgo.Ref<Array_>)) : stdgo.Ref<Array_>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Array_>), _1 : false };
                        }, _u = __tmp__._0, __40 = __tmp__._1;
                        if (_u != null && ((_u : Dynamic).__nil__ == null || !(_u : Dynamic).__nil__)) {
                            _valid = true;
                            _length = _u._len;
                            _x._typ = stdgo.Go.asInterface((stdgo.Go.setRef(({ _elem : _u._elem } : stdgo.go.types.Types.Slice_)) : stdgo.Ref<stdgo.go.types.Types.Slice_>));
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Slice_>))) {
                    var _u:stdgo.Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                    _valid = true;
                };
            };
            if (!_valid) {
                _check._errorf(stdgo.Go.asInterface(_x), (54 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot slice %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                return;
            };
            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
            if (_e.slice3 && ((_e.high == null) || (_e.max == null))) {
                _check._error(stdgo.Go.asInterface(_inNode(stdgo.Go.asInterface(_e), _e.rbrack)), (-1 : stdgo.internal.types.errors.Errors.Code), ("2nd and 3rd index required in 3-index slice" : stdgo.GoString));
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                return;
            };
            var _ind:stdgo.GoArray<stdgo.GoInt64> = new stdgo.GoArray<stdgo.GoInt64>(...[for (i in 0 ... 3) (0 : stdgo.GoInt64)]);
            for (_i => _expr in (new stdgo.Slice<stdgo.go.ast.Ast.Expr>(3, 3, _e.low, _e.high, _e.max) : stdgo.Slice<stdgo.go.ast.Ast.Expr>)) {
                var _x:stdgo.GoInt64 = (-1i64 : stdgo.GoInt64);
                if (_expr != null) {
                    var _max:stdgo.GoInt64 = (-1i64 : stdgo.GoInt64);
                    if (_length >= (0i64 : stdgo.GoInt64)) {
                        _max = _length + (1i64 : stdgo.GoInt64);
                    };
                    {
                        var __tmp__ = _check._index(_expr, _max), __65:stdgo.go.types.Types.Type_ = __tmp__._0, _v:stdgo.GoInt64 = __tmp__._1;
                        if (_v >= (0i64 : stdgo.GoInt64)) {
                            _x = _v;
                        };
                    };
                } else if (_i == ((0 : stdgo.GoInt))) {
                    _x = (0i64 : stdgo.GoInt64);
                } else if (_length >= (0i64 : stdgo.GoInt64)) {
                    _x = _length;
                };
                _ind[(_i : stdgo.GoInt)] = _x;
            };
            @:label("L") for (_i => _x in (_ind.__slice__(0, (2 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoInt64>)) {
                if (_x > (0i64 : stdgo.GoInt64)) {
                    for (_j => _y in (_ind.__slice__(_i + (1 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoInt64>)) {
                        if ((_y >= (0i64 : stdgo.GoInt64)) && (_y < _x)) {
                            var _at:stdgo.go.ast.Ast.Expr = (new stdgo.Slice<stdgo.go.ast.Ast.Expr>(3, 3, _e.low, _e.high, _e.max) : stdgo.Slice<stdgo.go.ast.Ast.Expr>)[((_i + (1 : stdgo.GoInt)) + _j : stdgo.GoInt)];
                            _check._errorf(_at, (53 : stdgo.internal.types.errors.Errors.Code), ("invalid slice indices: %d < %d" : stdgo.GoString), stdgo.Go.toInterface(_y), stdgo.Go.toInterface(_x));
                            @:jump("L") break;
                        };
                    };
                };
            };
        });
    }
    /**
        // If e is a valid function instantiation, indexExpr returns true.
        // In that case x represents the uninstantiated function value and
        // it is the caller's responsibility to instantiate the function.
    **/
    @:keep
    static public function _indexExpr( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _e:stdgo.Ref<stdgo.go.internal.typeparams.Typeparams.IndexExpr>):Bool {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _isFuncInst:Bool = false;
        _check._exprOrType(_x, _e.indexListExpr.x, true);
        {
            final __value__ = _x._mode;
            if (__value__ == ((0 : stdgo.go.types.Types.T_operandMode))) {
                _check._use(..._e.indexListExpr.indices.__toArray__());
                return false;
            } else if (__value__ == ((3 : stdgo.go.types.Types.T_operandMode))) {
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                _x._typ = _check._varType(_e.orig);
                if (stdgo.Go.toInterface(_x._typ) != (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                    _x._mode = (3 : stdgo.go.types.Types.T_operandMode);
                };
                return false;
            } else if (__value__ == ((7 : stdgo.go.types.Types.T_operandMode))) {
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_x._typ)) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Signature>), _1 : false };
                    }, _sig = __tmp__._0, __24 = __tmp__._1;
                    if (((_sig != null) && ((_sig : Dynamic).__nil__ == null || !(_sig : Dynamic).__nil__)) && (_sig.typeParams().len() > (0 : stdgo.GoInt))) {
                        return true;
                    };
                };
            };
        };
        _check._nonGeneric((null : stdgo.go.types.Types.Type_), _x);
        if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
            return false;
        };
        var _valid:Bool = false;
        var _length:stdgo.GoInt64 = (-1i64 : stdgo.GoInt64);
        {
            final __type__ = _under(_x._typ);
            {
                var __bool__ = true;
                while (__bool__) {
                    __bool__ = false;
                    if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                        var _typ:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                        if (_isString(stdgo.Go.asInterface(_typ))) {
                            _valid = true;
                            if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
                                _length = (stdgo.go.constant.Constant.stringVal(_x._val).length : stdgo.GoInt64);
                            };
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = _universeByte;
                        };
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Array_>))) {
                        var _typ:stdgo.Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                        _valid = true;
                        _length = _typ._len;
                        if (_x._mode != ((5 : stdgo.go.types.Types.T_operandMode))) {
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                        };
                        _x._typ = _typ._elem;
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Pointer_>))) {
                        var _typ:stdgo.Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                        {
                            var __tmp__ = try {
                                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_typ._base)) : stdgo.Ref<Array_>)) : stdgo.Ref<Array_>), _1 : true };
                            } catch(_) {
                                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Array_>), _1 : false };
                            }, _typ = __tmp__._0, __33 = __tmp__._1;
                            if (_typ != null && ((_typ : Dynamic).__nil__ == null || !(_typ : Dynamic).__nil__)) {
                                _valid = true;
                                _length = _typ._len;
                                _x._mode = (5 : stdgo.go.types.Types.T_operandMode);
                                _x._typ = _typ._elem;
                            };
                        };
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Slice_>))) {
                        var _typ:stdgo.Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                        _valid = true;
                        _x._mode = (5 : stdgo.go.types.Types.T_operandMode);
                        _x._typ = _typ._elem;
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Map_>))) {
                        var _typ:stdgo.Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                        var _index:stdgo.go.ast.Ast.Expr = _check._singleIndex(_e);
                        if (_index == null) {
                            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                            return false;
                        };
                        var _key:T_operand = ({} : stdgo.go.types.Types.T_operand);
                        _check._expr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_key) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _index);
                        _check._assignment((stdgo.Go.setRef(_key) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _typ._key, ("map index" : stdgo.GoString));
                        _x._mode = (6 : stdgo.go.types.Types.T_operandMode);
                        _x._typ = _typ._elem;
                        _x._expr = _e.orig;
                        return false;
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                        var _typ:stdgo.Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                        if (!_isTypeParam(_x._typ)) {
                            break;
                        };
                        var __0:Type_ = (null : stdgo.go.types.Types.Type_), __1:Type_ = (null : stdgo.go.types.Types.Type_), _elem:Type_ = __1, _key:Type_ = __0;
                        var _mode:stdgo.go.types.Types.T_operandMode = (5 : stdgo.go.types.Types.T_operandMode);
                        if (_typ._typeSet()._underIs(function(_u:Type_):Bool {
                            var _l:stdgo.GoInt64 = (-1i64 : stdgo.GoInt64);
                            var __0:Type_ = (null : stdgo.go.types.Types.Type_), __1:Type_ = (null : stdgo.go.types.Types.Type_), _e:Type_ = __1, _k:Type_ = __0;
                            {
                                final __type__ = _u;
                                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                                    var _t:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                                    if (_isString(stdgo.Go.asInterface(_t))) {
                                        _e = _universeByte;
                                        _mode = (7 : stdgo.go.types.Types.T_operandMode);
                                    };
                                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Array_>))) {
                                    var _t:stdgo.Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                                    _l = _t._len;
                                    _e = _t._elem;
                                    if (_x._mode != ((5 : stdgo.go.types.Types.T_operandMode))) {
                                        _mode = (7 : stdgo.go.types.Types.T_operandMode);
                                    };
                                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Pointer_>))) {
                                    var _t:stdgo.Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                                    {
                                        var __tmp__ = try {
                                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_t._base)) : stdgo.Ref<Array_>)) : stdgo.Ref<Array_>), _1 : true };
                                        } catch(_) {
                                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Array_>), _1 : false };
                                        }, _t = __tmp__._0, __66 = __tmp__._1;
                                        if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                                            _l = _t._len;
                                            _e = _t._elem;
                                        };
                                    };
                                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Slice_>))) {
                                    var _t:stdgo.Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                                    _e = _t._elem;
                                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Map_>))) {
                                    var _t:stdgo.Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                                    _k = _t._key;
                                    _e = _t._elem;
                                };
                            };
                            if (_e == null) {
                                return false;
                            };
                            if (_elem == null) {
                                _length = _l;
                                {
                                    final __tmp__0 = _k;
                                    final __tmp__1 = _e;
                                    _key = __tmp__0;
                                    _elem = __tmp__1;
                                };
                                return true;
                            };
                            if (!identical(_key, _k)) {
                                return false;
                            };
                            if (!identical(_elem, _e)) {
                                return false;
                            };
                            if ((_l >= (0i64 : stdgo.GoInt64)) && (_l < _length)) {
                                _length = _l;
                            };
                            return true;
                        })) {
                            if (_key != null) {
                                var _index:stdgo.go.ast.Ast.Expr = _check._singleIndex(_e);
                                if (_index == null) {
                                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                                    return false;
                                };
                                var _k:T_operand = ({} : stdgo.go.types.Types.T_operand);
                                _check._expr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_k) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _index);
                                _check._assignment((stdgo.Go.setRef(_k) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _key, ("map index" : stdgo.GoString));
                                _x._mode = (6 : stdgo.go.types.Types.T_operandMode);
                                _x._typ = _elem;
                                _x._expr = stdgo.Go.asInterface(_e);
                                return false;
                            };
                            _valid = true;
                            _x._mode = _mode;
                            _x._typ = _elem;
                        };
                    };
                    break;
                };
            };
        };
        if (!_valid) {
            _check._errorf(stdgo.Go.asInterface(_x), (51 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot index %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
            _check._use(..._e.indexListExpr.indices.__toArray__());
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            return false;
        };
        var _index:stdgo.go.ast.Ast.Expr = _check._singleIndex(_e);
        if (_index == null) {
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            return false;
        };
        if (_x._typ == null) {
            _x._typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
        };
        _check._index(_index, _length);
        return false;
    }
    /**
        // singleValue reports an error if x describes a tuple and sets x.mode to invalid.
    **/
    @:keep
    static public function _singleValue( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if (_x._mode == ((7 : stdgo.go.types.Types.T_operandMode))) {
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_x._typ) : stdgo.Ref<Tuple>)) : stdgo.Ref<Tuple>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Tuple>), _1 : false };
                }, _t = __tmp__._0, _ok = __tmp__._1;
                if (_ok) {
                    _assert(_t.len() != ((1 : stdgo.GoInt)));
                    _check._errorf(stdgo.Go.asInterface(_x), (41 : stdgo.internal.types.errors.Errors.Code), ("multiple-value %s in single-value context" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                };
            };
        };
    }
    /**
        // exclude reports an error if x.mode is in modeset and sets x.mode to invalid.
        // The modeset may contain any of 1<<novalue, 1<<builtin, 1<<typexpr.
    **/
    @:keep
    static public function _exclude( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _modeset:stdgo.GoUInt):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if (_modeset & ((1u32 : stdgo.GoUInt) << _x._mode) != ((0u32 : stdgo.GoUInt))) {
            var _msg:stdgo.GoString = ("" : stdgo.GoString);
            var _code:Code = ((0 : stdgo.GoInt) : stdgo.internal.types.errors.Errors.Code);
            {
                final __value__ = _x._mode;
                if (__value__ == ((1 : stdgo.go.types.Types.T_operandMode))) {
                    if (_modeset & (8u32 : stdgo.GoUInt) != ((0u32 : stdgo.GoUInt))) {
                        _msg = ("%s used as value" : stdgo.GoString);
                    } else {
                        _msg = ("%s used as value or type" : stdgo.GoString);
                    };
                    _code = (41 : stdgo.internal.types.errors.Errors.Code);
                } else if (__value__ == ((2 : stdgo.go.types.Types.T_operandMode))) {
                    _msg = ("%s must be called" : stdgo.GoString);
                    _code = (82 : stdgo.internal.types.errors.Errors.Code);
                } else if (__value__ == ((3 : stdgo.go.types.Types.T_operandMode))) {
                    _msg = ("%s is not an expression" : stdgo.GoString);
                    _code = (42 : stdgo.internal.types.errors.Errors.Code);
                } else {
                    _unreachable();
                };
            };
            _check._errorf(stdgo.Go.asInterface(_x), _code, _msg?.__copy__(), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
        };
    }
    /**
        // exprOrType typechecks expression or type e and initializes x with the expression value or type.
        // If allowGeneric is set, the operand type may be an uninstantiated parameterized type or function
        // value.
        // If an error occurred, x.mode is set to invalid.
    **/
    @:keep
    static public function _exprOrType( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _allowGeneric:Bool):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _check._rawExpr((null : stdgo.go.types.Types.Type_), _x, _e, (null : stdgo.go.types.Types.Type_), _allowGeneric);
        _check._exclude(_x, (2u32 : stdgo.GoUInt));
        _check._singleValue(_x);
    }
    /**
        // exprWithHint typechecks expression e and initializes x with the expression value;
        // hint is the type of a composite literal element.
        // If an error occurred, x.mode is set to invalid.
    **/
    @:keep
    static public function _exprWithHint( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _hint:Type_):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _assert(_hint != null);
        _check._rawExpr((null : stdgo.go.types.Types.Type_), _x, _e, _hint, false);
        _check._exclude(_x, (14u32 : stdgo.GoUInt));
        _check._singleValue(_x);
    }
    /**
        // multiExpr typechecks e and returns its value (or values) in list.
        // If allowCommaOk is set and e is a map index, comma-ok, or comma-err
        // expression, the result is a two-element list containing the value
        // of e, and an untyped bool value or an error value, respectively.
        // If an error occurred, list[0] is not valid.
    **/
    @:keep
    static public function _multiExpr( _check:stdgo.Ref<Checker>, _e:stdgo.go.ast.Ast.Expr, _allowCommaOk:Bool):{ var _0 : stdgo.Slice<stdgo.Ref<T_operand>>; var _1 : Bool; } {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _list:stdgo.Slice<stdgo.Ref<T_operand>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_operand>>), _commaOk:Bool = false;
        var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
        _check._rawExpr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _e, (null : stdgo.go.types.Types.Type_), false);
        _check._exclude((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), (14u32 : stdgo.GoUInt));
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_x._typ) : stdgo.Ref<Tuple>)) : stdgo.Ref<Tuple>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Tuple>), _1 : false };
            }, _t = __tmp__._0, _ok = __tmp__._1;
            if (_ok && (_x._mode != (0 : stdgo.go.types.Types.T_operandMode))) {
                _list = new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_operand>>((_t.len() : stdgo.GoInt).toBasic(), 0);
                for (_i => _v in _t._vars) {
                    _list[(_i : stdgo.GoInt)] = (stdgo.Go.setRef(({ _mode : (7 : stdgo.go.types.Types.T_operandMode), _expr : _e, _typ : _v._object._typ } : stdgo.go.types.Types.T_operand)) : stdgo.Ref<stdgo.go.types.Types.T_operand>);
                };
                return { _0 : _list, _1 : _commaOk };
            };
        };
        _list = (new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_operand>>(1, 1, (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>)) : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_operand>>);
        if (_allowCommaOk && (((_x._mode == (6 : stdgo.go.types.Types.T_operandMode)) || (_x._mode == (8 : stdgo.go.types.Types.T_operandMode))) || (_x._mode == (9 : stdgo.go.types.Types.T_operandMode)))) {
            var _x2 = (stdgo.Go.setRef(({ _mode : (7 : stdgo.go.types.Types.T_operandMode), _expr : _e, _typ : stdgo.Go.asInterface(typ[((19 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]) } : stdgo.go.types.Types.T_operand)) : stdgo.Ref<stdgo.go.types.Types.T_operand>);
            if (_x._mode == ((9 : stdgo.go.types.Types.T_operandMode))) {
                _x2._typ = _universeError;
            };
            _list = (_list.__append__(_x2));
            _commaOk = true;
        };
        return { _0 : _list, _1 : _commaOk };
    }
    /**
        // genericExpr is like expr but the result may also be generic.
    **/
    @:keep
    static public function _genericExpr( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _check._rawExpr((null : stdgo.go.types.Types.Type_), _x, _e, (null : stdgo.go.types.Types.Type_), true);
        _check._exclude(_x, (14u32 : stdgo.GoUInt));
        _check._singleValue(_x);
    }
    /**
        // expr typechecks expression e and initializes x with the expression value.
        // If a non-nil target type T is given and e is a generic function
        // or function call, T is used to infer the type arguments for e.
        // The result must be a single value.
        // If an error occurred, x.mode is set to invalid.
    **/
    @:keep
    static public function _expr( _check:stdgo.Ref<Checker>, t:Type_, _x:stdgo.Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _check._rawExpr(t, _x, _e, (null : stdgo.go.types.Types.Type_), false);
        _check._exclude(_x, (14u32 : stdgo.GoUInt));
        _check._singleValue(_x);
    }
    /**
        // typeAssertion checks x.(T). The type of x must be an interface.
    **/
    @:keep
    static public function _typeAssertion( _check:stdgo.Ref<Checker>, _e:stdgo.go.ast.Ast.Expr, _x:stdgo.Ref<T_operand>, t:Type_, _typeSwitch:Bool):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _cause:stdgo.GoString = ("" : stdgo.GoString);
        if (_check._assertableTo(_x._typ, t, stdgo.Go.pointer(_cause))) {
            return;
        };
        if (_typeSwitch) {
            _check._errorf(_e, (95 : stdgo.internal.types.errors.Errors.Code), ("impossible type switch case: %s\n\t%s cannot have dynamic type %s %s" : stdgo.GoString), stdgo.Go.toInterface(_e), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(t), stdgo.Go.toInterface(_cause));
            return;
        };
        _check._errorf(_e, (95 : stdgo.internal.types.errors.Errors.Code), ("impossible type assertion: %s\n\t%s does not implement %s %s" : stdgo.GoString), stdgo.Go.toInterface(_e), stdgo.Go.toInterface(t), stdgo.Go.toInterface(_x._typ), stdgo.Go.toInterface(_cause));
    }
    /**
        // exprInternal contains the core of type checking of expressions.
        // Must only be called by rawExpr.
        // (See rawExpr for an explanation of the parameters.)
    **/
    @:keep
    static public function _exprInternal( _check:stdgo.Ref<Checker>, t:Type_, _x:stdgo.Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _hint:Type_):T_exprKind {
        stdgo.internal.Macro.controlFlow({
            @:recv var _check:stdgo.Ref<Checker> = _check;
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            _x._typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
            {
                final __type__ = _e;
                {
                    var __bool__ = true;
                    while (__bool__) {
                        __bool__ = false;
                        if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BadExpr>))) {
                            var _e:stdgo.Ref<stdgo.go.ast.Ast.BadExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BadExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BadExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BadExpr>) : __type__.__underlying__().value;
                            @:goto "Error";
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.Ident>))) {
                            var _e:stdgo.Ref<stdgo.go.ast.Ast.Ident> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__().value;
                            _check._ident(_x, _e, null, false);
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.Ellipsis>))) {
                            var _e:stdgo.Ref<stdgo.go.ast.Ast.Ellipsis> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__.__underlying__().value;
                            _check._error(stdgo.Go.asInterface(_e), (77 : stdgo.internal.types.errors.Errors.Code), ("invalid use of \'...\'" : stdgo.GoString));
                            @:goto "Error";
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BasicLit>))) {
                            var _e:stdgo.Ref<stdgo.go.ast.Ast.BasicLit> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BasicLit>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BasicLit>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BasicLit>) : __type__.__underlying__().value;
                            {
                                final __value__ = _e.kind;
                                if (__value__ == ((5 : stdgo.go.token.Token.Token)) || __value__ == ((6 : stdgo.go.token.Token.Token)) || __value__ == ((7 : stdgo.go.token.Token.Token))) {
                                    _check._langCompat(_e);
                                    {};
                                    if ((_e.value.length) > (10000 : stdgo.GoInt)) {
                                        _check._errorf(stdgo.Go.asInterface(_e), (14 : stdgo.internal.types.errors.Errors.Code), ("excessively long constant: %s... (%d chars)" : stdgo.GoString), stdgo.Go.toInterface((_e.value.__slice__(0, (10 : stdgo.GoInt)) : stdgo.GoString)), stdgo.Go.toInterface((_e.value.length)));
                                        @:goto "Error";
                                    };
                                };
                            };
                            _x._setConst(_e.kind, _e.value?.__copy__());
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                _check._errorf(stdgo.Go.asInterface(_e), (14 : stdgo.internal.types.errors.Errors.Code), ("malformed constant: %s" : stdgo.GoString), stdgo.Go.toInterface(_e.value));
                                @:goto "Error";
                            };
                            _check._overflow(_x, _e.pos());
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.FuncLit>))) {
                            var _e:stdgo.Ref<stdgo.go.ast.Ast.FuncLit> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.FuncLit>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.FuncLit>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.FuncLit>) : __type__.__underlying__().value;
                            {
                                var __tmp__ = try {
                                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_check._environment._sig._recv._object._typ(stdgo.Go.asInterface(_e.type))) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>), _1 : true };
                                } catch(_) {
                                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Signature>), _1 : false };
                                }, _sig = __tmp__._0, _ok = __tmp__._1;
                                if (_ok) {
                                    if (!_check._conf.ignoreFuncBodies && ((_e.body != null) && ((_e.body : Dynamic).__nil__ == null || !(_e.body : Dynamic).__nil__))) {
                                        var _decl = _check._environment._decl;
                                        var _iota:stdgo.go.constant.Constant.Value = _check._environment._iota;
                                        _check._later(function():Void {
                                            _check._funcBody(_decl, ("<function literal>" : stdgo.GoString), _sig, _e.body, _iota);
                                        })._describef(stdgo.Go.asInterface(_e), ("func literal" : stdgo.GoString));
                                    };
                                    _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                                    _x._typ = stdgo.Go.asInterface(_sig);
                                } else {
                                    _check._errorf(stdgo.Go.asInterface(_e), (-1 : stdgo.internal.types.errors.Errors.Code), ("invalid function literal %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_e)));
                                    @:goto "Error";
                                };
                            };
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.CompositeLit>))) {
                            var _e:stdgo.Ref<stdgo.go.ast.Ast.CompositeLit> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CompositeLit>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CompositeLit>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CompositeLit>) : __type__.__underlying__().value;
                            var __0:Type_ = (null : stdgo.go.types.Types.Type_), __1:Type_ = (null : stdgo.go.types.Types.Type_), _base:Type_ = __1, _typ:Type_ = __0;
                            {
                                var __switchIndex__ = -1;
                                var __run__ = true;
                                while (__run__) {
                                    __run__ = false;
                                    if (_e.type != null) {
                                        {
                                            var __tmp__ = try {
                                                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_e.type) : stdgo.Ref<stdgo.go.ast.Ast.ArrayType>)) : stdgo.Ref<stdgo.go.ast.Ast.ArrayType>), _1 : true };
                                            } catch(_) {
                                                { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.ArrayType>), _1 : false };
                                            }, _atyp = __tmp__._0, __96 = __tmp__._1;
                                            if (((_atyp != null) && ((_atyp : Dynamic).__nil__ == null || !(_atyp : Dynamic).__nil__)) && (_atyp.len != null)) {
                                                {
                                                    var __tmp__ = try {
                                                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_atyp.len) : stdgo.Ref<stdgo.go.ast.Ast.Ellipsis>)) : stdgo.Ref<stdgo.go.ast.Ast.Ellipsis>), _1 : true };
                                                    } catch(_) {
                                                        { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.Ellipsis>), _1 : false };
                                                    }, _ellip = __tmp__._0, __97 = __tmp__._1;
                                                    if (((_ellip != null) && ((_ellip : Dynamic).__nil__ == null || !(_ellip : Dynamic).__nil__)) && (_ellip.elt == null)) {
                                                        _typ = stdgo.Go.asInterface((stdgo.Go.setRef(({ _len : (-1i64 : stdgo.GoInt64), _elem : _check._varType(_atyp.elt) } : stdgo.go.types.Types.Array_)) : stdgo.Ref<stdgo.go.types.Types.Array_>));
                                                        _base = _typ;
                                                        break;
                                                    };
                                                };
                                            };
                                        };
                                        _typ = _check._environment._sig._recv._object._typ(_e.type);
                                        _base = _typ;
                                        break;
                                    } else if (_hint != null) {
                                        _typ = _hint;
                                        {
                                            var __tmp__ = _deref(_coreType(_typ));
                                            _base = __tmp__._0;
                                        };
                                        if (_base == null) {
                                            _check._errorf(stdgo.Go.asInterface(_e), (71 : stdgo.internal.types.errors.Errors.Code), ("invalid composite literal element type %s (no core type)" : stdgo.GoString), stdgo.Go.toInterface(_typ));
                                            @:goto "Error";
                                        };
                                        break;
                                    } else {
                                        _check._error(stdgo.Go.asInterface(_e), (70 : stdgo.internal.types.errors.Errors.Code), ("missing type in composite literal" : stdgo.GoString));
                                        @:goto "Error";
                                    };
                                    break;
                                };
                            };
                            {
                                final __type__ = _coreType(_base);
                                {
                                    var __bool__ = true;
                                    while (__bool__) {
                                        __bool__ = false;
                                        if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Struct>))) {
                                            var _utyp:stdgo.Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                                            if (_utyp._fields == null) {
                                                _check._error(stdgo.Go.asInterface(_e), (12 : stdgo.internal.types.errors.Errors.Code), ("invalid recursive type" : stdgo.GoString));
                                                @:goto "Error";
                                            };
                                            if ((_e.elts.length) == ((0 : stdgo.GoInt))) {
                                                break;
                                            };
                                            var _fields = _utyp._fields;
                                            {
                                                var __tmp__ = try {
                                                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_e.elts[(0 : stdgo.GoInt)]) : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>)) : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>), _1 : true };
                                                } catch(_) {
                                                    { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>), _1 : false };
                                                }, __138 = __tmp__._0, _ok = __tmp__._1;
                                                if (_ok) {
                                                    var _visited = new stdgo.Slice<Bool>((_fields.length : stdgo.GoInt).toBasic(), 0);
                                                    for (__139 => _e in _e.elts) {
                                                        var __tmp__ = try {
                                                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_e) : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>)) : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>), _1 : true };
                                                        } catch(_) {
                                                            { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>), _1 : false };
                                                        }, _kv = __tmp__._0, __140 = __tmp__._1;
                                                        if (_kv == null || (_kv : Dynamic).__nil__) {
                                                            _check._error(_e, (64 : stdgo.internal.types.errors.Errors.Code), ("mixture of field:value and value elements in struct literal" : stdgo.GoString));
                                                            continue;
                                                        };
                                                        var __tmp__ = try {
                                                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_kv.key) : stdgo.Ref<stdgo.go.ast.Ast.Ident>)) : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _1 : true };
                                                        } catch(_) {
                                                            { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _1 : false };
                                                        }, _key = __tmp__._0, __149 = __tmp__._1;
                                                        _check._expr((null : stdgo.go.types.Types.Type_), _x, _kv.value);
                                                        if (_key == null || (_key : Dynamic).__nil__) {
                                                            _check._errorf(stdgo.Go.asInterface(_kv), (69 : stdgo.internal.types.errors.Errors.Code), ("invalid field name %s in struct literal" : stdgo.GoString), stdgo.Go.toInterface(_kv.key));
                                                            continue;
                                                        };
                                                        var _i:stdgo.GoInt = _fieldIndex(_utyp._fields, _check._pkg, _key.name?.__copy__());
                                                        if (_i < (0 : stdgo.GoInt)) {
                                                            _check._errorf(stdgo.Go.asInterface(_kv), (66 : stdgo.internal.types.errors.Errors.Code), ("unknown field %s in struct literal of type %s" : stdgo.GoString), stdgo.Go.toInterface(_key.name), stdgo.Go.toInterface(_base));
                                                            continue;
                                                        };
                                                        var _fld = _fields[(_i : stdgo.GoInt)];
                                                        _check._recordUse(_key, stdgo.Go.asInterface(_fld));
                                                        var _etyp:stdgo.go.types.Types.Type_ = _fld._object._typ;
                                                        _check._assignment(_x, _etyp, ("struct literal" : stdgo.GoString));
                                                        if (_visited[(_i : stdgo.GoInt)]) {
                                                            _check._errorf(stdgo.Go.asInterface(_kv), (67 : stdgo.internal.types.errors.Errors.Code), ("duplicate field name %s in struct literal" : stdgo.GoString), stdgo.Go.toInterface(_key.name));
                                                            continue;
                                                        };
                                                        _visited[(_i : stdgo.GoInt)] = true;
                                                    };
                                                } else {
                                                    for (_i => _e in _e.elts) {
                                                        {
                                                            var __tmp__ = try {
                                                                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_e) : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>)) : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>), _1 : true };
                                                            } catch(_) {
                                                                { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>), _1 : false };
                                                            }, _kv = __tmp__._0, __206 = __tmp__._1;
                                                            if (_kv != null && ((_kv : Dynamic).__nil__ == null || !(_kv : Dynamic).__nil__)) {
                                                                _check._error(stdgo.Go.asInterface(_kv), (64 : stdgo.internal.types.errors.Errors.Code), ("mixture of field:value and value elements in struct literal" : stdgo.GoString));
                                                                continue;
                                                            };
                                                        };
                                                        _check._expr((null : stdgo.go.types.Types.Type_), _x, _e);
                                                        if (_i >= (_fields.length)) {
                                                            _check._errorf(stdgo.Go.asInterface(_x), (65 : stdgo.internal.types.errors.Errors.Code), ("too many values in struct literal of type %s" : stdgo.GoString), stdgo.Go.toInterface(_base));
                                                            break;
                                                        };
                                                        var _fld = _fields[(_i : stdgo.GoInt)];
                                                        if (!_fld.exported() && (_fld._object._pkg != _check._pkg)) {
                                                            _check._errorf(stdgo.Go.asInterface(_x), (68 : stdgo.internal.types.errors.Errors.Code), ("implicit assignment to unexported field %s in struct literal of type %s" : stdgo.GoString), stdgo.Go.toInterface(_fld._object._name), stdgo.Go.toInterface(_base));
                                                            continue;
                                                        };
                                                        var _etyp:stdgo.go.types.Types.Type_ = _fld._object._typ;
                                                        _check._assignment(_x, _etyp, ("struct literal" : stdgo.GoString));
                                                    };
                                                    if ((_e.elts.length) < (_fields.length)) {
                                                        _check._errorf(stdgo.Go.asInterface(_inNode(stdgo.Go.asInterface(_e), _e.rbrace)), (65 : stdgo.internal.types.errors.Errors.Code), ("too few values in struct literal of type %s" : stdgo.GoString), stdgo.Go.toInterface(_base));
                                                    };
                                                };
                                            };
                                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Array_>))) {
                                            var _utyp:stdgo.Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                                            if (_utyp._elem == null) {
                                                _check._error(stdgo.Go.asInterface(_e), (12 : stdgo.internal.types.errors.Errors.Code), ("invalid recursive type" : stdgo.GoString));
                                                @:goto "Error";
                                            };
                                            var _n:stdgo.GoInt64 = _check._indexedElts(_e.elts, _utyp._elem, _utyp._len);
                                            if (_utyp._len < (0i64 : stdgo.GoInt64)) {
                                                _utyp._len = _n;
                                                if (_e.type != null) {
                                                    _check._recordTypeAndValue(_e.type, (3 : stdgo.go.types.Types.T_operandMode), stdgo.Go.asInterface(_utyp), (null : stdgo.go.constant.Constant.Value));
                                                };
                                            };
                                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Slice_>))) {
                                            var _utyp:stdgo.Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                                            if (_utyp._elem == null) {
                                                _check._error(stdgo.Go.asInterface(_e), (12 : stdgo.internal.types.errors.Errors.Code), ("invalid recursive type" : stdgo.GoString));
                                                @:goto "Error";
                                            };
                                            _check._indexedElts(_e.elts, _utyp._elem, (-1i64 : stdgo.GoInt64));
                                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Map_>))) {
                                            var _utyp:stdgo.Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                                            if ((_utyp._key == null) || (_utyp._elem == null)) {
                                                _check._error(stdgo.Go.asInterface(_e), (12 : stdgo.internal.types.errors.Errors.Code), ("invalid recursive type" : stdgo.GoString));
                                                @:goto "Error";
                                            };
                                            var _keyIsInterface:Bool = _isNonTypeParamInterface(_utyp._key);
                                            var _visited = ({
                                                final x = new stdgo.GoMap.GoAnyInterfaceMap<stdgo.Slice<stdgo.go.types.Types.Type_>>();
                                                x.__defaultValue__ = () -> (null : stdgo.Slice<stdgo.go.types.Types.Type_>);
                                                @:mergeBlock {};
                                                cast x;
                                            } : stdgo.GoMap<stdgo.AnyInterface, stdgo.Slice<stdgo.go.types.Types.Type_>>);
                                            for (__311 => _e in _e.elts) {
                                                var __tmp__ = try {
                                                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_e) : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>)) : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>), _1 : true };
                                                } catch(_) {
                                                    { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>), _1 : false };
                                                }, _kv = __tmp__._0, __312 = __tmp__._1;
                                                if (_kv == null || (_kv : Dynamic).__nil__) {
                                                    _check._error(_e, (61 : stdgo.internal.types.errors.Errors.Code), ("missing key in map literal" : stdgo.GoString));
                                                    continue;
                                                };
                                                _check._exprWithHint(_x, _kv.key, _utyp._key);
                                                _check._assignment(_x, _utyp._key, ("map literal" : stdgo.GoString));
                                                if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                                    continue;
                                                };
                                                if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
                                                    var _duplicate:Bool = false;
                                                    var _xkey:stdgo.AnyInterface = _keyVal(_x._val);
                                                    if (_keyIsInterface) {
                                                        for (__337 => _vtyp in (_visited[_xkey] ?? (null : stdgo.Slice<stdgo.go.types.Types.Type_>))) {
                                                            if (identical(_vtyp, _x._typ)) {
                                                                _duplicate = true;
                                                                break;
                                                            };
                                                        };
                                                        _visited[_xkey] = ((_visited[_xkey] ?? (null : stdgo.Slice<stdgo.go.types.Types.Type_>)).__append__(_x._typ));
                                                    } else {
                                                        {
                                                            var __tmp__ = (_visited != null && _visited.exists(_xkey) ? { _0 : _visited[_xkey], _1 : true } : { _0 : (null : stdgo.Slice<stdgo.go.types.Types.Type_>), _1 : false });
                                                            _duplicate = __tmp__._1;
                                                        };
                                                        _visited[_xkey] = (null : stdgo.Slice<stdgo.go.types.Types.Type_>);
                                                    };
                                                    if (_duplicate) {
                                                        _check._errorf(stdgo.Go.asInterface(_x), (60 : stdgo.internal.types.errors.Errors.Code), ("duplicate key %s in map literal" : stdgo.GoString), stdgo.Go.toInterface(_x._val));
                                                        continue;
                                                    };
                                                };
                                                _check._exprWithHint(_x, _kv.value, _utyp._elem);
                                                _check._assignment(_x, _utyp._elem, ("map literal" : stdgo.GoString));
                                            };
                                        } else {
                                            var _utyp:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                                            for (__362 => _e in _e.elts) {
                                                {
                                                    var __tmp__ = try {
                                                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_e) : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>)) : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>), _1 : true };
                                                    } catch(_) {
                                                        { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>), _1 : false };
                                                    }, _kv = __tmp__._0, __363 = __tmp__._1;
                                                    if (_kv != null && ((_kv : Dynamic).__nil__ == null || !(_kv : Dynamic).__nil__)) {
                                                        _e = _kv.value;
                                                    };
                                                };
                                                _check._use(_e);
                                            };
                                            if (stdgo.Go.toInterface(_utyp) != (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                                                _check._errorf(stdgo.Go.asInterface(_e), (71 : stdgo.internal.types.errors.Errors.Code), ("invalid composite literal type %s" : stdgo.GoString), stdgo.Go.toInterface(_typ));
                                                @:goto "Error";
                                            };
                                        };
                                        break;
                                    };
                                };
                            };
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = _typ;
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>))) {
                            var _e:stdgo.Ref<stdgo.go.ast.Ast.ParenExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__().value;
                            var _kind:stdgo.go.types.Types.T_exprKind = _check._rawExpr((null : stdgo.go.types.Types.Type_), _x, _e.x, (null : stdgo.go.types.Types.Type_), false);
                            _x._expr = stdgo.Go.asInterface(_e);
                            return _kind;
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>))) {
                            var _e:stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__().value;
                            _check._selector(_x, _e, null, false);
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IndexExpr>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IndexListExpr>))) {
                            var _e:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                            var _ix = stdgo.go.internal.typeparams.Typeparams.unpackIndexExpr(_e);
                            if (_check._indexExpr(_x, _ix)) {
                                var _tsig:stdgo.Ref<Signature> = (null : stdgo.Ref<stdgo.go.types.Types.Signature>);
                                if (true && (t != null)) {
                                    {
                                        var __tmp__ = try {
                                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(t)) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>), _1 : true };
                                        } catch(_) {
                                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Signature>), _1 : false };
                                        };
                                        _tsig = __tmp__._0;
                                    };
                                };
                                _check._funcInst(_tsig, _e.pos(), _x, _ix, true);
                            };
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                @:goto "Error";
                            };
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SliceExpr>))) {
                            var _e:stdgo.Ref<stdgo.go.ast.Ast.SliceExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SliceExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SliceExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.SliceExpr>) : __type__.__underlying__().value;
                            _check._sliceExpr(_x, _e);
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                @:goto "Error";
                            };
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.TypeAssertExpr>))) {
                            var _e:stdgo.Ref<stdgo.go.ast.Ast.TypeAssertExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.TypeAssertExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.TypeAssertExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.TypeAssertExpr>) : __type__.__underlying__().value;
                            _check._expr((null : stdgo.go.types.Types.Type_), _x, _e.x);
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                @:goto "Error";
                            };
                            if (_e.type == null) {
                                _check._error(stdgo.Go.asInterface(_e), (115 : stdgo.internal.types.errors.Errors.Code), ("use of .(type) outside type switch" : stdgo.GoString));
                                @:goto "Error";
                            };
                            if (_isTypeParam(_x._typ)) {
                                _check._errorf(stdgo.Go.asInterface(_x), (94 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot use type assertion on type parameter value %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                                @:goto "Error";
                            };
                            {
                                var __tmp__ = try {
                                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_x._typ)) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>), _1 : true };
                                } catch(_) {
                                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Interface>), _1 : false };
                                }, __444 = __tmp__._0, _ok = __tmp__._1;
                                if (!_ok) {
                                    _check._errorf(stdgo.Go.asInterface(_x), (94 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: %s is not an interface" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                                    @:goto "Error";
                                };
                            };
                            var t:stdgo.go.types.Types.Type_ = _check._varType(_e.type);
                            if (stdgo.Go.toInterface(t) == (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                                @:goto "Error";
                            };
                            _check._typeAssertion(stdgo.Go.asInterface(_e), _x, t, false);
                            _x._mode = (8 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = t;
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>))) {
                            var _e:stdgo.Ref<stdgo.go.ast.Ast.CallExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>) : __type__.__underlying__().value;
                            return _check._callExpr(_x, _e);
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>))) {
                            var _e:stdgo.Ref<stdgo.go.ast.Ast.StarExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__().value;
                            _check._exprOrType(_x, _e.x, false);
                            {
                                final __value__ = _x._mode;
                                if (__value__ == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                    @:goto "Error";
                                } else if (__value__ == ((3 : stdgo.go.types.Types.T_operandMode))) {
                                    _check._validVarType(_e.x, _x._typ);
                                    _x._typ = stdgo.Go.asInterface((stdgo.Go.setRef(({ _base : _x._typ } : stdgo.go.types.Types.Pointer_)) : stdgo.Ref<stdgo.go.types.Types.Pointer_>));
                                } else {
                                    var _base:Type_ = (null : stdgo.go.types.Types.Type_);
                                    if (!_underIs(_x._typ, function(_u:Type_):Bool {
                                        var __tmp__ = try {
                                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_u) : stdgo.Ref<Pointer_>)) : stdgo.Ref<Pointer_>), _1 : true };
                                        } catch(_) {
                                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>), _1 : false };
                                        }, _p = __tmp__._0, __493 = __tmp__._1;
                                        if (_p == null || (_p : Dynamic).__nil__) {
                                            _check._errorf(stdgo.Go.asInterface(_x), (50 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot indirect %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                                            return false;
                                        };
                                        if ((_base != null) && !identical(_p._base, _base)) {
                                            _check._errorf(stdgo.Go.asInterface(_x), (50 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: pointers of %s must have identical base types" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                                            return false;
                                        };
                                        _base = _p._base;
                                        return true;
                                    })) {
                                        @:goto "Error";
                                    };
                                    _x._mode = (5 : stdgo.go.types.Types.T_operandMode);
                                    _x._typ = _base;
                                };
                            };
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>))) {
                            var _e:stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__().value;
                            _check._unary(_x, _e);
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                @:goto "Error";
                            };
                            if (_e.op == ((36 : stdgo.go.token.Token.Token))) {
                                _x._expr = stdgo.Go.asInterface(_e);
                                return (2 : stdgo.go.types.Types.T_exprKind);
                            };
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>))) {
                            var _e:stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__().value;
                            _check._binary(_x, stdgo.Go.asInterface(_e), _e.x, _e.y, _e.op, _e.opPos);
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                @:goto "Error";
                            };
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>))) {
                            var _e:stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>) : __type__.__underlying__().value;
                            _check._error(stdgo.Go.asInterface(_e), (-1 : stdgo.internal.types.errors.Errors.Code), ("no key:value expected" : stdgo.GoString));
                            @:goto "Error";
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ArrayType>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.StructType>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.FuncType>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.InterfaceType>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.MapType>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ChanType>))) {
                            var _e:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                            _x._mode = (3 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = _check._environment._sig._recv._object._typ(_e);
                        } else {
                            var _e:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                            throw stdgo.Go.toInterface(stdgo.fmt.Fmt.sprintf(("%s: unknown expression type %T" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_check._fset.position(_e.pos()))), stdgo.Go.toInterface(_e)));
                        };
                        break;
                    };
                };
            };
            _x._expr = _e;
            return (1 : stdgo.go.types.Types.T_exprKind);
            @:label("Error") _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            _x._expr = _e;
            return (2 : stdgo.go.types.Types.T_exprKind);
        });
        throw "controlFlow did not return";
    }
    /**
        // If x is a generic type, or a generic function whose type arguments cannot be inferred
        // from a non-nil target type T, nonGeneric reports an error and invalidates x.mode and x.typ.
        // Otherwise it leaves x alone.
    **/
    @:keep
    static public function _nonGeneric( _check:stdgo.Ref<Checker>, t:Type_, _x:stdgo.Ref<T_operand>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if ((_x._mode == (0 : stdgo.go.types.Types.T_operandMode)) || (_x._mode == (1 : stdgo.go.types.Types.T_operandMode))) {
            return;
        };
        var _what:stdgo.GoString = ("" : stdgo.GoString);
        {
            final __type__ = _x._typ;
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Named>))) {
                var _t:stdgo.Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                if (_isGeneric(stdgo.Go.asInterface(_t))) {
                    _what = ("type" : stdgo.GoString);
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Signature>))) {
                var _t:stdgo.Ref<stdgo.go.types.Types.Signature> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__().value;
                if (_t._tparams != null && ((_t._tparams : Dynamic).__nil__ == null || !(_t._tparams : Dynamic).__nil__)) {
                    if (true && (t != null)) {
                        {
                            var __tmp__ = try {
                                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(t)) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>), _1 : true };
                            } catch(_) {
                                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Signature>), _1 : false };
                            }, _tsig = __tmp__._0, __0 = __tmp__._1;
                            if (_tsig != null && ((_tsig : Dynamic).__nil__ == null || !(_tsig : Dynamic).__nil__)) {
                                _check._funcInst(_tsig, _x.pos(), _x, null, true);
                                return;
                            };
                        };
                    };
                    _what = ("function" : stdgo.GoString);
                };
            };
        };
        if (_what != (stdgo.Go.str())) {
            _check._errorf(_x._expr, (137 : stdgo.internal.types.errors.Errors.Code), ("cannot use generic %s %s without instantiation" : stdgo.GoString), stdgo.Go.toInterface(_what), stdgo.Go.toInterface(_x._expr));
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            _x._typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
        };
    }
    /**
        // rawExpr typechecks expression e and initializes x with the expression
        // value or type. If an error occurred, x.mode is set to invalid.
        // If a non-nil target type T is given and e is a generic function
        // or function call, T is used to infer the type arguments for e.
        // If hint != nil, it is the type of a composite literal element.
        // If allowGeneric is set, the operand type may be an uninstantiated
        // parameterized type or function value.
    **/
    @:keep
    static public function _rawExpr( _check:stdgo.Ref<Checker>, t:Type_, _x:stdgo.Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _hint:Type_, _allowGeneric:Bool):T_exprKind {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            if (_check._conf.__Trace) {
                _check._trace(_e.pos(), ("-- expr %s" : stdgo.GoString), stdgo.Go.toInterface(_e));
                _check._indent++;
                __deferstack__.unshift(() -> {
                    var a = function():Void {
                        _check._indent--;
                        _check._trace(_e.pos(), ("=> %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                    };
                    a();
                });
            };
            var _kind:stdgo.go.types.Types.T_exprKind = _check._exprInternal(t, _x, _e, _hint);
            if (!_allowGeneric) {
                _check._nonGeneric(t, _x);
            };
            _check._record(_x);
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _kind;
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return ((0 : stdgo.GoInt) : stdgo.go.types.Types.T_exprKind);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return ((0 : stdgo.GoInt) : stdgo.go.types.Types.T_exprKind);
        };
    }
    /**
        // matchTypes attempts to convert any untyped types x and y such that they match.
        // If an error occurs, x.mode is set to invalid.
    **/
    @:keep
    static public function _matchTypes( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _y:stdgo.Ref<T_operand>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _mayConvert = function(_x:stdgo.Ref<T_operand>, _y:stdgo.Ref<T_operand>):Bool {
            if (_isTyped(_x._typ) && _isTyped(_y._typ)) {
                return false;
            };
            if (_isNonTypeParamInterface(_x._typ) || _isNonTypeParamInterface(_y._typ)) {
                return true;
            };
            if (_allBoolean(_x._typ) != (_allBoolean(_y._typ))) {
                return false;
            };
            if (_allString(_x._typ) != (_allString(_y._typ))) {
                return false;
            };
            if (_x._isNil()) {
                return _hasNil(_y._typ);
            };
            if (_y._isNil()) {
                return _hasNil(_x._typ);
            };
            if (_isPointer(_x._typ) || _isPointer(_y._typ)) {
                return false;
            };
            return true;
        };
        if (_mayConvert(_x, _y)) {
            _check._convertUntyped(_x, _y._typ);
            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                return;
            };
            _check._convertUntyped(_y, _x._typ);
            if (_y._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                return;
            };
        };
    }
    /**
        // If e != nil, it must be the binary expression; it may be nil for non-constant expressions
        // (when invoked for an assignment operation where the binary expression is implicit).
    **/
    @:keep
    static public function _binary( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _lhs:stdgo.go.ast.Ast.Expr, _rhs:stdgo.go.ast.Ast.Expr, _op:stdgo.go.token.Token.Token, _opPos:stdgo.go.token.Token.Pos):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _y:T_operand = ({} : stdgo.go.types.Types.T_operand);
        _check._expr((null : stdgo.go.types.Types.Type_), _x, _lhs);
        _check._expr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_y) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _rhs);
        if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
            return;
        };
        if (_y._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            _x._expr = _y._expr;
            return;
        };
        if (_isShift(_op)) {
            _check._shift(_x, (stdgo.Go.setRef(_y) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _e, _op);
            return;
        };
        _check._matchTypes(_x, (stdgo.Go.setRef(_y) : stdgo.Ref<stdgo.go.types.Types.T_operand>));
        if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
            return;
        };
        if (_isComparison(_op)) {
            _check._comparison(_x, (stdgo.Go.setRef(_y) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _op, false);
            return;
        };
        if (!identical(_x._typ, _y._typ)) {
            if ((stdgo.Go.toInterface(_x._typ) != stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]))) && (stdgo.Go.toInterface(_y._typ) != stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                var _posn:T_positioner = stdgo.Go.asInterface(_x);
                if (_e != null) {
                    _posn = _e;
                };
                if (_e != null) {
                    _check._errorf(_posn, (46 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: %s (mismatched types %s and %s)" : stdgo.GoString), stdgo.Go.toInterface(_e), stdgo.Go.toInterface(_x._typ), stdgo.Go.toInterface(_y._typ));
                } else {
                    _check._errorf(_posn, (46 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: %s %s= %s (mismatched types %s and %s)" : stdgo.GoString), stdgo.Go.toInterface(_lhs), stdgo.Go.toInterface(stdgo.Go.asInterface(_op)), stdgo.Go.toInterface(_rhs), stdgo.Go.toInterface(_x._typ), stdgo.Go.toInterface(_y._typ));
                };
            };
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            return;
        };
        if (!_check._op(_binaryOpPredicates, _x, _op)) {
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            return;
        };
        if ((_op == (15 : stdgo.go.token.Token.Token)) || (_op == (16 : stdgo.go.token.Token.Token))) {
            if ((((_x._mode == (4 : stdgo.go.types.Types.T_operandMode)) || _allInteger(_x._typ)) && (_y._mode == (4 : stdgo.go.types.Types.T_operandMode))) && (stdgo.go.constant.Constant.sign(_y._val) == (0 : stdgo.GoInt))) {
                _check._error(stdgo.Go.asInterface((stdgo.Go.setRef(_y) : stdgo.Ref<stdgo.go.types.Types.T_operand>)), (47 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: division by zero" : stdgo.GoString));
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                return;
            };
            if (((_x._mode == (4 : stdgo.go.types.Types.T_operandMode)) && (_y._mode == (4 : stdgo.go.types.Types.T_operandMode))) && _isComplex(_x._typ)) {
                var __0:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.real(_y._val), __1:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.imag(_y._val), _im:stdgo.go.constant.Constant.Value = __1, _re:stdgo.go.constant.Constant.Value = __0;
                var __0:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.binaryOp(_re, (14 : stdgo.go.token.Token.Token), _re), __1:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.binaryOp(_im, (14 : stdgo.go.token.Token.Token), _im), _im2:stdgo.go.constant.Constant.Value = __1, _re2:stdgo.go.constant.Constant.Value = __0;
                if ((stdgo.go.constant.Constant.sign(_re2) == (0 : stdgo.GoInt)) && (stdgo.go.constant.Constant.sign(_im2) == (0 : stdgo.GoInt))) {
                    _check._error(stdgo.Go.asInterface((stdgo.Go.setRef(_y) : stdgo.Ref<stdgo.go.types.Types.T_operand>)), (47 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: division by zero" : stdgo.GoString));
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                    return;
                };
            };
        };
        if ((_x._mode == (4 : stdgo.go.types.Types.T_operandMode)) && (_y._mode == (4 : stdgo.go.types.Types.T_operandMode))) {
            if ((_x._val.kind() == (0 : stdgo.go.constant.Constant.Kind)) || (_y._val.kind() == (0 : stdgo.go.constant.Constant.Kind))) {
                _x._val = stdgo.go.constant.Constant.makeUnknown();
                return;
            };
            if ((_op == (15 : stdgo.go.token.Token.Token)) && _isInteger(_x._typ)) {
                _op = (26 : stdgo.go.token.Token.Token);
            };
            _x._val = stdgo.go.constant.Constant.binaryOp(_x._val, _op, _y._val);
            _x._expr = _e;
            _check._overflow(_x, _opPos);
            return;
        };
        _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
    }
    /**
        // If e != nil, it must be the shift expression; it may be nil for non-constant shifts.
    **/
    @:keep
    static public function _shift( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _y:stdgo.Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _op:stdgo.go.token.Token.Token):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _xval:stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
        if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
            _xval = stdgo.go.constant.Constant.toInt(_x._val);
        };
        if (_allInteger(_x._typ) || ((_isUntyped(_x._typ) && (_xval != null)) && (_xval.kind() == (3 : stdgo.go.constant.Constant.Kind)))) {} else {
            _check._errorf(stdgo.Go.asInterface(_x), (57 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: shifted operand %s must be integer" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            return;
        };
        var _yval:stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
        if (_y._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
            _yval = stdgo.go.constant.Constant.toInt(_y._val);
            if ((_yval.kind() == (3 : stdgo.go.constant.Constant.Kind)) && (stdgo.go.constant.Constant.sign(_yval) < (0 : stdgo.GoInt))) {
                _check._errorf(stdgo.Go.asInterface(_y), (56 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: negative shift count %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_y)));
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                return;
            };
            if (_isUntyped(_y._typ)) {
                _check._representable(_y, typ[((7 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                if (_y._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                    return;
                };
            };
        } else {
            if (_allInteger(_y._typ)) {
                if (!_allUnsigned(_y._typ) && !_check._verifyVersionf(stdgo.Go.asInterface(_y), _go1_13?.__copy__(), ("invalid operation: signed shift count %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_y)))) {
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                    return;
                };
            } else if (_isUntyped(_y._typ)) {
                _check._convertUntyped(_y, stdgo.Go.asInterface(typ[((7 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]));
                if (_y._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                    return;
                };
            } else {
                _check._errorf(stdgo.Go.asInterface(_y), (56 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: shift count %s must be integer" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_y)));
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                return;
            };
        };
        if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
            if (_y._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
                if ((_x._val.kind() == (0 : stdgo.go.constant.Constant.Kind)) || (_y._val.kind() == (0 : stdgo.go.constant.Constant.Kind))) {
                    _x._val = stdgo.go.constant.Constant.makeUnknown();
                    if (!_isInteger(_x._typ)) {
                        _x._typ = stdgo.Go.asInterface(typ[((20 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                    };
                    return;
                };
                {};
                var __tmp__ = stdgo.go.constant.Constant.uint64Val(_yval), _s:stdgo.GoUInt64 = __tmp__._0, _ok:Bool = __tmp__._1;
                if (!_ok || (_s > (1074i64 : stdgo.GoUInt64))) {
                    _check._errorf(stdgo.Go.asInterface(_y), (56 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: invalid shift count %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_y)));
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                    return;
                };
                if (!_isInteger(_x._typ)) {
                    _x._typ = stdgo.Go.asInterface(typ[((20 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                };
                _x._val = stdgo.go.constant.Constant.shift(_xval, _op, (_s : stdgo.GoUInt));
                _x._expr = _e;
                var _opPos:stdgo.go.token.Token.Pos = _x.pos();
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_e) : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>)) : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>), _1 : false };
                    }, _b = __tmp__._0, __56 = __tmp__._1;
                    if (_b != null && ((_b : Dynamic).__nil__ == null || !(_b : Dynamic).__nil__)) {
                        _opPos = _b.opPos;
                    };
                };
                _check._overflow(_x, _opPos);
                return;
            };
            if (_isUntyped(_x._typ)) {
                {
                    var __tmp__ = (_check._untyped != null && _check._untyped.exists(_x._expr) ? { _0 : _check._untyped[_x._expr], _1 : true } : { _0 : ({} : stdgo.go.types.Types.T_exprInfo), _1 : false }), _info:stdgo.go.types.Types.T_exprInfo = __tmp__._0, _found:Bool = __tmp__._1;
                    if (_found) {
                        _info._isLhs = true;
                        _check._untyped[_x._expr] = _info?.__copy__();
                    };
                };
                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                return;
            };
        };
        if (!_allInteger(_x._typ)) {
            _check._errorf(stdgo.Go.asInterface(_x), (57 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: shifted operand %s must be integer" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            return;
        };
        _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
    }
    /**
        // kindString returns the type kind as a string.
    **/
    @:keep
    static public function _kindString( _check:stdgo.Ref<Checker>, _typ:Type_):stdgo.GoString {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        {
            final __type__ = _under(_typ);
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Array_>))) {
                return ("array" : stdgo.GoString);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Slice_>))) {
                return ("slice" : stdgo.GoString);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Struct>))) {
                return ("struct" : stdgo.GoString);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Pointer_>))) {
                return ("pointer" : stdgo.GoString);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Signature>))) {
                return ("func" : stdgo.GoString);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                if (_isTypeParam(_typ)) {
                    return _check._sprintf(("type parameter %s" : stdgo.GoString), stdgo.Go.toInterface(_typ))?.__copy__();
                };
                return ("interface" : stdgo.GoString);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Map_>))) {
                return ("map" : stdgo.GoString);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Chan>))) {
                return ("chan" : stdgo.GoString);
            } else {
                return _check._sprintf(("%s" : stdgo.GoString), stdgo.Go.toInterface(_typ))?.__copy__();
            };
        };
    }
    /**
        // incomparableCause returns a more specific cause why typ is not comparable.
        // If there is no more specific cause, the result is "".
    **/
    @:keep
    static public function _incomparableCause( _check:stdgo.Ref<Checker>, _typ:Type_):stdgo.GoString {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        {
            final __type__ = _under(_typ);
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Slice_>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Signature>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Map_>))) {
                return _check._kindString(_typ) + (" can only be compared to nil" : stdgo.GoString)?.__copy__()?.__copy__();
            };
        };
        var _cause:stdgo.GoString = ("" : stdgo.GoString);
        _comparable(_typ, true, (null : stdgo.GoMap<stdgo.go.types.Types.Type_, Bool>), function(_format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):Void {
            _cause = _check._sprintf(_format?.__copy__(), ..._args.__toArray__())?.__copy__();
        });
        return _cause?.__copy__();
    }
    /**
        // If switchCase is true, the operator op is ignored.
    **/
    @:keep
    static public function _comparison( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _y:stdgo.Ref<T_operand>, _op:stdgo.go.token.Token.Token, _switchCase:Bool):Void {
        stdgo.internal.Macro.controlFlow({
            @:recv var _check:stdgo.Ref<Checker> = _check;
            if ((stdgo.Go.toInterface(_x._typ) == stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]))) || (stdgo.Go.toInterface(_y._typ) == stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                return;
            };
            if (_switchCase) {
                _op = (39 : stdgo.go.token.Token.Token);
            };
            var _errOp = _x;
            var _cause:stdgo.GoString = stdgo.Go.str()?.__copy__();
            var _code:stdgo.internal.types.errors.Errors.Code = (46 : stdgo.internal.types.errors.Errors.Code);
            var __tmp__ = _x._assignableTo(_check, _y._typ, (null : stdgo.Pointer<stdgo.GoString>)), _ok:Bool = __tmp__._0, __0:stdgo.internal.types.errors.Errors.Code = __tmp__._1;
            if (!_ok) {
                {
                    var __tmp__ = _y._assignableTo(_check, _x._typ, (null : stdgo.Pointer<stdgo.GoString>));
                    _ok = __tmp__._0;
                };
            };
            if (!_ok) {
                _errOp = _y;
                _cause = _check._sprintf(("mismatched types %s and %s" : stdgo.GoString), stdgo.Go.toInterface(_x._typ), stdgo.Go.toInterface(_y._typ))?.__copy__();
                @:goto "Error";
            };
            _code = (45 : stdgo.internal.types.errors.Errors.Code);
            {
                final __value__ = _op;
                if (__value__ == ((39 : stdgo.go.token.Token.Token)) || __value__ == ((44 : stdgo.go.token.Token.Token))) {
                    if (_x._isNil() || _y._isNil()) {
                        var _typ:stdgo.go.types.Types.Type_ = _x._typ;
                        if (_x._isNil()) {
                            _typ = _y._typ;
                        };
                        if (!_hasNil(_typ)) {
                            _errOp = _y;
                            @:goto "Error";
                        };
                    } else if (!comparable(_x._typ)) {
                        _errOp = _x;
                        _cause = _check._incomparableCause(_x._typ)?.__copy__();
                        @:goto "Error";
                    } else if (!comparable(_y._typ)) {
                        _errOp = _y;
                        _cause = _check._incomparableCause(_y._typ)?.__copy__();
                        @:goto "Error";
                    };
                } else if (__value__ == ((40 : stdgo.go.token.Token.Token)) || __value__ == ((45 : stdgo.go.token.Token.Token)) || __value__ == ((41 : stdgo.go.token.Token.Token)) || __value__ == ((46 : stdgo.go.token.Token.Token))) {
                    if (!_allOrdered(_x._typ)) {
                        _errOp = _x;
                        @:goto "Error";
                    } else if (!_allOrdered(_y._typ)) {
                        _errOp = _y;
                        @:goto "Error";
                    };
                } else {
                    _unreachable();
                };
            };
            if ((_x._mode == (4 : stdgo.go.types.Types.T_operandMode)) && (_y._mode == (4 : stdgo.go.types.Types.T_operandMode))) {
                _x._val = stdgo.go.constant.Constant.makeBool(stdgo.go.constant.Constant.compare(_x._val, _op, _y._val));
            } else {
                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                _check._updateExprType(_x._expr, default_(_x._typ), true);
                _check._updateExprType(_y._expr, default_(_y._typ), true);
            };
            _x._typ = stdgo.Go.asInterface(typ[((19 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
            return;
            @:label("Error") if (_cause == (stdgo.Go.str())) {
                if (_isTypeParam(_x._typ) || _isTypeParam(_y._typ)) {
                    if (!_isTypeParam(_x._typ)) {
                        _errOp = _y;
                    };
                    _cause = _check._sprintf(("type parameter %s is not comparable with %s" : stdgo.GoString), stdgo.Go.toInterface(_errOp._typ), stdgo.Go.toInterface(stdgo.Go.asInterface(_op)))?.__copy__();
                } else {
                    _cause = _check._sprintf(("operator %s not defined on %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_op)), stdgo.Go.toInterface(_check._kindString(_errOp._typ)))?.__copy__();
                };
            };
            if (_switchCase) {
                _check._errorf(stdgo.Go.asInterface(_x), _code, ("invalid case %s in switch on %s (%s)" : stdgo.GoString), stdgo.Go.toInterface(_x._expr), stdgo.Go.toInterface(_y._expr), stdgo.Go.toInterface(_cause));
            } else {
                _check._errorf(stdgo.Go.asInterface(_errOp), _code, ("invalid operation: %s %s %s (%s)" : stdgo.GoString), stdgo.Go.toInterface(_x._expr), stdgo.Go.toInterface(stdgo.Go.asInterface(_op)), stdgo.Go.toInterface(_y._expr), stdgo.Go.toInterface(_cause));
            };
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
        });
    }
    /**
        // implicitTypeAndValue returns the implicit type of x when used in a context
        // where the target type is expected. If no such implicit conversion is
        // possible, it returns a nil Type and non-zero error code.
        //
        // If x is a constant operand, the returned constant.Value will be the
        // representation of x in this context.
    **/
    @:keep
    static public function _implicitTypeAndValue( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _target:Type_):{ var _0 : Type_; var _1 : stdgo.go.constant.Constant.Value; var _2 : Code; } {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if (((_x._mode == (0 : stdgo.go.types.Types.T_operandMode)) || _isTyped(_x._typ)) || (stdgo.Go.toInterface(_target) == stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
            return { _0 : _x._typ, _1 : (null : stdgo.go.constant.Constant.Value), _2 : (0 : stdgo.internal.types.errors.Errors.Code) };
        };
        if (_isUntyped(_target)) {
            {
                var _m:stdgo.go.types.Types.Type_ = _maxType(_x._typ, _target);
                if (_m != null) {
                    return { _0 : _m, _1 : (null : stdgo.go.constant.Constant.Value), _2 : (0 : stdgo.internal.types.errors.Errors.Code) };
                };
            };
            return { _0 : (null : stdgo.go.types.Types.Type_), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (97 : stdgo.internal.types.errors.Errors.Code) };
        };
        {
            final __type__ = _under(_target);
            {
                var __bool__ = true;
                while (__bool__) {
                    __bool__ = false;
                    if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                        var _u:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                        if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
                            var __tmp__ = _check._representation(_x, _u), _v:stdgo.go.constant.Constant.Value = __tmp__._0, _code:stdgo.internal.types.errors.Errors.Code = __tmp__._1;
                            if (_code != ((0 : stdgo.internal.types.errors.Errors.Code))) {
                                return { _0 : (null : stdgo.go.types.Types.Type_), _1 : (null : stdgo.go.constant.Constant.Value), _2 : _code };
                            };
                            return { _0 : _target, _1 : _v, _2 : _code };
                        };
                        {
                            final __value__ = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_x._typ) : stdgo.Ref<Basic>)) : stdgo.Ref<Basic>)._kind;
                            if (__value__ == ((19 : stdgo.go.types.Types.BasicKind))) {
                                if (!_isBoolean(_target)) {
                                    return { _0 : (null : stdgo.go.types.Types.Type_), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (97 : stdgo.internal.types.errors.Errors.Code) };
                                };
                            } else if (__value__ == ((20 : stdgo.go.types.Types.BasicKind)) || __value__ == ((21 : stdgo.go.types.Types.BasicKind)) || __value__ == ((22 : stdgo.go.types.Types.BasicKind)) || __value__ == ((23 : stdgo.go.types.Types.BasicKind))) {
                                if (!_isNumeric(_target)) {
                                    return { _0 : (null : stdgo.go.types.Types.Type_), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (97 : stdgo.internal.types.errors.Errors.Code) };
                                };
                            } else if (__value__ == ((24 : stdgo.go.types.Types.BasicKind))) {
                                if (!_isString(_target)) {
                                    return { _0 : (null : stdgo.go.types.Types.Type_), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (97 : stdgo.internal.types.errors.Errors.Code) };
                                };
                            } else if (__value__ == ((25 : stdgo.go.types.Types.BasicKind))) {
                                if (!_hasNil(_target)) {
                                    return { _0 : (null : stdgo.go.types.Types.Type_), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (97 : stdgo.internal.types.errors.Errors.Code) };
                                };
                                return { _0 : stdgo.Go.asInterface(typ[((25 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (0 : stdgo.internal.types.errors.Errors.Code) };
                            } else {
                                return { _0 : (null : stdgo.go.types.Types.Type_), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (97 : stdgo.internal.types.errors.Errors.Code) };
                            };
                        };
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                        var _u:stdgo.Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                        if (_isTypeParam(_target)) {
                            if (!_u._typeSet()._underIs(function(_u:Type_):Bool {
                                if (_u == null) {
                                    return false;
                                };
                                var __tmp__ = _check._implicitTypeAndValue(_x, _u), _t:stdgo.go.types.Types.Type_ = __tmp__._0, __24:stdgo.go.constant.Constant.Value = __tmp__._1, __25:stdgo.internal.types.errors.Errors.Code = __tmp__._2;
                                return _t != null;
                            })) {
                                return { _0 : (null : stdgo.go.types.Types.Type_), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (97 : stdgo.internal.types.errors.Errors.Code) };
                            };
                            if (_x._isNil()) {
                                return { _0 : stdgo.Go.asInterface(typ[((25 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (0 : stdgo.internal.types.errors.Errors.Code) };
                            };
                            break;
                        };
                        if (_x._isNil()) {
                            return { _0 : stdgo.Go.asInterface(typ[((25 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (0 : stdgo.internal.types.errors.Errors.Code) };
                        };
                        if (!_u.empty()) {
                            return { _0 : (null : stdgo.go.types.Types.Type_), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (97 : stdgo.internal.types.errors.Errors.Code) };
                        };
                        return { _0 : default_(_x._typ), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (0 : stdgo.internal.types.errors.Errors.Code) };
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Pointer_>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Signature>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Slice_>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Map_>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Chan>))) {
                        var _u:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                        if (!_x._isNil()) {
                            return { _0 : (null : stdgo.go.types.Types.Type_), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (97 : stdgo.internal.types.errors.Errors.Code) };
                        };
                        return { _0 : stdgo.Go.asInterface(typ[((25 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (0 : stdgo.internal.types.errors.Errors.Code) };
                    } else {
                        var _u:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                        return { _0 : (null : stdgo.go.types.Types.Type_), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (97 : stdgo.internal.types.errors.Errors.Code) };
                    };
                    break;
                };
            };
        };
        return { _0 : _target, _1 : (null : stdgo.go.constant.Constant.Value), _2 : (0 : stdgo.internal.types.errors.Errors.Code) };
    }
    /**
        // updateExprVal updates the value of x to val.
    **/
    @:keep
    static public function _updateExprVal( _check:stdgo.Ref<Checker>, _x:stdgo.go.ast.Ast.Expr, _val:stdgo.go.constant.Constant.Value):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        {
            var __tmp__ = (_check._untyped != null && _check._untyped.exists(_x) ? { _0 : _check._untyped[_x], _1 : true } : { _0 : ({} : stdgo.go.types.Types.T_exprInfo), _1 : false }), _info:stdgo.go.types.Types.T_exprInfo = __tmp__._0, _ok:Bool = __tmp__._1;
            if (_ok) {
                _info._val = _val;
                _check._untyped[_x] = _info?.__copy__();
            };
        };
    }
    @:keep
    static public function _updateExprType0( _check:stdgo.Ref<Checker>, _parent:stdgo.go.ast.Ast.Expr, _x:stdgo.go.ast.Ast.Expr, _typ:Type_, _final:Bool):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var __tmp__ = (_check._untyped != null && _check._untyped.exists(_x) ? { _0 : _check._untyped[_x], _1 : true } : { _0 : ({} : stdgo.go.types.Types.T_exprInfo), _1 : false }), _old:stdgo.go.types.Types.T_exprInfo = __tmp__._0, _found:Bool = __tmp__._1;
        if (!_found) {
            return;
        };
        {
            final __type__ = _x;
            {
                var __bool__ = true;
                while (__bool__) {
                    __bool__ = false;
                    if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BadExpr>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.FuncLit>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.CompositeLit>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IndexExpr>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SliceExpr>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.TypeAssertExpr>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.StarExpr>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.KeyValueExpr>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ArrayType>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.StructType>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.FuncType>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.InterfaceType>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.MapType>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ChanType>))) {
                        var _x:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                        if (false) {
                            _check._dump(("%v: found old type(%s): %s (new: %s)" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x.pos())), stdgo.Go.toInterface(_x), stdgo.Go.toInterface(stdgo.Go.asInterface(_old._typ)), stdgo.Go.toInterface(_typ));
                            _unreachable();
                        };
                        return;
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>))) {
                        var _x:stdgo.Ref<stdgo.go.ast.Ast.CallExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>) : __type__.__underlying__().value;
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.Ident>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BasicLit>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>))) {
                        var _x:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>))) {
                        var _x:stdgo.Ref<stdgo.go.ast.Ast.ParenExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__().value;
                        _check._updateExprType0(stdgo.Go.asInterface(_x), _x.x, _typ, _final);
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>))) {
                        var _x:stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__().value;
                        if (_old._val != null) {
                            break;
                        };
                        _check._updateExprType0(stdgo.Go.asInterface(_x), _x.x, _typ, _final);
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>))) {
                        var _x:stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__().value;
                        if (_old._val != null) {
                            break;
                        };
                        if (_isComparison(_x.op)) {} else if (_isShift(_x.op)) {
                            _check._updateExprType0(stdgo.Go.asInterface(_x), _x.x, _typ, _final);
                        } else {
                            _check._updateExprType0(stdgo.Go.asInterface(_x), _x.x, _typ, _final);
                            _check._updateExprType0(stdgo.Go.asInterface(_x), _x.y, _typ, _final);
                        };
                    } else {
                        var _x:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                        _unreachable();
                    };
                    break;
                };
            };
        };
        if (!_final && _isUntyped(_typ)) {
            _old._typ = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_typ)) : stdgo.Ref<Basic>)) : stdgo.Ref<Basic>);
            _check._untyped[_x] = _old?.__copy__();
            return;
        };
        if (_check._untyped != null) _check._untyped.remove(_x);
        if (_old._isLhs) {
            if (!_allInteger(_typ)) {
                _check._errorf(_x, (57 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: shifted operand %s (type %s) must be integer" : stdgo.GoString), stdgo.Go.toInterface(_x), stdgo.Go.toInterface(_typ));
                return;
            };
        };
        if (_old._val != null) {
            var _c:stdgo.go.types.Types.T_operand = (new stdgo.go.types.Types.T_operand(_old._mode, _x, stdgo.Go.asInterface(_old._typ), _old._val, (0 : stdgo.go.types.Types.T_builtinId)) : stdgo.go.types.Types.T_operand);
            _check._convertUntyped((stdgo.Go.setRef(_c) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _typ);
            if (_c._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                return;
            };
        };
        _check._recordTypeAndValue(_x, _old._mode, _typ, _old._val);
    }
    /**
        // updateExprType updates the type of x to typ and invokes itself
        // recursively for the operands of x, depending on expression kind.
        // If typ is still an untyped and not the final type, updateExprType
        // only updates the recorded untyped type for x and possibly its
        // operands. Otherwise (i.e., typ is not an untyped type anymore,
        // or it is the final type for x), the type and value are recorded.
        // Also, if x is a constant, it must be representable as a value of typ,
        // and if x is the (formerly untyped) lhs operand of a non-constant
        // shift, it must be an integer value.
    **/
    @:keep
    static public function _updateExprType( _check:stdgo.Ref<Checker>, _x:stdgo.go.ast.Ast.Expr, _typ:Type_, _final:Bool):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _check._updateExprType0((null : stdgo.go.ast.Ast.Expr), _x, _typ, _final);
    }
    /**
        // The unary expression e may be nil. It's passed in for better error messages only.
    **/
    @:keep
    static public function _unary( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _e:stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _check._expr((null : stdgo.go.types.Types.Type_), _x, _e.x);
        if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
            return;
        };
        var _op:stdgo.go.token.Token.Token = _e.op;
        {
            final __value__ = _op;
            if (__value__ == ((17 : stdgo.go.token.Token.Token))) {
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_unparen(_e.x)) : stdgo.Ref<stdgo.go.ast.Ast.CompositeLit>)) : stdgo.Ref<stdgo.go.ast.Ast.CompositeLit>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.CompositeLit>), _1 : false };
                    }, __8 = __tmp__._0, _ok = __tmp__._1;
                    if (!_ok && (_x._mode != (5 : stdgo.go.types.Types.T_operandMode))) {
                        _check._errorf(stdgo.Go.asInterface(_x), (49 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot take address of %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                        _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                        return;
                    };
                };
                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                _x._typ = stdgo.Go.asInterface((stdgo.Go.setRef(({ _base : _x._typ } : stdgo.go.types.Types.Pointer_)) : stdgo.Ref<stdgo.go.types.Types.Pointer_>));
                return;
            } else if (__value__ == ((36 : stdgo.go.token.Token.Token))) {
                var _u:stdgo.go.types.Types.Type_ = _coreType(_x._typ);
                if (_u == null) {
                    _check._errorf(stdgo.Go.asInterface(_x), (58 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot receive from %s (no core type)" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                    return;
                };
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_u) : stdgo.Ref<Chan>)) : stdgo.Ref<Chan>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Chan>), _1 : false };
                }, _ch = __tmp__._0, __25 = __tmp__._1;
                if (_ch == null || (_ch : Dynamic).__nil__) {
                    _check._errorf(stdgo.Go.asInterface(_x), (58 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot receive from non-channel %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                    return;
                };
                if (_ch._dir == ((1 : stdgo.go.types.Types.ChanDir))) {
                    _check._errorf(stdgo.Go.asInterface(_x), (58 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot receive from send-only channel %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                    return;
                };
                _x._mode = (8 : stdgo.go.types.Types.T_operandMode);
                _x._typ = _ch._elem;
                _check._environment._hasCallOrRecv = true;
                return;
            } else if (__value__ == ((88 : stdgo.go.token.Token.Token))) {
                if (!_allInteger(_x._typ)) {
                    _check._error(stdgo.Go.asInterface(_e), (45 : stdgo.internal.types.errors.Errors.Code), ("cannot use ~ outside of interface or type constraint" : stdgo.GoString));
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                    return;
                };
                _check._error(stdgo.Go.asInterface(_e), (45 : stdgo.internal.types.errors.Errors.Code), ("cannot use ~ outside of interface or type constraint (use ^ for bitwise complement)" : stdgo.GoString));
                _op = (19 : stdgo.go.token.Token.Token);
            };
        };
        if (!_check._op(_unaryOpPredicates, _x, _op)) {
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            return;
        };
        if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
            if (_x._val.kind() == ((0 : stdgo.go.constant.Constant.Kind))) {
                return;
            };
            var _prec:stdgo.GoUInt = (0 : stdgo.GoUInt);
            if (_isUnsigned(_x._typ)) {
                _prec = (_check._conf._sizeof(_x._typ) * (8i64 : stdgo.GoInt64) : stdgo.GoUInt);
            };
            _x._val = stdgo.go.constant.Constant.unaryOp(_op, _x._val, _prec);
            _x._expr = stdgo.Go.asInterface(_e);
            _check._overflow(_x, _x.pos());
            return;
        };
        _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
    }
    @:keep
    static public function _op( _check:stdgo.Ref<Checker>, _m:T_opPredicates, _x:stdgo.Ref<T_operand>, _op:stdgo.go.token.Token.Token):Bool {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        {
            var _pred:stdgo.go.types.Types.Type_ -> Bool = (_m[_op] ?? null);
            if (_pred != null) {
                if (!_pred(_x._typ)) {
                    _check._errorf(stdgo.Go.asInterface(_x), (45 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: operator %s not defined on %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_op)), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                    return false;
                };
            } else {
                _check._errorf(stdgo.Go.asInterface(_x), (-1 : stdgo.internal.types.errors.Errors.Code), ("unknown operator %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_op)));
                return false;
            };
        };
        return true;
    }
    @:keep
    static public function _versionErrorf( _check:stdgo.Ref<Checker>, _at:T_positioner, _v:T_version, _format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):Void {
        var _args = new stdgo.Slice<stdgo.AnyInterface>(_args.length, 0, ..._args);
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _msg:stdgo.GoString = _check._sprintf(_format?.__copy__(), ..._args.__toArray__())?.__copy__();
        var _err:stdgo.Ref<T_error_> = (null : stdgo.Ref<stdgo.go.types.Types.T_error_>);
        _err = _newErrorf(_at, (135 : stdgo.internal.types.errors.Errors.Code), ("%s requires %s or later" : stdgo.GoString), stdgo.Go.toInterface(_msg), stdgo.Go.toInterface(stdgo.Go.asInterface(_v)));
        _check._report(_err);
    }
    @:keep
    static public function _softErrorf( _check:stdgo.Ref<Checker>, _at:T_positioner, _code:Code, _format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):Void {
        var _args = new stdgo.Slice<stdgo.AnyInterface>(_args.length, 0, ..._args);
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _err = _newErrorf(_at, _code, _format?.__copy__(), ..._args.__toArray__());
        _err._soft = true;
        _check._report(_err);
    }
    @:keep
    static public function _errorf( _check:stdgo.Ref<Checker>, _at:T_positioner, _code:Code, _format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):Void {
        var _args = new stdgo.Slice<stdgo.AnyInterface>(_args.length, 0, ..._args);
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _check._report(_newErrorf(_at, _code, _format?.__copy__(), ..._args.__toArray__()));
    }
    @:keep
    static public function _error( _check:stdgo.Ref<Checker>, _at:T_positioner, _code:Code, _msg:stdgo.GoString):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _check._report(_newErrorf(_at, _code, ("%s" : stdgo.GoString), stdgo.Go.toInterface(_msg)));
    }
    /**
        // Report records the error pointed to by errp, setting check.firstError if
        // necessary.
    **/
    @:keep
    static public function _report( _check:stdgo.Ref<Checker>, _errp:stdgo.Ref<T_error_>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if (_errp._empty()) {
            throw stdgo.Go.toInterface(("empty error details" : stdgo.GoString));
        };
        var _msg:stdgo.GoString = _errp._msg(_check._fset, _check._qualifier)?.__copy__();
        {
            final __value__ = _errp._code;
            if (__value__ == ((-1 : stdgo.internal.types.errors.Errors.Code))) {
                _msg = ("invalid AST: " : stdgo.GoString) + _msg?.__copy__()?.__copy__();
            } else if (__value__ == ((0 : stdgo.internal.types.errors.Errors.Code))) {
                throw stdgo.Go.toInterface(("no error code provided" : stdgo.GoString));
            };
        };
        if ((_errp._code != (0 : stdgo.internal.types.errors.Errors.Code)) && (_check._conf.__ErrorURL != stdgo.Go.str())) {
            var _u:stdgo.GoString = stdgo.fmt.Fmt.sprintf(_check._conf.__ErrorURL?.__copy__(), stdgo.Go.toInterface(stdgo.Go.asInterface(_errp._code)))?.__copy__();
            {
                var _i:stdgo.GoInt = stdgo.strings.Strings.index(_msg?.__copy__(), ("\n" : stdgo.GoString));
                if (_i >= (0 : stdgo.GoInt)) {
                    _msg = (_msg.__slice__(0, _i) : stdgo.GoString) + _u?.__copy__() + (_msg.__slice__(_i) : stdgo.GoString)?.__copy__()?.__copy__();
                } else {
                    _msg = _msg + (_u)?.__copy__();
                };
            };
        };
        var _span:stdgo.go.types.Types.T_posSpan = _spanOf(_errp._desc[(0 : stdgo.GoInt)]._posn)?.__copy__();
        var _e:stdgo.go.types.Types.Error = ({ fset : _check._fset, pos : _span._pos, msg : _msg?.__copy__(), soft : _errp._soft, _go116code : _errp._code, _go116start : _span._start, _go116end : _span._end } : stdgo.go.types.Types.Error);
        var _isInvalidErr:Bool = (stdgo.strings.Strings.index(_e.msg?.__copy__(), ("invalid operand" : stdgo.GoString)) > (0 : stdgo.GoInt)) || (stdgo.strings.Strings.index(_e.msg?.__copy__(), ("invalid type" : stdgo.GoString)) > (0 : stdgo.GoInt));
        if ((_check._firstErr != null) && _isInvalidErr) {
            return;
        };
        _e.msg = _stripAnnotations(_e.msg?.__copy__())?.__copy__();
        if (_check._environment._errpos != null) {
            var _span:stdgo.go.types.Types.T_posSpan = _spanOf(_check._environment._errpos)?.__copy__();
            _e.pos = _span._pos;
            _e._go116start = _span._start;
            _e._go116end = _span._end;
        };
        var _err:stdgo.go.types.Types.Error = _e?.__copy__();
        if (_check._firstErr == null) {
            _check._firstErr = stdgo.Go.asInterface(_err);
        };
        if (_check._conf.__Trace) {
            var _pos:stdgo.go.token.Token.Pos = _e.pos;
            var _msg:stdgo.GoString = _e.msg?.__copy__();
            _check._trace(_pos, ("ERROR: %s" : stdgo.GoString), stdgo.Go.toInterface(_msg));
        };
        var _f:stdgo.Error -> Void = _check._conf.error;
        if (_f == null) {
            throw stdgo.Go.toInterface((new stdgo.go.types.Types.T_bailout() : stdgo.go.types.Types.T_bailout));
        };
        _f(stdgo.Go.asInterface(_err));
    }
    /**
        // dump is only needed for debugging
    **/
    @:keep
    static public function _dump( _check:stdgo.Ref<Checker>, _format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):Void {
        var _args = new stdgo.Slice<stdgo.AnyInterface>(_args.length, 0, ..._args);
        @:recv var _check:stdgo.Ref<Checker> = _check;
        stdgo.fmt.Fmt.println(stdgo.Go.toInterface(stdgo.go.types.Types._sprintf(_check._fset, _check._qualifier, true, _format?.__copy__(), ..._args.__toArray__())));
    }
    @:keep
    static public function _trace( _check:stdgo.Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):Void {
        var _args = new stdgo.Slice<stdgo.AnyInterface>(_args.length, 0, ..._args);
        @:recv var _check:stdgo.Ref<Checker> = _check;
        stdgo.fmt.Fmt.printf(("%s:\t%s%s\n" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_check._fset.position(_pos))), stdgo.Go.toInterface(stdgo.strings.Strings.repeat((".  " : stdgo.GoString), _check._indent)), stdgo.Go.toInterface(stdgo.go.types.Types._sprintf(_check._fset, _check._qualifier, true, _format?.__copy__(), ..._args.__toArray__())));
    }
    /**
        // check may be nil.
    **/
    @:keep
    static public function _sprintf( _check:stdgo.Ref<Checker>, _format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):stdgo.GoString {
        var _args = new stdgo.Slice<stdgo.AnyInterface>(_args.length, 0, ..._args);
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _fset:stdgo.Ref<stdgo.go.token.Token.FileSet> = (null : stdgo.Ref<stdgo.go.token.Token.FileSet>);
        var _qf:Qualifier = (null : stdgo.go.types.Types.Qualifier);
        if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
            _fset = _check._fset;
            _qf = _check._qualifier;
        };
        return stdgo.go.types.Types._sprintf(_fset, _qf, false, _format?.__copy__(), ..._args.__toArray__())?.__copy__();
    }
    /**
        // markImports recursively walks pkg and its imports, to record unique import
        // paths in pkgPathMap.
    **/
    @:keep
    static public function _markImports( _check:stdgo.Ref<Checker>, _pkg:stdgo.Ref<Package>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if ((_check._seenPkgMap[_pkg] ?? false)) {
            return;
        };
        _check._seenPkgMap[_pkg] = true;
        var __tmp__ = (_check._pkgPathMap != null && _check._pkgPathMap.exists(_pkg._name?.__copy__()) ? { _0 : _check._pkgPathMap[_pkg._name?.__copy__()], _1 : true } : { _0 : (null : stdgo.GoMap<stdgo.GoString, Bool>), _1 : false }), _forName:stdgo.GoMap<stdgo.GoString, Bool> = __tmp__._0, _ok:Bool = __tmp__._1;
        if (!_ok) {
            _forName = ({
                final x = new stdgo.GoMap.GoStringMap<Bool>();
                x.__defaultValue__ = () -> false;
                @:mergeBlock {};
                x;
            } : stdgo.GoMap<stdgo.GoString, Bool>);
            _check._pkgPathMap[_pkg._name] = _forName;
        };
        _forName[_pkg._path] = true;
        for (__40 => _imp in _pkg._imports) {
            _check._markImports(_imp);
        };
    }
    @:keep
    static public function _qualifier( _check:stdgo.Ref<Checker>, _pkg:stdgo.Ref<Package>):stdgo.GoString {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if (_pkg != (_check._pkg)) {
            if (_check._pkgPathMap == null) {
                _check._pkgPathMap = ({
                    final x = new stdgo.GoMap.GoStringMap<stdgo.GoMap<stdgo.GoString, Bool>>();
                    x.__defaultValue__ = () -> (null : stdgo.GoMap<stdgo.GoString, Bool>);
                    @:mergeBlock {};
                    x;
                } : stdgo.GoMap<stdgo.GoString, stdgo.GoMap<stdgo.GoString, Bool>>);
                _check._seenPkgMap = ({
                    final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.types.Types.Package>, Bool>();
                    @:mergeBlock {};
                    cast x;
                } : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Package>, Bool>);
                _check._markImports(_check._pkg);
            };
            if (((_check._pkgPathMap[_pkg._name] ?? (null : stdgo.GoMap<stdgo.GoString, Bool>)).length) > (1 : stdgo.GoInt)) {
                return stdgo.strconv.Strconv.quote(_pkg._path?.__copy__())?.__copy__();
            };
            return _pkg._name?.__copy__();
        };
        return stdgo.Go.str()?.__copy__();
    }
    @:keep
    static public function _declStmt( _check:stdgo.Ref<Checker>, _d:stdgo.go.ast.Ast.Decl):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _pkg = _check._pkg;
        _check._walkDecl(_d, function(_d:T_decl):Void {
            {
                final __type__ = _d;
                {
                    var __bool__ = true;
                    while (__bool__) {
                        __bool__ = false;
                        if (stdgo.Go.typeEquals((__type__ : T_constDecl))) {
                            var _d:stdgo.go.types.Types.T_constDecl = __type__ == null ? ({} : stdgo.go.types.Types.T_constDecl) : __type__.__underlying__() == null ? ({} : stdgo.go.types.Types.T_constDecl) : __type__ == null ? ({} : stdgo.go.types.Types.T_constDecl) : __type__.__underlying__().value;
                            var _top:stdgo.GoInt = (_check._delayed.length);
                            var _lhs = new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Const>>((_d._spec.names.length : stdgo.GoInt).toBasic(), 0);
                            for (_i => _name in _d._spec.names) {
                                var _obj = newConst(_name.pos(), _pkg, _name.name?.__copy__(), (null : stdgo.go.types.Types.Type_), stdgo.go.constant.Constant.makeInt64((_d._iota : stdgo.GoInt64)));
                                _lhs[(_i : stdgo.GoInt)] = _obj;
                                var _init:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
                                if (_i < (_d._init.length)) {
                                    _init = _d._init[(_i : stdgo.GoInt)];
                                };
                                _check._constDecl(_obj, _d._typ, _init, _d._inherited);
                            };
                            _check._processDelayed(_top);
                            var _scopePos:stdgo.go.token.Token.Pos = _d._spec.end();
                            for (_i => _name in _d._spec.names) {
                                _check._declare(_check._pkg._scope, _name, stdgo.Go.asInterface(_lhs[(_i : stdgo.GoInt)]), _scopePos);
                            };
                        } else if (stdgo.Go.typeEquals((__type__ : T_varDecl))) {
                            var _d:stdgo.go.types.Types.T_varDecl = __type__ == null ? ({} : stdgo.go.types.Types.T_varDecl) : __type__.__underlying__() == null ? ({} : stdgo.go.types.Types.T_varDecl) : __type__ == null ? ({} : stdgo.go.types.Types.T_varDecl) : __type__.__underlying__().value;
                            var _top:stdgo.GoInt = (_check._delayed.length);
                            var _lhs0 = new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>((_d._spec.names.length : stdgo.GoInt).toBasic(), 0);
                            for (_i => _name in _d._spec.names) {
                                _lhs0[(_i : stdgo.GoInt)] = newVar(_name.pos(), _pkg, _name.name?.__copy__(), (null : stdgo.go.types.Types.Type_));
                            };
                            for (_i => _obj in _lhs0) {
                                var _lhs:stdgo.Slice<stdgo.Ref<Var>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>);
                                var _init:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
                                {
                                    final __value__ = (_d._spec.values.length);
                                    if (__value__ == ((_d._spec.names.length))) {
                                        _init = _d._spec.values[(_i : stdgo.GoInt)];
                                    } else if (__value__ == ((1 : stdgo.GoInt))) {
                                        _lhs = _lhs0;
                                        _init = _d._spec.values[(0 : stdgo.GoInt)];
                                    } else {
                                        if (_i < (_d._spec.values.length)) {
                                            _init = _d._spec.values[(_i : stdgo.GoInt)];
                                        };
                                    };
                                };
                                _check._varDecl(_obj, _lhs, _d._spec.type, _init);
                                if ((_d._spec.values.length) == ((1 : stdgo.GoInt))) {
                                    if (false) {
                                        for (__72 => _obj in _lhs0) {
                                            _assert(_obj._object._typ != null);
                                        };
                                    };
                                    break;
                                };
                            };
                            _check._processDelayed(_top);
                            var _scopePos:stdgo.go.token.Token.Pos = _d._spec.end();
                            for (_i => _name in _d._spec.names) {
                                _check._declare(_check._pkg._scope, _name, stdgo.Go.asInterface(_lhs0[(_i : stdgo.GoInt)]), _scopePos);
                            };
                        } else if (stdgo.Go.typeEquals((__type__ : T_typeDecl))) {
                            var _d:stdgo.go.types.Types.T_typeDecl = __type__ == null ? ({} : stdgo.go.types.Types.T_typeDecl) : __type__.__underlying__() == null ? ({} : stdgo.go.types.Types.T_typeDecl) : __type__ == null ? ({} : stdgo.go.types.Types.T_typeDecl) : __type__.__underlying__().value;
                            var _obj = newTypeName(_d._spec.name.pos(), _pkg, _d._spec.name.name?.__copy__(), (null : stdgo.go.types.Types.Type_));
                            var _scopePos:stdgo.go.token.Token.Pos = _d._spec.name.pos();
                            _check._declare(_check._pkg._scope, _d._spec.name, stdgo.Go.asInterface(_obj), _scopePos);
                            _obj._setColor((2u32 : stdgo.go.types.Types.T_color) + (_check._push(stdgo.Go.asInterface(_obj)) : T_color));
                            _check._typeDecl(_obj, _d._spec, null);
                            _check._pop()._setColor((1u32 : stdgo.go.types.Types.T_color));
                        } else {
                            var _d:stdgo.go.types.Types.T_decl = __type__ == null ? (null : stdgo.go.types.Types.T_decl) : cast __type__;
                            _check._errorf(_d._node(), (-1 : stdgo.internal.types.errors.Errors.Code), ("unknown ast.Decl node %T" : stdgo.GoString), stdgo.Go.toInterface(_d._node()));
                        };
                        break;
                    };
                };
            };
        });
    }
    @:keep
    static public function _funcDecl( _check:stdgo.Ref<Checker>, _obj:stdgo.Ref<Func>, _decl:stdgo.Ref<T_declInfo>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _assert(_obj._object._typ == null);
        _assert(_check._environment._iota == null);
        var _sig = (stdgo.Go.setRef(({} : stdgo.go.types.Types.Signature)) : stdgo.Ref<stdgo.go.types.Types.Signature>);
        _obj._object._typ = stdgo.Go.asInterface(_sig);
        var _saved:stdgo.go.types.Types.T_color = _obj._object._color_;
        _obj._object._color_ = (1u32 : stdgo.go.types.Types.T_color);
        var _fdecl = _decl._fdecl;
        _check._funcType(_sig, _fdecl.recv, _fdecl.type);
        _obj._object._color_ = _saved;
        if ((_fdecl.type.typeParams.numFields() > (0 : stdgo.GoInt)) && (_fdecl.body == null) || (_fdecl.body : Dynamic).__nil__) {
            _check._softErrorf(stdgo.Go.asInterface(_fdecl.name), (131 : stdgo.internal.types.errors.Errors.Code), ("generic function is missing function body" : stdgo.GoString));
        };
        if (!_check._conf.ignoreFuncBodies && ((_fdecl.body != null) && ((_fdecl.body : Dynamic).__nil__ == null || !(_fdecl.body : Dynamic).__nil__))) {
            _check._later(function():Void {
                _check._funcBody(_decl, _obj._object._name?.__copy__(), _sig, _fdecl.body, (null : stdgo.go.constant.Constant.Value));
            })._describef(stdgo.Go.asInterface(_obj), ("func %s" : stdgo.GoString), stdgo.Go.toInterface(_obj._object._name));
        };
    }
    @:keep
    static public function _checkFieldUniqueness( _check:stdgo.Ref<Checker>, _base:stdgo.Ref<Named>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_base._under()) : stdgo.Ref<Struct>)) : stdgo.Ref<Struct>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Struct>), _1 : false };
            }, _t = __tmp__._0, __8 = __tmp__._1;
            if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                var _mset:T_objset = (null : stdgo.go.types.Types.T_objset);
                {
                    var _i:stdgo.GoInt = (0 : stdgo.GoInt);
                    stdgo.Go.cfor(_i < _base.numMethods(), _i++, {
                        var _m = _base.method(_i);
                        _assert(_m._object._name != (("_" : stdgo.GoString)));
                        _assert(_mset._insert(stdgo.Go.asInterface(_m)) == null);
                    });
                };
                for (__25 => _fld in _t._fields) {
                    if (_fld._object._name != (("_" : stdgo.GoString))) {
                        {
                            var _alt:stdgo.go.types.Types.Object = _mset._insert(stdgo.Go.asInterface(_fld));
                            if (_alt != null) {
                                (stdgo.Go.typeAssert((stdgo.Go.toInterface(_alt) : stdgo.Ref<Func>)) : stdgo.Ref<Func>);
                                _check._errorf(_alt, (33 : stdgo.internal.types.errors.Errors.Code), ("field and method with the same name %s" : stdgo.GoString), stdgo.Go.toInterface(_fld._object._name));
                                _check._reportAltDecl(stdgo.Go.asInterface(_fld));
                            };
                        };
                    };
                };
            };
        };
    }
    @:keep
    static public function _collectMethods( _check:stdgo.Ref<Checker>, _obj:stdgo.Ref<TypeName>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _methods = (_check._methods[_obj] ?? (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>));
        if (_methods == null) {
            return;
        };
        if (_check._methods != null) _check._methods.remove(_obj);
        _assert(!(_check._objMap[stdgo.Go.asInterface(_obj)] ?? (null : stdgo.Ref<stdgo.go.types.Types.T_declInfo>))._tdecl.assign.isValid());
        var _mset:T_objset = (null : stdgo.go.types.Types.T_objset);
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj._object._typ) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
        }, _base = __tmp__._0, __24 = __tmp__._1;
        if (_base != null && ((_base : Dynamic).__nil__ == null || !(_base : Dynamic).__nil__)) {
            _assert(_base.typeArgs().len() == ((0 : stdgo.GoInt)));
            _check._later(function():Void {
                _check._checkFieldUniqueness(_base);
            })._describef(stdgo.Go.asInterface(_obj), ("verifying field uniqueness for %v" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_base)));
            {
                var _i:stdgo.GoInt = (0 : stdgo.GoInt);
                stdgo.Go.cfor(_i < _base.numMethods(), _i++, {
                    var _m = _base.method(_i);
                    _assert(_m._object._name != (("_" : stdgo.GoString)));
                    _assert(_mset._insert(stdgo.Go.asInterface(_m)) == null);
                });
            };
        };
        for (__57 => _m in _methods) {
            _assert(_m._object._name != (("_" : stdgo.GoString)));
            {
                var _alt:stdgo.go.types.Types.Object = _mset._insert(stdgo.Go.asInterface(_m));
                if (_alt != null) {
                    if (_alt.pos().isValid()) {
                        _check._errorf(stdgo.Go.asInterface(_m), (34 : stdgo.internal.types.errors.Errors.Code), ("method %s.%s already declared at %s" : stdgo.GoString), stdgo.Go.toInterface(_obj.name()), stdgo.Go.toInterface(_m._object._name), stdgo.Go.toInterface(stdgo.Go.asInterface(_alt.pos())));
                    } else {
                        _check._errorf(stdgo.Go.asInterface(_m), (34 : stdgo.internal.types.errors.Errors.Code), ("method %s.%s already declared" : stdgo.GoString), stdgo.Go.toInterface(_obj.name()), stdgo.Go.toInterface(_m._object._name));
                    };
                    continue;
                };
            };
            if (_base != null && ((_base : Dynamic).__nil__ == null || !(_base : Dynamic).__nil__)) {
                _base.addMethod(_m);
            };
        };
    }
    @:keep
    static public function _declareTypeParams( _check:stdgo.Ref<Checker>, _tparams:stdgo.Slice<stdgo.Ref<TypeParam>>, _names:stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.Ident>>):stdgo.Slice<stdgo.Ref<TypeParam>> {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        for (__0 => _name in _names) {
            var _tname = newTypeName(_name.pos(), _check._pkg, _name.name?.__copy__(), (null : stdgo.go.types.Types.Type_));
            var _tpar = _check._newTypeParam(_tname, stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]));
            _check._declare(_check._pkg._scope, _name, stdgo.Go.asInterface(_tname), _check._pkg._scope._pos);
            _tparams = (_tparams.__append__(_tpar));
        };
        if (_check._conf.__Trace && (_names.length > (0 : stdgo.GoInt))) {
            _check._trace(_names[(0 : stdgo.GoInt)].pos(), ("type params = %v" : stdgo.GoString), stdgo.Go.toInterface((_tparams.__slice__((_tparams.length) - (_names.length)) : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>)));
        };
        return _tparams;
    }
    @:keep
    static public function _bound( _check:stdgo.Ref<Checker>, _x:stdgo.go.ast.Ast.Expr):Type_ {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _wrap:Bool = false;
        {
            final __type__ = _x;
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>))) {
                var _op:stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__().value;
                _wrap = _op.op == ((88 : stdgo.go.token.Token.Token));
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>))) {
                var _op:stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__().value;
                _wrap = _op.op == ((18 : stdgo.go.token.Token.Token));
            };
        };
        if (_wrap) {
            _x = stdgo.Go.asInterface((stdgo.Go.setRef(({ methods : (stdgo.Go.setRef(({ list : (new stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.Field>>(1, 1, ({ type : _x } : stdgo.go.ast.Ast.Field)) : stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.Field>>) } : stdgo.go.ast.Ast.FieldList)) : stdgo.Ref<stdgo.go.ast.Ast.FieldList>) } : stdgo.go.ast.Ast.InterfaceType)) : stdgo.Ref<stdgo.go.ast.Ast.InterfaceType>));
            var _t:stdgo.go.types.Types.Type_ = _check._environment._sig._recv._object._typ(_x);
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_t) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Interface>), _1 : false };
                }, _t = __tmp__._0, __8 = __tmp__._1;
                if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                    _t._implicit = true;
                };
            };
            return _t;
        };
        return _check._environment._sig._recv._object._typ(_x);
    }
    @:keep
    static public function _collectTypeParams( _check:stdgo.Ref<Checker>, _dst:stdgo.Ref<stdgo.Ref<TypeParamList>>, _list:stdgo.Ref<stdgo.go.ast.Ast.FieldList>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            var _tparams:stdgo.Slice<stdgo.Ref<TypeParam>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>);
            for (__0 => _f in _list.list) {
                _tparams = _check._declareTypeParams(_tparams, _f.names);
            };
            _dst = _bindTParams(_tparams);
            _assert(!_check._environment._inTParamList);
            _check._environment._inTParamList = true;
            __deferstack__.unshift(() -> {
                var a = function():Void {
                    _check._environment._inTParamList = false;
                };
                a();
            });
            var _index:stdgo.GoInt = (0 : stdgo.GoInt);
            for (__25 => _f in _list.list) {
                var _bound:Type_ = (null : stdgo.go.types.Types.Type_);
                if (_f.type != null) {
                    _bound = _check._bound(_f.type);
                    if (_isTypeParam(_bound)) {
                        _check._error(_f.type, (144 : stdgo.internal.types.errors.Errors.Code), ("cannot use a type parameter as constraint" : stdgo.GoString));
                        _bound = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                    };
                } else {
                    _bound = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                };
                for (_i => _ in _f.names) {
                    _tparams[(_index + _i : stdgo.GoInt)]._bound = _bound;
                };
                _index = _index + ((_f.names.length));
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return;
        };
    }
    @:keep
    static public function _typeDecl( _check:stdgo.Ref<Checker>, _obj:stdgo.Ref<TypeName>, _tdecl:stdgo.Ref<stdgo.go.ast.Ast.TypeSpec>, _def:stdgo.Ref<Named>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            _assert(_obj._object._typ == null);
            var _rhs:Type_ = (null : stdgo.go.types.Types.Type_);
            _check._later(function():Void {
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj._object._typ) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
                    }, _t = __tmp__._0, __8 = __tmp__._1;
                    if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                        _check._validType(_t);
                    };
                };
                _check._isImportedConstraint(_rhs) && _check._verifyVersionf(_tdecl.type, _go1_18?.__copy__(), ("using type constraint %s" : stdgo.GoString), stdgo.Go.toInterface(_rhs));
            })._describef(stdgo.Go.asInterface(_obj), ("validType(%s)" : stdgo.GoString), stdgo.Go.toInterface(_obj.name()));
            var _alias:Bool = _tdecl.assign.isValid();
            if (_alias && (_tdecl.typeParams.numFields() != (0 : stdgo.GoInt))) {
                _check._error(stdgo.Go.asInterface((_tdecl.assign : T_atPos)), (131 : stdgo.internal.types.errors.Errors.Code), ("generic type cannot be alias" : stdgo.GoString));
                _alias = false;
            };
            if (_alias) {
                _check._verifyVersionf(stdgo.Go.asInterface((_tdecl.assign : T_atPos)), _go1_9?.__copy__(), ("type aliases" : stdgo.GoString));
                _check._brokenAlias(_obj);
                _rhs = _check._environment._sig._recv._object._typ(_tdecl.type);
                _check._validAlias(_obj, _rhs);
                return;
            };
            var _named = _check._newNamed(_obj, (null : stdgo.go.types.Types.Type_), (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>));
            _def._setUnderlying(stdgo.Go.asInterface(_named));
            if (_tdecl.typeParams != null && ((_tdecl.typeParams : Dynamic).__nil__ == null || !(_tdecl.typeParams : Dynamic).__nil__)) {
                _check._openScope(stdgo.Go.asInterface(_tdecl), ("type parameters" : stdgo.GoString));
                __deferstack__.unshift(() -> _check._closeScope());
                _check._collectTypeParams((stdgo.Go.setRef(_named._tparams) : stdgo.Ref<stdgo.Ref<stdgo.go.types.Types.TypeParamList>>), _tdecl.typeParams);
            };
            _rhs = _check._definedType(_tdecl.type, _named);
            _assert(_rhs != null);
            _named._fromRHS = _rhs;
            if (_named._underlying == null) {
                _named._underlying = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
            };
            if (_isTypeParam(_rhs)) {
                _check._error(_tdecl.type, (144 : stdgo.internal.types.errors.Errors.Code), ("cannot use a type parameter as RHS in type declaration" : stdgo.GoString));
                _named._underlying = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return;
        };
    }
    /**
        // isImportedConstraint reports whether typ is an imported type constraint.
    **/
    @:keep
    static public function _isImportedConstraint( _check:stdgo.Ref<Checker>, _typ:Type_):Bool {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_typ) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
        }, _named = __tmp__._0, __0 = __tmp__._1;
        if ((((_named == null) || (_named : Dynamic).__nil__) || (_named._obj._object._pkg == _check._pkg)) || ((_named._obj._object._pkg == null) || (_named._obj._object._pkg : Dynamic).__nil__)) {
            return false;
        };
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_named._under()) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Interface>), _1 : false };
        }, _u = __tmp__._0, __33 = __tmp__._1;
        return ((_u != null) && ((_u : Dynamic).__nil__ == null || !(_u : Dynamic).__nil__)) && !_u.isMethodSet();
    }
    @:keep
    static public function _varDecl( _check:stdgo.Ref<Checker>, _obj:stdgo.Ref<Var>, _lhs:stdgo.Slice<stdgo.Ref<Var>>, _typ:stdgo.go.ast.Ast.Expr, _init:stdgo.go.ast.Ast.Expr):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _assert(_obj._object._typ == null);
        if (_typ != null) {
            _obj._object._typ = _check._varType(_typ);
        };
        if (_init == null) {
            if (_typ == null) {
                _obj._object._typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
            };
            return;
        };
        if ((_lhs == null) || (_lhs.length == (1 : stdgo.GoInt))) {
            _assert((_lhs == null) || (_lhs[(0 : stdgo.GoInt)] == _obj));
            var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
            _check._expr(_obj._object._typ, (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _init);
            _check._initVar(_obj, (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), ("variable declaration" : stdgo.GoString));
            return;
        };
        if (false) {
            var _found:Bool = false;
            for (__24 => _lhs in _lhs) {
                if (_obj == (_lhs)) {
                    _found = true;
                    break;
                };
            };
            if (!_found) {
                throw stdgo.Go.toInterface(("inconsistent lhs" : stdgo.GoString));
            };
        };
        if (_typ != null) {
            for (__25 => _lhs in _lhs) {
                _lhs._object._typ = _obj._object._typ;
            };
        };
        _check._initVars(_lhs, (new stdgo.Slice<stdgo.go.ast.Ast.Expr>(1, 1, _init) : stdgo.Slice<stdgo.go.ast.Ast.Expr>), (null : stdgo.go.ast.Ast.Stmt));
    }
    @:keep
    static public function _constDecl( _check:stdgo.Ref<Checker>, _obj:stdgo.Ref<Const>, _typ:stdgo.go.ast.Ast.Expr, _init:stdgo.go.ast.Ast.Expr, _inherited:Bool):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            _assert(_obj._object._typ == null);
            {
                var _a0 = _check._environment._iota;
                var _a1 = _check._environment._errpos;
                __deferstack__.unshift(() -> {
                    var a = function(_iota:stdgo.go.constant.Constant.Value, _errpos:T_positioner):Void {
                        _check._environment._iota = _iota;
                        _check._environment._errpos = _errpos;
                    };
                    a(_a0, _a1);
                });
            };
            _check._environment._iota = _obj._val;
            _check._environment._errpos = (null : stdgo.go.types.Types.T_positioner);
            _obj._val = stdgo.go.constant.Constant.makeUnknown();
            if (_typ != null) {
                var _t:stdgo.go.types.Types.Type_ = _check._environment._sig._recv._object._typ(_typ);
                if (!_isConstType(_t)) {
                    if (stdgo.Go.toInterface(_under(_t)) != (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                        _check._errorf(_typ, (15 : stdgo.internal.types.errors.Errors.Code), ("invalid constant type %s" : stdgo.GoString), stdgo.Go.toInterface(_t));
                    };
                    _obj._object._typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return;
                    };
                };
                _obj._object._typ = _t;
            };
            var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
            if (_init != null) {
                if (_inherited) {
                    _check._environment._errpos = stdgo.Go.asInterface((_obj._object._pos : T_atPos));
                };
                _check._expr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _init);
            };
            _check._initConst(_obj, (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>));
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return;
        };
    }
    @:keep
    static public function _walkDecl( _check:stdgo.Ref<Checker>, _d:stdgo.go.ast.Ast.Decl, _f:T_decl -> Void):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        {
            final __type__ = _d;
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.BadDecl>))) {
                var _d:stdgo.Ref<stdgo.go.ast.Ast.BadDecl> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BadDecl>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BadDecl>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.BadDecl>) : __type__.__underlying__().value;
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.GenDecl>))) {
                var _d:stdgo.Ref<stdgo.go.ast.Ast.GenDecl> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.GenDecl>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.GenDecl>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.GenDecl>) : __type__.__underlying__().value;
                var _last:stdgo.Ref<stdgo.go.ast.Ast.ValueSpec> = (null : stdgo.Ref<stdgo.go.ast.Ast.ValueSpec>);
                for (_iota => _s in _d.specs) {
                    {
                        final __type__ = _s;
                        if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ImportSpec>))) {
                            var _s:stdgo.Ref<stdgo.go.ast.Ast.ImportSpec> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ImportSpec>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ImportSpec>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ImportSpec>) : __type__.__underlying__().value;
                            _f(stdgo.Go.asInterface((new stdgo.go.types.Types.T_importDecl(_s) : stdgo.go.types.Types.T_importDecl)));
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ValueSpec>))) {
                            var _s:stdgo.Ref<stdgo.go.ast.Ast.ValueSpec> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ValueSpec>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ValueSpec>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ValueSpec>) : __type__.__underlying__().value;
                            {
                                final __value__ = _d.tok;
                                if (__value__ == ((64 : stdgo.go.token.Token.Token))) {
                                    var _inherited:Bool = true;
                                    if ((_s.type != null) || (_s.values.length > (0 : stdgo.GoInt))) {
                                        _last = _s;
                                        _inherited = false;
                                    } else if (_last == null || (_last : Dynamic).__nil__) {
                                        _last = (stdgo.Go.setRef(({} : stdgo.go.ast.Ast.ValueSpec)) : stdgo.Ref<stdgo.go.ast.Ast.ValueSpec>);
                                        _inherited = false;
                                    };
                                    _check._arityMatch(_s, _last);
                                    _f(stdgo.Go.asInterface(({ _spec : _s, _iota : _iota, _typ : _last.type, _init : _last.values, _inherited : _inherited } : stdgo.go.types.Types.T_constDecl)));
                                } else if (__value__ == ((85 : stdgo.go.token.Token.Token))) {
                                    _check._arityMatch(_s, null);
                                    _f(stdgo.Go.asInterface((new stdgo.go.types.Types.T_varDecl(_s) : stdgo.go.types.Types.T_varDecl)));
                                } else {
                                    _check._errorf(stdgo.Go.asInterface(_s), (-1 : stdgo.internal.types.errors.Errors.Code), ("invalid token %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_d.tok)));
                                };
                            };
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.TypeSpec>))) {
                            var _s:stdgo.Ref<stdgo.go.ast.Ast.TypeSpec> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.TypeSpec>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.TypeSpec>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.TypeSpec>) : __type__.__underlying__().value;
                            _f(stdgo.Go.asInterface((new stdgo.go.types.Types.T_typeDecl(_s) : stdgo.go.types.Types.T_typeDecl)));
                        } else {
                            var _s:stdgo.go.ast.Ast.Spec = __type__ == null ? (null : stdgo.go.ast.Ast.Spec) : cast __type__;
                            _check._errorf(_s, (-1 : stdgo.internal.types.errors.Errors.Code), ("unknown ast.Spec node %T" : stdgo.GoString), stdgo.Go.toInterface(_s));
                        };
                    };
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.FuncDecl>))) {
                var _d:stdgo.Ref<stdgo.go.ast.Ast.FuncDecl> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.FuncDecl>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.FuncDecl>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.FuncDecl>) : __type__.__underlying__().value;
                _f(stdgo.Go.asInterface((new stdgo.go.types.Types.T_funcDecl(_d) : stdgo.go.types.Types.T_funcDecl)));
            } else {
                var _d:stdgo.go.ast.Ast.Decl = __type__ == null ? (null : stdgo.go.ast.Ast.Decl) : cast __type__;
                _check._errorf(_d, (-1 : stdgo.internal.types.errors.Errors.Code), ("unknown ast.Decl node %T" : stdgo.GoString), stdgo.Go.toInterface(_d));
            };
        };
    }
    @:keep
    static public function _walkDecls( _check:stdgo.Ref<Checker>, _decls:stdgo.Slice<stdgo.go.ast.Ast.Decl>, _f:T_decl -> Void):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        for (__0 => _d in _decls) {
            _check._walkDecl(_d, _f);
        };
    }
    /**
        // cycleError reports a declaration cycle starting with
        // the object in cycle that is "first" in the source.
    **/
    @:keep
    static public function _cycleError( _check:stdgo.Ref<Checker>, _cycle:stdgo.Slice<Object>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _name:stdgo.go.types.Types.Object -> stdgo.GoString = function(_obj:Object):stdgo.GoString {
            return _packagePrefix(_obj.pkg(), _check._qualifier) + _obj.name()?.__copy__()?.__copy__();
        };
        var _i:stdgo.GoInt = _firstInSrc(_cycle);
        var _obj:stdgo.go.types.Types.Object = _cycle[(_i : stdgo.GoInt)];
        var _objName:stdgo.GoString = _name(_obj)?.__copy__();
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<TypeName>)) : stdgo.Ref<TypeName>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeName>), _1 : false };
        }, _tname = __tmp__._0, __0 = __tmp__._1;
        if (((_tname != null) && ((_tname : Dynamic).__nil__ == null || !(_tname : Dynamic).__nil__)) && _tname.isAlias()) {
            _check._validAlias(_tname, stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]));
        };
        if ((_cycle.length) == ((1 : stdgo.GoInt))) {
            if (_tname != null && ((_tname : Dynamic).__nil__ == null || !(_tname : Dynamic).__nil__)) {
                _check._errorf(_obj, (11 : stdgo.internal.types.errors.Errors.Code), ("invalid recursive type: %s refers to itself" : stdgo.GoString), stdgo.Go.toInterface(_objName));
            } else {
                _check._errorf(_obj, (11 : stdgo.internal.types.errors.Errors.Code), ("invalid cycle in declaration: %s refers to itself" : stdgo.GoString), stdgo.Go.toInterface(_objName));
            };
            return;
        };
        if (_tname != null && ((_tname : Dynamic).__nil__ == null || !(_tname : Dynamic).__nil__)) {
            _check._errorf(_obj, (11 : stdgo.internal.types.errors.Errors.Code), ("invalid recursive type %s" : stdgo.GoString), stdgo.Go.toInterface(_objName));
        } else {
            _check._errorf(_obj, (11 : stdgo.internal.types.errors.Errors.Code), ("invalid cycle in declaration of %s" : stdgo.GoString), stdgo.Go.toInterface(_objName));
        };
        for (_ => _ in _cycle) {
            _check._errorf(_obj, (11 : stdgo.internal.types.errors.Errors.Code), ("\t%s refers to" : stdgo.GoString), stdgo.Go.toInterface(_objName));
            _i++;
            if (_i >= (_cycle.length)) {
                _i = (0 : stdgo.GoInt);
            };
            _obj = _cycle[(_i : stdgo.GoInt)];
            _objName = _name(_obj)?.__copy__();
        };
        _check._errorf(_obj, (11 : stdgo.internal.types.errors.Errors.Code), ("\t%s" : stdgo.GoString), stdgo.Go.toInterface(_objName));
    }
    /**
        // validCycle checks if the cycle starting with obj is valid and
        // reports an error if it is not.
    **/
    @:keep
    static public function _validCycle( _check:stdgo.Ref<Checker>, _obj:Object):Bool {
        stdgo.internal.Macro.controlFlow({
            @:recv var _check:stdgo.Ref<Checker> = _check;
            var __deferstack__:Array<Void -> Void> = [];
            var _valid:Bool = false;
            try {
                if (false) {
                    var _info = (_check._objMap[_obj] ?? (null : stdgo.Ref<stdgo.go.types.Types.T_declInfo>));
                    var _inObjMap:Bool = ((_info != null) && ((_info : Dynamic).__nil__ == null || !(_info : Dynamic).__nil__)) && (((_info._fdecl == null) || (_info._fdecl : Dynamic).__nil__) || ((_info._fdecl.recv == null) || (_info._fdecl.recv : Dynamic).__nil__));
                    var _isPkgObj:Bool = _obj.parent() == (_check._pkg._scope);
                    if (_isPkgObj != (_inObjMap)) {
                        _check._dump(("%v: inconsistent object map for %s (isPkgObj = %v, inObjMap = %v)" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_obj.pos())), stdgo.Go.toInterface(_obj), stdgo.Go.toInterface(_isPkgObj), stdgo.Go.toInterface(_inObjMap));
                        _unreachable();
                    };
                };
                _assert(_obj._color() >= (2u32 : stdgo.go.types.Types.T_color));
                var _start:stdgo.go.types.Types.T_color = _obj._color() - (2u32 : stdgo.go.types.Types.T_color);
                var _cycle = (_check._objPath.__slice__(_start) : stdgo.Slice<stdgo.go.types.Types.Object>);
                var _tparCycle:Bool = false;
                var _nval:stdgo.GoInt = (0 : stdgo.GoInt);
                var _ndef:stdgo.GoInt = (0 : stdgo.GoInt);
                @:label("loop") for (__32 => _obj in _cycle) {
                    {
                        final __type__ = _obj;
                        {
                            var __bool__ = true;
                            while (__bool__) {
                                __bool__ = false;
                                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Const>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Var>))) {
                                    var _obj:stdgo.go.types.Types.Object = __type__ == null ? (null : stdgo.go.types.Types.Object) : cast __type__;
                                    _nval++;
                                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeName>))) {
                                    var _obj:stdgo.Ref<stdgo.go.types.Types.TypeName> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeName>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__().value;
                                    if (_check._environment._inTParamList && _isGeneric(_obj._object._typ)) {
                                        _tparCycle = true;
                                        @:jump("loop") break;
                                    };
                                    var _alias:Bool = false;
                                    {
                                        var _d = (_check._objMap[stdgo.Go.asInterface(_obj)] ?? (null : stdgo.Ref<stdgo.go.types.Types.T_declInfo>));
                                        if (_d != null && ((_d : Dynamic).__nil__ == null || !(_d : Dynamic).__nil__)) {
                                            _alias = _d._tdecl.assign.isValid();
                                        } else {
                                            _alias = _obj.isAlias();
                                        };
                                    };
                                    if (!_alias) {
                                        _ndef++;
                                    };
                                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Func>))) {
                                    var _obj:stdgo.Ref<stdgo.go.types.Types.Func> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Func>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__().value;
                                } else {
                                    var _obj:stdgo.go.types.Types.Object = __type__ == null ? (null : stdgo.go.types.Types.Object) : cast __type__;
                                    _unreachable();
                                };
                                break;
                            };
                        };
                    };
                };
                if (_check._conf.__Trace) {
                    _check._trace(_obj.pos(), ("## cycle detected: objPath = %s->%s (len = %d)" : stdgo.GoString), stdgo.Go.toInterface(_pathString(_cycle)), stdgo.Go.toInterface(_obj.name()), stdgo.Go.toInterface((_cycle.length)));
                    if (_tparCycle) {
                        _check._trace(_obj.pos(), ("## cycle contains: generic type in a type parameter list" : stdgo.GoString));
                    } else {
                        _check._trace(_obj.pos(), ("## cycle contains: %d values, %d type definitions" : stdgo.GoString), stdgo.Go.toInterface(_nval), stdgo.Go.toInterface(_ndef));
                    };
                    __deferstack__.unshift(() -> {
                        var a = function():Void {
                            if (_valid) {
                                _check._trace(_obj.pos(), ("=> cycle is valid" : stdgo.GoString));
                            } else {
                                _check._trace(_obj.pos(), ("=> error: cycle is invalid" : stdgo.GoString));
                            };
                        };
                        a();
                    });
                };
                if (!_tparCycle) {
                    if (_nval == ((_cycle.length))) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return true;
                        };
                    };
                    if ((_nval == (0 : stdgo.GoInt)) && (_ndef > (0 : stdgo.GoInt))) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return true;
                        };
                    };
                };
                _check._cycleError(_cycle);
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return false;
                };
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                    return _valid;
                };
            } catch(__exception__) {
                var exe:Dynamic = __exception__.native;
                if ((exe is haxe.ValueException)) exe = exe.value;
                if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                    exe = stdgo.Go.toInterface(__exception__.message);
                };
                stdgo.Go.recover_exception = exe;
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return _valid;
            };
        });
        throw "controlFlow did not return";
    }
    /**
        // objDecl type-checks the declaration of obj in its respective (file) environment.
        // For the meaning of def, see Checker.definedType, in typexpr.go.
    **/
    @:keep
    static public function _objDecl( _check:stdgo.Ref<Checker>, _obj:Object, _def:stdgo.Ref<Named>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            if (_check._conf.__Trace && (_obj.type() == null)) {
                if (_check._indent == ((0 : stdgo.GoInt))) {
                    stdgo.fmt.Fmt.println();
                };
                _check._trace(_obj.pos(), ("-- checking %s (%s, objPath = %s)" : stdgo.GoString), stdgo.Go.toInterface(_obj), stdgo.Go.toInterface(stdgo.Go.asInterface(_obj._color())), stdgo.Go.toInterface(_pathString(_check._objPath)));
                _check._indent++;
                __deferstack__.unshift(() -> {
                    var a = function():Void {
                        _check._indent--;
                        _check._trace(_obj.pos(), ("=> %s (%s)" : stdgo.GoString), stdgo.Go.toInterface(_obj), stdgo.Go.toInterface(stdgo.Go.asInterface(_obj._color())));
                    };
                    a();
                });
            };
            if ((_obj._color() == (0u32 : stdgo.go.types.Types.T_color)) && (_obj.type() != null)) {
                _obj._setColor((1u32 : stdgo.go.types.Types.T_color));
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return;
                };
            };
            {
                var __switchIndex__ = -1;
                var __run__ = true;
                while (__run__) {
                    __run__ = false;
                    {
                        final __value__ = _obj._color();
                        if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (__value__ == (0u32 : stdgo.go.types.Types.T_color)))) {
                            _assert(_obj.type() == null);
                            _obj._setColor((2u32 : stdgo.go.types.Types.T_color) + (_check._push(_obj) : T_color));
                            __deferstack__.unshift(() -> {
                                var a = function():Void {
                                    _check._pop()._setColor((1u32 : stdgo.go.types.Types.T_color));
                                };
                                a();
                            });
                            break;
                            break;
                        } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && (__value__ == (1u32 : stdgo.go.types.Types.T_color)))) {
                            _assert(_obj.type() != null);
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return;
                            };
                            break;
                            break;
                        } else if (__switchIndex__ == 3 || (__switchIndex__ == -1 && (__value__ == (2u32 : stdgo.go.types.Types.T_color)))) {
                            {
                                final __type__ = _obj;
                                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Const>))) {
                                    var _obj:stdgo.Ref<stdgo.go.types.Types.Const> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Const>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Const>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Const>) : __type__.__underlying__().value;
                                    if (!_check._validCycle(stdgo.Go.asInterface(_obj)) || (_obj._object._typ == null)) {
                                        _obj._object._typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                                    };
                                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Var>))) {
                                    var _obj:stdgo.Ref<stdgo.go.types.Types.Var> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Var>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__().value;
                                    if (!_check._validCycle(stdgo.Go.asInterface(_obj)) || (_obj._object._typ == null)) {
                                        _obj._object._typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                                    };
                                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeName>))) {
                                    var _obj:stdgo.Ref<stdgo.go.types.Types.TypeName> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeName>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__().value;
                                    if (!_check._validCycle(stdgo.Go.asInterface(_obj))) {
                                        _obj._object._typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                                    };
                                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Func>))) {
                                    var _obj:stdgo.Ref<stdgo.go.types.Types.Func> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Func>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__().value;
                                    if (!_check._validCycle(stdgo.Go.asInterface(_obj))) {};
                                } else {
                                    var _obj:stdgo.go.types.Types.Object = __type__ == null ? (null : stdgo.go.types.Types.Object) : cast __type__;
                                    _unreachable();
                                };
                            };
                            _assert(_obj.type() != null);
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return;
                            };
                            break;
                            break;
                        } else {
                            @:fallthrough {
                                __switchIndex__ = 3;
                                __run__ = true;
                                continue;
                            };
                        };
                    };
                    break;
                };
            };
            var _d = (_check._objMap[_obj] ?? (null : stdgo.Ref<stdgo.go.types.Types.T_declInfo>));
            if (_d == null || (_d : Dynamic).__nil__) {
                _check._dump(("%v: %s should have been declared" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_obj.pos())), stdgo.Go.toInterface(_obj));
                _unreachable();
            };
            {
                var _a0 = _check._environment;
                __deferstack__.unshift(() -> {
                    var a = function(_env:T_environment):Void {
                        _check._environment = _env?.__copy__();
                    };
                    a(_a0?.__copy__());
                });
            };
            _check._environment = ({ _scope : _d._file } : stdgo.go.types.Types.T_environment);
            {
                final __type__ = _obj;
                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Const>))) {
                    var _obj:stdgo.Ref<stdgo.go.types.Types.Const> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Const>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Const>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Const>) : __type__.__underlying__().value;
                    _check._environment._decl = _d;
                    _check._constDecl(_obj, _d._vtyp, _d._init, _d._inherited);
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Var>))) {
                    var _obj:stdgo.Ref<stdgo.go.types.Types.Var> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Var>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__().value;
                    _check._environment._decl = _d;
                    _check._varDecl(_obj, _d._lhs, _d._vtyp, _d._init);
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeName>))) {
                    var _obj:stdgo.Ref<stdgo.go.types.Types.TypeName> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeName>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__().value;
                    _check._typeDecl(_obj, _d._tdecl, _def);
                    _check._collectMethods(_obj);
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Func>))) {
                    var _obj:stdgo.Ref<stdgo.go.types.Types.Func> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Func>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__().value;
                    _check._funcDecl(_obj, _d);
                } else {
                    var _obj:stdgo.go.types.Types.Object = __type__ == null ? (null : stdgo.go.types.Types.Object) : cast __type__;
                    _unreachable();
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return;
        };
    }
    @:keep
    static public function _declare( _check:stdgo.Ref<Checker>, _scope:stdgo.Ref<Scope>, _id:stdgo.Ref<stdgo.go.ast.Ast.Ident>, _obj:Object, _pos:stdgo.go.token.Token.Pos):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if (_obj.name() != (("_" : stdgo.GoString))) {
            {
                var _alt:stdgo.go.types.Types.Object = _scope.insert(_obj);
                if (_alt != null) {
                    _check._errorf(_obj, (10 : stdgo.internal.types.errors.Errors.Code), ("%s redeclared in this block" : stdgo.GoString), stdgo.Go.toInterface(_obj.name()));
                    _check._reportAltDecl(_alt);
                    return;
                };
            };
            _obj._setScopePos(_pos);
        };
        if (_id != null && ((_id : Dynamic).__nil__ == null || !(_id : Dynamic).__nil__)) {
            _check._recordDef(_id, _obj);
        };
    }
    @:keep
    static public function _reportAltDecl( _check:stdgo.Ref<Checker>, _obj:Object):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        {
            var _pos:stdgo.go.token.Token.Pos = _obj.pos();
            if (_pos.isValid()) {
                _check._errorf(_obj, (10 : stdgo.internal.types.errors.Errors.Code), ("\tother declaration of %s" : stdgo.GoString), stdgo.Go.toInterface(_obj.name()));
            };
        };
    }
    /**
        // conversion type-checks the conversion T(x).
        // The result is in x.
    **/
    @:keep
    static public function _conversion( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, t:Type_):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _constArg:Bool = _x._mode == ((4 : stdgo.go.types.Types.T_operandMode));
        var _constConvertibleTo = function(t:Type_, _val:stdgo.Ref<stdgo.go.constant.Constant.Value>):Bool {
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(t)) : stdgo.Ref<Basic>)) : stdgo.Ref<Basic>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Basic>), _1 : false };
                }, _t = __tmp__._0, __0 = __tmp__._1;
                if (_t == null || (_t : Dynamic).__nil__) {} else if (_representableConst(_x._val, _check, _t, _val)) {
                    return true;
                } else if (_isInteger(_x._typ) && _isString(stdgo.Go.asInterface(_t))) {
                    var _codepoint:stdgo.GoInt32 = (65533 : stdgo.GoInt32);
                    {
                        var __tmp__ = stdgo.go.constant.Constant.uint64Val(_x._val), _i:stdgo.GoUInt64 = __tmp__._0, _ok:Bool = __tmp__._1;
                        if (_ok && (_i <= (1114111i64 : stdgo.GoUInt64))) {
                            _codepoint = (_i : stdgo.GoRune);
                        };
                    };
                    if (_val != null && ((_val : Dynamic).__nil__ == null || !(_val : Dynamic).__nil__)) {
                        {
                            var __tmp__ = stdgo.go.constant.Constant.makeString((_codepoint : stdgo.GoString)?.__copy__());
                            _val.exactString = __tmp__.exactString;
                            _val.kind = __tmp__.kind;
                            _val.string = __tmp__.string;
                            _val._implementsValue = __tmp__._implementsValue;
                        };
                    };
                    return true;
                };
            };
            return false;
        };
        var _ok:Bool = false;
        var _cause:stdgo.GoString = ("" : stdgo.GoString);
        if (_constArg && _isConstType(t)) {
            _ok = _constConvertibleTo(t, (stdgo.Go.setRef(_x._val) : stdgo.Ref<stdgo.go.constant.Constant.Value>));
        } else if (_constArg && _isTypeParam(t)) {
            _ok = (stdgo.Go.typeAssert((stdgo.Go.toInterface(t) : stdgo.Ref<TypeParam>)) : stdgo.Ref<TypeParam>)._underIs(function(_u:Type_):Bool {
                if (_u == null) {
                    _cause = _check._sprintf(("%s does not contain specific types" : stdgo.GoString), stdgo.Go.toInterface(t))?.__copy__();
                    return false;
                };
                if (_isString(_x._typ) && _isBytesOrRunes(_u)) {
                    return true;
                };
                if (!_constConvertibleTo(_u, (null : stdgo.Ref<stdgo.go.constant.Constant.Value>))) {
                    _cause = _check._sprintf(("cannot convert %s to type %s (in %s)" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(_u), stdgo.Go.toInterface(t))?.__copy__();
                    return false;
                };
                return true;
            });
            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
        } else if (_x._convertibleTo(_check, t, stdgo.Go.pointer(_cause))) {
            _ok = true;
            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
        };
        if (!_ok) {
            if (_cause != (stdgo.Go.str())) {
                _check._errorf(stdgo.Go.asInterface(_x), (96 : stdgo.internal.types.errors.Errors.Code), ("cannot convert %s to type %s: %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(t), stdgo.Go.toInterface(_cause));
            } else {
                _check._errorf(stdgo.Go.asInterface(_x), (96 : stdgo.internal.types.errors.Errors.Code), ("cannot convert %s to type %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(t));
            };
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            return;
        };
        if (_isUntyped(_x._typ)) {
            var _final:stdgo.go.types.Types.Type_ = t;
            if ((_isNonTypeParamInterface(t) || (_constArg && !_isConstType(t))) || _x._isNil()) {
                _final = default_(_x._typ);
            } else if (((_x._mode == (4 : stdgo.go.types.Types.T_operandMode)) && _isInteger(_x._typ)) && _allString(t)) {
                _final = _x._typ;
            };
            _check._updateExprType(_x._expr, _final, true);
        };
        _x._typ = t;
    }
    /**
        // convertUntyped attempts to set the type of an untyped value to the target type.
    **/
    @:keep
    static public function _convertUntyped( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _target:Type_):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var __tmp__ = _check._implicitTypeAndValue(_x, _target), _newType:stdgo.go.types.Types.Type_ = __tmp__._0, _val:stdgo.go.constant.Constant.Value = __tmp__._1, _code:stdgo.internal.types.errors.Errors.Code = __tmp__._2;
        if (_code != ((0 : stdgo.internal.types.errors.Errors.Code))) {
            var _t:stdgo.go.types.Types.Type_ = _target;
            if (!_isTypeParam(_target)) {
                _t = _safeUnderlying(_target);
            };
            _check._invalidConversion(_code, _x, _t);
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            return;
        };
        if (_val != null) {
            _x._val = _val;
            _check._updateExprVal(_x._expr, _val);
        };
        if (stdgo.Go.toInterface(_newType) != (stdgo.Go.toInterface(_x._typ))) {
            _x._typ = _newType;
            _check._updateExprType(_x._expr, _newType, false);
        };
    }
    @:keep
    static public function _invalidConversion( _check:stdgo.Ref<Checker>, _code:Code, _x:stdgo.Ref<T_operand>, _target:Type_):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _msg:stdgo.GoString = ("cannot convert %s to type %s" : stdgo.GoString);
        {
            final __value__ = _code;
            if (__value__ == ((43 : stdgo.internal.types.errors.Errors.Code))) {
                _msg = ("%s truncated to %s" : stdgo.GoString);
            } else if (__value__ == ((44 : stdgo.internal.types.errors.Errors.Code))) {
                _msg = ("%s overflows %s" : stdgo.GoString);
            };
        };
        _check._errorf(stdgo.Go.asInterface(_x), _code, _msg?.__copy__(), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(_target));
    }
    /**
        // representation returns the representation of the constant operand x as the
        // basic type typ.
        //
        // If no such representation is possible, it returns a non-zero error code.
    **/
    @:keep
    static public function _representation( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _typ:stdgo.Ref<Basic>):{ var _0 : stdgo.go.constant.Constant.Value; var _1 : Code; } {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _assert(_x._mode == ((4 : stdgo.go.types.Types.T_operandMode)));
        var _v:stdgo.go.constant.Constant.Value = _x._val;
        if (!_representableConst(_x._val, _check, _typ, (stdgo.Go.setRef(_v) : stdgo.Ref<stdgo.go.constant.Constant.Value>))) {
            if (_isNumeric(_x._typ) && _isNumeric(stdgo.Go.asInterface(_typ))) {
                if (!_isInteger(_x._typ) && _isInteger(stdgo.Go.asInterface(_typ))) {
                    return { _0 : (null : stdgo.go.constant.Constant.Value), _1 : (43 : stdgo.internal.types.errors.Errors.Code) };
                } else {
                    return { _0 : (null : stdgo.go.constant.Constant.Value), _1 : (44 : stdgo.internal.types.errors.Errors.Code) };
                };
            };
            return { _0 : (null : stdgo.go.constant.Constant.Value), _1 : (14 : stdgo.internal.types.errors.Errors.Code) };
        };
        return { _0 : _v, _1 : (0 : stdgo.internal.types.errors.Errors.Code) };
    }
    /**
        // representable checks that a constant operand is representable in the given
        // basic type.
    **/
    @:keep
    static public function _representable( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _typ:stdgo.Ref<Basic>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var __tmp__ = _check._representation(_x, _typ), _v:stdgo.go.constant.Constant.Value = __tmp__._0, _code:stdgo.internal.types.errors.Errors.Code = __tmp__._1;
        if (_code != ((0 : stdgo.internal.types.errors.Errors.Code))) {
            _check._invalidConversion(_code, _x, stdgo.Go.asInterface(_typ));
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            return;
        };
        _assert(_v != null);
        _x._val = _v;
    }
    /**
        // overflow checks that the constant x is representable by its type.
        // For untyped constants, it checks that the value doesn't become
        // arbitrarily large.
    **/
    @:keep
    static public function _overflow( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _opPos:stdgo.go.token.Token.Pos):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _assert(_x._mode == ((4 : stdgo.go.types.Types.T_operandMode)));
        if (_x._val.kind() == ((0 : stdgo.go.constant.Constant.Kind))) {
            _check._error(stdgo.Go.asInterface((_opPos : T_atPos)), (14 : stdgo.internal.types.errors.Errors.Code), ("constant result is not representable" : stdgo.GoString));
            return;
        };
        if (_isTyped(_x._typ)) {
            _check._representable(_x, (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_x._typ)) : stdgo.Ref<Basic>)) : stdgo.Ref<Basic>));
            return;
        };
        {};
        if ((_x._val.kind() == (3 : stdgo.go.constant.Constant.Kind)) && (stdgo.go.constant.Constant.bitLen(_x._val) > (512 : stdgo.GoInt))) {
            var _op:stdgo.GoString = _opName(_x._expr)?.__copy__();
            if (_op != (stdgo.Go.str())) {
                _op = _op + ((" " : stdgo.GoString))?.__copy__();
            };
            _check._errorf(stdgo.Go.asInterface((_opPos : T_atPos)), (14 : stdgo.internal.types.errors.Errors.Code), ("constant %soverflow" : stdgo.GoString), stdgo.Go.toInterface(_op));
            _x._val = stdgo.go.constant.Constant.makeUnknown();
        };
    }
    @:keep
    static public function _recordScope( _check:stdgo.Ref<Checker>, _node:stdgo.go.ast.Ast.Node, _scope:stdgo.Ref<Scope>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _assert(_node != null);
        _assert(_scope != null && ((_scope : Dynamic).__nil__ == null || !(_scope : Dynamic).__nil__));
        {
            var _m = _check.info.scopes;
            if (_m != null) {
                _m[_node] = _scope;
            };
        };
    }
    @:keep
    static public function _recordSelection( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>, _kind:SelectionKind, _recv:Type_, _obj:Object, _index:stdgo.Slice<stdgo.GoInt>, _indirect:Bool):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _assert((_obj != null) && ((_recv == null) || (_index.length > (0 : stdgo.GoInt))));
        _check._recordUse(_x.sel, _obj);
        {
            var _m = _check.info.selections;
            if (_m != null) {
                _m[_x] = (stdgo.Go.setRef((new stdgo.go.types.Types.Selection(_kind, _recv, _obj, _index, _indirect) : stdgo.go.types.Types.Selection)) : stdgo.Ref<stdgo.go.types.Types.Selection>);
            };
        };
    }
    @:keep
    static public function _recordImplicit( _check:stdgo.Ref<Checker>, _node:stdgo.go.ast.Ast.Node, _obj:Object):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _assert(_node != null);
        _assert(_obj != null);
        {
            var _m = _check.info.implicits;
            if (_m != null) {
                _m[_node] = _obj;
            };
        };
    }
    @:keep
    static public function _recordUse( _check:stdgo.Ref<Checker>, _id:stdgo.Ref<stdgo.go.ast.Ast.Ident>, _obj:Object):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _assert(_id != null && ((_id : Dynamic).__nil__ == null || !(_id : Dynamic).__nil__));
        _assert(_obj != null);
        {
            var _m = _check.info.uses;
            if (_m != null) {
                _m[_id] = _obj;
            };
        };
    }
    @:keep
    static public function _recordDef( _check:stdgo.Ref<Checker>, _id:stdgo.Ref<stdgo.go.ast.Ast.Ident>, _obj:Object):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _assert(_id != null && ((_id : Dynamic).__nil__ == null || !(_id : Dynamic).__nil__));
        {
            var _m = _check.info.defs;
            if (_m != null) {
                _m[_id] = _obj;
            };
        };
    }
    /**
        // recordInstance records instantiation information into check.Info, if the
        // Instances map is non-nil. The given expr must be an ident, selector, or
        // index (list) expr with ident or selector operand.
        //
        // TODO(rfindley): the expr parameter is fragile. See if we can access the
        // instantiated identifier in some other way.
    **/
    @:keep
    static public function _recordInstance( _check:stdgo.Ref<Checker>, _expr:stdgo.go.ast.Ast.Expr, _targs:stdgo.Slice<Type_>, _typ:Type_):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _ident = _instantiatedIdent(_expr);
        _assert(_ident != null && ((_ident : Dynamic).__nil__ == null || !(_ident : Dynamic).__nil__));
        _assert(_typ != null);
        {
            var _m = _check.info.instances;
            if (_m != null) {
                _m[_ident] = (new stdgo.go.types.Types.Instance(_newTypeList(_targs), _typ) : stdgo.go.types.Types.Instance);
            };
        };
    }
    /**
        // recordCommaOkTypes updates recorded types to reflect that x is used in a commaOk context
        // (and therefore has tuple type).
    **/
    @:keep
    static public function _recordCommaOkTypes( _check:stdgo.Ref<Checker>, _x:stdgo.go.ast.Ast.Expr, _a:stdgo.Slice<stdgo.Ref<T_operand>>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _assert(_x != null);
        _assert((_a.length) == ((2 : stdgo.GoInt)));
        if (_a[(0 : stdgo.GoInt)]._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
            return;
        };
        var __0:stdgo.go.types.Types.Type_ = _a[(0 : stdgo.GoInt)]._typ, __1:stdgo.go.types.Types.Type_ = _a[(1 : stdgo.GoInt)]._typ, _t1:stdgo.go.types.Types.Type_ = __1, _t0:stdgo.go.types.Types.Type_ = __0;
        _assert((_isTyped(_t0) && _isTyped(_t1)) && (_isBoolean(_t1) || (stdgo.Go.toInterface(_t1) == stdgo.Go.toInterface(_universeError))));
        {
            var _m = _check.info.types;
            if (_m != null) {
                while (true) {
                    var _tv:stdgo.go.types.Types.TypeAndValue = (_m[_x] ?? ({} : stdgo.go.types.Types.TypeAndValue))?.__copy__();
                    _assert(_tv.type != null);
                    var _pos:stdgo.go.token.Token.Pos = _x.pos();
                    _tv.type = stdgo.Go.asInterface(newTuple(newVar(_pos, _check._pkg, stdgo.Go.str()?.__copy__(), _t0), newVar(_pos, _check._pkg, stdgo.Go.str()?.__copy__(), _t1)));
                    _m[_x] = _tv?.__copy__();
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_x) : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>)) : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>), _1 : false };
                    }, _p = __tmp__._0, __24 = __tmp__._1;
                    if (_p == null || (_p : Dynamic).__nil__) {
                        break;
                    };
                    _x = _p.x;
                };
            };
        };
    }
    @:keep
    static public function _recordBuiltinType( _check:stdgo.Ref<Checker>, _f:stdgo.go.ast.Ast.Expr, _sig:stdgo.Ref<Signature>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        while (true) {
            _check._recordTypeAndValue(_f, (2 : stdgo.go.types.Types.T_operandMode), stdgo.Go.asInterface(_sig), (null : stdgo.go.constant.Constant.Value));
            {
                final __type__ = _f;
                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.Ident>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>))) {
                    var _p:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                    return;
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>))) {
                    var _p:stdgo.Ref<stdgo.go.ast.Ast.ParenExpr> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__().value;
                    _f = _p.x;
                } else {
                    var _p:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                    _unreachable();
                };
            };
        };
    }
    @:keep
    static public function _recordTypeAndValue( _check:stdgo.Ref<Checker>, _x:stdgo.go.ast.Ast.Expr, _mode:T_operandMode, _typ:Type_, _val:stdgo.go.constant.Constant.Value):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _assert(_x != null);
        _assert(_typ != null);
        if (_mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
            return;
        };
        if (_mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
            _assert(_val != null);
            _assert((stdgo.Go.toInterface(_typ) == stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]))) || _allBasic(_typ, (59 : stdgo.go.types.Types.BasicInfo)));
        };
        {
            var _m = _check.info.types;
            if (_m != null) {
                _m[_x] = (new stdgo.go.types.Types.TypeAndValue(_mode, _typ, _val) : stdgo.go.types.Types.TypeAndValue);
            };
        };
    }
    @:keep
    static public function _recordUntyped( _check:stdgo.Ref<Checker>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if (true && (_check.info.types == null)) {
            return;
        };
        for (_x => _info in _check._untyped) {
            if (false && _isTyped(stdgo.Go.asInterface(_info._typ))) {
                _check._dump(("%v: %s (type %s) is typed" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x.pos())), stdgo.Go.toInterface(_x), stdgo.Go.toInterface(stdgo.Go.asInterface(_info._typ)));
                _unreachable();
            };
            _check._recordTypeAndValue(_x, _info._mode, stdgo.Go.asInterface(_info._typ), _info._val);
        };
    }
    @:keep
    static public function _record( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _typ:Type_ = (null : stdgo.go.types.Types.Type_);
        var _val:stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
        {
            final __value__ = _x._mode;
            if (__value__ == ((0 : stdgo.go.types.Types.T_operandMode))) {
                _typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
            } else if (__value__ == ((1 : stdgo.go.types.Types.T_operandMode))) {
                _typ = stdgo.Go.asInterface(((null : stdgo.Ref<stdgo.go.types.Types.Tuple>) : stdgo.Ref<Tuple>));
            } else if (__value__ == ((4 : stdgo.go.types.Types.T_operandMode))) {
                _typ = _x._typ;
                _val = _x._val;
            } else {
                _typ = _x._typ;
            };
        };
        _assert((_x._expr != null) && (_typ != null));
        if (_isUntyped(_typ)) {
            _check._rememberUntyped(_x._expr, false, _x._mode, (stdgo.Go.typeAssert((stdgo.Go.toInterface(_typ) : stdgo.Ref<Basic>)) : stdgo.Ref<Basic>), _val);
        } else {
            _check._recordTypeAndValue(_x._expr, _x._mode, _typ, _val);
        };
    }
    /**
        // cleanup runs cleanup for all collected cleaners.
    **/
    @:keep
    static public function _cleanup( _check:stdgo.Ref<Checker>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        {
            var _i:stdgo.GoInt = (0 : stdgo.GoInt);
            stdgo.Go.cfor(_i < (_check._cleaners.length), _i++, {
                _check._cleaners[(_i : stdgo.GoInt)]._cleanup();
            });
        };
        _check._cleaners = (null : stdgo.Slice<stdgo.go.types.Types.T_cleaner>);
    }
    /**
        // processDelayed processes all delayed actions pushed after top.
    **/
    @:keep
    static public function _processDelayed( _check:stdgo.Ref<Checker>, _top:stdgo.GoInt):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        {
            var _i:stdgo.GoInt = _top;
            stdgo.Go.cfor(_i < (_check._delayed.length), _i++, {
                var _a = (stdgo.Go.setRef(_check._delayed[(_i : stdgo.GoInt)]) : stdgo.Ref<stdgo.go.types.Types.T_action>);
                if (_check._conf.__Trace) {
                    if (_a._desc != null && ((_a._desc : Dynamic).__nil__ == null || !(_a._desc : Dynamic).__nil__)) {
                        _check._trace(_a._desc._pos.pos(), ("-- " : stdgo.GoString) + _a._desc._format?.__copy__()?.__copy__(), ..._a._desc._args.__toArray__());
                    } else {
                        _check._trace(_nopos, ("-- delayed %p" : stdgo.GoString), stdgo.Go.toInterface(_a._f));
                    };
                };
                _a._f();
                if (_check._conf.__Trace) {
                    stdgo.fmt.Fmt.println();
                };
            });
        };
        _assert(_top <= (_check._delayed.length));
        _check._delayed = (_check._delayed.__slice__(0, _top) : stdgo.Slice<stdgo.go.types.Types.T_action>);
    }
    @:keep
    static public function _checkFiles( _check:stdgo.Ref<Checker>, _files:stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.File>>):stdgo.Error {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var __deferstack__:Array<Void -> Void> = [];
        var _err:stdgo.Error = (null : stdgo.Error);
        try {
            if (_check._pkg == (unsafe)) {
                return (null : stdgo.Error);
            };
            {
                var __tmp__ = _parseGoVersion(_check._conf.goVersion?.__copy__());
                _check._version = __tmp__._0?.__copy__();
                _err = __tmp__._1;
            };
            if (_err != null) {
                return _err;
            };
            if (_check._version._after((new stdgo.go.types.Types.T_version((1 : stdgo.GoInt), (21 : stdgo.GoInt)) : stdgo.go.types.Types.T_version))) {
                return stdgo.fmt.Fmt.errorf(("package requires newer Go version %v" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_check._version)));
            };
            if (_check._conf.fakeImportC && _check._conf._go115UsesCgo) {
                return _errBadCgo;
            };
            {
                var _a0 = (stdgo.Go.setRef(_err) : stdgo.Ref<stdgo.Error>);
                __deferstack__.unshift(() -> _check._handleBailout(_a0));
            };
            var _print:stdgo.GoString -> Void = function(_msg:stdgo.GoString):Void {
                if (_check._conf.__Trace) {
                    stdgo.fmt.Fmt.println();
                    stdgo.fmt.Fmt.println(stdgo.Go.toInterface(_msg));
                };
            };
            _print(("== initFiles ==" : stdgo.GoString));
            _check._initFiles(_files);
            _print(("== collectObjects ==" : stdgo.GoString));
            _check._collectObjects();
            _print(("== packageObjects ==" : stdgo.GoString));
            _check._packageObjects();
            _print(("== processDelayed ==" : stdgo.GoString));
            _check._processDelayed((0 : stdgo.GoInt));
            _print(("== cleanup ==" : stdgo.GoString));
            _check._cleanup();
            _print(("== initOrder ==" : stdgo.GoString));
            _check._initOrder();
            if (!_check._conf.disableUnusedImportCheck) {
                _print(("== unusedImports ==" : stdgo.GoString));
                _check._unusedImports();
            };
            _print(("== recordUntyped ==" : stdgo.GoString));
            _check._recordUntyped();
            if (_check._firstErr == null) {
                _check._monomorph();
            };
            _check._pkg._goVersion = _check._conf.goVersion?.__copy__();
            _check._pkg._complete = true;
            _check._imports = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.PkgName>>);
            _check._dotImportMap = (null : stdgo.GoMap<stdgo.go.types.Types.T_dotImportKey, stdgo.Ref<stdgo.go.types.Types.PkgName>>);
            _check._pkgPathMap = (null : stdgo.GoMap<stdgo.GoString, stdgo.GoMap<stdgo.GoString, Bool>>);
            _check._seenPkgMap = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Package>, Bool>);
            _check._recvTParamMap = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.ast.Ast.Ident>, stdgo.Ref<stdgo.go.types.Types.TypeParam>>);
            _check._brokenAliases = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, Bool>);
            _check._unionTypeSets = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Union>, stdgo.Ref<stdgo.go.types.Types.T__TypeSet>>);
            _check._ctxt = null;
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _err;
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return _err;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return _err;
        };
    }
    /**
        // Files checks the provided files as part of the checker's package.
    **/
    @:keep
    static public function files( _check:stdgo.Ref<Checker>, _files:stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.File>>):stdgo.Error {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        return _check._checkFiles(_files);
    }
    @:keep
    static public function _handleBailout( _check:stdgo.Ref<Checker>, _err:stdgo.Ref<stdgo.Error>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        {
            final __type__ = ({
                final r = stdgo.Go.recover_exception;
                stdgo.Go.recover_exception = null;
                r;
            });
            if (__type__ == null || stdgo.Go.typeEquals((__type__ : T_bailout))) {
                var _p:stdgo.AnyInterface = __type__?.__underlying__();
                {
                    var __tmp__ = _check._firstErr;
                    _err.error = __tmp__.error;
                };
            } else {
                var _p:stdgo.AnyInterface = __type__?.__underlying__();
                throw stdgo.Go.toInterface(_p);
            };
        };
    }
    /**
        // initFiles initializes the files-specific portion of checker.
        // The provided files must all belong to the same package.
    **/
    @:keep
    static public function _initFiles( _check:stdgo.Ref<Checker>, _files:stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.File>>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _check._files = (null : stdgo.Slice<stdgo.Ref<stdgo.go.ast.Ast.File>>);
        _check._imports = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.PkgName>>);
        _check._dotImportMap = (null : stdgo.GoMap<stdgo.go.types.Types.T_dotImportKey, stdgo.Ref<stdgo.go.types.Types.PkgName>>);
        _check._firstErr = (null : stdgo.Error);
        _check._methods = (null : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>>);
        _check._untyped = (null : stdgo.GoMap<stdgo.go.ast.Ast.Expr, stdgo.go.types.Types.T_exprInfo>);
        _check._delayed = (null : stdgo.Slice<stdgo.go.types.Types.T_action>);
        _check._objPath = (null : stdgo.Slice<stdgo.go.types.Types.Object>);
        _check._cleaners = (null : stdgo.Slice<stdgo.go.types.Types.T_cleaner>);
        var _pkg = _check._pkg;
        for (__80 => _file in _files) {
            {
                var _name:stdgo.GoString = _file.name.name?.__copy__();
                {
                    var __switchIndex__ = -1;
                    var __run__ = true;
                    while (__run__) {
                        __run__ = false;
                        {
                            final __value__ = _pkg._name;
                            if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (__value__ == stdgo.Go.str()))) {
                                if (_name != (("_" : stdgo.GoString))) {
                                    _pkg._name = _name?.__copy__();
                                } else {
                                    _check._error(stdgo.Go.asInterface(_file.name), (2 : stdgo.internal.types.errors.Errors.Code), ("invalid package name _" : stdgo.GoString));
                                };
                                @:fallthrough {
                                    __switchIndex__ = 1;
                                    __run__ = true;
                                    continue;
                                };
                                break;
                            } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && (__value__ == _name))) {
                                _check._files = (_check._files.__append__(_file));
                                break;
                                break;
                            } else {
                                _check._errorf(stdgo.Go.asInterface((_file.package_ : T_atPos)), (3 : stdgo.internal.types.errors.Errors.Code), ("package %s; expected %s" : stdgo.GoString), stdgo.Go.toInterface(_name), stdgo.Go.toInterface(_pkg._name));
                                break;
                            };
                        };
                        break;
                    };
                };
            };
        };
        for (__121 => _file in _check._files) {
            var __tmp__ = _parseGoVersion(_file.goVersion?.__copy__()), _v:stdgo.go.types.Types.T_version = __tmp__._0, __122:stdgo.Error = __tmp__._1;
            if (_v._major > (0 : stdgo.GoInt)) {
                if (_v._equal(_check._version?.__copy__())) {
                    continue;
                };
                if ((_v._before(_check._version?.__copy__()) && _check._version._before((new stdgo.go.types.Types.T_version((1 : stdgo.GoInt), (21 : stdgo.GoInt)) : stdgo.go.types.Types.T_version))) || _check._version._equal((new stdgo.go.types.Types.T_version((0 : stdgo.GoInt), (0 : stdgo.GoInt)) : stdgo.go.types.Types.T_version))) {
                    continue;
                };
                if (_check._posVers == null) {
                    _check._posVers = ({
                        final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.token.Token.File>, stdgo.go.types.Types.T_version>();
                        @:mergeBlock {};
                        cast x;
                    } : stdgo.GoMap<stdgo.Ref<stdgo.go.token.Token.File>, stdgo.go.types.Types.T_version>);
                };
                _check._posVers[_check._fset.file(_file.fileStart)] = _v?.__copy__();
            };
        };
    }
    /**
        // needsCleanup records objects/types that implement the cleanup method
        // which will be called at the end of type-checking.
    **/
    @:keep
    static public function _needsCleanup( _check:stdgo.Ref<Checker>, _c:T_cleaner):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _check._cleaners = (_check._cleaners.__append__(_c));
    }
    /**
        // pop pops and returns the topmost object from the object path.
    **/
    @:keep
    static public function _pop( _check:stdgo.Ref<Checker>):Object {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _i:stdgo.GoInt = (_check._objPath.length) - (1 : stdgo.GoInt);
        var _obj:stdgo.go.types.Types.Object = _check._objPath[(_i : stdgo.GoInt)];
        _check._objPath[(_i : stdgo.GoInt)] = (null : stdgo.go.types.Types.Object);
        _check._objPath = (_check._objPath.__slice__(0, _i) : stdgo.Slice<stdgo.go.types.Types.Object>);
        return _obj;
    }
    /**
        // push pushes obj onto the object path and returns its index in the path.
    **/
    @:keep
    static public function _push( _check:stdgo.Ref<Checker>, _obj:Object):stdgo.GoInt {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _check._objPath = (_check._objPath.__append__(_obj));
        return (_check._objPath.length) - (1 : stdgo.GoInt);
    }
    /**
        // later pushes f on to the stack of actions that will be processed later;
        // either at the end of the current statement, or in case of a local constant
        // or variable declaration, before the constant or variable is in scope
        // (so that f still sees the scope before any new declarations).
        // later returns the pushed action so one can provide a description
        // via action.describef for debugging, if desired.
    **/
    @:keep
    static public function _later( _check:stdgo.Ref<Checker>, _f:() -> Void):stdgo.Ref<T_action> {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _i:stdgo.GoInt = (_check._delayed.length);
        _check._delayed = (_check._delayed.__append__(({ _f : _f } : stdgo.go.types.Types.T_action)));
        return (stdgo.Go.setRef(_check._delayed[(_i : stdgo.GoInt)]) : stdgo.Ref<stdgo.go.types.Types.T_action>);
    }
    @:keep
    static public function _rememberUntyped( _check:stdgo.Ref<Checker>, _e:stdgo.go.ast.Ast.Expr, _lhs:Bool, _mode:T_operandMode, _typ:stdgo.Ref<Basic>, _val:stdgo.go.constant.Constant.Value):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _m = _check._untyped;
        if (_m == null) {
            _m = ({
                final x = new stdgo.GoMap.GoObjectMap<stdgo.go.ast.Ast.Expr, stdgo.go.types.Types.T_exprInfo>();
                x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.ast.Ast.Expr", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }));
                x.__defaultValue__ = () -> ({} : stdgo.go.types.Types.T_exprInfo);
                @:mergeBlock {};
                cast x;
            } : stdgo.GoMap<stdgo.go.ast.Ast.Expr, stdgo.go.types.Types.T_exprInfo>);
            _check._untyped = _m;
        };
        _m[_e] = (new stdgo.go.types.Types.T_exprInfo(_lhs, _mode, _typ, _val) : stdgo.go.types.Types.T_exprInfo);
    }
    /**
        // isBrokenAlias reports whether alias doesn't have a determined type yet.
    **/
    @:keep
    static public function _isBrokenAlias( _check:stdgo.Ref<Checker>, _alias:stdgo.Ref<TypeName>):Bool {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        return (stdgo.Go.toInterface(_alias._object._typ) == stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]))) && (_check._brokenAliases[_alias] ?? false);
    }
    /**
        // validAlias records that alias has the valid type typ (possibly Typ[Invalid]).
    **/
    @:keep
    static public function _validAlias( _check:stdgo.Ref<Checker>, _alias:stdgo.Ref<TypeName>, _typ:Type_):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if (_check._brokenAliases != null) _check._brokenAliases.remove(_alias);
        _alias._object._typ = _typ;
    }
    /**
        // brokenAlias records that alias doesn't have a determined type yet.
        // It also sets alias.typ to Typ[Invalid].
    **/
    @:keep
    static public function _brokenAlias( _check:stdgo.Ref<Checker>, _alias:stdgo.Ref<TypeName>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if (_check._brokenAliases == null) {
            _check._brokenAliases = ({
                final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, Bool>();
                @:mergeBlock {};
                cast x;
            } : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, Bool>);
        };
        _check._brokenAliases[_alias] = true;
        _alias._object._typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
    }
    /**
        // addDeclDep adds the dependency edge (check.decl -> to) if check.decl exists
    **/
    @:keep
    static public function _addDeclDep( _check:stdgo.Ref<Checker>, _to:Object):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _from = _check._environment._decl;
        if (_from == null || (_from : Dynamic).__nil__) {
            return;
        };
        {
            var __tmp__ = (_check._objMap != null && _check._objMap.exists(_to) ? { _0 : _check._objMap[_to], _1 : true } : { _0 : (null : stdgo.Ref<stdgo.go.types.Types.T_declInfo>), _1 : false }), __24:stdgo.Ref<stdgo.go.types.Types.T_declInfo> = __tmp__._0, _found:Bool = __tmp__._1;
            if (!_found) {
                return;
            };
        };
        _from._addDep(_to);
    }
    @:keep
    static public function _use1( _check:stdgo.Ref<Checker>, _e:stdgo.go.ast.Ast.Expr, _lhs:Bool):Bool {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
        _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
        {
            final __type__ = _unparen(_e);
            {
                var __bool__ = true;
                while (__bool__) {
                    __bool__ = false;
                    if (__type__ == null) {
                        var _n:stdgo.AnyInterface = __type__ == null ? (null : stdgo.AnyInterface) : cast __type__;
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.Ident>))) {
                        var _n:stdgo.Ref<stdgo.go.ast.Ast.Ident> = __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__().value;
                        if (_n.name == (("_" : stdgo.GoString))) {
                            break;
                        };
                        var _v:stdgo.Ref<Var> = (null : stdgo.Ref<stdgo.go.types.Types.Var>);
                        var _v_used:Bool = false;
                        if (_lhs) {
                            {
                                var __tmp__ = _check._pkg._scope.lookupParent(_n.name?.__copy__(), _nopos), __8:stdgo.Ref<stdgo.go.types.Types.Scope> = __tmp__._0, _obj:stdgo.go.types.Types.Object = __tmp__._1;
                                if (_obj != null) {
                                    {
                                        var __tmp__ = try {
                                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<Var>)) : stdgo.Ref<Var>), _1 : true };
                                        } catch(_) {
                                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Var>), _1 : false };
                                        }, _w = __tmp__._0, __9 = __tmp__._1;
                                        if (((_w != null) && ((_w : Dynamic).__nil__ == null || !(_w : Dynamic).__nil__)) && (_w._object._pkg == _check._pkg)) {
                                            _v = _w;
                                            _v_used = _v._used;
                                        };
                                    };
                                };
                            };
                        };
                        _check._exprOrType((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), stdgo.Go.asInterface(_n), true);
                        if (_v != null && ((_v : Dynamic).__nil__ == null || !(_v : Dynamic).__nil__)) {
                            _v._used = _v_used;
                        };
                    } else {
                        var _n:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                        _check._rawExpr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _e, (null : stdgo.go.types.Types.Type_), true);
                    };
                    break;
                };
            };
        };
        return _x._mode != ((0 : stdgo.go.types.Types.T_operandMode));
    }
    @:keep
    static public function _useN( _check:stdgo.Ref<Checker>, _args:stdgo.Slice<stdgo.go.ast.Ast.Expr>, _lhs:Bool):Bool {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _ok:Bool = true;
        for (__0 => _e in _args) {
            if (!_check._use1(_e, _lhs)) {
                _ok = false;
            };
        };
        return _ok;
    }
    /**
        // useLHS is like use, but doesn't "use" top-level identifiers.
        // It should be called instead of use if the arguments are
        // expressions on the lhs of an assignment.
    **/
    @:keep
    static public function _useLHS( _check:stdgo.Ref<Checker>, _args:haxe.Rest<stdgo.go.ast.Ast.Expr>):Bool {
        var _args = new stdgo.Slice<stdgo.go.ast.Ast.Expr>(_args.length, 0, ..._args);
        @:recv var _check:stdgo.Ref<Checker> = _check;
        return _check._useN(_args, true);
    }
    /**
        // use type-checks each argument.
        // Useful to make sure expressions are evaluated
        // (and variables are "used") in the presence of
        // other errors. Arguments may be nil.
        // Reports if all arguments evaluated without error.
    **/
    @:keep
    static public function _use( _check:stdgo.Ref<Checker>, _args:haxe.Rest<stdgo.go.ast.Ast.Expr>):Bool {
        var _args = new stdgo.Slice<stdgo.go.ast.Ast.Expr>(_args.length, 0, ..._args);
        @:recv var _check:stdgo.Ref<Checker> = _check;
        return _check._useN(_args, false);
    }
    @:keep
    static public function _selector( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _e:stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>, _def:stdgo.Ref<Named>, _wantType:Bool):Void {
        stdgo.internal.Macro.controlFlow({
            @:recv var _check:stdgo.Ref<Checker> = _check;
            var __0:Object = (null : stdgo.go.types.Types.Object), __1:stdgo.Slice<stdgo.GoInt> = (null : stdgo.Slice<stdgo.GoInt>), __2:Bool = false, _indirect:Bool = __2, _index:stdgo.Slice<stdgo.GoInt> = __1, _obj:Object = __0;
            var _sel:stdgo.GoString = _e.sel.name?.__copy__();
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_e.x) : stdgo.Ref<stdgo.go.ast.Ast.Ident>)) : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _1 : false };
                }, _ident = __tmp__._0, _ok = __tmp__._1;
                if (_ok) {
                    var _obj:stdgo.go.types.Types.Object = _check._lookup(_ident.name?.__copy__());
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<PkgName>)) : stdgo.Ref<PkgName>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.PkgName>), _1 : false };
                        }, _pname = __tmp__._0, __8 = __tmp__._1;
                        if (_pname != null && ((_pname : Dynamic).__nil__ == null || !(_pname : Dynamic).__nil__)) {
                            _assert(_pname._object._pkg == (_check._pkg));
                            _check._recordUse(_ident, stdgo.Go.asInterface(_pname));
                            _pname._used = true;
                            var _pkg = _pname._imported;
                            var _exp:Object = (null : stdgo.go.types.Types.Object);
                            var _funcMode:stdgo.go.types.Types.T_operandMode = (7 : stdgo.go.types.Types.T_operandMode);
                            if (_pkg._cgo) {
                                if (_sel == (("malloc" : stdgo.GoString))) {
                                    _sel = ("_CMalloc" : stdgo.GoString);
                                } else {
                                    _funcMode = (10 : stdgo.go.types.Types.T_operandMode);
                                };
                                for (__25 => _prefix in _cgoPrefixes) {
                                    {
                                        var __tmp__ = _check._pkg._scope.lookupParent(_prefix + _sel?.__copy__()?.__copy__(), _check._environment._pos);
                                        _exp = __tmp__._1;
                                    };
                                    if (_exp != null) {
                                        break;
                                    };
                                };
                                if (_exp == null) {
                                    _check._errorf(stdgo.Go.asInterface(_e.sel), (73 : stdgo.internal.types.errors.Errors.Code), ("undefined: %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_e)));
                                    @:goto "Error";
                                };
                                _check._objDecl(_exp, null);
                            } else {
                                _exp = _pkg._scope.lookup(_sel?.__copy__());
                                if (_exp == null) {
                                    if (!_pkg._fake) {
                                        _check._errorf(stdgo.Go.asInterface(_e.sel), (73 : stdgo.internal.types.errors.Errors.Code), ("undefined: %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_e)));
                                    };
                                    @:goto "Error";
                                };
                                if (!_exp.exported()) {
                                    _check._errorf(stdgo.Go.asInterface(_e.sel), (74 : stdgo.internal.types.errors.Errors.Code), ("%s not exported by package %s" : stdgo.GoString), stdgo.Go.toInterface(_sel), stdgo.Go.toInterface(_pkg._name));
                                };
                            };
                            _check._recordUse(_e.sel, _exp);
                            {
                                final __type__ = _exp;
                                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Const>))) {
                                    var _exp:stdgo.Ref<stdgo.go.types.Types.Const> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Const>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Const>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Const>) : __type__.__underlying__().value;
                                    _assert(_exp.val() != null);
                                    _x._mode = (4 : stdgo.go.types.Types.T_operandMode);
                                    _x._typ = _exp._object._typ;
                                    _x._val = _exp._val;
                                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeName>))) {
                                    var _exp:stdgo.Ref<stdgo.go.types.Types.TypeName> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeName>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__().value;
                                    _x._mode = (3 : stdgo.go.types.Types.T_operandMode);
                                    _x._typ = _exp._object._typ;
                                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Var>))) {
                                    var _exp:stdgo.Ref<stdgo.go.types.Types.Var> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Var>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__().value;
                                    _x._mode = (5 : stdgo.go.types.Types.T_operandMode);
                                    _x._typ = _exp._object._typ;
                                    if (_pkg._cgo && stdgo.strings.Strings.hasPrefix(_exp._object._name?.__copy__(), ("_Cvar_" : stdgo.GoString))) {
                                        _x._typ = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_x._typ) : stdgo.Ref<Pointer_>)) : stdgo.Ref<Pointer_>)._base;
                                    };
                                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Func>))) {
                                    var _exp:stdgo.Ref<stdgo.go.types.Types.Func> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Func>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__().value;
                                    _x._mode = _funcMode;
                                    _x._typ = _exp._object._typ;
                                    if (_pkg._cgo && stdgo.strings.Strings.hasPrefix(_exp._object._name?.__copy__(), ("_Cmacro_" : stdgo.GoString))) {
                                        _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                                        _x._typ = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_x._typ) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>)._results._vars[(0 : stdgo.GoInt)]._object._typ;
                                    };
                                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Builtin>))) {
                                    var _exp:stdgo.Ref<stdgo.go.types.Types.Builtin> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Builtin>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Builtin>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Builtin>) : __type__.__underlying__().value;
                                    _x._mode = (2 : stdgo.go.types.Types.T_operandMode);
                                    _x._typ = _exp._object._typ;
                                    _x._id = _exp._id;
                                } else {
                                    var _exp:stdgo.go.types.Types.Object = __type__ == null ? (null : stdgo.go.types.Types.Object) : cast __type__;
                                    _check._dump(("%v: unexpected object %v" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_e.sel.pos())), stdgo.Go.toInterface(_exp));
                                    _unreachable();
                                };
                            };
                            _x._expr = stdgo.Go.asInterface(_e);
                            return;
                        };
                    };
                };
            };
            _check._exprOrType(_x, _e.x, false);
            {
                final __value__ = _x._mode;
                if (__value__ == ((3 : stdgo.go.types.Types.T_operandMode))) {
                    if (((_def != null) && ((_def : Dynamic).__nil__ == null || !(_def : Dynamic).__nil__)) && (stdgo.Go.toInterface(_x._typ) == stdgo.Go.toInterface(stdgo.Go.asInterface(_def)))) {
                        _check._cycleError((new stdgo.Slice<stdgo.go.types.Types.Object>(1, 1, stdgo.Go.asInterface(_def._obj)) : stdgo.Slice<stdgo.go.types.Types.Object>));
                        @:goto "Error";
                    };
                } else if (__value__ == ((2 : stdgo.go.types.Types.T_operandMode))) {
                    _check._errorf(stdgo.Go.asInterface(_e.sel), (82 : stdgo.internal.types.errors.Errors.Code), ("cannot select on %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                    @:goto "Error";
                } else if (__value__ == ((0 : stdgo.go.types.Types.T_operandMode))) {
                    @:goto "Error";
                };
            };
            if (_wantType) {
                _check._errorf(stdgo.Go.asInterface(_e.sel), (25 : stdgo.internal.types.errors.Errors.Code), ("%s is not a type" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_e)));
                @:goto "Error";
            };
            {
                var __tmp__ = lookupFieldOrMethod(_x._typ, _x._mode == ((5 : stdgo.go.types.Types.T_operandMode)), _check._pkg, _sel?.__copy__());
                _obj = __tmp__._0;
                _index = __tmp__._1;
                _indirect = __tmp__._2;
            };
            if (_obj == null) {
                if (stdgo.Go.toInterface(_under(_x._typ)) == (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                    @:goto "Error";
                };
                if (_index != null) {
                    _check._errorf(stdgo.Go.asInterface(_e.sel), (72 : stdgo.internal.types.errors.Errors.Code), ("ambiguous selector %s.%s" : stdgo.GoString), stdgo.Go.toInterface(_x._expr), stdgo.Go.toInterface(_sel));
                    @:goto "Error";
                };
                if (_indirect) {
                    if (_x._mode == ((3 : stdgo.go.types.Types.T_operandMode))) {
                        _check._errorf(stdgo.Go.asInterface(_e.sel), (125 : stdgo.internal.types.errors.Errors.Code), ("invalid method expression %s.%s (needs pointer receiver (*%s).%s)" : stdgo.GoString), stdgo.Go.toInterface(_x._typ), stdgo.Go.toInterface(_sel), stdgo.Go.toInterface(_x._typ), stdgo.Go.toInterface(_sel));
                    } else {
                        _check._errorf(stdgo.Go.asInterface(_e.sel), (125 : stdgo.internal.types.errors.Errors.Code), ("cannot call pointer method %s on %s" : stdgo.GoString), stdgo.Go.toInterface(_sel), stdgo.Go.toInterface(_x._typ));
                    };
                    @:goto "Error";
                };
                var _why:stdgo.GoString = ("" : stdgo.GoString);
                if (_isInterfacePtr(_x._typ)) {
                    _why = _check._interfacePtrError(_x._typ)?.__copy__();
                } else {
                    _why = _check._sprintf(("type %s has no field or method %s" : stdgo.GoString), stdgo.Go.toInterface(_x._typ), stdgo.Go.toInterface(_sel))?.__copy__();
                    if ((_sel.length) > (0 : stdgo.GoInt)) {
                        var _changeCase:stdgo.GoString = ("" : stdgo.GoString);
                        {
                            var _r:stdgo.GoInt32 = (_sel[(0 : stdgo.GoInt)] : stdgo.GoRune);
                            if (stdgo.unicode.Unicode.isUpper(_r)) {
                                _changeCase = (stdgo.unicode.Unicode.toLower(_r) : stdgo.GoString) + (_sel.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__()?.__copy__();
                            } else {
                                _changeCase = (stdgo.unicode.Unicode.toUpper(_r) : stdgo.GoString) + (_sel.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__()?.__copy__();
                            };
                        };
                        {
                            {
                                var __tmp__ = lookupFieldOrMethod(_x._typ, _x._mode == ((5 : stdgo.go.types.Types.T_operandMode)), _check._pkg, _changeCase?.__copy__());
                                _obj = __tmp__._0;
                            };
                            if (_obj != null) {
                                _why = _why + ((", but does have " : stdgo.GoString) + _changeCase?.__copy__())?.__copy__();
                            };
                        };
                    };
                };
                _check._errorf(stdgo.Go.asInterface(_e.sel), (76 : stdgo.internal.types.errors.Errors.Code), ("%s.%s undefined (%s)" : stdgo.GoString), stdgo.Go.toInterface(_x._expr), stdgo.Go.toInterface(_sel), stdgo.Go.toInterface(_why));
                @:goto "Error";
            };
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<Func>)) : stdgo.Ref<Func>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Func>), _1 : false };
                }, _m = __tmp__._0, __194 = __tmp__._1;
                if (_m != null && ((_m : Dynamic).__nil__ == null || !(_m : Dynamic).__nil__)) {
                    _check._objDecl(stdgo.Go.asInterface(_m), null);
                };
            };
            if (_x._mode == ((3 : stdgo.go.types.Types.T_operandMode))) {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<Func>)) : stdgo.Ref<Func>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Func>), _1 : false };
                }, _m = __tmp__._0, __203 = __tmp__._1;
                if (_m == null || (_m : Dynamic).__nil__) {
                    _check._errorf(stdgo.Go.asInterface(_e.sel), (76 : stdgo.internal.types.errors.Errors.Code), ("%s.%s undefined (type %s has no method %s)" : stdgo.GoString), stdgo.Go.toInterface(_x._expr), stdgo.Go.toInterface(_sel), stdgo.Go.toInterface(_x._typ), stdgo.Go.toInterface(_sel));
                    @:goto "Error";
                };
                _check._recordSelection(_e, (2 : stdgo.go.types.Types.SelectionKind), _x._typ, stdgo.Go.asInterface(_m), _index, _indirect);
                var _sig = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_m._object._typ) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>);
                if (_sig._recv == null || (_sig._recv : Dynamic).__nil__) {
                    _check._error(stdgo.Go.asInterface(_e), (11 : stdgo.internal.types.errors.Errors.Code), ("illegal cycle in method declaration" : stdgo.GoString));
                    @:goto "Error";
                };
                var _params:stdgo.Slice<stdgo.Ref<Var>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>);
                if (_sig._params != null && ((_sig._params : Dynamic).__nil__ == null || !(_sig._params : Dynamic).__nil__)) {
                    _params = _sig._params._vars;
                };
                var _name:stdgo.GoString = stdgo.Go.str()?.__copy__();
                if ((_params.length > (0 : stdgo.GoInt)) && (_params[(0 : stdgo.GoInt)]._object._name != stdgo.Go.str())) {
                    _name = _sig._recv._object._name?.__copy__();
                    if (_name == (stdgo.Go.str())) {
                        _name = ("_" : stdgo.GoString);
                    };
                };
                _params = ((new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>(1, 1, newVar(_sig._recv._object._pos, _sig._recv._object._pkg, _name?.__copy__(), _x._typ)) : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>).__append__(..._params.__toArray__()));
                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                _x._typ = stdgo.Go.asInterface((stdgo.Go.setRef(({ _tparams : _sig._tparams, _params : newTuple(..._params.__toArray__()), _results : _sig._results, _variadic : _sig._variadic } : stdgo.go.types.Types.Signature)) : stdgo.Ref<stdgo.go.types.Types.Signature>));
                _check._addDeclDep(stdgo.Go.asInterface(_m));
            } else {
                {
                    final __type__ = _obj;
                    if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Var>))) {
                        var _obj:stdgo.Ref<stdgo.go.types.Types.Var> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Var>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__().value;
                        _check._recordSelection(_e, (0 : stdgo.go.types.Types.SelectionKind), _x._typ, stdgo.Go.asInterface(_obj), _index, _indirect);
                        if ((_x._mode == (5 : stdgo.go.types.Types.T_operandMode)) || _indirect) {
                            _x._mode = (5 : stdgo.go.types.Types.T_operandMode);
                        } else {
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                        };
                        _x._typ = _obj._object._typ;
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Func>))) {
                        var _obj:stdgo.Ref<stdgo.go.types.Types.Func> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Func>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__().value;
                        _check._recordSelection(_e, (1 : stdgo.go.types.Types.SelectionKind), _x._typ, stdgo.Go.asInterface(_obj), _index, _indirect);
                        var _disabled:Bool = true;
                        if (!_disabled && false) {
                            var _typ:stdgo.go.types.Types.Type_ = _x._typ;
                            if (_x._mode == ((5 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    var __tmp__ = try {
                                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_typ) : stdgo.Ref<Pointer_>)) : stdgo.Ref<Pointer_>), _1 : true };
                                    } catch(_) {
                                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>), _1 : false };
                                    }, __252 = __tmp__._0, _ok = __tmp__._1;
                                    if (!_ok && !isInterface(_typ)) {
                                        _typ = stdgo.Go.asInterface((stdgo.Go.setRef(({ _base : _typ } : stdgo.go.types.Types.Pointer_)) : stdgo.Ref<stdgo.go.types.Types.Pointer_>));
                                    };
                                };
                            };
                            var _mset = newMethodSet(_typ);
                            {
                                var _m = _mset.lookup(_check._pkg, _sel?.__copy__());
                                if (((_m == null) || (_m : Dynamic).__nil__) || (stdgo.Go.toInterface(_m._obj) != stdgo.Go.toInterface(stdgo.Go.asInterface(_obj)))) {
                                    _check._dump(("%v: (%s).%v -> %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_e.pos())), stdgo.Go.toInterface(_typ), stdgo.Go.toInterface(_obj._object._name), stdgo.Go.toInterface(stdgo.Go.asInterface(_m)));
                                    _check._dump(("%s\n" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_mset)));
                                    throw stdgo.Go.toInterface(("method sets and lookup don\'t agree" : stdgo.GoString));
                                };
                            };
                        };
                        _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                        var _sig:stdgo.go.types.Types.Signature = ((stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj._object._typ) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>) : stdgo.go.types.Types.Signature)?.__copy__();
                        _sig._recv = null;
                        _x._typ = stdgo.Go.asInterface((stdgo.Go.setRef(_sig) : stdgo.Ref<stdgo.go.types.Types.Signature>));
                        _check._addDeclDep(stdgo.Go.asInterface(_obj));
                    } else {
                        var _obj:stdgo.go.types.Types.Object = __type__ == null ? (null : stdgo.go.types.Types.Object) : cast __type__;
                        _unreachable();
                    };
                };
            };
            _x._expr = stdgo.Go.asInterface(_e);
            return;
            @:label("Error") _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            _x._expr = stdgo.Go.asInterface(_e);
        });
    }
    /**
        // arguments type-checks arguments passed to a function call with the given signature.
        // The function and its arguments may be generic, and possibly partially instantiated.
        // targs and xlist are the function's type arguments (and corresponding expressions).
        // args are the function arguments. If an argument args[i] is a partially instantiated
        // generic function, atargs[i] and atxlist[i] are the corresponding type arguments
        // (and corresponding expressions).
        // If the callee is variadic, arguments adjusts its signature to match the provided
        // arguments. The type parameters and arguments of the callee and all its arguments
        // are used together to infer any missing type arguments, and the callee and argument
        // functions are instantiated as necessary.
        // The result signature is the (possibly adjusted and instantiated) function signature.
        // If an error occurred, the result signature is the incoming sig.
    **/
    @:keep
    static public function _arguments( _check:stdgo.Ref<Checker>, _call:stdgo.Ref<stdgo.go.ast.Ast.CallExpr>, _sig:stdgo.Ref<Signature>, _targs:stdgo.Slice<Type_>, _xlist:stdgo.Slice<stdgo.go.ast.Ast.Expr>, _args:stdgo.Slice<stdgo.Ref<T_operand>>, _atargs:stdgo.Slice<stdgo.Slice<Type_>>, _atxlist:stdgo.Slice<stdgo.Slice<stdgo.go.ast.Ast.Expr>>):stdgo.Ref<Signature> {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _rsig:stdgo.Ref<Signature> = (null : stdgo.Ref<stdgo.go.types.Types.Signature>);
        _rsig = _sig;
        var _nargs:stdgo.GoInt = (_args.length);
        var _npars:stdgo.GoInt = _sig._params.len();
        var _ddd:Bool = _call.ellipsis.isValid();
        var _sigParams = _sig._params;
        var _adjusted:Bool = false;
        if (_sig._variadic) {
            if (_ddd) {
                if ((_call.args.length == (1 : stdgo.GoInt)) && (_nargs > (1 : stdgo.GoInt))) {
                    _check._errorf(stdgo.Go.asInterface(_inNode(stdgo.Go.asInterface(_call), _call.ellipsis)), (81 : stdgo.internal.types.errors.Errors.Code), ("cannot use ... with %d-valued %s" : stdgo.GoString), stdgo.Go.toInterface(_nargs), stdgo.Go.toInterface(_call.args[(0 : stdgo.GoInt)]));
                    return _rsig;
                };
            } else {
                if (_nargs >= (_npars - (1 : stdgo.GoInt))) {
                    var _vars = new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>((_npars - (1 : stdgo.GoInt) : stdgo.GoInt).toBasic(), 0);
                    stdgo.Go.copySlice(_vars, _sig._params._vars);
                    var _last = _sig._params._vars[(_npars - (1 : stdgo.GoInt) : stdgo.GoInt)];
                    var _typ:stdgo.go.types.Types.Type_ = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_last._object._typ) : stdgo.Ref<Slice_>)) : stdgo.Ref<Slice_>)._elem;
                    while ((_vars.length) < _nargs) {
                        _vars = (_vars.__append__(newParam(_last._object._pos, _last._object._pkg, _last._object._name?.__copy__(), _typ)));
                    };
                    _sigParams = newTuple(..._vars.__toArray__());
                    _adjusted = true;
                    _npars = _nargs;
                } else {
                    _npars--;
                };
            };
        } else {
            if (_ddd) {
                _check._errorf(stdgo.Go.asInterface(_inNode(stdgo.Go.asInterface(_call), _call.ellipsis)), (78 : stdgo.internal.types.errors.Errors.Code), ("cannot use ... in call to non-variadic %s" : stdgo.GoString), stdgo.Go.toInterface(_call.fun));
                return _rsig;
            };
        };
        if (_nargs != (_npars)) {
            var _at:T_positioner = stdgo.Go.asInterface(_call);
            var _qualifier:stdgo.GoString = ("not enough" : stdgo.GoString);
            if (_nargs > _npars) {
                _at = _args[(_npars : stdgo.GoInt)]._expr;
                _qualifier = ("too many" : stdgo.GoString);
            } else {
                _at = stdgo.Go.asInterface((_call.rparen : T_atPos));
            };
            var _params:stdgo.Slice<stdgo.Ref<Var>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>);
            if (_sig._params != null && ((_sig._params : Dynamic).__nil__ == null || !(_sig._params : Dynamic).__nil__)) {
                _params = _sig._params._vars;
            };
            var _err = _newErrorf(_at, (126 : stdgo.internal.types.errors.Errors.Code), ("%s arguments in call to %s" : stdgo.GoString), stdgo.Go.toInterface(_qualifier), stdgo.Go.toInterface(_call.fun));
            _err._errorf(_nopos, ("have %s" : stdgo.GoString), stdgo.Go.toInterface(_check._typesSummary(_operandTypes(_args), false)));
            _err._errorf(_nopos, ("want %s" : stdgo.GoString), stdgo.Go.toInterface(_check._typesSummary(_varTypes(_params), _sig._variadic)));
            _check._report(_err);
            return _rsig;
        };
        var _tparams:stdgo.Slice<stdgo.Ref<TypeParam>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>);
        var _n:stdgo.GoInt = _sig.typeParams().len();
        if (_n > (0 : stdgo.GoInt)) {
            if (!_check._allowVersion(_check._pkg, stdgo.Go.asInterface(_call), _go1_18?.__copy__())) {
                {
                    final __type__ = _call.fun;
                    if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IndexExpr>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<stdgo.go.ast.Ast.IndexListExpr>))) {
                        var _ix = stdgo.go.internal.typeparams.Typeparams.unpackIndexExpr(_call.fun);
                        _check._versionErrorf(stdgo.Go.asInterface(_inNode(_call.fun, _ix.indexListExpr.lbrack)), _go1_18?.__copy__(), ("function instantiation" : stdgo.GoString));
                    } else {
                        _check._versionErrorf(stdgo.Go.asInterface(_inNode(stdgo.Go.asInterface(_call), _call.lparen)), _go1_18?.__copy__(), ("implicit function instantiation" : stdgo.GoString));
                    };
                };
            };
            var _tmp:Type_ = (null : stdgo.go.types.Types.Type_);
            {
                var __tmp__ = _check._renameTParams(_call.pos(), _sig.typeParams()._list(), stdgo.Go.asInterface(_sigParams));
                _tparams = __tmp__._0;
                _tmp = __tmp__._1;
            };
            _sigParams = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_tmp) : stdgo.Ref<Tuple>)) : stdgo.Ref<Tuple>);
            while ((_targs.length) < (_tparams.length)) {
                _targs = (_targs.__append__((null : stdgo.go.types.Types.Type_)));
            };
        };
        _assert((_tparams.length) == ((_targs.length)));
        var _genericArgs:stdgo.Slice<stdgo.GoInt> = (null : stdgo.Slice<stdgo.GoInt>);
        if (true) {
            for (_i => _arg in _args) {
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_arg._typ) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Signature>), _1 : false };
                    }, _asig = __tmp__._0, __80 = __tmp__._1;
                    if (((_asig != null) && ((_asig : Dynamic).__nil__ == null || !(_asig : Dynamic).__nil__)) && (_asig.typeParams().len() > (0 : stdgo.GoInt))) {
                        var __tmp__ = _check._renameTParams(_call.pos(), _asig.typeParams()._list(), stdgo.Go.asInterface(_asig)), _atparams:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>> = __tmp__._0, _tmp:stdgo.go.types.Types.Type_ = __tmp__._1;
                        _asig = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_tmp) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>);
                        _asig._tparams = (stdgo.Go.setRef((new stdgo.go.types.Types.TypeParamList(_atparams) : stdgo.go.types.Types.TypeParamList)) : stdgo.Ref<stdgo.go.types.Types.TypeParamList>);
                        _arg._typ = stdgo.Go.asInterface(_asig);
                        _tparams = (_tparams.__append__(..._atparams.__toArray__()));
                        if (_i < (_atargs.length)) {
                            _targs = (_targs.__append__(..._atargs[(_i : stdgo.GoInt)].__toArray__()));
                        };
                        while ((_targs.length) < (_tparams.length)) {
                            _targs = (_targs.__append__((null : stdgo.go.types.Types.Type_)));
                        };
                        _genericArgs = (_genericArgs.__append__(_i));
                    };
                };
            };
        };
        _assert((_tparams.length) == ((_targs.length)));
        (_genericArgs.length > (0 : stdgo.GoInt)) && _check._verifyVersionf(stdgo.Go.asInterface(_args[(_genericArgs[(0 : stdgo.GoInt)] : stdgo.GoInt)]), _go1_21?.__copy__(), ("implicitly instantiated function as argument" : stdgo.GoString));
        if ((_tparams.length) > (0 : stdgo.GoInt)) {
            _targs = _check._infer(stdgo.Go.asInterface(_call), _tparams, _targs, _sigParams, _args);
            if (_targs == null) {
                return _rsig;
            };
            if (_n > (0 : stdgo.GoInt)) {
                _rsig = _check._instantiateSignature(_call.pos(), _call.fun, _sig, (_targs.__slice__(0, _n) : stdgo.Slice<stdgo.go.types.Types.Type_>), _xlist);
                if (_adjusted) {
                    _sigParams = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_check._subst(_call.pos(), stdgo.Go.asInterface(_sigParams), _makeSubstMap((_tparams.__slice__(0, _n) : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>), (_targs.__slice__(0, _n) : stdgo.Slice<stdgo.go.types.Types.Type_>)), null, _check._context())) : stdgo.Ref<Tuple>)) : stdgo.Ref<Tuple>);
                } else {
                    _sigParams = _rsig._params;
                };
            };
            var _j:stdgo.GoInt = _n;
            for (__129 => _i in _genericArgs) {
                var _arg = _args[(_i : stdgo.GoInt)];
                var _asig = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_arg._typ) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>);
                var _k:stdgo.GoInt = _j + _asig.typeParams().len();
                _arg._typ = stdgo.Go.asInterface(_check._instantiateSignature(_call.pos(), _arg._expr, _asig, (_targs.__slice__(_j, _k) : stdgo.Slice<stdgo.go.types.Types.Type_>), (null : stdgo.Slice<stdgo.go.ast.Ast.Expr>)));
                _check._record(_arg);
                _j = _k;
            };
        };
        if ((_args.length) > (0 : stdgo.GoInt)) {
            var _context:stdgo.GoString = _check._sprintf(("argument to %s" : stdgo.GoString), stdgo.Go.toInterface(_call.fun))?.__copy__();
            for (_i => _a in _args) {
                _check._assignment(_a, _sigParams._vars[(_i : stdgo.GoInt)]._object._typ, _context?.__copy__());
            };
        };
        return _rsig;
    }
    /**
        // genericExprList is like exprList but result operands may be uninstantiated or partially
        // instantiated generic functions (where constraint information is insufficient to infer
        // the missing type arguments) for Go 1.21 and later.
        // For each non-generic or uninstantiated generic operand, the corresponding targsList and
        // xlistList elements do not exist (targsList and xlistList are nil) or the elements are nil.
        // For each partially instantiated generic function operand, the corresponding targsList and
        // xlistList elements are the operand's partial type arguments and type expression lists.
    **/
    @:keep
    static public function _genericExprList( _check:stdgo.Ref<Checker>, _elist:stdgo.Slice<stdgo.go.ast.Ast.Expr>):{ var _0 : stdgo.Slice<stdgo.Ref<T_operand>>; var _1 : stdgo.Slice<stdgo.Slice<Type_>>; var _2 : stdgo.Slice<stdgo.Slice<stdgo.go.ast.Ast.Expr>>; } {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var __deferstack__:Array<Void -> Void> = [];
        var _resList:stdgo.Slice<stdgo.Ref<T_operand>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_operand>>), _targsList:stdgo.Slice<stdgo.Slice<Type_>> = (null : stdgo.Slice<stdgo.Slice<stdgo.go.types.Types.Type_>>), _xlistList:stdgo.Slice<stdgo.Slice<stdgo.go.ast.Ast.Expr>> = (null : stdgo.Slice<stdgo.Slice<stdgo.go.ast.Ast.Expr>>);
        try {
            if (false) {
                __deferstack__.unshift(() -> {
                    var a = function():Void {
                        _assert((_targsList.length) == ((_xlistList.length)));
                        for (_i => _x in _resList) {
                            if (_i < (_targsList.length)) {
                                {
                                    var _n:stdgo.GoInt = (_targsList[(_i : stdgo.GoInt)].length);
                                    if (_n > (0 : stdgo.GoInt)) {
                                        _assert(_n < (stdgo.Go.typeAssert((stdgo.Go.toInterface(_x._typ) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>).typeParams().len());
                                    };
                                };
                            };
                        };
                    };
                    a();
                });
            };
            var _infer:Bool = true;
            var _n:stdgo.GoInt = (_elist.length);
            if ((_n > (0 : stdgo.GoInt)) && _check._allowVersion(_check._pkg, _elist[(0 : stdgo.GoInt)], _go1_21?.__copy__())) {
                _infer = false;
            };
            if (_n == ((1 : stdgo.GoInt))) {
                var _e:stdgo.go.ast.Ast.Expr = _elist[(0 : stdgo.GoInt)];
                var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                {
                    var _ix = stdgo.go.internal.typeparams.Typeparams.unpackIndexExpr(_e);
                    if (((_ix != null) && ((_ix : Dynamic).__nil__ == null || !(_ix : Dynamic).__nil__)) && _check._indexExpr((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _ix)) {
                        var __tmp__ = _check._funcInst(null, _x.pos(), (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _ix, _infer), _targs:stdgo.Slice<stdgo.go.types.Types.Type_> = __tmp__._0, _xlist:stdgo.Slice<stdgo.go.ast.Ast.Expr> = __tmp__._1;
                        if (_targs != null) {
                            _targsList = (new stdgo.Slice<stdgo.Slice<stdgo.go.types.Types.Type_>>(1, 1, _targs) : stdgo.Slice<stdgo.Slice<stdgo.go.types.Types.Type_>>);
                            _xlistList = (new stdgo.Slice<stdgo.Slice<stdgo.go.ast.Ast.Expr>>(1, 1, _xlist) : stdgo.Slice<stdgo.Slice<stdgo.go.ast.Ast.Expr>>);
                            _x._expr = _ix.orig;
                        } else {
                            _check._record((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>));
                        };
                        _resList = (new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_operand>>(1, 1, (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>)) : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_operand>>);
                    } else {
                        _check._rawExpr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _e, (null : stdgo.go.types.Types.Type_), true);
                        _check._exclude((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), (14u32 : stdgo.GoUInt));
                        {
                            var __tmp__ = try {
                                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_x._typ) : stdgo.Ref<Tuple>)) : stdgo.Ref<Tuple>), _1 : true };
                            } catch(_) {
                                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Tuple>), _1 : false };
                            }, _t = __tmp__._0, _ok = __tmp__._1;
                            if (_ok && (_x._mode != (0 : stdgo.go.types.Types.T_operandMode))) {
                                _resList = new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_operand>>((_t.len() : stdgo.GoInt).toBasic(), 0);
                                for (_i => _v in _t._vars) {
                                    _resList[(_i : stdgo.GoInt)] = (stdgo.Go.setRef(({ _mode : (7 : stdgo.go.types.Types.T_operandMode), _expr : _e, _typ : _v._object._typ } : stdgo.go.types.Types.T_operand)) : stdgo.Ref<stdgo.go.types.Types.T_operand>);
                                };
                            } else {
                                _resList = (new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_operand>>(1, 1, (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>)) : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_operand>>);
                            };
                        };
                    };
                };
            } else if (_n > (1 : stdgo.GoInt)) {
                _resList = new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_operand>>((_n : stdgo.GoInt).toBasic(), 0);
                _targsList = new stdgo.Slice<stdgo.Slice<stdgo.go.types.Types.Type_>>((_n : stdgo.GoInt).toBasic(), 0);
                _xlistList = new stdgo.Slice<stdgo.Slice<stdgo.go.ast.Ast.Expr>>((_n : stdgo.GoInt).toBasic(), 0);
                for (_i => _e in _elist) {
                    var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                    {
                        var _ix = stdgo.go.internal.typeparams.Typeparams.unpackIndexExpr(_e);
                        if (((_ix != null) && ((_ix : Dynamic).__nil__ == null || !(_ix : Dynamic).__nil__)) && _check._indexExpr((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _ix)) {
                            var __tmp__ = _check._funcInst(null, _x.pos(), (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _ix, _infer), _targs:stdgo.Slice<stdgo.go.types.Types.Type_> = __tmp__._0, _xlist:stdgo.Slice<stdgo.go.ast.Ast.Expr> = __tmp__._1;
                            if (_targs != null) {
                                _targsList[(_i : stdgo.GoInt)] = _targs;
                                _xlistList[(_i : stdgo.GoInt)] = _xlist;
                                _x._expr = _ix.orig;
                            } else {
                                _check._record((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>));
                            };
                        } else {
                            _check._genericExpr((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _e);
                        };
                    };
                    _resList[(_i : stdgo.GoInt)] = (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>);
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return { _0 : _resList, _1 : _targsList, _2 : _xlistList };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return { _0 : _resList, _1 : _targsList, _2 : _xlistList };
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return { _0 : _resList, _1 : _targsList, _2 : _xlistList };
        };
    }
    /**
        // exprList evaluates a list of expressions and returns the corresponding operands.
        // A single-element expression list may evaluate to multiple operands.
    **/
    @:keep
    static public function _exprList( _check:stdgo.Ref<Checker>, _elist:stdgo.Slice<stdgo.go.ast.Ast.Expr>):stdgo.Slice<stdgo.Ref<T_operand>> {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _xlist:stdgo.Slice<stdgo.Ref<T_operand>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_operand>>);
        {
            var _n:stdgo.GoInt = (_elist.length);
            if (_n == ((1 : stdgo.GoInt))) {
                {
                    var __tmp__ = _check._multiExpr(_elist[(0 : stdgo.GoInt)], false);
                    _xlist = __tmp__._0;
                };
            } else if (_n > (1 : stdgo.GoInt)) {
                _xlist = new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_operand>>((_n : stdgo.GoInt).toBasic(), 0);
                for (_i => _e in _elist) {
                    var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                    _check._expr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _e);
                    _xlist[(_i : stdgo.GoInt)] = (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>);
                };
            };
        };
        return _xlist;
    }
    @:keep
    static public function _callExpr( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _call:stdgo.Ref<stdgo.go.ast.Ast.CallExpr>):T_exprKind {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _ix = stdgo.go.internal.typeparams.Typeparams.unpackIndexExpr(_call.fun);
        if (_ix != null && ((_ix : Dynamic).__nil__ == null || !(_ix : Dynamic).__nil__)) {
            if (_check._indexExpr(_x, _ix)) {
                _assert(_x._mode == ((7 : stdgo.go.types.Types.T_operandMode)));
            } else {
                _ix = null;
            };
            _x._expr = _call.fun;
            _check._record(_x);
        } else {
            _check._exprOrType(_x, _call.fun, true);
        };
        {
            var __switchIndex__ = -1;
            var __run__ = true;
            while (__run__) {
                __run__ = false;
                {
                    final __value__ = _x._mode;
                    if (__value__ == ((0 : stdgo.go.types.Types.T_operandMode))) {
                        _check._use(..._call.args.__toArray__());
                        _x._expr = stdgo.Go.asInterface(_call);
                        return (2 : stdgo.go.types.Types.T_exprKind);
                        break;
                    } else if (__value__ == ((3 : stdgo.go.types.Types.T_operandMode))) {
                        _check._nonGeneric((null : stdgo.go.types.Types.Type_), _x);
                        if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                            return (0 : stdgo.go.types.Types.T_exprKind);
                        };
                        var t:stdgo.go.types.Types.Type_ = _x._typ;
                        _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                        {
                            var _n:stdgo.GoInt = (_call.args.length);
                            {
                                var __switchIndex__ = -1;
                                var __run__ = true;
                                while (__run__) {
                                    __run__ = false;
                                    {
                                        final __value__ = _n;
                                        if (__value__ == ((0 : stdgo.GoInt))) {
                                            _check._errorf(stdgo.Go.asInterface(_inNode(stdgo.Go.asInterface(_call), _call.rparen)), (126 : stdgo.internal.types.errors.Errors.Code), ("missing argument in conversion to %s" : stdgo.GoString), stdgo.Go.toInterface(t));
                                            break;
                                        } else if (__value__ == ((1 : stdgo.GoInt))) {
                                            _check._expr((null : stdgo.go.types.Types.Type_), _x, _call.args[(0 : stdgo.GoInt)]);
                                            if (_x._mode != ((0 : stdgo.go.types.Types.T_operandMode))) {
                                                if (_call.ellipsis.isValid()) {
                                                    _check._errorf(_call.args[(0 : stdgo.GoInt)], (77 : stdgo.internal.types.errors.Errors.Code), ("invalid use of ... in conversion to %s" : stdgo.GoString), stdgo.Go.toInterface(t));
                                                    break;
                                                };
                                                {
                                                    var __tmp__ = try {
                                                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(t)) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>), _1 : true };
                                                    } catch(_) {
                                                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Interface>), _1 : false };
                                                    }, _t = __tmp__._0, __64 = __tmp__._1;
                                                    if (((_t != null) && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) && !_isTypeParam(t)) {
                                                        if (!_t.isMethodSet()) {
                                                            _check._errorf(stdgo.Go.asInterface(_call), (142 : stdgo.internal.types.errors.Errors.Code), ("cannot use interface %s in conversion (contains specific type constraints or is comparable)" : stdgo.GoString), stdgo.Go.toInterface(t));
                                                            break;
                                                        };
                                                    };
                                                };
                                                _check._conversion(_x, t);
                                            };
                                            break;
                                        } else {
                                            _check._use(..._call.args.__toArray__());
                                            _check._errorf(_call.args[(_n - (1 : stdgo.GoInt) : stdgo.GoInt)], (126 : stdgo.internal.types.errors.Errors.Code), ("too many arguments in conversion to %s" : stdgo.GoString), stdgo.Go.toInterface(t));
                                        };
                                    };
                                    break;
                                };
                            };
                        };
                        _x._expr = stdgo.Go.asInterface(_call);
                        return (0 : stdgo.go.types.Types.T_exprKind);
                        break;
                    } else if (__value__ == ((2 : stdgo.go.types.Types.T_operandMode))) {
                        var _id:stdgo.go.types.Types.T_builtinId = _x._id;
                        if (!_check._builtin(_x, _call, _id)) {
                            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                        };
                        _x._expr = stdgo.Go.asInterface(_call);
                        if ((_x._mode != (0 : stdgo.go.types.Types.T_operandMode)) && (_x._mode != (4 : stdgo.go.types.Types.T_operandMode))) {
                            _check._environment._hasCallOrRecv = true;
                        };
                        return _predeclaredFuncs[(_id : stdgo.GoInt)]._kind;
                        break;
                    };
                };
                break;
            };
        };
        var _cgocall:Bool = _x._mode == ((10 : stdgo.go.types.Types.T_operandMode));
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_coreType(_x._typ)) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Signature>), _1 : false };
        }, _sig = __tmp__._0, __121 = __tmp__._1;
        if (_sig == null || (_sig : Dynamic).__nil__) {
            _check._errorf(stdgo.Go.asInterface(_x), (127 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot call non-function %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            _x._expr = stdgo.Go.asInterface(_call);
            return (2 : stdgo.go.types.Types.T_exprKind);
        };
        var _wasGeneric:Bool = _sig.typeParams().len() > (0 : stdgo.GoInt);
        var _xlist:stdgo.Slice<stdgo.go.ast.Ast.Expr> = (null : stdgo.Slice<stdgo.go.ast.Ast.Expr>);
        var _targs:stdgo.Slice<Type_> = (null : stdgo.Slice<stdgo.go.types.Types.Type_>);
        if (_ix != null && ((_ix : Dynamic).__nil__ == null || !(_ix : Dynamic).__nil__)) {
            _xlist = _ix.indexListExpr.indices;
            _targs = _check._typeList(_xlist);
            if (_targs == null) {
                _check._use(..._call.args.__toArray__());
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                _x._expr = stdgo.Go.asInterface(_call);
                return (2 : stdgo.go.types.Types.T_exprKind);
            };
            _assert((_targs.length) == ((_xlist.length)));
            var __0:stdgo.GoInt = (_targs.length), __1:stdgo.GoInt = _sig.typeParams().len(), _want:stdgo.GoInt = __1, _got:stdgo.GoInt = __0;
            if (_got > _want) {
                _check._errorf(_xlist[(_want : stdgo.GoInt)], (137 : stdgo.internal.types.errors.Errors.Code), ("got %d type arguments but want %d" : stdgo.GoString), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_want));
                _check._use(..._call.args.__toArray__());
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                _x._expr = stdgo.Go.asInterface(_call);
                return (2 : stdgo.go.types.Types.T_exprKind);
            };
            if ((_got == _want) && (_want > (0 : stdgo.GoInt))) {
                _check._verifyVersionf(stdgo.Go.asInterface((_ix.indexListExpr.lbrack : T_atPos)), _go1_18?.__copy__(), ("function instantiation" : stdgo.GoString));
                _sig = _check._instantiateSignature(_ix.pos(), _ix.orig, _sig, _targs, _xlist);
                _targs = (null : stdgo.Slice<stdgo.go.types.Types.Type_>);
                _xlist = (null : stdgo.Slice<stdgo.go.ast.Ast.Expr>);
            };
        };
        var __tmp__ = _check._genericExprList(_call.args), _args:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_operand>> = __tmp__._0, _atargs:stdgo.Slice<stdgo.Slice<stdgo.go.types.Types.Type_>> = __tmp__._1, _atxlist:stdgo.Slice<stdgo.Slice<stdgo.go.ast.Ast.Expr>> = __tmp__._2;
        _sig = _check._arguments(_call, _sig, _targs, _xlist, _args, _atargs, _atxlist);
        if (_wasGeneric && (_sig.typeParams().len() == (0 : stdgo.GoInt))) {
            _check._recordTypeAndValue(_call.fun, (7 : stdgo.go.types.Types.T_operandMode), stdgo.Go.asInterface(_sig), (null : stdgo.go.constant.Constant.Value));
        };
        {
            final __value__ = _sig._results.len();
            if (__value__ == ((0 : stdgo.GoInt))) {
                _x._mode = (1 : stdgo.go.types.Types.T_operandMode);
            } else if (__value__ == ((1 : stdgo.GoInt))) {
                if (_cgocall) {
                    _x._mode = (9 : stdgo.go.types.Types.T_operandMode);
                } else {
                    _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                };
                _x._typ = _sig._results._vars[(0 : stdgo.GoInt)]._object._typ;
            } else {
                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                _x._typ = stdgo.Go.asInterface(_sig._results);
            };
        };
        _x._expr = stdgo.Go.asInterface(_call);
        _check._environment._hasCallOrRecv = true;
        if (((_x._mode == (7 : stdgo.go.types.Types.T_operandMode)) && (_sig.typeParams().len() > (0 : stdgo.GoInt))) && _isParameterized(_sig.typeParams()._list(), _x._typ)) {
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
        };
        return (2 : stdgo.go.types.Types.T_exprKind);
    }
    @:keep
    static public function _instantiateSignature( _check:stdgo.Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _expr:stdgo.go.ast.Ast.Expr, _typ:stdgo.Ref<Signature>, _targs:stdgo.Slice<Type_>, _xlist:stdgo.Slice<stdgo.go.ast.Ast.Expr>):stdgo.Ref<Signature> {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var __deferstack__:Array<Void -> Void> = [];
        var _res:stdgo.Ref<Signature> = (null : stdgo.Ref<stdgo.go.types.Types.Signature>);
        try {
            _assert(_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__));
            _assert((_targs.length) == (_typ.typeParams().len()));
            if (_check._conf.__Trace) {
                _check._trace(_pos, ("-- instantiating signature %s with %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_typ)), stdgo.Go.toInterface(_targs));
                _check._indent++;
                __deferstack__.unshift(() -> {
                    var a = function():Void {
                        _check._indent--;
                        _check._trace(_pos, ("=> %s (under = %s)" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_res)), stdgo.Go.toInterface(_res.underlying()));
                    };
                    a();
                });
            };
            var _inst = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_check._instance(_pos, stdgo.Go.asInterface(_typ), _targs, null, _check._context())) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>);
            _assert(_inst.typeParams().len() == ((0 : stdgo.GoInt)));
            _check._recordInstance(_expr, _targs, stdgo.Go.asInterface(_inst));
            _assert((_xlist.length) <= (_targs.length));
            _check._later(function():Void {
                var _tparams = _typ.typeParams()._list();
                {
                    var __tmp__ = _check._verify(_pos, _tparams, _targs, _check._context()), _i:stdgo.GoInt = __tmp__._0, _err:stdgo.Error = __tmp__._1;
                    if (_err != null) {
                        var _pos:stdgo.go.token.Token.Pos = _pos;
                        if (_i < (_xlist.length)) {
                            _pos = _xlist[(_i : stdgo.GoInt)].pos();
                        };
                        _check._softErrorf(stdgo.Go.asInterface((_pos : T_atPos)), (139 : stdgo.internal.types.errors.Errors.Code), ("%s" : stdgo.GoString), stdgo.Go.toInterface(_err));
                    } else {
                        _check._mono._recordInstance(_check._pkg, _pos, _tparams, _targs, _xlist);
                    };
                };
            })._describef(stdgo.Go.asInterface((_pos : T_atPos)), ("verify instantiation" : stdgo.GoString));
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _inst;
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return _res;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return _res;
        };
    }
    /**
        // funcInst type-checks a function instantiation.
        // The incoming x must be a generic function.
        // If ix != nil, it provides some or all of the type arguments (ix.Indices).
        // If target type tsig != nil, the signature may be used to infer missing type
        // arguments of x, if any. At least one of tsig or inst must be provided.
        //
        // There are two modes of operation:
        //
        //  1. If infer == true, funcInst infers missing type arguments as needed and
        //     instantiates the function x. The returned results are nil.
        //
        //  2. If infer == false and inst provides all type arguments, funcInst
        //     instantiates the function x. The returned results are nil.
        //     If inst doesn't provide enough type arguments, funcInst returns the
        //     available arguments and the corresponding expression list; x remains
        //     unchanged.
        //
        // If an error (other than a version error) occurs in any case, it is reported
        // and x.mode is set to invalid.
    **/
    @:keep
    static public function _funcInst( _check:stdgo.Ref<Checker>, _tsig:stdgo.Ref<Signature>, _pos:stdgo.go.token.Token.Pos, _x:stdgo.Ref<T_operand>, _ix:stdgo.Ref<stdgo.go.internal.typeparams.Typeparams.IndexExpr>, _infer:Bool):{ var _0 : stdgo.Slice<Type_>; var _1 : stdgo.Slice<stdgo.go.ast.Ast.Expr>; } {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _assert(((_tsig != null) && ((_tsig : Dynamic).__nil__ == null || !(_tsig : Dynamic).__nil__)) || ((_ix != null) && ((_ix : Dynamic).__nil__ == null || !(_ix : Dynamic).__nil__)));
        var _instErrPos:T_positioner = (null : stdgo.go.types.Types.T_positioner);
        if (_ix != null && ((_ix : Dynamic).__nil__ == null || !(_ix : Dynamic).__nil__)) {
            _instErrPos = stdgo.Go.asInterface(_inNode(_ix.orig, _ix.indexListExpr.lbrack));
        } else {
            _instErrPos = stdgo.Go.asInterface((_pos : T_atPos));
        };
        var _versionErr:Bool = !_check._verifyVersionf(_instErrPos, _go1_18?.__copy__(), ("function instantiation" : stdgo.GoString));
        var _targs:stdgo.Slice<Type_> = (null : stdgo.Slice<stdgo.go.types.Types.Type_>);
        var _xlist:stdgo.Slice<stdgo.go.ast.Ast.Expr> = (null : stdgo.Slice<stdgo.go.ast.Ast.Expr>);
        if (_ix != null && ((_ix : Dynamic).__nil__ == null || !(_ix : Dynamic).__nil__)) {
            _xlist = _ix.indexListExpr.indices;
            _targs = _check._typeList(_xlist);
            if (_targs == null) {
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                _x._expr = stdgo.Go.asInterface(_ix);
                return { _0 : (null : stdgo.Slice<stdgo.go.types.Types.Type_>), _1 : (null : stdgo.Slice<stdgo.go.ast.Ast.Expr>) };
            };
            _assert((_targs.length) == ((_xlist.length)));
        };
        var _sig = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_x._typ) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>);
        var __0:stdgo.GoInt = (_targs.length), __1:stdgo.GoInt = _sig.typeParams().len(), _want:stdgo.GoInt = __1, _got:stdgo.GoInt = __0;
        if (_got > _want) {
            _check._errorf(_ix.indexListExpr.indices[(_got - (1 : stdgo.GoInt) : stdgo.GoInt)], (137 : stdgo.internal.types.errors.Errors.Code), ("got %d type arguments but want %d" : stdgo.GoString), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_want));
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            _x._expr = _ix.orig;
            return { _0 : (null : stdgo.Slice<stdgo.go.types.Types.Type_>), _1 : (null : stdgo.Slice<stdgo.go.ast.Ast.Expr>) };
        };
        if (_got < _want) {
            if (!_infer) {
                return { _0 : _targs, _1 : _xlist };
            };
            var _args:stdgo.Slice<stdgo.Ref<T_operand>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_operand>>);
            var _params:stdgo.Slice<stdgo.Ref<Var>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>);
            if (((_tsig != null) && ((_tsig : Dynamic).__nil__ == null || !(_tsig : Dynamic).__nil__)) && ((_sig._tparams != null) && ((_sig._tparams : Dynamic).__nil__ == null || !(_sig._tparams : Dynamic).__nil__))) {
                if (!_versionErr && !_check._allowVersion(_check._pkg, _instErrPos, _go1_21?.__copy__())) {
                    if (_ix != null && ((_ix : Dynamic).__nil__ == null || !(_ix : Dynamic).__nil__)) {
                        _check._versionErrorf(_instErrPos, _go1_21?.__copy__(), ("partially instantiated function in assignment" : stdgo.GoString));
                    } else {
                        _check._versionErrorf(_instErrPos, _go1_21?.__copy__(), ("implicitly instantiated function in assignment" : stdgo.GoString));
                    };
                };
                var _gsig = newSignatureType(null, (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>), (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>), _sig._params, _sig._results, _sig._variadic);
                _params = (new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>(1, 1, newVar(_x.pos(), _check._pkg, stdgo.Go.str()?.__copy__(), stdgo.Go.asInterface(_gsig))) : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>);
                var _expr = stdgo.go.ast.Ast.newIdent(("variable in assignment" : stdgo.GoString));
                _expr.namePos = _x.pos();
                _args = (new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_operand>>(1, 1, ({ _mode : (7 : stdgo.go.types.Types.T_operandMode), _expr : stdgo.Go.asInterface(_expr), _typ : stdgo.Go.asInterface(_tsig) } : stdgo.go.types.Types.T_operand)) : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_operand>>);
            };
            var __tmp__ = _check._renameTParams(_pos, _sig.typeParams()._list(), stdgo.Go.asInterface(newTuple(..._params.__toArray__()))), _tparams:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>> = __tmp__._0, _params2:stdgo.go.types.Types.Type_ = __tmp__._1;
            _targs = _check._infer(stdgo.Go.asInterface((_pos : T_atPos)), _tparams, _targs, (stdgo.Go.typeAssert((stdgo.Go.toInterface(_params2) : stdgo.Ref<Tuple>)) : stdgo.Ref<Tuple>), _args);
            if (_targs == null) {
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                _x._expr = stdgo.Go.asInterface(_ix);
                return { _0 : (null : stdgo.Slice<stdgo.go.types.Types.Type_>), _1 : (null : stdgo.Slice<stdgo.go.ast.Ast.Expr>) };
            };
            _got = (_targs.length);
        };
        _assert(_got == (_want));
        var _expr:stdgo.go.ast.Ast.Expr = _x._expr;
        if (_ix != null && ((_ix : Dynamic).__nil__ == null || !(_ix : Dynamic).__nil__)) {
            _expr = _ix.orig;
        };
        _sig = _check._instantiateSignature(_x.pos(), _expr, _sig, _targs, _xlist);
        _x._typ = stdgo.Go.asInterface(_sig);
        _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
        _x._expr = _expr;
        return { _0 : (null : stdgo.Slice<stdgo.go.types.Types.Type_>), _1 : (null : stdgo.Slice<stdgo.go.ast.Ast.Expr>) };
    }
    /**
        // applyTypeFunc applies f to x. If x is a type parameter,
        // the result is a type parameter constrained by an new
        // interface bound. The type bounds for that interface
        // are computed by applying f to each of the type bounds
        // of x. If any of these applications of f return nil,
        // applyTypeFunc returns nil.
        // If x is not a type parameter, the result is f(x).
    **/
    @:keep
    static public function _applyTypeFunc( _check:stdgo.Ref<Checker>, _f:Type_ -> Type_, _x:stdgo.Ref<T_operand>, _id:T_builtinId):Type_ {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_x._typ) : stdgo.Ref<TypeParam>)) : stdgo.Ref<TypeParam>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>), _1 : false };
            }, _tp = __tmp__._0, __0 = __tmp__._1;
            if (_tp != null && ((_tp : Dynamic).__nil__ == null || !(_tp : Dynamic).__nil__)) {
                var _terms:stdgo.Slice<stdgo.Ref<Term>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Term>>);
                if (!_tp._is(function(_t:stdgo.Ref<T_term>):Bool {
                    if (_t == null || (_t : Dynamic).__nil__) {
                        return false;
                    };
                    {
                        var _r:stdgo.go.types.Types.Type_ = _f(_t._typ);
                        if (_r != null) {
                            _terms = (_terms.__append__(newTerm(_t._tilde, _r)));
                            return true;
                        };
                    };
                    return false;
                })) {
                    return (null : stdgo.go.types.Types.Type_);
                };
                var _code:Code = ((0 : stdgo.GoInt) : stdgo.internal.types.errors.Errors.Code);
                {
                    final __value__ = _id;
                    if (__value__ == ((16 : stdgo.go.types.Types.T_builtinId))) {
                        _code = (93 : stdgo.internal.types.errors.Errors.Code);
                    } else if (__value__ == ((7 : stdgo.go.types.Types.T_builtinId))) {
                        _code = (89 : stdgo.internal.types.errors.Errors.Code);
                    } else if (__value__ == ((4 : stdgo.go.types.Types.T_builtinId))) {
                        _code = (87 : stdgo.internal.types.errors.Errors.Code);
                    } else {
                        _unreachable();
                    };
                };
                _check._softErrorf(stdgo.Go.asInterface(_x), _code, ("%s not supported as argument to %s for go1.18 (see go.dev/issue/50937)" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(_predeclaredFuncs[(_id : stdgo.GoInt)]._name));
                var _tpar = newTypeName(_nopos, _check._pkg, _tp._obj._object._name?.__copy__(), (null : stdgo.go.types.Types.Type_));
                var _ptyp = _check._newTypeParam(_tpar, stdgo.Go.asInterface(newInterfaceType((null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>), (new stdgo.Slice<stdgo.go.types.Types.Type_>(1, 1, stdgo.Go.asInterface(newUnion(_terms))) : stdgo.Slice<stdgo.go.types.Types.Type_>))));
                _ptyp._index = _tp._index;
                return stdgo.Go.asInterface(_ptyp);
            };
        };
        return _f(_x._typ);
    }
    /**
        // builtin type-checks a call to the built-in specified by id and
        // reports whether the call is valid, with *x holding the result;
        // but x.expr is not set. If the call is invalid, the result is
        // false, and *x is undefined.
    **/
    @:keep
    static public function _builtin( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, _call:stdgo.Ref<stdgo.go.ast.Ast.CallExpr>, _id:T_builtinId):Bool {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var __deferstack__:Array<Void -> Void> = [];
        var _0:Bool = false;
        try {
            var _argList = _call.args;
            var _bin:T__struct_7 = {
                final x = _predeclaredFuncs[(_id : stdgo.GoInt)];
                ({ _name : x._name?.__copy__(), _nargs : x._nargs, _variadic : x._variadic, _kind : x._kind } : T__struct_7);
            };
            if (_call.ellipsis.isValid() && (_id != (0 : stdgo.go.types.Types.T_builtinId))) {
                _check._errorf(stdgo.Go.asInterface((_call.ellipsis : T_atPos)), (81 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: invalid use of ... with built-in %s" : stdgo.GoString), stdgo.Go.toInterface(_bin._name));
                _check._use(..._argList.__toArray__());
                return _0;
            };
            if ((_id == (8 : stdgo.go.types.Types.T_builtinId)) || (_id == (1 : stdgo.go.types.Types.T_builtinId))) {
                {
                    var _a0 = _check._environment._hasCallOrRecv;
                    __deferstack__.unshift(() -> {
                        var a = function(_b:Bool):Void {
                            _check._environment._hasCallOrRecv = _b;
                        };
                        a(_a0);
                    });
                };
                _check._environment._hasCallOrRecv = false;
            };
            var _args:stdgo.Slice<stdgo.Ref<T_operand>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_operand>>);
            var _nargs:stdgo.GoInt = (0 : stdgo.GoInt);
            {
                final __value__ = _id;
                if (__value__ == ((9 : stdgo.go.types.Types.T_builtinId)) || __value__ == ((12 : stdgo.go.types.Types.T_builtinId)) || __value__ == ((20 : stdgo.go.types.Types.T_builtinId)) || __value__ == ((27 : stdgo.go.types.Types.T_builtinId))) {
                    _nargs = (_argList.length);
                } else {
                    _args = _check._exprList(_argList);
                    _nargs = (_args.length);
                    for (__40 => _a in _args) {
                        if (_a._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _0;
                            };
                        };
                    };
                    if (_nargs > (0 : stdgo.GoInt)) {
                        {
                            var __tmp__ = (_args[(0 : stdgo.GoInt)] : stdgo.go.types.Types.T_operand)?.__copy__();
                            _x._mode = __tmp__._mode;
                            _x._expr = __tmp__._expr;
                            _x._typ = __tmp__._typ;
                            _x._val = __tmp__._val;
                            _x._id = __tmp__._id;
                        };
                    };
                };
            };
            {
                var _msg:stdgo.GoString = stdgo.Go.str()?.__copy__();
                if (_nargs < _bin._nargs) {
                    _msg = ("not enough" : stdgo.GoString);
                } else if (!_bin._variadic && (_nargs > _bin._nargs)) {
                    _msg = ("too many" : stdgo.GoString);
                };
                if (_msg != (stdgo.Go.str())) {
                    _check._errorf(stdgo.Go.asInterface(_inNode(stdgo.Go.asInterface(_call), _call.rparen)), (126 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: %s arguments for %s (expected %d, found %d)" : stdgo.GoString), stdgo.Go.toInterface(_msg), stdgo.Go.toInterface(stdgo.Go.asInterface(_call)), stdgo.Go.toInterface(_bin._nargs), stdgo.Go.toInterface(_nargs));
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _0;
                    };
                };
            };
            {
                var __switchIndex__ = -1;
                var __run__ = true;
                while (__run__) {
                    __run__ = false;
                    {
                        final __value__ = _id;
                        if (__value__ == ((0 : stdgo.go.types.Types.T_builtinId))) {
                            var s:stdgo.go.types.Types.Type_ = _x._typ;
                            var t:Type_ = (null : stdgo.go.types.Types.Type_);
                            {
                                var __tmp__ = try {
                                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_coreType(s)) : stdgo.Ref<Slice_>)) : stdgo.Ref<Slice_>), _1 : true };
                                } catch(_) {
                                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Slice_>), _1 : false };
                                }, _s = __tmp__._0, __49 = __tmp__._1;
                                if (_s != null && ((_s : Dynamic).__nil__ == null || !(_s : Dynamic).__nil__)) {
                                    t = _s._elem;
                                } else {
                                    var _cause:stdgo.GoString = ("" : stdgo.GoString);
                                    if (_x._isNil()) {
                                        _cause = ("have untyped nil" : stdgo.GoString);
                                    } else if (_isTypeParam(s)) {
                                        {
                                            var _u:stdgo.go.types.Types.Type_ = _coreType(s);
                                            if (_u != null) {
                                                _cause = _check._sprintf(("%s has core type %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(_u))?.__copy__();
                                            } else {
                                                _cause = _check._sprintf(("%s has no core type" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)))?.__copy__();
                                            };
                                        };
                                    } else {
                                        _cause = _check._sprintf(("have %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)))?.__copy__();
                                    };
                                    _check._errorf(stdgo.Go.asInterface(_x), (83 : stdgo.internal.types.errors.Errors.Code), ("first argument to append must be a slice; %s" : stdgo.GoString), stdgo.Go.toInterface(_cause));
                                    {
                                        for (defer in __deferstack__) {
                                            defer();
                                        };
                                        return _0;
                                    };
                                };
                            };
                            if ((_nargs == (2 : stdgo.GoInt)) && _call.ellipsis.isValid()) {
                                {
                                    var __tmp__ = _x._assignableTo(_check, stdgo.Go.asInterface(newSlice(_universeByte)), (null : stdgo.Pointer<stdgo.GoString>)), _ok:Bool = __tmp__._0, __82:stdgo.internal.types.errors.Errors.Code = __tmp__._1;
                                    if (_ok) {
                                        var _y = _args[(1 : stdgo.GoInt)];
                                        {
                                            var _t:stdgo.go.types.Types.Type_ = _coreString(_y._typ);
                                            if ((_t != null) && _isString(_t)) {
                                                if (_check._recordTypes()) {
                                                    var _sig = _makeSig(s, s, _y._typ);
                                                    _sig._variadic = true;
                                                    _check._recordBuiltinType(_call.fun, _sig);
                                                };
                                                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                                                _x._typ = s;
                                                break;
                                            };
                                        };
                                    };
                                };
                            };
                            var _sig = _makeSig(s, s, stdgo.Go.asInterface(newSlice(t)));
                            _sig._variadic = true;
                            _check._arguments(_call, _sig, (null : stdgo.Slice<stdgo.go.types.Types.Type_>), (null : stdgo.Slice<stdgo.go.ast.Ast.Expr>), _args, (null : stdgo.Slice<stdgo.Slice<stdgo.go.types.Types.Type_>>), (null : stdgo.Slice<stdgo.Slice<stdgo.go.ast.Ast.Expr>>));
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = s;
                            if (_check._recordTypes()) {
                                _check._recordBuiltinType(_call.fun, _sig);
                            };
                            break;
                        } else if (__value__ == ((1 : stdgo.go.types.Types.T_builtinId)) || __value__ == ((8 : stdgo.go.types.Types.T_builtinId))) {
                            var _mode:stdgo.go.types.Types.T_operandMode = (0 : stdgo.go.types.Types.T_operandMode);
                            var _val:stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
                            {
                                final __type__ = _arrayPtrDeref(_under(_x._typ));
                                {
                                    var __bool__ = true;
                                    while (__bool__) {
                                        __bool__ = false;
                                        if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                                            var _t:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                                            if (_isString(stdgo.Go.asInterface(_t)) && (_id == (8 : stdgo.go.types.Types.T_builtinId))) {
                                                if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
                                                    _mode = (4 : stdgo.go.types.Types.T_operandMode);
                                                    _val = stdgo.go.constant.Constant.makeInt64((stdgo.go.constant.Constant.stringVal(_x._val).length : stdgo.GoInt64));
                                                } else {
                                                    _mode = (7 : stdgo.go.types.Types.T_operandMode);
                                                };
                                            };
                                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Array_>))) {
                                            var _t:stdgo.Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                                            _mode = (7 : stdgo.go.types.Types.T_operandMode);
                                            if (!_check._environment._hasCallOrRecv) {
                                                _mode = (4 : stdgo.go.types.Types.T_operandMode);
                                                if (_t._len >= (0i64 : stdgo.GoInt64)) {
                                                    _val = stdgo.go.constant.Constant.makeInt64(_t._len);
                                                } else {
                                                    _val = stdgo.go.constant.Constant.makeUnknown();
                                                };
                                            };
                                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Slice_>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Chan>))) {
                                            var _t:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                                            _mode = (7 : stdgo.go.types.Types.T_operandMode);
                                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Map_>))) {
                                            var _t:stdgo.Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                                            if (_id == ((8 : stdgo.go.types.Types.T_builtinId))) {
                                                _mode = (7 : stdgo.go.types.Types.T_operandMode);
                                            };
                                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                                            var _t:stdgo.Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                                            if (!_isTypeParam(_x._typ)) {
                                                break;
                                            };
                                            if (_t._typeSet()._underIs(function(_t:Type_):Bool {
                                                {
                                                    final __type__ = _arrayPtrDeref(_t);
                                                    if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                                                        var _t:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                                                        if (_isString(stdgo.Go.asInterface(_t)) && (_id == (8 : stdgo.go.types.Types.T_builtinId))) {
                                                            return true;
                                                        };
                                                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Array_>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Slice_>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Chan>))) {
                                                        var _t:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                                                        return true;
                                                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Map_>))) {
                                                        var _t:stdgo.Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                                                        if (_id == ((8 : stdgo.go.types.Types.T_builtinId))) {
                                                            return true;
                                                        };
                                                    };
                                                };
                                                return false;
                                            })) {
                                                _mode = (7 : stdgo.go.types.Types.T_operandMode);
                                            };
                                        };
                                        break;
                                    };
                                };
                            };
                            if (_mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                if (stdgo.Go.toInterface(_under(_x._typ)) != (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                                    var _code:stdgo.internal.types.errors.Errors.Code = (84 : stdgo.internal.types.errors.Errors.Code);
                                    if (_id == ((8 : stdgo.go.types.Types.T_builtinId))) {
                                        _code = (90 : stdgo.internal.types.errors.Errors.Code);
                                    };
                                    _check._errorf(stdgo.Go.asInterface(_x), _code, ("invalid argument: %s for %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(_bin._name));
                                };
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            if (_check._recordTypes() && (_mode != (4 : stdgo.go.types.Types.T_operandMode))) {
                                _check._recordBuiltinType(_call.fun, _makeSig(stdgo.Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]), _x._typ));
                            };
                            _x._mode = _mode;
                            _x._typ = stdgo.Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                            _x._val = _val;
                            break;
                        } else if (__value__ == ((2 : stdgo.go.types.Types.T_builtinId))) {
                            _check._verifyVersionf(_call.fun, _go1_21?.__copy__(), ("clear" : stdgo.GoString));
                            if (!_underIs(_x._typ, function(_u:Type_):Bool {
                                {
                                    final __type__ = _u;
                                    if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Map_>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Slice_>))) {
                                        return true;
                                    };
                                };
                                _check._errorf(stdgo.Go.asInterface(_x), (148 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: cannot clear %s: argument must be (or constrained by) map or slice" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                                return false;
                            })) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _x._mode = (1 : stdgo.go.types.Types.T_operandMode);
                            if (_check._recordTypes()) {
                                _check._recordBuiltinType(_call.fun, _makeSig((null : stdgo.go.types.Types.Type_), _x._typ));
                            };
                            break;
                        } else if (__value__ == ((3 : stdgo.go.types.Types.T_builtinId))) {
                            if (!_underIs(_x._typ, function(_u:Type_):Bool {
                                var __tmp__ = try {
                                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_u) : stdgo.Ref<Chan>)) : stdgo.Ref<Chan>), _1 : true };
                                } catch(_) {
                                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Chan>), _1 : false };
                                }, _uch = __tmp__._0, __187 = __tmp__._1;
                                if (_uch == null || (_uch : Dynamic).__nil__) {
                                    _check._errorf(stdgo.Go.asInterface(_x), (85 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot close non-channel %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                                    return false;
                                };
                                if (_uch._dir == ((2 : stdgo.go.types.Types.ChanDir))) {
                                    _check._errorf(stdgo.Go.asInterface(_x), (85 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot close receive-only channel %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                                    return false;
                                };
                                return true;
                            })) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _x._mode = (1 : stdgo.go.types.Types.T_operandMode);
                            if (_check._recordTypes()) {
                                _check._recordBuiltinType(_call.fun, _makeSig((null : stdgo.go.types.Types.Type_), _x._typ));
                            };
                            break;
                        } else if (__value__ == ((4 : stdgo.go.types.Types.T_builtinId))) {
                            var _y = _args[(1 : stdgo.GoInt)];
                            var _d:stdgo.GoInt = (0 : stdgo.GoInt);
                            if (_isUntyped(_x._typ)) {
                                _d = _d | ((1 : stdgo.GoInt));
                            };
                            if (_isUntyped(_y._typ)) {
                                _d = _d | ((2 : stdgo.GoInt));
                            };
                            {
                                final __value__ = _d;
                                if (__value__ == ((0 : stdgo.GoInt))) {} else if (__value__ == ((1 : stdgo.GoInt))) {
                                    _check._convertUntyped(_x, _y._typ);
                                } else if (__value__ == ((2 : stdgo.GoInt))) {
                                    _check._convertUntyped(_y, _x._typ);
                                } else if (__value__ == ((3 : stdgo.GoInt))) {
                                    if ((_x._mode == (4 : stdgo.go.types.Types.T_operandMode)) && (_y._mode == (4 : stdgo.go.types.Types.T_operandMode))) {
                                        var _toFloat = function(_x:stdgo.Ref<T_operand>):Void {
                                            if (_isNumeric(_x._typ) && (stdgo.go.constant.Constant.sign(stdgo.go.constant.Constant.imag(_x._val)) == (0 : stdgo.GoInt))) {
                                                _x._typ = stdgo.Go.asInterface(typ[((22 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                                            };
                                        };
                                        _toFloat(_x);
                                        _toFloat(_y);
                                    } else {
                                        _check._convertUntyped(_x, stdgo.Go.asInterface(typ[((14 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]));
                                        _check._convertUntyped(_y, stdgo.Go.asInterface(typ[((14 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]));
                                    };
                                };
                            };
                            if ((_x._mode == (0 : stdgo.go.types.Types.T_operandMode)) || (_y._mode == (0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            if (!identical(_x._typ, _y._typ)) {
                                _check._errorf(stdgo.Go.asInterface(_x), (87 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: %v (mismatched types %s and %s)" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_call)), stdgo.Go.toInterface(_x._typ), stdgo.Go.toInterface(_y._typ));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            var _f:stdgo.go.types.Types.Type_ -> stdgo.go.types.Types.Type_ = function(_typ:Type_):Type_ {
                                _assert(!_isTypeParam(_typ));
                                {
                                    var __tmp__ = try {
                                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_typ)) : stdgo.Ref<Basic>)) : stdgo.Ref<Basic>), _1 : true };
                                    } catch(_) {
                                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Basic>), _1 : false };
                                    }, _t = __tmp__._0, __243 = __tmp__._1;
                                    if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                                        {
                                            final __value__ = _t._kind;
                                            if (__value__ == ((13 : stdgo.go.types.Types.BasicKind))) {
                                                return stdgo.Go.asInterface(typ[((15 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                                            } else if (__value__ == ((14 : stdgo.go.types.Types.BasicKind))) {
                                                return stdgo.Go.asInterface(typ[((16 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                                            } else if (__value__ == ((22 : stdgo.go.types.Types.BasicKind))) {
                                                return stdgo.Go.asInterface(typ[((23 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                                            };
                                        };
                                    };
                                };
                                return (null : stdgo.go.types.Types.Type_);
                            };
                            var _resTyp:stdgo.go.types.Types.Type_ = _check._applyTypeFunc(_f, _x, _id);
                            if (_resTyp == null) {
                                _check._errorf(stdgo.Go.asInterface(_x), (87 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: arguments have type %s, expected floating-point" : stdgo.GoString), stdgo.Go.toInterface(_x._typ));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            if ((_x._mode == (4 : stdgo.go.types.Types.T_operandMode)) && (_y._mode == (4 : stdgo.go.types.Types.T_operandMode))) {
                                _x._val = stdgo.go.constant.Constant.binaryOp(stdgo.go.constant.Constant.toFloat(_x._val), (12 : stdgo.go.token.Token.Token), stdgo.go.constant.Constant.makeImag(stdgo.go.constant.Constant.toFloat(_y._val)));
                            } else {
                                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            };
                            if (_check._recordTypes() && (_x._mode != (4 : stdgo.go.types.Types.T_operandMode))) {
                                _check._recordBuiltinType(_call.fun, _makeSig(_resTyp, _x._typ, _x._typ));
                            };
                            _x._typ = _resTyp;
                            break;
                        } else if (__value__ == ((5 : stdgo.go.types.Types.T_builtinId))) {
                            var __tmp__ = try {
                                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_coreType(_x._typ)) : stdgo.Ref<Slice_>)) : stdgo.Ref<Slice_>), _1 : true };
                            } catch(_) {
                                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Slice_>), _1 : false };
                            }, _dst = __tmp__._0, __275 = __tmp__._1;
                            var _y = _args[(1 : stdgo.GoInt)];
                            var _src0:stdgo.go.types.Types.Type_ = _coreString(_y._typ);
                            if ((_src0 != null) && _isString(_src0)) {
                                _src0 = stdgo.Go.asInterface(newSlice(_universeByte));
                            };
                            var __tmp__ = try {
                                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_src0) : stdgo.Ref<Slice_>)) : stdgo.Ref<Slice_>), _1 : true };
                            } catch(_) {
                                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Slice_>), _1 : false };
                            }, _src = __tmp__._0, __276 = __tmp__._1;
                            if (((_dst == null) || (_dst : Dynamic).__nil__) || ((_src == null) || (_src : Dynamic).__nil__)) {
                                _check._errorf(stdgo.Go.asInterface(_x), (86 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: copy expects slice arguments; found %s and %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(stdgo.Go.asInterface(_y)));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            if (!identical(_dst._elem, _src._elem)) {
                                _check._errorf(stdgo.Go.asInterface(_x), (86 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: arguments to copy %s and %s have different element types %s and %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(stdgo.Go.asInterface(_y)), stdgo.Go.toInterface(_dst._elem), stdgo.Go.toInterface(_src._elem));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            if (_check._recordTypes()) {
                                _check._recordBuiltinType(_call.fun, _makeSig(stdgo.Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]), _x._typ, _y._typ));
                            };
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = stdgo.Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                            break;
                        } else if (__value__ == ((6 : stdgo.go.types.Types.T_builtinId))) {
                            var _map_:stdgo.go.types.Types.Type_ = _x._typ;
                            var _key:Type_ = (null : stdgo.go.types.Types.Type_);
                            if (!_underIs(_map_, function(_u:Type_):Bool {
                                var __tmp__ = try {
                                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_u) : stdgo.Ref<Map_>)) : stdgo.Ref<Map_>), _1 : true };
                                } catch(_) {
                                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Map_>), _1 : false };
                                }, _map_ = __tmp__._0, __309 = __tmp__._1;
                                if (_map_ == null || (_map_ : Dynamic).__nil__) {
                                    _check._errorf(stdgo.Go.asInterface(_x), (88 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: %s is not a map" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                                    return false;
                                };
                                if ((_key != null) && !identical(_map_._key, _key)) {
                                    _check._errorf(stdgo.Go.asInterface(_x), (88 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: maps of %s must have identical key types" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                                    return false;
                                };
                                _key = _map_._key;
                                return true;
                            })) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            {
                                var __tmp__ = (_args[(1 : stdgo.GoInt)] : stdgo.go.types.Types.T_operand)?.__copy__();
                                _x._mode = __tmp__._mode;
                                _x._expr = __tmp__._expr;
                                _x._typ = __tmp__._typ;
                                _x._val = __tmp__._val;
                                _x._id = __tmp__._id;
                            };
                            _check._assignment(_x, _key, ("argument to delete" : stdgo.GoString));
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _x._mode = (1 : stdgo.go.types.Types.T_operandMode);
                            if (_check._recordTypes()) {
                                _check._recordBuiltinType(_call.fun, _makeSig((null : stdgo.go.types.Types.Type_), _map_, _key));
                            };
                            break;
                        } else if (__value__ == ((7 : stdgo.go.types.Types.T_builtinId)) || __value__ == ((16 : stdgo.go.types.Types.T_builtinId))) {
                            if (_isUntyped(_x._typ)) {
                                if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
                                    if (_isNumeric(_x._typ)) {
                                        _x._typ = stdgo.Go.asInterface(typ[((23 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                                    };
                                } else {
                                    _check._convertUntyped(_x, stdgo.Go.asInterface(typ[((16 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]));
                                    if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                        {
                                            for (defer in __deferstack__) {
                                                defer();
                                            };
                                            return _0;
                                        };
                                    };
                                };
                            };
                            var _f:stdgo.go.types.Types.Type_ -> stdgo.go.types.Types.Type_ = function(_typ:Type_):Type_ {
                                _assert(!_isTypeParam(_typ));
                                {
                                    var __tmp__ = try {
                                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_typ)) : stdgo.Ref<Basic>)) : stdgo.Ref<Basic>), _1 : true };
                                    } catch(_) {
                                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Basic>), _1 : false };
                                    }, _t = __tmp__._0, __341 = __tmp__._1;
                                    if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                                        {
                                            final __value__ = _t._kind;
                                            if (__value__ == ((15 : stdgo.go.types.Types.BasicKind))) {
                                                return stdgo.Go.asInterface(typ[((13 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                                            } else if (__value__ == ((16 : stdgo.go.types.Types.BasicKind))) {
                                                return stdgo.Go.asInterface(typ[((14 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                                            } else if (__value__ == ((23 : stdgo.go.types.Types.BasicKind))) {
                                                return stdgo.Go.asInterface(typ[((22 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                                            };
                                        };
                                    };
                                };
                                return (null : stdgo.go.types.Types.Type_);
                            };
                            var _resTyp:stdgo.go.types.Types.Type_ = _check._applyTypeFunc(_f, _x, _id);
                            if (_resTyp == null) {
                                var _code:stdgo.internal.types.errors.Errors.Code = (89 : stdgo.internal.types.errors.Errors.Code);
                                if (_id == ((16 : stdgo.go.types.Types.T_builtinId))) {
                                    _code = (93 : stdgo.internal.types.errors.Errors.Code);
                                };
                                _check._errorf(stdgo.Go.asInterface(_x), _code, ("invalid argument: argument has type %s, expected complex type" : stdgo.GoString), stdgo.Go.toInterface(_x._typ));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
                                if (_id == ((16 : stdgo.go.types.Types.T_builtinId))) {
                                    _x._val = stdgo.go.constant.Constant.real(_x._val);
                                } else {
                                    _x._val = stdgo.go.constant.Constant.imag(_x._val);
                                };
                            } else {
                                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            };
                            if (_check._recordTypes() && (_x._mode != (4 : stdgo.go.types.Types.T_operandMode))) {
                                _check._recordBuiltinType(_call.fun, _makeSig(_resTyp, _x._typ));
                            };
                            _x._typ = _resTyp;
                            break;
                        } else if (__value__ == ((9 : stdgo.go.types.Types.T_builtinId))) {
                            var _arg0:stdgo.go.ast.Ast.Expr = _argList[(0 : stdgo.GoInt)];
                            var t:stdgo.go.types.Types.Type_ = _check._varType(_arg0);
                            if (stdgo.Go.toInterface(t) == (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            var _min:stdgo.GoInt = (0 : stdgo.GoInt);
                            {
                                final __type__ = _coreType(t);
                                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Slice_>))) {
                                    _min = (2 : stdgo.GoInt);
                                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Map_>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Chan>))) {
                                    _min = (1 : stdgo.GoInt);
                                } else if (__type__ == null) {
                                    _check._errorf(_arg0, (92 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: cannot make %s: no core type" : stdgo.GoString), stdgo.Go.toInterface(_arg0));
                                    {
                                        for (defer in __deferstack__) {
                                            defer();
                                        };
                                        return _0;
                                    };
                                } else {
                                    _check._errorf(_arg0, (92 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: cannot make %s; type must be slice, map, or channel" : stdgo.GoString), stdgo.Go.toInterface(_arg0));
                                    {
                                        for (defer in __deferstack__) {
                                            defer();
                                        };
                                        return _0;
                                    };
                                };
                            };
                            if ((_nargs < _min) || ((_min + (1 : stdgo.GoInt)) < _nargs)) {
                                _check._errorf(stdgo.Go.asInterface(_call), (126 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: %v expects %d or %d arguments; found %d" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_call)), stdgo.Go.toInterface(_min), stdgo.Go.toInterface(_min + (1 : stdgo.GoInt)), stdgo.Go.toInterface(_nargs));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            var _types = (new stdgo.Slice<stdgo.go.types.Types.Type_>(1, 1, t) : stdgo.Slice<stdgo.go.types.Types.Type_>);
                            var _sizes:stdgo.Slice<stdgo.GoInt64> = (null : stdgo.Slice<stdgo.GoInt64>);
                            for (__405 => _arg in (_argList.__slice__((1 : stdgo.GoInt)) : stdgo.Slice<stdgo.go.ast.Ast.Expr>)) {
                                var __tmp__ = _check._index(_arg, (-1i64 : stdgo.GoInt64)), _typ:stdgo.go.types.Types.Type_ = __tmp__._0, _size:stdgo.GoInt64 = __tmp__._1;
                                _types = (_types.__append__(_typ));
                                if (_size >= (0i64 : stdgo.GoInt64)) {
                                    _sizes = (_sizes.__append__(_size));
                                };
                            };
                            if ((_sizes.length == (2 : stdgo.GoInt)) && (_sizes[(0 : stdgo.GoInt)] > _sizes[(1 : stdgo.GoInt)])) {
                                _check._error(_argList[(1 : stdgo.GoInt)], (91 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: length and capacity swapped" : stdgo.GoString));
                            };
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = t;
                            if (_check._recordTypes()) {
                                _check._recordBuiltinType(_call.fun, _makeSig(_x._typ, ..._types.__toArray__()));
                            };
                            break;
                        } else if (__value__ == ((10 : stdgo.go.types.Types.T_builtinId)) || __value__ == ((11 : stdgo.go.types.Types.T_builtinId))) {
                            _check._verifyVersionf(_call.fun, _go1_21?.__copy__(), _bin._name?.__copy__());
                            var _op:stdgo.go.token.Token.Token = (40 : stdgo.go.token.Token.Token);
                            if (_id == ((10 : stdgo.go.types.Types.T_builtinId))) {
                                _op = (41 : stdgo.go.token.Token.Token);
                            };
                            for (_i => _a in _args) {
                                if (_a._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                    {
                                        for (defer in __deferstack__) {
                                            defer();
                                        };
                                        return _0;
                                    };
                                };
                                if (!_allOrdered(_a._typ)) {
                                    _check._errorf(stdgo.Go.asInterface(_a), (150 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: %s cannot be ordered" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_a)));
                                    {
                                        for (defer in __deferstack__) {
                                            defer();
                                        };
                                        return _0;
                                    };
                                };
                                if (_i > (0 : stdgo.GoInt)) {
                                    _check._matchTypes(_x, _a);
                                    if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                        {
                                            for (defer in __deferstack__) {
                                                defer();
                                            };
                                            return _0;
                                        };
                                    };
                                    if (!identical(_x._typ, _a._typ)) {
                                        _check._errorf(stdgo.Go.asInterface(_a), (46 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: mismatched types %s (previous argument) and %s (type of %s)" : stdgo.GoString), stdgo.Go.toInterface(_x._typ), stdgo.Go.toInterface(_a._typ), stdgo.Go.toInterface(_a._expr));
                                        {
                                            for (defer in __deferstack__) {
                                                defer();
                                            };
                                            return _0;
                                        };
                                    };
                                    if ((_x._mode == (4 : stdgo.go.types.Types.T_operandMode)) && (_a._mode == (4 : stdgo.go.types.Types.T_operandMode))) {
                                        if (stdgo.go.constant.Constant.compare(_a._val, _op, _x._val)) {
                                            {
                                                var __tmp__ = (_a : stdgo.go.types.Types.T_operand)?.__copy__();
                                                _x._mode = __tmp__._mode;
                                                _x._expr = __tmp__._expr;
                                                _x._typ = __tmp__._typ;
                                                _x._val = __tmp__._val;
                                                _x._id = __tmp__._id;
                                            };
                                        };
                                    } else {
                                        _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                                    };
                                };
                            };
                            if (_x._mode != ((4 : stdgo.go.types.Types.T_operandMode))) {
                                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                                _check._assignment(_x, stdgo.Go.asInterface((stdgo.Go.setRef(_emptyInterface) : stdgo.Ref<stdgo.go.types.Types.Interface>)), ("argument to " : stdgo.GoString) + _bin._name?.__copy__()?.__copy__());
                                if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                    {
                                        for (defer in __deferstack__) {
                                            defer();
                                        };
                                        return _0;
                                    };
                                };
                            };
                            for (__478 => _a in _args) {
                                _check._updateExprType(_a._expr, _x._typ, true);
                            };
                            if (_check._recordTypes() && (_x._mode != (4 : stdgo.go.types.Types.T_operandMode))) {
                                var _types = new stdgo.Slice<stdgo.go.types.Types.Type_>((_nargs : stdgo.GoInt).toBasic(), 0);
                                for (_i => _ in _types) {
                                    _types[(_i : stdgo.GoInt)] = _x._typ;
                                };
                                _check._recordBuiltinType(_call.fun, _makeSig(_x._typ, ..._types.__toArray__()));
                            };
                            break;
                        } else if (__value__ == ((12 : stdgo.go.types.Types.T_builtinId))) {
                            var t:stdgo.go.types.Types.Type_ = _check._varType(_argList[(0 : stdgo.GoInt)]);
                            if (stdgo.Go.toInterface(t) == (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = stdgo.Go.asInterface((stdgo.Go.setRef(({ _base : t } : stdgo.go.types.Types.Pointer_)) : stdgo.Ref<stdgo.go.types.Types.Pointer_>));
                            if (_check._recordTypes()) {
                                _check._recordBuiltinType(_call.fun, _makeSig(_x._typ, t));
                            };
                            break;
                        } else if (__value__ == ((13 : stdgo.go.types.Types.T_builtinId))) {
                            if (((_check._environment._sig != null) && ((_check._environment._sig : Dynamic).__nil__ == null || !(_check._environment._sig : Dynamic).__nil__)) && (_check._environment._sig._results.len() > (0 : stdgo.GoInt))) {
                                var _p = _check._environment._isPanic;
                                if (_p == null) {
                                    _p = ({
                                        final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.ast.Ast.CallExpr>, Bool>();
                                        @:mergeBlock {};
                                        cast x;
                                    } : stdgo.GoMap<stdgo.Ref<stdgo.go.ast.Ast.CallExpr>, Bool>);
                                    _check._environment._isPanic = _p;
                                };
                                _p[_call] = true;
                            };
                            _check._assignment(_x, stdgo.Go.asInterface((stdgo.Go.setRef(_emptyInterface) : stdgo.Ref<stdgo.go.types.Types.Interface>)), ("argument to panic" : stdgo.GoString));
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _x._mode = (1 : stdgo.go.types.Types.T_operandMode);
                            if (_check._recordTypes()) {
                                _check._recordBuiltinType(_call.fun, _makeSig((null : stdgo.go.types.Types.Type_), stdgo.Go.asInterface((stdgo.Go.setRef(_emptyInterface) : stdgo.Ref<stdgo.go.types.Types.Interface>))));
                            };
                            break;
                        } else if (__value__ == ((14 : stdgo.go.types.Types.T_builtinId)) || __value__ == ((15 : stdgo.go.types.Types.T_builtinId))) {
                            var _params:stdgo.Slice<Type_> = (null : stdgo.Slice<stdgo.go.types.Types.Type_>);
                            if (_nargs > (0 : stdgo.GoInt)) {
                                _params = new stdgo.Slice<stdgo.go.types.Types.Type_>((_nargs : stdgo.GoInt).toBasic(), 0);
                                for (_i => _a in _args) {
                                    _check._assignment(_a, (null : stdgo.go.types.Types.Type_), ("argument to " : stdgo.GoString) + _predeclaredFuncs[(_id : stdgo.GoInt)]._name?.__copy__()?.__copy__());
                                    if (_a._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                        {
                                            for (defer in __deferstack__) {
                                                defer();
                                            };
                                            return _0;
                                        };
                                    };
                                    _params[(_i : stdgo.GoInt)] = _a._typ;
                                };
                            };
                            _x._mode = (1 : stdgo.go.types.Types.T_operandMode);
                            if (_check._recordTypes()) {
                                _check._recordBuiltinType(_call.fun, _makeSig((null : stdgo.go.types.Types.Type_), ..._params.__toArray__()));
                            };
                            break;
                        } else if (__value__ == ((17 : stdgo.go.types.Types.T_builtinId))) {
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = stdgo.Go.asInterface((stdgo.Go.setRef(_emptyInterface) : stdgo.Ref<stdgo.go.types.Types.Interface>));
                            if (_check._recordTypes()) {
                                _check._recordBuiltinType(_call.fun, _makeSig(_x._typ));
                            };
                            break;
                        } else if (__value__ == ((18 : stdgo.go.types.Types.T_builtinId))) {
                            _check._verifyVersionf(_call.fun, _go1_17?.__copy__(), ("unsafe.Add" : stdgo.GoString));
                            _check._assignment(_x, stdgo.Go.asInterface(typ[((18 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]), ("argument to unsafe.Add" : stdgo.GoString));
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            var _y = _args[(1 : stdgo.GoInt)];
                            if (!_check._isValidIndex(_y, (133 : stdgo.internal.types.errors.Errors.Code), ("length" : stdgo.GoString), true)) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = stdgo.Go.asInterface(typ[((18 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                            if (_check._recordTypes()) {
                                _check._recordBuiltinType(_call.fun, _makeSig(_x._typ, _x._typ, _y._typ));
                            };
                            break;
                        } else if (__value__ == ((19 : stdgo.go.types.Types.T_builtinId))) {
                            _check._assignment(_x, (null : stdgo.go.types.Types.Type_), ("argument to unsafe.Alignof" : stdgo.GoString));
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            if (_hasVarSize(_x._typ, (null : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Named>, Bool>))) {
                                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                                if (_check._recordTypes()) {
                                    _check._recordBuiltinType(_call.fun, _makeSig(stdgo.Go.asInterface(typ[((12 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]), _x._typ));
                                };
                            } else {
                                _x._mode = (4 : stdgo.go.types.Types.T_operandMode);
                                _x._val = stdgo.go.constant.Constant.makeInt64(_check._conf._alignof(_x._typ));
                            };
                            _x._typ = stdgo.Go.asInterface(typ[((12 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                            break;
                        } else if (__value__ == ((20 : stdgo.go.types.Types.T_builtinId))) {
                            var _arg0:stdgo.go.ast.Ast.Expr = _argList[(0 : stdgo.GoInt)];
                            var __tmp__ = try {
                                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_unparen(_arg0)) : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>)) : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>), _1 : true };
                            } catch(_) {
                                { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>), _1 : false };
                            }, _selx = __tmp__._0, __695 = __tmp__._1;
                            if (_selx == null || (_selx : Dynamic).__nil__) {
                                _check._errorf(_arg0, (98 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: %s is not a selector expression" : stdgo.GoString), stdgo.Go.toInterface(_arg0));
                                _check._use(_arg0);
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _check._expr((null : stdgo.go.types.Types.Type_), _x, _selx.x);
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            var _base:stdgo.go.types.Types.Type_ = _derefStructPtr(_x._typ);
                            var _sel:stdgo.GoString = _selx.sel.name?.__copy__();
                            var __tmp__ = lookupFieldOrMethod(_base, false, _check._pkg, _sel?.__copy__()), _obj:stdgo.go.types.Types.Object = __tmp__._0, _index:stdgo.Slice<stdgo.GoInt> = __tmp__._1, _indirect:Bool = __tmp__._2;
                            {
                                final __type__ = _obj;
                                if (__type__ == null) {
                                    _check._errorf(stdgo.Go.asInterface(_x), (76 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: %s has no single field %s" : stdgo.GoString), stdgo.Go.toInterface(_base), stdgo.Go.toInterface(_sel));
                                    {
                                        for (defer in __deferstack__) {
                                            defer();
                                        };
                                        return _0;
                                    };
                                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Func>))) {
                                    _check._errorf(_arg0, (99 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: %s is a method value" : stdgo.GoString), stdgo.Go.toInterface(_arg0));
                                    {
                                        for (defer in __deferstack__) {
                                            defer();
                                        };
                                        return _0;
                                    };
                                };
                            };
                            if (_indirect) {
                                _check._errorf(stdgo.Go.asInterface(_x), (99 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: field %s is embedded via a pointer in %s" : stdgo.GoString), stdgo.Go.toInterface(_sel), stdgo.Go.toInterface(_base));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _check._recordSelection(_selx, (0 : stdgo.go.types.Types.SelectionKind), _base, _obj, _index, false);
                            {
                                var _mode:stdgo.go.types.Types.T_operandMode = (7 : stdgo.go.types.Types.T_operandMode);
                                if ((_x._mode == (5 : stdgo.go.types.Types.T_operandMode)) || _indirect) {
                                    _mode = (5 : stdgo.go.types.Types.T_operandMode);
                                };
                                _check._record((stdgo.Go.setRef((new stdgo.go.types.Types.T_operand(_mode, stdgo.Go.asInterface(_selx), _obj.type(), (null : stdgo.go.constant.Constant.Value), (0 : stdgo.go.types.Types.T_builtinId)) : stdgo.go.types.Types.T_operand)) : stdgo.Ref<stdgo.go.types.Types.T_operand>));
                            };
                            if (_hasVarSize(_base, (null : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Named>, Bool>))) {
                                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                                if (_check._recordTypes()) {
                                    _check._recordBuiltinType(_call.fun, _makeSig(stdgo.Go.asInterface(typ[((12 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]), _obj.type()));
                                };
                            } else {
                                var _offs:stdgo.GoInt64 = _check._conf._offsetof(_base, _index);
                                if (_offs < (0i64 : stdgo.GoInt64)) {
                                    _check._errorf(stdgo.Go.asInterface(_x), (149 : stdgo.internal.types.errors.Errors.Code), ("%s is too large" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                                    {
                                        for (defer in __deferstack__) {
                                            defer();
                                        };
                                        return _0;
                                    };
                                };
                                _x._mode = (4 : stdgo.go.types.Types.T_operandMode);
                                _x._val = stdgo.go.constant.Constant.makeInt64(_offs);
                            };
                            _x._typ = stdgo.Go.asInterface(typ[((12 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                            break;
                        } else if (__value__ == ((21 : stdgo.go.types.Types.T_builtinId))) {
                            _check._assignment(_x, (null : stdgo.go.types.Types.Type_), ("argument to unsafe.Sizeof" : stdgo.GoString));
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            if (_hasVarSize(_x._typ, (null : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Named>, Bool>))) {
                                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                                if (_check._recordTypes()) {
                                    _check._recordBuiltinType(_call.fun, _makeSig(stdgo.Go.asInterface(typ[((12 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]), _x._typ));
                                };
                            } else {
                                var _size:stdgo.GoInt64 = _check._conf._sizeof(_x._typ);
                                if (_size < (0i64 : stdgo.GoInt64)) {
                                    _check._errorf(stdgo.Go.asInterface(_x), (149 : stdgo.internal.types.errors.Errors.Code), ("%s is too large" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                                    {
                                        for (defer in __deferstack__) {
                                            defer();
                                        };
                                        return _0;
                                    };
                                };
                                _x._mode = (4 : stdgo.go.types.Types.T_operandMode);
                                _x._val = stdgo.go.constant.Constant.makeInt64(_size);
                            };
                            _x._typ = stdgo.Go.asInterface(typ[((12 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                            break;
                        } else if (__value__ == ((22 : stdgo.go.types.Types.T_builtinId))) {
                            _check._verifyVersionf(_call.fun, _go1_17?.__copy__(), ("unsafe.Slice" : stdgo.GoString));
                            var __tmp__ = try {
                                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_x._typ)) : stdgo.Ref<Pointer_>)) : stdgo.Ref<Pointer_>), _1 : true };
                            } catch(_) {
                                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>), _1 : false };
                            }, _ptr = __tmp__._0, __848 = __tmp__._1;
                            if (_ptr == null || (_ptr : Dynamic).__nil__) {
                                _check._errorf(stdgo.Go.asInterface(_x), (134 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: %s is not a pointer" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            var _y = _args[(1 : stdgo.GoInt)];
                            if (!_check._isValidIndex(_y, (134 : stdgo.internal.types.errors.Errors.Code), ("length" : stdgo.GoString), false)) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = stdgo.Go.asInterface(newSlice(_ptr._base));
                            if (_check._recordTypes()) {
                                _check._recordBuiltinType(_call.fun, _makeSig(_x._typ, stdgo.Go.asInterface(_ptr), _y._typ));
                            };
                            break;
                        } else if (__value__ == ((23 : stdgo.go.types.Types.T_builtinId))) {
                            _check._verifyVersionf(_call.fun, _go1_20?.__copy__(), ("unsafe.SliceData" : stdgo.GoString));
                            var __tmp__ = try {
                                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_x._typ)) : stdgo.Ref<Slice_>)) : stdgo.Ref<Slice_>), _1 : true };
                            } catch(_) {
                                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Slice_>), _1 : false };
                            }, _slice = __tmp__._0, __889 = __tmp__._1;
                            if (_slice == null || (_slice : Dynamic).__nil__) {
                                _check._errorf(stdgo.Go.asInterface(_x), (145 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: %s is not a slice" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = stdgo.Go.asInterface(newPointer(_slice._elem));
                            if (_check._recordTypes()) {
                                _check._recordBuiltinType(_call.fun, _makeSig(_x._typ, stdgo.Go.asInterface(_slice)));
                            };
                            break;
                        } else if (__value__ == ((24 : stdgo.go.types.Types.T_builtinId))) {
                            _check._verifyVersionf(_call.fun, _go1_20?.__copy__(), ("unsafe.String" : stdgo.GoString));
                            _check._assignment(_x, stdgo.Go.asInterface(newPointer(_universeByte)), ("argument to unsafe.String" : stdgo.GoString));
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            var _y = _args[(1 : stdgo.GoInt)];
                            if (!_check._isValidIndex(_y, (146 : stdgo.internal.types.errors.Errors.Code), ("length" : stdgo.GoString), false)) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = stdgo.Go.asInterface(typ[((17 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                            if (_check._recordTypes()) {
                                _check._recordBuiltinType(_call.fun, _makeSig(_x._typ, stdgo.Go.asInterface(newPointer(_universeByte)), _y._typ));
                            };
                            break;
                        } else if (__value__ == ((25 : stdgo.go.types.Types.T_builtinId))) {
                            _check._verifyVersionf(_call.fun, _go1_20?.__copy__(), ("unsafe.StringData" : stdgo.GoString));
                            _check._assignment(_x, stdgo.Go.asInterface(typ[((17 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]), ("argument to unsafe.StringData" : stdgo.GoString));
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = stdgo.Go.asInterface(newPointer(_universeByte));
                            if (_check._recordTypes()) {
                                _check._recordBuiltinType(_call.fun, _makeSig(_x._typ, stdgo.Go.asInterface(typ[((17 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])));
                            };
                            break;
                        } else if (__value__ == ((26 : stdgo.go.types.Types.T_builtinId))) {
                            if ((_x._mode != (4 : stdgo.go.types.Types.T_operandMode)) || !_isBoolean(_x._typ)) {
                                _check._errorf(stdgo.Go.asInterface(_x), (1 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: %s is not a boolean constant" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            if (_x._val.kind() != ((1 : stdgo.go.constant.Constant.Kind))) {
                                _check._errorf(stdgo.Go.asInterface(_x), (1 : stdgo.internal.types.errors.Errors.Code), ("internal error: value of %s should be a boolean constant" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            if (!stdgo.go.constant.Constant.boolVal(_x._val)) {
                                _check._errorf(stdgo.Go.asInterface(_call), (1 : stdgo.internal.types.errors.Errors.Code), ("%v failed" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_call)));
                            };
                            break;
                        } else if (__value__ == ((27 : stdgo.go.types.Types.T_builtinId))) {
                            if (_nargs == ((0 : stdgo.GoInt))) {
                                _check._dump(("%v: trace() without arguments" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_call.pos())));
                                _x._mode = (1 : stdgo.go.types.Types.T_operandMode);
                                break;
                            };
                            var _t:T_operand = ({} : stdgo.go.types.Types.T_operand);
                            var _x1 = _x;
                            for (__1018 => _arg in _argList) {
                                _check._rawExpr((null : stdgo.go.types.Types.Type_), _x1, _arg, (null : stdgo.go.types.Types.Type_), false);
                                _check._dump(("%v: %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x1.pos())), stdgo.Go.toInterface(stdgo.Go.asInterface(_x1)));
                                _x1 = (stdgo.Go.setRef(_t) : stdgo.Ref<stdgo.go.types.Types.T_operand>);
                            };
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            break;
                        } else {
                            _unreachable();
                        };
                    };
                    break;
                };
            };
            _assert(_x._mode != ((0 : stdgo.go.types.Types.T_operandMode)));
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return true;
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return _0;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return _0;
        };
    }
    @:keep
    static public function _shortVarDecl( _check:stdgo.Ref<Checker>, _pos:T_positioner, _lhs:stdgo.Slice<stdgo.go.ast.Ast.Expr>, _rhs:stdgo.Slice<stdgo.go.ast.Ast.Expr>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _top:stdgo.GoInt = (_check._delayed.length);
        var _scope = _check._pkg._scope;
        var _seen = ({
            final x = new stdgo.GoMap.GoStringMap<Bool>();
            x.__defaultValue__ = () -> false;
            @:mergeBlock {};
            x;
        } : stdgo.GoMap<stdgo.GoString, Bool>);
        var _lhsVars = new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>((_lhs.length : stdgo.GoInt).toBasic(), 0);
        var _newVars = new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>((0 : stdgo.GoInt).toBasic(), (_lhs.length));
        var _hasErr:Bool = false;
        for (_i => _lhs in _lhs) {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_lhs) : stdgo.Ref<stdgo.go.ast.Ast.Ident>)) : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _1 : false };
            }, _ident = __tmp__._0, __16 = __tmp__._1;
            if (_ident == null || (_ident : Dynamic).__nil__) {
                _check._useLHS(_lhs);
                _check._errorf(_lhs, (131 : stdgo.internal.types.errors.Errors.Code), ("non-name %s on left side of :=" : stdgo.GoString), stdgo.Go.toInterface(_lhs));
                _hasErr = true;
                continue;
            };
            var _name:stdgo.GoString = _ident.name?.__copy__();
            if (_name != (("_" : stdgo.GoString))) {
                if ((_seen[_name] ?? false)) {
                    _check._errorf(_lhs, (132 : stdgo.internal.types.errors.Errors.Code), ("%s repeated on left side of :=" : stdgo.GoString), stdgo.Go.toInterface(_lhs));
                    _hasErr = true;
                    continue;
                };
                _seen[_name] = true;
            };
            {
                var _alt:stdgo.go.types.Types.Object = _scope.lookup(_name?.__copy__());
                if (_alt != null) {
                    _check._recordUse(_ident, _alt);
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_alt) : stdgo.Ref<Var>)) : stdgo.Ref<Var>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Var>), _1 : false };
                        }, _obj = __tmp__._0, __49 = __tmp__._1;
                        if (_obj != null && ((_obj : Dynamic).__nil__ == null || !(_obj : Dynamic).__nil__)) {
                            _lhsVars[(_i : stdgo.GoInt)] = _obj;
                        } else {
                            _check._errorf(_lhs, (18 : stdgo.internal.types.errors.Errors.Code), ("cannot assign to %s" : stdgo.GoString), stdgo.Go.toInterface(_lhs));
                            _hasErr = true;
                        };
                    };
                    continue;
                };
            };
            var _obj = newVar(_ident.pos(), _check._pkg, _name?.__copy__(), (null : stdgo.go.types.Types.Type_));
            _lhsVars[(_i : stdgo.GoInt)] = _obj;
            if (_name != (("_" : stdgo.GoString))) {
                _newVars = (_newVars.__append__(_obj));
            };
            _check._recordDef(_ident, stdgo.Go.asInterface(_obj));
        };
        for (_i => _obj in _lhsVars) {
            if (_obj == null || (_obj : Dynamic).__nil__) {
                _lhsVars[(_i : stdgo.GoInt)] = newVar(_lhs[(_i : stdgo.GoInt)].pos(), _check._pkg, ("_" : stdgo.GoString), (null : stdgo.go.types.Types.Type_));
            };
        };
        _check._initVars(_lhsVars, _rhs, (null : stdgo.go.ast.Ast.Stmt));
        _check._processDelayed(_top);
        if ((_newVars.length == (0 : stdgo.GoInt)) && !_hasErr) {
            _check._softErrorf(_pos, (19 : stdgo.internal.types.errors.Errors.Code), ("no new variables on left side of :=" : stdgo.GoString));
            return;
        };
        var _scopePos:stdgo.go.token.Token.Pos = _rhs[((_rhs.length) - (1 : stdgo.GoInt) : stdgo.GoInt)].end();
        for (__106 => _obj in _newVars) {
            _check._declare(_scope, null, stdgo.Go.asInterface(_obj), _scopePos);
        };
    }
    /**
        // assignVars type-checks assignments of expressions orig_rhs to variables lhs.
    **/
    @:keep
    static public function _assignVars( _check:stdgo.Ref<Checker>, _lhs:stdgo.Slice<stdgo.go.ast.Ast.Expr>, _orig_rhs:stdgo.Slice<stdgo.go.ast.Ast.Expr>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var __0:stdgo.GoInt = (_lhs.length), __1:stdgo.GoInt = (_orig_rhs.length), _r:stdgo.GoInt = __1, _l:stdgo.GoInt = __0;
        var _isCall:Bool = false;
        if (_r == ((1 : stdgo.GoInt))) {
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_unparen(_orig_rhs[(0 : stdgo.GoInt)])) : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>)) : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>), _1 : false };
                };
                _isCall = __tmp__._1;
            };
        };
        if ((_l == _r) && !_isCall) {
            for (_i => _lhs in _lhs) {
                _check._assignVar(_lhs, _orig_rhs[(_i : stdgo.GoInt)], null);
            };
            return;
        };
        if (_r != ((1 : stdgo.GoInt))) {
            var _okLHS:Bool = _check._useLHS(..._lhs.__toArray__());
            var _okRHS:Bool = _check._use(..._orig_rhs.__toArray__());
            if (_okLHS && _okRHS) {
                _check._assignError(_orig_rhs, _l, _r);
            };
            return;
        };
        var __tmp__ = _check._multiExpr(_orig_rhs[(0 : stdgo.GoInt)], _l == ((2 : stdgo.GoInt))), _rhs:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_operand>> = __tmp__._0, _commaOk:Bool = __tmp__._1;
        _r = (_rhs.length);
        if (_l == (_r)) {
            for (_i => _lhs in _lhs) {
                _check._assignVar(_lhs, (null : stdgo.go.ast.Ast.Expr), _rhs[(_i : stdgo.GoInt)]);
            };
            if ((_commaOk && (_rhs[(0 : stdgo.GoInt)]._mode != (0 : stdgo.go.types.Types.T_operandMode))) && (_rhs[(1 : stdgo.GoInt)]._mode != (0 : stdgo.go.types.Types.T_operandMode))) {
                _check._recordCommaOkTypes(_orig_rhs[(0 : stdgo.GoInt)], _rhs);
            };
            return;
        };
        if (_rhs[(0 : stdgo.GoInt)]._mode != ((0 : stdgo.go.types.Types.T_operandMode))) {
            _check._assignError(_orig_rhs, _l, _r);
        };
        _check._useLHS(..._lhs.__toArray__());
    }
    /**
        // initVars type-checks assignments of initialization expressions orig_rhs
        // to variables lhs.
        // If returnStmt is non-nil, initVars type-checks the implicit assignment
        // of result expressions orig_rhs to function result parameters lhs.
    **/
    @:keep
    static public function _initVars( _check:stdgo.Ref<Checker>, _lhs:stdgo.Slice<stdgo.Ref<Var>>, _orig_rhs:stdgo.Slice<stdgo.go.ast.Ast.Expr>, _returnStmt:stdgo.go.ast.Ast.Stmt):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _context:stdgo.GoString = ("assignment" : stdgo.GoString);
        if (_returnStmt != null) {
            _context = ("return statement" : stdgo.GoString);
        };
        var __0:stdgo.GoInt = (_lhs.length), __1:stdgo.GoInt = (_orig_rhs.length), _r:stdgo.GoInt = __1, _l:stdgo.GoInt = __0;
        var _isCall:Bool = false;
        if (_r == ((1 : stdgo.GoInt))) {
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_unparen(_orig_rhs[(0 : stdgo.GoInt)])) : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>)) : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>), _1 : false };
                };
                _isCall = __tmp__._1;
            };
        };
        if ((_l == _r) && !_isCall) {
            var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
            for (_i => _lhs in _lhs) {
                _check._expr(_lhs._object._typ, (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _orig_rhs[(_i : stdgo.GoInt)]);
                _check._initVar(_lhs, (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _context?.__copy__());
            };
            return;
        };
        if (_r != ((1 : stdgo.GoInt))) {
            if (_check._use(..._orig_rhs.__toArray__())) {
                if (_returnStmt != null) {
                    var _rhs = _check._exprList(_orig_rhs);
                    _check._returnError(_returnStmt, _lhs, _rhs);
                } else {
                    _check._assignError(_orig_rhs, _l, _r);
                };
            };
            for (__48 => _v in _lhs) {
                if (_v._object._typ == null) {
                    _v._object._typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                };
            };
            return;
        };
        var __tmp__ = _check._multiExpr(_orig_rhs[(0 : stdgo.GoInt)], (_l == (2 : stdgo.GoInt)) && (_returnStmt == null)), _rhs:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.T_operand>> = __tmp__._0, _commaOk:Bool = __tmp__._1;
        _r = (_rhs.length);
        if (_l == (_r)) {
            for (_i => _lhs in _lhs) {
                _check._initVar(_lhs, _rhs[(_i : stdgo.GoInt)], _context?.__copy__());
            };
            if ((_commaOk && (_rhs[(0 : stdgo.GoInt)]._mode != (0 : stdgo.go.types.Types.T_operandMode))) && (_rhs[(1 : stdgo.GoInt)]._mode != (0 : stdgo.go.types.Types.T_operandMode))) {
                _check._recordCommaOkTypes(_orig_rhs[(0 : stdgo.GoInt)], _rhs);
            };
            return;
        };
        if (_rhs[(0 : stdgo.GoInt)]._mode != ((0 : stdgo.go.types.Types.T_operandMode))) {
            if (_returnStmt != null) {
                _check._returnError(_returnStmt, _lhs, _rhs);
            } else {
                _check._assignError(_orig_rhs, _l, _r);
            };
        };
        for (__89 => _v in _lhs) {
            if (_v._object._typ == null) {
                _v._object._typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
            };
        };
    }
    @:keep
    static public function _returnError( _check:stdgo.Ref<Checker>, _at:T_positioner, _lhs:stdgo.Slice<stdgo.Ref<Var>>, _rhs:stdgo.Slice<stdgo.Ref<T_operand>>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var __0:stdgo.GoInt = (_lhs.length), __1:stdgo.GoInt = (_rhs.length), _r:stdgo.GoInt = __1, _l:stdgo.GoInt = __0;
        var _qualifier:stdgo.GoString = ("not enough" : stdgo.GoString);
        if (_r > _l) {
            _at = stdgo.Go.asInterface(_rhs[(_l : stdgo.GoInt)]);
            _qualifier = ("too many" : stdgo.GoString);
        } else if (_r > (0 : stdgo.GoInt)) {
            _at = stdgo.Go.asInterface(_rhs[(_r - (1 : stdgo.GoInt) : stdgo.GoInt)]);
        };
        var _err:T_error_ = ({} : stdgo.go.types.Types.T_error_);
        _err._code = (103 : stdgo.internal.types.errors.Errors.Code);
        _err._errorf(_at.pos(), ("%s return values" : stdgo.GoString), stdgo.Go.toInterface(_qualifier));
        _err._errorf(_nopos, ("have %s" : stdgo.GoString), stdgo.Go.toInterface(_check._typesSummary(_operandTypes(_rhs), false)));
        _err._errorf(_nopos, ("want %s" : stdgo.GoString), stdgo.Go.toInterface(_check._typesSummary(_varTypes(_lhs), false)));
        _check._report((stdgo.Go.setRef(_err) : stdgo.Ref<stdgo.go.types.Types.T_error_>));
    }
    @:keep
    static public function _assignError( _check:stdgo.Ref<Checker>, _rhs:stdgo.Slice<stdgo.go.ast.Ast.Expr>, _l:stdgo.GoInt, _r:stdgo.GoInt):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _vars:stdgo.GoString = _measure(_l, ("variable" : stdgo.GoString))?.__copy__();
        var _vals:stdgo.GoString = _measure(_r, ("value" : stdgo.GoString))?.__copy__();
        var _rhs0:stdgo.go.ast.Ast.Expr = _rhs[(0 : stdgo.GoInt)];
        if ((_rhs.length) == ((1 : stdgo.GoInt))) {
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_unparen(_rhs0)) : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>)) : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.CallExpr>), _1 : false };
                }, _call = __tmp__._0, __0 = __tmp__._1;
                if (_call != null && ((_call : Dynamic).__nil__ == null || !(_call : Dynamic).__nil__)) {
                    _check._errorf(_rhs0, (17 : stdgo.internal.types.errors.Errors.Code), ("assignment mismatch: %s but %s returns %s" : stdgo.GoString), stdgo.Go.toInterface(_vars), stdgo.Go.toInterface(_call.fun), stdgo.Go.toInterface(_vals));
                    return;
                };
            };
        };
        _check._errorf(_rhs0, (17 : stdgo.internal.types.errors.Errors.Code), ("assignment mismatch: %s but %s" : stdgo.GoString), stdgo.Go.toInterface(_vars), stdgo.Go.toInterface(_vals));
    }
    /**
        // typesSummary returns a string of the form "(t1, t2, ...)" where the
        // ti's are user-friendly string representations for the given types.
        // If variadic is set and the last type is a slice, its string is of
        // the form "...E" where E is the slice's element type.
    **/
    @:keep
    static public function _typesSummary( _check:stdgo.Ref<Checker>, _list:stdgo.Slice<Type_>, _variadic:Bool):stdgo.GoString {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var _res:stdgo.Slice<stdgo.GoString> = (null : stdgo.Slice<stdgo.GoString>);
        for (_i => _t in _list) {
            var _s:stdgo.GoString = ("" : stdgo.GoString);
            {
                var __switchIndex__ = -1;
                var __run__ = true;
                while (__run__) {
                    __run__ = false;
                    if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (_t == null))) {
                        @:fallthrough {
                            __switchIndex__ = 1;
                            __run__ = true;
                            continue;
                        };
                        break;
                    } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && (stdgo.Go.toInterface(_t) == stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]))))) {
                        _s = ("unknown type" : stdgo.GoString);
                        break;
                        break;
                    } else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && _isUntyped(_t))) {
                        if (_isNumeric(_t)) {
                            _s = ("number" : stdgo.GoString);
                        } else {
                            _s = stdgo.strings.Strings.replace((stdgo.Go.typeAssert((stdgo.Go.toInterface(_t) : stdgo.Ref<Basic>)) : stdgo.Ref<Basic>)._name?.__copy__(), ("untyped " : stdgo.GoString), stdgo.Go.str()?.__copy__(), (-1 : stdgo.GoInt))?.__copy__();
                        };
                        break;
                        break;
                    } else if (__switchIndex__ == 3 || (__switchIndex__ == -1 && (_variadic && (_i == (_list.length - (1 : stdgo.GoInt)))))) {
                        _s = _check._sprintf(("...%s" : stdgo.GoString), stdgo.Go.toInterface((stdgo.Go.typeAssert((stdgo.Go.toInterface(_t) : stdgo.Ref<Slice_>)) : stdgo.Ref<Slice_>)._elem))?.__copy__();
                        break;
                        break;
                    };
                    break;
                };
            };
            if (_s == (stdgo.Go.str())) {
                _s = _check._sprintf(("%s" : stdgo.GoString), stdgo.Go.toInterface(_t))?.__copy__();
            };
            _res = (_res.__append__(_s?.__copy__()));
        };
        return ("(" : stdgo.GoString) + stdgo.strings.Strings.join(_res, (", " : stdgo.GoString))?.__copy__() + (")" : stdgo.GoString)?.__copy__()?.__copy__();
    }
    /**
        // assignVar checks the assignment lhs = rhs (if x == nil), or lhs = x (if x != nil).
        // If x != nil, it must be the evaluation of rhs (and rhs will be ignored).
        // If the assignment check fails and x != nil, x.mode is set to invalid.
    **/
    @:keep
    static public function _assignVar( _check:stdgo.Ref<Checker>, _lhs:stdgo.go.ast.Ast.Expr, _rhs:stdgo.go.ast.Ast.Expr, _x:stdgo.Ref<T_operand>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var t:stdgo.go.types.Types.Type_ = _check._lhsVar(_lhs);
        if (stdgo.Go.toInterface(t) == (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
            if (_x != null && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) {
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            } else {
                _check._use(_rhs);
            };
            return;
        };
        if (_x == null || (_x : Dynamic).__nil__) {
            _x = (stdgo.Go.setRef(({} : stdgo.go.types.Types.T_operand)) : stdgo.Ref<stdgo.go.types.Types.T_operand>);
            _check._expr(t, _x, _rhs);
        };
        var _context:stdgo.GoString = ("assignment" : stdgo.GoString);
        if (t == null) {
            _context = ("assignment to _ identifier" : stdgo.GoString);
        };
        _check._assignment(_x, t, _context?.__copy__());
    }
    /**
        // lhsVar checks a lhs variable in an assignment and returns its type.
        // lhsVar takes care of not counting a lhs identifier as a "use" of
        // that identifier. The result is nil if it is the blank identifier,
        // and Typ[Invalid] if it is an invalid lhs expression.
    **/
    @:keep
    static public function _lhsVar( _check:stdgo.Ref<Checker>, _lhs:stdgo.go.ast.Ast.Expr):Type_ {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_unparen(_lhs)) : stdgo.Ref<stdgo.go.ast.Ast.Ident>)) : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>), _1 : false };
        }, _ident = __tmp__._0, __0 = __tmp__._1;
        if (((_ident != null) && ((_ident : Dynamic).__nil__ == null || !(_ident : Dynamic).__nil__)) && (_ident.name == ("_" : stdgo.GoString))) {
            _check._recordDef(_ident, (null : stdgo.go.types.Types.Object));
            return (null : stdgo.go.types.Types.Type_);
        };
        var _v:stdgo.Ref<Var> = (null : stdgo.Ref<stdgo.go.types.Types.Var>);
        var _v_used:Bool = false;
        if (_ident != null && ((_ident : Dynamic).__nil__ == null || !(_ident : Dynamic).__nil__)) {
            {
                var _obj:stdgo.go.types.Types.Object = _check._lookup(_ident.name?.__copy__());
                if (_obj != null) {
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<Var>)) : stdgo.Ref<Var>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Var>), _1 : false };
                        }, _w = __tmp__._0, __17 = __tmp__._1;
                        if (((_w != null) && ((_w : Dynamic).__nil__ == null || !(_w : Dynamic).__nil__)) && (_w._object._pkg == _check._pkg)) {
                            _v = _w;
                            _v_used = _v._used;
                        };
                    };
                };
            };
        };
        var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
        _check._expr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _lhs);
        if (_v != null && ((_v : Dynamic).__nil__ == null || !(_v : Dynamic).__nil__)) {
            _v._used = _v_used;
        };
        if ((_x._mode == (0 : stdgo.go.types.Types.T_operandMode)) || (stdgo.Go.toInterface(_x._typ) == stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
            return stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
        };
        {
            final __value__ = _x._mode;
            if (__value__ == ((0 : stdgo.go.types.Types.T_operandMode))) {
                return stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
            } else if (__value__ == ((5 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((6 : stdgo.go.types.Types.T_operandMode))) {} else {
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_x._expr) : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>)) : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.ast.Ast.SelectorExpr>), _1 : false };
                    }, _sel = __tmp__._0, _ok = __tmp__._1;
                    if (_ok) {
                        var _op:T_operand = ({} : stdgo.go.types.Types.T_operand);
                        _check._expr((null : stdgo.go.types.Types.Type_), (stdgo.Go.setRef(_op) : stdgo.Ref<stdgo.go.types.Types.T_operand>), _sel.x);
                        if (_op._mode == ((6 : stdgo.go.types.Types.T_operandMode))) {
                            _check._errorf(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>)), (24 : stdgo.internal.types.errors.Errors.Code), ("cannot assign to struct field %s in map" : stdgo.GoString), stdgo.Go.toInterface(exprString(_x._expr)));
                            return stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                        };
                    };
                };
                _check._errorf(stdgo.Go.asInterface((stdgo.Go.setRef(_x) : stdgo.Ref<stdgo.go.types.Types.T_operand>)), (18 : stdgo.internal.types.errors.Errors.Code), ("cannot assign to %s (neither addressable nor a map index expression)" : stdgo.GoString), stdgo.Go.toInterface(_x._expr));
                return stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
            };
        };
        return _x._typ;
    }
    /**
        // initVar checks the initialization lhs = x in a variable declaration.
        // If lhs doesn't have a type yet, it is given the type of x,
        // or Typ[Invalid] in case of an error.
        // If the initialization check fails, x.mode is set to invalid.
    **/
    @:keep
    static public function _initVar( _check:stdgo.Ref<Checker>, _lhs:stdgo.Ref<Var>, _x:stdgo.Ref<T_operand>, _context:stdgo.GoString):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if (((_x._mode == (0 : stdgo.go.types.Types.T_operandMode)) || (stdgo.Go.toInterface(_x._typ) == stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) || (stdgo.Go.toInterface(_lhs._object._typ) == stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
            if (_lhs._object._typ == null) {
                _lhs._object._typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
            };
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            return;
        };
        if (_lhs._object._typ == null) {
            var _typ:stdgo.go.types.Types.Type_ = _x._typ;
            if (_isUntyped(_typ)) {
                if (stdgo.Go.toInterface(_typ) == (stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((25 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                    _check._errorf(stdgo.Go.asInterface(_x), (16 : stdgo.internal.types.errors.Errors.Code), ("use of untyped nil in %s" : stdgo.GoString), stdgo.Go.toInterface(_context));
                    _lhs._object._typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                    return;
                };
                _typ = default_(_typ);
            };
            _lhs._object._typ = _typ;
        };
        _check._assignment(_x, _lhs._object._typ, _context?.__copy__());
    }
    @:keep
    static public function _initConst( _check:stdgo.Ref<Checker>, _lhs:stdgo.Ref<Const>, _x:stdgo.Ref<T_operand>):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        if (((_x._mode == (0 : stdgo.go.types.Types.T_operandMode)) || (stdgo.Go.toInterface(_x._typ) == stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) || (stdgo.Go.toInterface(_lhs._object._typ) == stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
            if (_lhs._object._typ == null) {
                _lhs._object._typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
            };
            return;
        };
        if (_x._mode != ((4 : stdgo.go.types.Types.T_operandMode))) {
            _check._errorf(stdgo.Go.asInterface(_x), (13 : stdgo.internal.types.errors.Errors.Code), ("%s is not constant" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)));
            if (_lhs._object._typ == null) {
                _lhs._object._typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
            };
            return;
        };
        _assert(_isConstType(_x._typ));
        if (_lhs._object._typ == null) {
            _lhs._object._typ = _x._typ;
        };
        _check._assignment(_x, _lhs._object._typ, ("constant declaration" : stdgo.GoString));
        if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
            return;
        };
        _lhs._val = _x._val;
    }
    /**
        // assignment reports whether x can be assigned to a variable of type T,
        // if necessary by attempting to convert untyped values to the appropriate
        // type. context describes the context in which the assignment takes place.
        // Use T == nil to indicate assignment to an untyped blank identifier.
        // If the assignment check fails, x.mode is set to invalid.
    **/
    @:keep
    static public function _assignment( _check:stdgo.Ref<Checker>, _x:stdgo.Ref<T_operand>, t:Type_, _context:stdgo.GoString):Void {
        @:recv var _check:stdgo.Ref<Checker> = _check;
        _check._singleValue(_x);
        {
            final __value__ = _x._mode;
            if (__value__ == ((0 : stdgo.go.types.Types.T_operandMode))) {
                return;
            } else if (__value__ == ((4 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((5 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((6 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((7 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((8 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((9 : stdgo.go.types.Types.T_operandMode))) {} else {
                _check._errorf(stdgo.Go.asInterface(_x), (23 : stdgo.internal.types.errors.Errors.Code), ("cannot assign %s to %s in %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(t), stdgo.Go.toInterface(_context));
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                return;
            };
        };
        if (_isUntyped(_x._typ)) {
            var _target:stdgo.go.types.Types.Type_ = t;
            if ((t == null) || _isNonTypeParamInterface(t)) {
                if ((t == null) && (stdgo.Go.toInterface(_x._typ) == stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((25 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
                    _check._errorf(stdgo.Go.asInterface(_x), (16 : stdgo.internal.types.errors.Errors.Code), ("use of untyped nil in %s" : stdgo.GoString), stdgo.Go.toInterface(_context));
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                    return;
                };
                _target = default_(_x._typ);
            };
            var __tmp__ = _check._implicitTypeAndValue(_x, _target), _newType:stdgo.go.types.Types.Type_ = __tmp__._0, _val:stdgo.go.constant.Constant.Value = __tmp__._1, _code:stdgo.internal.types.errors.Errors.Code = __tmp__._2;
            if (_code != ((0 : stdgo.internal.types.errors.Errors.Code))) {
                var _msg:stdgo.GoString = _check._sprintf(("cannot use %s as %s value in %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(_target), stdgo.Go.toInterface(_context))?.__copy__();
                {
                    final __value__ = _code;
                    if (__value__ == ((43 : stdgo.internal.types.errors.Errors.Code))) {
                        _msg = _msg + ((" (truncated)" : stdgo.GoString))?.__copy__();
                    } else if (__value__ == ((44 : stdgo.internal.types.errors.Errors.Code))) {
                        _msg = _msg + ((" (overflows)" : stdgo.GoString))?.__copy__();
                    } else {
                        _code = (23 : stdgo.internal.types.errors.Errors.Code);
                    };
                };
                _check._error(stdgo.Go.asInterface(_x), _code, _msg?.__copy__());
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                return;
            };
            if (_val != null) {
                _x._val = _val;
                _check._updateExprVal(_x._expr, _val);
            };
            if (stdgo.Go.toInterface(_newType) != (stdgo.Go.toInterface(_x._typ))) {
                _x._typ = _newType;
                _check._updateExprType(_x._expr, _newType, false);
            };
        };
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_x._typ)) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Signature>), _1 : false };
            }, _sig = __tmp__._0, __64 = __tmp__._1;
            if (((_sig != null) && ((_sig : Dynamic).__nil__ == null || !(_sig : Dynamic).__nil__)) && (_sig.typeParams().len() > (0 : stdgo.GoInt))) {
                _check._errorf(stdgo.Go.asInterface(_x), (137 : stdgo.internal.types.errors.Errors.Code), ("cannot use generic function %s without instantiation in %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(_context));
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                return;
            };
        };
        if (t == null) {
            return;
        };
        var _cause:stdgo.GoString = stdgo.Go.str()?.__copy__();
        {
            var __tmp__ = _x._assignableTo(_check, t, stdgo.Go.pointer(_cause)), _ok:Bool = __tmp__._0, _code:stdgo.internal.types.errors.Errors.Code = __tmp__._1;
            if (!_ok) {
                if (_cause != (stdgo.Go.str())) {
                    _check._errorf(stdgo.Go.asInterface(_x), _code, ("cannot use %s as %s value in %s: %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(t), stdgo.Go.toInterface(_context), stdgo.Go.toInterface(_cause));
                } else {
                    _check._errorf(stdgo.Go.asInterface(_x), _code, ("cannot use %s as %s value in %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(t), stdgo.Go.toInterface(_context));
                };
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            };
        };
    }
    @:embedded
    public static function _recordTypes( __self__:Checker):Bool return __self__._recordTypes();
    @:embedded
    public static function _lookup( __self__:Checker, __0:stdgo.GoString):stdgo.go.types.Types.Object return __self__._lookup(__0);
    @:embedded
    public static function typeOf( __self__:Checker, _e:stdgo.go.ast.Ast.Expr):stdgo.go.types.Types.Type_ return __self__.typeOf(_e);
    @:embedded
    public static function objectOf( __self__:Checker, _id:stdgo.Ref<stdgo.go.ast.Ast.Ident>):stdgo.go.types.Types.Object return __self__.objectOf(_id);
}
/**
    
    
    
**/
@:structInit class T__collectObjects_39___localname___methodInfo {
    public var _obj : stdgo.Ref<stdgo.go.types.Types.Func> = (null : stdgo.Ref<stdgo.go.types.Types.Func>);
    public var _ptr : Bool = false;
    public var _recv : stdgo.Ref<stdgo.go.ast.Ast.Ident> = (null : stdgo.Ref<stdgo.go.ast.Ast.Ident>);
    public function new(?_obj:stdgo.Ref<stdgo.go.types.Types.Func>, ?_ptr:Bool, ?_recv:stdgo.Ref<stdgo.go.ast.Ast.Ident>) {
        if (_obj != null) this._obj = _obj;
        if (_ptr != null) this._ptr = _ptr;
        if (_recv != null) this._recv = _recv;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T__collectObjects_39___localname___methodInfo(_obj, _ptr, _recv);
    }
}
class Context_asInterface {
    /**
        // getID returns a unique ID for the type t.
    **/
    @:keep
    public dynamic function _getID(_t:Type_):stdgo.GoInt return __self__.value._getID(_t);
    /**
        // update de-duplicates n against previously seen types with the hash h.  If an
        // identical type is found with the type hash h, the previously seen type is
        // returned. Otherwise, n is returned, and recorded in the Context for the hash
        // h.
    **/
    @:keep
    public dynamic function _update(_h:stdgo.GoString, _orig:Type_, _targs:stdgo.Slice<Type_>, _inst:Type_):Type_ return __self__.value._update(_h, _orig, _targs, _inst);
    /**
        // lookup returns an existing instantiation of orig with targs, if it exists.
        // Otherwise, it returns nil.
    **/
    @:keep
    public dynamic function _lookup(_h:stdgo.GoString, _orig:Type_, _targs:stdgo.Slice<Type_>):Type_ return __self__.value._lookup(_h, _orig, _targs);
    /**
        // instanceHash returns a string representation of typ instantiated with targs.
        // The hash should be a perfect hash, though out of caution the type checker
        // does not assume this. The result is guaranteed to not contain blanks.
    **/
    @:keep
    public dynamic function _instanceHash(_orig:Type_, _targs:stdgo.Slice<Type_>):stdgo.GoString return __self__.value._instanceHash(_orig, _targs);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Context>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Context_asInterface) class Context_static_extension {
    /**
        // getID returns a unique ID for the type t.
    **/
    @:keep
    static public function _getID( _ctxt:stdgo.Ref<Context>, _t:Type_):stdgo.GoInt {
        @:recv var _ctxt:stdgo.Ref<Context> = _ctxt;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            _ctxt._mu.lock();
            __deferstack__.unshift(() -> _ctxt._mu.unlock());
            var __tmp__ = (_ctxt._originIDs != null && _ctxt._originIDs.exists(_t) ? { _0 : _ctxt._originIDs[_t], _1 : true } : { _0 : (0 : stdgo.GoInt), _1 : false }), _id:stdgo.GoInt = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _id = _ctxt._nextID;
                _ctxt._originIDs[_t] = _id;
                _ctxt._nextID++;
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _id;
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return (0 : stdgo.GoInt);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return (0 : stdgo.GoInt);
        };
    }
    /**
        // update de-duplicates n against previously seen types with the hash h.  If an
        // identical type is found with the type hash h, the previously seen type is
        // returned. Otherwise, n is returned, and recorded in the Context for the hash
        // h.
    **/
    @:keep
    static public function _update( _ctxt:stdgo.Ref<Context>, _h:stdgo.GoString, _orig:Type_, _targs:stdgo.Slice<Type_>, _inst:Type_):Type_ {
        @:recv var _ctxt:stdgo.Ref<Context> = _ctxt;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            _assert(_inst != null);
            _ctxt._mu.lock();
            __deferstack__.unshift(() -> _ctxt._mu.unlock());
            for (__0 => _e in (_ctxt._typeMap[_h] ?? (null : stdgo.Slice<stdgo.go.types.Types.T_ctxtEntry>))) {
                if ((_inst == null) || identical(_inst, _e._instance)) {
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _e._instance;
                    };
                };
                if (false) {
                    throw stdgo.Go.toInterface(stdgo.fmt.Fmt.sprintf(("%s and %s are not identical" : stdgo.GoString), stdgo.Go.toInterface(_inst), stdgo.Go.toInterface(_e._instance)));
                };
            };
            _ctxt._typeMap[_h] = ((_ctxt._typeMap[_h] ?? (null : stdgo.Slice<stdgo.go.types.Types.T_ctxtEntry>)).__append__(({ _orig : _orig, _targs : _targs, _instance : _inst } : stdgo.go.types.Types.T_ctxtEntry)));
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _inst;
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return (null : stdgo.go.types.Types.Type_);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return (null : stdgo.go.types.Types.Type_);
        };
    }
    /**
        // lookup returns an existing instantiation of orig with targs, if it exists.
        // Otherwise, it returns nil.
    **/
    @:keep
    static public function _lookup( _ctxt:stdgo.Ref<Context>, _h:stdgo.GoString, _orig:Type_, _targs:stdgo.Slice<Type_>):Type_ {
        @:recv var _ctxt:stdgo.Ref<Context> = _ctxt;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            _ctxt._mu.lock();
            __deferstack__.unshift(() -> _ctxt._mu.unlock());
            for (__0 => _e in (_ctxt._typeMap[_h] ?? (null : stdgo.Slice<stdgo.go.types.Types.T_ctxtEntry>))) {
                if (_identicalInstance(_orig, _targs, _e._orig, _e._targs)) {
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _e._instance;
                    };
                };
                if (false) {
                    throw stdgo.Go.toInterface(stdgo.fmt.Fmt.sprintf(("non-identical instances: (orig: %s, targs: %v) and %s" : stdgo.GoString), stdgo.Go.toInterface(_orig), stdgo.Go.toInterface(_targs), stdgo.Go.toInterface(_e._instance)));
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return (null : stdgo.go.types.Types.Type_);
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return (null : stdgo.go.types.Types.Type_);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return (null : stdgo.go.types.Types.Type_);
        };
    }
    /**
        // instanceHash returns a string representation of typ instantiated with targs.
        // The hash should be a perfect hash, though out of caution the type checker
        // does not assume this. The result is guaranteed to not contain blanks.
    **/
    @:keep
    static public function _instanceHash( _ctxt:stdgo.Ref<Context>, _orig:Type_, _targs:stdgo.Slice<Type_>):stdgo.GoString {
        @:recv var _ctxt:stdgo.Ref<Context> = _ctxt;
        _assert(_ctxt != null && ((_ctxt : Dynamic).__nil__ == null || !(_ctxt : Dynamic).__nil__));
        _assert(_orig != null);
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        var _h = _newTypeHasher((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.bytes.Bytes.Buffer>), _ctxt);
        _h._string(stdgo.strconv.Strconv.itoa(_ctxt._getID(_orig))?.__copy__());
        _h._typ(_orig);
        if ((_targs.length) > (0 : stdgo.GoInt)) {
            _h._typeList(_targs);
        };
        return stdgo.strings.Strings.replace((_buf.string() : stdgo.GoString)?.__copy__(), (" " : stdgo.GoString), ("#" : stdgo.GoString), (-1 : stdgo.GoInt))?.__copy__();
    }
}
class T_importDecl_asInterface {
    @:keep
    public dynamic function _node():stdgo.go.ast.Ast.Node return __self__.value._node();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_importDecl>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_importDecl_asInterface) class T_importDecl_static_extension {
    @:keep
    static public function _node( _d:T_importDecl):stdgo.go.ast.Ast.Node {
        @:recv var _d:T_importDecl = _d?.__copy__();
        return stdgo.Go.asInterface(_d._spec);
    }
}
class T_constDecl_asInterface {
    @:keep
    public dynamic function _node():stdgo.go.ast.Ast.Node return __self__.value._node();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_constDecl>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_constDecl_asInterface) class T_constDecl_static_extension {
    @:keep
    static public function _node( _d:T_constDecl):stdgo.go.ast.Ast.Node {
        @:recv var _d:T_constDecl = _d?.__copy__();
        return stdgo.Go.asInterface(_d._spec);
    }
}
class T_varDecl_asInterface {
    @:keep
    public dynamic function _node():stdgo.go.ast.Ast.Node return __self__.value._node();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_varDecl>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_varDecl_asInterface) class T_varDecl_static_extension {
    @:keep
    static public function _node( _d:T_varDecl):stdgo.go.ast.Ast.Node {
        @:recv var _d:T_varDecl = _d?.__copy__();
        return stdgo.Go.asInterface(_d._spec);
    }
}
class T_typeDecl_asInterface {
    @:keep
    public dynamic function _node():stdgo.go.ast.Ast.Node return __self__.value._node();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_typeDecl>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_typeDecl_asInterface) class T_typeDecl_static_extension {
    @:keep
    static public function _node( _d:T_typeDecl):stdgo.go.ast.Ast.Node {
        @:recv var _d:T_typeDecl = _d?.__copy__();
        return stdgo.Go.asInterface(_d._spec);
    }
}
class T_funcDecl_asInterface {
    @:keep
    public dynamic function _node():stdgo.go.ast.Ast.Node return __self__.value._node();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_funcDecl>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_funcDecl_asInterface) class T_funcDecl_static_extension {
    @:keep
    static public function _node( _d:T_funcDecl):stdgo.go.ast.Ast.Node {
        @:recv var _d:T_funcDecl = _d?.__copy__();
        return stdgo.Go.asInterface(_d._decl);
    }
}
class T_error__asInterface {
    /**
        // errorf adds formatted error information to err.
        // It may be called multiple times to provide additional information.
    **/
    @:keep
    public dynamic function _errorf(_at:stdgo.go.token.Token.Pos, _format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):Void __self__.value._errorf(_at, _format, ..._args);
    /**
        // String is for testing.
    **/
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:keep
    public dynamic function _msg(_fset:stdgo.Ref<stdgo.go.token.Token.FileSet>, _qf:Qualifier):stdgo.GoString return __self__.value._msg(_fset, _qf);
    @:keep
    public dynamic function _pos():stdgo.go.token.Token.Pos return __self__.value._pos();
    @:keep
    public dynamic function _empty():Bool return __self__.value._empty();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_error_>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_error__asInterface) class T_error__static_extension {
    /**
        // errorf adds formatted error information to err.
        // It may be called multiple times to provide additional information.
    **/
    @:keep
    static public function _errorf( _err:stdgo.Ref<T_error_>, _at:stdgo.go.token.Token.Pos, _format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):Void {
        var _args = new stdgo.Slice<stdgo.AnyInterface>(_args.length, 0, ..._args);
        @:recv var _err:stdgo.Ref<T_error_> = _err;
        _err._desc = (_err._desc.__append__((new stdgo.go.types.Types.T_errorDesc(stdgo.Go.asInterface((_at : T_atPos)), _format?.__copy__(), _args) : stdgo.go.types.Types.T_errorDesc)));
    }
    /**
        // String is for testing.
    **/
    @:keep
    static public function string( _err:stdgo.Ref<T_error_>):stdgo.GoString {
        @:recv var _err:stdgo.Ref<T_error_> = _err;
        if (_err._empty()) {
            return ("no error" : stdgo.GoString);
        };
        return stdgo.fmt.Fmt.sprintf(("%d: %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_err._pos())), stdgo.Go.toInterface(_err._msg(null, null)))?.__copy__();
    }
    @:keep
    static public function _msg( _err:stdgo.Ref<T_error_>, _fset:stdgo.Ref<stdgo.go.token.Token.FileSet>, _qf:Qualifier):stdgo.GoString {
        @:recv var _err:stdgo.Ref<T_error_> = _err;
        if (_err._empty()) {
            return ("no error" : stdgo.GoString);
        };
        var _buf:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
        for (_i => _ in _err._desc) {
            var _p = (stdgo.Go.setRef(_err._desc[(_i : stdgo.GoInt)]) : stdgo.Ref<stdgo.go.types.Types.T_errorDesc>);
            if (_i > (0 : stdgo.GoInt)) {
                stdgo.fmt.Fmt.fprint(stdgo.Go.asInterface((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.strings.Strings.Builder>)), stdgo.Go.toInterface(("\n\t" : stdgo.GoString)));
                if (_p._posn.pos().isValid()) {
                    stdgo.fmt.Fmt.fprintf(stdgo.Go.asInterface((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.strings.Strings.Builder>)), ("%s: " : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_fset.position(_p._posn.pos()))));
                };
            };
            _buf.writeString(_sprintf(_fset, _qf, false, _p._format?.__copy__(), ..._p._args.__toArray__())?.__copy__());
        };
        return (_buf.string() : stdgo.GoString)?.__copy__();
    }
    @:keep
    static public function _pos( _err:stdgo.Ref<T_error_>):stdgo.go.token.Token.Pos {
        @:recv var _err:stdgo.Ref<T_error_> = _err;
        if (_err._empty()) {
            return _nopos;
        };
        return _err._desc[(0 : stdgo.GoInt)]._posn.pos();
    }
    @:keep
    static public function _empty( _err:stdgo.Ref<T_error_>):Bool {
        @:recv var _err:stdgo.Ref<T_error_> = _err;
        return _err._desc == null;
    }
}
class T_posSpan_asInterface {
    @:keep
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_posSpan>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_posSpan_asInterface) class T_posSpan_static_extension {
    @:keep
    static public function pos( _e:T_posSpan):stdgo.go.token.Token.Pos {
        @:recv var _e:T_posSpan = _e?.__copy__();
        return _e._pos;
    }
}
class T_tpWalker_asInterface {
    @:keep
    public dynamic function _varList(_list:stdgo.Slice<stdgo.Ref<Var>>):Bool return __self__.value._varList(_list);
    @:keep
    public dynamic function _isParameterized(_typ:Type_):Bool return __self__.value._isParameterized(_typ);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_tpWalker>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_tpWalker_asInterface) class T_tpWalker_static_extension {
    @:keep
    static public function _varList( _w:stdgo.Ref<T_tpWalker>, _list:stdgo.Slice<stdgo.Ref<Var>>):Bool {
        @:recv var _w:stdgo.Ref<T_tpWalker> = _w;
        for (__0 => _v in _list) {
            if (_w._isParameterized(_v._object._typ)) {
                return true;
            };
        };
        return false;
    }
    @:keep
    static public function _isParameterized( _w:stdgo.Ref<T_tpWalker>, _typ:Type_):Bool {
        @:recv var _w:stdgo.Ref<T_tpWalker> = _w;
        var __deferstack__:Array<Void -> Void> = [];
        var _res:Bool = false;
        try {
            {
                var __tmp__ = (_w._seen != null && _w._seen.exists(_typ) ? { _0 : _w._seen[_typ], _1 : true } : { _0 : false, _1 : false }), _x:Bool = __tmp__._0, _ok:Bool = __tmp__._1;
                if (_ok) {
                    return _x;
                };
            };
            _w._seen[_typ] = false;
            __deferstack__.unshift(() -> {
                var a = function():Void {
                    _w._seen[_typ] = _res;
                };
                a();
            });
            {
                final __type__ = _typ;
                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Array_>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _w._isParameterized(_t._elem);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Slice_>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _w._isParameterized(_t._elem);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Struct>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _w._varList(_t._fields);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Pointer_>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _w._isParameterized(_t._base);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Tuple>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Tuple> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Tuple>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Tuple>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Tuple>) : __type__.__underlying__().value;
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return ((_t != null) && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) && _w._varList(_t._vars);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Signature>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Signature> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__().value;
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return (((_t._params != null) && ((_t._params : Dynamic).__nil__ == null || !(_t._params : Dynamic).__nil__)) && _w._varList(_t._params._vars)) || (((_t._results != null) && ((_t._results : Dynamic).__nil__ == null || !(_t._results : Dynamic).__nil__)) && _w._varList(_t._results._vars));
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                    var _tset = _t._typeSet();
                    for (__8 => _m in _tset._methods) {
                        if (_w._isParameterized(_m._object._typ)) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return true;
                            };
                        };
                    };
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _tset._is(function(_t:stdgo.Ref<T_term>):Bool {
                            return ((_t != null) && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) && _w._isParameterized(_t._typ);
                        });
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Map_>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _w._isParameterized(_t._key) || _w._isParameterized(_t._elem);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Chan>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Chan> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__().value;
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _w._isParameterized(_t._elem);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Named>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                    for (__17 => _t in _t.typeArgs()._list()) {
                        if (_w._isParameterized(_t)) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return true;
                            };
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeParam>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.TypeParam> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__().value;
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _tparamIndex(_w._tparams, _t) >= (0 : stdgo.GoInt);
                    };
                } else {
                    var _t:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                    throw stdgo.Go.toInterface(stdgo.fmt.Fmt.sprintf(("unexpected %T" : stdgo.GoString), stdgo.Go.toInterface(_typ)));
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return false;
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return _res;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return _res;
        };
    }
}
class T_cycleFinder_asInterface {
    @:keep
    public dynamic function _varList(_list:stdgo.Slice<stdgo.Ref<Var>>):Void __self__.value._varList(_list);
    @:keep
    public dynamic function _typ(_typ:Type_):Void __self__.value._typ(_typ);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_cycleFinder>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_cycleFinder_asInterface) class T_cycleFinder_static_extension {
    @:keep
    static public function _varList( _w:stdgo.Ref<T_cycleFinder>, _list:stdgo.Slice<stdgo.Ref<Var>>):Void {
        @:recv var _w:stdgo.Ref<T_cycleFinder> = _w;
        for (__0 => _v in _list) {
            _w._typ(_v._object._typ);
        };
    }
    @:keep
    static public function _typ( _w:stdgo.Ref<T_cycleFinder>, _typ:Type_):Void {
        @:recv var _w:stdgo.Ref<T_cycleFinder> = _w;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            if ((_w._seen[_typ] ?? false)) {
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_typ) : stdgo.Ref<TypeParam>)) : stdgo.Ref<TypeParam>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>), _1 : false };
                    }, _tpar = __tmp__._0, __0 = __tmp__._1;
                    if (_tpar != null && ((_tpar : Dynamic).__nil__ == null || !(_tpar : Dynamic).__nil__)) {
                        {
                            var _i:stdgo.GoInt = _tparamIndex(_w._tparams, _tpar);
                            if (_i >= (0 : stdgo.GoInt)) {
                                _w._inferred[(_i : stdgo.GoInt)] = (null : stdgo.go.types.Types.Type_);
                            };
                        };
                    };
                };
                return;
            };
            _w._seen[_typ] = true;
            {
                var _a0 = _w._seen;
                var _a1 = _typ;
                __deferstack__.unshift(() -> if (_a0 != null) _a0.remove(_a1));
            };
            {
                final __type__ = _typ;
                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Array_>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                    _w._typ(_t._elem);
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Slice_>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                    _w._typ(_t._elem);
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Struct>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                    _w._varList(_t._fields);
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Pointer_>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                    _w._typ(_t._base);
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Signature>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Signature> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__().value;
                    if (_t._params != null && ((_t._params : Dynamic).__nil__ == null || !(_t._params : Dynamic).__nil__)) {
                        _w._varList(_t._params._vars);
                    };
                    if (_t._results != null && ((_t._results : Dynamic).__nil__ == null || !(_t._results : Dynamic).__nil__)) {
                        _w._varList(_t._results._vars);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Union>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Union> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Union>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__().value;
                    for (__1 => _t in _t._terms) {
                        _w._typ(_t._typ);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                    for (__10 => _m in _t._methods) {
                        _w._typ(_m._object._typ);
                    };
                    for (__19 => _t in _t._embeddeds) {
                        _w._typ(_t);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Map_>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                    _w._typ(_t._key);
                    _w._typ(_t._elem);
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Chan>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Chan> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__().value;
                    _w._typ(_t._elem);
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Named>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                    for (__28 => _tpar in _t.typeArgs()._list()) {
                        _w._typ(_tpar);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeParam>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.TypeParam> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__().value;
                    {
                        var _i:stdgo.GoInt = _tparamIndex(_w._tparams, _t);
                        if ((_i >= (0 : stdgo.GoInt)) && (_w._inferred[(_i : stdgo.GoInt)] != null)) {
                            _w._typ(_w._inferred[(_i : stdgo.GoInt)]);
                        };
                    };
                } else {
                    var _t:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                    throw stdgo.Go.toInterface(stdgo.fmt.Fmt.sprintf(("unexpected %T" : stdgo.GoString), stdgo.Go.toInterface(_typ)));
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return;
        };
    }
}
class T_graphNode_asInterface {
    /**
        // cost returns the cost of removing this node, which involves copying each
        // predecessor to each successor (and vice-versa).
    **/
    @:keep
    public dynamic function _cost():stdgo.GoInt return __self__.value._cost();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_graphNode>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_graphNode_asInterface) class T_graphNode_static_extension {
    /**
        // cost returns the cost of removing this node, which involves copying each
        // predecessor to each successor (and vice-versa).
    **/
    @:keep
    static public function _cost( _n:stdgo.Ref<T_graphNode>):stdgo.GoInt {
        @:recv var _n:stdgo.Ref<T_graphNode> = _n;
        return (_n._pred.length) * (_n._succ.length);
    }
}
class Interface_asInterface {
    @:keep
    public dynamic function _cleanup():Void __self__.value._cleanup();
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type_ return __self__.value.underlying();
    /**
        // Complete computes the interface's type set. It must be called by users of
        // NewInterfaceType and NewInterface after the interface's embedded types are
        // fully defined and before using the interface type in any way other than to
        // form other types. The interface must not contain duplicate methods or a
        // panic occurs. Complete returns the receiver.
        //
        // Interface types that have been completed are safe for concurrent use.
    **/
    @:keep
    public dynamic function complete():stdgo.Ref<Interface> return __self__.value.complete();
    /**
        // IsImplicit reports whether the interface t is a wrapper for a type set literal.
    **/
    @:keep
    public dynamic function isImplicit():Bool return __self__.value.isImplicit();
    /**
        // IsMethodSet reports whether the interface t is fully described by its method
        // set.
    **/
    @:keep
    public dynamic function isMethodSet():Bool return __self__.value.isMethodSet();
    /**
        // IsComparable reports whether each type in interface t's type set is comparable.
    **/
    @:keep
    public dynamic function isComparable():Bool return __self__.value.isComparable();
    /**
        // Empty reports whether t is the empty interface.
    **/
    @:keep
    public dynamic function empty():Bool return __self__.value.empty();
    /**
        // Method returns the i'th method of interface t for 0 <= i < t.NumMethods().
        // The methods are ordered by their unique Id.
    **/
    @:keep
    public dynamic function method(_i:stdgo.GoInt):stdgo.Ref<Func> return __self__.value.method(_i);
    /**
        // NumMethods returns the total number of methods of interface t.
    **/
    @:keep
    public dynamic function numMethods():stdgo.GoInt return __self__.value.numMethods();
    /**
        // EmbeddedType returns the i'th embedded type of interface t for 0 <= i < t.NumEmbeddeds().
    **/
    @:keep
    public dynamic function embeddedType(_i:stdgo.GoInt):Type_ return __self__.value.embeddedType(_i);
    /**
        // Embedded returns the i'th embedded defined (*Named) type of interface t for 0 <= i < t.NumEmbeddeds().
        // The result is nil if the i'th embedded type is not a defined type.
        //
        // Deprecated: Use EmbeddedType which is not restricted to defined (*Named) types.
    **/
    @:keep
    public dynamic function embedded(_i:stdgo.GoInt):stdgo.Ref<Named> return __self__.value.embedded(_i);
    /**
        // NumEmbeddeds returns the number of embedded types in interface t.
    **/
    @:keep
    public dynamic function numEmbeddeds():stdgo.GoInt return __self__.value.numEmbeddeds();
    /**
        // ExplicitMethod returns the i'th explicitly declared method of interface t for 0 <= i < t.NumExplicitMethods().
        // The methods are ordered by their unique Id.
    **/
    @:keep
    public dynamic function explicitMethod(_i:stdgo.GoInt):stdgo.Ref<Func> return __self__.value.explicitMethod(_i);
    /**
        // NumExplicitMethods returns the number of explicitly declared methods of interface t.
    **/
    @:keep
    public dynamic function numExplicitMethods():stdgo.GoInt return __self__.value.numExplicitMethods();
    /**
        // MarkImplicit marks the interface t as implicit, meaning this interface
        // corresponds to a constraint literal such as ~T or A|B without explicit
        // interface embedding. MarkImplicit should be called before any concurrent use
        // of implicit interfaces.
    **/
    @:keep
    public dynamic function markImplicit():Void __self__.value.markImplicit();
    /**
        // typeSet returns the type set for interface t.
    **/
    @:keep
    public dynamic function _typeSet():stdgo.Ref<T__TypeSet> return __self__.value._typeSet();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Interface>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Interface_asInterface) class Interface_static_extension {
    @:keep
    static public function _cleanup( _t:stdgo.Ref<Interface>):Void {
        @:recv var _t:stdgo.Ref<Interface> = _t;
        _t._check = null;
        _t._embedPos = (null : stdgo.Ref<stdgo.Slice<stdgo.go.token.Token.Pos>>);
    }
    @:keep
    static public function string( _t:stdgo.Ref<Interface>):stdgo.GoString {
        @:recv var _t:stdgo.Ref<Interface> = _t;
        return typeString(stdgo.Go.asInterface(_t), null)?.__copy__();
    }
    @:keep
    static public function underlying( _t:stdgo.Ref<Interface>):Type_ {
        @:recv var _t:stdgo.Ref<Interface> = _t;
        return stdgo.Go.asInterface(_t);
    }
    /**
        // Complete computes the interface's type set. It must be called by users of
        // NewInterfaceType and NewInterface after the interface's embedded types are
        // fully defined and before using the interface type in any way other than to
        // form other types. The interface must not contain duplicate methods or a
        // panic occurs. Complete returns the receiver.
        //
        // Interface types that have been completed are safe for concurrent use.
    **/
    @:keep
    static public function complete( _t:stdgo.Ref<Interface>):stdgo.Ref<Interface> {
        @:recv var _t:stdgo.Ref<Interface> = _t;
        if (!_t._complete) {
            _t._complete = true;
        };
        _t._typeSet();
        return _t;
    }
    /**
        // IsImplicit reports whether the interface t is a wrapper for a type set literal.
    **/
    @:keep
    static public function isImplicit( _t:stdgo.Ref<Interface>):Bool {
        @:recv var _t:stdgo.Ref<Interface> = _t;
        return _t._implicit;
    }
    /**
        // IsMethodSet reports whether the interface t is fully described by its method
        // set.
    **/
    @:keep
    static public function isMethodSet( _t:stdgo.Ref<Interface>):Bool {
        @:recv var _t:stdgo.Ref<Interface> = _t;
        return _t._typeSet().isMethodSet();
    }
    /**
        // IsComparable reports whether each type in interface t's type set is comparable.
    **/
    @:keep
    static public function isComparable( _t:stdgo.Ref<Interface>):Bool {
        @:recv var _t:stdgo.Ref<Interface> = _t;
        return _t._typeSet().isComparable((null : stdgo.GoMap<stdgo.go.types.Types.Type_, Bool>));
    }
    /**
        // Empty reports whether t is the empty interface.
    **/
    @:keep
    static public function empty( _t:stdgo.Ref<Interface>):Bool {
        @:recv var _t:stdgo.Ref<Interface> = _t;
        return _t._typeSet().isAll();
    }
    /**
        // Method returns the i'th method of interface t for 0 <= i < t.NumMethods().
        // The methods are ordered by their unique Id.
    **/
    @:keep
    static public function method( _t:stdgo.Ref<Interface>, _i:stdgo.GoInt):stdgo.Ref<Func> {
        @:recv var _t:stdgo.Ref<Interface> = _t;
        return _t._typeSet().method(_i);
    }
    /**
        // NumMethods returns the total number of methods of interface t.
    **/
    @:keep
    static public function numMethods( _t:stdgo.Ref<Interface>):stdgo.GoInt {
        @:recv var _t:stdgo.Ref<Interface> = _t;
        return _t._typeSet().numMethods();
    }
    /**
        // EmbeddedType returns the i'th embedded type of interface t for 0 <= i < t.NumEmbeddeds().
    **/
    @:keep
    static public function embeddedType( _t:stdgo.Ref<Interface>, _i:stdgo.GoInt):Type_ {
        @:recv var _t:stdgo.Ref<Interface> = _t;
        return _t._embeddeds[(_i : stdgo.GoInt)];
    }
    /**
        // Embedded returns the i'th embedded defined (*Named) type of interface t for 0 <= i < t.NumEmbeddeds().
        // The result is nil if the i'th embedded type is not a defined type.
        //
        // Deprecated: Use EmbeddedType which is not restricted to defined (*Named) types.
    **/
    @:keep
    static public function embedded( _t:stdgo.Ref<Interface>, _i:stdgo.GoInt):stdgo.Ref<Named> {
        @:recv var _t:stdgo.Ref<Interface> = _t;
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_t._embeddeds[(_i : stdgo.GoInt)]) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
        }, _tname = __tmp__._0, __8 = __tmp__._1;
        return _tname;
    }
    /**
        // NumEmbeddeds returns the number of embedded types in interface t.
    **/
    @:keep
    static public function numEmbeddeds( _t:stdgo.Ref<Interface>):stdgo.GoInt {
        @:recv var _t:stdgo.Ref<Interface> = _t;
        return (_t._embeddeds.length);
    }
    /**
        // ExplicitMethod returns the i'th explicitly declared method of interface t for 0 <= i < t.NumExplicitMethods().
        // The methods are ordered by their unique Id.
    **/
    @:keep
    static public function explicitMethod( _t:stdgo.Ref<Interface>, _i:stdgo.GoInt):stdgo.Ref<Func> {
        @:recv var _t:stdgo.Ref<Interface> = _t;
        return _t._methods[(_i : stdgo.GoInt)];
    }
    /**
        // NumExplicitMethods returns the number of explicitly declared methods of interface t.
    **/
    @:keep
    static public function numExplicitMethods( _t:stdgo.Ref<Interface>):stdgo.GoInt {
        @:recv var _t:stdgo.Ref<Interface> = _t;
        return (_t._methods.length);
    }
    /**
        // MarkImplicit marks the interface t as implicit, meaning this interface
        // corresponds to a constraint literal such as ~T or A|B without explicit
        // interface embedding. MarkImplicit should be called before any concurrent use
        // of implicit interfaces.
    **/
    @:keep
    static public function markImplicit( _t:stdgo.Ref<Interface>):Void {
        @:recv var _t:stdgo.Ref<Interface> = _t;
        _t._implicit = true;
    }
    /**
        // typeSet returns the type set for interface t.
    **/
    @:keep
    static public function _typeSet( _t:stdgo.Ref<Interface>):stdgo.Ref<T__TypeSet> {
        @:recv var _t:stdgo.Ref<Interface> = _t;
        return _computeInterfaceTypeSet(_t._check, _nopos, _t);
    }
}
class T_block_asInterface {
    /**
        // enclosingTarget returns the innermost enclosing labeled
        // statement with the given label name, or nil.
    **/
    @:keep
    public dynamic function _enclosingTarget(_name:stdgo.GoString):stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt> return __self__.value._enclosingTarget(_name);
    /**
        // gotoTarget returns the labeled statement in the current
        // or an enclosing block with the given label name, or nil.
    **/
    @:keep
    public dynamic function _gotoTarget(_name:stdgo.GoString):stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt> return __self__.value._gotoTarget(_name);
    /**
        // insert records a new label declaration for the current block.
        // The label must not have been declared before in any block.
    **/
    @:keep
    public dynamic function _insert(_s:stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>):Void __self__.value._insert(_s);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_block>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_block_asInterface) class T_block_static_extension {
    /**
        // enclosingTarget returns the innermost enclosing labeled
        // statement with the given label name, or nil.
    **/
    @:keep
    static public function _enclosingTarget( _b:stdgo.Ref<T_block>, _name:stdgo.GoString):stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt> {
        @:recv var _b:stdgo.Ref<T_block> = _b;
        {
            var _s = _b;
            stdgo.Go.cfor(_s != null && ((_s : Dynamic).__nil__ == null || !(_s : Dynamic).__nil__), _s = _s._parent, {
                {
                    var _t = _s._lstmt;
                    if (((_t != null) && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) && (_t.label.name == _name)) {
                        return _t;
                    };
                };
            });
        };
        return null;
    }
    /**
        // gotoTarget returns the labeled statement in the current
        // or an enclosing block with the given label name, or nil.
    **/
    @:keep
    static public function _gotoTarget( _b:stdgo.Ref<T_block>, _name:stdgo.GoString):stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt> {
        @:recv var _b:stdgo.Ref<T_block> = _b;
        {
            var _s = _b;
            stdgo.Go.cfor(_s != null && ((_s : Dynamic).__nil__ == null || !(_s : Dynamic).__nil__), _s = _s._parent, {
                {
                    var _t = (_s._labels[_name] ?? (null : stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>));
                    if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                        return _t;
                    };
                };
            });
        };
        return null;
    }
    /**
        // insert records a new label declaration for the current block.
        // The label must not have been declared before in any block.
    **/
    @:keep
    static public function _insert( _b:stdgo.Ref<T_block>, _s:stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>):Void {
        @:recv var _b:stdgo.Ref<T_block> = _b;
        var _name:stdgo.GoString = _s.label.name?.__copy__();
        if (false) {
            _assert(_b._gotoTarget(_name?.__copy__()) == null || (_b._gotoTarget(_name?.__copy__()) : Dynamic).__nil__);
        };
        var _labels = _b._labels;
        if (_labels == null) {
            _labels = ({
                final x = new stdgo.GoMap.GoStringMap<stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>>();
                x.__defaultValue__ = () -> (null : stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>);
                @:mergeBlock {};
                x;
            } : stdgo.GoMap<stdgo.GoString, stdgo.Ref<stdgo.go.ast.Ast.LabeledStmt>>);
            _b._labels = _labels;
        };
        _labels[_name] = _s;
    }
}
class T_instanceLookup_asInterface {
    @:keep
    public dynamic function _add(_inst:stdgo.Ref<Named>):Void __self__.value._add(_inst);
    @:keep
    public dynamic function _lookup(_inst:stdgo.Ref<Named>):stdgo.Ref<Named> return __self__.value._lookup(_inst);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_instanceLookup>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_instanceLookup_asInterface) class T_instanceLookup_static_extension {
    @:keep
    static public function _add( _l:stdgo.Ref<T_instanceLookup>, _inst:stdgo.Ref<Named>):Void {
        @:recv var _l:stdgo.Ref<T_instanceLookup> = _l;
        for (_i => _t in _l._buf) {
            if (_t == null || (_t : Dynamic).__nil__) {
                _l._buf[(_i : stdgo.GoInt)] = _inst;
                return;
            };
        };
        if (_l._m == null) {
            _l._m = ({
                final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.types.Types.Named>, stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Named>>>();
                @:mergeBlock {};
                cast x;
            } : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Named>, stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Named>>>);
        };
        var _insts = (_l._m[_inst.origin()] ?? (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Named>>));
        _l._m[_inst.origin()] = (_insts.__append__(_inst));
    }
    @:keep
    static public function _lookup( _l:stdgo.Ref<T_instanceLookup>, _inst:stdgo.Ref<Named>):stdgo.Ref<Named> {
        @:recv var _l:stdgo.Ref<T_instanceLookup> = _l;
        for (__0 => _t in _l._buf) {
            if (((_t != null) && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) && identical(stdgo.Go.asInterface(_inst), stdgo.Go.asInterface(_t))) {
                return _t;
            };
        };
        for (__9 => _t in (_l._m[_inst.origin()] ?? (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Named>>))) {
            if (identical(stdgo.Go.asInterface(_inst), stdgo.Go.asInterface(_t))) {
                return _t;
            };
        };
        return null;
    }
}
class Map__asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type_ return __self__.value.underlying();
    /**
        // Elem returns the element type of map m.
    **/
    @:keep
    public dynamic function elem():Type_ return __self__.value.elem();
    /**
        // Key returns the key type of map m.
    **/
    @:keep
    public dynamic function key():Type_ return __self__.value.key();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Map_>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Map__asInterface) class Map__static_extension {
    @:keep
    static public function string( _t:stdgo.Ref<Map_>):stdgo.GoString {
        @:recv var _t:stdgo.Ref<Map_> = _t;
        return typeString(stdgo.Go.asInterface(_t), null)?.__copy__();
    }
    @:keep
    static public function underlying( _t:stdgo.Ref<Map_>):Type_ {
        @:recv var _t:stdgo.Ref<Map_> = _t;
        return stdgo.Go.asInterface(_t);
    }
    /**
        // Elem returns the element type of map m.
    **/
    @:keep
    static public function elem( _m:stdgo.Ref<Map_>):Type_ {
        @:recv var _m:stdgo.Ref<Map_> = _m;
        return _m._elem;
    }
    /**
        // Key returns the key type of map m.
    **/
    @:keep
    static public function key( _m:stdgo.Ref<Map_>):Type_ {
        @:recv var _m:stdgo.Ref<Map_> = _m;
        return _m._key;
    }
}
class MethodSet_asInterface {
    /**
        // Lookup returns the method with matching package and name, or nil if not found.
    **/
    @:keep
    public dynamic function lookup(_pkg:stdgo.Ref<Package>, _name:stdgo.GoString):stdgo.Ref<Selection> return __self__.value.lookup(_pkg, _name);
    /**
        // At returns the i'th method in s for 0 <= i < s.Len().
    **/
    @:keep
    public dynamic function at(_i:stdgo.GoInt):stdgo.Ref<Selection> return __self__.value.at(_i);
    /**
        // Len returns the number of methods in s.
    **/
    @:keep
    public dynamic function len():stdgo.GoInt return __self__.value.len();
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<MethodSet>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.MethodSet_asInterface) class MethodSet_static_extension {
    /**
        // Lookup returns the method with matching package and name, or nil if not found.
    **/
    @:keep
    static public function lookup( _s:stdgo.Ref<MethodSet>, _pkg:stdgo.Ref<Package>, _name:stdgo.GoString):stdgo.Ref<Selection> {
        @:recv var _s:stdgo.Ref<MethodSet> = _s;
        if (_s.len() == ((0 : stdgo.GoInt))) {
            return null;
        };
        var _key:stdgo.GoString = id(_pkg, _name?.__copy__())?.__copy__();
        var _i:stdgo.GoInt = stdgo.sort.Sort.search((_s._list.length), function(_i:stdgo.GoInt):Bool {
            var _m = _s._list[(_i : stdgo.GoInt)];
            return _m._obj.id() >= _key;
        });
        if (_i < (_s._list.length)) {
            var _m = _s._list[(_i : stdgo.GoInt)];
            if (_m._obj.id() == (_key)) {
                return _m;
            };
        };
        return null;
    }
    /**
        // At returns the i'th method in s for 0 <= i < s.Len().
    **/
    @:keep
    static public function at( _s:stdgo.Ref<MethodSet>, _i:stdgo.GoInt):stdgo.Ref<Selection> {
        @:recv var _s:stdgo.Ref<MethodSet> = _s;
        return _s._list[(_i : stdgo.GoInt)];
    }
    /**
        // Len returns the number of methods in s.
    **/
    @:keep
    static public function len( _s:stdgo.Ref<MethodSet>):stdgo.GoInt {
        @:recv var _s:stdgo.Ref<MethodSet> = _s;
        return (_s._list.length);
    }
    @:keep
    static public function string( _s:stdgo.Ref<MethodSet>):stdgo.GoString {
        @:recv var _s:stdgo.Ref<MethodSet> = _s;
        if (_s.len() == ((0 : stdgo.GoInt))) {
            return ("MethodSet {}" : stdgo.GoString);
        };
        var _buf:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
        stdgo.fmt.Fmt.fprintln(stdgo.Go.asInterface((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.strings.Strings.Builder>)), stdgo.Go.toInterface(("MethodSet {" : stdgo.GoString)));
        for (__0 => _f in _s._list) {
            stdgo.fmt.Fmt.fprintf(stdgo.Go.asInterface((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.strings.Strings.Builder>)), ("\t%s\n" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_f)));
        };
        stdgo.fmt.Fmt.fprintln(stdgo.Go.asInterface((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.strings.Strings.Builder>)), stdgo.Go.toInterface(("}" : stdgo.GoString)));
        return (_buf.string() : stdgo.GoString)?.__copy__();
    }
}
class T_monoGraph_asInterface {
    @:keep
    public dynamic function _addEdge(_dst:stdgo.GoInt, _src:stdgo.GoInt, _weight:stdgo.GoInt, _pos:stdgo.go.token.Token.Pos, _typ:Type_):Void __self__.value._addEdge(_dst, _src, _weight, _pos, _typ);
    /**
        // typeParamVertex returns the index of the vertex representing tpar.
    **/
    @:keep
    public dynamic function _typeParamVertex(_tpar:stdgo.Ref<TypeParam>):stdgo.GoInt return __self__.value._typeParamVertex(_tpar);
    /**
        // localNamedVertex returns the index of the vertex representing
        // named, or -1 if named doesn't need representation.
    **/
    @:keep
    public dynamic function _localNamedVertex(_pkg:stdgo.Ref<Package>, _named:stdgo.Ref<Named>):stdgo.GoInt return __self__.value._localNamedVertex(_pkg, _named);
    /**
        // assign records that tpar was instantiated as targ at pos.
    **/
    @:keep
    public dynamic function _assign(_pkg:stdgo.Ref<Package>, _pos:stdgo.go.token.Token.Pos, _tpar:stdgo.Ref<TypeParam>, _targ:Type_):Void __self__.value._assign(_pkg, _pos, _tpar, _targ);
    /**
        // recordInstance records that the given type parameters were
        // instantiated with the corresponding type arguments.
    **/
    @:keep
    public dynamic function _recordInstance(_pkg:stdgo.Ref<Package>, _pos:stdgo.go.token.Token.Pos, _tparams:stdgo.Slice<stdgo.Ref<TypeParam>>, _targs:stdgo.Slice<Type_>, _xlist:stdgo.Slice<stdgo.go.ast.Ast.Expr>):Void __self__.value._recordInstance(_pkg, _pos, _tparams, _targs, _xlist);
    /**
        // recordCanon records that tpar is the canonical type parameter
        // corresponding to method type parameter mpar.
    **/
    @:keep
    public dynamic function _recordCanon(_mpar:stdgo.Ref<TypeParam>, _tpar:stdgo.Ref<TypeParam>):Void __self__.value._recordCanon(_mpar, _tpar);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_monoGraph>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_monoGraph_asInterface) class T_monoGraph_static_extension {
    @:keep
    static public function _addEdge( _w:stdgo.Ref<T_monoGraph>, _dst:stdgo.GoInt, _src:stdgo.GoInt, _weight:stdgo.GoInt, _pos:stdgo.go.token.Token.Pos, _typ:Type_):Void {
        @:recv var _w:stdgo.Ref<T_monoGraph> = _w;
        _w._edges = (_w._edges.__append__(({ _dst : _dst, _src : _src, _weight : _weight, _pos : _pos, _typ : _typ } : stdgo.go.types.Types.T_monoEdge)));
    }
    /**
        // typeParamVertex returns the index of the vertex representing tpar.
    **/
    @:keep
    static public function _typeParamVertex( _w:stdgo.Ref<T_monoGraph>, _tpar:stdgo.Ref<TypeParam>):stdgo.GoInt {
        @:recv var _w:stdgo.Ref<T_monoGraph> = _w;
        {
            var __tmp__ = (_w._canon != null && _w._canon.exists(_tpar) ? { _0 : _w._canon[_tpar], _1 : true } : { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>), _1 : false }), _x:stdgo.Ref<stdgo.go.types.Types.TypeParam> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (_ok) {
                _tpar = _x;
            };
        };
        var _obj = _tpar._check._environment._decl._tdecl.name.obj();
        {
            var __tmp__ = (_w._nameIdx != null && _w._nameIdx.exists(_obj) ? { _0 : _w._nameIdx[_obj], _1 : true } : { _0 : (0 : stdgo.GoInt), _1 : false }), _idx:stdgo.GoInt = __tmp__._0, _ok:Bool = __tmp__._1;
            if (_ok) {
                return _idx;
            };
        };
        if (_w._nameIdx == null) {
            _w._nameIdx = ({
                final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, stdgo.GoInt>();
                @:mergeBlock {};
                cast x;
            } : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, stdgo.GoInt>);
        };
        var _idx:stdgo.GoInt = (_w._vertices.length);
        _w._vertices = (_w._vertices.__append__(({ _obj : _obj } : stdgo.go.types.Types.T_monoVertex)));
        _w._nameIdx[_obj] = _idx;
        return _idx;
    }
    /**
        // localNamedVertex returns the index of the vertex representing
        // named, or -1 if named doesn't need representation.
    **/
    @:keep
    static public function _localNamedVertex( _w:stdgo.Ref<T_monoGraph>, _pkg:stdgo.Ref<Package>, _named:stdgo.Ref<Named>):stdgo.GoInt {
        @:recv var _w:stdgo.Ref<T_monoGraph> = _w;
        var _obj = _named._check._environment._decl._tdecl.name.obj();
        if (_obj.pkg() != (_pkg)) {
            return (-1 : stdgo.GoInt);
        };
        var _root = _pkg.scope();
        if (_obj.parent() == (_root)) {
            return (-1 : stdgo.GoInt);
        };
        {
            var __tmp__ = (_w._nameIdx != null && _w._nameIdx.exists(_obj) ? { _0 : _w._nameIdx[_obj], _1 : true } : { _0 : (0 : stdgo.GoInt), _1 : false }), _idx:stdgo.GoInt = __tmp__._0, _ok:Bool = __tmp__._1;
            if (_ok) {
                return _idx;
            };
        };
        var _idx:stdgo.GoInt = (-1 : stdgo.GoInt);
        {
            var _scope = _obj.parent();
            stdgo.Go.cfor(_scope != (_root), _scope = _scope.parent(), {
                for (__8 => _elem in _scope._elems) {
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_elem) : stdgo.Ref<TypeName>)) : stdgo.Ref<TypeName>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeName>), _1 : false };
                        }, _elem = __tmp__._0, _ok = __tmp__._1;
                        if ((_ok && !_elem.isAlias()) && (_cmpPos(_elem.pos(), _obj.pos()) < (0 : stdgo.GoInt))) {
                            {
                                var __tmp__ = try {
                                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_elem.type()) : stdgo.Ref<TypeParam>)) : stdgo.Ref<TypeParam>), _1 : true };
                                } catch(_) {
                                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>), _1 : false };
                                }, _tpar = __tmp__._0, _ok = __tmp__._1;
                                if (_ok) {
                                    if (_idx < (0 : stdgo.GoInt)) {
                                        _idx = (_w._vertices.length);
                                        _w._vertices = (_w._vertices.__append__(({ _obj : _obj } : stdgo.go.types.Types.T_monoVertex)));
                                    };
                                    _w._addEdge(_idx, _w._typeParamVertex(_tpar), (1 : stdgo.GoInt), _obj.pos(), stdgo.Go.asInterface(_tpar));
                                };
                            };
                        };
                    };
                };
            });
        };
        if (_w._nameIdx == null) {
            _w._nameIdx = ({
                final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, stdgo.GoInt>();
                @:mergeBlock {};
                cast x;
            } : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeName>, stdgo.GoInt>);
        };
        _w._nameIdx[_obj] = _idx;
        return _idx;
    }
    /**
        // assign records that tpar was instantiated as targ at pos.
    **/
    @:keep
    static public function _assign( _w:stdgo.Ref<T_monoGraph>, _pkg:stdgo.Ref<Package>, _pos:stdgo.go.token.Token.Pos, _tpar:stdgo.Ref<TypeParam>, _targ:Type_):Void {
        @:recv var _w:stdgo.Ref<T_monoGraph> = _w;
        if (_tpar._check._environment._decl._tdecl.name.obj().pkg() != (_pkg)) {
            return;
        };
        var _flow:(stdgo.GoInt, stdgo.go.types.Types.Type_) -> Void = function(_src:stdgo.GoInt, _typ:Type_):Void {
            var _weight:stdgo.GoInt = (1 : stdgo.GoInt);
            if (stdgo.Go.toInterface(_typ) == (stdgo.Go.toInterface(_targ))) {
                _weight = (0 : stdgo.GoInt);
            };
            _w._addEdge(_w._typeParamVertex(_tpar), _src, _weight, _pos, _targ);
        };
        var _do:(_typ:Type_) -> Void = null;
        _do = function(_typ:Type_):Void {
            {
                final __type__ = _typ;
                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeParam>))) {
                    var _typ:stdgo.Ref<stdgo.go.types.Types.TypeParam> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__().value;
                    _assert(_typ._check._environment._decl._tdecl.name.obj().pkg() == (_pkg));
                    _flow(_w._typeParamVertex(_typ), stdgo.Go.asInterface(_typ));
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Named>))) {
                    var _typ:stdgo.Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                    {
                        var _src:stdgo.GoInt = _w._localNamedVertex(_pkg, _typ.origin());
                        if (_src >= (0 : stdgo.GoInt)) {
                            _flow(_src, stdgo.Go.asInterface(_typ));
                        };
                    };
                    var _targs = _typ.typeArgs();
                    {
                        var _i:stdgo.GoInt = (0 : stdgo.GoInt);
                        stdgo.Go.cfor(_i < _targs.len(), _i++, {
                            _do(_targs.at(_i));
                        });
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Array_>))) {
                    var _typ:stdgo.Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                    _do(_typ.elem());
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                    var _typ:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Chan>))) {
                    var _typ:stdgo.Ref<stdgo.go.types.Types.Chan> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__().value;
                    _do(_typ.elem());
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Map_>))) {
                    var _typ:stdgo.Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                    _do(_typ.key());
                    _do(_typ.elem());
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Pointer_>))) {
                    var _typ:stdgo.Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                    _do(_typ.elem());
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Slice_>))) {
                    var _typ:stdgo.Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                    _do(_typ.elem());
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                    var _typ:stdgo.Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                    {
                        var _i:stdgo.GoInt = (0 : stdgo.GoInt);
                        stdgo.Go.cfor(_i < _typ.numMethods(), _i++, {
                            _do(_typ.method(_i).type());
                        });
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Signature>))) {
                    var _typ:stdgo.Ref<stdgo.go.types.Types.Signature> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__().value;
                    var _tuple = function(_tup:stdgo.Ref<Tuple>):Void {
                        {
                            var _i:stdgo.GoInt = (0 : stdgo.GoInt);
                            stdgo.Go.cfor(_i < _tup.len(), _i++, {
                                _do(_tup.at(_i).type());
                            });
                        };
                    };
                    _tuple(_typ.params());
                    _tuple(_typ.results());
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Struct>))) {
                    var _typ:stdgo.Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                    {
                        var _i:stdgo.GoInt = (0 : stdgo.GoInt);
                        stdgo.Go.cfor(_i < _typ.numFields(), _i++, {
                            _do(_typ.field(_i).type());
                        });
                    };
                } else {
                    var _typ:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                    throw stdgo.Go.toInterface(("unexpected type" : stdgo.GoString));
                };
            };
        };
        _do(_targ);
    }
    /**
        // recordInstance records that the given type parameters were
        // instantiated with the corresponding type arguments.
    **/
    @:keep
    static public function _recordInstance( _w:stdgo.Ref<T_monoGraph>, _pkg:stdgo.Ref<Package>, _pos:stdgo.go.token.Token.Pos, _tparams:stdgo.Slice<stdgo.Ref<TypeParam>>, _targs:stdgo.Slice<Type_>, _xlist:stdgo.Slice<stdgo.go.ast.Ast.Expr>):Void {
        @:recv var _w:stdgo.Ref<T_monoGraph> = _w;
        for (_i => _tpar in _tparams) {
            var _pos:stdgo.go.token.Token.Pos = _pos;
            if (_i < (_xlist.length)) {
                _pos = _xlist[(_i : stdgo.GoInt)].pos();
            };
            _w._assign(_pkg, _pos, _tpar, _targs[(_i : stdgo.GoInt)]);
        };
    }
    /**
        // recordCanon records that tpar is the canonical type parameter
        // corresponding to method type parameter mpar.
    **/
    @:keep
    static public function _recordCanon( _w:stdgo.Ref<T_monoGraph>, _mpar:stdgo.Ref<TypeParam>, _tpar:stdgo.Ref<TypeParam>):Void {
        @:recv var _w:stdgo.Ref<T_monoGraph> = _w;
        if (_w._canon == null) {
            _w._canon = ({
                final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.types.Types.TypeParam>, stdgo.Ref<stdgo.go.types.Types.TypeParam>>();
                @:mergeBlock {};
                cast x;
            } : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.TypeParam>, stdgo.Ref<stdgo.go.types.Types.TypeParam>>);
        };
        _w._canon[_mpar] = _tpar;
    }
}
class Named_asInterface {
    /**
        // expandUnderlying substitutes type arguments in the underlying type n.orig,
        // returning the result. Returns Typ[Invalid] if there was an error.
    **/
    @:keep
    public dynamic function _expandUnderlying():Type_ return __self__.value._expandUnderlying();
    @:keep
    public dynamic function _lookupMethod(_pkg:stdgo.Ref<Package>, _name:stdgo.GoString, _foldCase:Bool):{ var _0 : stdgo.GoInt; var _1 : stdgo.Ref<Func>; } return __self__.value._lookupMethod(_pkg, _name, _foldCase);
    @:keep
    public dynamic function _setUnderlying(_typ:Type_):Void __self__.value._setUnderlying(_typ);
    /**
        // under returns the expanded underlying type of n0; possibly by following
        // forward chains of named types. If an underlying type is found, resolve
        // the chain by setting the underlying type for each defined type in the
        // chain before returning it. If no underlying type is found or a cycle
        // is detected, the result is Typ[Invalid]. If a cycle is detected and
        // n0.check != nil, the cycle is reported.
        //
        // This is necessary because the underlying type of named may be itself a
        // named type that is incomplete:
        //
        //	type (
        //		A B
        //		B *C
        //		C A
        //	)
        //
        // The type of C is the (named) type of A which is incomplete,
        // and which has as its underlying type the named type B.
    **/
    @:keep
    public dynamic function _under():Type_ return __self__.value._under();
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type_ return __self__.value.underlying();
    /**
        // AddMethod adds method m unless it is already in the method list.
        // t must not have type arguments.
    **/
    @:keep
    public dynamic function addMethod(_m:stdgo.Ref<Func>):Void __self__.value.addMethod(_m);
    /**
        // SetUnderlying sets the underlying type and marks t as complete.
        // t must not have type arguments.
    **/
    @:keep
    public dynamic function setUnderlying(_underlying:Type_):Void __self__.value.setUnderlying(_underlying);
    /**
        // expandMethod substitutes type arguments in the i'th method for an
        // instantiated receiver.
    **/
    @:keep
    public dynamic function _expandMethod(_i:stdgo.GoInt):stdgo.Ref<Func> return __self__.value._expandMethod(_i);
    /**
        // Method returns the i'th method of named type t for 0 <= i < t.NumMethods().
        //
        // For an ordinary or instantiated type t, the receiver base type of this
        // method is the named type t. For an uninstantiated generic type t, each
        // method receiver is instantiated with its receiver type parameters.
    **/
    @:keep
    public dynamic function method(_i:stdgo.GoInt):stdgo.Ref<Func> return __self__.value.method(_i);
    /**
        // NumMethods returns the number of explicit methods defined for t.
    **/
    @:keep
    public dynamic function numMethods():stdgo.GoInt return __self__.value.numMethods();
    /**
        // TypeArgs returns the type arguments used to instantiate the named type t.
    **/
    @:keep
    public dynamic function typeArgs():stdgo.Ref<TypeList> return __self__.value.typeArgs();
    /**
        // SetTypeParams sets the type parameters of the named type t.
        // t must not have type arguments.
    **/
    @:keep
    public dynamic function setTypeParams(_tparams:stdgo.Slice<stdgo.Ref<TypeParam>>):Void __self__.value.setTypeParams(_tparams);
    /**
        // TypeParams returns the type parameters of the named type t, or nil.
        // The result is non-nil for an (originally) generic type even if it is instantiated.
    **/
    @:keep
    public dynamic function typeParams():stdgo.Ref<TypeParamList> return __self__.value.typeParams();
    /**
        // Origin returns the generic type from which the named type t is
        // instantiated. If t is not an instantiated type, the result is t.
    **/
    @:keep
    public dynamic function origin():stdgo.Ref<Named> return __self__.value.origin();
    /**
        // Obj returns the type name for the declaration defining the named type t. For
        // instantiated types, this is same as the type name of the origin type.
    **/
    @:keep
    public dynamic function obj():stdgo.Ref<TypeName> return __self__.value.obj();
    @:keep
    public dynamic function _cleanup():Void __self__.value._cleanup();
    /**
        // setState atomically stores the given state for n.
        // Must only be called while holding n.mu.
    **/
    @:keep
    public dynamic function _setState(_state:T_namedState):Void __self__.value._setState(_state);
    /**
        // state atomically accesses the current state of the receiver.
    **/
    @:keep
    public dynamic function _state():T_namedState return __self__.value._state();
    /**
        // resolve resolves the type parameters, methods, and underlying type of n.
        // This information may be loaded from a provided loader function, or computed
        // from an origin type (in the case of instances).
        //
        // After resolution, the type parameters, methods, and underlying type of n are
        // accessible; but if n is an instantiated type, its methods may still be
        // unexpanded.
    **/
    @:keep
    public dynamic function _resolve():stdgo.Ref<Named> return __self__.value._resolve();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Named>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Named_asInterface) class Named_static_extension {
    /**
        // expandUnderlying substitutes type arguments in the underlying type n.orig,
        // returning the result. Returns Typ[Invalid] if there was an error.
    **/
    @:keep
    static public function _expandUnderlying( _n:stdgo.Ref<Named>):Type_ {
        @:recv var _n:stdgo.Ref<Named> = _n;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            var _check = _n._check;
            if (((_check != null) && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) && _check._conf.__Trace) {
                _check._trace(_n._obj._object._pos, ("-- Named.expandUnderlying %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_n)));
                _check._indent++;
                __deferstack__.unshift(() -> {
                    var a = function():Void {
                        _check._indent--;
                        _check._trace(_n._obj._object._pos, ("=> %s (tparams = %s, under = %s)" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_n)), stdgo.Go.toInterface(_n._tparams._list()), stdgo.Go.toInterface(_n._underlying));
                    };
                    a();
                });
            };
            _assert(_n._inst._orig._underlying != null);
            if (_n._inst._ctxt == null || (_n._inst._ctxt : Dynamic).__nil__) {
                _n._inst._ctxt = newContext();
            };
            var _orig = _n._inst._orig;
            var _targs = _n._inst._targs;
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_orig._underlying) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
                }, __96 = __tmp__._0, _unexpanded = __tmp__._1;
                if (_unexpanded) {
                    _assert(_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__));
                };
            };
            if (_orig._tparams.len() != (_targs.len())) {
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                };
            };
            var _h:stdgo.GoString = _n._inst._ctxt._instanceHash(stdgo.Go.asInterface(_orig), _targs._list())?.__copy__();
            var _n2:stdgo.go.types.Types.Type_ = _n._inst._ctxt._update(_h?.__copy__(), stdgo.Go.asInterface(_orig), _n.typeArgs()._list(), stdgo.Go.asInterface(_n));
            _assert(stdgo.Go.toInterface(stdgo.Go.asInterface(_n)) == (stdgo.Go.toInterface(_n2)));
            var _smap:stdgo.go.types.Types.T_substMap = _makeSubstMap(_orig._tparams._list(), _targs._list());
            var _ctxt:stdgo.Ref<Context> = (null : stdgo.Ref<stdgo.go.types.Types.Context>);
            if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
                _ctxt = _check._context();
            };
            var _underlying:stdgo.go.types.Types.Type_ = _n._check._subst(_n._obj._object._pos, _orig._underlying, _smap, _n, _ctxt);
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_underlying) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Interface>), _1 : false };
                }, _iface = __tmp__._0, __177 = __tmp__._1;
                if (_iface != null && ((_iface : Dynamic).__nil__ == null || !(_iface : Dynamic).__nil__)) {
                    {
                        var __tmp__ = _replaceRecvType(_iface._methods, stdgo.Go.asInterface(_orig), stdgo.Go.asInterface(_n)), _methods:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>> = __tmp__._0, _copied:Bool = __tmp__._1;
                        if (_copied) {
                            if (stdgo.Go.toInterface(stdgo.Go.asInterface(_iface)) == (stdgo.Go.toInterface(_orig._underlying))) {
                                var _old = _iface;
                                _iface = _check._newInterface();
                                _iface._embeddeds = _old._embeddeds;
                                _iface._complete = _old._complete;
                                _iface._implicit = _old._implicit;
                                _underlying = stdgo.Go.asInterface(_iface);
                            };
                            _iface._methods = _methods;
                        };
                    };
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _underlying;
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return (null : stdgo.go.types.Types.Type_);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return (null : stdgo.go.types.Types.Type_);
        };
    }
    @:keep
    static public function _lookupMethod( _n:stdgo.Ref<Named>, _pkg:stdgo.Ref<Package>, _name:stdgo.GoString, _foldCase:Bool):{ var _0 : stdgo.GoInt; var _1 : stdgo.Ref<Func>; } {
        @:recv var _n:stdgo.Ref<Named> = _n;
        _n._resolve();
        var __tmp__ = stdgo.go.types.Types._lookupMethod(_n.origin()._methods, _pkg, _name?.__copy__(), _foldCase), _i:stdgo.GoInt = __tmp__._0, __24:stdgo.Ref<stdgo.go.types.Types.Func> = __tmp__._1;
        if (_i < (0 : stdgo.GoInt)) {
            return { _0 : (-1 : stdgo.GoInt), _1 : null };
        };
        return { _0 : _i, _1 : _n.method(_i) };
    }
    @:keep
    static public function _setUnderlying( _n:stdgo.Ref<Named>, _typ:Type_):Void {
        @:recv var _n:stdgo.Ref<Named> = _n;
        if (_n != null && ((_n : Dynamic).__nil__ == null || !(_n : Dynamic).__nil__)) {
            _n._underlying = _typ;
        };
    }
    /**
        // under returns the expanded underlying type of n0; possibly by following
        // forward chains of named types. If an underlying type is found, resolve
        // the chain by setting the underlying type for each defined type in the
        // chain before returning it. If no underlying type is found or a cycle
        // is detected, the result is Typ[Invalid]. If a cycle is detected and
        // n0.check != nil, the cycle is reported.
        //
        // This is necessary because the underlying type of named may be itself a
        // named type that is incomplete:
        //
        //	type (
        //		A B
        //		B *C
        //		C A
        //	)
        //
        // The type of C is the (named) type of A which is incomplete,
        // and which has as its underlying type the named type B.
    **/
    @:keep
    static public function _under( _n0:stdgo.Ref<Named>):Type_ {
        stdgo.internal.Macro.controlFlow({
            @:recv var _n0:stdgo.Ref<Named> = _n0;
            var _u:stdgo.go.types.Types.Type_ = _n0.underlying();
            var _n1:stdgo.Ref<Named> = (null : stdgo.Ref<stdgo.go.types.Types.Named>);
            {
                final __type__ = _u;
                if (__type__ == null) {
                    var _u1:stdgo.AnyInterface = __type__ == null ? (null : stdgo.AnyInterface) : cast __type__;
                    throw stdgo.Go.toInterface(("nil underlying" : stdgo.GoString));
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Named>))) {
                    var _u1:stdgo.Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                    _n1 = _u1;
                } else {
                    var _u1:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                    return _u;
                };
            };
            if (_n0._check == null || (_n0._check : Dynamic).__nil__) {
                throw stdgo.Go.toInterface(("Named.check == nil but type is incomplete" : stdgo.GoString));
            };
            var _check = _n0._check;
            var _n = _n0;
            var _seen = ({
                final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.types.Types.Named>, stdgo.GoInt>();
                @:mergeBlock {};
                cast x;
            } : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Named>, stdgo.GoInt>);
            var _path:stdgo.Slice<Object> = (null : stdgo.Slice<stdgo.go.types.Types.Object>);
            @:label("loop") while (true) {
                _seen[_n] = (_seen.length);
                _path = (_path.__append__(stdgo.Go.asInterface(_n._obj)));
                _n = _n1;
                {
                    var __tmp__ = (_seen != null && _seen.exists(_n) ? { _0 : _seen[_n], _1 : true } : { _0 : (0 : stdgo.GoInt), _1 : false }), _i:stdgo.GoInt = __tmp__._0, _ok:Bool = __tmp__._1;
                    if (_ok) {
                        _check._cycleError((_path.__slice__(_i) : stdgo.Slice<stdgo.go.types.Types.Object>));
                        _u = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                        break;
                    };
                };
                _u = _n.underlying();
                {
                    final __type__ = _u;
                    {
                        var __bool__ = true;
                        while (__bool__) {
                            __bool__ = false;
                            if (__type__ == null) {
                                var _u1:stdgo.AnyInterface = __type__ == null ? (null : stdgo.AnyInterface) : cast __type__;
                                _u = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                                @:jump("loop") break;
                            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Named>))) {
                                var _u1:stdgo.Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                                _n1 = _u1;
                            } else {
                                var _u1:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                                @:jump("loop") break;
                            };
                            break;
                        };
                    };
                };
            };
            for (_n => _ in _seen) {
                if (_n._obj._object._pkg != (_check._pkg)) {
                    throw stdgo.Go.toInterface(("imported type with unresolved underlying type" : stdgo.GoString));
                };
                _n._underlying = _u;
            };
            return _u;
        });
        throw "controlFlow did not return";
    }
    @:keep
    static public function string( _t:stdgo.Ref<Named>):stdgo.GoString {
        @:recv var _t:stdgo.Ref<Named> = _t;
        return typeString(stdgo.Go.asInterface(_t), null)?.__copy__();
    }
    @:keep
    static public function underlying( _t:stdgo.Ref<Named>):Type_ {
        @:recv var _t:stdgo.Ref<Named> = _t;
        return _t._resolve()._underlying;
    }
    /**
        // AddMethod adds method m unless it is already in the method list.
        // t must not have type arguments.
    **/
    @:keep
    static public function addMethod( _t:stdgo.Ref<Named>, _m:stdgo.Ref<Func>):Void {
        @:recv var _t:stdgo.Ref<Named> = _t;
        _assert(_t._inst == null || (_t._inst : Dynamic).__nil__);
        _t._resolve();
        {
            var __tmp__ = stdgo.go.types.Types._lookupMethod(_t._methods, _m._object._pkg, _m._object._name?.__copy__(), false), _i:stdgo.GoInt = __tmp__._0, __24:stdgo.Ref<stdgo.go.types.Types.Func> = __tmp__._1;
            if (_i < (0 : stdgo.GoInt)) {
                _t._methods = (_t._methods.__append__(_m));
            };
        };
    }
    /**
        // SetUnderlying sets the underlying type and marks t as complete.
        // t must not have type arguments.
    **/
    @:keep
    static public function setUnderlying( _t:stdgo.Ref<Named>, _underlying:Type_):Void {
        @:recv var _t:stdgo.Ref<Named> = _t;
        _assert(_t._inst == null || (_t._inst : Dynamic).__nil__);
        if (_underlying == null) {
            throw stdgo.Go.toInterface(("underlying type must not be nil" : stdgo.GoString));
        };
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_underlying) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
            }, __8 = __tmp__._0, _ok = __tmp__._1;
            if (_ok) {
                throw stdgo.Go.toInterface(("underlying type must not be *Named" : stdgo.GoString));
            };
        };
        _t._resolve()._underlying = _underlying;
        if (_t._fromRHS == null) {
            _t._fromRHS = _underlying;
        };
    }
    /**
        // expandMethod substitutes type arguments in the i'th method for an
        // instantiated receiver.
    **/
    @:keep
    static public function _expandMethod( _t:stdgo.Ref<Named>, _i:stdgo.GoInt):stdgo.Ref<Func> {
        @:recv var _t:stdgo.Ref<Named> = _t;
        var _origm = _t._inst._orig.method(_i);
        _assert(_origm != null && ((_origm : Dynamic).__nil__ == null || !(_origm : Dynamic).__nil__));
        var _check = _t._check;
        if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
            _check._objDecl(stdgo.Go.asInterface(_origm), null);
        };
        var _origSig = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_origm._object._typ) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>);
        var __tmp__ = _deref(_origSig.recv().type()), _rbase:stdgo.go.types.Types.Type_ = __tmp__._0, __32:Bool = __tmp__._1;
        if (stdgo.Go.toInterface(_rbase) == (stdgo.Go.toInterface(stdgo.Go.asInterface(_t)))) {
            return _origm;
        };
        var _sig = _origSig;
        if (_origSig.recvTypeParams().len() == (_t._inst._targs.len())) {
            var _smap:stdgo.go.types.Types.T_substMap = _makeSubstMap(_origSig.recvTypeParams()._list(), _t._inst._targs._list());
            var _ctxt:stdgo.Ref<Context> = (null : stdgo.Ref<stdgo.go.types.Types.Context>);
            if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
                _ctxt = _check._context();
            };
            _sig = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_check._subst(_origm._object._pos, stdgo.Go.asInterface(_origSig), _smap, _t, _ctxt)) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>);
        };
        if (_sig == (_origSig)) {
            var _copy:stdgo.go.types.Types.Signature = (_origSig : stdgo.go.types.Types.Signature)?.__copy__();
            _sig = (stdgo.Go.setRef(_copy) : stdgo.Ref<stdgo.go.types.Types.Signature>);
        };
        var _rtyp:Type_ = (null : stdgo.go.types.Types.Type_);
        if (_origm._hasPtrRecv()) {
            _rtyp = stdgo.Go.asInterface(newPointer(stdgo.Go.asInterface(_t)));
        } else {
            _rtyp = stdgo.Go.asInterface(_t);
        };
        _sig._recv = _substVar(_origSig._recv, _rtyp);
        return _substFunc(_origm, stdgo.Go.asInterface(_sig));
    }
    /**
        // Method returns the i'th method of named type t for 0 <= i < t.NumMethods().
        //
        // For an ordinary or instantiated type t, the receiver base type of this
        // method is the named type t. For an uninstantiated generic type t, each
        // method receiver is instantiated with its receiver type parameters.
    **/
    @:keep
    static public function method( _t:stdgo.Ref<Named>, _i:stdgo.GoInt):stdgo.Ref<Func> {
        @:recv var _t:stdgo.Ref<Named> = _t;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            _t._resolve();
            if (_t._mu._state() >= (2u32 : stdgo.go.types.Types.T_namedState)) {
                return _t._methods[(_i : stdgo.GoInt)];
            };
            _assert(_t._inst != null && ((_t._inst : Dynamic).__nil__ == null || !(_t._inst : Dynamic).__nil__));
            var _orig = _t._inst._orig;
            _t._mu.lock();
            __deferstack__.unshift(() -> _t._mu.unlock());
            if ((_t._methods.length) != ((_orig._methods.length))) {
                _assert((_t._methods.length) == ((0 : stdgo.GoInt)));
                _t._methods = new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>((_orig._methods.length : stdgo.GoInt).toBasic(), 0);
            };
            if (_t._methods[(_i : stdgo.GoInt)] == null || (_t._methods[(_i : stdgo.GoInt)] : Dynamic).__nil__) {
                _assert(_t._inst._ctxt != null && ((_t._inst._ctxt : Dynamic).__nil__ == null || !(_t._inst._ctxt : Dynamic).__nil__));
                _t._methods[(_i : stdgo.GoInt)] = _t._expandMethod(_i);
                _t._inst._expandedMethods++;
                if (_t._inst._expandedMethods == ((_orig._methods.length))) {
                    _t._setState((2u32 : stdgo.go.types.Types.T_namedState));
                    _t._inst._ctxt = null;
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _t._methods[(_i : stdgo.GoInt)];
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return (null : stdgo.Ref<stdgo.go.types.Types.Func>);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return (null : stdgo.Ref<stdgo.go.types.Types.Func>);
        };
    }
    /**
        // NumMethods returns the number of explicit methods defined for t.
    **/
    @:keep
    static public function numMethods( _t:stdgo.Ref<Named>):stdgo.GoInt {
        @:recv var _t:stdgo.Ref<Named> = _t;
        return (_t.origin()._resolve()._methods.length);
    }
    /**
        // TypeArgs returns the type arguments used to instantiate the named type t.
    **/
    @:keep
    static public function typeArgs( _t:stdgo.Ref<Named>):stdgo.Ref<TypeList> {
        @:recv var _t:stdgo.Ref<Named> = _t;
        if (_t._inst == null || (_t._inst : Dynamic).__nil__) {
            return null;
        };
        return _t._inst._targs;
    }
    /**
        // SetTypeParams sets the type parameters of the named type t.
        // t must not have type arguments.
    **/
    @:keep
    static public function setTypeParams( _t:stdgo.Ref<Named>, _tparams:stdgo.Slice<stdgo.Ref<TypeParam>>):Void {
        @:recv var _t:stdgo.Ref<Named> = _t;
        _assert(_t._inst == null || (_t._inst : Dynamic).__nil__);
        _t._resolve()._tparams = _bindTParams(_tparams);
    }
    /**
        // TypeParams returns the type parameters of the named type t, or nil.
        // The result is non-nil for an (originally) generic type even if it is instantiated.
    **/
    @:keep
    static public function typeParams( _t:stdgo.Ref<Named>):stdgo.Ref<TypeParamList> {
        @:recv var _t:stdgo.Ref<Named> = _t;
        return _t._resolve()._tparams;
    }
    /**
        // Origin returns the generic type from which the named type t is
        // instantiated. If t is not an instantiated type, the result is t.
    **/
    @:keep
    static public function origin( _t:stdgo.Ref<Named>):stdgo.Ref<Named> {
        @:recv var _t:stdgo.Ref<Named> = _t;
        if (_t._inst == null || (_t._inst : Dynamic).__nil__) {
            return _t;
        };
        return _t._inst._orig;
    }
    /**
        // Obj returns the type name for the declaration defining the named type t. For
        // instantiated types, this is same as the type name of the origin type.
    **/
    @:keep
    static public function obj( _t:stdgo.Ref<Named>):stdgo.Ref<TypeName> {
        @:recv var _t:stdgo.Ref<Named> = _t;
        if (_t._inst == null || (_t._inst : Dynamic).__nil__) {
            return _t._obj;
        };
        return _t._inst._orig._obj;
    }
    @:keep
    static public function _cleanup( _t:stdgo.Ref<Named>):Void {
        @:recv var _t:stdgo.Ref<Named> = _t;
        _assert(((_t._inst == null) || (_t._inst : Dynamic).__nil__) || ((_t._inst._orig._inst == null) || (_t._inst._orig._inst : Dynamic).__nil__));
        {
            final __type__ = _t._underlying;
            if (__type__ == null) {
                if (_t.typeArgs().len() == ((0 : stdgo.GoInt))) {
                    throw stdgo.Go.toInterface(("nil underlying" : stdgo.GoString));
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Named>))) {
                _t._under();
            };
        };
        _t._check = null;
    }
    /**
        // setState atomically stores the given state for n.
        // Must only be called while holding n.mu.
    **/
    @:keep
    static public function _setState( _n:stdgo.Ref<Named>, _state:T_namedState):Void {
        @:recv var _n:stdgo.Ref<Named> = _n;
        stdgo.sync.atomic_.Atomic_.storeUint32(stdgo.Go.pointer(_n._state_), (_state : stdgo.GoUInt32));
    }
    /**
        // state atomically accesses the current state of the receiver.
    **/
    @:keep
    static public function _state( _n:stdgo.Ref<Named>):T_namedState {
        @:recv var _n:stdgo.Ref<Named> = _n;
        return (stdgo.sync.atomic_.Atomic_.loadUint32(stdgo.Go.pointer(_n._state_)) : T_namedState);
    }
    /**
        // resolve resolves the type parameters, methods, and underlying type of n.
        // This information may be loaded from a provided loader function, or computed
        // from an origin type (in the case of instances).
        //
        // After resolution, the type parameters, methods, and underlying type of n are
        // accessible; but if n is an instantiated type, its methods may still be
        // unexpanded.
    **/
    @:keep
    static public function _resolve( _n:stdgo.Ref<Named>):stdgo.Ref<Named> {
        @:recv var _n:stdgo.Ref<Named> = _n;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            if (_n._mu._state() >= (1u32 : stdgo.go.types.Types.T_namedState)) {
                return _n;
            };
            _n._mu.lock();
            __deferstack__.unshift(() -> _n._mu.unlock());
            if (_n._mu._state() >= (1u32 : stdgo.go.types.Types.T_namedState)) {
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return _n;
                };
            };
            if (_n._inst != null && ((_n._inst : Dynamic).__nil__ == null || !(_n._inst : Dynamic).__nil__)) {
                _assert(_n._underlying == null);
                _assert(_n._loader == null);
                var _orig = _n._inst._orig;
                _orig._resolve();
                var _underlying:stdgo.go.types.Types.Type_ = _n._expandUnderlying();
                _n._tparams = _orig._tparams;
                _n._underlying = _underlying;
                _n._fromRHS = _orig._fromRHS;
                if ((_orig._methods.length) == ((0 : stdgo.GoInt))) {
                    _n._setState((2u32 : stdgo.go.types.Types.T_namedState));
                    _n._inst._ctxt = null;
                } else {
                    _n._setState((1u32 : stdgo.go.types.Types.T_namedState));
                };
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return _n;
                };
            };
            if (_n._loader != null) {
                _assert(_n._underlying == null);
                _assert(_n.typeArgs().len() == ((0 : stdgo.GoInt)));
                var __tmp__ = _n._loader(_n), _tparams:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>> = __tmp__._0, _underlying:stdgo.go.types.Types.Type_ = __tmp__._1, _methods:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>> = __tmp__._2;
                _n._tparams = _bindTParams(_tparams);
                _n._underlying = _underlying;
                _n._fromRHS = _underlying;
                _n._methods = _methods;
                _n._loader = null;
            };
            _n._setState((2u32 : stdgo.go.types.Types.T_namedState));
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _n;
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return (null : stdgo.Ref<stdgo.go.types.Types.Named>);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return (null : stdgo.Ref<stdgo.go.types.Types.Named>);
        };
    }
}
class T_object_asInterface {
    /**
        // less reports whether object a is ordered before object b.
        //
        // Objects are ordered nil before non-nil, exported before
        // non-exported, then by name, and finally (for non-exported
        // functions) by package path.
    **/
    @:keep
    public dynamic function _less(_b:stdgo.Ref<T_object>):Bool return __self__.value._less(_b);
    @:keep
    public dynamic function _sameId(_pkg:stdgo.Ref<Package>, _name:stdgo.GoString):Bool return __self__.value._sameId(_pkg, _name);
    @:keep
    public dynamic function _setScopePos(_pos:stdgo.go.token.Token.Pos):Void __self__.value._setScopePos(_pos);
    @:keep
    public dynamic function _setColor(_color:T_color):Void __self__.value._setColor(_color);
    @:keep
    public dynamic function _setOrder(_order:stdgo.GoUInt32):Void __self__.value._setOrder(_order);
    @:keep
    public dynamic function _setType(_typ:Type_):Void __self__.value._setType(_typ);
    @:keep
    public dynamic function _setParent(_parent:stdgo.Ref<Scope>):Void __self__.value._setParent(_parent);
    @:keep
    public dynamic function _scopePos():stdgo.go.token.Token.Pos return __self__.value._scopePos();
    @:keep
    public dynamic function _color():T_color return __self__.value._color();
    @:keep
    public dynamic function _order():stdgo.GoUInt32 return __self__.value._order();
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    /**
        // Id is a wrapper for Id(obj.Pkg(), obj.Name()).
    **/
    @:keep
    public dynamic function id():stdgo.GoString return __self__.value.id();
    /**
        // Exported reports whether the object is exported (starts with a capital letter).
        // It doesn't take into account whether the object is in a local (function) scope
        // or not.
    **/
    @:keep
    public dynamic function exported():Bool return __self__.value.exported();
    /**
        // Type returns the object's type.
    **/
    @:keep
    public dynamic function type():Type_ return __self__.value.type();
    /**
        // Name returns the object's (package-local, unqualified) name.
    **/
    @:keep
    public dynamic function name():stdgo.GoString return __self__.value.name();
    /**
        // Pkg returns the package to which the object belongs.
        // The result is nil for labels and objects in the Universe scope.
    **/
    @:keep
    public dynamic function pkg():stdgo.Ref<Package> return __self__.value.pkg();
    /**
        // Pos returns the declaration position of the object's identifier.
    **/
    @:keep
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    /**
        // Parent returns the scope in which the object is declared.
        // The result is nil for methods and struct fields.
    **/
    @:keep
    public dynamic function parent():stdgo.Ref<Scope> return __self__.value.parent();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_object>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_object_asInterface) class T_object_static_extension {
    /**
        // less reports whether object a is ordered before object b.
        //
        // Objects are ordered nil before non-nil, exported before
        // non-exported, then by name, and finally (for non-exported
        // functions) by package path.
    **/
    @:keep
    static public function _less( _a:stdgo.Ref<T_object>, _b:stdgo.Ref<T_object>):Bool {
        @:recv var _a:stdgo.Ref<T_object> = _a;
        if (_a == (_b)) {
            return false;
        };
        if (_a == null || (_a : Dynamic).__nil__) {
            return true;
        };
        if (_b == null || (_b : Dynamic).__nil__) {
            return false;
        };
        var _ea:Bool = _isExported(_a._name?.__copy__());
        var _eb:Bool = _isExported(_b._name?.__copy__());
        if (_ea != (_eb)) {
            return _ea;
        };
        if (_a._name != (_b._name)) {
            return _a._name < _b._name;
        };
        if (!_ea) {
            return _a._pkg._path < _b._pkg._path;
        };
        return false;
    }
    @:keep
    static public function _sameId( _obj:stdgo.Ref<T_object>, _pkg:stdgo.Ref<Package>, _name:stdgo.GoString):Bool {
        @:recv var _obj:stdgo.Ref<T_object> = _obj;
        if (_name != (_obj._name)) {
            return false;
        };
        if (_obj.exported()) {
            return true;
        };
        if (((_pkg == null) || (_pkg : Dynamic).__nil__) || ((_obj._pkg == null) || (_obj._pkg : Dynamic).__nil__)) {
            return _pkg == (_obj._pkg);
        };
        return _pkg._path == (_obj._pkg._path);
    }
    @:keep
    static public function _setScopePos( _obj:stdgo.Ref<T_object>, _pos:stdgo.go.token.Token.Pos):Void {
        @:recv var _obj:stdgo.Ref<T_object> = _obj;
        _obj._scopePos_ = _pos;
    }
    @:keep
    static public function _setColor( _obj:stdgo.Ref<T_object>, _color:T_color):Void {
        @:recv var _obj:stdgo.Ref<T_object> = _obj;
        _assert(_color != ((0u32 : stdgo.go.types.Types.T_color)));
        _obj._color_ = _color;
    }
    @:keep
    static public function _setOrder( _obj:stdgo.Ref<T_object>, _order:stdgo.GoUInt32):Void {
        @:recv var _obj:stdgo.Ref<T_object> = _obj;
        _assert(_order > (0u32 : stdgo.GoUInt32));
        _obj._order_ = _order;
    }
    @:keep
    static public function _setType( _obj:stdgo.Ref<T_object>, _typ:Type_):Void {
        @:recv var _obj:stdgo.Ref<T_object> = _obj;
        _obj._typ = _typ;
    }
    @:keep
    static public function _setParent( _obj:stdgo.Ref<T_object>, _parent:stdgo.Ref<Scope>):Void {
        @:recv var _obj:stdgo.Ref<T_object> = _obj;
        _obj._parent = _parent;
    }
    @:keep
    static public function _scopePos( _obj:stdgo.Ref<T_object>):stdgo.go.token.Token.Pos {
        @:recv var _obj:stdgo.Ref<T_object> = _obj;
        return _obj._scopePos_;
    }
    @:keep
    static public function _color( _obj:stdgo.Ref<T_object>):T_color {
        @:recv var _obj:stdgo.Ref<T_object> = _obj;
        return _obj._color_;
    }
    @:keep
    static public function _order( _obj:stdgo.Ref<T_object>):stdgo.GoUInt32 {
        @:recv var _obj:stdgo.Ref<T_object> = _obj;
        return _obj._order_;
    }
    @:keep
    static public function string( _obj:stdgo.Ref<T_object>):stdgo.GoString {
        @:recv var _obj:stdgo.Ref<T_object> = _obj;
        throw stdgo.Go.toInterface(("abstract" : stdgo.GoString));
    }
    /**
        // Id is a wrapper for Id(obj.Pkg(), obj.Name()).
    **/
    @:keep
    static public function id( _obj:stdgo.Ref<T_object>):stdgo.GoString {
        @:recv var _obj:stdgo.Ref<T_object> = _obj;
        return stdgo.go.types.Types.id(_obj._pkg, _obj._name?.__copy__())?.__copy__();
    }
    /**
        // Exported reports whether the object is exported (starts with a capital letter).
        // It doesn't take into account whether the object is in a local (function) scope
        // or not.
    **/
    @:keep
    static public function exported( _obj:stdgo.Ref<T_object>):Bool {
        @:recv var _obj:stdgo.Ref<T_object> = _obj;
        return _isExported(_obj._name?.__copy__());
    }
    /**
        // Type returns the object's type.
    **/
    @:keep
    static public function type( _obj:stdgo.Ref<T_object>):Type_ {
        @:recv var _obj:stdgo.Ref<T_object> = _obj;
        return _obj._typ;
    }
    /**
        // Name returns the object's (package-local, unqualified) name.
    **/
    @:keep
    static public function name( _obj:stdgo.Ref<T_object>):stdgo.GoString {
        @:recv var _obj:stdgo.Ref<T_object> = _obj;
        return _obj._name?.__copy__();
    }
    /**
        // Pkg returns the package to which the object belongs.
        // The result is nil for labels and objects in the Universe scope.
    **/
    @:keep
    static public function pkg( _obj:stdgo.Ref<T_object>):stdgo.Ref<Package> {
        @:recv var _obj:stdgo.Ref<T_object> = _obj;
        return _obj._pkg;
    }
    /**
        // Pos returns the declaration position of the object's identifier.
    **/
    @:keep
    static public function pos( _obj:stdgo.Ref<T_object>):stdgo.go.token.Token.Pos {
        @:recv var _obj:stdgo.Ref<T_object> = _obj;
        return _obj._pos;
    }
    /**
        // Parent returns the scope in which the object is declared.
        // The result is nil for methods and struct fields.
    **/
    @:keep
    static public function parent( _obj:stdgo.Ref<T_object>):stdgo.Ref<Scope> {
        @:recv var _obj:stdgo.Ref<T_object> = _obj;
        return _obj._parent;
    }
}
class PkgName_asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    /**
        // Imported returns the package that was imported.
        // It is distinct from Pkg(), which is the package containing the import statement.
    **/
    @:keep
    public dynamic function imported():stdgo.Ref<Package> return __self__.value.imported();
    @:embedded
    public dynamic function _setType(__0:stdgo.go.types.Types.Type_):Void __self__.value._setType(__0);
    @:embedded
    public dynamic function _setScopePos(_p:stdgo.go.token.Token.Pos):Void __self__.value._setScopePos(_p);
    @:embedded
    public dynamic function _setParent(__0:stdgo.Ref<stdgo.go.types.Types.Scope>):Void __self__.value._setParent(__0);
    @:embedded
    public dynamic function _setOrder(__0:stdgo.GoUInt32):Void __self__.value._setOrder(__0);
    @:embedded
    public dynamic function _setColor(__0:stdgo.go.types.Types.T_color):Void __self__.value._setColor(__0);
    @:embedded
    public dynamic function _scopePos():stdgo.go.token.Token.Pos return __self__.value._scopePos();
    @:embedded
    public dynamic function _sameId(_pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return __self__.value._sameId(_pkg_, _name_);
    @:embedded
    public dynamic function _order():stdgo.GoUInt32 return __self__.value._order();
    @:embedded
    public dynamic function _less(_b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return __self__.value._less(_b);
    @:embedded
    public dynamic function _color():stdgo.go.types.Types.T_color return __self__.value._color();
    @:embedded
    public dynamic function type():stdgo.go.types.Types.Type_ return __self__.value.type();
    @:embedded
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    @:embedded
    public dynamic function pkg():stdgo.Ref<stdgo.go.types.Types.Package> return __self__.value.pkg();
    @:embedded
    public dynamic function parent():stdgo.Ref<stdgo.go.types.Types.Scope> return __self__.value.parent();
    @:embedded
    public dynamic function name():stdgo.GoString return __self__.value.name();
    @:embedded
    public dynamic function id():stdgo.GoString return __self__.value.id();
    @:embedded
    public dynamic function exported():Bool return __self__.value.exported();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<PkgName>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.PkgName_asInterface) class PkgName_static_extension {
    @:keep
    static public function string( _obj:stdgo.Ref<PkgName>):stdgo.GoString {
        @:recv var _obj:stdgo.Ref<PkgName> = _obj;
        return objectString(stdgo.Go.asInterface(_obj), null)?.__copy__();
    }
    /**
        // Imported returns the package that was imported.
        // It is distinct from Pkg(), which is the package containing the import statement.
    **/
    @:keep
    static public function imported( _obj:stdgo.Ref<PkgName>):stdgo.Ref<Package> {
        @:recv var _obj:stdgo.Ref<PkgName> = _obj;
        return _obj._imported;
    }
    @:embedded
    public static function _setType( __self__:PkgName, __0:stdgo.go.types.Types.Type_) __self__._setType(__0);
    @:embedded
    public static function _setScopePos( __self__:PkgName, _p:stdgo.go.token.Token.Pos) __self__._setScopePos(_p);
    @:embedded
    public static function _setParent( __self__:PkgName, __0:stdgo.Ref<stdgo.go.types.Types.Scope>) __self__._setParent(__0);
    @:embedded
    public static function _setOrder( __self__:PkgName, __0:stdgo.GoUInt32) __self__._setOrder(__0);
    @:embedded
    public static function _setColor( __self__:PkgName, __0:stdgo.go.types.Types.T_color) __self__._setColor(__0);
    @:embedded
    public static function _scopePos( __self__:PkgName):stdgo.go.token.Token.Pos return __self__._scopePos();
    @:embedded
    public static function _sameId( __self__:PkgName, _pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return __self__._sameId(_pkg_, _name_);
    @:embedded
    public static function _order( __self__:PkgName):stdgo.GoUInt32 return __self__._order();
    @:embedded
    public static function _less( __self__:PkgName, _b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return __self__._less(_b);
    @:embedded
    public static function _color( __self__:PkgName):stdgo.go.types.Types.T_color return __self__._color();
    @:embedded
    public static function type( __self__:PkgName):stdgo.go.types.Types.Type_ return __self__.type();
    @:embedded
    public static function pos( __self__:PkgName):stdgo.go.token.Token.Pos return __self__.pos();
    @:embedded
    public static function pkg( __self__:PkgName):stdgo.Ref<stdgo.go.types.Types.Package> return __self__.pkg();
    @:embedded
    public static function parent( __self__:PkgName):stdgo.Ref<stdgo.go.types.Types.Scope> return __self__.parent();
    @:embedded
    public static function name( __self__:PkgName):stdgo.GoString return __self__.name();
    @:embedded
    public static function id( __self__:PkgName):stdgo.GoString return __self__.id();
    @:embedded
    public static function exported( __self__:PkgName):Bool return __self__.exported();
}
class Const_asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:keep
    public dynamic function _isDependency():Void __self__.value._isDependency();
    /**
        // Val returns the constant's value.
    **/
    @:keep
    public dynamic function val():stdgo.go.constant.Constant.Value return __self__.value.val();
    @:embedded
    public dynamic function _setType(__0:stdgo.go.types.Types.Type_):Void __self__.value._setType(__0);
    @:embedded
    public dynamic function _setScopePos(_p:stdgo.go.token.Token.Pos):Void __self__.value._setScopePos(_p);
    @:embedded
    public dynamic function _setParent(__0:stdgo.Ref<stdgo.go.types.Types.Scope>):Void __self__.value._setParent(__0);
    @:embedded
    public dynamic function _setOrder(__0:stdgo.GoUInt32):Void __self__.value._setOrder(__0);
    @:embedded
    public dynamic function _setColor(__0:stdgo.go.types.Types.T_color):Void __self__.value._setColor(__0);
    @:embedded
    public dynamic function _scopePos():stdgo.go.token.Token.Pos return __self__.value._scopePos();
    @:embedded
    public dynamic function _sameId(_pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return __self__.value._sameId(_pkg_, _name_);
    @:embedded
    public dynamic function _order():stdgo.GoUInt32 return __self__.value._order();
    @:embedded
    public dynamic function _less(_b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return __self__.value._less(_b);
    @:embedded
    public dynamic function _color():stdgo.go.types.Types.T_color return __self__.value._color();
    @:embedded
    public dynamic function type():stdgo.go.types.Types.Type_ return __self__.value.type();
    @:embedded
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    @:embedded
    public dynamic function pkg():stdgo.Ref<stdgo.go.types.Types.Package> return __self__.value.pkg();
    @:embedded
    public dynamic function parent():stdgo.Ref<stdgo.go.types.Types.Scope> return __self__.value.parent();
    @:embedded
    public dynamic function name():stdgo.GoString return __self__.value.name();
    @:embedded
    public dynamic function id():stdgo.GoString return __self__.value.id();
    @:embedded
    public dynamic function exported():Bool return __self__.value.exported();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Const>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Const_asInterface) class Const_static_extension {
    @:keep
    static public function string( _obj:stdgo.Ref<Const>):stdgo.GoString {
        @:recv var _obj:stdgo.Ref<Const> = _obj;
        return objectString(stdgo.Go.asInterface(_obj), null)?.__copy__();
    }
    @:keep
    static public function _isDependency( _:stdgo.Ref<Const>):Void {
        @:recv var _:stdgo.Ref<Const> = _;
    }
    /**
        // Val returns the constant's value.
    **/
    @:keep
    static public function val( _obj:stdgo.Ref<Const>):stdgo.go.constant.Constant.Value {
        @:recv var _obj:stdgo.Ref<Const> = _obj;
        return _obj._val;
    }
    @:embedded
    public static function _setType( __self__:Const, __0:stdgo.go.types.Types.Type_) __self__._setType(__0);
    @:embedded
    public static function _setScopePos( __self__:Const, _p:stdgo.go.token.Token.Pos) __self__._setScopePos(_p);
    @:embedded
    public static function _setParent( __self__:Const, __0:stdgo.Ref<stdgo.go.types.Types.Scope>) __self__._setParent(__0);
    @:embedded
    public static function _setOrder( __self__:Const, __0:stdgo.GoUInt32) __self__._setOrder(__0);
    @:embedded
    public static function _setColor( __self__:Const, __0:stdgo.go.types.Types.T_color) __self__._setColor(__0);
    @:embedded
    public static function _scopePos( __self__:Const):stdgo.go.token.Token.Pos return __self__._scopePos();
    @:embedded
    public static function _sameId( __self__:Const, _pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return __self__._sameId(_pkg_, _name_);
    @:embedded
    public static function _order( __self__:Const):stdgo.GoUInt32 return __self__._order();
    @:embedded
    public static function _less( __self__:Const, _b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return __self__._less(_b);
    @:embedded
    public static function _color( __self__:Const):stdgo.go.types.Types.T_color return __self__._color();
    @:embedded
    public static function type( __self__:Const):stdgo.go.types.Types.Type_ return __self__.type();
    @:embedded
    public static function pos( __self__:Const):stdgo.go.token.Token.Pos return __self__.pos();
    @:embedded
    public static function pkg( __self__:Const):stdgo.Ref<stdgo.go.types.Types.Package> return __self__.pkg();
    @:embedded
    public static function parent( __self__:Const):stdgo.Ref<stdgo.go.types.Types.Scope> return __self__.parent();
    @:embedded
    public static function name( __self__:Const):stdgo.GoString return __self__.name();
    @:embedded
    public static function id( __self__:Const):stdgo.GoString return __self__.id();
    @:embedded
    public static function exported( __self__:Const):Bool return __self__.exported();
}
class TypeName_asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    /**
        // IsAlias reports whether obj is an alias name for a type.
    **/
    @:keep
    public dynamic function isAlias():Bool return __self__.value.isAlias();
    @:embedded
    public dynamic function _setType(__0:stdgo.go.types.Types.Type_):Void __self__.value._setType(__0);
    @:embedded
    public dynamic function _setScopePos(_p:stdgo.go.token.Token.Pos):Void __self__.value._setScopePos(_p);
    @:embedded
    public dynamic function _setParent(__0:stdgo.Ref<stdgo.go.types.Types.Scope>):Void __self__.value._setParent(__0);
    @:embedded
    public dynamic function _setOrder(__0:stdgo.GoUInt32):Void __self__.value._setOrder(__0);
    @:embedded
    public dynamic function _setColor(__0:stdgo.go.types.Types.T_color):Void __self__.value._setColor(__0);
    @:embedded
    public dynamic function _scopePos():stdgo.go.token.Token.Pos return __self__.value._scopePos();
    @:embedded
    public dynamic function _sameId(_pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return __self__.value._sameId(_pkg_, _name_);
    @:embedded
    public dynamic function _order():stdgo.GoUInt32 return __self__.value._order();
    @:embedded
    public dynamic function _less(_b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return __self__.value._less(_b);
    @:embedded
    public dynamic function _color():stdgo.go.types.Types.T_color return __self__.value._color();
    @:embedded
    public dynamic function type():stdgo.go.types.Types.Type_ return __self__.value.type();
    @:embedded
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    @:embedded
    public dynamic function pkg():stdgo.Ref<stdgo.go.types.Types.Package> return __self__.value.pkg();
    @:embedded
    public dynamic function parent():stdgo.Ref<stdgo.go.types.Types.Scope> return __self__.value.parent();
    @:embedded
    public dynamic function name():stdgo.GoString return __self__.value.name();
    @:embedded
    public dynamic function id():stdgo.GoString return __self__.value.id();
    @:embedded
    public dynamic function exported():Bool return __self__.value.exported();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<TypeName>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.TypeName_asInterface) class TypeName_static_extension {
    @:keep
    static public function string( _obj:stdgo.Ref<TypeName>):stdgo.GoString {
        @:recv var _obj:stdgo.Ref<TypeName> = _obj;
        return objectString(stdgo.Go.asInterface(_obj), null)?.__copy__();
    }
    /**
        // IsAlias reports whether obj is an alias name for a type.
    **/
    @:keep
    static public function isAlias( _obj:stdgo.Ref<TypeName>):Bool {
        @:recv var _obj:stdgo.Ref<TypeName> = _obj;
        {
            final __type__ = _obj._object._typ;
            if (__type__ == null) {
                var _t:stdgo.AnyInterface = __type__ == null ? (null : stdgo.AnyInterface) : cast __type__;
                return false;
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                var _t:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                if (_obj._object._pkg == (unsafe)) {
                    return false;
                };
                return ((((_obj._object._pkg != null) && ((_obj._object._pkg : Dynamic).__nil__ == null || !(_obj._object._pkg : Dynamic).__nil__)) || (_t._name != _obj._object._name)) || (stdgo.Go.toInterface(stdgo.Go.asInterface(_t)) == stdgo.Go.toInterface(_universeByte))) || (stdgo.Go.toInterface(stdgo.Go.asInterface(_t)) == stdgo.Go.toInterface(_universeRune));
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Named>))) {
                var _t:stdgo.Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                return _obj != (_t._obj);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeParam>))) {
                var _t:stdgo.Ref<stdgo.go.types.Types.TypeParam> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__().value;
                return _obj != (_t._obj);
            } else {
                var _t:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                return true;
            };
        };
    }
    @:embedded
    public static function _setType( __self__:TypeName, __0:stdgo.go.types.Types.Type_) __self__._setType(__0);
    @:embedded
    public static function _setScopePos( __self__:TypeName, _p:stdgo.go.token.Token.Pos) __self__._setScopePos(_p);
    @:embedded
    public static function _setParent( __self__:TypeName, __0:stdgo.Ref<stdgo.go.types.Types.Scope>) __self__._setParent(__0);
    @:embedded
    public static function _setOrder( __self__:TypeName, __0:stdgo.GoUInt32) __self__._setOrder(__0);
    @:embedded
    public static function _setColor( __self__:TypeName, __0:stdgo.go.types.Types.T_color) __self__._setColor(__0);
    @:embedded
    public static function _scopePos( __self__:TypeName):stdgo.go.token.Token.Pos return __self__._scopePos();
    @:embedded
    public static function _sameId( __self__:TypeName, _pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return __self__._sameId(_pkg_, _name_);
    @:embedded
    public static function _order( __self__:TypeName):stdgo.GoUInt32 return __self__._order();
    @:embedded
    public static function _less( __self__:TypeName, _b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return __self__._less(_b);
    @:embedded
    public static function _color( __self__:TypeName):stdgo.go.types.Types.T_color return __self__._color();
    @:embedded
    public static function type( __self__:TypeName):stdgo.go.types.Types.Type_ return __self__.type();
    @:embedded
    public static function pos( __self__:TypeName):stdgo.go.token.Token.Pos return __self__.pos();
    @:embedded
    public static function pkg( __self__:TypeName):stdgo.Ref<stdgo.go.types.Types.Package> return __self__.pkg();
    @:embedded
    public static function parent( __self__:TypeName):stdgo.Ref<stdgo.go.types.Types.Scope> return __self__.parent();
    @:embedded
    public static function name( __self__:TypeName):stdgo.GoString return __self__.name();
    @:embedded
    public static function id( __self__:TypeName):stdgo.GoString return __self__.id();
    @:embedded
    public static function exported( __self__:TypeName):Bool return __self__.exported();
}
class Var_asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:keep
    public dynamic function _isDependency():Void __self__.value._isDependency();
    /**
        // Origin returns the canonical Var for its receiver, i.e. the Var object
        // recorded in Info.Defs.
        //
        // For synthetic Vars created during instantiation (such as struct fields or
        // function parameters that depend on type arguments), this will be the
        // corresponding Var on the generic (uninstantiated) type. For all other Vars
        // Origin returns the receiver.
    **/
    @:keep
    public dynamic function origin():stdgo.Ref<Var> return __self__.value.origin();
    /**
        // IsField reports whether the variable is a struct field.
    **/
    @:keep
    public dynamic function isField():Bool return __self__.value.isField();
    /**
        // Embedded reports whether the variable is an embedded field.
    **/
    @:keep
    public dynamic function embedded():Bool return __self__.value.embedded();
    /**
        // Anonymous reports whether the variable is an embedded field.
        // Same as Embedded; only present for backward-compatibility.
    **/
    @:keep
    public dynamic function anonymous():Bool return __self__.value.anonymous();
    @:embedded
    public dynamic function _setType(__0:stdgo.go.types.Types.Type_):Void __self__.value._setType(__0);
    @:embedded
    public dynamic function _setScopePos(_p:stdgo.go.token.Token.Pos):Void __self__.value._setScopePos(_p);
    @:embedded
    public dynamic function _setParent(__0:stdgo.Ref<stdgo.go.types.Types.Scope>):Void __self__.value._setParent(__0);
    @:embedded
    public dynamic function _setOrder(__0:stdgo.GoUInt32):Void __self__.value._setOrder(__0);
    @:embedded
    public dynamic function _setColor(__0:stdgo.go.types.Types.T_color):Void __self__.value._setColor(__0);
    @:embedded
    public dynamic function _scopePos():stdgo.go.token.Token.Pos return __self__.value._scopePos();
    @:embedded
    public dynamic function _sameId(_pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return __self__.value._sameId(_pkg_, _name_);
    @:embedded
    public dynamic function _order():stdgo.GoUInt32 return __self__.value._order();
    @:embedded
    public dynamic function _less(_b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return __self__.value._less(_b);
    @:embedded
    public dynamic function _color():stdgo.go.types.Types.T_color return __self__.value._color();
    @:embedded
    public dynamic function type():stdgo.go.types.Types.Type_ return __self__.value.type();
    @:embedded
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    @:embedded
    public dynamic function pkg():stdgo.Ref<stdgo.go.types.Types.Package> return __self__.value.pkg();
    @:embedded
    public dynamic function parent():stdgo.Ref<stdgo.go.types.Types.Scope> return __self__.value.parent();
    @:embedded
    public dynamic function name():stdgo.GoString return __self__.value.name();
    @:embedded
    public dynamic function id():stdgo.GoString return __self__.value.id();
    @:embedded
    public dynamic function exported():Bool return __self__.value.exported();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Var>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Var_asInterface) class Var_static_extension {
    @:keep
    static public function string( _obj:stdgo.Ref<Var>):stdgo.GoString {
        @:recv var _obj:stdgo.Ref<Var> = _obj;
        return objectString(stdgo.Go.asInterface(_obj), null)?.__copy__();
    }
    @:keep
    static public function _isDependency( _:stdgo.Ref<Var>):Void {
        @:recv var _:stdgo.Ref<Var> = _;
    }
    /**
        // Origin returns the canonical Var for its receiver, i.e. the Var object
        // recorded in Info.Defs.
        //
        // For synthetic Vars created during instantiation (such as struct fields or
        // function parameters that depend on type arguments), this will be the
        // corresponding Var on the generic (uninstantiated) type. For all other Vars
        // Origin returns the receiver.
    **/
    @:keep
    static public function origin( _obj:stdgo.Ref<Var>):stdgo.Ref<Var> {
        @:recv var _obj:stdgo.Ref<Var> = _obj;
        if (_obj._origin != null && ((_obj._origin : Dynamic).__nil__ == null || !(_obj._origin : Dynamic).__nil__)) {
            return _obj._origin;
        };
        return _obj;
    }
    /**
        // IsField reports whether the variable is a struct field.
    **/
    @:keep
    static public function isField( _obj:stdgo.Ref<Var>):Bool {
        @:recv var _obj:stdgo.Ref<Var> = _obj;
        return _obj._isField;
    }
    /**
        // Embedded reports whether the variable is an embedded field.
    **/
    @:keep
    static public function embedded( _obj:stdgo.Ref<Var>):Bool {
        @:recv var _obj:stdgo.Ref<Var> = _obj;
        return _obj._embedded;
    }
    /**
        // Anonymous reports whether the variable is an embedded field.
        // Same as Embedded; only present for backward-compatibility.
    **/
    @:keep
    static public function anonymous( _obj:stdgo.Ref<Var>):Bool {
        @:recv var _obj:stdgo.Ref<Var> = _obj;
        return _obj._embedded;
    }
    @:embedded
    public static function _setType( __self__:Var, __0:stdgo.go.types.Types.Type_) __self__._setType(__0);
    @:embedded
    public static function _setScopePos( __self__:Var, _p:stdgo.go.token.Token.Pos) __self__._setScopePos(_p);
    @:embedded
    public static function _setParent( __self__:Var, __0:stdgo.Ref<stdgo.go.types.Types.Scope>) __self__._setParent(__0);
    @:embedded
    public static function _setOrder( __self__:Var, __0:stdgo.GoUInt32) __self__._setOrder(__0);
    @:embedded
    public static function _setColor( __self__:Var, __0:stdgo.go.types.Types.T_color) __self__._setColor(__0);
    @:embedded
    public static function _scopePos( __self__:Var):stdgo.go.token.Token.Pos return __self__._scopePos();
    @:embedded
    public static function _sameId( __self__:Var, _pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return __self__._sameId(_pkg_, _name_);
    @:embedded
    public static function _order( __self__:Var):stdgo.GoUInt32 return __self__._order();
    @:embedded
    public static function _less( __self__:Var, _b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return __self__._less(_b);
    @:embedded
    public static function _color( __self__:Var):stdgo.go.types.Types.T_color return __self__._color();
    @:embedded
    public static function type( __self__:Var):stdgo.go.types.Types.Type_ return __self__.type();
    @:embedded
    public static function pos( __self__:Var):stdgo.go.token.Token.Pos return __self__.pos();
    @:embedded
    public static function pkg( __self__:Var):stdgo.Ref<stdgo.go.types.Types.Package> return __self__.pkg();
    @:embedded
    public static function parent( __self__:Var):stdgo.Ref<stdgo.go.types.Types.Scope> return __self__.parent();
    @:embedded
    public static function name( __self__:Var):stdgo.GoString return __self__.name();
    @:embedded
    public static function id( __self__:Var):stdgo.GoString return __self__.id();
    @:embedded
    public static function exported( __self__:Var):Bool return __self__.exported();
}
class Func_asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:keep
    public dynamic function _isDependency():Void __self__.value._isDependency();
    /**
        // hasPtrRecv reports whether the receiver is of the form *T for the given method obj.
    **/
    @:keep
    public dynamic function _hasPtrRecv():Bool return __self__.value._hasPtrRecv();
    /**
        // Origin returns the canonical Func for its receiver, i.e. the Func object
        // recorded in Info.Defs.
        //
        // For synthetic functions created during instantiation (such as methods on an
        // instantiated Named type or interface methods that depend on type arguments),
        // this will be the corresponding Func on the generic (uninstantiated) type.
        // For all other Funcs Origin returns the receiver.
    **/
    @:keep
    public dynamic function origin():stdgo.Ref<Func> return __self__.value.origin();
    /**
        // Scope returns the scope of the function's body block.
        // The result is nil for imported or instantiated functions and methods
        // (but there is also no mechanism to get to an instantiated function).
    **/
    @:keep
    public dynamic function scope():stdgo.Ref<Scope> return __self__.value.scope();
    /**
        // FullName returns the package- or receiver-type-qualified name of
        // function or method obj.
    **/
    @:keep
    public dynamic function fullName():stdgo.GoString return __self__.value.fullName();
    @:embedded
    public dynamic function _setType(__0:stdgo.go.types.Types.Type_):Void __self__.value._setType(__0);
    @:embedded
    public dynamic function _setScopePos(_p:stdgo.go.token.Token.Pos):Void __self__.value._setScopePos(_p);
    @:embedded
    public dynamic function _setParent(__0:stdgo.Ref<stdgo.go.types.Types.Scope>):Void __self__.value._setParent(__0);
    @:embedded
    public dynamic function _setOrder(__0:stdgo.GoUInt32):Void __self__.value._setOrder(__0);
    @:embedded
    public dynamic function _setColor(__0:stdgo.go.types.Types.T_color):Void __self__.value._setColor(__0);
    @:embedded
    public dynamic function _scopePos():stdgo.go.token.Token.Pos return __self__.value._scopePos();
    @:embedded
    public dynamic function _sameId(_pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return __self__.value._sameId(_pkg_, _name_);
    @:embedded
    public dynamic function _order():stdgo.GoUInt32 return __self__.value._order();
    @:embedded
    public dynamic function _less(_b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return __self__.value._less(_b);
    @:embedded
    public dynamic function _color():stdgo.go.types.Types.T_color return __self__.value._color();
    @:embedded
    public dynamic function type():stdgo.go.types.Types.Type_ return __self__.value.type();
    @:embedded
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    @:embedded
    public dynamic function pkg():stdgo.Ref<stdgo.go.types.Types.Package> return __self__.value.pkg();
    @:embedded
    public dynamic function parent():stdgo.Ref<stdgo.go.types.Types.Scope> return __self__.value.parent();
    @:embedded
    public dynamic function name():stdgo.GoString return __self__.value.name();
    @:embedded
    public dynamic function id():stdgo.GoString return __self__.value.id();
    @:embedded
    public dynamic function exported():Bool return __self__.value.exported();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Func>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Func_asInterface) class Func_static_extension {
    @:keep
    static public function string( _obj:stdgo.Ref<Func>):stdgo.GoString {
        @:recv var _obj:stdgo.Ref<Func> = _obj;
        return objectString(stdgo.Go.asInterface(_obj), null)?.__copy__();
    }
    @:keep
    static public function _isDependency( _:stdgo.Ref<Func>):Void {
        @:recv var _:stdgo.Ref<Func> = _;
    }
    /**
        // hasPtrRecv reports whether the receiver is of the form *T for the given method obj.
    **/
    @:keep
    static public function _hasPtrRecv( _obj:stdgo.Ref<Func>):Bool {
        @:recv var _obj:stdgo.Ref<Func> = _obj;
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj._object._typ) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Signature>), _1 : false };
            }, _sig = __tmp__._0, __0 = __tmp__._1;
            if (((_sig != null) && ((_sig : Dynamic).__nil__ == null || !(_sig : Dynamic).__nil__)) && ((_sig._recv != null) && ((_sig._recv : Dynamic).__nil__ == null || !(_sig._recv : Dynamic).__nil__))) {
                var __tmp__ = _deref(_sig._recv._object._typ), __1:stdgo.go.types.Types.Type_ = __tmp__._0, _isPtr:Bool = __tmp__._1;
                return _isPtr;
            };
        };
        return _obj._hasPtrRecv_;
    }
    /**
        // Origin returns the canonical Func for its receiver, i.e. the Func object
        // recorded in Info.Defs.
        //
        // For synthetic functions created during instantiation (such as methods on an
        // instantiated Named type or interface methods that depend on type arguments),
        // this will be the corresponding Func on the generic (uninstantiated) type.
        // For all other Funcs Origin returns the receiver.
    **/
    @:keep
    static public function origin( _obj:stdgo.Ref<Func>):stdgo.Ref<Func> {
        @:recv var _obj:stdgo.Ref<Func> = _obj;
        if (_obj._origin != null && ((_obj._origin : Dynamic).__nil__ == null || !(_obj._origin : Dynamic).__nil__)) {
            return _obj._origin;
        };
        return _obj;
    }
    /**
        // Scope returns the scope of the function's body block.
        // The result is nil for imported or instantiated functions and methods
        // (but there is also no mechanism to get to an instantiated function).
    **/
    @:keep
    static public function scope( _obj:stdgo.Ref<Func>):stdgo.Ref<Scope> {
        @:recv var _obj:stdgo.Ref<Func> = _obj;
        return (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj._object._typ) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>)._scope;
    }
    /**
        // FullName returns the package- or receiver-type-qualified name of
        // function or method obj.
    **/
    @:keep
    static public function fullName( _obj:stdgo.Ref<Func>):stdgo.GoString {
        @:recv var _obj:stdgo.Ref<Func> = _obj;
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        _writeFuncName((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.bytes.Bytes.Buffer>), _obj, null);
        return (_buf.string() : stdgo.GoString)?.__copy__();
    }
    @:embedded
    public static function _setType( __self__:Func, __0:stdgo.go.types.Types.Type_) __self__._setType(__0);
    @:embedded
    public static function _setScopePos( __self__:Func, _p:stdgo.go.token.Token.Pos) __self__._setScopePos(_p);
    @:embedded
    public static function _setParent( __self__:Func, __0:stdgo.Ref<stdgo.go.types.Types.Scope>) __self__._setParent(__0);
    @:embedded
    public static function _setOrder( __self__:Func, __0:stdgo.GoUInt32) __self__._setOrder(__0);
    @:embedded
    public static function _setColor( __self__:Func, __0:stdgo.go.types.Types.T_color) __self__._setColor(__0);
    @:embedded
    public static function _scopePos( __self__:Func):stdgo.go.token.Token.Pos return __self__._scopePos();
    @:embedded
    public static function _sameId( __self__:Func, _pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return __self__._sameId(_pkg_, _name_);
    @:embedded
    public static function _order( __self__:Func):stdgo.GoUInt32 return __self__._order();
    @:embedded
    public static function _less( __self__:Func, _b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return __self__._less(_b);
    @:embedded
    public static function _color( __self__:Func):stdgo.go.types.Types.T_color return __self__._color();
    @:embedded
    public static function type( __self__:Func):stdgo.go.types.Types.Type_ return __self__.type();
    @:embedded
    public static function pos( __self__:Func):stdgo.go.token.Token.Pos return __self__.pos();
    @:embedded
    public static function pkg( __self__:Func):stdgo.Ref<stdgo.go.types.Types.Package> return __self__.pkg();
    @:embedded
    public static function parent( __self__:Func):stdgo.Ref<stdgo.go.types.Types.Scope> return __self__.parent();
    @:embedded
    public static function name( __self__:Func):stdgo.GoString return __self__.name();
    @:embedded
    public static function id( __self__:Func):stdgo.GoString return __self__.id();
    @:embedded
    public static function exported( __self__:Func):Bool return __self__.exported();
}
class Label_asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:embedded
    public dynamic function _setType(__0:stdgo.go.types.Types.Type_):Void __self__.value._setType(__0);
    @:embedded
    public dynamic function _setScopePos(_p:stdgo.go.token.Token.Pos):Void __self__.value._setScopePos(_p);
    @:embedded
    public dynamic function _setParent(__0:stdgo.Ref<stdgo.go.types.Types.Scope>):Void __self__.value._setParent(__0);
    @:embedded
    public dynamic function _setOrder(__0:stdgo.GoUInt32):Void __self__.value._setOrder(__0);
    @:embedded
    public dynamic function _setColor(__0:stdgo.go.types.Types.T_color):Void __self__.value._setColor(__0);
    @:embedded
    public dynamic function _scopePos():stdgo.go.token.Token.Pos return __self__.value._scopePos();
    @:embedded
    public dynamic function _sameId(_pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return __self__.value._sameId(_pkg_, _name_);
    @:embedded
    public dynamic function _order():stdgo.GoUInt32 return __self__.value._order();
    @:embedded
    public dynamic function _less(_b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return __self__.value._less(_b);
    @:embedded
    public dynamic function _color():stdgo.go.types.Types.T_color return __self__.value._color();
    @:embedded
    public dynamic function type():stdgo.go.types.Types.Type_ return __self__.value.type();
    @:embedded
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    @:embedded
    public dynamic function pkg():stdgo.Ref<stdgo.go.types.Types.Package> return __self__.value.pkg();
    @:embedded
    public dynamic function parent():stdgo.Ref<stdgo.go.types.Types.Scope> return __self__.value.parent();
    @:embedded
    public dynamic function name():stdgo.GoString return __self__.value.name();
    @:embedded
    public dynamic function id():stdgo.GoString return __self__.value.id();
    @:embedded
    public dynamic function exported():Bool return __self__.value.exported();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Label>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Label_asInterface) class Label_static_extension {
    @:keep
    static public function string( _obj:stdgo.Ref<Label>):stdgo.GoString {
        @:recv var _obj:stdgo.Ref<Label> = _obj;
        return objectString(stdgo.Go.asInterface(_obj), null)?.__copy__();
    }
    @:embedded
    public static function _setType( __self__:Label, __0:stdgo.go.types.Types.Type_) __self__._setType(__0);
    @:embedded
    public static function _setScopePos( __self__:Label, _p:stdgo.go.token.Token.Pos) __self__._setScopePos(_p);
    @:embedded
    public static function _setParent( __self__:Label, __0:stdgo.Ref<stdgo.go.types.Types.Scope>) __self__._setParent(__0);
    @:embedded
    public static function _setOrder( __self__:Label, __0:stdgo.GoUInt32) __self__._setOrder(__0);
    @:embedded
    public static function _setColor( __self__:Label, __0:stdgo.go.types.Types.T_color) __self__._setColor(__0);
    @:embedded
    public static function _scopePos( __self__:Label):stdgo.go.token.Token.Pos return __self__._scopePos();
    @:embedded
    public static function _sameId( __self__:Label, _pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return __self__._sameId(_pkg_, _name_);
    @:embedded
    public static function _order( __self__:Label):stdgo.GoUInt32 return __self__._order();
    @:embedded
    public static function _less( __self__:Label, _b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return __self__._less(_b);
    @:embedded
    public static function _color( __self__:Label):stdgo.go.types.Types.T_color return __self__._color();
    @:embedded
    public static function type( __self__:Label):stdgo.go.types.Types.Type_ return __self__.type();
    @:embedded
    public static function pos( __self__:Label):stdgo.go.token.Token.Pos return __self__.pos();
    @:embedded
    public static function pkg( __self__:Label):stdgo.Ref<stdgo.go.types.Types.Package> return __self__.pkg();
    @:embedded
    public static function parent( __self__:Label):stdgo.Ref<stdgo.go.types.Types.Scope> return __self__.parent();
    @:embedded
    public static function name( __self__:Label):stdgo.GoString return __self__.name();
    @:embedded
    public static function id( __self__:Label):stdgo.GoString return __self__.id();
    @:embedded
    public static function exported( __self__:Label):Bool return __self__.exported();
}
class Builtin_asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:embedded
    public dynamic function _setType(__0:stdgo.go.types.Types.Type_):Void __self__.value._setType(__0);
    @:embedded
    public dynamic function _setScopePos(_p:stdgo.go.token.Token.Pos):Void __self__.value._setScopePos(_p);
    @:embedded
    public dynamic function _setParent(__0:stdgo.Ref<stdgo.go.types.Types.Scope>):Void __self__.value._setParent(__0);
    @:embedded
    public dynamic function _setOrder(__0:stdgo.GoUInt32):Void __self__.value._setOrder(__0);
    @:embedded
    public dynamic function _setColor(__0:stdgo.go.types.Types.T_color):Void __self__.value._setColor(__0);
    @:embedded
    public dynamic function _scopePos():stdgo.go.token.Token.Pos return __self__.value._scopePos();
    @:embedded
    public dynamic function _sameId(_pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return __self__.value._sameId(_pkg_, _name_);
    @:embedded
    public dynamic function _order():stdgo.GoUInt32 return __self__.value._order();
    @:embedded
    public dynamic function _less(_b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return __self__.value._less(_b);
    @:embedded
    public dynamic function _color():stdgo.go.types.Types.T_color return __self__.value._color();
    @:embedded
    public dynamic function type():stdgo.go.types.Types.Type_ return __self__.value.type();
    @:embedded
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    @:embedded
    public dynamic function pkg():stdgo.Ref<stdgo.go.types.Types.Package> return __self__.value.pkg();
    @:embedded
    public dynamic function parent():stdgo.Ref<stdgo.go.types.Types.Scope> return __self__.value.parent();
    @:embedded
    public dynamic function name():stdgo.GoString return __self__.value.name();
    @:embedded
    public dynamic function id():stdgo.GoString return __self__.value.id();
    @:embedded
    public dynamic function exported():Bool return __self__.value.exported();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Builtin>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Builtin_asInterface) class Builtin_static_extension {
    @:keep
    static public function string( _obj:stdgo.Ref<Builtin>):stdgo.GoString {
        @:recv var _obj:stdgo.Ref<Builtin> = _obj;
        return objectString(stdgo.Go.asInterface(_obj), null)?.__copy__();
    }
    @:embedded
    public static function _setType( __self__:Builtin, __0:stdgo.go.types.Types.Type_) __self__._setType(__0);
    @:embedded
    public static function _setScopePos( __self__:Builtin, _p:stdgo.go.token.Token.Pos) __self__._setScopePos(_p);
    @:embedded
    public static function _setParent( __self__:Builtin, __0:stdgo.Ref<stdgo.go.types.Types.Scope>) __self__._setParent(__0);
    @:embedded
    public static function _setOrder( __self__:Builtin, __0:stdgo.GoUInt32) __self__._setOrder(__0);
    @:embedded
    public static function _setColor( __self__:Builtin, __0:stdgo.go.types.Types.T_color) __self__._setColor(__0);
    @:embedded
    public static function _scopePos( __self__:Builtin):stdgo.go.token.Token.Pos return __self__._scopePos();
    @:embedded
    public static function _sameId( __self__:Builtin, _pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return __self__._sameId(_pkg_, _name_);
    @:embedded
    public static function _order( __self__:Builtin):stdgo.GoUInt32 return __self__._order();
    @:embedded
    public static function _less( __self__:Builtin, _b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return __self__._less(_b);
    @:embedded
    public static function _color( __self__:Builtin):stdgo.go.types.Types.T_color return __self__._color();
    @:embedded
    public static function type( __self__:Builtin):stdgo.go.types.Types.Type_ return __self__.type();
    @:embedded
    public static function pos( __self__:Builtin):stdgo.go.token.Token.Pos return __self__.pos();
    @:embedded
    public static function pkg( __self__:Builtin):stdgo.Ref<stdgo.go.types.Types.Package> return __self__.pkg();
    @:embedded
    public static function parent( __self__:Builtin):stdgo.Ref<stdgo.go.types.Types.Scope> return __self__.parent();
    @:embedded
    public static function name( __self__:Builtin):stdgo.GoString return __self__.name();
    @:embedded
    public static function id( __self__:Builtin):stdgo.GoString return __self__.id();
    @:embedded
    public static function exported( __self__:Builtin):Bool return __self__.exported();
}
class Nil_asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:embedded
    public dynamic function _setType(__0:stdgo.go.types.Types.Type_):Void __self__.value._setType(__0);
    @:embedded
    public dynamic function _setScopePos(_p:stdgo.go.token.Token.Pos):Void __self__.value._setScopePos(_p);
    @:embedded
    public dynamic function _setParent(__0:stdgo.Ref<stdgo.go.types.Types.Scope>):Void __self__.value._setParent(__0);
    @:embedded
    public dynamic function _setOrder(__0:stdgo.GoUInt32):Void __self__.value._setOrder(__0);
    @:embedded
    public dynamic function _setColor(__0:stdgo.go.types.Types.T_color):Void __self__.value._setColor(__0);
    @:embedded
    public dynamic function _scopePos():stdgo.go.token.Token.Pos return __self__.value._scopePos();
    @:embedded
    public dynamic function _sameId(_pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return __self__.value._sameId(_pkg_, _name_);
    @:embedded
    public dynamic function _order():stdgo.GoUInt32 return __self__.value._order();
    @:embedded
    public dynamic function _less(_b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return __self__.value._less(_b);
    @:embedded
    public dynamic function _color():stdgo.go.types.Types.T_color return __self__.value._color();
    @:embedded
    public dynamic function type():stdgo.go.types.Types.Type_ return __self__.value.type();
    @:embedded
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    @:embedded
    public dynamic function pkg():stdgo.Ref<stdgo.go.types.Types.Package> return __self__.value.pkg();
    @:embedded
    public dynamic function parent():stdgo.Ref<stdgo.go.types.Types.Scope> return __self__.value.parent();
    @:embedded
    public dynamic function name():stdgo.GoString return __self__.value.name();
    @:embedded
    public dynamic function id():stdgo.GoString return __self__.value.id();
    @:embedded
    public dynamic function exported():Bool return __self__.value.exported();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Nil>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Nil_asInterface) class Nil_static_extension {
    @:keep
    static public function string( _obj:stdgo.Ref<Nil>):stdgo.GoString {
        @:recv var _obj:stdgo.Ref<Nil> = _obj;
        return objectString(stdgo.Go.asInterface(_obj), null)?.__copy__();
    }
    @:embedded
    public static function _setType( __self__:Nil, __0:stdgo.go.types.Types.Type_) __self__._setType(__0);
    @:embedded
    public static function _setScopePos( __self__:Nil, _p:stdgo.go.token.Token.Pos) __self__._setScopePos(_p);
    @:embedded
    public static function _setParent( __self__:Nil, __0:stdgo.Ref<stdgo.go.types.Types.Scope>) __self__._setParent(__0);
    @:embedded
    public static function _setOrder( __self__:Nil, __0:stdgo.GoUInt32) __self__._setOrder(__0);
    @:embedded
    public static function _setColor( __self__:Nil, __0:stdgo.go.types.Types.T_color) __self__._setColor(__0);
    @:embedded
    public static function _scopePos( __self__:Nil):stdgo.go.token.Token.Pos return __self__._scopePos();
    @:embedded
    public static function _sameId( __self__:Nil, _pkg_:stdgo.Ref<stdgo.go.types.Types.Package>, _name_:stdgo.GoString):Bool return __self__._sameId(_pkg_, _name_);
    @:embedded
    public static function _order( __self__:Nil):stdgo.GoUInt32 return __self__._order();
    @:embedded
    public static function _less( __self__:Nil, _b:stdgo.Ref<stdgo.go.types.Types.T_object>):Bool return __self__._less(_b);
    @:embedded
    public static function _color( __self__:Nil):stdgo.go.types.Types.T_color return __self__._color();
    @:embedded
    public static function type( __self__:Nil):stdgo.go.types.Types.Type_ return __self__.type();
    @:embedded
    public static function pos( __self__:Nil):stdgo.go.token.Token.Pos return __self__.pos();
    @:embedded
    public static function pkg( __self__:Nil):stdgo.Ref<stdgo.go.types.Types.Package> return __self__.pkg();
    @:embedded
    public static function parent( __self__:Nil):stdgo.Ref<stdgo.go.types.Types.Scope> return __self__.parent();
    @:embedded
    public static function name( __self__:Nil):stdgo.GoString return __self__.name();
    @:embedded
    public static function id( __self__:Nil):stdgo.GoString return __self__.id();
    @:embedded
    public static function exported( __self__:Nil):Bool return __self__.exported();
}
class T_operand_asInterface {
    /**
        // assignableTo reports whether x is assignable to a variable of type T. If the
        // result is false and a non-nil cause is provided, it may be set to a more
        // detailed explanation of the failure (result != ""). The returned error code
        // is only valid if the (first) result is false. The check parameter may be nil
        // if assignableTo is invoked through an exported API call, i.e., when all
        // methods have been type-checked.
    **/
    @:keep
    public dynamic function _assignableTo(_check:stdgo.Ref<Checker>, t:Type_, _cause:stdgo.Pointer<stdgo.GoString>):{ var _0 : Bool; var _1 : Code; } return __self__.value._assignableTo(_check, t, _cause);
    /**
        // isNil reports whether x is the (untyped) nil value.
    **/
    @:keep
    public dynamic function _isNil():Bool return __self__.value._isNil();
    /**
        // setConst sets x to the untyped constant for literal lit.
    **/
    @:keep
    public dynamic function _setConst(_tok:stdgo.go.token.Token.Token, _lit:stdgo.GoString):Void __self__.value._setConst(_tok, _lit);
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    /**
        // Pos returns the position of the expression corresponding to x.
        // If x is invalid the position is nopos.
    **/
    @:keep
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    /**
        // convertibleTo reports whether T(x) is valid. In the failure case, *cause
        // may be set to the cause for the failure.
        // The check parameter may be nil if convertibleTo is invoked through an
        // exported API call, i.e., when all methods have been type-checked.
    **/
    @:keep
    public dynamic function _convertibleTo(_check:stdgo.Ref<Checker>, t:Type_, _cause:stdgo.Pointer<stdgo.GoString>):Bool return __self__.value._convertibleTo(_check, t, _cause);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_operand>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_operand_asInterface) class T_operand_static_extension {
    /**
        // assignableTo reports whether x is assignable to a variable of type T. If the
        // result is false and a non-nil cause is provided, it may be set to a more
        // detailed explanation of the failure (result != ""). The returned error code
        // is only valid if the (first) result is false. The check parameter may be nil
        // if assignableTo is invoked through an exported API call, i.e., when all
        // methods have been type-checked.
    **/
    @:keep
    static public function _assignableTo( _x:stdgo.Ref<T_operand>, _check:stdgo.Ref<Checker>, t:Type_, _cause:stdgo.Pointer<stdgo.GoString>):{ var _0 : Bool; var _1 : Code; } {
        @:recv var _x:stdgo.Ref<T_operand> = _x;
        if ((_x._mode == (0 : stdgo.go.types.Types.T_operandMode)) || (stdgo.Go.toInterface(t) == stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])))) {
            return { _0 : true, _1 : (0 : stdgo.internal.types.errors.Errors.Code) };
        };
        var v:stdgo.go.types.Types.Type_ = _x._typ;
        if (identical(v, t)) {
            return { _0 : true, _1 : (0 : stdgo.internal.types.errors.Errors.Code) };
        };
        var vu:stdgo.go.types.Types.Type_ = _under(v);
        var tu:stdgo.go.types.Types.Type_ = _under(t);
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(v) : stdgo.Ref<TypeParam>)) : stdgo.Ref<TypeParam>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>), _1 : false };
        }, vp = __tmp__._0, __0 = __tmp__._1;
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(t) : stdgo.Ref<TypeParam>)) : stdgo.Ref<TypeParam>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>), _1 : false };
        }, tp = __tmp__._0, __1 = __tmp__._1;
        if (_isUntyped(vu)) {
            _assert(vp == null || (vp : Dynamic).__nil__);
            if (tp != null && ((tp : Dynamic).__nil__ == null || !(tp : Dynamic).__nil__)) {
                return { _0 : tp._is(function(_t:stdgo.Ref<T_term>):Bool {
                    if (_t == null || (_t : Dynamic).__nil__) {
                        return false;
                    };
                    var __tmp__ = _check._implicitTypeAndValue(_x, _t._typ), _newType:stdgo.go.types.Types.Type_ = __tmp__._0, __18:stdgo.go.constant.Constant.Value = __tmp__._1, __19:stdgo.internal.types.errors.Errors.Code = __tmp__._2;
                    return _newType != null;
                }), _1 : (23 : stdgo.internal.types.errors.Errors.Code) };
            };
            var __tmp__ = _check._implicitTypeAndValue(_x, t), _newType:stdgo.go.types.Types.Type_ = __tmp__._0, __18:stdgo.go.constant.Constant.Value = __tmp__._1, __19:stdgo.internal.types.errors.Errors.Code = __tmp__._2;
            return { _0 : _newType != null, _1 : (23 : stdgo.internal.types.errors.Errors.Code) };
        };
        if (((identical(vu, tu) && (!_hasName(v) || !_hasName(t))) && (vp == null) || (vp : Dynamic).__nil__) && (tp == null) || (tp : Dynamic).__nil__) {
            return { _0 : true, _1 : (0 : stdgo.internal.types.errors.Errors.Code) };
        };
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(tu) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Interface>), _1 : false };
            }, __20 = __tmp__._0, _ok = __tmp__._1;
            if ((_ok && (tp == null) || (tp : Dynamic).__nil__) || _isInterfacePtr(tu)) {
                if (_check._implements(_x.pos(), v, t, false, _cause)) {
                    return { _0 : true, _1 : (0 : stdgo.internal.types.errors.Errors.Code) };
                };
                if (vp == null || (vp : Dynamic).__nil__) {
                    return { _0 : false, _1 : (21 : stdgo.internal.types.errors.Errors.Code) };
                };
                if (_cause != null) {
                    _cause.value = stdgo.Go.str()?.__copy__();
                };
            };
        };
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(vu) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Interface>), _1 : false };
            }, vi = __tmp__._0, __29 = __tmp__._1;
            if (((vi != null) && ((vi : Dynamic).__nil__ == null || !(vi : Dynamic).__nil__)) && (vp == null) || (vp : Dynamic).__nil__) {
                if (_check._implements(_x.pos(), t, v, false, (null : stdgo.Pointer<stdgo.GoString>))) {
                    if (_cause != null) {
                        _cause.value = ("need type assertion" : stdgo.GoString);
                    };
                    return { _0 : false, _1 : (23 : stdgo.internal.types.errors.Errors.Code) };
                };
            };
        };
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(vu) : stdgo.Ref<Chan>)) : stdgo.Ref<Chan>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Chan>), _1 : false };
            }, vc = __tmp__._0, _ok = __tmp__._1;
            if (_ok && (vc._dir == (0 : stdgo.go.types.Types.ChanDir))) {
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(tu) : stdgo.Ref<Chan>)) : stdgo.Ref<Chan>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Chan>), _1 : false };
                    }, tc = __tmp__._0, _ok = __tmp__._1;
                    if (_ok && identical(vc._elem, tc._elem)) {
                        return { _0 : !_hasName(v) || !_hasName(t), _1 : (22 : stdgo.internal.types.errors.Errors.Code) };
                    };
                };
            };
        };
        if ((vp == null) || (vp : Dynamic).__nil__ && (tp == null) || (tp : Dynamic).__nil__) {
            return { _0 : false, _1 : (23 : stdgo.internal.types.errors.Errors.Code) };
        };
        var _errorf = function(_format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):Void {
            if (((_check != null) && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) && (_cause != null)) {
                var _msg:stdgo.GoString = _check._sprintf(_format?.__copy__(), ..._args.__toArray__())?.__copy__();
                if (_cause.value != (stdgo.Go.str())) {
                    _msg = _msg + (("\n\t" : stdgo.GoString) + _cause.value?.__copy__())?.__copy__();
                };
                _cause.value = _msg?.__copy__();
            };
        };
        if (!_hasName(v) && ((tp != null) && ((tp : Dynamic).__nil__ == null || !(tp : Dynamic).__nil__))) {
            var _ok:Bool = false;
            var _code:stdgo.internal.types.errors.Errors.Code = (23 : stdgo.internal.types.errors.Errors.Code);
            tp._is(function(t:stdgo.Ref<T_term>):Bool {
                if (t == null || (t : Dynamic).__nil__) {
                    return false;
                };
                {
                    var __tmp__ = _x._assignableTo(_check, t._typ, _cause);
                    _ok = __tmp__._0;
                    _code = __tmp__._1;
                };
                if (!_ok) {
                    _errorf(("cannot assign %s to %s (in %s)" : stdgo.GoString), stdgo.Go.toInterface(_x._typ), stdgo.Go.toInterface(t._typ), stdgo.Go.toInterface(stdgo.Go.asInterface(tp)));
                    return false;
                };
                return true;
            });
            return { _0 : _ok, _1 : _code };
        };
        if (((vp != null) && ((vp : Dynamic).__nil__ == null || !(vp : Dynamic).__nil__)) && !_hasName(t)) {
            var _x:stdgo.go.types.Types.T_operand = (_x : stdgo.go.types.Types.T_operand)?.__copy__();
            var _ok:Bool = false;
            var _code:stdgo.internal.types.errors.Errors.Code = (23 : stdgo.internal.types.errors.Errors.Code);
            vp._is(function(v:stdgo.Ref<T_term>):Bool {
                if (v == null || (v : Dynamic).__nil__) {
                    return false;
                };
                _x._typ = v._typ;
                {
                    var __tmp__ = _x._assignableTo(_check, t, _cause);
                    _ok = __tmp__._0;
                    _code = __tmp__._1;
                };
                if (!_ok) {
                    _errorf(("cannot assign %s (in %s) to %s" : stdgo.GoString), stdgo.Go.toInterface(v._typ), stdgo.Go.toInterface(stdgo.Go.asInterface(vp)), stdgo.Go.toInterface(t));
                    return false;
                };
                return true;
            });
            return { _0 : _ok, _1 : _code };
        };
        return { _0 : false, _1 : (23 : stdgo.internal.types.errors.Errors.Code) };
    }
    /**
        // isNil reports whether x is the (untyped) nil value.
    **/
    @:keep
    static public function _isNil( _x:stdgo.Ref<T_operand>):Bool {
        @:recv var _x:stdgo.Ref<T_operand> = _x;
        return (_x._mode == (7 : stdgo.go.types.Types.T_operandMode)) && (stdgo.Go.toInterface(_x._typ) == stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((25 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])));
    }
    /**
        // setConst sets x to the untyped constant for literal lit.
    **/
    @:keep
    static public function _setConst( _x:stdgo.Ref<T_operand>, _tok:stdgo.go.token.Token.Token, _lit:stdgo.GoString):Void {
        @:recv var _x:stdgo.Ref<T_operand> = _x;
        var _kind:BasicKind = ((0 : stdgo.GoInt) : stdgo.go.types.Types.BasicKind);
        {
            final __value__ = _tok;
            if (__value__ == ((5 : stdgo.go.token.Token.Token))) {
                _kind = (20 : stdgo.go.types.Types.BasicKind);
            } else if (__value__ == ((6 : stdgo.go.token.Token.Token))) {
                _kind = (22 : stdgo.go.types.Types.BasicKind);
            } else if (__value__ == ((7 : stdgo.go.token.Token.Token))) {
                _kind = (23 : stdgo.go.types.Types.BasicKind);
            } else if (__value__ == ((8 : stdgo.go.token.Token.Token))) {
                _kind = (21 : stdgo.go.types.Types.BasicKind);
            } else if (__value__ == ((9 : stdgo.go.token.Token.Token))) {
                _kind = (24 : stdgo.go.types.Types.BasicKind);
            } else {
                _unreachable();
            };
        };
        var _val:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.makeFromLiteral(_lit?.__copy__(), _tok, (0u32 : stdgo.GoUInt));
        if (_val.kind() == ((0 : stdgo.go.constant.Constant.Kind))) {
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            _x._typ = stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
            return;
        };
        _x._mode = (4 : stdgo.go.types.Types.T_operandMode);
        _x._typ = stdgo.Go.asInterface(typ[(_kind : stdgo.GoInt)]);
        _x._val = _val;
    }
    @:keep
    static public function string( _x:stdgo.Ref<T_operand>):stdgo.GoString {
        @:recv var _x:stdgo.Ref<T_operand> = _x;
        return _operandString(_x, null)?.__copy__();
    }
    /**
        // Pos returns the position of the expression corresponding to x.
        // If x is invalid the position is nopos.
    **/
    @:keep
    static public function pos( _x:stdgo.Ref<T_operand>):stdgo.go.token.Token.Pos {
        @:recv var _x:stdgo.Ref<T_operand> = _x;
        if (_x._expr == null) {
            return _nopos;
        };
        return _x._expr.pos();
    }
    /**
        // convertibleTo reports whether T(x) is valid. In the failure case, *cause
        // may be set to the cause for the failure.
        // The check parameter may be nil if convertibleTo is invoked through an
        // exported API call, i.e., when all methods have been type-checked.
    **/
    @:keep
    static public function _convertibleTo( _x:stdgo.Ref<T_operand>, _check:stdgo.Ref<Checker>, t:Type_, _cause:stdgo.Pointer<stdgo.GoString>):Bool {
        @:recv var _x:stdgo.Ref<T_operand> = _x;
        {
            var __tmp__ = _x._assignableTo(_check, t, _cause), _ok:Bool = __tmp__._0, __0:stdgo.internal.types.errors.Errors.Code = __tmp__._1;
            if (_ok) {
                return true;
            };
        };
        var v:stdgo.go.types.Types.Type_ = _x._typ;
        var vu:stdgo.go.types.Types.Type_ = _under(v);
        var tu:stdgo.go.types.Types.Type_ = _under(t);
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(v) : stdgo.Ref<TypeParam>)) : stdgo.Ref<TypeParam>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>), _1 : false };
        }, vp = __tmp__._0, __1 = __tmp__._1;
        var __tmp__ = try {
            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(t) : stdgo.Ref<TypeParam>)) : stdgo.Ref<TypeParam>), _1 : true };
        } catch(_) {
            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>), _1 : false };
        }, tp = __tmp__._0, __2 = __tmp__._1;
        if ((identicalIgnoreTags(vu, tu) && (vp == null) || (vp : Dynamic).__nil__) && (tp == null) || (tp : Dynamic).__nil__) {
            return true;
        };
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(v) : stdgo.Ref<Pointer_>)) : stdgo.Ref<Pointer_>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>), _1 : false };
            }, v = __tmp__._0, _ok = __tmp__._1;
            if (_ok) {
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(t) : stdgo.Ref<Pointer_>)) : stdgo.Ref<Pointer_>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>), _1 : false };
                    }, t = __tmp__._0, _ok = __tmp__._1;
                    if (_ok) {
                        if ((identicalIgnoreTags(_under(v._base), _under(t._base)) && !_isTypeParam(v._base)) && !_isTypeParam(t._base)) {
                            return true;
                        };
                    };
                };
            };
        };
        if (_isIntegerOrFloat(vu) && _isIntegerOrFloat(tu)) {
            return true;
        };
        if (_isComplex(vu) && _isComplex(tu)) {
            return true;
        };
        if ((_isInteger(vu) || _isBytesOrRunes(vu)) && _isString(tu)) {
            return true;
        };
        if (_isString(vu) && _isBytesOrRunes(tu)) {
            return true;
        };
        if ((_isPointer(vu) || _isUintptr(vu)) && _isUnsafePointer(tu)) {
            return true;
        };
        if (_isUnsafePointer(vu) && (_isPointer(tu) || _isUintptr(tu))) {
            return true;
        };
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(vu) : stdgo.Ref<Slice_>)) : stdgo.Ref<Slice_>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Slice_>), _1 : false };
            }, _s = __tmp__._0, __3 = __tmp__._1;
            if (_s != null && ((_s : Dynamic).__nil__ == null || !(_s : Dynamic).__nil__)) {
                {
                    final __type__ = tu;
                    if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Array_>))) {
                        var _a:stdgo.Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                        if (identical(_s.elem(), _a.elem())) {
                            if (((_check == null) || (_check : Dynamic).__nil__) || _check._allowVersion(_check._pkg, stdgo.Go.asInterface(_x), _go1_20?.__copy__())) {
                                return true;
                            };
                            if (_cause != null) {
                                _cause.value = ("conversion of slices to arrays requires go1.20 or later" : stdgo.GoString);
                            };
                            return false;
                        };
                    } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Pointer_>))) {
                        var _a:stdgo.Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                        {
                            var __tmp__ = try {
                                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_a.elem())) : stdgo.Ref<Array_>)) : stdgo.Ref<Array_>), _1 : true };
                            } catch(_) {
                                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Array_>), _1 : false };
                            }, _a = __tmp__._0, __20 = __tmp__._1;
                            if (_a != null && ((_a : Dynamic).__nil__ == null || !(_a : Dynamic).__nil__)) {
                                if (identical(_s.elem(), _a.elem())) {
                                    if (((_check == null) || (_check : Dynamic).__nil__) || _check._allowVersion(_check._pkg, stdgo.Go.asInterface(_x), _go1_17?.__copy__())) {
                                        return true;
                                    };
                                    if (_cause != null) {
                                        _cause.value = ("conversion of slices to array pointers requires go1.17 or later" : stdgo.GoString);
                                    };
                                    return false;
                                };
                            };
                        };
                    };
                };
            };
        };
        if ((vp == null) || (vp : Dynamic).__nil__ && (tp == null) || (tp : Dynamic).__nil__) {
            return false;
        };
        var _errorf = function(_format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):Void {
            if (((_check != null) && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) && (_cause != null)) {
                var _msg:stdgo.GoString = _check._sprintf(_format?.__copy__(), ..._args.__toArray__())?.__copy__();
                if (_cause.value != (stdgo.Go.str())) {
                    _msg = _msg + (("\n\t" : stdgo.GoString) + _cause.value?.__copy__())?.__copy__();
                };
                _cause.value = _msg?.__copy__();
            };
        };
        if (((vp != null) && ((vp : Dynamic).__nil__ == null || !(vp : Dynamic).__nil__)) && ((tp != null) && ((tp : Dynamic).__nil__ == null || !(tp : Dynamic).__nil__))) {
            var _x:stdgo.go.types.Types.T_operand = (_x : stdgo.go.types.Types.T_operand)?.__copy__();
            return vp._is(function(v:stdgo.Ref<T_term>):Bool {
                if (v == null || (v : Dynamic).__nil__) {
                    return false;
                };
                _x._typ = v._typ;
                return tp._is(function(t:stdgo.Ref<T_term>):Bool {
                    if (t == null || (t : Dynamic).__nil__) {
                        return false;
                    };
                    if (!_x._convertibleTo(_check, t._typ, _cause)) {
                        _errorf(("cannot convert %s (in %s) to type %s (in %s)" : stdgo.GoString), stdgo.Go.toInterface(v._typ), stdgo.Go.toInterface(stdgo.Go.asInterface(vp)), stdgo.Go.toInterface(t._typ), stdgo.Go.toInterface(stdgo.Go.asInterface(tp)));
                        return false;
                    };
                    return true;
                });
            });
        } else if (vp != null && ((vp : Dynamic).__nil__ == null || !(vp : Dynamic).__nil__)) {
            var _x:stdgo.go.types.Types.T_operand = (_x : stdgo.go.types.Types.T_operand)?.__copy__();
            return vp._is(function(v:stdgo.Ref<T_term>):Bool {
                if (v == null || (v : Dynamic).__nil__) {
                    return false;
                };
                _x._typ = v._typ;
                if (!_x._convertibleTo(_check, t, _cause)) {
                    _errorf(("cannot convert %s (in %s) to type %s" : stdgo.GoString), stdgo.Go.toInterface(v._typ), stdgo.Go.toInterface(stdgo.Go.asInterface(vp)), stdgo.Go.toInterface(t));
                    return false;
                };
                return true;
            });
        } else if (tp != null && ((tp : Dynamic).__nil__ == null || !(tp : Dynamic).__nil__)) {
            return tp._is(function(t:stdgo.Ref<T_term>):Bool {
                if (t == null || (t : Dynamic).__nil__) {
                    return false;
                };
                if (!_x._convertibleTo(_check, t._typ, _cause)) {
                    _errorf(("cannot convert %s to type %s (in %s)" : stdgo.GoString), stdgo.Go.toInterface(_x._typ), stdgo.Go.toInterface(t._typ), stdgo.Go.toInterface(stdgo.Go.asInterface(tp)));
                    return false;
                };
                return true;
            });
        };
        return false;
    }
}
class Package_asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    /**
        // SetImports sets the list of explicitly imported packages to list.
        // It is the caller's responsibility to make sure list elements are unique.
    **/
    @:keep
    public dynamic function setImports(_list:stdgo.Slice<stdgo.Ref<Package>>):Void __self__.value.setImports(_list);
    /**
        // Imports returns the list of packages directly imported by
        // pkg; the list is in source order.
        //
        // If pkg was loaded from export data, Imports includes packages that
        // provide package-level objects referenced by pkg. This may be more or
        // less than the set of packages directly imported by pkg's source code.
        //
        // If pkg uses cgo and the FakeImportC configuration option
        // was enabled, the imports list may contain a fake "C" package.
    **/
    @:keep
    public dynamic function imports():stdgo.Slice<stdgo.Ref<Package>> return __self__.value.imports();
    /**
        // MarkComplete marks a package as complete.
    **/
    @:keep
    public dynamic function markComplete():Void __self__.value.markComplete();
    /**
        // A package is complete if its scope contains (at least) all
        // exported objects; otherwise it is incomplete.
    **/
    @:keep
    public dynamic function complete():Bool return __self__.value.complete();
    /**
        // Scope returns the (complete or incomplete) package scope
        // holding the objects declared at package level (TypeNames,
        // Consts, Vars, and Funcs).
        // For a nil pkg receiver, Scope returns the Universe scope.
    **/
    @:keep
    public dynamic function scope():stdgo.Ref<Scope> return __self__.value.scope();
    /**
        // GoVersion returns the minimum Go version required by this package.
        // If the minimum version is unknown, GoVersion returns the empty string.
        // Individual source files may specify a different minimum Go version,
        // as reported in the [go/ast.File.GoVersion] field.
    **/
    @:keep
    public dynamic function goVersion():stdgo.GoString return __self__.value.goVersion();
    /**
        // SetName sets the package name.
    **/
    @:keep
    public dynamic function setName(_name:stdgo.GoString):Void __self__.value.setName(_name);
    /**
        // Name returns the package name.
    **/
    @:keep
    public dynamic function name():stdgo.GoString return __self__.value.name();
    /**
        // Path returns the package path.
    **/
    @:keep
    public dynamic function path():stdgo.GoString return __self__.value.path();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Package>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Package_asInterface) class Package_static_extension {
    @:keep
    static public function string( _pkg:stdgo.Ref<Package>):stdgo.GoString {
        @:recv var _pkg:stdgo.Ref<Package> = _pkg;
        return stdgo.fmt.Fmt.sprintf(("package %s (%q)" : stdgo.GoString), stdgo.Go.toInterface(_pkg._name), stdgo.Go.toInterface(_pkg._path))?.__copy__();
    }
    /**
        // SetImports sets the list of explicitly imported packages to list.
        // It is the caller's responsibility to make sure list elements are unique.
    **/
    @:keep
    static public function setImports( _pkg:stdgo.Ref<Package>, _list:stdgo.Slice<stdgo.Ref<Package>>):Void {
        @:recv var _pkg:stdgo.Ref<Package> = _pkg;
        _pkg._imports = _list;
    }
    /**
        // Imports returns the list of packages directly imported by
        // pkg; the list is in source order.
        //
        // If pkg was loaded from export data, Imports includes packages that
        // provide package-level objects referenced by pkg. This may be more or
        // less than the set of packages directly imported by pkg's source code.
        //
        // If pkg uses cgo and the FakeImportC configuration option
        // was enabled, the imports list may contain a fake "C" package.
    **/
    @:keep
    static public function imports( _pkg:stdgo.Ref<Package>):stdgo.Slice<stdgo.Ref<Package>> {
        @:recv var _pkg:stdgo.Ref<Package> = _pkg;
        return _pkg._imports;
    }
    /**
        // MarkComplete marks a package as complete.
    **/
    @:keep
    static public function markComplete( _pkg:stdgo.Ref<Package>):Void {
        @:recv var _pkg:stdgo.Ref<Package> = _pkg;
        _pkg._complete = true;
    }
    /**
        // A package is complete if its scope contains (at least) all
        // exported objects; otherwise it is incomplete.
    **/
    @:keep
    static public function complete( _pkg:stdgo.Ref<Package>):Bool {
        @:recv var _pkg:stdgo.Ref<Package> = _pkg;
        return _pkg._complete;
    }
    /**
        // Scope returns the (complete or incomplete) package scope
        // holding the objects declared at package level (TypeNames,
        // Consts, Vars, and Funcs).
        // For a nil pkg receiver, Scope returns the Universe scope.
    **/
    @:keep
    static public function scope( _pkg:stdgo.Ref<Package>):stdgo.Ref<Scope> {
        @:recv var _pkg:stdgo.Ref<Package> = _pkg;
        if (_pkg != null && ((_pkg : Dynamic).__nil__ == null || !(_pkg : Dynamic).__nil__)) {
            return _pkg._scope;
        };
        return universe;
    }
    /**
        // GoVersion returns the minimum Go version required by this package.
        // If the minimum version is unknown, GoVersion returns the empty string.
        // Individual source files may specify a different minimum Go version,
        // as reported in the [go/ast.File.GoVersion] field.
    **/
    @:keep
    static public function goVersion( _pkg:stdgo.Ref<Package>):stdgo.GoString {
        @:recv var _pkg:stdgo.Ref<Package> = _pkg;
        return _pkg._goVersion?.__copy__();
    }
    /**
        // SetName sets the package name.
    **/
    @:keep
    static public function setName( _pkg:stdgo.Ref<Package>, _name:stdgo.GoString):Void {
        @:recv var _pkg:stdgo.Ref<Package> = _pkg;
        _pkg._name = _name?.__copy__();
    }
    /**
        // Name returns the package name.
    **/
    @:keep
    static public function name( _pkg:stdgo.Ref<Package>):stdgo.GoString {
        @:recv var _pkg:stdgo.Ref<Package> = _pkg;
        return _pkg._name?.__copy__();
    }
    /**
        // Path returns the package path.
    **/
    @:keep
    static public function path( _pkg:stdgo.Ref<Package>):stdgo.GoString {
        @:recv var _pkg:stdgo.Ref<Package> = _pkg;
        return _pkg._path?.__copy__();
    }
}
class Pointer__asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type_ return __self__.value.underlying();
    /**
        // Elem returns the element type for the given pointer p.
    **/
    @:keep
    public dynamic function elem():Type_ return __self__.value.elem();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Pointer_>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Pointer__asInterface) class Pointer__static_extension {
    @:keep
    static public function string( _p:stdgo.Ref<Pointer_>):stdgo.GoString {
        @:recv var _p:stdgo.Ref<Pointer_> = _p;
        return typeString(stdgo.Go.asInterface(_p), null)?.__copy__();
    }
    @:keep
    static public function underlying( _p:stdgo.Ref<Pointer_>):Type_ {
        @:recv var _p:stdgo.Ref<Pointer_> = _p;
        return stdgo.Go.asInterface(_p);
    }
    /**
        // Elem returns the element type for the given pointer p.
    **/
    @:keep
    static public function elem( _p:stdgo.Ref<Pointer_>):Type_ {
        @:recv var _p:stdgo.Ref<Pointer_> = _p;
        return _p._base;
    }
}
class T_ifacePair_asInterface {
    @:keep
    public dynamic function _identical(_q:stdgo.Ref<T_ifacePair>):Bool return __self__.value._identical(_q);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_ifacePair>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_ifacePair_asInterface) class T_ifacePair_static_extension {
    @:keep
    static public function _identical( _p:stdgo.Ref<T_ifacePair>, _q:stdgo.Ref<T_ifacePair>):Bool {
        @:recv var _p:stdgo.Ref<T_ifacePair> = _p;
        return ((_p._x == _q._x) && (_p._y == _q._y)) || ((_p._x == _q._y) && (_p._y == _q._x));
    }
}
class T_comparer_asInterface {
    /**
        // For changes to this code the corresponding changes should be made to unifier.nify.
    **/
    @:keep
    public dynamic function _identical(_x:Type_, _y:Type_, _p:stdgo.Ref<T_ifacePair>):Bool return __self__.value._identical(_x, _y, _p);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_comparer>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_comparer_asInterface) class T_comparer_static_extension {
    /**
        // For changes to this code the corresponding changes should be made to unifier.nify.
    **/
    @:keep
    static public function _identical( _c:stdgo.Ref<T_comparer>, _x:Type_, _y:Type_, _p:stdgo.Ref<T_ifacePair>):Bool {
        @:recv var _c:stdgo.Ref<T_comparer> = _c;
        if (stdgo.Go.toInterface(_x) == (stdgo.Go.toInterface(_y))) {
            return true;
        };
        if (_c._ignoreInvalids && ((stdgo.Go.toInterface(_x) == stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]))) || (stdgo.Go.toInterface(_y) == stdgo.Go.toInterface(stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]))))) {
            return true;
        };
        {
            final __type__ = _x;
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                var _x:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Basic>)) : stdgo.Ref<Basic>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Basic>), _1 : false };
                    }, _y = __tmp__._0, _ok = __tmp__._1;
                    if (_ok) {
                        return _x._kind == (_y._kind);
                    };
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Array_>))) {
                var _x:stdgo.Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Array_>)) : stdgo.Ref<Array_>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Array_>), _1 : false };
                    }, _y = __tmp__._0, _ok = __tmp__._1;
                    if (_ok) {
                        return (((_x._len < (0i64 : stdgo.GoInt64)) || (_y._len < (0i64 : stdgo.GoInt64))) || (_x._len == _y._len)) && _c._identical(_x._elem, _y._elem, _p);
                    };
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Slice_>))) {
                var _x:stdgo.Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Slice_>)) : stdgo.Ref<Slice_>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Slice_>), _1 : false };
                    }, _y = __tmp__._0, _ok = __tmp__._1;
                    if (_ok) {
                        return _c._identical(_x._elem, _y._elem, _p);
                    };
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Struct>))) {
                var _x:stdgo.Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Struct>)) : stdgo.Ref<Struct>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Struct>), _1 : false };
                    }, _y = __tmp__._0, _ok = __tmp__._1;
                    if (_ok) {
                        if (_x.numFields() == (_y.numFields())) {
                            for (_i => _f in _x._fields) {
                                var _g = _y._fields[(_i : stdgo.GoInt)];
                                if ((((_f._embedded != _g._embedded) || (!_c._ignoreTags && (_x.tag(_i) != _y.tag(_i)))) || !_f._sameId(_g._object._pkg, _g._object._name?.__copy__())) || !_c._identical(_f._object._typ, _g._object._typ, _p)) {
                                    return false;
                                };
                            };
                            return true;
                        };
                    };
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Pointer_>))) {
                var _x:stdgo.Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Pointer_>)) : stdgo.Ref<Pointer_>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>), _1 : false };
                    }, _y = __tmp__._0, _ok = __tmp__._1;
                    if (_ok) {
                        return _c._identical(_x._base, _y._base, _p);
                    };
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Tuple>))) {
                var _x:stdgo.Ref<stdgo.go.types.Types.Tuple> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Tuple>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Tuple>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Tuple>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Tuple>)) : stdgo.Ref<Tuple>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Tuple>), _1 : false };
                    }, _y = __tmp__._0, _ok = __tmp__._1;
                    if (_ok) {
                        if (_x.len() == (_y.len())) {
                            if (_x != null && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) {
                                for (_i => _v in _x._vars) {
                                    var _w = _y._vars[(_i : stdgo.GoInt)];
                                    if (!_c._identical(_v._object._typ, _w._object._typ, _p)) {
                                        return false;
                                    };
                                };
                            };
                            return true;
                        };
                    };
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Signature>))) {
                var _x:stdgo.Ref<stdgo.go.types.Types.Signature> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__().value;
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Signature>), _1 : false };
                }, _y = __tmp__._0, __0 = __tmp__._1;
                if (_y == null || (_y : Dynamic).__nil__) {
                    return false;
                };
                if (_x.typeParams().len() != (_y.typeParams().len())) {
                    return false;
                };
                var _yparams = _y._params;
                var _yresults = _y._results;
                if (_x.typeParams().len() > (0 : stdgo.GoInt)) {
                    var _xtparams = _x.typeParams()._list();
                    var _ytparams = _y.typeParams()._list();
                    var _targs:stdgo.Slice<Type_> = (null : stdgo.Slice<stdgo.go.types.Types.Type_>);
                    for (_i => _ in _xtparams) {
                        _targs = (_targs.__append__(stdgo.Go.asInterface(_x.typeParams().at(_i))));
                    };
                    var _smap:stdgo.go.types.Types.T_substMap = _makeSubstMap(_ytparams, _targs);
                    var _check:stdgo.Ref<Checker> = (null : stdgo.Ref<stdgo.go.types.Types.Checker>);
                    var _ctxt = newContext();
                    for (_i => _xtparam in _xtparams) {
                        var _ybound:stdgo.go.types.Types.Type_ = _check._subst(_nopos, _ytparams[(_i : stdgo.GoInt)]._bound, _smap, null, _ctxt);
                        if (!_c._identical(_xtparam._bound, _ybound, _p)) {
                            return false;
                        };
                    };
                    _yparams = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_check._subst(_nopos, stdgo.Go.asInterface(_y._params), _smap, null, _ctxt)) : stdgo.Ref<Tuple>)) : stdgo.Ref<Tuple>);
                    _yresults = (stdgo.Go.typeAssert((stdgo.Go.toInterface(_check._subst(_nopos, stdgo.Go.asInterface(_y._results), _smap, null, _ctxt)) : stdgo.Ref<Tuple>)) : stdgo.Ref<Tuple>);
                };
                return ((_x._variadic == _y._variadic) && _c._identical(stdgo.Go.asInterface(_x._params), stdgo.Go.asInterface(_yparams), _p)) && _c._identical(stdgo.Go.asInterface(_x._results), stdgo.Go.asInterface(_yresults), _p);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Union>))) {
                var _x:stdgo.Ref<stdgo.go.types.Types.Union> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Union>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Union>)) : stdgo.Ref<Union>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Union>), _1 : false };
                    }, _y = __tmp__._0, __41 = __tmp__._1;
                    if (_y != null && ((_y : Dynamic).__nil__ == null || !(_y : Dynamic).__nil__)) {
                        var _unionSets = ({
                            final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.types.Types.Union>, stdgo.Ref<stdgo.go.types.Types.T__TypeSet>>();
                            @:mergeBlock {};
                            cast x;
                        } : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.Union>, stdgo.Ref<stdgo.go.types.Types.T__TypeSet>>);
                        var _xset = _computeUnionTypeSet(null, _unionSets, _nopos, _x);
                        var _yset = _computeUnionTypeSet(null, _unionSets, _nopos, _y);
                        return _xset._terms._equal(_yset._terms);
                    };
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                var _x:stdgo.Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Interface>), _1 : false };
                    }, _y = __tmp__._0, _ok = __tmp__._1;
                    if (_ok) {
                        var _xset = _x._typeSet();
                        var _yset = _y._typeSet();
                        if (_xset._comparable != (_yset._comparable)) {
                            return false;
                        };
                        if (!_xset._terms._equal(_yset._terms)) {
                            return false;
                        };
                        var _a = _xset._methods;
                        var _b = _yset._methods;
                        if ((_a.length) == ((_b.length))) {
                            var _q = (stdgo.Go.setRef((new stdgo.go.types.Types.T_ifacePair(_x, _y, _p) : stdgo.go.types.Types.T_ifacePair)) : stdgo.Ref<stdgo.go.types.Types.T_ifacePair>);
                            while (_p != null && ((_p : Dynamic).__nil__ == null || !(_p : Dynamic).__nil__)) {
                                if (_p._identical(_q)) {
                                    return true;
                                };
                                _p = _p._prev;
                            };
                            if (false) {
                                _assertSortedMethods(_a);
                                _assertSortedMethods(_b);
                            };
                            for (_i => _f in _a) {
                                var _g = _b[(_i : stdgo.GoInt)];
                                if ((_f.id() != _g.id()) || !_c._identical(_f._object._typ, _g._object._typ, _q)) {
                                    return false;
                                };
                            };
                            return true;
                        };
                    };
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Map_>))) {
                var _x:stdgo.Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Map_>)) : stdgo.Ref<Map_>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Map_>), _1 : false };
                    }, _y = __tmp__._0, _ok = __tmp__._1;
                    if (_ok) {
                        return _c._identical(_x._key, _y._key, _p) && _c._identical(_x._elem, _y._elem, _p);
                    };
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Chan>))) {
                var _x:stdgo.Ref<stdgo.go.types.Types.Chan> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Chan>)) : stdgo.Ref<Chan>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Chan>), _1 : false };
                    }, _y = __tmp__._0, _ok = __tmp__._1;
                    if (_ok) {
                        return (_x._dir == _y._dir) && _c._identical(_x._elem, _y._elem, _p);
                    };
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Named>))) {
                var _x:stdgo.Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
                    } catch(_) {
                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
                    }, _y = __tmp__._0, _ok = __tmp__._1;
                    if (_ok) {
                        var _xargs = _x.typeArgs()._list();
                        var _yargs = _y.typeArgs()._list();
                        if ((_xargs.length) != ((_yargs.length))) {
                            return false;
                        };
                        for (_i => _xarg in _xargs) {
                            if (!identical(_xarg, _yargs[(_i : stdgo.GoInt)])) {
                                return false;
                            };
                        };
                        return _indenticalOrigin(_x, _y);
                    };
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeParam>))) {
                var _x:stdgo.Ref<stdgo.go.types.Types.TypeParam> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__().value;
            } else if (__type__ == null) {
                var _x:stdgo.AnyInterface = __type__ == null ? (null : stdgo.AnyInterface) : cast __type__;
            } else {
                var _x:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                _unreachable();
            };
        };
        return false;
    }
}
class T_declInfo_asInterface {
    /**
        // addDep adds obj to the set of objects d's init expression depends on.
    **/
    @:keep
    public dynamic function _addDep(_obj:Object):Void __self__.value._addDep(_obj);
    /**
        // hasInitializer reports whether the declared object has an initialization
        // expression or function body.
    **/
    @:keep
    public dynamic function _hasInitializer():Bool return __self__.value._hasInitializer();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_declInfo>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_declInfo_asInterface) class T_declInfo_static_extension {
    /**
        // addDep adds obj to the set of objects d's init expression depends on.
    **/
    @:keep
    static public function _addDep( _d:stdgo.Ref<T_declInfo>, _obj:Object):Void {
        @:recv var _d:stdgo.Ref<T_declInfo> = _d;
        var _m = _d._deps;
        if (_m == null) {
            _m = ({
                final x = new stdgo.GoMap.GoObjectMap<stdgo.go.types.Types.Object, Bool>();
                x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Object", [], stdgo.internal.reflect.Reflect.GoType.named("Object", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
                x.__defaultValue__ = () -> false;
                @:mergeBlock {};
                cast x;
            } : stdgo.GoMap<stdgo.go.types.Types.Object, Bool>);
            _d._deps = _m;
        };
        _m[_obj] = true;
    }
    /**
        // hasInitializer reports whether the declared object has an initialization
        // expression or function body.
    **/
    @:keep
    static public function _hasInitializer( _d:stdgo.Ref<T_declInfo>):Bool {
        @:recv var _d:stdgo.Ref<T_declInfo> = _d;
        return (_d._init != null) || (((_d._fdecl != null) && ((_d._fdecl : Dynamic).__nil__ == null || !(_d._fdecl : Dynamic).__nil__)) && ((_d._fdecl.body != null) && ((_d._fdecl.body : Dynamic).__nil__ == null || !(_d._fdecl.body : Dynamic).__nil__)));
    }
}
class Scope_asInterface {
    /**
        // String returns a string representation of the scope, for debugging.
    **/
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    /**
        // WriteTo writes a string representation of the scope to w,
        // with the scope elements sorted by name.
        // The level of indentation is controlled by n >= 0, with
        // n == 0 for no indentation.
        // If recurse is set, it also writes nested (children) scopes.
    **/
    @:keep
    public dynamic function writeTo(_w:stdgo.io.Io.Writer, _n:stdgo.GoInt, _recurse:Bool):Void __self__.value.writeTo(_w, _n, _recurse);
    /**
        // Innermost returns the innermost (child) scope containing
        // pos. If pos is not within any scope, the result is nil.
        // The result is also nil for the Universe scope.
        // The result is guaranteed to be valid only if the type-checked
        // AST has complete position information.
    **/
    @:keep
    public dynamic function innermost(_pos:stdgo.go.token.Token.Pos):stdgo.Ref<Scope> return __self__.value.innermost(_pos);
    /**
        // Contains reports whether pos is within the scope's extent.
        // The result is guaranteed to be valid only if the type-checked
        // AST has complete position information.
    **/
    @:keep
    public dynamic function contains(_pos:stdgo.go.token.Token.Pos):Bool return __self__.value.contains(_pos);
    @:keep
    public dynamic function end():stdgo.go.token.Token.Pos return __self__.value.end();
    /**
        // Pos and End describe the scope's source code extent [pos, end).
        // The results are guaranteed to be valid only if the type-checked
        // AST has complete position information. The extent is undefined
        // for Universe and package scopes.
    **/
    @:keep
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    /**
        // Squash merges s with its parent scope p by adding all
        // objects of s to p, adding all children of s to the
        // children of p, and removing s from p's children.
        // The function f is called for each object obj in s which
        // has an object alt in p. s should be discarded after
        // having been squashed.
    **/
    @:keep
    public dynamic function _squash(_err:(_obj:Object, _alt:Object) -> Void):Void __self__.value._squash(_err);
    @:keep
    public dynamic function _insert(_name:stdgo.GoString, _obj:Object):Void __self__.value._insert(_name, _obj);
    /**
        // InsertLazy is like Insert, but allows deferring construction of the
        // inserted object until it's accessed with Lookup. The Object
        // returned by resolve must have the same name as given to InsertLazy.
        // If s already contains an alternative object with the same name,
        // InsertLazy leaves s unchanged and returns false. Otherwise it
        // records the binding and returns true. The object's parent scope
        // will be set to s after resolve is called.
    **/
    @:keep
    public dynamic function __InsertLazy(_name:stdgo.GoString, _resolve:() -> Object):Bool return __self__.value.__InsertLazy(_name, _resolve);
    /**
        // Insert attempts to insert an object obj into scope s.
        // If s already contains an alternative object alt with
        // the same name, Insert leaves s unchanged and returns alt.
        // Otherwise it inserts obj, sets the object's parent scope
        // if not already set, and returns nil.
    **/
    @:keep
    public dynamic function insert(_obj:Object):Object return __self__.value.insert(_obj);
    /**
        // LookupParent follows the parent chain of scopes starting with s until
        // it finds a scope where Lookup(name) returns a non-nil object, and then
        // returns that scope and object. If a valid position pos is provided,
        // only objects that were declared at or before pos are considered.
        // If no such scope and object exists, the result is (nil, nil).
        //
        // Note that obj.Parent() may be different from the returned scope if the
        // object was inserted into the scope and already had a parent at that
        // time (see Insert). This can only happen for dot-imported objects
        // whose scope is the scope of the package that exported them.
    **/
    @:keep
    public dynamic function lookupParent(_name:stdgo.GoString, _pos:stdgo.go.token.Token.Pos):{ var _0 : stdgo.Ref<Scope>; var _1 : Object; } return __self__.value.lookupParent(_name, _pos);
    /**
        // Lookup returns the object in scope s with the given name if such an
        // object exists; otherwise the result is nil.
    **/
    @:keep
    public dynamic function lookup(_name:stdgo.GoString):Object return __self__.value.lookup(_name);
    /**
        // Child returns the i'th child scope for 0 <= i < NumChildren().
    **/
    @:keep
    public dynamic function child(_i:stdgo.GoInt):stdgo.Ref<Scope> return __self__.value.child(_i);
    /**
        // NumChildren returns the number of scopes nested in s.
    **/
    @:keep
    public dynamic function numChildren():stdgo.GoInt return __self__.value.numChildren();
    /**
        // Names returns the scope's element names in sorted order.
    **/
    @:keep
    public dynamic function names():stdgo.Slice<stdgo.GoString> return __self__.value.names();
    /**
        // Len returns the number of scope elements.
    **/
    @:keep
    public dynamic function len():stdgo.GoInt return __self__.value.len();
    /**
        // Parent returns the scope's containing (parent) scope.
    **/
    @:keep
    public dynamic function parent():stdgo.Ref<Scope> return __self__.value.parent();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Scope>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Scope_asInterface) class Scope_static_extension {
    /**
        // String returns a string representation of the scope, for debugging.
    **/
    @:keep
    static public function string( _s:stdgo.Ref<Scope>):stdgo.GoString {
        @:recv var _s:stdgo.Ref<Scope> = _s;
        var _buf:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
        _s.writeTo(stdgo.Go.asInterface((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.strings.Strings.Builder>)), (0 : stdgo.GoInt), false);
        return (_buf.string() : stdgo.GoString)?.__copy__();
    }
    /**
        // WriteTo writes a string representation of the scope to w,
        // with the scope elements sorted by name.
        // The level of indentation is controlled by n >= 0, with
        // n == 0 for no indentation.
        // If recurse is set, it also writes nested (children) scopes.
    **/
    @:keep
    static public function writeTo( _s:stdgo.Ref<Scope>, _w:stdgo.io.Io.Writer, _n:stdgo.GoInt, _recurse:Bool):Void {
        @:recv var _s:stdgo.Ref<Scope> = _s;
        {};
        var _indn:stdgo.GoString = stdgo.strings.Strings.repeat((".  " : stdgo.GoString), _n)?.__copy__();
        stdgo.fmt.Fmt.fprintf(_w, ("%s%s scope %p {\n" : stdgo.GoString), stdgo.Go.toInterface(_indn), stdgo.Go.toInterface(_s._comment), stdgo.Go.toInterface(stdgo.Go.asInterface(_s)));
        var _indn1:stdgo.GoString = _indn + (".  " : stdgo.GoString)?.__copy__()?.__copy__();
        for (__0 => _name in _s.names()) {
            stdgo.fmt.Fmt.fprintf(_w, ("%s%s\n" : stdgo.GoString), stdgo.Go.toInterface(_indn1), stdgo.Go.toInterface(_s.lookup(_name?.__copy__())));
        };
        if (_recurse) {
            for (__1 => _s in _s._children) {
                _s.writeTo(_w, _n + (1 : stdgo.GoInt), _recurse);
            };
        };
        stdgo.fmt.Fmt.fprintf(_w, ("%s}\n" : stdgo.GoString), stdgo.Go.toInterface(_indn));
    }
    /**
        // Innermost returns the innermost (child) scope containing
        // pos. If pos is not within any scope, the result is nil.
        // The result is also nil for the Universe scope.
        // The result is guaranteed to be valid only if the type-checked
        // AST has complete position information.
    **/
    @:keep
    static public function innermost( _s:stdgo.Ref<Scope>, _pos:stdgo.go.token.Token.Pos):stdgo.Ref<Scope> {
        @:recv var _s:stdgo.Ref<Scope> = _s;
        if (_s._parent == (universe)) {
            for (__0 => _s in _s._children) {
                {
                    var _inner = _s.innermost(_pos);
                    if (_inner != null && ((_inner : Dynamic).__nil__ == null || !(_inner : Dynamic).__nil__)) {
                        return _inner;
                    };
                };
            };
        };
        if (_s.contains(_pos)) {
            for (__1 => _s in _s._children) {
                if (_s.contains(_pos)) {
                    return _s.innermost(_pos);
                };
            };
            return _s;
        };
        return null;
    }
    /**
        // Contains reports whether pos is within the scope's extent.
        // The result is guaranteed to be valid only if the type-checked
        // AST has complete position information.
    **/
    @:keep
    static public function contains( _s:stdgo.Ref<Scope>, _pos:stdgo.go.token.Token.Pos):Bool {
        @:recv var _s:stdgo.Ref<Scope> = _s;
        return (_cmpPos(_s._pos, _pos) <= (0 : stdgo.GoInt)) && (_cmpPos(_pos, _s._end) < (0 : stdgo.GoInt));
    }
    @:keep
    static public function end( _s:stdgo.Ref<Scope>):stdgo.go.token.Token.Pos {
        @:recv var _s:stdgo.Ref<Scope> = _s;
        return _s._end;
    }
    /**
        // Pos and End describe the scope's source code extent [pos, end).
        // The results are guaranteed to be valid only if the type-checked
        // AST has complete position information. The extent is undefined
        // for Universe and package scopes.
    **/
    @:keep
    static public function pos( _s:stdgo.Ref<Scope>):stdgo.go.token.Token.Pos {
        @:recv var _s:stdgo.Ref<Scope> = _s;
        return _s._pos;
    }
    /**
        // Squash merges s with its parent scope p by adding all
        // objects of s to p, adding all children of s to the
        // children of p, and removing s from p's children.
        // The function f is called for each object obj in s which
        // has an object alt in p. s should be discarded after
        // having been squashed.
    **/
    @:keep
    static public function _squash( _s:stdgo.Ref<Scope>, _err:(_obj:Object, _alt:Object) -> Void):Void {
        @:recv var _s:stdgo.Ref<Scope> = _s;
        var _p = _s._parent;
        _assert(_p != null && ((_p : Dynamic).__nil__ == null || !(_p : Dynamic).__nil__));
        for (_name => _obj in _s._elems) {
            _obj = _resolve(_name?.__copy__(), _obj);
            _obj._setParent(null);
            {
                var _alt:stdgo.go.types.Types.Object = _p.insert(_obj);
                if (_alt != null) {
                    _err(_obj, _alt);
                };
            };
        };
        var _j:stdgo.GoInt = (-1 : stdgo.GoInt);
        for (_i => _ch in _p._children) {
            if (_ch == (_s)) {
                _j = _i;
                break;
            };
        };
        _assert(_j >= (0 : stdgo.GoInt));
        var _k:stdgo.GoInt = (_p._children.length) - (1 : stdgo.GoInt);
        _p._children[(_j : stdgo.GoInt)] = _p._children[(_k : stdgo.GoInt)];
        _p._children = (_p._children.__slice__(0, _k) : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Scope>>);
        _p._children = (_p._children.__append__(..._s._children.__toArray__()));
        _s._children = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Scope>>);
        _s._elems = (null : stdgo.GoMap<stdgo.GoString, stdgo.go.types.Types.Object>);
    }
    @:keep
    static public function _insert( _s:stdgo.Ref<Scope>, _name:stdgo.GoString, _obj:Object):Void {
        @:recv var _s:stdgo.Ref<Scope> = _s;
        if (_s._elems == null) {
            _s._elems = ({
                final x = new stdgo.GoMap.GoStringMap<stdgo.go.types.Types.Object>();
                x.__defaultValue__ = () -> (null : stdgo.go.types.Types.Object);
                @:mergeBlock {};
                x;
            } : stdgo.GoMap<stdgo.GoString, stdgo.go.types.Types.Object>);
        };
        _s._elems[_name] = _obj;
    }
    /**
        // InsertLazy is like Insert, but allows deferring construction of the
        // inserted object until it's accessed with Lookup. The Object
        // returned by resolve must have the same name as given to InsertLazy.
        // If s already contains an alternative object with the same name,
        // InsertLazy leaves s unchanged and returns false. Otherwise it
        // records the binding and returns true. The object's parent scope
        // will be set to s after resolve is called.
    **/
    @:keep
    static public function __InsertLazy( _s:stdgo.Ref<Scope>, _name:stdgo.GoString, _resolve:() -> Object):Bool {
        @:recv var _s:stdgo.Ref<Scope> = _s;
        if ((_s._elems[_name] ?? (null : stdgo.go.types.Types.Object)) != null) {
            return false;
        };
        _s._insert(_name?.__copy__(), stdgo.Go.asInterface((stdgo.Go.setRef(({ _parent : _s, _resolve : _resolve } : stdgo.go.types.Types.T_lazyObject)) : stdgo.Ref<stdgo.go.types.Types.T_lazyObject>)));
        return true;
    }
    /**
        // Insert attempts to insert an object obj into scope s.
        // If s already contains an alternative object alt with
        // the same name, Insert leaves s unchanged and returns alt.
        // Otherwise it inserts obj, sets the object's parent scope
        // if not already set, and returns nil.
    **/
    @:keep
    static public function insert( _s:stdgo.Ref<Scope>, _obj:Object):Object {
        @:recv var _s:stdgo.Ref<Scope> = _s;
        var _name:stdgo.GoString = _obj.name()?.__copy__();
        {
            var _alt:stdgo.go.types.Types.Object = _s.lookup(_name?.__copy__());
            if (_alt != null) {
                return _alt;
            };
        };
        _s._insert(_name?.__copy__(), _obj);
        if (_obj.parent() == null || (_obj.parent() : Dynamic).__nil__) {
            _obj._setParent(_s);
        };
        return (null : stdgo.go.types.Types.Object);
    }
    /**
        // LookupParent follows the parent chain of scopes starting with s until
        // it finds a scope where Lookup(name) returns a non-nil object, and then
        // returns that scope and object. If a valid position pos is provided,
        // only objects that were declared at or before pos are considered.
        // If no such scope and object exists, the result is (nil, nil).
        //
        // Note that obj.Parent() may be different from the returned scope if the
        // object was inserted into the scope and already had a parent at that
        // time (see Insert). This can only happen for dot-imported objects
        // whose scope is the scope of the package that exported them.
    **/
    @:keep
    static public function lookupParent( _s:stdgo.Ref<Scope>, _name:stdgo.GoString, _pos:stdgo.go.token.Token.Pos):{ var _0 : stdgo.Ref<Scope>; var _1 : Object; } {
        @:recv var _s:stdgo.Ref<Scope> = _s;
        stdgo.Go.cfor(_s != null && ((_s : Dynamic).__nil__ == null || !(_s : Dynamic).__nil__), _s = _s._parent, {
            {
                var _obj:stdgo.go.types.Types.Object = _s.lookup(_name?.__copy__());
                if ((_obj != null) && (!_pos.isValid() || (_cmpPos(_obj._scopePos(), _pos) <= (0 : stdgo.GoInt)))) {
                    return { _0 : _s, _1 : _obj };
                };
            };
        });
        return { _0 : null, _1 : (null : stdgo.go.types.Types.Object) };
    }
    /**
        // Lookup returns the object in scope s with the given name if such an
        // object exists; otherwise the result is nil.
    **/
    @:keep
    static public function lookup( _s:stdgo.Ref<Scope>, _name:stdgo.GoString):Object {
        @:recv var _s:stdgo.Ref<Scope> = _s;
        return _resolve(_name?.__copy__(), (_s._elems[_name] ?? (null : stdgo.go.types.Types.Object)));
    }
    /**
        // Child returns the i'th child scope for 0 <= i < NumChildren().
    **/
    @:keep
    static public function child( _s:stdgo.Ref<Scope>, _i:stdgo.GoInt):stdgo.Ref<Scope> {
        @:recv var _s:stdgo.Ref<Scope> = _s;
        return _s._children[(_i : stdgo.GoInt)];
    }
    /**
        // NumChildren returns the number of scopes nested in s.
    **/
    @:keep
    static public function numChildren( _s:stdgo.Ref<Scope>):stdgo.GoInt {
        @:recv var _s:stdgo.Ref<Scope> = _s;
        return (_s._children.length);
    }
    /**
        // Names returns the scope's element names in sorted order.
    **/
    @:keep
    static public function names( _s:stdgo.Ref<Scope>):stdgo.Slice<stdgo.GoString> {
        @:recv var _s:stdgo.Ref<Scope> = _s;
        var _names = new stdgo.Slice<stdgo.GoString>((_s._elems.length : stdgo.GoInt).toBasic(), 0).__setString__();
        var _i:stdgo.GoInt = (0 : stdgo.GoInt);
        for (_name => _ in _s._elems) {
            _names[(_i : stdgo.GoInt)] = _name?.__copy__();
            _i++;
        };
        stdgo.sort.Sort.strings(_names);
        return _names;
    }
    /**
        // Len returns the number of scope elements.
    **/
    @:keep
    static public function len( _s:stdgo.Ref<Scope>):stdgo.GoInt {
        @:recv var _s:stdgo.Ref<Scope> = _s;
        return (_s._elems.length);
    }
    /**
        // Parent returns the scope's containing (parent) scope.
    **/
    @:keep
    static public function parent( _s:stdgo.Ref<Scope>):stdgo.Ref<Scope> {
        @:recv var _s:stdgo.Ref<Scope> = _s;
        return _s._parent;
    }
}
class T_lazyObject_asInterface {
    @:keep
    public dynamic function _setScopePos(_pos:stdgo.go.token.Token.Pos):Void __self__.value._setScopePos(_pos);
    @:keep
    public dynamic function _scopePos():stdgo.go.token.Token.Pos return __self__.value._scopePos();
    @:keep
    public dynamic function _sameId(_pkg:stdgo.Ref<Package>, _name:stdgo.GoString):Bool return __self__.value._sameId(_pkg, _name);
    @:keep
    public dynamic function _setParent(_0:stdgo.Ref<Scope>):Void __self__.value._setParent(_0);
    @:keep
    public dynamic function _setColor(_color:T_color):Void __self__.value._setColor(_color);
    @:keep
    public dynamic function _setOrder(_0:stdgo.GoUInt32):Void __self__.value._setOrder(_0);
    @:keep
    public dynamic function _setType(_0:Type_):Void __self__.value._setType(_0);
    @:keep
    public dynamic function _color():T_color return __self__.value._color();
    @:keep
    public dynamic function _order():stdgo.GoUInt32 return __self__.value._order();
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:keep
    public dynamic function id():stdgo.GoString return __self__.value.id();
    @:keep
    public dynamic function exported():Bool return __self__.value.exported();
    @:keep
    public dynamic function type():Type_ return __self__.value.type();
    @:keep
    public dynamic function name():stdgo.GoString return __self__.value.name();
    @:keep
    public dynamic function pkg():stdgo.Ref<Package> return __self__.value.pkg();
    @:keep
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    /**
        // stub implementations so *lazyObject implements Object and we can
        // store them directly into Scope.elems.
    **/
    @:keep
    public dynamic function parent():stdgo.Ref<Scope> return __self__.value.parent();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_lazyObject>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_lazyObject_asInterface) class T_lazyObject_static_extension {
    @:keep
    static public function _setScopePos( _:stdgo.Ref<T_lazyObject>, _pos:stdgo.go.token.Token.Pos):Void {
        @:recv var _:stdgo.Ref<T_lazyObject> = _;
        throw stdgo.Go.toInterface(("unreachable" : stdgo.GoString));
    }
    @:keep
    static public function _scopePos( _:stdgo.Ref<T_lazyObject>):stdgo.go.token.Token.Pos {
        @:recv var _:stdgo.Ref<T_lazyObject> = _;
        throw stdgo.Go.toInterface(("unreachable" : stdgo.GoString));
    }
    @:keep
    static public function _sameId( _:stdgo.Ref<T_lazyObject>, _pkg:stdgo.Ref<Package>, _name:stdgo.GoString):Bool {
        @:recv var _:stdgo.Ref<T_lazyObject> = _;
        throw stdgo.Go.toInterface(("unreachable" : stdgo.GoString));
    }
    @:keep
    static public function _setParent( _:stdgo.Ref<T_lazyObject>, _0:stdgo.Ref<Scope>):Void {
        @:recv var _:stdgo.Ref<T_lazyObject> = _;
        throw stdgo.Go.toInterface(("unreachable" : stdgo.GoString));
    }
    @:keep
    static public function _setColor( _:stdgo.Ref<T_lazyObject>, _color:T_color):Void {
        @:recv var _:stdgo.Ref<T_lazyObject> = _;
        throw stdgo.Go.toInterface(("unreachable" : stdgo.GoString));
    }
    @:keep
    static public function _setOrder( _:stdgo.Ref<T_lazyObject>, _0:stdgo.GoUInt32):Void {
        @:recv var _:stdgo.Ref<T_lazyObject> = _;
        throw stdgo.Go.toInterface(("unreachable" : stdgo.GoString));
    }
    @:keep
    static public function _setType( _:stdgo.Ref<T_lazyObject>, _0:Type_):Void {
        @:recv var _:stdgo.Ref<T_lazyObject> = _;
        throw stdgo.Go.toInterface(("unreachable" : stdgo.GoString));
    }
    @:keep
    static public function _color( _:stdgo.Ref<T_lazyObject>):T_color {
        @:recv var _:stdgo.Ref<T_lazyObject> = _;
        throw stdgo.Go.toInterface(("unreachable" : stdgo.GoString));
    }
    @:keep
    static public function _order( _:stdgo.Ref<T_lazyObject>):stdgo.GoUInt32 {
        @:recv var _:stdgo.Ref<T_lazyObject> = _;
        throw stdgo.Go.toInterface(("unreachable" : stdgo.GoString));
    }
    @:keep
    static public function string( _:stdgo.Ref<T_lazyObject>):stdgo.GoString {
        @:recv var _:stdgo.Ref<T_lazyObject> = _;
        throw stdgo.Go.toInterface(("unreachable" : stdgo.GoString));
    }
    @:keep
    static public function id( _:stdgo.Ref<T_lazyObject>):stdgo.GoString {
        @:recv var _:stdgo.Ref<T_lazyObject> = _;
        throw stdgo.Go.toInterface(("unreachable" : stdgo.GoString));
    }
    @:keep
    static public function exported( _:stdgo.Ref<T_lazyObject>):Bool {
        @:recv var _:stdgo.Ref<T_lazyObject> = _;
        throw stdgo.Go.toInterface(("unreachable" : stdgo.GoString));
    }
    @:keep
    static public function type( _:stdgo.Ref<T_lazyObject>):Type_ {
        @:recv var _:stdgo.Ref<T_lazyObject> = _;
        throw stdgo.Go.toInterface(("unreachable" : stdgo.GoString));
    }
    @:keep
    static public function name( _:stdgo.Ref<T_lazyObject>):stdgo.GoString {
        @:recv var _:stdgo.Ref<T_lazyObject> = _;
        throw stdgo.Go.toInterface(("unreachable" : stdgo.GoString));
    }
    @:keep
    static public function pkg( _:stdgo.Ref<T_lazyObject>):stdgo.Ref<Package> {
        @:recv var _:stdgo.Ref<T_lazyObject> = _;
        throw stdgo.Go.toInterface(("unreachable" : stdgo.GoString));
    }
    @:keep
    static public function pos( _:stdgo.Ref<T_lazyObject>):stdgo.go.token.Token.Pos {
        @:recv var _:stdgo.Ref<T_lazyObject> = _;
        throw stdgo.Go.toInterface(("unreachable" : stdgo.GoString));
    }
    /**
        // stub implementations so *lazyObject implements Object and we can
        // store them directly into Scope.elems.
    **/
    @:keep
    static public function parent( _:stdgo.Ref<T_lazyObject>):stdgo.Ref<Scope> {
        @:recv var _:stdgo.Ref<T_lazyObject> = _;
        throw stdgo.Go.toInterface(("unreachable" : stdgo.GoString));
    }
}
class Selection_asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    /**
        // Indirect reports whether any pointer indirection was required to get from
        // x to f in x.f.
    **/
    @:keep
    public dynamic function indirect():Bool return __self__.value.indirect();
    /**
        // Index describes the path from x to f in x.f.
        // The last index entry is the field or method index of the type declaring f;
        // either:
        //
        //  1. the list of declared methods of a named type; or
        //  2. the list of methods of an interface type; or
        //  3. the list of fields of a struct type.
        //
        // The earlier index entries are the indices of the embedded fields implicitly
        // traversed to get from (the type of) x to f, starting at embedding depth 0.
    **/
    @:keep
    public dynamic function index():stdgo.Slice<stdgo.GoInt> return __self__.value.index();
    /**
        // Type returns the type of x.f, which may be different from the type of f.
        // See Selection for more information.
    **/
    @:keep
    public dynamic function type():Type_ return __self__.value.type();
    /**
        // Obj returns the object denoted by x.f; a *Var for
        // a field selection, and a *Func in all other cases.
    **/
    @:keep
    public dynamic function obj():Object return __self__.value.obj();
    /**
        // Recv returns the type of x in x.f.
    **/
    @:keep
    public dynamic function recv():Type_ return __self__.value.recv();
    /**
        // Kind returns the selection kind.
    **/
    @:keep
    public dynamic function kind():SelectionKind return __self__.value.kind();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Selection>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Selection_asInterface) class Selection_static_extension {
    @:keep
    static public function string( _s:stdgo.Ref<Selection>):stdgo.GoString {
        @:recv var _s:stdgo.Ref<Selection> = _s;
        return selectionString(_s, null)?.__copy__();
    }
    /**
        // Indirect reports whether any pointer indirection was required to get from
        // x to f in x.f.
    **/
    @:keep
    static public function indirect( _s:stdgo.Ref<Selection>):Bool {
        @:recv var _s:stdgo.Ref<Selection> = _s;
        return _s._indirect;
    }
    /**
        // Index describes the path from x to f in x.f.
        // The last index entry is the field or method index of the type declaring f;
        // either:
        //
        //  1. the list of declared methods of a named type; or
        //  2. the list of methods of an interface type; or
        //  3. the list of fields of a struct type.
        //
        // The earlier index entries are the indices of the embedded fields implicitly
        // traversed to get from (the type of) x to f, starting at embedding depth 0.
    **/
    @:keep
    static public function index( _s:stdgo.Ref<Selection>):stdgo.Slice<stdgo.GoInt> {
        @:recv var _s:stdgo.Ref<Selection> = _s;
        return _s._index;
    }
    /**
        // Type returns the type of x.f, which may be different from the type of f.
        // See Selection for more information.
    **/
    @:keep
    static public function type( _s:stdgo.Ref<Selection>):Type_ {
        @:recv var _s:stdgo.Ref<Selection> = _s;
        {
            final __value__ = _s._kind;
            if (__value__ == ((1 : stdgo.go.types.Types.SelectionKind))) {
                var _sig:stdgo.go.types.Types.Signature = ((stdgo.Go.typeAssert((stdgo.Go.toInterface((stdgo.Go.typeAssert((stdgo.Go.toInterface(_s._obj) : stdgo.Ref<Func>)) : stdgo.Ref<Func>)._object._typ) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>) : stdgo.go.types.Types.Signature)?.__copy__();
                var _recv:stdgo.go.types.Types.Var = (_sig._recv : stdgo.go.types.Types.Var)?.__copy__();
                _recv._object._typ = _s._recv;
                _sig._recv = (stdgo.Go.setRef(_recv) : stdgo.Ref<stdgo.go.types.Types.Var>);
                return stdgo.Go.asInterface((stdgo.Go.setRef(_sig) : stdgo.Ref<stdgo.go.types.Types.Signature>));
            } else if (__value__ == ((2 : stdgo.go.types.Types.SelectionKind))) {
                var _sig:stdgo.go.types.Types.Signature = ((stdgo.Go.typeAssert((stdgo.Go.toInterface((stdgo.Go.typeAssert((stdgo.Go.toInterface(_s._obj) : stdgo.Ref<Func>)) : stdgo.Ref<Func>)._object._typ) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>) : stdgo.go.types.Types.Signature)?.__copy__();
                var _arg0:stdgo.go.types.Types.Var = (_sig._recv : stdgo.go.types.Types.Var)?.__copy__();
                _sig._recv = null;
                _arg0._object._typ = _s._recv;
                var _params:stdgo.Slice<stdgo.Ref<Var>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>);
                if (_sig._params != null && ((_sig._params : Dynamic).__nil__ == null || !(_sig._params : Dynamic).__nil__)) {
                    _params = _sig._params._vars;
                };
                _sig._params = newTuple(...((new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>(1, 1, (stdgo.Go.setRef(_arg0) : stdgo.Ref<stdgo.go.types.Types.Var>)) : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>).__append__(..._params.__toArray__())).__toArray__());
                return stdgo.Go.asInterface((stdgo.Go.setRef(_sig) : stdgo.Ref<stdgo.go.types.Types.Signature>));
            };
        };
        return _s._obj.type();
    }
    /**
        // Obj returns the object denoted by x.f; a *Var for
        // a field selection, and a *Func in all other cases.
    **/
    @:keep
    static public function obj( _s:stdgo.Ref<Selection>):Object {
        @:recv var _s:stdgo.Ref<Selection> = _s;
        return _s._obj;
    }
    /**
        // Recv returns the type of x in x.f.
    **/
    @:keep
    static public function recv( _s:stdgo.Ref<Selection>):Type_ {
        @:recv var _s:stdgo.Ref<Selection> = _s;
        return _s._recv;
    }
    /**
        // Kind returns the selection kind.
    **/
    @:keep
    static public function kind( _s:stdgo.Ref<Selection>):SelectionKind {
        @:recv var _s:stdgo.Ref<Selection> = _s;
        return _s._kind;
    }
}
class Signature_asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type_ return __self__.value.underlying();
    /**
        // Variadic reports whether the signature s is variadic.
    **/
    @:keep
    public dynamic function variadic():Bool return __self__.value.variadic();
    /**
        // Results returns the results of signature s, or nil.
    **/
    @:keep
    public dynamic function results():stdgo.Ref<Tuple> return __self__.value.results();
    /**
        // Params returns the parameters of signature s, or nil.
    **/
    @:keep
    public dynamic function params():stdgo.Ref<Tuple> return __self__.value.params();
    /**
        // RecvTypeParams returns the receiver type parameters of signature s, or nil.
    **/
    @:keep
    public dynamic function recvTypeParams():stdgo.Ref<TypeParamList> return __self__.value.recvTypeParams();
    /**
        // TypeParams returns the type parameters of signature s, or nil.
    **/
    @:keep
    public dynamic function typeParams():stdgo.Ref<TypeParamList> return __self__.value.typeParams();
    /**
        // Recv returns the receiver of signature s (if a method), or nil if a
        // function. It is ignored when comparing signatures for identity.
        //
        // For an abstract method, Recv returns the enclosing interface either
        // as a *Named or an *Interface. Due to embedding, an interface may
        // contain methods whose receiver type is a different interface.
    **/
    @:keep
    public dynamic function recv():stdgo.Ref<Var> return __self__.value.recv();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Signature>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Signature_asInterface) class Signature_static_extension {
    @:keep
    static public function string( _t:stdgo.Ref<Signature>):stdgo.GoString {
        @:recv var _t:stdgo.Ref<Signature> = _t;
        return typeString(stdgo.Go.asInterface(_t), null)?.__copy__();
    }
    @:keep
    static public function underlying( _t:stdgo.Ref<Signature>):Type_ {
        @:recv var _t:stdgo.Ref<Signature> = _t;
        return stdgo.Go.asInterface(_t);
    }
    /**
        // Variadic reports whether the signature s is variadic.
    **/
    @:keep
    static public function variadic( _s:stdgo.Ref<Signature>):Bool {
        @:recv var _s:stdgo.Ref<Signature> = _s;
        return _s._variadic;
    }
    /**
        // Results returns the results of signature s, or nil.
    **/
    @:keep
    static public function results( _s:stdgo.Ref<Signature>):stdgo.Ref<Tuple> {
        @:recv var _s:stdgo.Ref<Signature> = _s;
        return _s._results;
    }
    /**
        // Params returns the parameters of signature s, or nil.
    **/
    @:keep
    static public function params( _s:stdgo.Ref<Signature>):stdgo.Ref<Tuple> {
        @:recv var _s:stdgo.Ref<Signature> = _s;
        return _s._params;
    }
    /**
        // RecvTypeParams returns the receiver type parameters of signature s, or nil.
    **/
    @:keep
    static public function recvTypeParams( _s:stdgo.Ref<Signature>):stdgo.Ref<TypeParamList> {
        @:recv var _s:stdgo.Ref<Signature> = _s;
        return _s._rparams;
    }
    /**
        // TypeParams returns the type parameters of signature s, or nil.
    **/
    @:keep
    static public function typeParams( _s:stdgo.Ref<Signature>):stdgo.Ref<TypeParamList> {
        @:recv var _s:stdgo.Ref<Signature> = _s;
        return _s._tparams;
    }
    /**
        // Recv returns the receiver of signature s (if a method), or nil if a
        // function. It is ignored when comparing signatures for identity.
        //
        // For an abstract method, Recv returns the enclosing interface either
        // as a *Named or an *Interface. Due to embedding, an interface may
        // contain methods whose receiver type is a different interface.
    **/
    @:keep
    static public function recv( _s:stdgo.Ref<Signature>):stdgo.Ref<Var> {
        @:recv var _s:stdgo.Ref<Signature> = _s;
        return _s._recv;
    }
}
class StdSizes_asInterface {
    @:keep
    public dynamic function sizeof(t:Type_):stdgo.GoInt64 return __self__.value.sizeof(t);
    @:keep
    public dynamic function offsetsof(_fields:stdgo.Slice<stdgo.Ref<Var>>):stdgo.Slice<stdgo.GoInt64> return __self__.value.offsetsof(_fields);
    @:keep
    public dynamic function alignof_(t:Type_):stdgo.GoInt64 return __self__.value.alignof_(t);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<StdSizes>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.StdSizes_asInterface) class StdSizes_static_extension {
    @:keep
    static public function sizeof( _s:stdgo.Ref<StdSizes>, t:Type_):stdgo.GoInt64 {
        @:recv var _s:stdgo.Ref<StdSizes> = _s;
        {
            final __type__ = _under(t);
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                var _t:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                _assert(_isTyped(t));
                var _k:stdgo.go.types.Types.BasicKind = _t._kind;
                if ((_k : stdgo.GoInt) < (_basicSizes.length)) {
                    {
                        var _s:stdgo.GoUInt8 = _basicSizes[(_k : stdgo.GoInt)];
                        if (_s > (0 : stdgo.GoUInt8)) {
                            return (_s : stdgo.GoInt64);
                        };
                    };
                };
                if (_k == ((17 : stdgo.go.types.Types.BasicKind))) {
                    return _s.wordSize * (2i64 : stdgo.GoInt64);
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Array_>))) {
                var _t:stdgo.Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                var _n:stdgo.GoInt64 = _t._len;
                if (_n <= (0i64 : stdgo.GoInt64)) {
                    return (0i64 : stdgo.GoInt64);
                };
                var _esize:stdgo.GoInt64 = _s.sizeof(_t._elem);
                if (_esize < (0i64 : stdgo.GoInt64)) {
                    return (-1i64 : stdgo.GoInt64);
                };
                if (_esize == ((0i64 : stdgo.GoInt64))) {
                    return (0i64 : stdgo.GoInt64);
                };
                var _a:stdgo.GoInt64 = _s.alignof_(_t._elem);
                var _ea:stdgo.GoInt64 = _align(_esize, _a);
                if (_ea < (0i64 : stdgo.GoInt64)) {
                    return (-1i64 : stdgo.GoInt64);
                };
                var _n1:stdgo.GoInt64 = _n - (1i64 : stdgo.GoInt64);
                {};
                if ((_n1 > (0i64 : stdgo.GoInt64)) && (_ea > ((9223372036854775807i64 : stdgo.GoInt64) / _n1))) {
                    return (-1i64 : stdgo.GoInt64);
                };
                return (_ea * _n1) + _esize;
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Slice_>))) {
                var _t:stdgo.Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                return _s.wordSize * (3i64 : stdgo.GoInt64);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Struct>))) {
                var _t:stdgo.Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                var _n:stdgo.GoInt = _t.numFields();
                if (_n == ((0 : stdgo.GoInt))) {
                    return (0i64 : stdgo.GoInt64);
                };
                var _offsets = _s.offsetsof(_t._fields);
                var _offs:stdgo.GoInt64 = _offsets[(_n - (1 : stdgo.GoInt) : stdgo.GoInt)];
                var _size:stdgo.GoInt64 = _s.sizeof(_t._fields[(_n - (1 : stdgo.GoInt) : stdgo.GoInt)]._object._typ);
                if ((_offs < (0i64 : stdgo.GoInt64)) || (_size < (0i64 : stdgo.GoInt64))) {
                    return (-1i64 : stdgo.GoInt64);
                };
                return _offs + _size;
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                var _t:stdgo.Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                _assert(!_isTypeParam(t));
                return _s.wordSize * (2i64 : stdgo.GoInt64);
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeParam>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Union>))) {
                var _t:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                _unreachable();
            };
        };
        return _s.wordSize;
    }
    @:keep
    static public function offsetsof( _s:stdgo.Ref<StdSizes>, _fields:stdgo.Slice<stdgo.Ref<Var>>):stdgo.Slice<stdgo.GoInt64> {
        @:recv var _s:stdgo.Ref<StdSizes> = _s;
        var _offsets = new stdgo.Slice<stdgo.GoInt64>((_fields.length : stdgo.GoInt).toBasic(), 0).__setNumber64__();
        var _offs:stdgo.GoInt64 = (0 : stdgo.GoInt64);
        for (_i => _f in _fields) {
            if (_offs < (0i64 : stdgo.GoInt64)) {
                _offsets[(_i : stdgo.GoInt)] = (-1i64 : stdgo.GoInt64);
                continue;
            };
            var _a:stdgo.GoInt64 = _s.alignof_(_f._object._typ);
            _offs = _align(_offs, _a);
            _offsets[(_i : stdgo.GoInt)] = _offs;
            {
                var _d:stdgo.GoInt64 = _s.sizeof(_f._object._typ);
                if ((_d >= (0i64 : stdgo.GoInt64)) && (_offs >= (0i64 : stdgo.GoInt64))) {
                    _offs = _offs + (_d);
                } else {
                    _offs = (-1i64 : stdgo.GoInt64);
                };
            };
        };
        return _offsets;
    }
    @:keep
    static public function alignof_( _s:stdgo.Ref<StdSizes>, t:Type_):stdgo.GoInt64 {
        @:recv var _s:stdgo.Ref<StdSizes> = _s;
        var __deferstack__:Array<Void -> Void> = [];
        var _result:stdgo.GoInt64 = (0 : stdgo.GoInt64);
        try {
            __deferstack__.unshift(() -> {
                var a = function():Void {
                    _assert(_result >= (1i64 : stdgo.GoInt64));
                };
                a();
            });
            {
                final __type__ = _under(t);
                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Array_>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _s.alignof_(_t._elem);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Struct>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                    if ((_t._fields.length == (0 : stdgo.GoInt)) && __IsSyncAtomicAlign64(t)) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return (8i64 : stdgo.GoInt64);
                        };
                    };
                    var _max:stdgo.GoInt64 = (1i64 : stdgo.GoInt64);
                    for (__0 => _f in _t._fields) {
                        {
                            var _a:stdgo.GoInt64 = _s.alignof_(_f._object._typ);
                            if (_a > _max) {
                                _max = _a;
                            };
                        };
                    };
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _max;
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Slice_>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                    var _t:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                    _assert(!_isTypeParam(t));
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _s.wordSize;
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                    if (_t.info() & (32 : stdgo.go.types.Types.BasicInfo) != ((0 : stdgo.go.types.Types.BasicInfo))) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return _s.wordSize;
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeParam>)) || stdgo.Go.typeEquals((__type__ : stdgo.Ref<Union>))) {
                    var _t:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                    _unreachable();
                };
            };
            var _a:stdgo.GoInt64 = _s.sizeof(t);
            if (_a < (1i64 : stdgo.GoInt64)) {
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return (1i64 : stdgo.GoInt64);
                };
            };
            if (_isComplex(t)) {
                _a = _a / ((2i64 : stdgo.GoInt64));
            };
            if (_a > _s.maxAlign) {
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return _s.maxAlign;
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _a;
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return _result;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return _result;
        };
    }
}
class Slice__asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type_ return __self__.value.underlying();
    /**
        // Elem returns the element type of slice s.
    **/
    @:keep
    public dynamic function elem():Type_ return __self__.value.elem();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Slice_>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Slice__asInterface) class Slice__static_extension {
    @:keep
    static public function string( _s:stdgo.Ref<Slice_>):stdgo.GoString {
        @:recv var _s:stdgo.Ref<Slice_> = _s;
        return typeString(stdgo.Go.asInterface(_s), null)?.__copy__();
    }
    @:keep
    static public function underlying( _s:stdgo.Ref<Slice_>):Type_ {
        @:recv var _s:stdgo.Ref<Slice_> = _s;
        return stdgo.Go.asInterface(_s);
    }
    /**
        // Elem returns the element type of slice s.
    **/
    @:keep
    static public function elem( _s:stdgo.Ref<Slice_>):Type_ {
        @:recv var _s:stdgo.Ref<Slice_> = _s;
        return _s._elem;
    }
}
class Struct_asInterface {
    @:keep
    public dynamic function _markComplete():Void __self__.value._markComplete();
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type_ return __self__.value.underlying();
    /**
        // Tag returns the i'th field tag for 0 <= i < NumFields().
    **/
    @:keep
    public dynamic function tag(_i:stdgo.GoInt):stdgo.GoString return __self__.value.tag(_i);
    /**
        // Field returns the i'th field for 0 <= i < NumFields().
    **/
    @:keep
    public dynamic function field(_i:stdgo.GoInt):stdgo.Ref<Var> return __self__.value.field(_i);
    /**
        // NumFields returns the number of fields in the struct (including blank and embedded fields).
    **/
    @:keep
    public dynamic function numFields():stdgo.GoInt return __self__.value.numFields();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Struct>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Struct_asInterface) class Struct_static_extension {
    @:keep
    static public function _markComplete( _s:stdgo.Ref<Struct>):Void {
        @:recv var _s:stdgo.Ref<Struct> = _s;
        if (_s._fields == null) {
            _s._fields = new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>((0 : stdgo.GoInt).toBasic(), 0);
        };
    }
    @:keep
    static public function string( _t:stdgo.Ref<Struct>):stdgo.GoString {
        @:recv var _t:stdgo.Ref<Struct> = _t;
        return typeString(stdgo.Go.asInterface(_t), null)?.__copy__();
    }
    @:keep
    static public function underlying( _t:stdgo.Ref<Struct>):Type_ {
        @:recv var _t:stdgo.Ref<Struct> = _t;
        return stdgo.Go.asInterface(_t);
    }
    /**
        // Tag returns the i'th field tag for 0 <= i < NumFields().
    **/
    @:keep
    static public function tag( _s:stdgo.Ref<Struct>, _i:stdgo.GoInt):stdgo.GoString {
        @:recv var _s:stdgo.Ref<Struct> = _s;
        if (_i < (_s._tags.length)) {
            return _s._tags[(_i : stdgo.GoInt)]?.__copy__();
        };
        return stdgo.Go.str()?.__copy__();
    }
    /**
        // Field returns the i'th field for 0 <= i < NumFields().
    **/
    @:keep
    static public function field( _s:stdgo.Ref<Struct>, _i:stdgo.GoInt):stdgo.Ref<Var> {
        @:recv var _s:stdgo.Ref<Struct> = _s;
        return _s._fields[(_i : stdgo.GoInt)];
    }
    /**
        // NumFields returns the number of fields in the struct (including blank and embedded fields).
    **/
    @:keep
    static public function numFields( _s:stdgo.Ref<Struct>):stdgo.GoInt {
        @:recv var _s:stdgo.Ref<Struct> = _s;
        return (_s._fields.length);
    }
}
class T_subster_asInterface {
    @:keep
    public dynamic function _termlist(_in:stdgo.Slice<stdgo.Ref<Term>>):{ var _0 : stdgo.Slice<stdgo.Ref<Term>>; var _1 : Bool; } return __self__.value._termlist(_in);
    @:keep
    public dynamic function _typeList(_in:stdgo.Slice<Type_>):{ var _0 : stdgo.Slice<Type_>; var _1 : Bool; } return __self__.value._typeList(_in);
    @:keep
    public dynamic function _funcList(_in:stdgo.Slice<stdgo.Ref<Func>>):{ var _0 : stdgo.Slice<stdgo.Ref<Func>>; var _1 : Bool; } return __self__.value._funcList(_in);
    @:keep
    public dynamic function _func_(_f:stdgo.Ref<Func>):stdgo.Ref<Func> return __self__.value._func_(_f);
    @:keep
    public dynamic function _varList(_in:stdgo.Slice<stdgo.Ref<Var>>):{ var _0 : stdgo.Slice<stdgo.Ref<Var>>; var _1 : Bool; } return __self__.value._varList(_in);
    @:keep
    public dynamic function _tuple(_t:stdgo.Ref<Tuple>):stdgo.Ref<Tuple> return __self__.value._tuple(_t);
    @:keep
    public dynamic function _var_(_v:stdgo.Ref<Var>):stdgo.Ref<Var> return __self__.value._var_(_v);
    /**
        // typOrNil is like typ but if the argument is nil it is replaced with Typ[Invalid].
        // A nil type may appear in pathological cases such as type T[P any] []func(_ T([]_))
        // where an array/slice element is accessed before it is set up.
    **/
    @:keep
    public dynamic function _typOrNil(_typ:Type_):Type_ return __self__.value._typOrNil(_typ);
    @:keep
    public dynamic function _typ(_typ:Type_):Type_ return __self__.value._typ(_typ);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_subster>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_subster_asInterface) class T_subster_static_extension {
    @:keep
    static public function _termlist( _subst:stdgo.Ref<T_subster>, _in:stdgo.Slice<stdgo.Ref<Term>>):{ var _0 : stdgo.Slice<stdgo.Ref<Term>>; var _1 : Bool; } {
        @:recv var _subst:stdgo.Ref<T_subster> = _subst;
        var _out:stdgo.Slice<stdgo.Ref<Term>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Term>>), _copied:Bool = false;
        _out = _in;
        for (_i => _t in _in) {
            {
                var _u:stdgo.go.types.Types.Type_ = _subst._expanding._obj._object._typ(_t._typ);
                if (stdgo.Go.toInterface(_u) != (stdgo.Go.toInterface(_t._typ))) {
                    if (!_copied) {
                        var _new = new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Term>>((_in.length : stdgo.GoInt).toBasic(), 0);
                        stdgo.Go.copySlice(_new, _out);
                        _out = _new;
                        _copied = true;
                    };
                    _out[(_i : stdgo.GoInt)] = newTerm(_t._tilde, _u);
                };
            };
        };
        return { _0 : _out, _1 : _copied };
    }
    @:keep
    static public function _typeList( _subst:stdgo.Ref<T_subster>, _in:stdgo.Slice<Type_>):{ var _0 : stdgo.Slice<Type_>; var _1 : Bool; } {
        @:recv var _subst:stdgo.Ref<T_subster> = _subst;
        var _out:stdgo.Slice<Type_> = (null : stdgo.Slice<stdgo.go.types.Types.Type_>), _copied:Bool = false;
        _out = _in;
        for (_i => _t in _in) {
            {
                var _u:stdgo.go.types.Types.Type_ = _subst._expanding._obj._object._typ(_t);
                if (stdgo.Go.toInterface(_u) != (stdgo.Go.toInterface(_t))) {
                    if (!_copied) {
                        var _new = new stdgo.Slice<stdgo.go.types.Types.Type_>((_in.length : stdgo.GoInt).toBasic(), 0);
                        stdgo.Go.copySlice(_new, _out);
                        _out = _new;
                        _copied = true;
                    };
                    _out[(_i : stdgo.GoInt)] = _u;
                };
            };
        };
        return { _0 : _out, _1 : _copied };
    }
    @:keep
    static public function _funcList( _subst:stdgo.Ref<T_subster>, _in:stdgo.Slice<stdgo.Ref<Func>>):{ var _0 : stdgo.Slice<stdgo.Ref<Func>>; var _1 : Bool; } {
        @:recv var _subst:stdgo.Ref<T_subster> = _subst;
        var _out:stdgo.Slice<stdgo.Ref<Func>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>), _copied:Bool = false;
        _out = _in;
        for (_i => _f in _in) {
            {
                var _g = _subst._func_(_f);
                if (_g != (_f)) {
                    if (!_copied) {
                        var _new = new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>((_in.length : stdgo.GoInt).toBasic(), 0);
                        stdgo.Go.copySlice(_new, _out);
                        _out = _new;
                        _copied = true;
                    };
                    _out[(_i : stdgo.GoInt)] = _g;
                };
            };
        };
        return { _0 : _out, _1 : _copied };
    }
    @:keep
    static public function _func_( _subst:stdgo.Ref<T_subster>, _f:stdgo.Ref<Func>):stdgo.Ref<Func> {
        @:recv var _subst:stdgo.Ref<T_subster> = _subst;
        if (_f != null && ((_f : Dynamic).__nil__ == null || !(_f : Dynamic).__nil__)) {
            {
                var _typ:stdgo.go.types.Types.Type_ = _subst._expanding._obj._object._typ(_f._object._typ);
                if (stdgo.Go.toInterface(_typ) != (stdgo.Go.toInterface(_f._object._typ))) {
                    return _substFunc(_f, _typ);
                };
            };
        };
        return _f;
    }
    @:keep
    static public function _varList( _subst:stdgo.Ref<T_subster>, _in:stdgo.Slice<stdgo.Ref<Var>>):{ var _0 : stdgo.Slice<stdgo.Ref<Var>>; var _1 : Bool; } {
        @:recv var _subst:stdgo.Ref<T_subster> = _subst;
        var _out:stdgo.Slice<stdgo.Ref<Var>> = (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>), _copied:Bool = false;
        _out = _in;
        for (_i => _v in _in) {
            {
                var _w = _subst._var_(_v);
                if (_w != (_v)) {
                    if (!_copied) {
                        var _new = new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>>((_in.length : stdgo.GoInt).toBasic(), 0);
                        stdgo.Go.copySlice(_new, _out);
                        _out = _new;
                        _copied = true;
                    };
                    _out[(_i : stdgo.GoInt)] = _w;
                };
            };
        };
        return { _0 : _out, _1 : _copied };
    }
    @:keep
    static public function _tuple( _subst:stdgo.Ref<T_subster>, _t:stdgo.Ref<Tuple>):stdgo.Ref<Tuple> {
        @:recv var _subst:stdgo.Ref<T_subster> = _subst;
        if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
            {
                var __tmp__ = _subst._varList(_t._vars), _vars:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>> = __tmp__._0, _copied:Bool = __tmp__._1;
                if (_copied) {
                    return (stdgo.Go.setRef(({ _vars : _vars } : stdgo.go.types.Types.Tuple)) : stdgo.Ref<stdgo.go.types.Types.Tuple>);
                };
            };
        };
        return _t;
    }
    @:keep
    static public function _var_( _subst:stdgo.Ref<T_subster>, _v:stdgo.Ref<Var>):stdgo.Ref<Var> {
        @:recv var _subst:stdgo.Ref<T_subster> = _subst;
        if (_v != null && ((_v : Dynamic).__nil__ == null || !(_v : Dynamic).__nil__)) {
            {
                var _typ:stdgo.go.types.Types.Type_ = _subst._expanding._obj._object._typ(_v._object._typ);
                if (stdgo.Go.toInterface(_typ) != (stdgo.Go.toInterface(_v._object._typ))) {
                    return _substVar(_v, _typ);
                };
            };
        };
        return _v;
    }
    /**
        // typOrNil is like typ but if the argument is nil it is replaced with Typ[Invalid].
        // A nil type may appear in pathological cases such as type T[P any] []func(_ T([]_))
        // where an array/slice element is accessed before it is set up.
    **/
    @:keep
    static public function _typOrNil( _subst:stdgo.Ref<T_subster>, _typ:Type_):Type_ {
        @:recv var _subst:stdgo.Ref<T_subster> = _subst;
        if (_typ == null) {
            return stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
        };
        return _subst._expanding._obj._object._typ(_typ);
    }
    @:keep
    static public function _typ( _subst:stdgo.Ref<T_subster>, _typ:Type_):Type_ {
        @:recv var _subst:stdgo.Ref<T_subster> = _subst;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            {
                final __type__ = _typ;
                if (__type__ == null) {
                    var _t:stdgo.AnyInterface = __type__ == null ? (null : stdgo.AnyInterface) : cast __type__;
                    throw stdgo.Go.toInterface(("nil typ" : stdgo.GoString));
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Array_>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                    var _elem:stdgo.go.types.Types.Type_ = _subst._typOrNil(_t._elem);
                    if (stdgo.Go.toInterface(_elem) != (stdgo.Go.toInterface(_t._elem))) {
                        return stdgo.Go.asInterface((stdgo.Go.setRef(({ _len : _t._len, _elem : _elem } : stdgo.go.types.Types.Array_)) : stdgo.Ref<stdgo.go.types.Types.Array_>));
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Slice_>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                    var _elem:stdgo.go.types.Types.Type_ = _subst._typOrNil(_t._elem);
                    if (stdgo.Go.toInterface(_elem) != (stdgo.Go.toInterface(_t._elem))) {
                        return stdgo.Go.asInterface((stdgo.Go.setRef(({ _elem : _elem } : stdgo.go.types.Types.Slice_)) : stdgo.Ref<stdgo.go.types.Types.Slice_>));
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Struct>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = _subst._varList(_t._fields), _fields:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Var>> = __tmp__._0, _copied:Bool = __tmp__._1;
                        if (_copied) {
                            var _s = (stdgo.Go.setRef(({ _fields : _fields, _tags : _t._tags } : stdgo.go.types.Types.Struct)) : stdgo.Ref<stdgo.go.types.Types.Struct>);
                            _s._markComplete();
                            return stdgo.Go.asInterface(_s);
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Pointer_>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                    var _base:stdgo.go.types.Types.Type_ = _subst._expanding._obj._object._typ(_t._base);
                    if (stdgo.Go.toInterface(_base) != (stdgo.Go.toInterface(_t._base))) {
                        return stdgo.Go.asInterface((stdgo.Go.setRef(({ _base : _base } : stdgo.go.types.Types.Pointer_)) : stdgo.Ref<stdgo.go.types.Types.Pointer_>));
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Tuple>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Tuple> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Tuple>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Tuple>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Tuple>) : __type__.__underlying__().value;
                    return stdgo.Go.asInterface(_subst._tuple(_t));
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Signature>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Signature> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__().value;
                    var _recv = _t._recv;
                    var _params = _subst._tuple(_t._params);
                    var _results = _subst._tuple(_t._results);
                    if ((_params != _t._params) || (_results != _t._results)) {
                        return stdgo.Go.asInterface((stdgo.Go.setRef(({ _rparams : _t._rparams, _tparams : _t._tparams, _recv : _recv, _params : _params, _results : _results, _variadic : _t._variadic } : stdgo.go.types.Types.Signature)) : stdgo.Ref<stdgo.go.types.Types.Signature>));
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Union>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Union> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Union>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__().value;
                    var __tmp__ = _subst._termlist(_t._terms), _terms:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Term>> = __tmp__._0, _copied:Bool = __tmp__._1;
                    if (_copied) {
                        return stdgo.Go.asInterface((stdgo.Go.setRef((new stdgo.go.types.Types.Union(_terms) : stdgo.go.types.Types.Union)) : stdgo.Ref<stdgo.go.types.Types.Union>));
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                    var __tmp__ = _subst._funcList(_t._methods), _methods:stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>> = __tmp__._0, _mcopied:Bool = __tmp__._1;
                    var __tmp__ = _subst._typeList(_t._embeddeds), _embeddeds:stdgo.Slice<stdgo.go.types.Types.Type_> = __tmp__._0, _ecopied:Bool = __tmp__._1;
                    if (_mcopied || _ecopied) {
                        var _iface = _subst._check._newInterface();
                        _iface._embeddeds = _embeddeds;
                        _iface._implicit = _t._implicit;
                        _iface._complete = _t._complete;
                        {
                            var __tmp__ = _replaceRecvType(_methods, stdgo.Go.asInterface(_t), stdgo.Go.asInterface(_iface));
                            _iface._methods = __tmp__._0;
                        };
                        return stdgo.Go.asInterface(_iface);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Map_>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                    var _key:stdgo.go.types.Types.Type_ = _subst._expanding._obj._object._typ(_t._key);
                    var _elem:stdgo.go.types.Types.Type_ = _subst._expanding._obj._object._typ(_t._elem);
                    if ((stdgo.Go.toInterface(_key) != stdgo.Go.toInterface(_t._key)) || (stdgo.Go.toInterface(_elem) != stdgo.Go.toInterface(_t._elem))) {
                        return stdgo.Go.asInterface((stdgo.Go.setRef(({ _key : _key, _elem : _elem } : stdgo.go.types.Types.Map_)) : stdgo.Ref<stdgo.go.types.Types.Map_>));
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Chan>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Chan> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__().value;
                    var _elem:stdgo.go.types.Types.Type_ = _subst._expanding._obj._object._typ(_t._elem);
                    if (stdgo.Go.toInterface(_elem) != (stdgo.Go.toInterface(_t._elem))) {
                        return stdgo.Go.asInterface((stdgo.Go.setRef(({ _dir : _t._dir, _elem : _elem } : stdgo.go.types.Types.Chan)) : stdgo.Ref<stdgo.go.types.Types.Chan>));
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Named>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                    var _dump = function(_0:stdgo.GoString, _1:haxe.Rest<stdgo.AnyInterface>):Void {};
                    if (((_subst._check != null) && ((_subst._check : Dynamic).__nil__ == null || !(_subst._check : Dynamic).__nil__)) && _subst._check._conf.__Trace) {
                        _subst._check._indent++;
                        __deferstack__.unshift(() -> {
                            var a = function():Void {
                                _subst._check._indent--;
                            };
                            a();
                        });
                        _dump = function(_format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):Void {
                            _subst._check._trace(_subst._pos, _format?.__copy__(), ..._args.__toArray__());
                        };
                    };
                    var _orig = _t.origin();
                    var _n:stdgo.GoInt = _orig._check._environment._decl._tdecl.typeParams().len();
                    if (_n == ((0 : stdgo.GoInt))) {
                        _dump((">>> %s is not parameterized" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_t)));
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return stdgo.Go.asInterface(_t);
                        };
                    };
                    var _newTArgs:stdgo.Slice<Type_> = (null : stdgo.Slice<stdgo.go.types.Types.Type_>);
                    if (_t.typeArgs().len() != (_n)) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return stdgo.Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)]);
                        };
                    };
                    _dump((">>> %s already instantiated" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_t)));
                    for (_i => _targ in _t.typeArgs()._list()) {
                        _dump((">>> %d targ = %s" : stdgo.GoString), stdgo.Go.toInterface(_i), stdgo.Go.toInterface(_targ));
                        var _new_targ:stdgo.go.types.Types.Type_ = _subst._expanding._obj._object._typ(_targ);
                        if (stdgo.Go.toInterface(_new_targ) != (stdgo.Go.toInterface(_targ))) {
                            _dump((">>> substituted %d targ %s => %s" : stdgo.GoString), stdgo.Go.toInterface(_i), stdgo.Go.toInterface(_targ), stdgo.Go.toInterface(_new_targ));
                            if (_newTArgs == null) {
                                _newTArgs = new stdgo.Slice<stdgo.go.types.Types.Type_>((_n : stdgo.GoInt).toBasic(), 0);
                                stdgo.Go.copySlice(_newTArgs, _t.typeArgs()._list());
                            };
                            _newTArgs[(_i : stdgo.GoInt)] = _new_targ;
                        };
                    };
                    if (_newTArgs == null) {
                        _dump((">>> nothing to substitute in %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_t)));
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return stdgo.Go.asInterface(_t);
                        };
                    };
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _subst._check._instance(_subst._pos, stdgo.Go.asInterface(_orig), _newTArgs, _subst._expanding, _subst._ctxt);
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeParam>))) {
                    var _t:stdgo.Ref<stdgo.go.types.Types.TypeParam> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__().value;
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _subst._smap._lookup(_t);
                    };
                } else {
                    var _t:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                    _unreachable();
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _typ;
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return (null : stdgo.go.types.Types.Type_);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return (null : stdgo.go.types.Types.Type_);
        };
    }
}
class Tuple_asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type_ return __self__.value.underlying();
    /**
        // At returns the i'th variable of tuple t.
    **/
    @:keep
    public dynamic function at(_i:stdgo.GoInt):stdgo.Ref<Var> return __self__.value.at(_i);
    /**
        // Len returns the number variables of tuple t.
    **/
    @:keep
    public dynamic function len():stdgo.GoInt return __self__.value.len();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Tuple>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Tuple_asInterface) class Tuple_static_extension {
    @:keep
    static public function string( _t:stdgo.Ref<Tuple>):stdgo.GoString {
        @:recv var _t:stdgo.Ref<Tuple> = _t;
        return typeString(stdgo.Go.asInterface(_t), null)?.__copy__();
    }
    @:keep
    static public function underlying( _t:stdgo.Ref<Tuple>):Type_ {
        @:recv var _t:stdgo.Ref<Tuple> = _t;
        return stdgo.Go.asInterface(_t);
    }
    /**
        // At returns the i'th variable of tuple t.
    **/
    @:keep
    static public function at( _t:stdgo.Ref<Tuple>, _i:stdgo.GoInt):stdgo.Ref<Var> {
        @:recv var _t:stdgo.Ref<Tuple> = _t;
        return _t._vars[(_i : stdgo.GoInt)];
    }
    /**
        // Len returns the number variables of tuple t.
    **/
    @:keep
    static public function len( _t:stdgo.Ref<Tuple>):stdgo.GoInt {
        @:recv var _t:stdgo.Ref<Tuple> = _t;
        if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
            return (_t._vars.length);
        };
        return (0 : stdgo.GoInt);
    }
}
class TypeParamList_asInterface {
    /**
        // list is for internal use where we expect a []*TypeParam.
        // TODO(rfindley): list should probably be eliminated: we can pass around a
        // TypeParamList instead.
    **/
    @:keep
    public dynamic function _list():stdgo.Slice<stdgo.Ref<TypeParam>> return __self__.value._list();
    /**
        // At returns the i'th type parameter in the list.
    **/
    @:keep
    public dynamic function at(_i:stdgo.GoInt):stdgo.Ref<TypeParam> return __self__.value.at(_i);
    /**
        // Len returns the number of type parameters in the list.
        // It is safe to call on a nil receiver.
    **/
    @:keep
    public dynamic function len():stdgo.GoInt return __self__.value.len();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<TypeParamList>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.TypeParamList_asInterface) class TypeParamList_static_extension {
    /**
        // list is for internal use where we expect a []*TypeParam.
        // TODO(rfindley): list should probably be eliminated: we can pass around a
        // TypeParamList instead.
    **/
    @:keep
    static public function _list( _l:stdgo.Ref<TypeParamList>):stdgo.Slice<stdgo.Ref<TypeParam>> {
        @:recv var _l:stdgo.Ref<TypeParamList> = _l;
        if (_l == null || (_l : Dynamic).__nil__) {
            return (null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>);
        };
        return _l._tparams;
    }
    /**
        // At returns the i'th type parameter in the list.
    **/
    @:keep
    static public function at( _l:stdgo.Ref<TypeParamList>, _i:stdgo.GoInt):stdgo.Ref<TypeParam> {
        @:recv var _l:stdgo.Ref<TypeParamList> = _l;
        return _l._tparams[(_i : stdgo.GoInt)];
    }
    /**
        // Len returns the number of type parameters in the list.
        // It is safe to call on a nil receiver.
    **/
    @:keep
    static public function len( _l:stdgo.Ref<TypeParamList>):stdgo.GoInt {
        @:recv var _l:stdgo.Ref<TypeParamList> = _l;
        return (_l._list().length);
    }
}
class TypeList_asInterface {
    /**
        // list is for internal use where we expect a []Type.
        // TODO(rfindley): list should probably be eliminated: we can pass around a
        // TypeList instead.
    **/
    @:keep
    public dynamic function _list():stdgo.Slice<Type_> return __self__.value._list();
    /**
        // At returns the i'th type in the list.
    **/
    @:keep
    public dynamic function at(_i:stdgo.GoInt):Type_ return __self__.value.at(_i);
    /**
        // Len returns the number of types in the list.
        // It is safe to call on a nil receiver.
    **/
    @:keep
    public dynamic function len():stdgo.GoInt return __self__.value.len();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<TypeList>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.TypeList_asInterface) class TypeList_static_extension {
    /**
        // list is for internal use where we expect a []Type.
        // TODO(rfindley): list should probably be eliminated: we can pass around a
        // TypeList instead.
    **/
    @:keep
    static public function _list( _l:stdgo.Ref<TypeList>):stdgo.Slice<Type_> {
        @:recv var _l:stdgo.Ref<TypeList> = _l;
        if (_l == null || (_l : Dynamic).__nil__) {
            return (null : stdgo.Slice<stdgo.go.types.Types.Type_>);
        };
        return _l._types;
    }
    /**
        // At returns the i'th type in the list.
    **/
    @:keep
    static public function at( _l:stdgo.Ref<TypeList>, _i:stdgo.GoInt):Type_ {
        @:recv var _l:stdgo.Ref<TypeList> = _l;
        return _l._types[(_i : stdgo.GoInt)];
    }
    /**
        // Len returns the number of types in the list.
        // It is safe to call on a nil receiver.
    **/
    @:keep
    static public function len( _l:stdgo.Ref<TypeList>):stdgo.GoInt {
        @:recv var _l:stdgo.Ref<TypeList> = _l;
        return (_l._list().length);
    }
}
class TypeParam_asInterface {
    /**
        // underIs calls f with the underlying types of the specific type terms
        // of t's constraint and reports whether all calls to f returned true.
        // If there are no specific terms, underIs returns the result of f(nil).
    **/
    @:keep
    public dynamic function _underIs(_f:Type_ -> Bool):Bool return __self__.value._underIs(_f);
    /**
        // is calls f with the specific type terms of t's constraint and reports whether
        // all calls to f returned true. If there are no specific terms, is
        // returns the result of f(nil).
    **/
    @:keep
    public dynamic function _is(_f:stdgo.Ref<T_term> -> Bool):Bool return __self__.value._is(_f);
    /**
        // iface returns the constraint interface of t.
    **/
    @:keep
    public dynamic function _iface():stdgo.Ref<Interface> return __self__.value._iface();
    @:keep
    public dynamic function _cleanup():Void __self__.value._cleanup();
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type_ return __self__.value.underlying();
    /**
        // SetConstraint sets the type constraint for t.
        //
        // It must be called by users of NewTypeParam after the bound's underlying is
        // fully defined, and before using the type parameter in any way other than to
        // form other types. Once SetConstraint returns the receiver, t is safe for
        // concurrent use.
    **/
    @:keep
    public dynamic function setConstraint(_bound:Type_):Void __self__.value.setConstraint(_bound);
    /**
        // Constraint returns the type constraint specified for t.
    **/
    @:keep
    public dynamic function constraint():Type_ return __self__.value.constraint();
    /**
        // Index returns the index of the type param within its param list, or -1 if
        // the type parameter has not yet been bound to a type.
    **/
    @:keep
    public dynamic function index():stdgo.GoInt return __self__.value.index();
    /**
        // Obj returns the type name for the type parameter t.
    **/
    @:keep
    public dynamic function obj():stdgo.Ref<TypeName> return __self__.value.obj();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<TypeParam>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.TypeParam_asInterface) class TypeParam_static_extension {
    /**
        // underIs calls f with the underlying types of the specific type terms
        // of t's constraint and reports whether all calls to f returned true.
        // If there are no specific terms, underIs returns the result of f(nil).
    **/
    @:keep
    static public function _underIs( _t:stdgo.Ref<TypeParam>, _f:Type_ -> Bool):Bool {
        @:recv var _t:stdgo.Ref<TypeParam> = _t;
        return _t._iface()._typeSet()._underIs(_f);
    }
    /**
        // is calls f with the specific type terms of t's constraint and reports whether
        // all calls to f returned true. If there are no specific terms, is
        // returns the result of f(nil).
    **/
    @:keep
    static public function _is( _t:stdgo.Ref<TypeParam>, _f:stdgo.Ref<T_term> -> Bool):Bool {
        @:recv var _t:stdgo.Ref<TypeParam> = _t;
        return _t._iface()._typeSet()._is(_f);
    }
    /**
        // iface returns the constraint interface of t.
    **/
    @:keep
    static public function _iface( _t:stdgo.Ref<TypeParam>):stdgo.Ref<Interface> {
        @:recv var _t:stdgo.Ref<TypeParam> = _t;
        var _bound:stdgo.go.types.Types.Type_ = _t._bound;
        var _ityp:stdgo.Ref<Interface> = (null : stdgo.Ref<stdgo.go.types.Types.Interface>);
        {
            final __type__ = _under(_bound);
            if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                var _u:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                if (_u == (typ[((0 : stdgo.go.types.Types.BasicKind) : stdgo.GoInt)])) {
                    return (stdgo.Go.setRef(_emptyInterface) : stdgo.Ref<stdgo.go.types.Types.Interface>);
                };
            } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                var _u:stdgo.Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                if (_isTypeParam(_bound)) {
                    return (stdgo.Go.setRef(_emptyInterface) : stdgo.Ref<stdgo.go.types.Types.Interface>);
                };
                _ityp = _u;
            };
        };
        if (_ityp == null || (_ityp : Dynamic).__nil__) {
            _ityp = newInterfaceType((null : stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.Func>>), (new stdgo.Slice<stdgo.go.types.Types.Type_>(1, 1, _bound) : stdgo.Slice<stdgo.go.types.Types.Type_>));
            _ityp._implicit = true;
            _t._bound = stdgo.Go.asInterface(_ityp);
        };
        if (_ityp._tset == null || (_ityp._tset : Dynamic).__nil__) {
            var _pos:stdgo.go.token.Token.Pos = _t._obj._object._pos;
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_bound) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
                }, _n = __tmp__._0, __40 = __tmp__._1;
                if (_n != null && ((_n : Dynamic).__nil__ == null || !(_n : Dynamic).__nil__)) {
                    _pos = _n._obj._object._pos;
                };
            };
            _computeInterfaceTypeSet(_t._check, _pos, _ityp);
        };
        return _ityp;
    }
    @:keep
    static public function _cleanup( _t:stdgo.Ref<TypeParam>):Void {
        @:recv var _t:stdgo.Ref<TypeParam> = _t;
        _t._iface();
        _t._check = null;
    }
    @:keep
    static public function string( _t:stdgo.Ref<TypeParam>):stdgo.GoString {
        @:recv var _t:stdgo.Ref<TypeParam> = _t;
        return typeString(stdgo.Go.asInterface(_t), null)?.__copy__();
    }
    @:keep
    static public function underlying( _t:stdgo.Ref<TypeParam>):Type_ {
        @:recv var _t:stdgo.Ref<TypeParam> = _t;
        return stdgo.Go.asInterface(_t._iface());
    }
    /**
        // SetConstraint sets the type constraint for t.
        //
        // It must be called by users of NewTypeParam after the bound's underlying is
        // fully defined, and before using the type parameter in any way other than to
        // form other types. Once SetConstraint returns the receiver, t is safe for
        // concurrent use.
    **/
    @:keep
    static public function setConstraint( _t:stdgo.Ref<TypeParam>, _bound:Type_):Void {
        @:recv var _t:stdgo.Ref<TypeParam> = _t;
        if (_bound == null) {
            throw stdgo.Go.toInterface(("nil constraint" : stdgo.GoString));
        };
        _t._bound = _bound;
        _t._iface();
    }
    /**
        // Constraint returns the type constraint specified for t.
    **/
    @:keep
    static public function constraint( _t:stdgo.Ref<TypeParam>):Type_ {
        @:recv var _t:stdgo.Ref<TypeParam> = _t;
        return _t._bound;
    }
    /**
        // Index returns the index of the type param within its param list, or -1 if
        // the type parameter has not yet been bound to a type.
    **/
    @:keep
    static public function index( _t:stdgo.Ref<TypeParam>):stdgo.GoInt {
        @:recv var _t:stdgo.Ref<TypeParam> = _t;
        return _t._index;
    }
    /**
        // Obj returns the type name for the type parameter t.
    **/
    @:keep
    static public function obj( _t:stdgo.Ref<TypeParam>):stdgo.Ref<TypeName> {
        @:recv var _t:stdgo.Ref<TypeParam> = _t;
        return _t._obj;
    }
}
class T__TypeSet_asInterface {
    /**
        // underIs calls f with the underlying types of the specific type terms
        // of s and reports whether all calls to f returned true. If there are
        // no specific terms, underIs returns the result of f(nil).
    **/
    @:keep
    public dynamic function _underIs(_f:Type_ -> Bool):Bool return __self__.value._underIs(_f);
    /**
        // is calls f with the specific type terms of s and reports whether
        // all calls to f returned true. If there are no specific terms, is
        // returns the result of f(nil).
    **/
    @:keep
    public dynamic function _is(_f:stdgo.Ref<T_term> -> Bool):Bool return __self__.value._is(_f);
    /**
        // subsetOf reports whether s1 ⊆ s2.
    **/
    @:keep
    public dynamic function _subsetOf(_s2:stdgo.Ref<T__TypeSet>):Bool return __self__.value._subsetOf(_s2);
    /**
        // hasTerms reports whether the type set has specific type terms.
    **/
    @:keep
    public dynamic function _hasTerms():Bool return __self__.value._hasTerms();
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    /**
        // LookupMethod returns the index of and method with matching package and name, or (-1, nil).
    **/
    @:keep
    public dynamic function lookupMethod(_pkg:stdgo.Ref<Package>, _name:stdgo.GoString, _foldCase:Bool):{ var _0 : stdgo.GoInt; var _1 : stdgo.Ref<Func>; } return __self__.value.lookupMethod(_pkg, _name, _foldCase);
    /**
        // Method returns the i'th method of type set s for 0 <= i < s.NumMethods().
        // The methods are ordered by their unique ID.
    **/
    @:keep
    public dynamic function method(_i:stdgo.GoInt):stdgo.Ref<Func> return __self__.value.method(_i);
    /**
        // NumMethods returns the number of methods available.
    **/
    @:keep
    public dynamic function numMethods():stdgo.GoInt return __self__.value.numMethods();
    /**
        // IsComparable reports whether each type in the set is comparable.
    **/
    @:keep
    public dynamic function isComparable(_seen:stdgo.GoMap<Type_, Bool>):Bool return __self__.value.isComparable(_seen);
    /**
        // IsMethodSet reports whether the interface t is fully described by its method set.
    **/
    @:keep
    public dynamic function isMethodSet():Bool return __self__.value.isMethodSet();
    /**
        // IsAll reports whether type set s is the set of all types (corresponding to the empty interface).
    **/
    @:keep
    public dynamic function isAll():Bool return __self__.value.isAll();
    /**
        // IsEmpty reports whether type set s is the empty set.
    **/
    @:keep
    public dynamic function isEmpty():Bool return __self__.value.isEmpty();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T__TypeSet>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T__TypeSet_asInterface) class T__TypeSet_static_extension {
    /**
        // underIs calls f with the underlying types of the specific type terms
        // of s and reports whether all calls to f returned true. If there are
        // no specific terms, underIs returns the result of f(nil).
    **/
    @:keep
    static public function _underIs( _s:stdgo.Ref<T__TypeSet>, _f:Type_ -> Bool):Bool {
        @:recv var _s:stdgo.Ref<T__TypeSet> = _s;
        if (!_s._hasTerms()) {
            return _f((null : stdgo.go.types.Types.Type_));
        };
        for (__0 => _t in _s._terms) {
            _assert(_t._typ != null);
            var _u:stdgo.go.types.Types.Type_ = _t._typ;
            if (!_t._tilde) {
                _u = _under(_u);
            };
            if (false) {
                _assert(identical(_u, _under(_u)));
            };
            if (!_f(_u)) {
                return false;
            };
        };
        return true;
    }
    /**
        // is calls f with the specific type terms of s and reports whether
        // all calls to f returned true. If there are no specific terms, is
        // returns the result of f(nil).
    **/
    @:keep
    static public function _is( _s:stdgo.Ref<T__TypeSet>, _f:stdgo.Ref<T_term> -> Bool):Bool {
        @:recv var _s:stdgo.Ref<T__TypeSet> = _s;
        if (!_s._hasTerms()) {
            return _f((null : stdgo.Ref<stdgo.go.types.Types.T_term>));
        };
        for (__0 => _t in _s._terms) {
            _assert(_t._typ != null);
            if (!_f(_t)) {
                return false;
            };
        };
        return true;
    }
    /**
        // subsetOf reports whether s1 ⊆ s2.
    **/
    @:keep
    static public function _subsetOf( _s1:stdgo.Ref<T__TypeSet>, _s2:stdgo.Ref<T__TypeSet>):Bool {
        @:recv var _s1:stdgo.Ref<T__TypeSet> = _s1;
        return _s1._terms._subsetOf(_s2._terms);
    }
    /**
        // hasTerms reports whether the type set has specific type terms.
    **/
    @:keep
    static public function _hasTerms( _s:stdgo.Ref<T__TypeSet>):Bool {
        @:recv var _s:stdgo.Ref<T__TypeSet> = _s;
        return !_s._terms._isEmpty() && !_s._terms._isAll();
    }
    @:keep
    static public function string( _s:stdgo.Ref<T__TypeSet>):stdgo.GoString {
        @:recv var _s:stdgo.Ref<T__TypeSet> = _s;
        if (_s.isEmpty()) {
            return ("∅" : stdgo.GoString);
        } else if (_s.isAll()) {
            return ("𝓤" : stdgo.GoString);
        };
        var _hasMethods:Bool = (_s._methods.length) > (0 : stdgo.GoInt);
        var _hasTerms:Bool = _s._hasTerms();
        var _buf:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
        _buf.writeByte((123 : stdgo.GoUInt8));
        if (_s._comparable) {
            _buf.writeString(("comparable" : stdgo.GoString));
            if (_hasMethods || _hasTerms) {
                _buf.writeString(("; " : stdgo.GoString));
            };
        };
        for (_i => _m in _s._methods) {
            if (_i > (0 : stdgo.GoInt)) {
                _buf.writeString(("; " : stdgo.GoString));
            };
            _buf.writeString((_m.string() : stdgo.GoString)?.__copy__());
        };
        if (_hasMethods && _hasTerms) {
            _buf.writeString(("; " : stdgo.GoString));
        };
        if (_hasTerms) {
            _buf.writeString((_s._terms.string() : stdgo.GoString)?.__copy__());
        };
        _buf.writeString(("}" : stdgo.GoString));
        return (_buf.string() : stdgo.GoString)?.__copy__();
    }
    /**
        // LookupMethod returns the index of and method with matching package and name, or (-1, nil).
    **/
    @:keep
    static public function lookupMethod( _s:stdgo.Ref<T__TypeSet>, _pkg:stdgo.Ref<Package>, _name:stdgo.GoString, _foldCase:Bool):{ var _0 : stdgo.GoInt; var _1 : stdgo.Ref<Func>; } {
        @:recv var _s:stdgo.Ref<T__TypeSet> = _s;
        return _lookupMethod(_s._methods, _pkg, _name?.__copy__(), _foldCase);
    }
    /**
        // Method returns the i'th method of type set s for 0 <= i < s.NumMethods().
        // The methods are ordered by their unique ID.
    **/
    @:keep
    static public function method( _s:stdgo.Ref<T__TypeSet>, _i:stdgo.GoInt):stdgo.Ref<Func> {
        @:recv var _s:stdgo.Ref<T__TypeSet> = _s;
        return _s._methods[(_i : stdgo.GoInt)];
    }
    /**
        // NumMethods returns the number of methods available.
    **/
    @:keep
    static public function numMethods( _s:stdgo.Ref<T__TypeSet>):stdgo.GoInt {
        @:recv var _s:stdgo.Ref<T__TypeSet> = _s;
        return (_s._methods.length);
    }
    /**
        // IsComparable reports whether each type in the set is comparable.
    **/
    @:keep
    static public function isComparable( _s:stdgo.Ref<T__TypeSet>, _seen:stdgo.GoMap<Type_, Bool>):Bool {
        @:recv var _s:stdgo.Ref<T__TypeSet> = _s;
        if (_s._terms._isAll()) {
            return _s._comparable;
        };
        return _s._is(function(_t:stdgo.Ref<T_term>):Bool {
            return ((_t != null) && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) && _comparable(_t._typ, false, _seen, null);
        });
    }
    /**
        // IsMethodSet reports whether the interface t is fully described by its method set.
    **/
    @:keep
    static public function isMethodSet( _s:stdgo.Ref<T__TypeSet>):Bool {
        @:recv var _s:stdgo.Ref<T__TypeSet> = _s;
        return !_s._comparable && _s._terms._isAll();
    }
    /**
        // IsAll reports whether type set s is the set of all types (corresponding to the empty interface).
    **/
    @:keep
    static public function isAll( _s:stdgo.Ref<T__TypeSet>):Bool {
        @:recv var _s:stdgo.Ref<T__TypeSet> = _s;
        return _s.isMethodSet() && (_s._methods.length == (0 : stdgo.GoInt));
    }
    /**
        // IsEmpty reports whether type set s is the empty set.
    **/
    @:keep
    static public function isEmpty( _s:stdgo.Ref<T__TypeSet>):Bool {
        @:recv var _s:stdgo.Ref<T__TypeSet> = _s;
        return _s._terms._isEmpty();
    }
}
class T_typeWriter_asInterface {
    @:keep
    public dynamic function _signature(_sig:stdgo.Ref<Signature>):Void __self__.value._signature(_sig);
    @:keep
    public dynamic function _tuple(_tup:stdgo.Ref<Tuple>, _variadic:Bool):Void __self__.value._tuple(_tup, _variadic);
    @:keep
    public dynamic function _typeName(_obj:stdgo.Ref<TypeName>):Void __self__.value._typeName(_obj);
    @:keep
    public dynamic function _tParamList(_list:stdgo.Slice<stdgo.Ref<TypeParam>>):Void __self__.value._tParamList(_list);
    @:keep
    public dynamic function _typeList(_list:stdgo.Slice<Type_>):Void __self__.value._typeList(_list);
    /**
        // typeSet writes a canonical hash for an interface type set.
    **/
    @:keep
    public dynamic function _typeSet(_s:stdgo.Ref<T__TypeSet>):Void __self__.value._typeSet(_s);
    @:keep
    public dynamic function _typ(_typ:Type_):Void __self__.value._typ(_typ);
    @:keep
    public dynamic function _error(_msg:stdgo.GoString):Void __self__.value._error(_msg);
    @:keep
    public dynamic function _string(_s:stdgo.GoString):Void __self__.value._string(_s);
    @:keep
    public dynamic function _byte(_b:stdgo.GoByte):Void __self__.value._byte(_b);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_typeWriter>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_typeWriter_asInterface) class T_typeWriter_static_extension {
    @:keep
    static public function _signature( _w:stdgo.Ref<T_typeWriter>, _sig:stdgo.Ref<Signature>):Void {
        @:recv var _w:stdgo.Ref<T_typeWriter> = _w;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            if (_sig.typeParams().len() != ((0 : stdgo.GoInt))) {
                if (_w._ctxt != null && ((_w._ctxt : Dynamic).__nil__ == null || !(_w._ctxt : Dynamic).__nil__)) {
                    _assert(_w._tparams == null || (_w._tparams : Dynamic).__nil__);
                    _w._tparams = _sig.typeParams();
                    __deferstack__.unshift(() -> {
                        var a = function():Void {
                            _w._tparams = null;
                        };
                        a();
                    });
                };
                _w._tParamList(_sig.typeParams()._list());
            };
            _w._tuple(_sig._params, _sig._variadic);
            var _n:stdgo.GoInt = _sig._results.len();
            if (_n == ((0 : stdgo.GoInt))) {
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return;
                };
            };
            _w._byte((32 : stdgo.GoUInt8));
            if ((_n == (1 : stdgo.GoInt)) && (((_w._ctxt != null) && ((_w._ctxt : Dynamic).__nil__ == null || !(_w._ctxt : Dynamic).__nil__)) || (_sig._results._vars[(0 : stdgo.GoInt)]._object._name == stdgo.Go.str()))) {
                _w._typ(_sig._results._vars[(0 : stdgo.GoInt)]._object._typ);
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return;
                };
            };
            _w._tuple(_sig._results, false);
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return;
        };
    }
    @:keep
    static public function _tuple( _w:stdgo.Ref<T_typeWriter>, _tup:stdgo.Ref<Tuple>, _variadic:Bool):Void {
        @:recv var _w:stdgo.Ref<T_typeWriter> = _w;
        _w._byte((40 : stdgo.GoUInt8));
        if (_tup != null && ((_tup : Dynamic).__nil__ == null || !(_tup : Dynamic).__nil__)) {
            for (_i => _v in _tup._vars) {
                if (_i > (0 : stdgo.GoInt)) {
                    _w._byte((44 : stdgo.GoUInt8));
                };
                if (((_w._ctxt == null) || (_w._ctxt : Dynamic).__nil__ && (_v._object._name != stdgo.Go.str())) && _w._paramNames) {
                    _w._string(_v._object._name?.__copy__());
                    _w._byte((32 : stdgo.GoUInt8));
                };
                var _typ:stdgo.go.types.Types.Type_ = _v._object._typ;
                if (_variadic && (_i == (_tup._vars.length - (1 : stdgo.GoInt)))) {
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_typ) : stdgo.Ref<Slice_>)) : stdgo.Ref<Slice_>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Slice_>), _1 : false };
                        }, _s = __tmp__._0, _ok = __tmp__._1;
                        if (_ok) {
                            _w._string(("..." : stdgo.GoString));
                            _typ = _s._elem;
                        } else {
                            {
                                var __tmp__ = try {
                                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_typ)) : stdgo.Ref<Basic>)) : stdgo.Ref<Basic>), _1 : true };
                                } catch(_) {
                                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Basic>), _1 : false };
                                }, _t = __tmp__._0, __0 = __tmp__._1;
                                if (((_t == null) || (_t : Dynamic).__nil__) || (_t._kind != (17 : stdgo.go.types.Types.BasicKind))) {
                                    _w._error(("expected string type" : stdgo.GoString));
                                    continue;
                                };
                            };
                            _w._typ(_typ);
                            _w._string(("..." : stdgo.GoString));
                            continue;
                        };
                    };
                };
                _w._typ(_typ);
            };
        };
        _w._byte((41 : stdgo.GoUInt8));
    }
    @:keep
    static public function _typeName( _w:stdgo.Ref<T_typeWriter>, _obj:stdgo.Ref<TypeName>):Void {
        @:recv var _w:stdgo.Ref<T_typeWriter> = _w;
        _w._string(_packagePrefix(_obj._object._pkg, _w._qf)?.__copy__());
        _w._string(_obj._object._name?.__copy__());
    }
    @:keep
    static public function _tParamList( _w:stdgo.Ref<T_typeWriter>, _list:stdgo.Slice<stdgo.Ref<TypeParam>>):Void {
        @:recv var _w:stdgo.Ref<T_typeWriter> = _w;
        _w._byte((91 : stdgo.GoUInt8));
        var _prev:Type_ = (null : stdgo.go.types.Types.Type_);
        for (_i => _tpar in _list) {
            if (_tpar == null || (_tpar : Dynamic).__nil__) {
                _w._error(("nil type parameter" : stdgo.GoString));
                continue;
            };
            if (_i > (0 : stdgo.GoInt)) {
                if (stdgo.Go.toInterface(_tpar._bound) != (stdgo.Go.toInterface(_prev))) {
                    _w._byte((32 : stdgo.GoUInt8));
                    _w._typ(_prev);
                };
                _w._byte((44 : stdgo.GoUInt8));
            };
            _prev = _tpar._bound;
            _w._typ(stdgo.Go.asInterface(_tpar));
        };
        if (_prev != null) {
            _w._byte((32 : stdgo.GoUInt8));
            _w._typ(_prev);
        };
        _w._byte((93 : stdgo.GoUInt8));
    }
    @:keep
    static public function _typeList( _w:stdgo.Ref<T_typeWriter>, _list:stdgo.Slice<Type_>):Void {
        @:recv var _w:stdgo.Ref<T_typeWriter> = _w;
        _w._byte((91 : stdgo.GoUInt8));
        for (_i => _typ in _list) {
            if (_i > (0 : stdgo.GoInt)) {
                _w._byte((44 : stdgo.GoUInt8));
            };
            _w._typ(_typ);
        };
        _w._byte((93 : stdgo.GoUInt8));
    }
    /**
        // typeSet writes a canonical hash for an interface type set.
    **/
    @:keep
    static public function _typeSet( _w:stdgo.Ref<T_typeWriter>, _s:stdgo.Ref<T__TypeSet>):Void {
        @:recv var _w:stdgo.Ref<T_typeWriter> = _w;
        _assert(_w._ctxt != null && ((_w._ctxt : Dynamic).__nil__ == null || !(_w._ctxt : Dynamic).__nil__));
        var _first:Bool = true;
        for (__0 => _m in _s._methods) {
            if (!_first) {
                _w._byte((59 : stdgo.GoUInt8));
            };
            _first = false;
            _w._string(_m._object._name?.__copy__());
            _w._signature((stdgo.Go.typeAssert((stdgo.Go.toInterface(_m._object._typ) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>));
        };
        if (_s._terms._isAll()) {} else if (_s._terms._isEmpty()) {
            _w._string((_s._terms.string() : stdgo.GoString)?.__copy__());
        } else {
            var _termHashes:stdgo.Slice<stdgo.GoString> = (null : stdgo.Slice<stdgo.GoString>);
            for (__1 => _term in _s._terms) {
                var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
                if (_term._tilde) {
                    _buf.writeByte((126 : stdgo.GoUInt8));
                };
                _newTypeHasher((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.bytes.Bytes.Buffer>), _w._ctxt)._typ(_term._typ);
                _termHashes = (_termHashes.__append__((_buf.string() : stdgo.GoString)?.__copy__()));
            };
            stdgo.sort.Sort.strings(_termHashes);
            if (!_first) {
                _w._byte((59 : stdgo.GoUInt8));
            };
            _w._string(stdgo.strings.Strings.join(_termHashes, ("|" : stdgo.GoString))?.__copy__());
        };
    }
    @:keep
    static public function _typ( _w:stdgo.Ref<T_typeWriter>, _typ:Type_):Void {
        @:recv var _w:stdgo.Ref<T_typeWriter> = _w;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            if ((_w._seen[_typ] ?? false)) {
                _w._error(("cycle to " : stdgo.GoString) + _goTypeName(_typ)?.__copy__()?.__copy__());
                return;
            };
            _w._seen[_typ] = true;
            {
                var _a0 = _w._seen;
                var _a1 = _typ;
                __deferstack__.unshift(() -> if (_a0 != null) _a0.remove(_a1));
            };
            {
                final __type__ = _typ;
                {
                    var __bool__ = true;
                    while (__bool__) {
                        __bool__ = false;
                        if (__type__ == null) {
                            var _t:stdgo.AnyInterface = __type__ == null ? (null : stdgo.AnyInterface) : cast __type__;
                            _w._error(("nil" : stdgo.GoString));
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                            var _t:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                            if (stdgo.go.token.Token.isExported(_t._name?.__copy__())) {
                                {
                                    var __tmp__ = try {
                                        { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(unsafe._scope.lookup(_t._name?.__copy__())) : stdgo.Ref<TypeName>)) : stdgo.Ref<TypeName>), _1 : true };
                                    } catch(_) {
                                        { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeName>), _1 : false };
                                    }, _obj = __tmp__._0, __0 = __tmp__._1;
                                    if (_obj != null && ((_obj : Dynamic).__nil__ == null || !(_obj : Dynamic).__nil__)) {
                                        _w._typeName(_obj);
                                        break;
                                    };
                                };
                            };
                            _w._string(_t._name?.__copy__());
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Array_>))) {
                            var _t:stdgo.Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                            _w._byte((91 : stdgo.GoUInt8));
                            _w._string(stdgo.strconv.Strconv.formatInt(_t._len, (10 : stdgo.GoInt))?.__copy__());
                            _w._byte((93 : stdgo.GoUInt8));
                            _w._typ(_t._elem);
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Slice_>))) {
                            var _t:stdgo.Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                            _w._string(("[]" : stdgo.GoString));
                            _w._typ(_t._elem);
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Struct>))) {
                            var _t:stdgo.Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                            _w._string(("struct{" : stdgo.GoString));
                            for (_i => _f in _t._fields) {
                                if (_i > (0 : stdgo.GoInt)) {
                                    _w._byte((59 : stdgo.GoUInt8));
                                };
                                var _pkgAnnotate:Bool = false;
                                if (((_w._qf == null) && _w._pkgInfo) && !stdgo.go.token.Token.isExported(_f._object._name?.__copy__())) {
                                    _pkgAnnotate = true;
                                    _w._pkgInfo = false;
                                };
                                if (!_f._embedded) {
                                    _w._string(_f._object._name?.__copy__());
                                    _w._byte((32 : stdgo.GoUInt8));
                                };
                                _w._typ(_f._object._typ);
                                if (_pkgAnnotate) {
                                    _w._string((" /* package " : stdgo.GoString));
                                    _w._string(_f._object._pkg.path()?.__copy__());
                                    _w._string((" */ " : stdgo.GoString));
                                };
                                {
                                    var _tag:stdgo.GoString = _t.tag(_i)?.__copy__();
                                    if (_tag != (stdgo.Go.str())) {
                                        _w._byte((32 : stdgo.GoUInt8));
                                        _w._string(stdgo.strconv.Strconv.quote(_tag?.__copy__())?.__copy__());
                                    };
                                };
                            };
                            _w._byte((125 : stdgo.GoUInt8));
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Pointer_>))) {
                            var _t:stdgo.Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                            _w._byte((42 : stdgo.GoUInt8));
                            _w._typ(_t._base);
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Tuple>))) {
                            var _t:stdgo.Ref<stdgo.go.types.Types.Tuple> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Tuple>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Tuple>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Tuple>) : __type__.__underlying__().value;
                            _w._tuple(_t, false);
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Signature>))) {
                            var _t:stdgo.Ref<stdgo.go.types.Types.Signature> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__().value;
                            _w._string(("func" : stdgo.GoString));
                            _w._signature(_t);
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Union>))) {
                            var _t:stdgo.Ref<stdgo.go.types.Types.Union> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Union>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__().value;
                            if (_t.len() == ((0 : stdgo.GoInt))) {
                                _w._error(("empty union" : stdgo.GoString));
                                break;
                            };
                            for (_i => _t in _t._terms) {
                                if (_i > (0 : stdgo.GoInt)) {
                                    _w._string((" | " : stdgo.GoString));
                                };
                                if (_t._tilde) {
                                    _w._byte((126 : stdgo.GoUInt8));
                                };
                                _w._typ(_t._typ);
                            };
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                            var _t:stdgo.Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                            if (_w._ctxt == null || (_w._ctxt : Dynamic).__nil__) {
                                if (stdgo.Go.toInterface(stdgo.Go.asInterface(_t)) == (stdgo.Go.toInterface(_universeAny.type()))) {
                                    _w._string(("any" : stdgo.GoString));
                                    break;
                                };
                                if (stdgo.Go.toInterface(stdgo.Go.asInterface(_t)) == (stdgo.Go.toInterface((stdgo.Go.typeAssert((stdgo.Go.toInterface(_universeComparable.type()) : stdgo.Ref<Named>)) : stdgo.Ref<Named>)._underlying))) {
                                    _w._string(("interface{comparable}" : stdgo.GoString));
                                    break;
                                };
                            };
                            if (_t._implicit) {
                                if ((_t._methods.length == (0 : stdgo.GoInt)) && (_t._embeddeds.length == (1 : stdgo.GoInt))) {
                                    _w._typ(_t._embeddeds[(0 : stdgo.GoInt)]);
                                    break;
                                };
                                _w._string(("/* implicit */ " : stdgo.GoString));
                            };
                            _w._string(("interface{" : stdgo.GoString));
                            var _first:Bool = true;
                            if (_w._ctxt != null && ((_w._ctxt : Dynamic).__nil__ == null || !(_w._ctxt : Dynamic).__nil__)) {
                                _w._typeSet(_t._typeSet());
                            } else {
                                for (__57 => _m in _t._methods) {
                                    if (!_first) {
                                        _w._byte((59 : stdgo.GoUInt8));
                                    };
                                    _first = false;
                                    _w._string(_m._object._name?.__copy__());
                                    _w._signature((stdgo.Go.typeAssert((stdgo.Go.toInterface(_m._object._typ) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>));
                                };
                                for (__66 => _typ in _t._embeddeds) {
                                    if (!_first) {
                                        _w._byte((59 : stdgo.GoUInt8));
                                    };
                                    _first = false;
                                    _w._typ(_typ);
                                };
                            };
                            _w._byte((125 : stdgo.GoUInt8));
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Map_>))) {
                            var _t:stdgo.Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                            _w._string(("map[" : stdgo.GoString));
                            _w._typ(_t._key);
                            _w._byte((93 : stdgo.GoUInt8));
                            _w._typ(_t._elem);
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Chan>))) {
                            var _t:stdgo.Ref<stdgo.go.types.Types.Chan> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__().value;
                            var _s:stdgo.GoString = ("" : stdgo.GoString);
                            var _parens:Bool = false;
                            {
                                final __value__ = _t._dir;
                                if (__value__ == ((0 : stdgo.go.types.Types.ChanDir))) {
                                    _s = ("chan " : stdgo.GoString);
                                    {
                                        var __tmp__ = try {
                                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_t._elem) : stdgo.Ref<Chan>)) : stdgo.Ref<Chan>), _1 : true };
                                        } catch(_) {
                                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Chan>), _1 : false };
                                        }, _c = __tmp__._0, __67 = __tmp__._1;
                                        if (((_c != null) && ((_c : Dynamic).__nil__ == null || !(_c : Dynamic).__nil__)) && (_c._dir == (2 : stdgo.go.types.Types.ChanDir))) {
                                            _parens = true;
                                        };
                                    };
                                } else if (__value__ == ((1 : stdgo.go.types.Types.ChanDir))) {
                                    _s = ("chan<- " : stdgo.GoString);
                                } else if (__value__ == ((2 : stdgo.go.types.Types.ChanDir))) {
                                    _s = ("<-chan " : stdgo.GoString);
                                } else {
                                    _w._error(("unknown channel direction" : stdgo.GoString));
                                };
                            };
                            _w._string(_s?.__copy__());
                            if (_parens) {
                                _w._byte((40 : stdgo.GoUInt8));
                            };
                            _w._typ(_t._elem);
                            if (_parens) {
                                _w._byte((41 : stdgo.GoUInt8));
                            };
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Named>))) {
                            var _t:stdgo.Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                            if (_w._ctxt != null && ((_w._ctxt : Dynamic).__nil__ == null || !(_w._ctxt : Dynamic).__nil__)) {
                                _w._string(stdgo.strconv.Strconv.itoa(_w._ctxt._getID(stdgo.Go.asInterface(_t)))?.__copy__());
                            };
                            _w._typeName(_t._obj);
                            if (_t._inst != null && ((_t._inst : Dynamic).__nil__ == null || !(_t._inst : Dynamic).__nil__)) {
                                _w._typeList(_t._inst._targs._list());
                            } else if ((_w._ctxt == null) || (_w._ctxt : Dynamic).__nil__ && (_t._check._environment._decl._tdecl.typeParams().len() != (0 : stdgo.GoInt))) {
                                _w._tParamList(_t._check._environment._decl._tdecl.typeParams()._list());
                            };
                        } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeParam>))) {
                            var _t:stdgo.Ref<stdgo.go.types.Types.TypeParam> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__().value;
                            if (_t._obj == null || (_t._obj : Dynamic).__nil__) {
                                _w._error(("unnamed type parameter" : stdgo.GoString));
                                break;
                            };
                            {
                                var _i:stdgo.GoInt = _tparamIndex(_w._tparams._list(), _t);
                                if (_i >= (0 : stdgo.GoInt)) {
                                    _w._string(stdgo.fmt.Fmt.sprintf(("$%d" : stdgo.GoString), stdgo.Go.toInterface(_i))?.__copy__());
                                } else {
                                    _w._string(_t._obj._object._name?.__copy__());
                                    if (_w._tpSubscripts || ((_w._ctxt != null) && ((_w._ctxt : Dynamic).__nil__ == null || !(_w._ctxt : Dynamic).__nil__))) {
                                        _w._string(_subscript(_t._id)?.__copy__());
                                    };
                                    if ((_w._ctxt == null) || (_w._ctxt : Dynamic).__nil__ && (universe.lookup(_t._obj._object._name?.__copy__()) != null)) {
                                        _w._string(("/* type parameter */" : stdgo.GoString));
                                    };
                                };
                            };
                        } else {
                            var _t:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                            _w._string((_t.string() : stdgo.GoString)?.__copy__());
                        };
                        break;
                    };
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return;
        };
    }
    @:keep
    static public function _error( _w:stdgo.Ref<T_typeWriter>, _msg:stdgo.GoString):Void {
        @:recv var _w:stdgo.Ref<T_typeWriter> = _w;
        if (_w._ctxt != null && ((_w._ctxt : Dynamic).__nil__ == null || !(_w._ctxt : Dynamic).__nil__)) {
            throw stdgo.Go.toInterface(_msg);
        };
        _w._buf.writeString(("<" : stdgo.GoString) + _msg?.__copy__() + (">" : stdgo.GoString)?.__copy__()?.__copy__());
    }
    @:keep
    static public function _string( _w:stdgo.Ref<T_typeWriter>, _s:stdgo.GoString):Void {
        @:recv var _w:stdgo.Ref<T_typeWriter> = _w;
        _w._buf.writeString(_s?.__copy__());
    }
    @:keep
    static public function _byte( _w:stdgo.Ref<T_typeWriter>, _b:stdgo.GoByte):Void {
        @:recv var _w:stdgo.Ref<T_typeWriter> = _w;
        if (_w._ctxt != null && ((_w._ctxt : Dynamic).__nil__ == null || !(_w._ctxt : Dynamic).__nil__)) {
            if (_b == ((32 : stdgo.GoUInt8))) {
                _b = (35 : stdgo.GoUInt8);
            };
            _w._buf.writeByte(_b);
            return;
        };
        _w._buf.writeByte(_b);
        if ((_b == (44 : stdgo.GoUInt8)) || (_b == (59 : stdgo.GoUInt8))) {
            _w._buf.writeByte((32 : stdgo.GoUInt8));
        };
    }
}
class T_term_asInterface {
    /**
        // disjoint reports whether x ∩ y == ∅.
        // x.typ and y.typ must not be nil.
    **/
    @:keep
    public dynamic function _disjoint(_y:stdgo.Ref<T_term>):Bool return __self__.value._disjoint(_y);
    /**
        // subsetOf reports whether x ⊆ y.
    **/
    @:keep
    public dynamic function _subsetOf(_y:stdgo.Ref<T_term>):Bool return __self__.value._subsetOf(_y);
    /**
        // includes reports whether t ∈ x.
    **/
    @:keep
    public dynamic function _includes(_t:Type_):Bool return __self__.value._includes(_t);
    /**
        // intersect returns the intersection x ∩ y.
    **/
    @:keep
    public dynamic function _intersect(_y:stdgo.Ref<T_term>):stdgo.Ref<T_term> return __self__.value._intersect(_y);
    /**
        // union returns the union x ∪ y: zero, one, or two non-nil terms.
    **/
    @:keep
    public dynamic function _union(_y:stdgo.Ref<T_term>):{ var _0 : stdgo.Ref<T_term>; var _1 : stdgo.Ref<T_term>; } return __self__.value._union(_y);
    /**
        // equal reports whether x and y represent the same type set.
    **/
    @:keep
    public dynamic function _equal(_y:stdgo.Ref<T_term>):Bool return __self__.value._equal(_y);
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_term>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_term_asInterface) class T_term_static_extension {
    /**
        // disjoint reports whether x ∩ y == ∅.
        // x.typ and y.typ must not be nil.
    **/
    @:keep
    static public function _disjoint( _x:stdgo.Ref<T_term>, _y:stdgo.Ref<T_term>):Bool {
        @:recv var _x:stdgo.Ref<T_term> = _x;
        if (false && ((_x._typ == null) || (_y._typ == null))) {
            throw stdgo.Go.toInterface(("invalid argument(s)" : stdgo.GoString));
        };
        var _ux:stdgo.go.types.Types.Type_ = _x._typ;
        if (_y._tilde) {
            _ux = _under(_ux);
        };
        var _uy:stdgo.go.types.Types.Type_ = _y._typ;
        if (_x._tilde) {
            _uy = _under(_uy);
        };
        return !identical(_ux, _uy);
    }
    /**
        // subsetOf reports whether x ⊆ y.
    **/
    @:keep
    static public function _subsetOf( _x:stdgo.Ref<T_term>, _y:stdgo.Ref<T_term>):Bool {
        @:recv var _x:stdgo.Ref<T_term> = _x;
        if (_x == null || (_x : Dynamic).__nil__) {
            return true;
        } else if (_y == null || (_y : Dynamic).__nil__) {
            return false;
        } else if (_y._typ == null) {
            return true;
        } else if (_x._typ == null) {
            return false;
        };
        if (_x._disjoint(_y)) {
            return false;
        };
        return !_x._tilde || _y._tilde;
    }
    /**
        // includes reports whether t ∈ x.
    **/
    @:keep
    static public function _includes( _x:stdgo.Ref<T_term>, _t:Type_):Bool {
        @:recv var _x:stdgo.Ref<T_term> = _x;
        if (_x == null || (_x : Dynamic).__nil__) {
            return false;
        } else if (_x._typ == null) {
            return true;
        };
        var _u:stdgo.go.types.Types.Type_ = _t;
        if (_x._tilde) {
            _u = _under(_u);
        };
        return identical(_x._typ, _u);
    }
    /**
        // intersect returns the intersection x ∩ y.
    **/
    @:keep
    static public function _intersect( _x:stdgo.Ref<T_term>, _y:stdgo.Ref<T_term>):stdgo.Ref<T_term> {
        @:recv var _x:stdgo.Ref<T_term> = _x;
        if (((_x == null) || (_x : Dynamic).__nil__) || ((_y == null) || (_y : Dynamic).__nil__)) {
            return (null : stdgo.Ref<stdgo.go.types.Types.T_term>);
        } else if (_x._typ == null) {
            return _y;
        } else if (_y._typ == null) {
            return _x;
        };
        if (_x._disjoint(_y)) {
            return (null : stdgo.Ref<stdgo.go.types.Types.T_term>);
        };
        if (!_x._tilde || _y._tilde) {
            return _x;
        };
        return _y;
    }
    /**
        // union returns the union x ∪ y: zero, one, or two non-nil terms.
    **/
    @:keep
    static public function _union( _x:stdgo.Ref<T_term>, _y:stdgo.Ref<T_term>):{ var _0 : stdgo.Ref<T_term>; var _1 : stdgo.Ref<T_term>; } {
        @:recv var _x:stdgo.Ref<T_term> = _x;
        var _0:stdgo.Ref<T_term> = (null : stdgo.Ref<stdgo.go.types.Types.T_term>), _1:stdgo.Ref<T_term> = (null : stdgo.Ref<stdgo.go.types.Types.T_term>);
        if ((_x == null) || (_x : Dynamic).__nil__ && (_y == null) || (_y : Dynamic).__nil__) {
            return { _0 : (null : stdgo.Ref<stdgo.go.types.Types.T_term>), _1 : (null : stdgo.Ref<stdgo.go.types.Types.T_term>) };
        } else if (_x == null || (_x : Dynamic).__nil__) {
            return { _0 : _y, _1 : (null : stdgo.Ref<stdgo.go.types.Types.T_term>) };
        } else if (_y == null || (_y : Dynamic).__nil__) {
            return { _0 : _x, _1 : (null : stdgo.Ref<stdgo.go.types.Types.T_term>) };
        } else if (_x._typ == null) {
            return { _0 : _x, _1 : (null : stdgo.Ref<stdgo.go.types.Types.T_term>) };
        } else if (_y._typ == null) {
            return { _0 : _y, _1 : (null : stdgo.Ref<stdgo.go.types.Types.T_term>) };
        };
        if (_x._disjoint(_y)) {
            return { _0 : _x, _1 : _y };
        };
        if (_x._tilde || !_y._tilde) {
            return { _0 : _x, _1 : (null : stdgo.Ref<stdgo.go.types.Types.T_term>) };
        };
        return { _0 : _y, _1 : (null : stdgo.Ref<stdgo.go.types.Types.T_term>) };
    }
    /**
        // equal reports whether x and y represent the same type set.
    **/
    @:keep
    static public function _equal( _x:stdgo.Ref<T_term>, _y:stdgo.Ref<T_term>):Bool {
        @:recv var _x:stdgo.Ref<T_term> = _x;
        if (((_x == null) || (_x : Dynamic).__nil__) || ((_y == null) || (_y : Dynamic).__nil__)) {
            return _x == (_y);
        } else if ((_x._typ == null) || (_y._typ == null)) {
            return stdgo.Go.toInterface(_x._typ) == (stdgo.Go.toInterface(_y._typ));
        };
        return (_x._tilde == _y._tilde) && identical(_x._typ, _y._typ);
    }
    @:keep
    static public function string( _x:stdgo.Ref<T_term>):stdgo.GoString {
        @:recv var _x:stdgo.Ref<T_term> = _x;
        if (_x == null || (_x : Dynamic).__nil__) {
            return ("∅" : stdgo.GoString);
        } else if (_x._typ == null) {
            return ("𝓤" : stdgo.GoString);
        } else if (_x._tilde) {
            return ("~" : stdgo.GoString) + (_x._typ.string() : stdgo.GoString)?.__copy__()?.__copy__();
        } else {
            return (_x._typ.string() : stdgo.GoString)?.__copy__();
        };
    }
}
class T_unifier_asInterface {
    /**
        // nify implements the core unification algorithm which is an
        // adapted version of Checker.identical. For changes to that
        // code the corresponding changes should be made here.
        // Must not be called directly from outside the unifier.
    **/
    @:keep
    public dynamic function _nify(_x:Type_, _y:Type_, _mode:T_unifyMode, _p:stdgo.Ref<T_ifacePair>):Bool return __self__.value._nify(_x, _y, _mode, _p);
    /**
        // inferred returns the list of inferred types for the given type parameter list.
        // The result is never nil and has the same length as tparams; result types that
        // could not be inferred are nil. Corresponding type parameters and result types
        // have identical indices.
    **/
    @:keep
    public dynamic function _inferred(_tparams:stdgo.Slice<stdgo.Ref<TypeParam>>):stdgo.Slice<Type_> return __self__.value._inferred(_tparams);
    /**
        // unknowns returns the number of type parameters for which no type has been set yet.
    **/
    @:keep
    public dynamic function _unknowns():stdgo.GoInt return __self__.value._unknowns();
    /**
        // set sets the type t for type parameter x;
        // t must not be nil.
    **/
    @:keep
    public dynamic function _set(_x:stdgo.Ref<TypeParam>, _t:Type_):Void __self__.value._set(_x, _t);
    /**
        // at returns the (possibly nil) type for type parameter x.
    **/
    @:keep
    public dynamic function _at(_x:stdgo.Ref<TypeParam>):Type_ return __self__.value._at(_x);
    /**
        // setHandle sets the handle for type parameter x
        // (and all its joined type parameters) to h.
    **/
    @:keep
    public dynamic function _setHandle(_x:stdgo.Ref<TypeParam>, _h:stdgo.Ref<Type_>):Void __self__.value._setHandle(_x, _h);
    /**
        // asTypeParam returns x.(*TypeParam) if x is a type parameter recorded with u.
        // Otherwise, the result is nil.
    **/
    @:keep
    public dynamic function _asTypeParam(_x:Type_):stdgo.Ref<TypeParam> return __self__.value._asTypeParam(_x);
    /**
        // join unifies the given type parameters x and y.
        // If both type parameters already have a type associated with them
        // and they are not joined, join fails and returns false.
    **/
    @:keep
    public dynamic function _join(_x:stdgo.Ref<TypeParam>, _y:stdgo.Ref<TypeParam>):Bool return __self__.value._join(_x, _y);
    /**
        // String returns a string representation of the current mapping
        // from type parameters to types.
    **/
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:keep
    public dynamic function _tracef(_format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):Void __self__.value._tracef(_format, ..._args);
    /**
        // unify attempts to unify x and y and reports whether it succeeded.
        // As a side-effect, types may be inferred for type parameters.
        // The mode parameter controls how types are compared.
    **/
    @:keep
    public dynamic function _unify(_x:Type_, _y:Type_, _mode:T_unifyMode):Bool return __self__.value._unify(_x, _y, _mode);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_unifier>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_unifier_asInterface) class T_unifier_static_extension {
    /**
        // nify implements the core unification algorithm which is an
        // adapted version of Checker.identical. For changes to that
        // code the corresponding changes should be made here.
        // Must not be called directly from outside the unifier.
    **/
    @:keep
    static public function _nify( _u:stdgo.Ref<T_unifier>, _x:Type_, _y:Type_, _mode:T_unifyMode, _p:stdgo.Ref<T_ifacePair>):Bool {
        @:recv var _u:stdgo.Ref<T_unifier> = _u;
        var __deferstack__:Array<Void -> Void> = [];
        var _result:Bool = false;
        try {
            _u._depth++;
            if (false) {
                _u._tracef(("%s ≡ %s\t// %s" : stdgo.GoString), stdgo.Go.toInterface(_x), stdgo.Go.toInterface(_y), stdgo.Go.toInterface(stdgo.Go.asInterface(_mode)));
            };
            __deferstack__.unshift(() -> {
                var a = function():Void {
                    if (false && !_result) {
                        _u._tracef(("%s ≢ %s" : stdgo.GoString), stdgo.Go.toInterface(_x), stdgo.Go.toInterface(_y));
                    };
                    _u._depth--;
                };
                a();
            });
            if (stdgo.Go.toInterface(_x) == (stdgo.Go.toInterface(_y))) {
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return true;
                };
            };
            if (_u._depth > (50 : stdgo.GoInt)) {
                if (false) {
                    _u._tracef(("depth %d >= %d" : stdgo.GoString), stdgo.Go.toInterface(_u._depth), stdgo.Go.toInterface((50 : stdgo.GoInt)));
                };
                if (true) {
                    throw stdgo.Go.toInterface(("unification reached recursion depth limit" : stdgo.GoString));
                };
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return false;
                };
            };
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_x) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
                }, __0 = __tmp__._0, _ok = __tmp__._1;
                if (_ok || ((_u._asTypeParam(_y) != null) && ((_u._asTypeParam(_y) : Dynamic).__nil__ == null || !(_u._asTypeParam(_y) : Dynamic).__nil__))) {
                    if (false) {
                        _u._tracef(("%s ≡ %s\t// swap" : stdgo.GoString), stdgo.Go.toInterface(_y), stdgo.Go.toInterface(_x));
                    };
                    {
                        final __tmp__0 = _y;
                        final __tmp__1 = _x;
                        _x = __tmp__0;
                        _y = __tmp__1;
                    };
                };
            };
            {
                var __tmp__ = try {
                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
                } catch(_) {
                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
                }, _ny = __tmp__._0, __1 = __tmp__._1;
                if (((((_mode & (2u32 : stdgo.go.types.Types.T_unifyMode)) == (0u32 : stdgo.go.types.Types.T_unifyMode)) && ((_ny != null) && ((_ny : Dynamic).__nil__ == null || !(_ny : Dynamic).__nil__))) && _isTypeLit(_x)) && !(_u._enableInterfaceInference && isInterface(_x))) {
                    if (false) {
                        _u._tracef(("%s ≡ under %s" : stdgo.GoString), stdgo.Go.toInterface(_x), stdgo.Go.toInterface(stdgo.Go.asInterface(_ny)));
                    };
                    _y = _ny._under();
                    _assert(!_isTypeParam(_y));
                    if (stdgo.Go.toInterface(_x) == (stdgo.Go.toInterface(_y))) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return true;
                        };
                    };
                };
            };
            {
                var __0 = _u._asTypeParam(_x), __1 = _u._asTypeParam(_y), _py = __1, _px = __0;
                if (((_px != null) && ((_px : Dynamic).__nil__ == null || !(_px : Dynamic).__nil__)) && ((_py != null) && ((_py : Dynamic).__nil__ == null || !(_py : Dynamic).__nil__))) {
                    if (_u._join(_px, _py)) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return true;
                        };
                    };
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _u._nify(_u._at(_px), _u._at(_py), _mode, _p);
                    };
                } else if (_px != null && ((_px : Dynamic).__nil__ == null || !(_px : Dynamic).__nil__)) {
                    {
                        var _x:stdgo.go.types.Types.Type_ = _u._at(_px);
                        if (_x != null) {
                            if (_u._nify(_x, _y, _mode, _p)) {
                                var _xi = _asInterface(_x);
                                var _yi = _asInterface(_y);
                                var __tmp__ = try {
                                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_x) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
                                } catch(_) {
                                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
                                }, __10 = __tmp__._0, _xn = __tmp__._1;
                                var __tmp__ = try {
                                    { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
                                } catch(_) {
                                    { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
                                }, __11 = __tmp__._0, _yn = __tmp__._1;
                                if (((_xi != null) && ((_xi : Dynamic).__nil__ == null || !(_xi : Dynamic).__nil__)) && ((_yi != null) && ((_yi : Dynamic).__nil__ == null || !(_yi : Dynamic).__nil__))) {
                                    if (_xn && _yn) {
                                        {
                                            for (defer in __deferstack__) {
                                                defer();
                                            };
                                            return identical(_x, _y);
                                        };
                                    };
                                    if ((_xi._typeSet()._methods.length) != ((_yi._typeSet()._methods.length))) {
                                        {
                                            for (defer in __deferstack__) {
                                                defer();
                                            };
                                            return false;
                                        };
                                    };
                                } else if (((_xi != null) && ((_xi : Dynamic).__nil__ == null || !(_xi : Dynamic).__nil__)) || ((_yi != null) && ((_yi : Dynamic).__nil__ == null || !(_yi : Dynamic).__nil__))) {
                                    {
                                        for (defer in __deferstack__) {
                                            defer();
                                        };
                                        return false;
                                    };
                                };
                                if (_mode & (2u32 : stdgo.go.types.Types.T_unifyMode) == ((0u32 : stdgo.go.types.Types.T_unifyMode))) {
                                    if (_xn) {} else if (_yn) {
                                        _u._set(_px, _y);
                                    } else {
                                        {
                                            var __tmp__ = try {
                                                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_under(_y)) : stdgo.Ref<Chan>)) : stdgo.Ref<Chan>), _1 : true };
                                            } catch(_) {
                                                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Chan>), _1 : false };
                                            }, _yc = __tmp__._0, __28 = __tmp__._1;
                                            if (((_yc != null) && ((_yc : Dynamic).__nil__ == null || !(_yc : Dynamic).__nil__)) && (_yc._dir != (0 : stdgo.go.types.Types.ChanDir))) {
                                                _u._set(_px, _y);
                                            };
                                        };
                                    };
                                };
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return true;
                                };
                            };
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return false;
                            };
                        };
                    };
                    _u._set(_px, _y);
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return true;
                    };
                };
            };
            _assert(stdgo.Go.toInterface(_x) != (stdgo.Go.toInterface(_y)));
            var _emode:stdgo.go.types.Types.T_unifyMode = _mode;
            if (_mode & (1u32 : stdgo.go.types.Types.T_unifyMode) != ((0u32 : stdgo.go.types.Types.T_unifyMode))) {
                _emode = _emode | ((2u32 : stdgo.go.types.Types.T_unifyMode));
            };
            if (_u._enableInterfaceInference && ((_mode & (2u32 : stdgo.go.types.Types.T_unifyMode)) == (0u32 : stdgo.go.types.Types.T_unifyMode))) {
                var _xi = _asInterface(_x);
                var _yi = _asInterface(_y);
                if (((_xi != null) && ((_xi : Dynamic).__nil__ == null || !(_xi : Dynamic).__nil__)) && ((_yi != null) && ((_yi : Dynamic).__nil__ == null || !(_yi : Dynamic).__nil__))) {
                    var _xset = _xi._typeSet();
                    var _yset = _yi._typeSet();
                    if (_xset._comparable != (_yset._comparable)) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return false;
                        };
                    };
                    if (!_xset._terms._equal(_yset._terms)) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return false;
                        };
                    };
                    var _q = (stdgo.Go.setRef((new stdgo.go.types.Types.T_ifacePair(_xi, _yi, _p) : stdgo.go.types.Types.T_ifacePair)) : stdgo.Ref<stdgo.go.types.Types.T_ifacePair>);
                    while (_p != null && ((_p : Dynamic).__nil__ == null || !(_p : Dynamic).__nil__)) {
                        if (_p._identical(_q)) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return true;
                            };
                        };
                        _p = _p._prev;
                    };
                    var _xmethods = _xset._methods;
                    var _ymethods = _yset._methods;
                    if ((_xmethods.length) > (_ymethods.length)) {
                        {
                            final __tmp__0 = _ymethods;
                            final __tmp__1 = _xmethods;
                            _xmethods = __tmp__0;
                            _ymethods = __tmp__1;
                        };
                    };
                    var _ymap = ({
                        final x = new stdgo.GoMap.GoStringMap<stdgo.Ref<stdgo.go.types.Types.Func>>();
                        x.__defaultValue__ = () -> (null : stdgo.Ref<stdgo.go.types.Types.Func>);
                        @:mergeBlock {};
                        x;
                    } : stdgo.GoMap<stdgo.GoString, stdgo.Ref<stdgo.go.types.Types.Func>>);
                    for (__77 => _ym in _ymethods) {
                        _ymap[_ym.id()] = _ym;
                    };
                    for (__78 => _xm in _xmethods) {
                        {
                            var _ym = (_ymap[_xm.id()] ?? (null : stdgo.Ref<stdgo.go.types.Types.Func>));
                            if (((_ym == null) || (_ym : Dynamic).__nil__) || !_u._nify(_xm._object._typ, _ym._object._typ, (2u32 : stdgo.go.types.Types.T_unifyMode), _p)) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return false;
                                };
                            };
                        };
                    };
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return true;
                    };
                };
                if (_yi != null && ((_yi : Dynamic).__nil__ == null || !(_yi : Dynamic).__nil__)) {
                    _xi = _yi;
                    _y = _x;
                };
                if (_xi != null && ((_xi : Dynamic).__nil__ == null || !(_xi : Dynamic).__nil__)) {
                    var _xmethods = _xi._typeSet()._methods;
                    for (__87 => _xm in _xmethods) {
                        var __tmp__ = lookupFieldOrMethod(_y, false, _xm._object._pkg, _xm._object._name?.__copy__()), _obj:stdgo.go.types.Types.Object = __tmp__._0, __88:stdgo.Slice<stdgo.GoInt> = __tmp__._1, __89:Bool = __tmp__._2;
                        {
                            var __tmp__ = try {
                                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_obj) : stdgo.Ref<Func>)) : stdgo.Ref<Func>), _1 : true };
                            } catch(_) {
                                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Func>), _1 : false };
                            }, _ym = __tmp__._0, __90 = __tmp__._1;
                            if (((_ym == null) || (_ym : Dynamic).__nil__) || !_u._nify(_xm._object._typ, _ym._object._typ, (2u32 : stdgo.go.types.Types.T_unifyMode), _p)) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return false;
                                };
                            };
                        };
                    };
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return true;
                    };
                };
            };
            if (_isTypeParam(_y)) {
                if (false) {
                    _u._tracef(("%s ≡ %s\t// swap" : stdgo.GoString), stdgo.Go.toInterface(_y), stdgo.Go.toInterface(_x));
                };
                {
                    final __tmp__0 = _y;
                    final __tmp__1 = _x;
                    _x = __tmp__0;
                    _y = __tmp__1;
                };
            };
            {
                final __type__ = _x;
                if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Basic>))) {
                    var _x:stdgo.Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Basic>)) : stdgo.Ref<Basic>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Basic>), _1 : false };
                        }, _y = __tmp__._0, _ok = __tmp__._1;
                        if (_ok) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _x._kind == (_y._kind);
                            };
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Array_>))) {
                    var _x:stdgo.Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Array_>)) : stdgo.Ref<Array_>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Array_>), _1 : false };
                        }, _y = __tmp__._0, _ok = __tmp__._1;
                        if (_ok) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return (((_x._len < (0i64 : stdgo.GoInt64)) || (_y._len < (0i64 : stdgo.GoInt64))) || (_x._len == _y._len)) && _u._nify(_x._elem, _y._elem, _emode, _p);
                            };
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Slice_>))) {
                    var _x:stdgo.Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Slice_>)) : stdgo.Ref<Slice_>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Slice_>), _1 : false };
                        }, _y = __tmp__._0, _ok = __tmp__._1;
                        if (_ok) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _u._nify(_x._elem, _y._elem, _emode, _p);
                            };
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Struct>))) {
                    var _x:stdgo.Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Struct>)) : stdgo.Ref<Struct>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Struct>), _1 : false };
                        }, _y = __tmp__._0, _ok = __tmp__._1;
                        if (_ok) {
                            if (_x.numFields() == (_y.numFields())) {
                                for (_i => _f in _x._fields) {
                                    var _g = _y._fields[(_i : stdgo.GoInt)];
                                    if ((((_f._embedded != _g._embedded) || (_x.tag(_i) != _y.tag(_i))) || !_f._sameId(_g._object._pkg, _g._object._name?.__copy__())) || !_u._nify(_f._object._typ, _g._object._typ, _emode, _p)) {
                                        {
                                            for (defer in __deferstack__) {
                                                defer();
                                            };
                                            return false;
                                        };
                                    };
                                };
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return true;
                                };
                            };
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Pointer_>))) {
                    var _x:stdgo.Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Pointer_>)) : stdgo.Ref<Pointer_>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Pointer_>), _1 : false };
                        }, _y = __tmp__._0, _ok = __tmp__._1;
                        if (_ok) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _u._nify(_x._base, _y._base, _emode, _p);
                            };
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Tuple>))) {
                    var _x:stdgo.Ref<stdgo.go.types.Types.Tuple> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Tuple>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Tuple>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Tuple>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Tuple>)) : stdgo.Ref<Tuple>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Tuple>), _1 : false };
                        }, _y = __tmp__._0, _ok = __tmp__._1;
                        if (_ok) {
                            if (_x.len() == (_y.len())) {
                                if (_x != null && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) {
                                    for (_i => _v in _x._vars) {
                                        var _w = _y._vars[(_i : stdgo.GoInt)];
                                        if (!_u._nify(_v._object._typ, _w._object._typ, _mode, _p)) {
                                            {
                                                for (defer in __deferstack__) {
                                                    defer();
                                                };
                                                return false;
                                            };
                                        };
                                    };
                                };
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return true;
                                };
                            };
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Signature>))) {
                    var _x:stdgo.Ref<stdgo.go.types.Types.Signature> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Signature>)) : stdgo.Ref<Signature>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Signature>), _1 : false };
                        }, _y = __tmp__._0, _ok = __tmp__._1;
                        if (_ok) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return ((_x._variadic == _y._variadic) && _u._nify(stdgo.Go.asInterface(_x._params), stdgo.Go.asInterface(_y._params), _emode, _p)) && _u._nify(stdgo.Go.asInterface(_x._results), stdgo.Go.asInterface(_y._results), _emode, _p);
                            };
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Interface>))) {
                    var _x:stdgo.Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                    _assert(!_u._enableInterfaceInference || ((_mode & (2u32 : stdgo.go.types.Types.T_unifyMode)) != (0u32 : stdgo.go.types.Types.T_unifyMode)));
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Interface>)) : stdgo.Ref<Interface>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Interface>), _1 : false };
                        }, _y = __tmp__._0, _ok = __tmp__._1;
                        if (_ok) {
                            var _xset = _x._typeSet();
                            var _yset = _y._typeSet();
                            if (_xset._comparable != (_yset._comparable)) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return false;
                                };
                            };
                            if (!_xset._terms._equal(_yset._terms)) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return false;
                                };
                            };
                            var _a = _xset._methods;
                            var _b = _yset._methods;
                            if ((_a.length) == ((_b.length))) {
                                var _q = (stdgo.Go.setRef((new stdgo.go.types.Types.T_ifacePair(_x, _y, _p) : stdgo.go.types.Types.T_ifacePair)) : stdgo.Ref<stdgo.go.types.Types.T_ifacePair>);
                                while (_p != null && ((_p : Dynamic).__nil__ == null || !(_p : Dynamic).__nil__)) {
                                    if (_p._identical(_q)) {
                                        {
                                            for (defer in __deferstack__) {
                                                defer();
                                            };
                                            return true;
                                        };
                                    };
                                    _p = _p._prev;
                                };
                                if (false) {
                                    _assertSortedMethods(_a);
                                    _assertSortedMethods(_b);
                                };
                                for (_i => _f in _a) {
                                    var _g = _b[(_i : stdgo.GoInt)];
                                    if ((_f.id() != _g.id()) || !_u._nify(_f._object._typ, _g._object._typ, (2u32 : stdgo.go.types.Types.T_unifyMode), _q)) {
                                        {
                                            for (defer in __deferstack__) {
                                                defer();
                                            };
                                            return false;
                                        };
                                    };
                                };
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return true;
                                };
                            };
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Map_>))) {
                    var _x:stdgo.Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Map_>)) : stdgo.Ref<Map_>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Map_>), _1 : false };
                        }, _y = __tmp__._0, _ok = __tmp__._1;
                        if (_ok) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _u._nify(_x._key, _y._key, _emode, _p) && _u._nify(_x._elem, _y._elem, _emode, _p);
                            };
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Chan>))) {
                    var _x:stdgo.Ref<stdgo.go.types.Types.Chan> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Chan>)) : stdgo.Ref<Chan>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Chan>), _1 : false };
                        }, _y = __tmp__._0, _ok = __tmp__._1;
                        if (_ok) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return (((_mode & (2u32 : stdgo.go.types.Types.T_unifyMode)) == (0u32 : stdgo.go.types.Types.T_unifyMode)) || (_x._dir == _y._dir)) && _u._nify(_x._elem, _y._elem, _emode, _p);
                            };
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<Named>))) {
                    var _x:stdgo.Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_y) : stdgo.Ref<Named>)) : stdgo.Ref<Named>), _1 : true };
                        } catch(_) {
                            { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Named>), _1 : false };
                        }, _y = __tmp__._0, _ok = __tmp__._1;
                        if (_ok) {
                            var _xargs = _x.typeArgs()._list();
                            var _yargs = _y.typeArgs()._list();
                            if ((_xargs.length) != ((_yargs.length))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return false;
                                };
                            };
                            for (_i => _xarg in _xargs) {
                                if (!_u._nify(_xarg, _yargs[(_i : stdgo.GoInt)], _mode, _p)) {
                                    {
                                        for (defer in __deferstack__) {
                                            defer();
                                        };
                                        return false;
                                    };
                                };
                            };
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _indenticalOrigin(_x, _y);
                            };
                        };
                    };
                } else if (stdgo.Go.typeEquals((__type__ : stdgo.Ref<TypeParam>))) {
                    var _x:stdgo.Ref<stdgo.go.types.Types.TypeParam> = __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__() == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__ == null ? (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__().value;
                    if (false) {
                        _assert(_u._asTypeParam(stdgo.Go.asInterface(_x)) == null || (_u._asTypeParam(stdgo.Go.asInterface(_x)) : Dynamic).__nil__);
                    };
                    if (true) {
                        {
                            var _cx:stdgo.go.types.Types.Type_ = _coreType(stdgo.Go.asInterface(_x));
                            if (_cx != null) {
                                if (false) {
                                    _u._tracef(("core %s ≡ %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(_y));
                                };
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _u._nify(_cx, _y, (1u32 : stdgo.go.types.Types.T_unifyMode), _p);
                                };
                            };
                        };
                    };
                } else if (__type__ == null) {
                    var _x:stdgo.AnyInterface = __type__ == null ? (null : stdgo.AnyInterface) : cast __type__;
                } else {
                    var _x:stdgo.go.types.Types.Type_ = __type__ == null ? (null : stdgo.go.types.Types.Type_) : cast __type__;
                    throw stdgo.Go.toInterface(_sprintf(null, null, true, ("u.nify(%s, %s, %d)" : stdgo.GoString), stdgo.Go.toInterface(_x), stdgo.Go.toInterface(_y), stdgo.Go.toInterface(stdgo.Go.asInterface(_mode))));
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return false;
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return _result;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return _result;
        };
    }
    /**
        // inferred returns the list of inferred types for the given type parameter list.
        // The result is never nil and has the same length as tparams; result types that
        // could not be inferred are nil. Corresponding type parameters and result types
        // have identical indices.
    **/
    @:keep
    static public function _inferred( _u:stdgo.Ref<T_unifier>, _tparams:stdgo.Slice<stdgo.Ref<TypeParam>>):stdgo.Slice<Type_> {
        @:recv var _u:stdgo.Ref<T_unifier> = _u;
        var _list = new stdgo.Slice<stdgo.go.types.Types.Type_>((_tparams.length : stdgo.GoInt).toBasic(), 0);
        for (_i => _x in _tparams) {
            _list[(_i : stdgo.GoInt)] = _u._at(_x);
        };
        return _list;
    }
    /**
        // unknowns returns the number of type parameters for which no type has been set yet.
    **/
    @:keep
    static public function _unknowns( _u:stdgo.Ref<T_unifier>):stdgo.GoInt {
        @:recv var _u:stdgo.Ref<T_unifier> = _u;
        var _n:stdgo.GoInt = (0 : stdgo.GoInt);
        for (__0 => _h in _u._handles) {
            if ((_h : stdgo.go.types.Types.Type_) == null) {
                _n++;
            };
        };
        return _n;
    }
    /**
        // set sets the type t for type parameter x;
        // t must not be nil.
    **/
    @:keep
    static public function _set( _u:stdgo.Ref<T_unifier>, _x:stdgo.Ref<TypeParam>, _t:Type_):Void {
        @:recv var _u:stdgo.Ref<T_unifier> = _u;
        _assert(_t != null);
        if (false) {
            _u._tracef(("%s ➞ %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(_t));
        };
        {
            var __tmp__ = _t;
            (_u._handles[_x] ?? (null : stdgo.Ref<stdgo.go.types.Types.Type_>)).string = __tmp__.string;
            (_u._handles[_x] ?? (null : stdgo.Ref<stdgo.go.types.Types.Type_>)).underlying = __tmp__.underlying;
        };
    }
    /**
        // at returns the (possibly nil) type for type parameter x.
    **/
    @:keep
    static public function _at( _u:stdgo.Ref<T_unifier>, _x:stdgo.Ref<TypeParam>):Type_ {
        @:recv var _u:stdgo.Ref<T_unifier> = _u;
        return (_u._handles[_x] ?? (null : stdgo.Ref<stdgo.go.types.Types.Type_>) : stdgo.go.types.Types.Type_);
    }
    /**
        // setHandle sets the handle for type parameter x
        // (and all its joined type parameters) to h.
    **/
    @:keep
    static public function _setHandle( _u:stdgo.Ref<T_unifier>, _x:stdgo.Ref<TypeParam>, _h:stdgo.Ref<Type_>):Void {
        @:recv var _u:stdgo.Ref<T_unifier> = _u;
        var _hx = (_u._handles[_x] ?? (null : stdgo.Ref<stdgo.go.types.Types.Type_>));
        _assert(_hx != null && ((_hx : Dynamic).__nil__ == null || !(_hx : Dynamic).__nil__));
        for (_y => _hy in _u._handles) {
            if (stdgo.Go.toInterface(_hy) == (stdgo.Go.toInterface(_hx))) {
                _u._handles[_y] = _h;
            };
        };
    }
    /**
        // asTypeParam returns x.(*TypeParam) if x is a type parameter recorded with u.
        // Otherwise, the result is nil.
    **/
    @:keep
    static public function _asTypeParam( _u:stdgo.Ref<T_unifier>, _x:Type_):stdgo.Ref<TypeParam> {
        @:recv var _u:stdgo.Ref<T_unifier> = _u;
        {
            var __tmp__ = try {
                { _0 : (stdgo.Go.typeAssert((stdgo.Go.toInterface(_x) : stdgo.Ref<TypeParam>)) : stdgo.Ref<TypeParam>), _1 : true };
            } catch(_) {
                { _0 : (null : stdgo.Ref<stdgo.go.types.Types.TypeParam>), _1 : false };
            }, _x = __tmp__._0, __0 = __tmp__._1;
            if (_x != null && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) {
                {
                    var __tmp__ = (_u._handles != null && _u._handles.exists(_x) ? { _0 : _u._handles[_x], _1 : true } : { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Type_>), _1 : false }), __1:stdgo.Ref<stdgo.go.types.Types.Type_> = __tmp__._0, _found:Bool = __tmp__._1;
                    if (_found) {
                        return _x;
                    };
                };
            };
        };
        return null;
    }
    /**
        // join unifies the given type parameters x and y.
        // If both type parameters already have a type associated with them
        // and they are not joined, join fails and returns false.
    **/
    @:keep
    static public function _join( _u:stdgo.Ref<T_unifier>, _x:stdgo.Ref<TypeParam>, _y:stdgo.Ref<TypeParam>):Bool {
        @:recv var _u:stdgo.Ref<T_unifier> = _u;
        if (false) {
            _u._tracef(("%s ⇄ %s" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_x)), stdgo.Go.toInterface(stdgo.Go.asInterface(_y)));
        };
        {
            var __0 = (_u._handles[_x] ?? (null : stdgo.Ref<stdgo.go.types.Types.Type_>)), __1 = (_u._handles[_y] ?? (null : stdgo.Ref<stdgo.go.types.Types.Type_>)), _hy = __1, _hx = __0;
            if (stdgo.Go.toInterface(_hx) == (stdgo.Go.toInterface(_hy))) {} else if (((_hx : stdgo.go.types.Types.Type_) != null) && ((_hy : stdgo.go.types.Types.Type_) != null)) {
                return false;
            } else if ((_hx : stdgo.go.types.Types.Type_) != null) {
                _u._setHandle(_y, _hx);
            } else {
                _u._setHandle(_x, _hy);
            };
        };
        return true;
    }
    /**
        // String returns a string representation of the current mapping
        // from type parameters to types.
    **/
    @:keep
    static public function string( _u:stdgo.Ref<T_unifier>):stdgo.GoString {
        @:recv var _u:stdgo.Ref<T_unifier> = _u;
        var _tparams:stdgo.go.types.Types.T_typeParamsById = new stdgo.Slice<stdgo.Ref<stdgo.go.types.Types.TypeParam>>((_u._handles.length : stdgo.GoInt).toBasic(), 0);
        var _i:stdgo.GoInt = (0 : stdgo.GoInt);
        for (_tpar => _ in _u._handles) {
            _tparams[(_i : stdgo.GoInt)] = _tpar;
            _i++;
        };
        stdgo.sort.Sort.sort(stdgo.Go.asInterface(_tparams));
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        var _w = _newTypeWriter((stdgo.Go.setRef(_buf) : stdgo.Ref<stdgo.bytes.Bytes.Buffer>), null);
        _w._byte((91 : stdgo.GoUInt8));
        for (_i => _x in _tparams) {
            if (_i > (0 : stdgo.GoInt)) {
                _w._string((", " : stdgo.GoString));
            };
            _w._typ(stdgo.Go.asInterface(_x));
            _w._string((": " : stdgo.GoString));
            _w._typ(_u._at(_x));
        };
        _w._byte((93 : stdgo.GoUInt8));
        return (_buf.string() : stdgo.GoString)?.__copy__();
    }
    @:keep
    static public function _tracef( _u:stdgo.Ref<T_unifier>, _format:stdgo.GoString, _args:haxe.Rest<stdgo.AnyInterface>):Void {
        var _args = new stdgo.Slice<stdgo.AnyInterface>(_args.length, 0, ..._args);
        @:recv var _u:stdgo.Ref<T_unifier> = _u;
        stdgo.fmt.Fmt.println(stdgo.Go.toInterface(stdgo.strings.Strings.repeat((".  " : stdgo.GoString), _u._depth) + _sprintf(null, null, true, _format?.__copy__(), ..._args.__toArray__())?.__copy__()));
    }
    /**
        // unify attempts to unify x and y and reports whether it succeeded.
        // As a side-effect, types may be inferred for type parameters.
        // The mode parameter controls how types are compared.
    **/
    @:keep
    static public function _unify( _u:stdgo.Ref<T_unifier>, _x:Type_, _y:Type_, _mode:T_unifyMode):Bool {
        @:recv var _u:stdgo.Ref<T_unifier> = _u;
        return _u._nify(_x, _y, _mode, null);
    }
}
class Union_asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type_ return __self__.value.underlying();
    @:keep
    public dynamic function term(_i:stdgo.GoInt):stdgo.Ref<Term> return __self__.value.term(_i);
    @:keep
    public dynamic function len():stdgo.GoInt return __self__.value.len();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Union>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Union_asInterface) class Union_static_extension {
    @:keep
    static public function string( _u:stdgo.Ref<Union>):stdgo.GoString {
        @:recv var _u:stdgo.Ref<Union> = _u;
        return typeString(stdgo.Go.asInterface(_u), null)?.__copy__();
    }
    @:keep
    static public function underlying( _u:stdgo.Ref<Union>):Type_ {
        @:recv var _u:stdgo.Ref<Union> = _u;
        return stdgo.Go.asInterface(_u);
    }
    @:keep
    static public function term( _u:stdgo.Ref<Union>, _i:stdgo.GoInt):stdgo.Ref<Term> {
        @:recv var _u:stdgo.Ref<Union> = _u;
        return _u._terms[(_i : stdgo.GoInt)];
    }
    @:keep
    static public function len( _u:stdgo.Ref<Union>):stdgo.GoInt {
        @:recv var _u:stdgo.Ref<Union> = _u;
        return (_u._terms.length);
    }
}
class T_version_asInterface {
    @:keep
    public dynamic function _after(_u:T_version):Bool return __self__.value._after(_u);
    @:keep
    public dynamic function _before(_u:T_version):Bool return __self__.value._before(_u);
    @:keep
    public dynamic function _equal(_u:T_version):Bool return __self__.value._equal(_u);
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_version>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_version_asInterface) class T_version_static_extension {
    @:keep
    static public function _after( _v:T_version, _u:T_version):Bool {
        @:recv var _v:T_version = _v?.__copy__();
        return (_v._major > _u._major) || ((_v._major == _u._major) && (_v._minor > _u._minor));
    }
    @:keep
    static public function _before( _v:T_version, _u:T_version):Bool {
        @:recv var _v:T_version = _v?.__copy__();
        return (_v._major < _u._major) || ((_v._major == _u._major) && (_v._minor < _u._minor));
    }
    @:keep
    static public function _equal( _v:T_version, _u:T_version):Bool {
        @:recv var _v:T_version = _v?.__copy__();
        return (_v._major == _u._major) && (_v._minor == _u._minor);
    }
    @:keep
    static public function string( _v:T_version):stdgo.GoString {
        @:recv var _v:T_version = _v?.__copy__();
        return stdgo.fmt.Fmt.sprintf(("go%d.%d" : stdgo.GoString), stdgo.Go.toInterface(_v._major), stdgo.Go.toInterface(_v._minor))?.__copy__();
    }
}
class T_atPos_asInterface {
    @:keep
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_atPos>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_atPos_asInterface) class T_atPos_static_extension {
    @:keep
    static public function pos( _s:T_atPos):stdgo.go.token.Token.Pos {
        @:recv var _s:T_atPos = _s;
        return (_s : stdgo.go.token.Token.Pos);
    }
}
class T_nodeSet_asInterface {
    @:keep
    public dynamic function _add(_p:stdgo.Ref<T_graphNode>):Void __self__.value._add(_p);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_nodeSet>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_nodeSet_asInterface) class T_nodeSet_static_extension {
    @:keep
    static public function _add( _s:stdgo.Ref<T_nodeSet>, _p:stdgo.Ref<T_graphNode>):Void {
        @:recv var _s:stdgo.Ref<T_nodeSet> = _s;
        if ((_s : stdgo.go.types.Types.T_nodeSet) == null) {
            _s.__setData__(({
                final x = new stdgo.GoMap.GoRefMap<stdgo.Ref<stdgo.go.types.Types.T_graphNode>, Bool>();
                @:mergeBlock {};
                cast x;
            } : stdgo.GoMap<stdgo.Ref<stdgo.go.types.Types.T_graphNode>, Bool>));
        };
        ((_s : stdgo.go.types.Types.T_nodeSet))[_p] = true;
    }
}
class T_nodeQueue_asInterface {
    @:keep
    public dynamic function pop():stdgo.AnyInterface return __self__.value.pop();
    @:keep
    public dynamic function push(_x:stdgo.AnyInterface):Void __self__.value.push(_x);
    @:keep
    public dynamic function less(_i:stdgo.GoInt, _j:stdgo.GoInt):Bool return __self__.value.less(_i, _j);
    @:keep
    public dynamic function swap(_i:stdgo.GoInt, _j:stdgo.GoInt):Void __self__.value.swap(_i, _j);
    @:keep
    public dynamic function len():stdgo.GoInt return __self__.value.len();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_nodeQueue>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_nodeQueue_asInterface) class T_nodeQueue_static_extension {
    @:keep
    static public function pop( _a:stdgo.Ref<T_nodeQueue>):stdgo.AnyInterface {
        @:recv var _a:stdgo.Ref<T_nodeQueue> = _a;
        var _n:stdgo.GoInt = ((_a : stdgo.go.types.Types.T_nodeQueue).length);
        var _x = ((_a : stdgo.go.types.Types.T_nodeQueue))[(_n - (1 : stdgo.GoInt) : stdgo.GoInt)];
        _x._index = (-1 : stdgo.GoInt);
        _a.__setData__((((_a : stdgo.go.types.Types.T_nodeQueue)).__slice__(0, _n - (1 : stdgo.GoInt)) : stdgo.go.types.Types.T_nodeQueue));
        return stdgo.Go.toInterface(stdgo.Go.asInterface(_x));
    }
    @:keep
    static public function push( _a:stdgo.Ref<T_nodeQueue>, _x:stdgo.AnyInterface):Void {
        @:recv var _a:stdgo.Ref<T_nodeQueue> = _a;
        throw stdgo.Go.toInterface(("unreachable" : stdgo.GoString));
    }
    @:keep
    static public function less( _a:T_nodeQueue, _i:stdgo.GoInt, _j:stdgo.GoInt):Bool {
        @:recv var _a:T_nodeQueue = _a;
        var __0 = _a[(_i : stdgo.GoInt)], __1 = _a[(_j : stdgo.GoInt)], _y = __1, _x = __0;
        return (_x._ndeps < _y._ndeps) || ((_x._ndeps == _y._ndeps) && (_x._obj._order() < _y._obj._order()));
    }
    @:keep
    static public function swap( _a:T_nodeQueue, _i:stdgo.GoInt, _j:stdgo.GoInt):Void {
        @:recv var _a:T_nodeQueue = _a;
        var __0 = _a[(_i : stdgo.GoInt)], __1 = _a[(_j : stdgo.GoInt)], _y = __1, _x = __0;
        {
            final __tmp__0 = _y;
            final __tmp__1 = _x;
            _a[(_i : stdgo.GoInt)] = __tmp__0;
            _a[(_j : stdgo.GoInt)] = __tmp__1;
        };
        {
            final __tmp__0 = _j;
            final __tmp__1 = _i;
            _x._index = __tmp__0;
            _y._index = __tmp__1;
        };
    }
    @:keep
    static public function len( _a:T_nodeQueue):stdgo.GoInt {
        @:recv var _a:T_nodeQueue = _a;
        return (_a.length);
    }
}
class T_methodSet_asInterface {
    @:keep
    public dynamic function _addOne(_f:stdgo.Ref<Func>, _index:stdgo.Slice<stdgo.GoInt>, _indirect:Bool, _multiples:Bool):T_methodSet return __self__.value._addOne(_f, _index, _indirect, _multiples);
    /**
        // Add adds all functions in list to the method set s.
        // If multiples is set, every function in list appears multiple times
        // and is treated as a collision.
    **/
    @:keep
    public dynamic function _add(_list:stdgo.Slice<stdgo.Ref<Func>>, _index:stdgo.Slice<stdgo.GoInt>, _indirect:Bool, _multiples:Bool):T_methodSet return __self__.value._add(_list, _index, _indirect, _multiples);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_methodSet>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_methodSet_asInterface) class T_methodSet_static_extension {
    @:keep
    static public function _addOne( _s:T_methodSet, _f:stdgo.Ref<Func>, _index:stdgo.Slice<stdgo.GoInt>, _indirect:Bool, _multiples:Bool):T_methodSet {
        @:recv var _s:T_methodSet = _s;
        if (_s == null) {
            _s = ({
                final x = new stdgo.GoMap.GoStringMap<stdgo.Ref<stdgo.go.types.Types.Selection>>();
                x.__defaultValue__ = () -> (null : stdgo.Ref<stdgo.go.types.Types.Selection>);
                @:mergeBlock {};
                x;
            } : stdgo.GoMap<stdgo.GoString, stdgo.Ref<stdgo.go.types.Types.Selection>>);
        };
        var _key:stdgo.GoString = _f.id()?.__copy__();
        if (!_multiples) {
            {
                var __tmp__ = (_s != null && _s.exists(_key?.__copy__()) ? { _0 : _s[_key?.__copy__()], _1 : true } : { _0 : (null : stdgo.Ref<stdgo.go.types.Types.Selection>), _1 : false }), __0:stdgo.Ref<stdgo.go.types.Types.Selection> = __tmp__._0, _found:Bool = __tmp__._1;
                if (!_found && (_indirect || !_f._hasPtrRecv())) {
                    _s[_key] = (stdgo.Go.setRef((new stdgo.go.types.Types.Selection((1 : stdgo.go.types.Types.SelectionKind), (null : stdgo.go.types.Types.Type_), stdgo.Go.asInterface(_f), _index, _indirect) : stdgo.go.types.Types.Selection)) : stdgo.Ref<stdgo.go.types.Types.Selection>);
                    return _s;
                };
            };
        };
        _s[_key] = null;
        return _s;
    }
    /**
        // Add adds all functions in list to the method set s.
        // If multiples is set, every function in list appears multiple times
        // and is treated as a collision.
    **/
    @:keep
    static public function _add( _s:T_methodSet, _list:stdgo.Slice<stdgo.Ref<Func>>, _index:stdgo.Slice<stdgo.GoInt>, _indirect:Bool, _multiples:Bool):T_methodSet {
        @:recv var _s:T_methodSet = _s;
        if ((_list.length) == ((0 : stdgo.GoInt))) {
            return _s;
        };
        for (_i => _f in _list) {
            _s = _s._addOne(_f, _concat(_index, _i), _indirect, _multiples);
        };
        return _s;
    }
}
class T_color_asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_color>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_color_asInterface) class T_color_static_extension {
    @:keep
    static public function string( _c:T_color):stdgo.GoString {
        @:recv var _c:T_color = _c;
        {
            final __value__ = _c;
            if (__value__ == ((0u32 : stdgo.go.types.Types.T_color))) {
                return ("white" : stdgo.GoString);
            } else if (__value__ == ((1u32 : stdgo.go.types.Types.T_color))) {
                return ("black" : stdgo.GoString);
            } else {
                return ("grey" : stdgo.GoString);
            };
        };
    }
}
class T_objset_asInterface {
    /**
        // insert attempts to insert an object obj into objset s.
        // If s already contains an alternative object alt with
        // the same name, insert leaves s unchanged and returns alt.
        // Otherwise it inserts obj and returns nil.
    **/
    @:keep
    public dynamic function _insert(_obj:Object):Object return __self__.value._insert(_obj);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_objset>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_objset_asInterface) class T_objset_static_extension {
    /**
        // insert attempts to insert an object obj into objset s.
        // If s already contains an alternative object alt with
        // the same name, insert leaves s unchanged and returns alt.
        // Otherwise it inserts obj and returns nil.
    **/
    @:keep
    static public function _insert( _s:stdgo.Ref<T_objset>, _obj:Object):Object {
        @:recv var _s:stdgo.Ref<T_objset> = _s;
        var _id:stdgo.GoString = _obj.id()?.__copy__();
        {
            var _alt:stdgo.go.types.Types.Object = (((_s : stdgo.go.types.Types.T_objset))[_id] ?? (null : stdgo.go.types.Types.Object));
            if (_alt != null) {
                return _alt;
            };
        };
        if ((_s : stdgo.go.types.Types.T_objset) == null) {
            _s.__setData__(({
                final x = new stdgo.GoMap.GoStringMap<stdgo.go.types.Types.Object>();
                x.__defaultValue__ = () -> (null : stdgo.go.types.Types.Object);
                @:mergeBlock {};
                x;
            } : stdgo.GoMap<stdgo.GoString, stdgo.go.types.Types.Object>));
        };
        ((_s : stdgo.go.types.Types.T_objset))[_id] = _obj;
        return (null : stdgo.go.types.Types.Object);
    }
}
class T_inSourceOrder_asInterface {
    @:keep
    public dynamic function swap(_i:stdgo.GoInt, _j:stdgo.GoInt):Void __self__.value.swap(_i, _j);
    @:keep
    public dynamic function less(_i:stdgo.GoInt, _j:stdgo.GoInt):Bool return __self__.value.less(_i, _j);
    @:keep
    public dynamic function len():stdgo.GoInt return __self__.value.len();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_inSourceOrder>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_inSourceOrder_asInterface) class T_inSourceOrder_static_extension {
    @:keep
    static public function swap( _a:T_inSourceOrder, _i:stdgo.GoInt, _j:stdgo.GoInt):Void {
        @:recv var _a:T_inSourceOrder = _a;
        {
            final __tmp__0 = _a[(_j : stdgo.GoInt)];
            final __tmp__1 = _a[(_i : stdgo.GoInt)];
            _a[(_i : stdgo.GoInt)] = __tmp__0;
            _a[(_j : stdgo.GoInt)] = __tmp__1;
        };
    }
    @:keep
    static public function less( _a:T_inSourceOrder, _i:stdgo.GoInt, _j:stdgo.GoInt):Bool {
        @:recv var _a:T_inSourceOrder = _a;
        return _a[(_i : stdgo.GoInt)]._order() < _a[(_j : stdgo.GoInt)]._order();
    }
    @:keep
    static public function len( _a:T_inSourceOrder):stdgo.GoInt {
        @:recv var _a:T_inSourceOrder = _a;
        return (_a.length);
    }
}
class T_substMap_asInterface {
    @:keep
    public dynamic function _lookup(_tpar:stdgo.Ref<TypeParam>):Type_ return __self__.value._lookup(_tpar);
    @:keep
    public dynamic function _empty():Bool return __self__.value._empty();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_substMap>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_substMap_asInterface) class T_substMap_static_extension {
    @:keep
    static public function _lookup( _m:T_substMap, _tpar:stdgo.Ref<TypeParam>):Type_ {
        @:recv var _m:T_substMap = _m;
        {
            var _t:stdgo.go.types.Types.Type_ = (_m[_tpar] ?? (null : stdgo.go.types.Types.Type_));
            if (_t != null) {
                return _t;
            };
        };
        return stdgo.Go.asInterface(_tpar);
    }
    @:keep
    static public function _empty( _m:T_substMap):Bool {
        @:recv var _m:T_substMap = _m;
        return (_m.length) == ((0 : stdgo.GoInt));
    }
}
class T_termlist_asInterface {
    /**
        // subsetOf reports whether xl ⊆ yl.
    **/
    @:keep
    public dynamic function _subsetOf(_yl:T_termlist):Bool return __self__.value._subsetOf(_yl);
    /**
        // supersetOf reports whether y ⊆ xl.
    **/
    @:keep
    public dynamic function _supersetOf(_y:stdgo.Ref<T_term>):Bool return __self__.value._supersetOf(_y);
    /**
        // includes reports whether t ∈ xl.
    **/
    @:keep
    public dynamic function _includes(_t:Type_):Bool return __self__.value._includes(_t);
    /**
        // equal reports whether xl and yl represent the same type set.
    **/
    @:keep
    public dynamic function _equal(_yl:T_termlist):Bool return __self__.value._equal(_yl);
    /**
        // intersect returns the intersection xl ∩ yl.
    **/
    @:keep
    public dynamic function _intersect(_yl:T_termlist):T_termlist return __self__.value._intersect(_yl);
    /**
        // union returns the union xl ∪ yl.
    **/
    @:keep
    public dynamic function _union(_yl:T_termlist):T_termlist return __self__.value._union(_yl);
    /**
        // norm returns the normal form of xl.
    **/
    @:keep
    public dynamic function _norm():T_termlist return __self__.value._norm();
    /**
        // isAll reports whether the termlist xl represents the set of all types.
    **/
    @:keep
    public dynamic function _isAll():Bool return __self__.value._isAll();
    /**
        // isEmpty reports whether the termlist xl represents the empty set of types.
    **/
    @:keep
    public dynamic function _isEmpty():Bool return __self__.value._isEmpty();
    /**
        // String prints the termlist exactly (without normalization).
    **/
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_termlist>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_termlist_asInterface) class T_termlist_static_extension {
    /**
        // subsetOf reports whether xl ⊆ yl.
    **/
    @:keep
    static public function _subsetOf( _xl:T_termlist, _yl:T_termlist):Bool {
        @:recv var _xl:T_termlist = _xl;
        if (_yl._isEmpty()) {
            return _xl._isEmpty();
        };
        for (__0 => _x in _xl) {
            if (!_yl._supersetOf(_x)) {
                return false;
            };
        };
        return true;
    }
    /**
        // supersetOf reports whether y ⊆ xl.
    **/
    @:keep
    static public function _supersetOf( _xl:T_termlist, _y:stdgo.Ref<T_term>):Bool {
        @:recv var _xl:T_termlist = _xl;
        for (__0 => _x in _xl) {
            if (_y._subsetOf(_x)) {
                return true;
            };
        };
        return false;
    }
    /**
        // includes reports whether t ∈ xl.
    **/
    @:keep
    static public function _includes( _xl:T_termlist, _t:Type_):Bool {
        @:recv var _xl:T_termlist = _xl;
        for (__0 => _x in _xl) {
            if (_x._includes(_t)) {
                return true;
            };
        };
        return false;
    }
    /**
        // equal reports whether xl and yl represent the same type set.
    **/
    @:keep
    static public function _equal( _xl:T_termlist, _yl:T_termlist):Bool {
        @:recv var _xl:T_termlist = _xl;
        return _xl._subsetOf(_yl) && _yl._subsetOf(_xl);
    }
    /**
        // intersect returns the intersection xl ∩ yl.
    **/
    @:keep
    static public function _intersect( _xl:T_termlist, _yl:T_termlist):T_termlist {
        @:recv var _xl:T_termlist = _xl;
        if (_xl._isEmpty() || _yl._isEmpty()) {
            return null;
        };
        var _rl:T_termlist = new stdgo.go.types.Types.T_termlist(0, 0);
        for (__0 => _x in _xl) {
            for (__1 => _y in _yl) {
                {
                    var _r = _x._intersect(_y);
                    if (_r != null && ((_r : Dynamic).__nil__ == null || !(_r : Dynamic).__nil__)) {
                        _rl = (_rl.__append__(_r));
                    };
                };
            };
        };
        return _rl._norm();
    }
    /**
        // union returns the union xl ∪ yl.
    **/
    @:keep
    static public function _union( _xl:T_termlist, _yl:T_termlist):T_termlist {
        @:recv var _xl:T_termlist = _xl;
        return (_xl.__append__(..._yl.__toArray__()))._norm();
    }
    /**
        // norm returns the normal form of xl.
    **/
    @:keep
    static public function _norm( _xl:T_termlist):T_termlist {
        @:recv var _xl:T_termlist = _xl;
        var _used = new stdgo.Slice<Bool>((_xl.length : stdgo.GoInt).toBasic(), 0);
        var _rl:T_termlist = new stdgo.go.types.Types.T_termlist(0, 0);
        for (_i => _xi in _xl) {
            if (((_xi == null) || (_xi : Dynamic).__nil__) || _used[(_i : stdgo.GoInt)]) {
                continue;
            };
            {
                var _j:stdgo.GoInt = _i + (1 : stdgo.GoInt);
                stdgo.Go.cfor(_j < (_xl.length), _j++, {
                    var _xj = _xl[(_j : stdgo.GoInt)];
                    if (((_xj == null) || (_xj : Dynamic).__nil__) || _used[(_j : stdgo.GoInt)]) {
                        continue;
                    };
                    {
                        var __tmp__ = _xi._union(_xj), _u1:stdgo.Ref<stdgo.go.types.Types.T_term> = __tmp__._0, _u2:stdgo.Ref<stdgo.go.types.Types.T_term> = __tmp__._1;
                        if (_u2 == null || (_u2 : Dynamic).__nil__) {
                            if (_u1._typ == null) {
                                return _allTermlist;
                            };
                            _xi = _u1;
                            _used[(_j : stdgo.GoInt)] = true;
                        };
                    };
                });
            };
            _rl = (_rl.__append__(_xi));
        };
        return _rl;
    }
    /**
        // isAll reports whether the termlist xl represents the set of all types.
    **/
    @:keep
    static public function _isAll( _xl:T_termlist):Bool {
        @:recv var _xl:T_termlist = _xl;
        for (__0 => _x in _xl) {
            if (((_x != null) && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) && (_x._typ == null)) {
                return true;
            };
        };
        return false;
    }
    /**
        // isEmpty reports whether the termlist xl represents the empty set of types.
    **/
    @:keep
    static public function _isEmpty( _xl:T_termlist):Bool {
        @:recv var _xl:T_termlist = _xl;
        for (__0 => _x in _xl) {
            if (_x != null && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) {
                return false;
            };
        };
        return true;
    }
    /**
        // String prints the termlist exactly (without normalization).
    **/
    @:keep
    static public function string( _xl:T_termlist):stdgo.GoString {
        @:recv var _xl:T_termlist = _xl;
        if ((_xl.length) == ((0 : stdgo.GoInt))) {
            return ("∅" : stdgo.GoString);
        };
        var _buf:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
        for (_i => _x in _xl) {
            if (_i > (0 : stdgo.GoInt)) {
                _buf.writeString((" | " : stdgo.GoString));
            };
            _buf.writeString((_x.string() : stdgo.GoString)?.__copy__());
        };
        return (_buf.string() : stdgo.GoString)?.__copy__();
    }
}
class T_byUniqueMethodName_asInterface {
    @:keep
    public dynamic function swap(_i:stdgo.GoInt, _j:stdgo.GoInt):Void __self__.value.swap(_i, _j);
    @:keep
    public dynamic function less(_i:stdgo.GoInt, _j:stdgo.GoInt):Bool return __self__.value.less(_i, _j);
    @:keep
    public dynamic function len():stdgo.GoInt return __self__.value.len();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_byUniqueMethodName>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_byUniqueMethodName_asInterface) class T_byUniqueMethodName_static_extension {
    @:keep
    static public function swap( _a:T_byUniqueMethodName, _i:stdgo.GoInt, _j:stdgo.GoInt):Void {
        @:recv var _a:T_byUniqueMethodName = _a;
        {
            final __tmp__0 = _a[(_j : stdgo.GoInt)];
            final __tmp__1 = _a[(_i : stdgo.GoInt)];
            _a[(_i : stdgo.GoInt)] = __tmp__0;
            _a[(_j : stdgo.GoInt)] = __tmp__1;
        };
    }
    @:keep
    static public function less( _a:T_byUniqueMethodName, _i:stdgo.GoInt, _j:stdgo.GoInt):Bool {
        @:recv var _a:T_byUniqueMethodName = _a;
        return _a[(_i : stdgo.GoInt)]._less((stdgo.Go.setRef(_a[(_j : stdgo.GoInt)]._object) : stdgo.Ref<stdgo.go.types.Types.T_object>));
    }
    @:keep
    static public function len( _a:T_byUniqueMethodName):stdgo.GoInt {
        @:recv var _a:T_byUniqueMethodName = _a;
        return (_a.length);
    }
}
class T_unifyMode_asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_unifyMode>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_unifyMode_asInterface) class T_unifyMode_static_extension {
    @:keep
    static public function string( _m:T_unifyMode):stdgo.GoString {
        @:recv var _m:T_unifyMode = _m;
        {
            final __value__ = _m;
            if (__value__ == ((0u32 : stdgo.go.types.Types.T_unifyMode))) {
                return ("inexact" : stdgo.GoString);
            } else if (__value__ == ((1u32 : stdgo.go.types.Types.T_unifyMode))) {
                return ("assign" : stdgo.GoString);
            } else if (__value__ == ((2u32 : stdgo.go.types.Types.T_unifyMode))) {
                return ("exact" : stdgo.GoString);
            } else if (__value__ == ((3u32 : stdgo.go.types.Types.T_unifyMode))) {
                return ("assign, exact" : stdgo.GoString);
            };
        };
        return stdgo.fmt.Fmt.sprintf(("mode %d" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_m)))?.__copy__();
    }
}
class T_typeParamsById_asInterface {
    @:keep
    public dynamic function swap(_i:stdgo.GoInt, _j:stdgo.GoInt):Void __self__.value.swap(_i, _j);
    @:keep
    public dynamic function less(_i:stdgo.GoInt, _j:stdgo.GoInt):Bool return __self__.value.less(_i, _j);
    @:keep
    public dynamic function len():stdgo.GoInt return __self__.value.len();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_typeParamsById>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_typeParamsById_asInterface) class T_typeParamsById_static_extension {
    @:keep
    static public function swap( _s:T_typeParamsById, _i:stdgo.GoInt, _j:stdgo.GoInt):Void {
        @:recv var _s:T_typeParamsById = _s;
        {
            final __tmp__0 = _s[(_j : stdgo.GoInt)];
            final __tmp__1 = _s[(_i : stdgo.GoInt)];
            _s[(_i : stdgo.GoInt)] = __tmp__0;
            _s[(_j : stdgo.GoInt)] = __tmp__1;
        };
    }
    @:keep
    static public function less( _s:T_typeParamsById, _i:stdgo.GoInt, _j:stdgo.GoInt):Bool {
        @:recv var _s:T_typeParamsById = _s;
        return _s[(_i : stdgo.GoInt)]._id < _s[(_j : stdgo.GoInt)]._id;
    }
    @:keep
    static public function len( _s:T_typeParamsById):stdgo.GoInt {
        @:recv var _s:T_typeParamsById = _s;
        return (_s.length);
    }
}
class Term_asInterface {
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:keep
    public dynamic function type():Type_ return __self__.value.type();
    @:keep
    public dynamic function tilde():Bool return __self__.value.tilde();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Term>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Term_asInterface) class Term_static_extension {
    @:keep
    static public function string( _t:stdgo.Ref<Term>):stdgo.GoString {
        @:recv var _t:stdgo.Ref<Term> = _t;
        return ((({
            final e = _t;
            ({ _tilde : e._tilde, _typ : e._typ } : stdgo.go.types.Types.T_term);
        })).string() : stdgo.GoString)?.__copy__();
    }
    @:keep
    static public function type( _t:stdgo.Ref<Term>):Type_ {
        @:recv var _t:stdgo.Ref<Term> = _t;
        return _t._typ;
    }
    @:keep
    static public function tilde( _t:stdgo.Ref<Term>):Bool {
        @:recv var _t:stdgo.Ref<Term> = _t;
        return _t._tilde;
    }
}
