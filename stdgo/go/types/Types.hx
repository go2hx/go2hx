package stdgo.go.types;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.internal.types.errors.Errors;
import stdgo.StdGoTypes;
import stdgo.Error;
import stdgo.Go;
import stdgo.GoString;
import stdgo.Pointer;
import stdgo.Slice;
import stdgo.GoArray;
import stdgo.GoMap;
import stdgo.Chan;
/**
    // Package types declares the data types and implements
    // the algorithms for type-checking of Go packages. Use
    // Config.Check to invoke the type checker for a package.
    // Alternatively, create a new type checker with NewChecker
    // and invoke it incrementally by calling Checker.Files.
    //
    // Type-checking consists of several interdependent phases:
    //
    // Name resolution maps each identifier (ast.Ident) in the program to the
    // language object (Object) it denotes.
    // Use Info.{Defs,Uses,Implicits} for the results of name resolution.
    //
    // Constant folding computes the exact constant value (constant.Value)
    // for every expression (ast.Expr) that is a compile-time constant.
    // Use Info.Types[expr].Value for the results of constant folding.
    //
    // Type inference computes the type (Type) of every expression (ast.Expr)
    // and checks for compliance with the language specification.
    // Use Info.Types[expr].Type for the results of type inference.
    //
    // For a tutorial, see https://golang.org/s/types-tutorial.
**/
private var __go2hxdoc__package : Bool;
/**
    
    
    
**/
private var _cgoPrefixes = (new GoArray<GoString>(("_Ciconst_" : GoString), ("_Cfconst_" : GoString), ("_Csconst_" : GoString), ("_Ctype_" : GoString), ("_Cvar_" : GoString), ("_Cfpvar_fp_" : GoString), ("_Cfunc_" : GoString), ("_Cmacro_" : GoString)) : GoArray<GoString>);
/**
    
    
    
**/
private var _errBadCgo = stdgo.errors.Errors.new_(("cannot use FakeImportC and go115UsesCgo together" : GoString));
/**
    
    
    
**/
private var _op2str1 = {
        var s:GoArray<GoString> = new GoArray<GoString>(...[for (i in 0 ... 20) ""]);
        s[19] = ("bitwise complement" : GoString);
        s;
    };
/**
    // This is only used for operations that may cause overflow.
    
    
**/
private var _op2str2 = {
        var s:GoArray<GoString> = new GoArray<GoString>(...[for (i in 0 ... 21) ""]);
        s[12] = ("addition" : GoString);
        s[13] = ("subtraction" : GoString);
        s[19] = ("bitwise XOR" : GoString);
        s[14] = ("multiplication" : GoString);
        s[20] = ("shift" : GoString);
        s;
    };
/**
    
    
    
**/
private var _gccgoArchSizes = ({
        final x = new stdgo.GoMap.GoStringMap<Ref<stdgo.go.types.Types.StdSizes>>();
        x.__defaultValue__ = () -> (null : Ref<stdgo.go.types.Types.StdSizes>);
        @:mergeBlock {
            x.set(("386" : GoString), (new stdgo.go.types.Types.StdSizes((4i64 : GoInt64), (4i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("alpha" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("amd64" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("amd64p32" : GoString), (new stdgo.go.types.Types.StdSizes((4i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("arm" : GoString), (new stdgo.go.types.Types.StdSizes((4i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("armbe" : GoString), (new stdgo.go.types.Types.StdSizes((4i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("arm64" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("arm64be" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("ia64" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("loong64" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("m68k" : GoString), (new stdgo.go.types.Types.StdSizes((4i64 : GoInt64), (2i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("mips" : GoString), (new stdgo.go.types.Types.StdSizes((4i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("mipsle" : GoString), (new stdgo.go.types.Types.StdSizes((4i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("mips64" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("mips64le" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("mips64p32" : GoString), (new stdgo.go.types.Types.StdSizes((4i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("mips64p32le" : GoString), (new stdgo.go.types.Types.StdSizes((4i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("nios2" : GoString), (new stdgo.go.types.Types.StdSizes((4i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("ppc" : GoString), (new stdgo.go.types.Types.StdSizes((4i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("ppc64" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("ppc64le" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("riscv" : GoString), (new stdgo.go.types.Types.StdSizes((4i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("riscv64" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("s390" : GoString), (new stdgo.go.types.Types.StdSizes((4i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("s390x" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("sh" : GoString), (new stdgo.go.types.Types.StdSizes((4i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("shbe" : GoString), (new stdgo.go.types.Types.StdSizes((4i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("sparc" : GoString), (new stdgo.go.types.Types.StdSizes((4i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("sparc64" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("wasm" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
        };
        x;
    } : GoMap<GoString, Ref<stdgo.go.types.Types.StdSizes>>);
/**
    
    
    
**/
private var _operandModeString = {
        var s:GoArray<GoString> = new GoArray<GoString>(...[for (i in 0 ... 11) ""]);
        s[0] = ("invalid operand" : GoString);
        s[1] = ("no value" : GoString);
        s[2] = ("built-in" : GoString);
        s[3] = ("type" : GoString);
        s[4] = ("constant" : GoString);
        s[5] = ("variable" : GoString);
        s[6] = ("map index expression" : GoString);
        s[7] = ("value" : GoString);
        s[8] = ("comma, ok expression" : GoString);
        s[9] = ("comma, error expression" : GoString);
        s[10] = ("cgo function" : GoString);
        s;
    };
/**
    
    
    
**/
private var _basicSizes = {
        var s:GoArray<GoUInt8> = new GoArray<GoUInt8>(...[for (i in 0 ... 17) 0]);
        s[1] = (1 : GoUInt8);
        s[3] = (1 : GoUInt8);
        s[4] = (2 : GoUInt8);
        s[5] = (4 : GoUInt8);
        s[6] = (8 : GoUInt8);
        s[8] = (1 : GoUInt8);
        s[9] = (2 : GoUInt8);
        s[10] = (4 : GoUInt8);
        s[11] = (8 : GoUInt8);
        s[13] = (4 : GoUInt8);
        s[14] = (8 : GoUInt8);
        s[15] = (8 : GoUInt8);
        s[16] = (16 : GoUInt8);
        s;
    };
/**
    // common architecture word sizes and alignments
    
    
**/
private var _gcArchSizes = ({
        final x = new stdgo.GoMap.GoStringMap<Ref<stdgo.go.types.Types.StdSizes>>();
        x.__defaultValue__ = () -> (null : Ref<stdgo.go.types.Types.StdSizes>);
        @:mergeBlock {
            x.set(("386" : GoString), (new stdgo.go.types.Types.StdSizes((4i64 : GoInt64), (4i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("amd64" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("amd64p32" : GoString), (new stdgo.go.types.Types.StdSizes((4i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("arm" : GoString), (new stdgo.go.types.Types.StdSizes((4i64 : GoInt64), (4i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("arm64" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("loong64" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("mips" : GoString), (new stdgo.go.types.Types.StdSizes((4i64 : GoInt64), (4i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("mipsle" : GoString), (new stdgo.go.types.Types.StdSizes((4i64 : GoInt64), (4i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("mips64" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("mips64le" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("ppc64" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("ppc64le" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("riscv64" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("s390x" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("sparc64" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
            x.set(("wasm" : GoString), (new stdgo.go.types.Types.StdSizes((8i64 : GoInt64), (8i64 : GoInt64)) : stdgo.go.types.Types.StdSizes));
        };
        x;
    } : GoMap<GoString, Ref<stdgo.go.types.Types.StdSizes>>);
/**
    // stdSizes is used if Config.Sizes == nil.
    
    
**/
private var _stdSizes = sizesFor(("gc" : GoString), ("amd64" : GoString));
/**
    // allTermlist represents the set of all types.
    // It is in normal form.
    
    
**/
private var _allTermlist = (new Slice<Ref<stdgo.go.types.Types.T_term>>(1, 1, (Go.setRef(({} : stdgo.go.types.Types.T_term)) : Ref<stdgo.go.types.Types.T_term>)) : stdgo.go.types.Types.T_termlist);
/**
    // topTypeSet may be used as type set for the empty interface.
    
    
**/
private var _topTypeSet = ({ _terms : _allTermlist } : T__TypeSet);
/**
    // emptyInterface represents the empty (completed) interface
    
    
**/
private var _emptyInterface = ({ _complete : true, _tset : (Go.setRef(_topTypeSet) : Ref<stdgo.go.types.Types.T__TypeSet>) } : Interface);
/**
    // Typ contains the predeclared *Basic types indexed by their
    // corresponding BasicKind.
    //
    // The *Basic type for Typ[Byte] will have the name "uint8".
    // Use Universe.Lookup("byte").Type() to obtain the specific
    // alias basic type named "byte" (and analogous for "rune").
    
    
**/
var typ = {
        var s = new Slice<Ref<stdgo.go.types.Types.Basic>>(26, 0);
        s[0] = (new stdgo.go.types.Types.Basic((0 : stdgo.go.types.Types.BasicKind), (0 : stdgo.go.types.Types.BasicInfo), ("invalid type" : GoString)) : stdgo.go.types.Types.Basic);
        s[1] = (new stdgo.go.types.Types.Basic((1 : stdgo.go.types.Types.BasicKind), (1 : stdgo.go.types.Types.BasicInfo), ("bool" : GoString)) : stdgo.go.types.Types.Basic);
        s[2] = (new stdgo.go.types.Types.Basic((2 : stdgo.go.types.Types.BasicKind), (2 : stdgo.go.types.Types.BasicInfo), ("int" : GoString)) : stdgo.go.types.Types.Basic);
        s[3] = (new stdgo.go.types.Types.Basic((3 : stdgo.go.types.Types.BasicKind), (2 : stdgo.go.types.Types.BasicInfo), ("int8" : GoString)) : stdgo.go.types.Types.Basic);
        s[4] = (new stdgo.go.types.Types.Basic((4 : stdgo.go.types.Types.BasicKind), (2 : stdgo.go.types.Types.BasicInfo), ("int16" : GoString)) : stdgo.go.types.Types.Basic);
        s[5] = (new stdgo.go.types.Types.Basic((5 : stdgo.go.types.Types.BasicKind), (2 : stdgo.go.types.Types.BasicInfo), ("int32" : GoString)) : stdgo.go.types.Types.Basic);
        s[6] = (new stdgo.go.types.Types.Basic((6 : stdgo.go.types.Types.BasicKind), (2 : stdgo.go.types.Types.BasicInfo), ("int64" : GoString)) : stdgo.go.types.Types.Basic);
        s[7] = (new stdgo.go.types.Types.Basic((7 : stdgo.go.types.Types.BasicKind), (6 : stdgo.go.types.Types.BasicInfo), ("uint" : GoString)) : stdgo.go.types.Types.Basic);
        s[8] = (new stdgo.go.types.Types.Basic((8 : stdgo.go.types.Types.BasicKind), (6 : stdgo.go.types.Types.BasicInfo), ("uint8" : GoString)) : stdgo.go.types.Types.Basic);
        s[9] = (new stdgo.go.types.Types.Basic((9 : stdgo.go.types.Types.BasicKind), (6 : stdgo.go.types.Types.BasicInfo), ("uint16" : GoString)) : stdgo.go.types.Types.Basic);
        s[10] = (new stdgo.go.types.Types.Basic((10 : stdgo.go.types.Types.BasicKind), (6 : stdgo.go.types.Types.BasicInfo), ("uint32" : GoString)) : stdgo.go.types.Types.Basic);
        s[11] = (new stdgo.go.types.Types.Basic((11 : stdgo.go.types.Types.BasicKind), (6 : stdgo.go.types.Types.BasicInfo), ("uint64" : GoString)) : stdgo.go.types.Types.Basic);
        s[12] = (new stdgo.go.types.Types.Basic((12 : stdgo.go.types.Types.BasicKind), (6 : stdgo.go.types.Types.BasicInfo), ("uintptr" : GoString)) : stdgo.go.types.Types.Basic);
        s[13] = (new stdgo.go.types.Types.Basic((13 : stdgo.go.types.Types.BasicKind), (8 : stdgo.go.types.Types.BasicInfo), ("float32" : GoString)) : stdgo.go.types.Types.Basic);
        s[14] = (new stdgo.go.types.Types.Basic((14 : stdgo.go.types.Types.BasicKind), (8 : stdgo.go.types.Types.BasicInfo), ("float64" : GoString)) : stdgo.go.types.Types.Basic);
        s[15] = (new stdgo.go.types.Types.Basic((15 : stdgo.go.types.Types.BasicKind), (16 : stdgo.go.types.Types.BasicInfo), ("complex64" : GoString)) : stdgo.go.types.Types.Basic);
        s[16] = (new stdgo.go.types.Types.Basic((16 : stdgo.go.types.Types.BasicKind), (16 : stdgo.go.types.Types.BasicInfo), ("complex128" : GoString)) : stdgo.go.types.Types.Basic);
        s[17] = (new stdgo.go.types.Types.Basic((17 : stdgo.go.types.Types.BasicKind), (32 : stdgo.go.types.Types.BasicInfo), ("string" : GoString)) : stdgo.go.types.Types.Basic);
        s[18] = (new stdgo.go.types.Types.Basic((18 : stdgo.go.types.Types.BasicKind), (0 : stdgo.go.types.Types.BasicInfo), ("Pointer" : GoString)) : stdgo.go.types.Types.Basic);
        s[19] = (new stdgo.go.types.Types.Basic((19 : stdgo.go.types.Types.BasicKind), (65 : stdgo.go.types.Types.BasicInfo), ("untyped bool" : GoString)) : stdgo.go.types.Types.Basic);
        s[20] = (new stdgo.go.types.Types.Basic((20 : stdgo.go.types.Types.BasicKind), (66 : stdgo.go.types.Types.BasicInfo), ("untyped int" : GoString)) : stdgo.go.types.Types.Basic);
        s[21] = (new stdgo.go.types.Types.Basic((21 : stdgo.go.types.Types.BasicKind), (66 : stdgo.go.types.Types.BasicInfo), ("untyped rune" : GoString)) : stdgo.go.types.Types.Basic);
        s[22] = (new stdgo.go.types.Types.Basic((22 : stdgo.go.types.Types.BasicKind), (72 : stdgo.go.types.Types.BasicInfo), ("untyped float" : GoString)) : stdgo.go.types.Types.Basic);
        s[23] = (new stdgo.go.types.Types.Basic((23 : stdgo.go.types.Types.BasicKind), (80 : stdgo.go.types.Types.BasicInfo), ("untyped complex" : GoString)) : stdgo.go.types.Types.Basic);
        s[24] = (new stdgo.go.types.Types.Basic((24 : stdgo.go.types.Types.BasicKind), (96 : stdgo.go.types.Types.BasicInfo), ("untyped string" : GoString)) : stdgo.go.types.Types.Basic);
        s[25] = (new stdgo.go.types.Types.Basic((25 : stdgo.go.types.Types.BasicKind), (64 : stdgo.go.types.Types.BasicInfo), ("untyped nil" : GoString)) : stdgo.go.types.Types.Basic);
        s;
    };
/**
    
    
    
**/
private var _aliases = (new GoArray<Ref<stdgo.go.types.Types.Basic>>((new stdgo.go.types.Types.Basic((8 : stdgo.go.types.Types.BasicKind), (6 : stdgo.go.types.Types.BasicInfo), ("byte" : GoString)) : stdgo.go.types.Types.Basic), (new stdgo.go.types.Types.Basic((5 : stdgo.go.types.Types.BasicKind), (2 : stdgo.go.types.Types.BasicInfo), ("rune" : GoString)) : stdgo.go.types.Types.Basic)) : GoArray<Ref<stdgo.go.types.Types.Basic>>);
/**
    
    
    
**/
private var _predeclaredConsts = (new GoArray<T__struct_6>(({ _name : ("true" : GoString), _kind : (19 : stdgo.go.types.Types.BasicKind), _val : stdgo.go.constant.Constant.makeBool(true) } : T__struct_6), ({ _name : ("false" : GoString), _kind : (19 : stdgo.go.types.Types.BasicKind), _val : stdgo.go.constant.Constant.makeBool(false) } : T__struct_6), ({ _name : ("iota" : GoString), _kind : (20 : stdgo.go.types.Types.BasicKind), _val : stdgo.go.constant.Constant.makeInt64((0i64 : GoInt64)) } : T__struct_6)) : GoArray<T__struct_6>);
/**
    
    
    
**/
private var _predeclaredFuncs = {
        var s:GoArray<T__struct_7> = new GoArray<T__struct_7>(...[for (i in 0 ... 26) ({ _name : ("" : GoString), _nargs : (0 : GoInt), _variadic : false, _kind : ((0 : GoInt) : stdgo.go.types.Types.T_exprKind) } : T__struct_7)]);
        s[0] = ({ _name : ("append" : GoString), _nargs : (1 : GoInt), _variadic : true, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[1] = ({ _name : ("cap" : GoString), _nargs : (1 : GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[2] = ({ _name : ("clear" : GoString), _nargs : (1 : GoInt), _variadic : false, _kind : (2 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[3] = ({ _name : ("close" : GoString), _nargs : (1 : GoInt), _variadic : false, _kind : (2 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[4] = ({ _name : ("complex" : GoString), _nargs : (2 : GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[5] = ({ _name : ("copy" : GoString), _nargs : (2 : GoInt), _variadic : false, _kind : (2 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[6] = ({ _name : ("delete" : GoString), _nargs : (2 : GoInt), _variadic : false, _kind : (2 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[7] = ({ _name : ("imag" : GoString), _nargs : (1 : GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[8] = ({ _name : ("len" : GoString), _nargs : (1 : GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[9] = ({ _name : ("make" : GoString), _nargs : (1 : GoInt), _variadic : true, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[10] = ({ _name : ("new" : GoString), _nargs : (1 : GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[11] = ({ _name : ("panic" : GoString), _nargs : (1 : GoInt), _variadic : false, _kind : (2 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[12] = ({ _name : ("print" : GoString), _nargs : (0 : GoInt), _variadic : true, _kind : (2 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[13] = ({ _name : ("println" : GoString), _nargs : (0 : GoInt), _variadic : true, _kind : (2 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[14] = ({ _name : ("real" : GoString), _nargs : (1 : GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[15] = ({ _name : ("recover" : GoString), _nargs : (0 : GoInt), _variadic : false, _kind : (2 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[16] = ({ _name : ("Add" : GoString), _nargs : (2 : GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[17] = ({ _name : ("Alignof" : GoString), _nargs : (1 : GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[18] = ({ _name : ("Offsetof" : GoString), _nargs : (1 : GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[19] = ({ _name : ("Sizeof" : GoString), _nargs : (1 : GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[20] = ({ _name : ("Slice" : GoString), _nargs : (2 : GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[21] = ({ _name : ("SliceData" : GoString), _nargs : (1 : GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[22] = ({ _name : ("String" : GoString), _nargs : (2 : GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[23] = ({ _name : ("StringData" : GoString), _nargs : (1 : GoInt), _variadic : false, _kind : (1 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[24] = ({ _name : ("assert" : GoString), _nargs : (1 : GoInt), _variadic : false, _kind : (2 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s[25] = ({ _name : ("trace" : GoString), _nargs : (0 : GoInt), _variadic : true, _kind : (2 : stdgo.go.types.Types.T_exprKind) } : T__struct_7);
        s;
    };
/**
    // goVersionRx matches a Go version string, e.g. "go1.12".
    
    
**/
private var _goVersionRx = stdgo.regexp.Regexp.mustCompile(("^go([1-9]\\d*)\\.(0|[1-9]\\d*)$$" : GoString));
/**
    
    
    
**/
private var _assignOps = ({
        final x = new stdgo.GoMap.GoIntMap<stdgo.go.token.Token.Token>();
        x.__defaultValue__ = () -> ((0 : GoInt) : stdgo.go.token.Token.Token);
        @:mergeBlock {
            x.set((23 : stdgo.go.token.Token.Token), (12 : stdgo.go.token.Token.Token));
            x.set((24 : stdgo.go.token.Token.Token), (13 : stdgo.go.token.Token.Token));
            x.set((25 : stdgo.go.token.Token.Token), (14 : stdgo.go.token.Token.Token));
            x.set((26 : stdgo.go.token.Token.Token), (15 : stdgo.go.token.Token.Token));
            x.set((27 : stdgo.go.token.Token.Token), (16 : stdgo.go.token.Token.Token));
            x.set((28 : stdgo.go.token.Token.Token), (17 : stdgo.go.token.Token.Token));
            x.set((29 : stdgo.go.token.Token.Token), (18 : stdgo.go.token.Token.Token));
            x.set((30 : stdgo.go.token.Token.Token), (19 : stdgo.go.token.Token.Token));
            x.set((31 : stdgo.go.token.Token.Token), (20 : stdgo.go.token.Token.Token));
            x.set((32 : stdgo.go.token.Token.Token), (21 : stdgo.go.token.Token.Token));
            x.set((33 : stdgo.go.token.Token.Token), (22 : stdgo.go.token.Token.Token));
        };
        x;
    } : GoMap<stdgo.go.token.Token.Token, stdgo.go.token.Token.Token>);
/**
    
    
    
**/
private var _myInt = {
        var a = function():Type {
            var _tname = newTypeName((0 : stdgo.go.token.Token.Pos), null, ("myInt" : GoString), (null : stdgo.go.types.Types.Type));
            return Go.asInterface(newNamed(_tname, Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : GoInt)]), (null : Slice<Ref<stdgo.go.types.Types.Func>>)));
        };
        a();
    };
/**
    
    
    
**/
private var _testTerms = ({
        final x = new stdgo.GoMap.GoStringMap<Ref<stdgo.go.types.Types.T_term>>();
        x.__defaultValue__ = () -> (null : Ref<stdgo.go.types.Types.T_term>);
        @:mergeBlock {
            x.set(("‚àÖ" : GoString), (null : Ref<stdgo.go.types.Types.T_term>));
            x.set(("ùì§" : GoString), (new stdgo.go.types.Types.T_term() : stdgo.go.types.Types.T_term));
            x.set(("int" : GoString), (new stdgo.go.types.Types.T_term(false, Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : GoInt)])) : stdgo.go.types.Types.T_term));
            x.set(("~int" : GoString), (new stdgo.go.types.Types.T_term(true, Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : GoInt)])) : stdgo.go.types.Types.T_term));
            x.set(("string" : GoString), (new stdgo.go.types.Types.T_term(false, Go.asInterface(typ[((17 : stdgo.go.types.Types.BasicKind) : GoInt)])) : stdgo.go.types.Types.T_term));
            x.set(("~string" : GoString), (new stdgo.go.types.Types.T_term(true, Go.asInterface(typ[((17 : stdgo.go.types.Types.BasicKind) : GoInt)])) : stdgo.go.types.Types.T_term));
            x.set(("myInt" : GoString), (new stdgo.go.types.Types.T_term(false, _myInt) : stdgo.go.types.Types.T_term));
        };
        x;
    } : GoMap<GoString, Ref<stdgo.go.types.Types.T_term>>);
/**
    
    
    // type is invalid
**/
final invalid : BasicKind = (25 : stdgo.go.types.Types.BasicKind);
/**
    // predeclared types
    
    
**/
final bool_ = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final int_ = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final int8 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final int16 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final int32 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final int64 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final uint = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final uint8 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final uint16 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final uint32 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final uint64 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final uintptr = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final float32 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final float64 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final complex64 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final complex128 = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final string = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final unsafePointer = (25 : stdgo.go.types.Types.BasicKind);
/**
    // types for untyped values
    
    
**/
final untypedBool = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final untypedInt = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final untypedRune = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final untypedFloat = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final untypedComplex = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final untypedString = (25 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final untypedNil = (25 : stdgo.go.types.Types.BasicKind);
/**
    // aliases
    
    
**/
final byte = (8 : stdgo.go.types.Types.BasicKind);
/**
    
    
    
**/
final rune = (5 : stdgo.go.types.Types.BasicKind);
/**
    // Properties of basic types.
    
    
**/
final isBoolean : BasicInfo = (64 : stdgo.go.types.Types.BasicInfo);
/**
    // Properties of basic types.
    
    
**/
final isInteger = (64 : stdgo.go.types.Types.BasicInfo);
/**
    // Properties of basic types.
    
    
**/
final isUnsigned = (64 : stdgo.go.types.Types.BasicInfo);
/**
    // Properties of basic types.
    
    
**/
final isFloat = (64 : stdgo.go.types.Types.BasicInfo);
/**
    // Properties of basic types.
    
    
**/
final isComplex = (64 : stdgo.go.types.Types.BasicInfo);
/**
    // Properties of basic types.
    
    
**/
final isString = (64 : stdgo.go.types.Types.BasicInfo);
/**
    // Properties of basic types.
    
    
**/
final isUntyped = (64 : stdgo.go.types.Types.BasicInfo);
/**
    // Properties of basic types.
    
    
**/
final isOrdered = (42 : stdgo.go.types.Types.BasicInfo);
/**
    // Properties of basic types.
    
    
**/
final isNumeric = (26 : stdgo.go.types.Types.BasicInfo);
/**
    // Properties of basic types.
    
    
**/
final isConstType = (59 : stdgo.go.types.Types.BasicInfo);
/**
    // The direction of a channel is indicated by one of these constants.
    
    
**/
final sendRecv : ChanDir = (2 : stdgo.go.types.Types.ChanDir);
/**
    // The direction of a channel is indicated by one of these constants.
    
    
**/
final sendOnly = (2 : stdgo.go.types.Types.ChanDir);
/**
    // The direction of a channel is indicated by one of these constants.
    
    
**/
final recvOnly = (2 : stdgo.go.types.Types.ChanDir);
/**
    // debugging/development support
    
    // leave on during development
**/
private final _debug = false;
/**
    // debugging/development support
    
    // turn on for detailed type resolution traces
**/
private final _trace = false;
/**
    
    
    
**/
private final _invalidArg = ("invalid argument: " : GoString);
/**
    
    
    
**/
private final _invalidOp = ("invalid operation: " : GoString);
/**
    
    
    
**/
private var _unaryOpPredicates : T_opPredicates = (null : stdgo.go.types.Types.T_opPredicates);
/**
    
    
    
**/
private var _binaryOpPredicates : T_opPredicates = (null : stdgo.go.types.Types.T_opPredicates);
/**
    
    
    
**/
private final _conversion : T_exprKind = (2 : stdgo.go.types.Types.T_exprKind);
/**
    
    
    
**/
private final _expression = (2 : stdgo.go.types.Types.T_exprKind);
/**
    
    
    
**/
private final _statement = (2 : stdgo.go.types.Types.T_exprKind);
/**
    // Shared empty method set.
    
    
**/
private var _emptyMethodSet : MethodSet = ({} : stdgo.go.types.Types.MethodSet);
/**
    
    
    // tparams, underlying type and methods might be unavailable
**/
private final _unresolved : T_namedState = (2u32 : stdgo.go.types.Types.T_namedState);
/**
    
    
    // resolve has run; methods might be incomplete (for instances)
**/
private final _resolved = (2u32 : stdgo.go.types.Types.T_namedState);
/**
    
    
    // all data is known
**/
private final _complete = (2u32 : stdgo.go.types.Types.T_namedState);
/**
    // An object may be painted in one of three colors.
    // Color values other than white or black are considered grey.
    
    
**/
private final _white : T_color = (2u32 : stdgo.go.types.Types.T_color);
/**
    // An object may be painted in one of three colors.
    // Color values other than white or black are considered grey.
    
    
**/
private final _black = (2u32 : stdgo.go.types.Types.T_color);
/**
    // An object may be painted in one of three colors.
    // Color values other than white or black are considered grey.
    
    // must be > white and black
**/
private final _grey = (2u32 : stdgo.go.types.Types.T_color);
/**
    
    
    // operand is invalid
**/
private final _invalid : T_operandMode = (10 : stdgo.go.types.Types.T_operandMode);
/**
    
    
    // operand represents no value (result of a function call w/o result)
**/
private final _novalue = (10 : stdgo.go.types.Types.T_operandMode);
/**
    
    
    // operand is a built-in function
**/
private final _builtin = (10 : stdgo.go.types.Types.T_operandMode);
/**
    
    
    // operand is a type
**/
private final _typexpr = (10 : stdgo.go.types.Types.T_operandMode);
/**
    
    
    // operand is a constant; the operand's typ is a Basic type
**/
private final _constant_ = (10 : stdgo.go.types.Types.T_operandMode);
/**
    
    
    // operand is an addressable variable
**/
private final _variable = (10 : stdgo.go.types.Types.T_operandMode);
/**
    
    
    // operand is a map index expression (acts like a variable on lhs, commaok on rhs of an assignment)
**/
private final _mapindex = (10 : stdgo.go.types.Types.T_operandMode);
/**
    
    
    // operand is a computed value
**/
private final _value = (10 : stdgo.go.types.Types.T_operandMode);
/**
    
    
    // like value, but operand may be used in a comma,ok expression
**/
private final _commaok = (10 : stdgo.go.types.Types.T_operandMode);
/**
    
    
    // like commaok, but second value is error, not boolean
**/
private final _commaerr = (10 : stdgo.go.types.Types.T_operandMode);
/**
    
    
    // operand is a cgo function
**/
private final _cgofunc = (10 : stdgo.go.types.Types.T_operandMode);
/**
    
    
    // x.f is a struct field selector
**/
final fieldVal : SelectionKind = (2 : stdgo.go.types.Types.SelectionKind);
/**
    
    
    // x.f is a method selector
**/
final methodVal = (2 : stdgo.go.types.Types.SelectionKind);
/**
    
    
    // x.f is a method expression
**/
final methodExpr = (2 : stdgo.go.types.Types.SelectionKind);
/**
    // permissible control-flow statements
    
    
**/
private final _breakOk : T_stmtContext = (16u32 : stdgo.go.types.Types.T_stmtContext);
/**
    
    
    
**/
private final _continueOk = (16u32 : stdgo.go.types.Types.T_stmtContext);
/**
    
    
    
**/
private final _fallthroughOk = (16u32 : stdgo.go.types.Types.T_stmtContext);
/**
    // additional context information
    
    
**/
private final _finalSwitchCase = (16u32 : stdgo.go.types.Types.T_stmtContext);
/**
    
    
    
**/
private final _inTypeSwitch = (16u32 : stdgo.go.types.Types.T_stmtContext);
/**
    // termSep is the separator used between individual terms.
    
    
**/
private final _termSep = (" | " : GoString);
/**
    // Note: This is a uint32 rather than a uint64 because the
    // respective 64 bit atomic instructions are not available
    // on all platforms.
    
    
**/
private var _lastID : GoUInt32 = (0 : GoUInt32);
/**
    // invalidTypeSet is a singleton type set to signal an invalid type set
    // due to an error. It's also a valid empty type set, so consumers of
    // type sets may choose to ignore it.
    
    
**/
private var _invalidTypeSet : T__TypeSet = ({} : stdgo.go.types.Types.T__TypeSet);
/**
    // Upper limit for recursion depth. Used to catch infinite recursions
    // due to implementation issues (e.g., see issues #48619, #48656).
    
    
**/
private final _unificationDepthLimit = (50i64 : GoUInt64);
/**
    // Whether to panic when unificationDepthLimit is reached.
    // If disabled, a recursion depth overflow results in a (quiet)
    // unification failure.
    
    
**/
private final _panicAtUnificationDepthLimit = true;
/**
    // If enableCoreTypeUnification is set, unification will consider
    // the core types, if any, of non-local (unbound) type parameters.
    
    
**/
private final _enableCoreTypeUnification = true;
/**
    // If traceInference is set, unification will print a trace of its operation.
    // Interpretation of trace:
    //   x ‚â° y    attempt to unify types x and y
    //   p ‚ûû y    type parameter p is set to type y (p is inferred to be y)
    //   p ‚áÑ q    type parameters p and q match (p is inferred to be q and vice versa)
    //   x ‚â¢ y    types x and y cannot be unified
    //   [p, q, ...] ‚ûû [x, y, ...]    mapping from type parameters to types
    
    
**/
private final _traceInference = false;
/**
    // Avoid excessive type-checking times due to quadratic termlist operations.
    
    
**/
private final _maxTermCount = (100i64 : GoUInt64);
/**
    // The Universe scope contains all predeclared objects of Go.
    // It is the outermost scope of any chain of nested scopes.
    
    
**/
var universe : Ref<Scope> = (null : Ref<stdgo.go.types.Types.Scope>);
/**
    // The Unsafe package is the package returned by an importer
    // for the import path "unsafe".
    
    
**/
var unsafe : Ref<Package> = (null : Ref<stdgo.go.types.Types.Package>);
/**
    
    
    
**/
private var _universeIota : Object = (null : stdgo.go.types.Types.Object);
/**
    
    
    // uint8 alias, but has name "byte"
**/
private var _universeByte : Type = (null : stdgo.go.types.Types.Type);
/**
    
    
    // int32 alias, but has name "rune"
**/
private var _universeRune : Type = (null : stdgo.go.types.Types.Type);
/**
    
    
    
**/
private var _universeAny : Object = (null : stdgo.go.types.Types.Object);
/**
    
    
    
**/
private var _universeError : Type = (null : stdgo.go.types.Types.Type);
/**
    
    
    
**/
private var _universeComparable : Object = (null : stdgo.go.types.Types.Object);
/**
    // universe scope
    
    
**/
private final __Append : T_builtinId = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __Cap = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __Clear = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __Close = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __Complex = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __Copy = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __Delete = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __Imag = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __Len = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __Make = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __New = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __Panic = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __Print = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __Println = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __Real = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __Recover = (25 : stdgo.go.types.Types.T_builtinId);
/**
    // package unsafe
    
    
**/
private final __Add = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __Alignof = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __Offsetof = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __Sizeof = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __Slice = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __SliceData = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __String = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __StringData = (25 : stdgo.go.types.Types.T_builtinId);
/**
    // testing support
    
    
**/
private final __Assert = (25 : stdgo.go.types.Types.T_builtinId);
/**
    
    
    
**/
private final __Trace = (25 : stdgo.go.types.Types.T_builtinId);
/**
    // An Importer resolves import paths to Packages.
    //
    // CAUTION: This interface does not support the import of locally
    // vendored packages. See https://golang.org/s/go15vendor.
    // If possible, external implementations should implement ImporterFrom.
    
    
**/
typedef Importer = StructType & {
    /**
        // Import returns the imported package for the given import path.
        // The semantics is like for ImporterFrom.ImportFrom except that
        // dir and mode are ignored (since they are not present).
        
        
    **/
    public dynamic function import_(_path:GoString):{ var _0 : Ref<Package>; var _1 : Error; };
};
/**
    // An ImporterFrom resolves import paths to packages; it
    // supports vendoring per https://golang.org/s/go15vendor.
    // Use go/importer to obtain an ImporterFrom implementation.
    
    
**/
typedef ImporterFrom = StructType & {
    > Importer,
    /**
        // ImportFrom returns the imported package for the given import
        // path when imported by a package file located in dir.
        // If the import failed, besides returning an error, ImportFrom
        // is encouraged to cache and return a package anyway, if one
        // was created. This will reduce package inconsistencies and
        // follow-on type checker errors due to the missing package.
        // The mode value must be 0; it is reserved for future use.
        // Two calls to ImportFrom with the same path and dir must
        // return the same package.
        
        
    **/
    public dynamic function importFrom(_path:GoString, _dir:GoString, _mode:ImportMode):{ var _0 : Ref<Package>; var _1 : Error; };
};
/**
    
    
    
**/
private typedef T_cleaner = StructType & {
    /**
        
        
        
    **/
    public dynamic function _cleanup():Void;
};
/**
    
    
    
**/
private typedef T_decl = StructType & {
    /**
        
        
        
    **/
    public dynamic function _node():stdgo.go.ast.Ast.Node;
};
/**
    // The positioner interface is used to extract the position of type-checker
    // errors.
    
    
**/
private typedef T_positioner = StructType & {
    /**
        
        
        
    **/
    public dynamic function pos():stdgo.go.token.Token.Pos;
};
/**
    // A dependency is an object that may be a dependency in an initialization
    // expression. Only constants, variables, and functions can be dependencies.
    // Constants are here because constant expression cycles are reported during
    // initialization order computation.
    
    
**/
private typedef T_dependency = StructType & {
    > Object,
    /**
        
        
        
    **/
    public dynamic function _isDependency():Void;
};
/**
    // An Object describes a named language entity such as a package,
    // constant, type, variable, function (incl. methods), or label.
    // All objects implement the Object interface.
    
    
**/
typedef Object = StructType & {
    /**
        
        
        // scope in which this object is declared; nil for methods and struct fields
    **/
    public dynamic function parent():Ref<Scope>;
    /**
        
        
        // position of object identifier in declaration
    **/
    public dynamic function pos():stdgo.go.token.Token.Pos;
    /**
        
        
        // package to which this object belongs; nil for labels and objects in the Universe scope
    **/
    public dynamic function pkg():Ref<Package>;
    /**
        
        
        // package local object name
    **/
    public dynamic function name():GoString;
    /**
        
        
        // object type
    **/
    public dynamic function type():Type;
    /**
        
        
        // reports whether the name starts with a capital letter
    **/
    public dynamic function exported():Bool;
    /**
        
        
        // object name if exported, qualified name if not exported (see func Id)
    **/
    public dynamic function id():GoString;
    /**
        // String returns a human-readable string of the object.
        
        
    **/
    public dynamic function string():GoString;
    /**
        // order reflects a package-level object's source order: if object
        // a is before object b in the source, then a.order() < b.order().
        // order returns a value > 0 for package-level objects; it returns
        // 0 for all other objects (including objects in file scopes).
        
        
    **/
    public dynamic function _order():GoUInt32;
    /**
        // color returns the object's color.
        
        
    **/
    public dynamic function _color():T_color;
    /**
        // setType sets the type of the object.
        
        
    **/
    public dynamic function _setType(_0:Type):Void;
    /**
        // setOrder sets the order number of the object. It must be > 0.
        
        
    **/
    public dynamic function _setOrder(_0:GoUInt32):Void;
    /**
        // setColor sets the object's color. It must not be white.
        
        
    **/
    public dynamic function _setColor(_color:T_color):Void;
    /**
        // setParent sets the parent scope of the object.
        
        
    **/
    public dynamic function _setParent(_0:Ref<Scope>):Void;
    /**
        // sameId reports whether obj.Id() and Id(pkg, name) are the same.
        
        
    **/
    public dynamic function _sameId(_pkg:Ref<Package>, _name:GoString):Bool;
    /**
        // scopePos returns the start position of the scope of this Object
        
        
    **/
    public dynamic function _scopePos():stdgo.go.token.Token.Pos;
    /**
        // setScopePos sets the start position of the scope for this Object.
        
        
    **/
    public dynamic function _setScopePos(_pos:stdgo.go.token.Token.Pos):Void;
};
/**
    // Sizes defines the sizing functions for package unsafe.
    
    
**/
typedef Sizes = StructType & {
    /**
        // Alignof returns the alignment of a variable of type T.
        // Alignof must implement the alignment guarantees required by the spec.
        
        
    **/
    public dynamic function alignof_(t:Type):GoInt64;
    /**
        // Offsetsof returns the offsets of the given struct fields, in bytes.
        // Offsetsof must implement the offset guarantees required by the spec.
        
        
    **/
    public dynamic function offsetsof(_fields:Slice<Ref<Var>>):Slice<GoInt64>;
    /**
        // Sizeof returns the size of a variable of type T.
        // Sizeof must implement the size guarantees required by the spec.
        
        
    **/
    public dynamic function sizeof(t:Type):GoInt64;
};
/**
    // A Type represents a type of Go.
    // All types implement the Type interface.
    
    
**/
typedef Type = StructType & {
    /**
        // Underlying returns the underlying type of a type.
        
        
    **/
    public dynamic function underlying():Type;
    /**
        // String returns a string representation of a type.
        
        
    **/
    public dynamic function string():GoString;
};
/**
    // An Error describes a type-checking error; it implements the error interface.
    // A "soft" error is an error that still permits a valid interpretation of a
    // package (such as "unused variable"); "hard" errors may lead to unpredictable
    // behavior if ignored.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.T_error_static_extension) class T_error {
    public var fset : Ref<stdgo.go.token.Token.FileSet> = (null : Ref<stdgo.go.token.Token.FileSet>);
    public var pos : stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
    public var msg : GoString = "";
    public var soft : Bool = false;
    /**
        // go116code is a future API, unexported as the set of error codes is large
        // and likely to change significantly during experimentation. Tools wishing
        // to preview this feature may read go116code using reflection (see
        // errorcodes_test.go), but beware that there is no guarantee of future
        // compatibility.
    **/
    public var _go116code : stdgo.internal.types.errors.Errors.Code = ((0 : GoInt) : stdgo.internal.types.errors.Errors.Code);
    public var _go116start : stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
    public var _go116end : stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
    public function new(?fset:Ref<stdgo.go.token.Token.FileSet>, ?pos:stdgo.go.token.Token.Pos, ?msg:GoString, ?soft:Bool, ?_go116code:stdgo.internal.types.errors.Errors.Code, ?_go116start:stdgo.go.token.Token.Pos, ?_go116end:stdgo.go.token.Token.Pos) {
        if (fset != null) this.fset = fset;
        if (pos != null) this.pos = pos;
        if (msg != null) this.msg = msg;
        if (soft != null) this.soft = soft;
        if (_go116code != null) this._go116code = _go116code;
        if (_go116start != null) this._go116start = _go116start;
        if (_go116end != null) this._go116end = _go116end;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_error(fset, pos, msg, soft, _go116code, _go116start, _go116end);
    }
}
/**
    // An ArgumentError holds an error associated with an argument index.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.ArgumentError_static_extension) class ArgumentError {
    public var index : GoInt = 0;
    public var err : Error = (null : Error);
    public function new(?index:GoInt, ?err:Error) {
        if (index != null) this.index = index;
        if (err != null) this.err = err;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new ArgumentError(index, err);
    }
}
/**
    // A Config specifies the configuration for type checking.
    // The zero value for Config is a ready-to-use default configuration.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Config_static_extension) class Config {
    /**
        // Context is the context used for resolving global identifiers. If nil, the
        // type checker will initialize this field with a newly created context.
    **/
    public var context : Ref<stdgo.go.types.Types.Context> = (null : Ref<stdgo.go.types.Types.Context>);
    /**
        // GoVersion describes the accepted Go language version. The string
        // must follow the format "go%d.%d" (e.g. "go1.12") or it must be
        // empty; an empty string indicates the latest language version.
        // If the format is invalid, invoking the type checker will cause a
        // panic.
    **/
    public var goVersion : GoString = "";
    /**
        // If IgnoreFuncBodies is set, function bodies are not
        // type-checked.
    **/
    public var ignoreFuncBodies : Bool = false;
    /**
        // If FakeImportC is set, `import "C"` (for packages requiring Cgo)
        // declares an empty "C" package and errors are omitted for qualified
        // identifiers referring to package C (which won't find an object).
        // This feature is intended for the standard library cmd/api tool.
        //
        // Caution: Effects may be unpredictable due to follow-on errors.
        //          Do not use casually!
    **/
    public var fakeImportC : Bool = false;
    /**
        // If go115UsesCgo is set, the type checker expects the
        // _cgo_gotypes.go file generated by running cmd/cgo to be
        // provided as a package source file. Qualified identifiers
        // referring to package C will be resolved to cgo-provided
        // declarations within _cgo_gotypes.go.
        //
        // It is an error to set both FakeImportC and go115UsesCgo.
    **/
    public var _go115UsesCgo : Bool = false;
    /**
        // If Error != nil, it is called with each error found
        // during type checking; err has dynamic type Error.
        // Secondary errors (for instance, to enumerate all types
        // involved in an invalid recursive type declaration) have
        // error strings that start with a '\t' character.
        // If Error == nil, type-checking stops with the first
        // error found.
    **/
    public var error : Error -> Void = null;
    /**
        // An importer is used to import packages referred to from
        // import declarations.
        // If the installed importer implements ImporterFrom, the type
        // checker calls ImportFrom instead of Import.
        // The type checker reports an error if an importer is needed
        // but none was installed.
    **/
    public var importer : stdgo.go.types.Types.Importer = (null : stdgo.go.types.Types.Importer);
    /**
        // If Sizes != nil, it provides the sizing functions for package unsafe.
        // Otherwise SizesFor("gc", "amd64") is used instead.
    **/
    public var sizes : stdgo.go.types.Types.Sizes = (null : stdgo.go.types.Types.Sizes);
    /**
        // If DisableUnusedImportCheck is set, packages are not checked
        // for unused imports.
    **/
    public var disableUnusedImportCheck : Bool = false;
    /**
        // If oldComparableSemantics is set, ordinary (non-type parameter)
        // interfaces do not satisfy the comparable constraint.
        // TODO(gri) remove this flag for Go 1.21
    **/
    public var _oldComparableSemantics : Bool = false;
    public function new(?context:Ref<stdgo.go.types.Types.Context>, ?goVersion:GoString, ?ignoreFuncBodies:Bool, ?fakeImportC:Bool, ?_go115UsesCgo:Bool, ?error:Error -> Void, ?importer:stdgo.go.types.Types.Importer, ?sizes:stdgo.go.types.Types.Sizes, ?disableUnusedImportCheck:Bool, ?_oldComparableSemantics:Bool) {
        if (context != null) this.context = context;
        if (goVersion != null) this.goVersion = goVersion;
        if (ignoreFuncBodies != null) this.ignoreFuncBodies = ignoreFuncBodies;
        if (fakeImportC != null) this.fakeImportC = fakeImportC;
        if (_go115UsesCgo != null) this._go115UsesCgo = _go115UsesCgo;
        if (error != null) this.error = error;
        if (importer != null) this.importer = importer;
        if (sizes != null) this.sizes = sizes;
        if (disableUnusedImportCheck != null) this.disableUnusedImportCheck = disableUnusedImportCheck;
        if (_oldComparableSemantics != null) this._oldComparableSemantics = _oldComparableSemantics;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Config(context, goVersion, ignoreFuncBodies, fakeImportC, _go115UsesCgo, error, importer, sizes, disableUnusedImportCheck, _oldComparableSemantics);
    }
}
/**
    // Info holds result type information for a type-checked package.
    // Only the information for which a map is provided is collected.
    // If the package has type errors, the collected information may
    // be incomplete.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Info_static_extension) class Info {
    /**
        // Types maps expressions to their types, and for constant
        // expressions, also their values. Invalid expressions are
        // omitted.
        //
        // For (possibly parenthesized) identifiers denoting built-in
        // functions, the recorded signatures are call-site specific:
        // if the call result is not a constant, the recorded type is
        // an argument-specific signature. Otherwise, the recorded type
        // is invalid.
        //
        // The Types map does not record the type of every identifier,
        // only those that appear where an arbitrary expression is
        // permitted. For instance, the identifier f in a selector
        // expression x.f is found only in the Selections map, the
        // identifier z in a variable declaration 'var z int' is found
        // only in the Defs map, and identifiers denoting packages in
        // qualified identifiers are collected in the Uses map.
    **/
    public var types : GoMap<stdgo.go.ast.Ast.Expr, stdgo.go.types.Types.TypeAndValue> = (null : GoMap<stdgo.go.ast.Ast.Expr, stdgo.go.types.Types.TypeAndValue>);
    /**
        // Instances maps identifiers denoting generic types or functions to their
        // type arguments and instantiated type.
        //
        // For example, Instances will map the identifier for 'T' in the type
        // instantiation T[int, string] to the type arguments [int, string] and
        // resulting instantiated *Named type. Given a generic function
        // func F[A any](A), Instances will map the identifier for 'F' in the call
        // expression F(int(1)) to the inferred type arguments [int], and resulting
        // instantiated *Signature.
        //
        // Invariant: Instantiating Uses[id].Type() with Instances[id].TypeArgs
        // results in an equivalent of Instances[id].Type.
    **/
    public var instances : GoMap<Ref<stdgo.go.ast.Ast.Ident>, stdgo.go.types.Types.Instance> = (null : GoMap<Ref<stdgo.go.ast.Ast.Ident>, stdgo.go.types.Types.Instance>);
    /**
        // Defs maps identifiers to the objects they define (including
        // package names, dots "." of dot-imports, and blank "_" identifiers).
        // For identifiers that do not denote objects (e.g., the package name
        // in package clauses, or symbolic variables t in t := x.(type) of
        // type switch headers), the corresponding objects are nil.
        //
        // For an embedded field, Defs returns the field *Var it defines.
        //
        // Invariant: Defs[id] == nil || Defs[id].Pos() == id.Pos()
    **/
    public var defs : GoMap<Ref<stdgo.go.ast.Ast.Ident>, stdgo.go.types.Types.Object> = (null : GoMap<Ref<stdgo.go.ast.Ast.Ident>, stdgo.go.types.Types.Object>);
    /**
        // Uses maps identifiers to the objects they denote.
        //
        // For an embedded field, Uses returns the *TypeName it denotes.
        //
        // Invariant: Uses[id].Pos() != id.Pos()
    **/
    public var uses : GoMap<Ref<stdgo.go.ast.Ast.Ident>, stdgo.go.types.Types.Object> = (null : GoMap<Ref<stdgo.go.ast.Ast.Ident>, stdgo.go.types.Types.Object>);
    /**
        // Implicits maps nodes to their implicitly declared objects, if any.
        // The following node and object types may appear:
        //
        //     node               declared object
        //
        //     *ast.ImportSpec    *PkgName for imports without renames
        //     *ast.CaseClause    type-specific *Var for each type switch case clause (incl. default)
        //     *ast.Field         anonymous parameter *Var (incl. unnamed results)
        //
    **/
    public var implicits : GoMap<stdgo.go.ast.Ast.Node, stdgo.go.types.Types.Object> = (null : GoMap<stdgo.go.ast.Ast.Node, stdgo.go.types.Types.Object>);
    /**
        // Selections maps selector expressions (excluding qualified identifiers)
        // to their corresponding selections.
    **/
    public var selections : GoMap<Ref<stdgo.go.ast.Ast.SelectorExpr>, Ref<stdgo.go.types.Types.Selection>> = (null : GoMap<Ref<stdgo.go.ast.Ast.SelectorExpr>, Ref<stdgo.go.types.Types.Selection>>);
    /**
        // Scopes maps ast.Nodes to the scopes they define. Package scopes are not
        // associated with a specific node but with all files belonging to a package.
        // Thus, the package scope can be found in the type-checked Package object.
        // Scopes nest, with the Universe scope being the outermost scope, enclosing
        // the package scope, which contains (one or more) files scopes, which enclose
        // function scopes which in turn enclose statement and function literal scopes.
        // Note that even though package-level functions are declared in the package
        // scope, the function scopes are embedded in the file scope of the file
        // containing the function declaration.
        //
        // The following node types may appear in Scopes:
        //
        //     *ast.File
        //     *ast.FuncType
        //     *ast.TypeSpec
        //     *ast.BlockStmt
        //     *ast.IfStmt
        //     *ast.SwitchStmt
        //     *ast.TypeSwitchStmt
        //     *ast.CaseClause
        //     *ast.CommClause
        //     *ast.ForStmt
        //     *ast.RangeStmt
        //
    **/
    public var scopes : GoMap<stdgo.go.ast.Ast.Node, Ref<stdgo.go.types.Types.Scope>> = (null : GoMap<stdgo.go.ast.Ast.Node, Ref<stdgo.go.types.Types.Scope>>);
    /**
        // InitOrder is the list of package-level initializers in the order in which
        // they must be executed. Initializers referring to variables related by an
        // initialization dependency appear in topological order, the others appear
        // in source order. Variables without an initialization expression do not
        // appear in this list.
    **/
    public var initOrder : Slice<Ref<stdgo.go.types.Types.Initializer>> = (null : Slice<Ref<stdgo.go.types.Types.Initializer>>);
    public function new(?types:GoMap<stdgo.go.ast.Ast.Expr, stdgo.go.types.Types.TypeAndValue>, ?instances:GoMap<Ref<stdgo.go.ast.Ast.Ident>, stdgo.go.types.Types.Instance>, ?defs:GoMap<Ref<stdgo.go.ast.Ast.Ident>, stdgo.go.types.Types.Object>, ?uses:GoMap<Ref<stdgo.go.ast.Ast.Ident>, stdgo.go.types.Types.Object>, ?implicits:GoMap<stdgo.go.ast.Ast.Node, stdgo.go.types.Types.Object>, ?selections:GoMap<Ref<stdgo.go.ast.Ast.SelectorExpr>, Ref<stdgo.go.types.Types.Selection>>, ?scopes:GoMap<stdgo.go.ast.Ast.Node, Ref<stdgo.go.types.Types.Scope>>, ?initOrder:Slice<Ref<stdgo.go.types.Types.Initializer>>) {
        if (types != null) this.types = types;
        if (instances != null) this.instances = instances;
        if (defs != null) this.defs = defs;
        if (uses != null) this.uses = uses;
        if (implicits != null) this.implicits = implicits;
        if (selections != null) this.selections = selections;
        if (scopes != null) this.scopes = scopes;
        if (initOrder != null) this.initOrder = initOrder;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Info(types, instances, defs, uses, implicits, selections, scopes, initOrder);
    }
}
/**
    // TypeAndValue reports the type and value (for constants)
    // of the corresponding expression.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.TypeAndValue_static_extension) class TypeAndValue {
    public var _mode : stdgo.go.types.Types.T_operandMode = ((0 : GoUInt8) : stdgo.go.types.Types.T_operandMode);
    public var type : stdgo.go.types.Types.Type = (null : stdgo.go.types.Types.Type);
    public var value : stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
    public function new(?_mode:stdgo.go.types.Types.T_operandMode, ?type:stdgo.go.types.Types.Type, ?value:stdgo.go.constant.Constant.Value) {
        if (_mode != null) this._mode = _mode;
        if (type != null) this.type = type;
        if (value != null) this.value = value;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new TypeAndValue(_mode, type, value);
    }
}
/**
    // Instance reports the type arguments and instantiated type for type and
    // function instantiations. For type instantiations, Type will be of dynamic
    // type *Named. For function instantiations, Type will be of dynamic type
    // *Signature.
    
    
**/
@:structInit class Instance {
    public var typeArgs : Ref<stdgo.go.types.Types.TypeList> = (null : Ref<stdgo.go.types.Types.TypeList>);
    public var type : stdgo.go.types.Types.Type = (null : stdgo.go.types.Types.Type);
    public function new(?typeArgs:Ref<stdgo.go.types.Types.TypeList>, ?type:stdgo.go.types.Types.Type) {
        if (typeArgs != null) this.typeArgs = typeArgs;
        if (type != null) this.type = type;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Instance(typeArgs, type);
    }
}
/**
    // An Initializer describes a package-level variable, or a list of variables in case
    // of a multi-valued initialization expression, and the corresponding initialization
    // expression.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Initializer_static_extension) class Initializer {
    public var lhs : Slice<Ref<stdgo.go.types.Types.Var>> = (null : Slice<Ref<stdgo.go.types.Types.Var>>);
    public var rhs : stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
    public function new(?lhs:Slice<Ref<stdgo.go.types.Types.Var>>, ?rhs:stdgo.go.ast.Ast.Expr) {
        if (lhs != null) this.lhs = lhs;
        if (rhs != null) this.rhs = rhs;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Initializer(lhs, rhs);
    }
}
/**
    // An Array represents an array type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Array__static_extension) class Array_ {
    public var _len : GoInt64 = 0;
    public var _elem : stdgo.go.types.Types.Type = (null : stdgo.go.types.Types.Type);
    public function new(?_len:GoInt64, ?_elem:stdgo.go.types.Types.Type) {
        if (_len != null) this._len = _len;
        if (_elem != null) this._elem = _elem;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Array_(_len, _elem);
    }
}
/**
    // A Basic represents a basic type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Basic_static_extension) class Basic {
    public var _kind : stdgo.go.types.Types.BasicKind = ((0 : GoInt) : stdgo.go.types.Types.BasicKind);
    public var _info : stdgo.go.types.Types.BasicInfo = ((0 : GoInt) : stdgo.go.types.Types.BasicInfo);
    public var _name : GoString = "";
    public function new(?_kind:stdgo.go.types.Types.BasicKind, ?_info:stdgo.go.types.Types.BasicInfo, ?_name:GoString) {
        if (_kind != null) this._kind = _kind;
        if (_info != null) this._info = _info;
        if (_name != null) this._name = _name;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Basic(_kind, _info, _name);
    }
}
/**
    // A Chan represents a channel type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Chan_static_extension) class Chan {
    public var _dir : stdgo.go.types.Types.ChanDir = ((0 : GoInt) : stdgo.go.types.Types.ChanDir);
    public var _elem : stdgo.go.types.Types.Type = (null : stdgo.go.types.Types.Type);
    public function new(?_dir:stdgo.go.types.Types.ChanDir, ?_elem:stdgo.go.types.Types.Type) {
        if (_dir != null) this._dir = _dir;
        if (_elem != null) this._elem = _elem;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Chan(_dir, _elem);
    }
}
/**
    // exprInfo stores information about an untyped expression.
    
    
**/
@:structInit @:private class T_exprInfo {
    public var _isLhs : Bool = false;
    public var _mode : stdgo.go.types.Types.T_operandMode = ((0 : GoUInt8) : stdgo.go.types.Types.T_operandMode);
    public var _typ : Ref<stdgo.go.types.Types.Basic> = (null : Ref<stdgo.go.types.Types.Basic>);
    public var _val : stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
    public function new(?_isLhs:Bool, ?_mode:stdgo.go.types.Types.T_operandMode, ?_typ:Ref<stdgo.go.types.Types.Basic>, ?_val:stdgo.go.constant.Constant.Value) {
        if (_isLhs != null) this._isLhs = _isLhs;
        if (_mode != null) this._mode = _mode;
        if (_typ != null) this._typ = _typ;
        if (_val != null) this._val = _val;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_exprInfo(_isLhs, _mode, _typ, _val);
    }
}
/**
    // An environment represents the environment within which an object is
    // type-checked.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_environment_static_extension) class T_environment {
    public var _decl : Ref<stdgo.go.types.Types.T_declInfo> = (null : Ref<stdgo.go.types.Types.T_declInfo>);
    public var _scope : Ref<stdgo.go.types.Types.Scope> = (null : Ref<stdgo.go.types.Types.Scope>);
    public var _pos : stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
    public var _iota : stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
    public var _errpos : stdgo.go.types.Types.T_positioner = (null : stdgo.go.types.Types.T_positioner);
    public var _inTParamList : Bool = false;
    public var _sig : Ref<stdgo.go.types.Types.Signature> = (null : Ref<stdgo.go.types.Types.Signature>);
    public var _isPanic : GoMap<Ref<stdgo.go.ast.Ast.CallExpr>, Bool> = (null : GoMap<Ref<stdgo.go.ast.Ast.CallExpr>, Bool>);
    public var _hasLabel : Bool = false;
    public var _hasCallOrRecv : Bool = false;
    public function new(?_decl:Ref<stdgo.go.types.Types.T_declInfo>, ?_scope:Ref<stdgo.go.types.Types.Scope>, ?_pos:stdgo.go.token.Token.Pos, ?_iota:stdgo.go.constant.Constant.Value, ?_errpos:stdgo.go.types.Types.T_positioner, ?_inTParamList:Bool, ?_sig:Ref<stdgo.go.types.Types.Signature>, ?_isPanic:GoMap<Ref<stdgo.go.ast.Ast.CallExpr>, Bool>, ?_hasLabel:Bool, ?_hasCallOrRecv:Bool) {
        if (_decl != null) this._decl = _decl;
        if (_scope != null) this._scope = _scope;
        if (_pos != null) this._pos = _pos;
        if (_iota != null) this._iota = _iota;
        if (_errpos != null) this._errpos = _errpos;
        if (_inTParamList != null) this._inTParamList = _inTParamList;
        if (_sig != null) this._sig = _sig;
        if (_isPanic != null) this._isPanic = _isPanic;
        if (_hasLabel != null) this._hasLabel = _hasLabel;
        if (_hasCallOrRecv != null) this._hasCallOrRecv = _hasCallOrRecv;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_environment(_decl, _scope, _pos, _iota, _errpos, _inTParamList, _sig, _isPanic, _hasLabel, _hasCallOrRecv);
    }
}
/**
    // An importKey identifies an imported package by import path and source directory
    // (directory containing the file containing the import). In practice, the directory
    // may always be the same, or may not matter. Given an (import path, directory), an
    // importer must always return the same package (but given two different import paths,
    // an importer may still return the same package by mapping them to the same package
    // paths).
    
    
**/
@:structInit @:private class T_importKey {
    public var _path : GoString = "";
    public var _dir : GoString = "";
    public function new(?_path:GoString, ?_dir:GoString) {
        if (_path != null) this._path = _path;
        if (_dir != null) this._dir = _dir;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_importKey(_path, _dir);
    }
}
/**
    // A dotImportKey describes a dot-imported object in the given scope.
    
    
**/
@:structInit @:private class T_dotImportKey {
    public var _scope : Ref<stdgo.go.types.Types.Scope> = (null : Ref<stdgo.go.types.Types.Scope>);
    public var _name : GoString = "";
    public function new(?_scope:Ref<stdgo.go.types.Types.Scope>, ?_name:GoString) {
        if (_scope != null) this._scope = _scope;
        if (_name != null) this._name = _name;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_dotImportKey(_scope, _name);
    }
}
/**
    // An action describes a (delayed) action.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_action_static_extension) class T_action {
    public var _f : () -> Void = null;
    public var _desc : Ref<stdgo.go.types.Types.T_actionDesc> = (null : Ref<stdgo.go.types.Types.T_actionDesc>);
    public function new(?_f:() -> Void, ?_desc:Ref<stdgo.go.types.Types.T_actionDesc>) {
        if (_f != null) this._f = _f;
        if (_desc != null) this._desc = _desc;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_action(_f, _desc);
    }
}
/**
    // An actionDesc provides information on an action.
    // For debugging only.
    
    
**/
@:structInit @:private class T_actionDesc {
    public var _pos : stdgo.go.types.Types.T_positioner = (null : stdgo.go.types.Types.T_positioner);
    public var _format : GoString = "";
    public var _args : Slice<AnyInterface> = (null : Slice<AnyInterface>);
    public function new(?_pos:stdgo.go.types.Types.T_positioner, ?_format:GoString, ?_args:Slice<AnyInterface>) {
        if (_pos != null) this._pos = _pos;
        if (_format != null) this._format = _format;
        if (_args != null) this._args = _args;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_actionDesc(_pos, _format, _args);
    }
}
/**
    // A Checker maintains the state of the type checker.
    // It must be created with NewChecker.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Checker_static_extension) class Checker {
    /**
        // package information
        // (initialized by NewChecker, valid for the life-time of checker)
    **/
    public var _conf : Ref<stdgo.go.types.Types.Config> = (null : Ref<stdgo.go.types.Types.Config>);
    public var _ctxt : Ref<stdgo.go.types.Types.Context> = (null : Ref<stdgo.go.types.Types.Context>);
    public var _fset : Ref<stdgo.go.token.Token.FileSet> = (null : Ref<stdgo.go.token.Token.FileSet>);
    public var _pkg : Ref<stdgo.go.types.Types.Package> = (null : Ref<stdgo.go.types.Types.Package>);
    @:embedded
    public var info : Ref<stdgo.go.types.Types.Info> = (null : Ref<stdgo.go.types.Types.Info>);
    public var _version : stdgo.go.types.Types.T_version = ({} : stdgo.go.types.Types.T_version);
    public var _nextID : GoUInt64 = 0;
    public var _objMap : GoMap<stdgo.go.types.Types.Object, Ref<stdgo.go.types.Types.T_declInfo>> = (null : GoMap<stdgo.go.types.Types.Object, Ref<stdgo.go.types.Types.T_declInfo>>);
    public var _impMap : GoMap<stdgo.go.types.Types.T_importKey, Ref<stdgo.go.types.Types.Package>> = (null : GoMap<stdgo.go.types.Types.T_importKey, Ref<stdgo.go.types.Types.Package>>);
    public var _valids : stdgo.go.types.Types.T_instanceLookup = ({} : stdgo.go.types.Types.T_instanceLookup);
    /**
        // pkgPathMap maps package names to the set of distinct import paths we've
        // seen for that name, anywhere in the import graph. It is used for
        // disambiguating package names in error messages.
        //
        // pkgPathMap is allocated lazily, so that we don't pay the price of building
        // it on the happy path. seenPkgMap tracks the packages that we've already
        // walked.
    **/
    public var _pkgPathMap : GoMap<GoString, GoMap<GoString, Bool>> = (null : GoMap<GoString, GoMap<GoString, Bool>>);
    public var _seenPkgMap : GoMap<Ref<stdgo.go.types.Types.Package>, Bool> = (null : GoMap<Ref<stdgo.go.types.Types.Package>, Bool>);
    /**
        // information collected during type-checking of a set of package files
        // (initialized by Files, valid only for the duration of check.Files;
        // maps and lists are allocated on demand)
    **/
    public var _files : Slice<Ref<stdgo.go.ast.Ast.File>> = (null : Slice<Ref<stdgo.go.ast.Ast.File>>);
    public var _imports : Slice<Ref<stdgo.go.types.Types.PkgName>> = (null : Slice<Ref<stdgo.go.types.Types.PkgName>>);
    public var _dotImportMap : GoMap<stdgo.go.types.Types.T_dotImportKey, Ref<stdgo.go.types.Types.PkgName>> = (null : GoMap<stdgo.go.types.Types.T_dotImportKey, Ref<stdgo.go.types.Types.PkgName>>);
    public var _recvTParamMap : GoMap<Ref<stdgo.go.ast.Ast.Ident>, Ref<stdgo.go.types.Types.TypeParam>> = (null : GoMap<Ref<stdgo.go.ast.Ast.Ident>, Ref<stdgo.go.types.Types.TypeParam>>);
    public var _brokenAliases : GoMap<Ref<stdgo.go.types.Types.TypeName>, Bool> = (null : GoMap<Ref<stdgo.go.types.Types.TypeName>, Bool>);
    public var _unionTypeSets : GoMap<Ref<stdgo.go.types.Types.Union>, Ref<stdgo.go.types.Types.T__TypeSet>> = (null : GoMap<Ref<stdgo.go.types.Types.Union>, Ref<stdgo.go.types.Types.T__TypeSet>>);
    public var _mono : stdgo.go.types.Types.T_monoGraph = ({} : stdgo.go.types.Types.T_monoGraph);
    public var _firstErr : Error = (null : Error);
    public var _methods : GoMap<Ref<stdgo.go.types.Types.TypeName>, Slice<Ref<stdgo.go.types.Types.Func>>> = (null : GoMap<Ref<stdgo.go.types.Types.TypeName>, Slice<Ref<stdgo.go.types.Types.Func>>>);
    public var _untyped : GoMap<stdgo.go.ast.Ast.Expr, stdgo.go.types.Types.T_exprInfo> = (null : GoMap<stdgo.go.ast.Ast.Expr, stdgo.go.types.Types.T_exprInfo>);
    public var _delayed : Slice<stdgo.go.types.Types.T_action> = (null : Slice<stdgo.go.types.Types.T_action>);
    public var _objPath : Slice<stdgo.go.types.Types.Object> = (null : Slice<stdgo.go.types.Types.Object>);
    public var _cleaners : Slice<stdgo.go.types.Types.T_cleaner> = (null : Slice<stdgo.go.types.Types.T_cleaner>);
    /**
        // environment within which the current object is type-checked (valid only
        // for the duration of type-checking a specific object)
    **/
    @:embedded
    public var _environment : stdgo.go.types.Types.T_environment = ({} : stdgo.go.types.Types.T_environment);
    /**
        // debugging
    **/
    public var _indent : GoInt = 0;
    public function new(?_conf:Ref<stdgo.go.types.Types.Config>, ?_ctxt:Ref<stdgo.go.types.Types.Context>, ?_fset:Ref<stdgo.go.token.Token.FileSet>, ?_pkg:Ref<stdgo.go.types.Types.Package>, ?info:Ref<stdgo.go.types.Types.Info>, ?_version:stdgo.go.types.Types.T_version, ?_nextID:GoUInt64, ?_objMap:GoMap<stdgo.go.types.Types.Object, Ref<stdgo.go.types.Types.T_declInfo>>, ?_impMap:GoMap<stdgo.go.types.Types.T_importKey, Ref<stdgo.go.types.Types.Package>>, ?_valids:stdgo.go.types.Types.T_instanceLookup, ?_pkgPathMap:GoMap<GoString, GoMap<GoString, Bool>>, ?_seenPkgMap:GoMap<Ref<stdgo.go.types.Types.Package>, Bool>, ?_files:Slice<Ref<stdgo.go.ast.Ast.File>>, ?_imports:Slice<Ref<stdgo.go.types.Types.PkgName>>, ?_dotImportMap:GoMap<stdgo.go.types.Types.T_dotImportKey, Ref<stdgo.go.types.Types.PkgName>>, ?_recvTParamMap:GoMap<Ref<stdgo.go.ast.Ast.Ident>, Ref<stdgo.go.types.Types.TypeParam>>, ?_brokenAliases:GoMap<Ref<stdgo.go.types.Types.TypeName>, Bool>, ?_unionTypeSets:GoMap<Ref<stdgo.go.types.Types.Union>, Ref<stdgo.go.types.Types.T__TypeSet>>, ?_mono:stdgo.go.types.Types.T_monoGraph, ?_firstErr:Error, ?_methods:GoMap<Ref<stdgo.go.types.Types.TypeName>, Slice<Ref<stdgo.go.types.Types.Func>>>, ?_untyped:GoMap<stdgo.go.ast.Ast.Expr, stdgo.go.types.Types.T_exprInfo>, ?_delayed:Slice<stdgo.go.types.Types.T_action>, ?_objPath:Slice<stdgo.go.types.Types.Object>, ?_cleaners:Slice<stdgo.go.types.Types.T_cleaner>, ?_environment:stdgo.go.types.Types.T_environment, ?_indent:GoInt) {
        if (_conf != null) this._conf = _conf;
        if (_ctxt != null) this._ctxt = _ctxt;
        if (_fset != null) this._fset = _fset;
        if (_pkg != null) this._pkg = _pkg;
        if (info != null) this.info = info;
        if (_version != null) this._version = _version;
        if (_nextID != null) this._nextID = _nextID;
        if (_objMap != null) this._objMap = _objMap;
        if (_impMap != null) this._impMap = _impMap;
        if (_valids != null) this._valids = _valids;
        if (_pkgPathMap != null) this._pkgPathMap = _pkgPathMap;
        if (_seenPkgMap != null) this._seenPkgMap = _seenPkgMap;
        if (_files != null) this._files = _files;
        if (_imports != null) this._imports = _imports;
        if (_dotImportMap != null) this._dotImportMap = _dotImportMap;
        if (_recvTParamMap != null) this._recvTParamMap = _recvTParamMap;
        if (_brokenAliases != null) this._brokenAliases = _brokenAliases;
        if (_unionTypeSets != null) this._unionTypeSets = _unionTypeSets;
        if (_mono != null) this._mono = _mono;
        if (_firstErr != null) this._firstErr = _firstErr;
        if (_methods != null) this._methods = _methods;
        if (_untyped != null) this._untyped = _untyped;
        if (_delayed != null) this._delayed = _delayed;
        if (_objPath != null) this._objPath = _objPath;
        if (_cleaners != null) this._cleaners = _cleaners;
        if (_environment != null) this._environment = _environment;
        if (_indent != null) this._indent = _indent;
    }
    public function __underlying__() return Go.toInterface(this);
    @:embedded
    public function objectOf(_id:Ref<stdgo.go.ast.Ast.Ident>):stdgo.go.types.Types.Object return info.objectOf(_id);
    @:embedded
    public function typeOf(_e:stdgo.go.ast.Ast.Expr):stdgo.go.types.Types.Type return info.typeOf(_e);
    @:embedded
    public function _lookup(__0:GoString):stdgo.go.types.Types.Object return _environment._lookup(__0);
    public function __copy__() {
        return new Checker(
_conf,
_ctxt,
_fset,
_pkg,
info,
_version,
_nextID,
_objMap,
_impMap,
_valids,
_pkgPathMap,
_seenPkgMap,
_files,
_imports,
_dotImportMap,
_recvTParamMap,
_brokenAliases,
_unionTypeSets,
_mono,
_firstErr,
_methods,
_untyped,
_delayed,
_objPath,
_cleaners,
_environment,
_indent);
    }
}
/**
    // A bailout panic is used for early termination.
    
    
**/
@:structInit @:private class T_bailout {
    public function new() {}
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_bailout();
    }
}
/**
    // A Context is an opaque type checking context. It may be used to share
    // identical type instances across type-checked packages or calls to
    // Instantiate. Contexts are safe for concurrent use.
    //
    // The use of a shared context does not guarantee that identical instances are
    // deduplicated in all cases.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Context_static_extension) class Context {
    public var _mu : stdgo.sync.Sync.Mutex = ({} : stdgo.sync.Sync.Mutex);
    public var _typeMap : GoMap<GoString, Slice<stdgo.go.types.Types.T_ctxtEntry>> = (null : GoMap<GoString, Slice<stdgo.go.types.Types.T_ctxtEntry>>);
    public var _nextID : GoInt = 0;
    public var _originIDs : GoMap<stdgo.go.types.Types.Type, GoInt> = (null : GoMap<stdgo.go.types.Types.Type, GoInt>);
    public function new(?_mu:stdgo.sync.Sync.Mutex, ?_typeMap:GoMap<GoString, Slice<stdgo.go.types.Types.T_ctxtEntry>>, ?_nextID:GoInt, ?_originIDs:GoMap<stdgo.go.types.Types.Type, GoInt>) {
        if (_mu != null) this._mu = _mu;
        if (_typeMap != null) this._typeMap = _typeMap;
        if (_nextID != null) this._nextID = _nextID;
        if (_originIDs != null) this._originIDs = _originIDs;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Context(_mu, _typeMap, _nextID, _originIDs);
    }
}
/**
    
    
    
**/
@:structInit @:private class T_ctxtEntry {
    public var _orig : stdgo.go.types.Types.Type = (null : stdgo.go.types.Types.Type);
    public var _targs : Slice<stdgo.go.types.Types.Type> = (null : Slice<stdgo.go.types.Types.Type>);
    public var _instance : stdgo.go.types.Types.Type = (null : stdgo.go.types.Types.Type);
    public function new(?_orig:stdgo.go.types.Types.Type, ?_targs:Slice<stdgo.go.types.Types.Type>, ?_instance:stdgo.go.types.Types.Type) {
        if (_orig != null) this._orig = _orig;
        if (_targs != null) this._targs = _targs;
        if (_instance != null) this._instance = _instance;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_ctxtEntry(_orig, _targs, _instance);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_importDecl_static_extension) class T_importDecl {
    public var _spec : Ref<stdgo.go.ast.Ast.ImportSpec> = (null : Ref<stdgo.go.ast.Ast.ImportSpec>);
    public function new(?_spec:Ref<stdgo.go.ast.Ast.ImportSpec>) {
        if (_spec != null) this._spec = _spec;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_importDecl(_spec);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_constDecl_static_extension) class T_constDecl {
    public var _spec : Ref<stdgo.go.ast.Ast.ValueSpec> = (null : Ref<stdgo.go.ast.Ast.ValueSpec>);
    public var _iota : GoInt = 0;
    public var _typ : stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
    public var _init : Slice<stdgo.go.ast.Ast.Expr> = (null : Slice<stdgo.go.ast.Ast.Expr>);
    public var _inherited : Bool = false;
    public function new(?_spec:Ref<stdgo.go.ast.Ast.ValueSpec>, ?_iota:GoInt, ?_typ:stdgo.go.ast.Ast.Expr, ?_init:Slice<stdgo.go.ast.Ast.Expr>, ?_inherited:Bool) {
        if (_spec != null) this._spec = _spec;
        if (_iota != null) this._iota = _iota;
        if (_typ != null) this._typ = _typ;
        if (_init != null) this._init = _init;
        if (_inherited != null) this._inherited = _inherited;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_constDecl(_spec, _iota, _typ, _init, _inherited);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_varDecl_static_extension) class T_varDecl {
    public var _spec : Ref<stdgo.go.ast.Ast.ValueSpec> = (null : Ref<stdgo.go.ast.Ast.ValueSpec>);
    public function new(?_spec:Ref<stdgo.go.ast.Ast.ValueSpec>) {
        if (_spec != null) this._spec = _spec;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_varDecl(_spec);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_typeDecl_static_extension) class T_typeDecl {
    public var _spec : Ref<stdgo.go.ast.Ast.TypeSpec> = (null : Ref<stdgo.go.ast.Ast.TypeSpec>);
    public function new(?_spec:Ref<stdgo.go.ast.Ast.TypeSpec>) {
        if (_spec != null) this._spec = _spec;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_typeDecl(_spec);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_funcDecl_static_extension) class T_funcDecl {
    public var _decl : Ref<stdgo.go.ast.Ast.FuncDecl> = (null : Ref<stdgo.go.ast.Ast.FuncDecl>);
    public function new(?_decl:Ref<stdgo.go.ast.Ast.FuncDecl>) {
        if (_decl != null) this._decl = _decl;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_funcDecl(_decl);
    }
}
/**
    // An error_ represents a type-checking error.
    // To report an error_, call Checker.report.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_error__static_extension) class T_error_ {
    public var _desc : Slice<stdgo.go.types.Types.T_errorDesc> = (null : Slice<stdgo.go.types.Types.T_errorDesc>);
    public var _code : stdgo.internal.types.errors.Errors.Code = ((0 : GoInt) : stdgo.internal.types.errors.Errors.Code);
    public var _soft : Bool = false;
    public function new(?_desc:Slice<stdgo.go.types.Types.T_errorDesc>, ?_code:stdgo.internal.types.errors.Errors.Code, ?_soft:Bool) {
        if (_desc != null) this._desc = _desc;
        if (_code != null) this._code = _code;
        if (_soft != null) this._soft = _soft;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_error_(_desc, _code, _soft);
    }
}
/**
    // An errorDesc describes part of a type-checking error.
    
    
**/
@:structInit @:private class T_errorDesc {
    public var _posn : stdgo.go.types.Types.T_positioner = (null : stdgo.go.types.Types.T_positioner);
    public var _format : GoString = "";
    public var _args : Slice<AnyInterface> = (null : Slice<AnyInterface>);
    public function new(?_posn:stdgo.go.types.Types.T_positioner, ?_format:GoString, ?_args:Slice<AnyInterface>) {
        if (_posn != null) this._posn = _posn;
        if (_format != null) this._format = _format;
        if (_args != null) this._args = _args;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_errorDesc(_posn, _format, _args);
    }
}
/**
    // posSpan holds a position range along with a highlighted position within that
    // range. This is used for positioning errors, with pos by convention being the
    // first position in the source where the error is known to exist, and start
    // and end defining the full span of syntax being considered when the error was
    // detected. Invariant: start <= pos < end || start == pos == end.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_posSpan_static_extension) class T_posSpan {
    public var _start : stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
    public var _pos : stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
    public var _end : stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
    public function new(?_start:stdgo.go.token.Token.Pos, ?_pos:stdgo.go.token.Token.Pos, ?_end:stdgo.go.token.Token.Pos) {
        if (_start != null) this._start = _start;
        if (_pos != null) this._pos = _pos;
        if (_end != null) this._end = _end;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_posSpan(_start, _pos, _end);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_tpWalker_static_extension) class T_tpWalker {
    public var _seen : GoMap<stdgo.go.types.Types.Type, Bool> = (null : GoMap<stdgo.go.types.Types.Type, Bool>);
    public var _tparams : Slice<Ref<stdgo.go.types.Types.TypeParam>> = (null : Slice<Ref<stdgo.go.types.Types.TypeParam>>);
    public function new(?_seen:GoMap<stdgo.go.types.Types.Type, Bool>, ?_tparams:Slice<Ref<stdgo.go.types.Types.TypeParam>>) {
        if (_seen != null) this._seen = _seen;
        if (_tparams != null) this._tparams = _tparams;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_tpWalker(_seen, _tparams);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_cycleFinder_static_extension) class T_cycleFinder {
    public var _tparams : Slice<Ref<stdgo.go.types.Types.TypeParam>> = (null : Slice<Ref<stdgo.go.types.Types.TypeParam>>);
    public var _types : Slice<stdgo.go.types.Types.Type> = (null : Slice<stdgo.go.types.Types.Type>);
    public var _seen : GoMap<stdgo.go.types.Types.Type, Bool> = (null : GoMap<stdgo.go.types.Types.Type, Bool>);
    public function new(?_tparams:Slice<Ref<stdgo.go.types.Types.TypeParam>>, ?_types:Slice<stdgo.go.types.Types.Type>, ?_seen:GoMap<stdgo.go.types.Types.Type, Bool>) {
        if (_tparams != null) this._tparams = _tparams;
        if (_types != null) this._types = _types;
        if (_seen != null) this._seen = _seen;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_cycleFinder(_tparams, _types, _seen);
    }
}
/**
    // A graphNode represents a node in the object dependency graph.
    // Each node p in n.pred represents an edge p->n, and each node
    // s in n.succ represents an edge n->s; with a->b indicating that
    // a depends on b.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_graphNode_static_extension) class T_graphNode {
    public var _obj : stdgo.go.types.Types.T_dependency = (null : stdgo.go.types.Types.T_dependency);
    public var _pred : stdgo.go.types.Types.T_nodeSet = (null : stdgo.go.types.Types.T_nodeSet);
    public var _succ : stdgo.go.types.Types.T_nodeSet = (null : stdgo.go.types.Types.T_nodeSet);
    public var _index : GoInt = 0;
    public var _ndeps : GoInt = 0;
    public function new(?_obj:stdgo.go.types.Types.T_dependency, ?_pred:stdgo.go.types.Types.T_nodeSet, ?_succ:stdgo.go.types.Types.T_nodeSet, ?_index:GoInt, ?_ndeps:GoInt) {
        if (_obj != null) this._obj = _obj;
        if (_pred != null) this._pred = _pred;
        if (_succ != null) this._succ = _succ;
        if (_index != null) this._index = _index;
        if (_ndeps != null) this._ndeps = _ndeps;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_graphNode(_obj, _pred, _succ, _index, _ndeps);
    }
}
/**
    // An Interface represents an interface type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Interface_static_extension) class Interface {
    public var _check : Ref<stdgo.go.types.Types.Checker> = (null : Ref<stdgo.go.types.Types.Checker>);
    public var _methods : Slice<Ref<stdgo.go.types.Types.Func>> = (null : Slice<Ref<stdgo.go.types.Types.Func>>);
    public var _embeddeds : Slice<stdgo.go.types.Types.Type> = (null : Slice<stdgo.go.types.Types.Type>);
    public var _embedPos : Ref<Slice<stdgo.go.token.Token.Pos>> = (null : Ref<Slice<stdgo.go.token.Token.Pos>>);
    public var _implicit : Bool = false;
    public var _complete : Bool = false;
    public var _tset : Ref<stdgo.go.types.Types.T__TypeSet> = (null : Ref<stdgo.go.types.Types.T__TypeSet>);
    public function new(?_check:Ref<stdgo.go.types.Types.Checker>, ?_methods:Slice<Ref<stdgo.go.types.Types.Func>>, ?_embeddeds:Slice<stdgo.go.types.Types.Type>, ?_embedPos:Ref<Slice<stdgo.go.token.Token.Pos>>, ?_implicit:Bool, ?_complete:Bool, ?_tset:Ref<stdgo.go.types.Types.T__TypeSet>) {
        if (_check != null) this._check = _check;
        if (_methods != null) this._methods = _methods;
        if (_embeddeds != null) this._embeddeds = _embeddeds;
        if (_embedPos != null) this._embedPos = _embedPos;
        if (_implicit != null) this._implicit = _implicit;
        if (_complete != null) this._complete = _complete;
        if (_tset != null) this._tset = _tset;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Interface(_check, _methods, _embeddeds, _embedPos, _implicit, _complete, _tset);
    }
}
/**
    // A block tracks label declarations in a block and its enclosing blocks.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_block_static_extension) class T_block {
    public var _parent : Ref<stdgo.go.types.Types.T_block> = (null : Ref<stdgo.go.types.Types.T_block>);
    public var _lstmt : Ref<stdgo.go.ast.Ast.LabeledStmt> = (null : Ref<stdgo.go.ast.Ast.LabeledStmt>);
    public var _labels : GoMap<GoString, Ref<stdgo.go.ast.Ast.LabeledStmt>> = (null : GoMap<GoString, Ref<stdgo.go.ast.Ast.LabeledStmt>>);
    public function new(?_parent:Ref<stdgo.go.types.Types.T_block>, ?_lstmt:Ref<stdgo.go.ast.Ast.LabeledStmt>, ?_labels:GoMap<GoString, Ref<stdgo.go.ast.Ast.LabeledStmt>>) {
        if (_parent != null) this._parent = _parent;
        if (_lstmt != null) this._lstmt = _lstmt;
        if (_labels != null) this._labels = _labels;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_block(_parent, _lstmt, _labels);
    }
}
/**
    // embeddedType represents an embedded type
    
    
**/
@:structInit @:private class T_embeddedType {
    public var _typ : stdgo.go.types.Types.Type = (null : stdgo.go.types.Types.Type);
    public var _index : Slice<GoInt> = (null : Slice<GoInt>);
    public var _indirect : Bool = false;
    public var _multiples : Bool = false;
    public function new(?_typ:stdgo.go.types.Types.Type, ?_index:Slice<GoInt>, ?_indirect:Bool, ?_multiples:Bool) {
        if (_typ != null) this._typ = _typ;
        if (_index != null) this._index = _index;
        if (_indirect != null) this._indirect = _indirect;
        if (_multiples != null) this._multiples = _multiples;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_embeddedType(_typ, _index, _indirect, _multiples);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_instanceLookup_static_extension) class T_instanceLookup {
    /**
        // buf is used to avoid allocating the map m in the common case of a small
        // number of instances.
    **/
    public var _buf : GoArray<Ref<stdgo.go.types.Types.Named>> = new GoArray<Ref<stdgo.go.types.Types.Named>>(...[for (i in 0 ... 3) (null : Ref<stdgo.go.types.Types.Named>)]);
    public var _m : GoMap<Ref<stdgo.go.types.Types.Named>, Slice<Ref<stdgo.go.types.Types.Named>>> = (null : GoMap<Ref<stdgo.go.types.Types.Named>, Slice<Ref<stdgo.go.types.Types.Named>>>);
    public function new(?_buf:GoArray<Ref<stdgo.go.types.Types.Named>>, ?_m:GoMap<Ref<stdgo.go.types.Types.Named>, Slice<Ref<stdgo.go.types.Types.Named>>>) {
        if (_buf != null) this._buf = _buf;
        if (_m != null) this._m = _m;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_instanceLookup(_buf, _m);
    }
}
/**
    // A Map represents a map type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Map__static_extension) class Map_ {
    public var _key : stdgo.go.types.Types.Type = (null : stdgo.go.types.Types.Type);
    public var _elem : stdgo.go.types.Types.Type = (null : stdgo.go.types.Types.Type);
    public function new(?_key:stdgo.go.types.Types.Type, ?_elem:stdgo.go.types.Types.Type) {
        if (_key != null) this._key = _key;
        if (_elem != null) this._elem = _elem;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Map_(_key, _elem);
    }
}
/**
    // A MethodSet is an ordered set of concrete or abstract (interface) methods;
    // a method is a MethodVal selection, and they are ordered by ascending m.Obj().Id().
    // The zero value for a MethodSet is a ready-to-use empty method set.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.MethodSet_static_extension) class MethodSet {
    public var _list : Slice<Ref<stdgo.go.types.Types.Selection>> = (null : Slice<Ref<stdgo.go.types.Types.Selection>>);
    public function new(?_list:Slice<Ref<stdgo.go.types.Types.Selection>>) {
        if (_list != null) this._list = _list;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new MethodSet(_list);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_monoGraph_static_extension) class T_monoGraph {
    public var _vertices : Slice<stdgo.go.types.Types.T_monoVertex> = (null : Slice<stdgo.go.types.Types.T_monoVertex>);
    public var _edges : Slice<stdgo.go.types.Types.T_monoEdge> = (null : Slice<stdgo.go.types.Types.T_monoEdge>);
    /**
        // canon maps method receiver type parameters to their respective
        // receiver type's type parameters.
    **/
    public var _canon : GoMap<Ref<stdgo.go.types.Types.TypeParam>, Ref<stdgo.go.types.Types.TypeParam>> = (null : GoMap<Ref<stdgo.go.types.Types.TypeParam>, Ref<stdgo.go.types.Types.TypeParam>>);
    /**
        // nameIdx maps a defined type or (canonical) type parameter to its
        // vertex index.
    **/
    public var _nameIdx : GoMap<Ref<stdgo.go.types.Types.TypeName>, GoInt> = (null : GoMap<Ref<stdgo.go.types.Types.TypeName>, GoInt>);
    public function new(?_vertices:Slice<stdgo.go.types.Types.T_monoVertex>, ?_edges:Slice<stdgo.go.types.Types.T_monoEdge>, ?_canon:GoMap<Ref<stdgo.go.types.Types.TypeParam>, Ref<stdgo.go.types.Types.TypeParam>>, ?_nameIdx:GoMap<Ref<stdgo.go.types.Types.TypeName>, GoInt>) {
        if (_vertices != null) this._vertices = _vertices;
        if (_edges != null) this._edges = _edges;
        if (_canon != null) this._canon = _canon;
        if (_nameIdx != null) this._nameIdx = _nameIdx;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_monoGraph(_vertices, _edges, _canon, _nameIdx);
    }
}
/**
    
    
    
**/
@:structInit @:private class T_monoVertex {
    public var _weight : GoInt = 0;
    public var _pre : GoInt = 0;
    public var _len : GoInt = 0;
    /**
        // obj is the defined type or type parameter represented by this
        // vertex.
    **/
    public var _obj : Ref<stdgo.go.types.Types.TypeName> = (null : Ref<stdgo.go.types.Types.TypeName>);
    public function new(?_weight:GoInt, ?_pre:GoInt, ?_len:GoInt, ?_obj:Ref<stdgo.go.types.Types.TypeName>) {
        if (_weight != null) this._weight = _weight;
        if (_pre != null) this._pre = _pre;
        if (_len != null) this._len = _len;
        if (_obj != null) this._obj = _obj;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_monoVertex(_weight, _pre, _len, _obj);
    }
}
/**
    
    
    
**/
@:structInit @:private class T_monoEdge {
    public var _dst : GoInt = 0;
    public var _src : GoInt = 0;
    public var _weight : GoInt = 0;
    public var _pos : stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
    public var _typ : stdgo.go.types.Types.Type = (null : stdgo.go.types.Types.Type);
    public function new(?_dst:GoInt, ?_src:GoInt, ?_weight:GoInt, ?_pos:stdgo.go.token.Token.Pos, ?_typ:stdgo.go.types.Types.Type) {
        if (_dst != null) this._dst = _dst;
        if (_src != null) this._src = _src;
        if (_weight != null) this._weight = _weight;
        if (_pos != null) this._pos = _pos;
        if (_typ != null) this._typ = _typ;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_monoEdge(_dst, _src, _weight, _pos, _typ);
    }
}
/**
    // A Named represents a named (defined) type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Named_static_extension) class Named {
    public var _check : Ref<stdgo.go.types.Types.Checker> = (null : Ref<stdgo.go.types.Types.Checker>);
    public var _obj : Ref<stdgo.go.types.Types.TypeName> = (null : Ref<stdgo.go.types.Types.TypeName>);
    /**
        // fromRHS holds the type (on RHS of declaration) this *Named type is derived
        // from (for cycle reporting). Only used by validType, and therefore does not
        // require synchronization.
    **/
    public var _fromRHS : stdgo.go.types.Types.Type = (null : stdgo.go.types.Types.Type);
    /**
        // information for instantiated types; nil otherwise
    **/
    public var _inst : Ref<stdgo.go.types.Types.T_instance> = (null : Ref<stdgo.go.types.Types.T_instance>);
    public var _mu : stdgo.sync.Sync.Mutex = ({} : stdgo.sync.Sync.Mutex);
    public var _state_ : GoUInt32 = 0;
    public var _underlying : stdgo.go.types.Types.Type = (null : stdgo.go.types.Types.Type);
    public var _tparams : Ref<stdgo.go.types.Types.TypeParamList> = (null : Ref<stdgo.go.types.Types.TypeParamList>);
    /**
        // methods declared for this type (not the method set of this type)
        // Signatures are type-checked lazily.
        // For non-instantiated types, this is a fully populated list of methods. For
        // instantiated types, methods are individually expanded when they are first
        // accessed.
    **/
    public var _methods : Slice<Ref<stdgo.go.types.Types.Func>> = (null : Slice<Ref<stdgo.go.types.Types.Func>>);
    /**
        // loader may be provided to lazily load type parameters, underlying type, and methods.
    **/
    public var _loader : Ref<stdgo.go.types.Types.Named> -> { var _0 : Slice<Ref<stdgo.go.types.Types.TypeParam>>; var _1 : stdgo.go.types.Types.Type; var _2 : Slice<Ref<stdgo.go.types.Types.Func>>; } = null;
    public function new(?_check:Ref<stdgo.go.types.Types.Checker>, ?_obj:Ref<stdgo.go.types.Types.TypeName>, ?_fromRHS:stdgo.go.types.Types.Type, ?_inst:Ref<stdgo.go.types.Types.T_instance>, ?_mu:stdgo.sync.Sync.Mutex, ?_state_:GoUInt32, ?_underlying:stdgo.go.types.Types.Type, ?_tparams:Ref<stdgo.go.types.Types.TypeParamList>, ?_methods:Slice<Ref<stdgo.go.types.Types.Func>>, ?_loader:Ref<stdgo.go.types.Types.Named> -> { var _0 : Slice<Ref<stdgo.go.types.Types.TypeParam>>; var _1 : stdgo.go.types.Types.Type; var _2 : Slice<Ref<stdgo.go.types.Types.Func>>; }) {
        if (_check != null) this._check = _check;
        if (_obj != null) this._obj = _obj;
        if (_fromRHS != null) this._fromRHS = _fromRHS;
        if (_inst != null) this._inst = _inst;
        if (_mu != null) this._mu = _mu;
        if (_state_ != null) this._state_ = _state_;
        if (_underlying != null) this._underlying = _underlying;
        if (_tparams != null) this._tparams = _tparams;
        if (_methods != null) this._methods = _methods;
        if (_loader != null) this._loader = _loader;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Named(_check, _obj, _fromRHS, _inst, _mu, _state_, _underlying, _tparams, _methods, _loader);
    }
}
/**
    // instance holds information that is only necessary for instantiated named
    // types.
    
    
**/
@:structInit @:private class T_instance {
    public var _orig : Ref<stdgo.go.types.Types.Named> = (null : Ref<stdgo.go.types.Types.Named>);
    public var _targs : Ref<stdgo.go.types.Types.TypeList> = (null : Ref<stdgo.go.types.Types.TypeList>);
    public var _expandedMethods : GoInt = 0;
    public var _ctxt : Ref<stdgo.go.types.Types.Context> = (null : Ref<stdgo.go.types.Types.Context>);
    public function new(?_orig:Ref<stdgo.go.types.Types.Named>, ?_targs:Ref<stdgo.go.types.Types.TypeList>, ?_expandedMethods:GoInt, ?_ctxt:Ref<stdgo.go.types.Types.Context>) {
        if (_orig != null) this._orig = _orig;
        if (_targs != null) this._targs = _targs;
        if (_expandedMethods != null) this._expandedMethods = _expandedMethods;
        if (_ctxt != null) this._ctxt = _ctxt;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_instance(_orig, _targs, _expandedMethods, _ctxt);
    }
}
/**
    // An object implements the common parts of an Object.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_object_static_extension) class T_object {
    public var _parent : Ref<stdgo.go.types.Types.Scope> = (null : Ref<stdgo.go.types.Types.Scope>);
    public var _pos : stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
    public var _pkg : Ref<stdgo.go.types.Types.Package> = (null : Ref<stdgo.go.types.Types.Package>);
    public var _name : GoString = "";
    public var _typ : stdgo.go.types.Types.Type = (null : stdgo.go.types.Types.Type);
    public var _order_ : GoUInt32 = 0;
    public var _color_ : stdgo.go.types.Types.T_color = ((0 : GoUInt32) : stdgo.go.types.Types.T_color);
    public var _scopePos_ : stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
    public function new(?_parent:Ref<stdgo.go.types.Types.Scope>, ?_pos:stdgo.go.token.Token.Pos, ?_pkg:Ref<stdgo.go.types.Types.Package>, ?_name:GoString, ?_typ:stdgo.go.types.Types.Type, ?_order_:GoUInt32, ?_color_:stdgo.go.types.Types.T_color, ?_scopePos_:stdgo.go.token.Token.Pos) {
        if (_parent != null) this._parent = _parent;
        if (_pos != null) this._pos = _pos;
        if (_pkg != null) this._pkg = _pkg;
        if (_name != null) this._name = _name;
        if (_typ != null) this._typ = _typ;
        if (_order_ != null) this._order_ = _order_;
        if (_color_ != null) this._color_ = _color_;
        if (_scopePos_ != null) this._scopePos_ = _scopePos_;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_object(_parent, _pos, _pkg, _name, _typ, _order_, _color_, _scopePos_);
    }
}
/**
    // A PkgName represents an imported Go package.
    // PkgNames don't have a type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.PkgName_static_extension) class PkgName {
    @:embedded
    public var _object : stdgo.go.types.Types.T_object = ({} : stdgo.go.types.Types.T_object);
    public var _imported : Ref<stdgo.go.types.Types.Package> = (null : Ref<stdgo.go.types.Types.Package>);
    public var _used : Bool = false;
    public function new(?_object:stdgo.go.types.Types.T_object, ?_imported:Ref<stdgo.go.types.Types.Package>, ?_used:Bool) {
        if (_object != null) this._object = _object;
        if (_imported != null) this._imported = _imported;
        if (_used != null) this._used = _used;
    }
    public function __underlying__() return Go.toInterface(this);
    @:embedded
    public function exported():Bool return _object.exported();
    @:embedded
    public function id():GoString return _object.id();
    @:embedded
    public function name():GoString return _object.name();
    @:embedded
    public function parent():Ref<stdgo.go.types.Types.Scope> return _object.parent();
    @:embedded
    public function pkg():Ref<stdgo.go.types.Types.Package> return _object.pkg();
    @:embedded
    public function pos():stdgo.go.token.Token.Pos return _object.pos();
    @:embedded
    public function type():stdgo.go.types.Types.Type return _object.type();
    @:embedded
    public function _color():stdgo.go.types.Types.T_color return _object._color();
    @:embedded
    public function _order():GoUInt32 return _object._order();
    @:embedded
    public function _sameId(_pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return _object._sameId(_pkg_, _name_);
    @:embedded
    public function _scopePos():stdgo.go.token.Token.Pos return _object._scopePos();
    @:embedded
    public function _setColor(__0:stdgo.go.types.Types.T_color) _object._setColor(__0);
    @:embedded
    public function _setOrder(__0:GoUInt32) _object._setOrder(__0);
    @:embedded
    public function _setParent(__0:Ref<stdgo.go.types.Types.Scope>) _object._setParent(__0);
    @:embedded
    public function _setScopePos(_p:stdgo.go.token.Token.Pos) _object._setScopePos(_p);
    @:embedded
    public function _setType(__0:stdgo.go.types.Types.Type) _object._setType(__0);
    public function __copy__() {
        return new PkgName(_object, _imported, _used);
    }
}
/**
    // A Const represents a declared constant.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Const_static_extension) class Const {
    @:embedded
    public var _object : stdgo.go.types.Types.T_object = ({} : stdgo.go.types.Types.T_object);
    public var _val : stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
    public function new(?_object:stdgo.go.types.Types.T_object, ?_val:stdgo.go.constant.Constant.Value) {
        if (_object != null) this._object = _object;
        if (_val != null) this._val = _val;
    }
    public function __underlying__() return Go.toInterface(this);
    @:embedded
    public function exported():Bool return _object.exported();
    @:embedded
    public function id():GoString return _object.id();
    @:embedded
    public function name():GoString return _object.name();
    @:embedded
    public function parent():Ref<stdgo.go.types.Types.Scope> return _object.parent();
    @:embedded
    public function pkg():Ref<stdgo.go.types.Types.Package> return _object.pkg();
    @:embedded
    public function pos():stdgo.go.token.Token.Pos return _object.pos();
    @:embedded
    public function type():stdgo.go.types.Types.Type return _object.type();
    @:embedded
    public function _color():stdgo.go.types.Types.T_color return _object._color();
    @:embedded
    public function _order():GoUInt32 return _object._order();
    @:embedded
    public function _sameId(_pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return _object._sameId(_pkg_, _name_);
    @:embedded
    public function _scopePos():stdgo.go.token.Token.Pos return _object._scopePos();
    @:embedded
    public function _setColor(__0:stdgo.go.types.Types.T_color) _object._setColor(__0);
    @:embedded
    public function _setOrder(__0:GoUInt32) _object._setOrder(__0);
    @:embedded
    public function _setParent(__0:Ref<stdgo.go.types.Types.Scope>) _object._setParent(__0);
    @:embedded
    public function _setScopePos(_p:stdgo.go.token.Token.Pos) _object._setScopePos(_p);
    @:embedded
    public function _setType(__0:stdgo.go.types.Types.Type) _object._setType(__0);
    public function __copy__() {
        return new Const(_object, _val);
    }
}
/**
    // A TypeName represents a name for a (defined or alias) type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.TypeName_static_extension) class TypeName {
    @:embedded
    public var _object : stdgo.go.types.Types.T_object = ({} : stdgo.go.types.Types.T_object);
    public function new(?_object:stdgo.go.types.Types.T_object) {
        if (_object != null) this._object = _object;
    }
    public function __underlying__() return Go.toInterface(this);
    @:embedded
    public function exported():Bool return _object.exported();
    @:embedded
    public function id():GoString return _object.id();
    @:embedded
    public function name():GoString return _object.name();
    @:embedded
    public function parent():Ref<stdgo.go.types.Types.Scope> return _object.parent();
    @:embedded
    public function pkg():Ref<stdgo.go.types.Types.Package> return _object.pkg();
    @:embedded
    public function pos():stdgo.go.token.Token.Pos return _object.pos();
    @:embedded
    public function type():stdgo.go.types.Types.Type return _object.type();
    @:embedded
    public function _color():stdgo.go.types.Types.T_color return _object._color();
    @:embedded
    public function _order():GoUInt32 return _object._order();
    @:embedded
    public function _sameId(_pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return _object._sameId(_pkg_, _name_);
    @:embedded
    public function _scopePos():stdgo.go.token.Token.Pos return _object._scopePos();
    @:embedded
    public function _setColor(__0:stdgo.go.types.Types.T_color) _object._setColor(__0);
    @:embedded
    public function _setOrder(__0:GoUInt32) _object._setOrder(__0);
    @:embedded
    public function _setParent(__0:Ref<stdgo.go.types.Types.Scope>) _object._setParent(__0);
    @:embedded
    public function _setScopePos(_p:stdgo.go.token.Token.Pos) _object._setScopePos(_p);
    @:embedded
    public function _setType(__0:stdgo.go.types.Types.Type) _object._setType(__0);
    public function __copy__() {
        return new TypeName(_object);
    }
}
/**
    // A Variable represents a declared variable (including function parameters and results, and struct fields).
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Var_static_extension) class Var {
    @:embedded
    public var _object : stdgo.go.types.Types.T_object = ({} : stdgo.go.types.Types.T_object);
    public var _embedded : Bool = false;
    public var _isField : Bool = false;
    public var _used : Bool = false;
    public var _origin : Ref<stdgo.go.types.Types.Var> = (null : Ref<stdgo.go.types.Types.Var>);
    public function new(?_object:stdgo.go.types.Types.T_object, ?_embedded:Bool, ?_isField:Bool, ?_used:Bool, ?_origin:Ref<stdgo.go.types.Types.Var>) {
        if (_object != null) this._object = _object;
        if (_embedded != null) this._embedded = _embedded;
        if (_isField != null) this._isField = _isField;
        if (_used != null) this._used = _used;
        if (_origin != null) this._origin = _origin;
    }
    public function __underlying__() return Go.toInterface(this);
    @:embedded
    public function exported():Bool return _object.exported();
    @:embedded
    public function id():GoString return _object.id();
    @:embedded
    public function name():GoString return _object.name();
    @:embedded
    public function parent():Ref<stdgo.go.types.Types.Scope> return _object.parent();
    @:embedded
    public function pkg():Ref<stdgo.go.types.Types.Package> return _object.pkg();
    @:embedded
    public function pos():stdgo.go.token.Token.Pos return _object.pos();
    @:embedded
    public function type():stdgo.go.types.Types.Type return _object.type();
    @:embedded
    public function _color():stdgo.go.types.Types.T_color return _object._color();
    @:embedded
    public function _order():GoUInt32 return _object._order();
    @:embedded
    public function _sameId(_pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return _object._sameId(_pkg_, _name_);
    @:embedded
    public function _scopePos():stdgo.go.token.Token.Pos return _object._scopePos();
    @:embedded
    public function _setColor(__0:stdgo.go.types.Types.T_color) _object._setColor(__0);
    @:embedded
    public function _setOrder(__0:GoUInt32) _object._setOrder(__0);
    @:embedded
    public function _setParent(__0:Ref<stdgo.go.types.Types.Scope>) _object._setParent(__0);
    @:embedded
    public function _setScopePos(_p:stdgo.go.token.Token.Pos) _object._setScopePos(_p);
    @:embedded
    public function _setType(__0:stdgo.go.types.Types.Type) _object._setType(__0);
    public function __copy__() {
        return new Var(_object, _embedded, _isField, _used, _origin);
    }
}
/**
    // A Func represents a declared function, concrete method, or abstract
    // (interface) method. Its Type() is always a *Signature.
    // An abstract method may belong to many interfaces due to embedding.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Func_static_extension) class Func {
    @:embedded
    public var _object : stdgo.go.types.Types.T_object = ({} : stdgo.go.types.Types.T_object);
    public var _hasPtrRecv_ : Bool = false;
    public var _origin : Ref<stdgo.go.types.Types.Func> = (null : Ref<stdgo.go.types.Types.Func>);
    public function new(?_object:stdgo.go.types.Types.T_object, ?_hasPtrRecv_:Bool, ?_origin:Ref<stdgo.go.types.Types.Func>) {
        if (_object != null) this._object = _object;
        if (_hasPtrRecv_ != null) this._hasPtrRecv_ = _hasPtrRecv_;
        if (_origin != null) this._origin = _origin;
    }
    public function __underlying__() return Go.toInterface(this);
    @:embedded
    public function exported():Bool return _object.exported();
    @:embedded
    public function id():GoString return _object.id();
    @:embedded
    public function name():GoString return _object.name();
    @:embedded
    public function parent():Ref<stdgo.go.types.Types.Scope> return _object.parent();
    @:embedded
    public function pkg():Ref<stdgo.go.types.Types.Package> return _object.pkg();
    @:embedded
    public function pos():stdgo.go.token.Token.Pos return _object.pos();
    @:embedded
    public function type():stdgo.go.types.Types.Type return _object.type();
    @:embedded
    public function _color():stdgo.go.types.Types.T_color return _object._color();
    @:embedded
    public function _order():GoUInt32 return _object._order();
    @:embedded
    public function _sameId(_pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return _object._sameId(_pkg_, _name_);
    @:embedded
    public function _scopePos():stdgo.go.token.Token.Pos return _object._scopePos();
    @:embedded
    public function _setColor(__0:stdgo.go.types.Types.T_color) _object._setColor(__0);
    @:embedded
    public function _setOrder(__0:GoUInt32) _object._setOrder(__0);
    @:embedded
    public function _setParent(__0:Ref<stdgo.go.types.Types.Scope>) _object._setParent(__0);
    @:embedded
    public function _setScopePos(_p:stdgo.go.token.Token.Pos) _object._setScopePos(_p);
    @:embedded
    public function _setType(__0:stdgo.go.types.Types.Type) _object._setType(__0);
    public function __copy__() {
        return new Func(_object, _hasPtrRecv_, _origin);
    }
}
/**
    // A Label represents a declared label.
    // Labels don't have a type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Label_static_extension) class Label {
    @:embedded
    public var _object : stdgo.go.types.Types.T_object = ({} : stdgo.go.types.Types.T_object);
    public var _used : Bool = false;
    public function new(?_object:stdgo.go.types.Types.T_object, ?_used:Bool) {
        if (_object != null) this._object = _object;
        if (_used != null) this._used = _used;
    }
    public function __underlying__() return Go.toInterface(this);
    @:embedded
    public function exported():Bool return _object.exported();
    @:embedded
    public function id():GoString return _object.id();
    @:embedded
    public function name():GoString return _object.name();
    @:embedded
    public function parent():Ref<stdgo.go.types.Types.Scope> return _object.parent();
    @:embedded
    public function pkg():Ref<stdgo.go.types.Types.Package> return _object.pkg();
    @:embedded
    public function pos():stdgo.go.token.Token.Pos return _object.pos();
    @:embedded
    public function type():stdgo.go.types.Types.Type return _object.type();
    @:embedded
    public function _color():stdgo.go.types.Types.T_color return _object._color();
    @:embedded
    public function _order():GoUInt32 return _object._order();
    @:embedded
    public function _sameId(_pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return _object._sameId(_pkg_, _name_);
    @:embedded
    public function _scopePos():stdgo.go.token.Token.Pos return _object._scopePos();
    @:embedded
    public function _setColor(__0:stdgo.go.types.Types.T_color) _object._setColor(__0);
    @:embedded
    public function _setOrder(__0:GoUInt32) _object._setOrder(__0);
    @:embedded
    public function _setParent(__0:Ref<stdgo.go.types.Types.Scope>) _object._setParent(__0);
    @:embedded
    public function _setScopePos(_p:stdgo.go.token.Token.Pos) _object._setScopePos(_p);
    @:embedded
    public function _setType(__0:stdgo.go.types.Types.Type) _object._setType(__0);
    public function __copy__() {
        return new Label(_object, _used);
    }
}
/**
    // A Builtin represents a built-in function.
    // Builtins don't have a valid type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Builtin_static_extension) class Builtin {
    @:embedded
    public var _object : stdgo.go.types.Types.T_object = ({} : stdgo.go.types.Types.T_object);
    public var _id : stdgo.go.types.Types.T_builtinId = ((0 : GoInt) : stdgo.go.types.Types.T_builtinId);
    public function new(?_object:stdgo.go.types.Types.T_object, ?_id:stdgo.go.types.Types.T_builtinId) {
        if (_object != null) this._object = _object;
        if (_id != null) this._id = _id;
    }
    public function __underlying__() return Go.toInterface(this);
    @:embedded
    public function exported():Bool return _object.exported();
    @:embedded
    public function id():GoString return _object.id();
    @:embedded
    public function name():GoString return _object.name();
    @:embedded
    public function parent():Ref<stdgo.go.types.Types.Scope> return _object.parent();
    @:embedded
    public function pkg():Ref<stdgo.go.types.Types.Package> return _object.pkg();
    @:embedded
    public function pos():stdgo.go.token.Token.Pos return _object.pos();
    @:embedded
    public function type():stdgo.go.types.Types.Type return _object.type();
    @:embedded
    public function _color():stdgo.go.types.Types.T_color return _object._color();
    @:embedded
    public function _order():GoUInt32 return _object._order();
    @:embedded
    public function _sameId(_pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return _object._sameId(_pkg_, _name_);
    @:embedded
    public function _scopePos():stdgo.go.token.Token.Pos return _object._scopePos();
    @:embedded
    public function _setColor(__0:stdgo.go.types.Types.T_color) _object._setColor(__0);
    @:embedded
    public function _setOrder(__0:GoUInt32) _object._setOrder(__0);
    @:embedded
    public function _setParent(__0:Ref<stdgo.go.types.Types.Scope>) _object._setParent(__0);
    @:embedded
    public function _setScopePos(_p:stdgo.go.token.Token.Pos) _object._setScopePos(_p);
    @:embedded
    public function _setType(__0:stdgo.go.types.Types.Type) _object._setType(__0);
    public function __copy__() {
        return new Builtin(_object, _id);
    }
}
/**
    // Nil represents the predeclared value nil.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Nil_static_extension) class Nil {
    @:embedded
    public var _object : stdgo.go.types.Types.T_object = ({} : stdgo.go.types.Types.T_object);
    public function new(?_object:stdgo.go.types.Types.T_object) {
        if (_object != null) this._object = _object;
    }
    public function __underlying__() return Go.toInterface(this);
    @:embedded
    public function exported():Bool return _object.exported();
    @:embedded
    public function id():GoString return _object.id();
    @:embedded
    public function name():GoString return _object.name();
    @:embedded
    public function parent():Ref<stdgo.go.types.Types.Scope> return _object.parent();
    @:embedded
    public function pkg():Ref<stdgo.go.types.Types.Package> return _object.pkg();
    @:embedded
    public function pos():stdgo.go.token.Token.Pos return _object.pos();
    @:embedded
    public function type():stdgo.go.types.Types.Type return _object.type();
    @:embedded
    public function _color():stdgo.go.types.Types.T_color return _object._color();
    @:embedded
    public function _order():GoUInt32 return _object._order();
    @:embedded
    public function _sameId(_pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return _object._sameId(_pkg_, _name_);
    @:embedded
    public function _scopePos():stdgo.go.token.Token.Pos return _object._scopePos();
    @:embedded
    public function _setColor(__0:stdgo.go.types.Types.T_color) _object._setColor(__0);
    @:embedded
    public function _setOrder(__0:GoUInt32) _object._setOrder(__0);
    @:embedded
    public function _setParent(__0:Ref<stdgo.go.types.Types.Scope>) _object._setParent(__0);
    @:embedded
    public function _setScopePos(_p:stdgo.go.token.Token.Pos) _object._setScopePos(_p);
    @:embedded
    public function _setType(__0:stdgo.go.types.Types.Type) _object._setType(__0);
    public function __copy__() {
        return new Nil(_object);
    }
}
/**
    // An operand represents an intermediate value during type checking.
    // Operands have an (addressing) mode, the expression evaluating to
    // the operand, the operand's type, a value for constants, and an id
    // for built-in functions.
    // The zero value of operand is a ready to use invalid operand.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_operand_static_extension) class T_operand {
    public var _mode : stdgo.go.types.Types.T_operandMode = ((0 : GoUInt8) : stdgo.go.types.Types.T_operandMode);
    public var _expr : stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
    public var _typ : stdgo.go.types.Types.Type = (null : stdgo.go.types.Types.Type);
    public var _val : stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
    public var _id : stdgo.go.types.Types.T_builtinId = ((0 : GoInt) : stdgo.go.types.Types.T_builtinId);
    public function new(?_mode:stdgo.go.types.Types.T_operandMode, ?_expr:stdgo.go.ast.Ast.Expr, ?_typ:stdgo.go.types.Types.Type, ?_val:stdgo.go.constant.Constant.Value, ?_id:stdgo.go.types.Types.T_builtinId) {
        if (_mode != null) this._mode = _mode;
        if (_expr != null) this._expr = _expr;
        if (_typ != null) this._typ = _typ;
        if (_val != null) this._val = _val;
        if (_id != null) this._id = _id;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_operand(_mode, _expr, _typ, _val, _id);
    }
}
/**
    // A Package describes a Go package.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Package_static_extension) class Package {
    public var _path : GoString = "";
    public var _name : GoString = "";
    public var _scope : Ref<stdgo.go.types.Types.Scope> = (null : Ref<stdgo.go.types.Types.Scope>);
    public var _complete : Bool = false;
    public var _imports : Slice<Ref<stdgo.go.types.Types.Package>> = (null : Slice<Ref<stdgo.go.types.Types.Package>>);
    public var _fake : Bool = false;
    public var _cgo : Bool = false;
    public function new(?_path:GoString, ?_name:GoString, ?_scope:Ref<stdgo.go.types.Types.Scope>, ?_complete:Bool, ?_imports:Slice<Ref<stdgo.go.types.Types.Package>>, ?_fake:Bool, ?_cgo:Bool) {
        if (_path != null) this._path = _path;
        if (_name != null) this._name = _name;
        if (_scope != null) this._scope = _scope;
        if (_complete != null) this._complete = _complete;
        if (_imports != null) this._imports = _imports;
        if (_fake != null) this._fake = _fake;
        if (_cgo != null) this._cgo = _cgo;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Package(_path, _name, _scope, _complete, _imports, _fake, _cgo);
    }
}
/**
    // A Pointer represents a pointer type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Pointer__static_extension) class Pointer_ {
    public var _base : stdgo.go.types.Types.Type = (null : stdgo.go.types.Types.Type);
    public function new(?_base:stdgo.go.types.Types.Type) {
        if (_base != null) this._base = _base;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Pointer_(_base);
    }
}
/**
    // An ifacePair is a node in a stack of interface type pairs compared for identity.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_ifacePair_static_extension) class T_ifacePair {
    public var _x : Ref<stdgo.go.types.Types.Interface> = (null : Ref<stdgo.go.types.Types.Interface>);
    public var _y : Ref<stdgo.go.types.Types.Interface> = (null : Ref<stdgo.go.types.Types.Interface>);
    public var _prev : Ref<stdgo.go.types.Types.T_ifacePair> = (null : Ref<stdgo.go.types.Types.T_ifacePair>);
    public function new(?_x:Ref<stdgo.go.types.Types.Interface>, ?_y:Ref<stdgo.go.types.Types.Interface>, ?_prev:Ref<stdgo.go.types.Types.T_ifacePair>) {
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_prev != null) this._prev = _prev;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_ifacePair(_x, _y, _prev);
    }
}
/**
    // A declInfo describes a package-level const, type, var, or func declaration.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_declInfo_static_extension) class T_declInfo {
    public var _file : Ref<stdgo.go.types.Types.Scope> = (null : Ref<stdgo.go.types.Types.Scope>);
    public var _lhs : Slice<Ref<stdgo.go.types.Types.Var>> = (null : Slice<Ref<stdgo.go.types.Types.Var>>);
    public var _vtyp : stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
    public var _init : stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
    public var _inherited : Bool = false;
    public var _tdecl : Ref<stdgo.go.ast.Ast.TypeSpec> = (null : Ref<stdgo.go.ast.Ast.TypeSpec>);
    public var _fdecl : Ref<stdgo.go.ast.Ast.FuncDecl> = (null : Ref<stdgo.go.ast.Ast.FuncDecl>);
    /**
        // The deps field tracks initialization expression dependencies.
    **/
    public var _deps : GoMap<stdgo.go.types.Types.Object, Bool> = (null : GoMap<stdgo.go.types.Types.Object, Bool>);
    public function new(?_file:Ref<stdgo.go.types.Types.Scope>, ?_lhs:Slice<Ref<stdgo.go.types.Types.Var>>, ?_vtyp:stdgo.go.ast.Ast.Expr, ?_init:stdgo.go.ast.Ast.Expr, ?_inherited:Bool, ?_tdecl:Ref<stdgo.go.ast.Ast.TypeSpec>, ?_fdecl:Ref<stdgo.go.ast.Ast.FuncDecl>, ?_deps:GoMap<stdgo.go.types.Types.Object, Bool>) {
        if (_file != null) this._file = _file;
        if (_lhs != null) this._lhs = _lhs;
        if (_vtyp != null) this._vtyp = _vtyp;
        if (_init != null) this._init = _init;
        if (_inherited != null) this._inherited = _inherited;
        if (_tdecl != null) this._tdecl = _tdecl;
        if (_fdecl != null) this._fdecl = _fdecl;
        if (_deps != null) this._deps = _deps;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_declInfo(_file, _lhs, _vtyp, _init, _inherited, _tdecl, _fdecl, _deps);
    }
}
/**
    // A Scope maintains a set of objects and links to its containing
    // (parent) and contained (children) scopes. Objects may be inserted
    // and looked up by name. The zero value for Scope is a ready-to-use
    // empty scope.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Scope_static_extension) class Scope {
    public var _parent : Ref<stdgo.go.types.Types.Scope> = (null : Ref<stdgo.go.types.Types.Scope>);
    public var _children : Slice<Ref<stdgo.go.types.Types.Scope>> = (null : Slice<Ref<stdgo.go.types.Types.Scope>>);
    public var _number : GoInt = 0;
    public var _elems : GoMap<GoString, stdgo.go.types.Types.Object> = (null : GoMap<GoString, stdgo.go.types.Types.Object>);
    public var _pos : stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
    public var _end : stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
    public var _comment : GoString = "";
    public var _isFunc : Bool = false;
    public function new(?_parent:Ref<stdgo.go.types.Types.Scope>, ?_children:Slice<Ref<stdgo.go.types.Types.Scope>>, ?_number:GoInt, ?_elems:GoMap<GoString, stdgo.go.types.Types.Object>, ?_pos:stdgo.go.token.Token.Pos, ?_end:stdgo.go.token.Token.Pos, ?_comment:GoString, ?_isFunc:Bool) {
        if (_parent != null) this._parent = _parent;
        if (_children != null) this._children = _children;
        if (_number != null) this._number = _number;
        if (_elems != null) this._elems = _elems;
        if (_pos != null) this._pos = _pos;
        if (_end != null) this._end = _end;
        if (_comment != null) this._comment = _comment;
        if (_isFunc != null) this._isFunc = _isFunc;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Scope(_parent, _children, _number, _elems, _pos, _end, _comment, _isFunc);
    }
}
/**
    // A lazyObject represents an imported Object that has not been fully
    // resolved yet by its importer.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_lazyObject_static_extension) class T_lazyObject {
    public var _parent : Ref<stdgo.go.types.Types.Scope> = (null : Ref<stdgo.go.types.Types.Scope>);
    public var _resolve : () -> stdgo.go.types.Types.Object = null;
    public var _obj : stdgo.go.types.Types.Object = (null : stdgo.go.types.Types.Object);
    public var _once : stdgo.sync.Sync.Once = ({} : stdgo.sync.Sync.Once);
    public function new(?_parent:Ref<stdgo.go.types.Types.Scope>, ?_resolve:() -> stdgo.go.types.Types.Object, ?_obj:stdgo.go.types.Types.Object, ?_once:stdgo.sync.Sync.Once) {
        if (_parent != null) this._parent = _parent;
        if (_resolve != null) this._resolve = _resolve;
        if (_obj != null) this._obj = _obj;
        if (_once != null) this._once = _once;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_lazyObject(_parent, _resolve, _obj, _once);
    }
}
/**
    // A Selection describes a selector expression x.f.
    // For the declarations:
    //
    //	type T struct{ x int; E }
    //	type E struct{}
    //	func (e E) m() {}
    //	var p *T
    //
    // the following relations exist:
    //
    //	Selector    Kind          Recv    Obj    Type       Index     Indirect
    //
    //	p.x         FieldVal      T       x      int        {0}       true
    //	p.m         MethodVal     *T      m      func()     {1, 0}    true
    //	T.m         MethodExpr    T       m      func(T)    {1, 0}    false
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Selection_static_extension) class Selection {
    public var _kind : stdgo.go.types.Types.SelectionKind = ((0 : GoInt) : stdgo.go.types.Types.SelectionKind);
    public var _recv : stdgo.go.types.Types.Type = (null : stdgo.go.types.Types.Type);
    public var _obj : stdgo.go.types.Types.Object = (null : stdgo.go.types.Types.Object);
    public var _index : Slice<GoInt> = (null : Slice<GoInt>);
    public var _indirect : Bool = false;
    public function new(?_kind:stdgo.go.types.Types.SelectionKind, ?_recv:stdgo.go.types.Types.Type, ?_obj:stdgo.go.types.Types.Object, ?_index:Slice<GoInt>, ?_indirect:Bool) {
        if (_kind != null) this._kind = _kind;
        if (_recv != null) this._recv = _recv;
        if (_obj != null) this._obj = _obj;
        if (_index != null) this._index = _index;
        if (_indirect != null) this._indirect = _indirect;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Selection(_kind, _recv, _obj, _index, _indirect);
    }
}
/**
    // A Signature represents a (non-builtin) function or method type.
    // The receiver is ignored when comparing signatures for identity.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Signature_static_extension) class Signature {
    /**
        // We need to keep the scope in Signature (rather than passing it around
        // and store it in the Func Object) because when type-checking a function
        // literal we call the general type checker which returns a general Type.
        // We then unpack the *Signature and use the scope for the literal body.
    **/
    public var _rparams : Ref<stdgo.go.types.Types.TypeParamList> = (null : Ref<stdgo.go.types.Types.TypeParamList>);
    public var _tparams : Ref<stdgo.go.types.Types.TypeParamList> = (null : Ref<stdgo.go.types.Types.TypeParamList>);
    public var _scope : Ref<stdgo.go.types.Types.Scope> = (null : Ref<stdgo.go.types.Types.Scope>);
    public var _recv : Ref<stdgo.go.types.Types.Var> = (null : Ref<stdgo.go.types.Types.Var>);
    public var _params : Ref<stdgo.go.types.Types.Tuple> = (null : Ref<stdgo.go.types.Types.Tuple>);
    public var _results : Ref<stdgo.go.types.Types.Tuple> = (null : Ref<stdgo.go.types.Types.Tuple>);
    public var _variadic : Bool = false;
    public function new(?_rparams:Ref<stdgo.go.types.Types.TypeParamList>, ?_tparams:Ref<stdgo.go.types.Types.TypeParamList>, ?_scope:Ref<stdgo.go.types.Types.Scope>, ?_recv:Ref<stdgo.go.types.Types.Var>, ?_params:Ref<stdgo.go.types.Types.Tuple>, ?_results:Ref<stdgo.go.types.Types.Tuple>, ?_variadic:Bool) {
        if (_rparams != null) this._rparams = _rparams;
        if (_tparams != null) this._tparams = _tparams;
        if (_scope != null) this._scope = _scope;
        if (_recv != null) this._recv = _recv;
        if (_params != null) this._params = _params;
        if (_results != null) this._results = _results;
        if (_variadic != null) this._variadic = _variadic;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Signature(_rparams, _tparams, _scope, _recv, _params, _results, _variadic);
    }
}
/**
    // StdSizes is a convenience type for creating commonly used Sizes.
    // It makes the following simplifying assumptions:
    //
    //   - The size of explicitly sized basic types (int16, etc.) is the
    //     specified size.
    //   - The size of strings and interfaces is 2*WordSize.
    //   - The size of slices is 3*WordSize.
    //   - The size of an array of n elements corresponds to the size of
    //     a struct of n consecutive fields of the array's element type.
    //   - The size of a struct is the offset of the last field plus that
    //     field's size. As with all element types, if the struct is used
    //     in an array its size must first be aligned to a multiple of the
    //     struct's alignment.
    //   - All other types have size WordSize.
    //   - Arrays and structs are aligned per spec definition; all other
    //     types are naturally aligned with a maximum alignment MaxAlign.
    //
    // *StdSizes implements Sizes.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.StdSizes_static_extension) class StdSizes {
    public var wordSize : GoInt64 = 0;
    public var maxAlign : GoInt64 = 0;
    public function new(?wordSize:GoInt64, ?maxAlign:GoInt64) {
        if (wordSize != null) this.wordSize = wordSize;
        if (maxAlign != null) this.maxAlign = maxAlign;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new StdSizes(wordSize, maxAlign);
    }
}
/**
    // A Slice represents a slice type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Slice__static_extension) class Slice_ {
    public var _elem : stdgo.go.types.Types.Type = (null : stdgo.go.types.Types.Type);
    public function new(?_elem:stdgo.go.types.Types.Type) {
        if (_elem != null) this._elem = _elem;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Slice_(_elem);
    }
}
/**
    // A valueMap maps a case value (of a basic Go type) to a list of positions
    // where the same case value appeared, together with the corresponding case
    // types.
    // Since two case values may have the same "underlying" value but different
    // types we need to also check the value's types (e.g., byte(1) vs myByte(1))
    // when the switch expression is of interface type.
    
    
**/
@:structInit @:private class T_valueType {
    public var _pos : stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
    public var _typ : stdgo.go.types.Types.Type = (null : stdgo.go.types.Types.Type);
    public function new(?_pos:stdgo.go.token.Token.Pos, ?_typ:stdgo.go.types.Types.Type) {
        if (_pos != null) this._pos = _pos;
        if (_typ != null) this._typ = _typ;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_valueType(_pos, _typ);
    }
}
/**
    // A Struct represents a struct type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Struct_static_extension) class Struct {
    public var _fields : Slice<Ref<stdgo.go.types.Types.Var>> = (null : Slice<Ref<stdgo.go.types.Types.Var>>);
    public var _tags : Slice<GoString> = (null : Slice<GoString>);
    public function new(?_fields:Slice<Ref<stdgo.go.types.Types.Var>>, ?_tags:Slice<GoString>) {
        if (_fields != null) this._fields = _fields;
        if (_tags != null) this._tags = _tags;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Struct(_fields, _tags);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_subster_static_extension) class T_subster {
    public var _pos : stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
    public var _smap : stdgo.go.types.Types.T_substMap = (null : stdgo.go.types.Types.T_substMap);
    public var _check : Ref<stdgo.go.types.Types.Checker> = (null : Ref<stdgo.go.types.Types.Checker>);
    public var _expanding : Ref<stdgo.go.types.Types.Named> = (null : Ref<stdgo.go.types.Types.Named>);
    public var _ctxt : Ref<stdgo.go.types.Types.Context> = (null : Ref<stdgo.go.types.Types.Context>);
    public function new(?_pos:stdgo.go.token.Token.Pos, ?_smap:stdgo.go.types.Types.T_substMap, ?_check:Ref<stdgo.go.types.Types.Checker>, ?_expanding:Ref<stdgo.go.types.Types.Named>, ?_ctxt:Ref<stdgo.go.types.Types.Context>) {
        if (_pos != null) this._pos = _pos;
        if (_smap != null) this._smap = _smap;
        if (_check != null) this._check = _check;
        if (_expanding != null) this._expanding = _expanding;
        if (_ctxt != null) this._ctxt = _ctxt;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_subster(_pos, _smap, _check, _expanding, _ctxt);
    }
}
/**
    // A Tuple represents an ordered list of variables; a nil *Tuple is a valid (empty) tuple.
    // Tuples are used as components of signatures and to represent the type of multiple
    // assignments; they are not first class types of Go.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Tuple_static_extension) class Tuple {
    public var _vars : Slice<Ref<stdgo.go.types.Types.Var>> = (null : Slice<Ref<stdgo.go.types.Types.Var>>);
    public function new(?_vars:Slice<Ref<stdgo.go.types.Types.Var>>) {
        if (_vars != null) this._vars = _vars;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Tuple(_vars);
    }
}
/**
    // TypeParamList holds a list of type parameters.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.TypeParamList_static_extension) class TypeParamList {
    public var _tparams : Slice<Ref<stdgo.go.types.Types.TypeParam>> = (null : Slice<Ref<stdgo.go.types.Types.TypeParam>>);
    public function new(?_tparams:Slice<Ref<stdgo.go.types.Types.TypeParam>>) {
        if (_tparams != null) this._tparams = _tparams;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new TypeParamList(_tparams);
    }
}
/**
    // TypeList holds a list of types.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.TypeList_static_extension) class TypeList {
    public var _types : Slice<stdgo.go.types.Types.Type> = (null : Slice<stdgo.go.types.Types.Type>);
    public function new(?_types:Slice<stdgo.go.types.Types.Type>) {
        if (_types != null) this._types = _types;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new TypeList(_types);
    }
}
/**
    // A TypeParam represents a type parameter type.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.TypeParam_static_extension) class TypeParam {
    public var _check : Ref<stdgo.go.types.Types.Checker> = (null : Ref<stdgo.go.types.Types.Checker>);
    public var _id : GoUInt64 = 0;
    public var _obj : Ref<stdgo.go.types.Types.TypeName> = (null : Ref<stdgo.go.types.Types.TypeName>);
    public var _index : GoInt = 0;
    public var _bound : stdgo.go.types.Types.Type = (null : stdgo.go.types.Types.Type);
    public function new(?_check:Ref<stdgo.go.types.Types.Checker>, ?_id:GoUInt64, ?_obj:Ref<stdgo.go.types.Types.TypeName>, ?_index:GoInt, ?_bound:stdgo.go.types.Types.Type) {
        if (_check != null) this._check = _check;
        if (_id != null) this._id = _id;
        if (_obj != null) this._obj = _obj;
        if (_index != null) this._index = _index;
        if (_bound != null) this._bound = _bound;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new TypeParam(_check, _id, _obj, _index, _bound);
    }
}
/**
    // A _TypeSet represents the type set of an interface.
    // Because of existing language restrictions, methods can be "factored out"
    // from the terms. The actual type set is the intersection of the type set
    // implied by the methods and the type set described by the terms and the
    // comparable bit. To test whether a type is included in a type set
    // ("implements" relation), the type must implement all methods _and_ be
    // an element of the type set described by the terms and the comparable bit.
    // If the term list describes the set of all types and comparable is true,
    // only comparable types are meant; in all other cases comparable is false.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T__TypeSet_static_extension) class T__TypeSet {
    public var _methods : Slice<Ref<stdgo.go.types.Types.Func>> = (null : Slice<Ref<stdgo.go.types.Types.Func>>);
    public var _terms : stdgo.go.types.Types.T_termlist = new stdgo.go.types.Types.T_termlist(0, 0);
    public var _comparable : Bool = false;
    public function new(?_methods:Slice<Ref<stdgo.go.types.Types.Func>>, ?_terms:stdgo.go.types.Types.T_termlist, ?_comparable:Bool) {
        if (_methods != null) this._methods = _methods;
        if (_terms != null) this._terms = _terms;
        if (_comparable != null) this._comparable = _comparable;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T__TypeSet(_methods, _terms, _comparable);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_typeWriter_static_extension) class T_typeWriter {
    public var _buf : Ref<stdgo.bytes.Bytes.Buffer> = (null : Ref<stdgo.bytes.Bytes.Buffer>);
    public var _seen : GoMap<stdgo.go.types.Types.Type, Bool> = (null : GoMap<stdgo.go.types.Types.Type, Bool>);
    public var _qf : stdgo.go.types.Types.Qualifier = (null : stdgo.go.types.Types.Qualifier);
    public var _ctxt : Ref<stdgo.go.types.Types.Context> = (null : Ref<stdgo.go.types.Types.Context>);
    public var _tparams : Ref<stdgo.go.types.Types.TypeParamList> = (null : Ref<stdgo.go.types.Types.TypeParamList>);
    public var _paramNames : Bool = false;
    public var _tpSubscripts : Bool = false;
    public var _pkgInfo : Bool = false;
    public function new(?_buf:Ref<stdgo.bytes.Bytes.Buffer>, ?_seen:GoMap<stdgo.go.types.Types.Type, Bool>, ?_qf:stdgo.go.types.Types.Qualifier, ?_ctxt:Ref<stdgo.go.types.Types.Context>, ?_tparams:Ref<stdgo.go.types.Types.TypeParamList>, ?_paramNames:Bool, ?_tpSubscripts:Bool, ?_pkgInfo:Bool) {
        if (_buf != null) this._buf = _buf;
        if (_seen != null) this._seen = _seen;
        if (_qf != null) this._qf = _qf;
        if (_ctxt != null) this._ctxt = _ctxt;
        if (_tparams != null) this._tparams = _tparams;
        if (_paramNames != null) this._paramNames = _paramNames;
        if (_tpSubscripts != null) this._tpSubscripts = _tpSubscripts;
        if (_pkgInfo != null) this._pkgInfo = _pkgInfo;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_typeWriter(_buf, _seen, _qf, _ctxt, _tparams, _paramNames, _tpSubscripts, _pkgInfo);
    }
}
/**
    // A term describes elementary type sets:
    //
    //	 ‚àÖ:  (*term)(nil)     == ‚àÖ                      // set of no types (empty set)
    //	 ùì§:  &term{}          == ùì§                      // set of all types (ùì§niverse)
    //	 T:  &term{false, T}  == {T}                    // set of type T
    //	~t:  &term{true, t}   == {t' | under(t') == t}  // set of types with underlying type t
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_term_static_extension) class T_term {
    public var _tilde : Bool = false;
    public var _typ : stdgo.go.types.Types.Type = (null : stdgo.go.types.Types.Type);
    public function new(?_tilde:Bool, ?_typ:stdgo.go.types.Types.Type) {
        if (_tilde != null) this._tilde = _tilde;
        if (_typ != null) this._typ = _typ;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_term(_tilde, _typ);
    }
}
/**
    // A unifier maintains the current type parameters for x and y
    // and the respective types inferred for each type parameter.
    // A unifier is created by calling newUnifier.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_unifier_static_extension) class T_unifier {
    public var _exact : Bool = false;
    public var _x : stdgo.go.types.Types.T_tparamsList = ({} : stdgo.go.types.Types.T_tparamsList);
    public var _y : stdgo.go.types.Types.T_tparamsList = ({} : stdgo.go.types.Types.T_tparamsList);
    public var _types : Slice<stdgo.go.types.Types.Type> = (null : Slice<stdgo.go.types.Types.Type>);
    public var _depth : GoInt = 0;
    public function new(?_exact:Bool, ?_x:stdgo.go.types.Types.T_tparamsList, ?_y:stdgo.go.types.Types.T_tparamsList, ?_types:Slice<stdgo.go.types.Types.Type>, ?_depth:GoInt) {
        if (_exact != null) this._exact = _exact;
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_types != null) this._types = _types;
        if (_depth != null) this._depth = _depth;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_unifier(_exact, _x, _y, _types, _depth);
    }
}
/**
    // A tparamsList describes a list of type parameters and the types inferred for them.
    
    
**/
@:structInit @:private @:using(stdgo.go.types.Types.T_tparamsList_static_extension) class T_tparamsList {
    public var _unifier : Ref<stdgo.go.types.Types.T_unifier> = (null : Ref<stdgo.go.types.Types.T_unifier>);
    public var _tparams : Slice<Ref<stdgo.go.types.Types.TypeParam>> = (null : Slice<Ref<stdgo.go.types.Types.TypeParam>>);
    /**
        // For each tparams element, there is a corresponding type slot index in indices.
        // index  < 0: unifier.types[-index-1] == nil
        // index == 0: no type slot allocated yet
        // index  > 0: unifier.types[index-1] == typ
        // Joined tparams elements share the same type slot and thus have the same index.
        // By using a negative index for nil types we don't need to check unifier.types
        // to see if we have a type or not.
    **/
    public var _indices : Slice<GoInt> = (null : Slice<GoInt>);
    public function new(?_unifier:Ref<stdgo.go.types.Types.T_unifier>, ?_tparams:Slice<Ref<stdgo.go.types.Types.TypeParam>>, ?_indices:Slice<GoInt>) {
        if (_unifier != null) this._unifier = _unifier;
        if (_tparams != null) this._tparams = _tparams;
        if (_indices != null) this._indices = _indices;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_tparamsList(_unifier, _tparams, _indices);
    }
}
/**
    // A Union represents a union of terms embedded in an interface.
    
    
**/
@:structInit @:using(stdgo.go.types.Types.Union_static_extension) class Union {
    public var _terms : Slice<Ref<stdgo.go.types.Types.Term>> = (null : Slice<Ref<stdgo.go.types.Types.Term>>);
    public function new(?_terms:Slice<Ref<stdgo.go.types.Types.Term>>) {
        if (_terms != null) this._terms = _terms;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Union(_terms);
    }
}
/**
    
    
    
**/
@:structInit @:private class T_version {
    public var _major : GoInt = 0;
    public var _minor : GoInt = 0;
    public function new(?_major:GoInt, ?_minor:GoInt) {
        if (_major != null) this._major = _major;
        if (_minor != null) this._minor = _minor;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_version(_major, _minor);
    }
}
class T__struct_0_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_0>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T__struct_0_asInterface) class T__struct_0_static_extension {

}
@:local @:using(stdgo.go.types.Types.T__struct_0_static_extension) private typedef T__struct_0 = {
    public var _in : GoString;
    public var _want : GoString;
};
class T__struct_1_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_1>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T__struct_1_asInterface) class T__struct_1_static_extension {

}
@:local @:using(stdgo.go.types.Types.T__struct_1_static_extension) private typedef T__struct_1 = {
    public var _val : AnyInterface;
    public var __32bit : GoUIntptr;
    public var __64bit : GoUIntptr;
};
class T__struct_2_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_2>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T__struct_2_asInterface) class T__struct_2_static_extension {

}
@:local @:using(stdgo.go.types.Types.T__struct_2_static_extension) private typedef T__struct_2 = {
    public var _xl : GoString;
    public var _want : GoString;
};
class T__struct_3_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_3>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T__struct_3_asInterface) class T__struct_3_static_extension {

}
@:local @:using(stdgo.go.types.Types.T__struct_3_static_extension) private typedef T__struct_3 = {
    public var _xl : GoString;
    public var _yl : GoString;
    public var _want : GoString;
};
class T__struct_4_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_4>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T__struct_4_asInterface) class T__struct_4_static_extension {

}
@:local @:using(stdgo.go.types.Types.T__struct_4_static_extension) private typedef T__struct_4 = {
    public var _xl : GoString;
    public var _yl : GoString;
    public var _want : Bool;
};
class T__struct_5_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_5>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T__struct_5_asInterface) class T__struct_5_static_extension {

}
@:local @:using(stdgo.go.types.Types.T__struct_5_static_extension) private typedef T__struct_5 = {
    public var _xl : GoString;
    public var _typ : GoString;
    public var _want : Bool;
};
class T__struct_6_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_6>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T__struct_6_asInterface) class T__struct_6_static_extension {

}
@:local @:using(stdgo.go.types.Types.T__struct_6_static_extension) private typedef T__struct_6 = {
    public var _name : GoString;
    public var _kind : stdgo.go.types.Types.BasicKind;
    public var _val : stdgo.go.constant.Constant.Value;
};
class T__struct_7_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_7>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T__struct_7_asInterface) class T__struct_7_static_extension {

}
@:local @:using(stdgo.go.types.Types.T__struct_7_static_extension) private typedef T__struct_7 = {
    public var _name : GoString;
    public var _nargs : GoInt;
    public var _variadic : Bool;
    public var _kind : stdgo.go.types.Types.T_exprKind;
};
/**
    // ImportMode is reserved for future use.
**/
@:named typedef ImportMode = GoInt;
/**
    // BasicKind describes the kind of basic type.
**/
@:named typedef BasicKind = GoInt;
/**
    // BasicInfo is a set of flags describing properties of a basic type.
**/
@:named typedef BasicInfo = GoInt;
/**
    // A ChanDir value indicates a channel direction.
**/
@:named typedef ChanDir = GoInt;
/**
    // atPos wraps a token.Pos to implement the positioner interface.
**/
@:named @:using(stdgo.go.types.Types.T_atPos_static_extension) private typedef T_atPos = stdgo.go.token.Token.Pos;
@:named private typedef T_opPredicates = GoMap<stdgo.go.token.Token.Token, stdgo.go.types.Types.Type -> Bool>;
/**
    // exprKind describes the kind of an expression; the kind
    // determines if an expression is valid in 'statement context'.
**/
@:named private typedef T_exprKind = GoInt;
@:named @:using(stdgo.go.types.Types.T_nodeSet_static_extension) private typedef T_nodeSet = GoMap<Ref<stdgo.go.types.Types.T_graphNode>, Bool>;
/**
    // nodeQueue implements the container/heap interface;
    // a nodeQueue may be used as a priority queue.
**/
@:named @:using(stdgo.go.types.Types.T_nodeQueue_static_extension) private typedef T_nodeQueue = Slice<Ref<stdgo.go.types.Types.T_graphNode>>;
/**
    // A methodSet is a set of methods and name collisions.
    // A collision indicates that multiple methods with the
    // same unique id, or a field with that id appeared.
**/
@:named @:using(stdgo.go.types.Types.T_methodSet_static_extension) private typedef T_methodSet = GoMap<GoString, Ref<stdgo.go.types.Types.Selection>>;
/**
    // namedState represents the possible states that a named type may assume.
**/
@:named private typedef T_namedState = GoUInt32;
/**
    // color encodes the color of an object (see Checker.objDecl for details).
**/
@:named @:using(stdgo.go.types.Types.T_color_static_extension) private typedef T_color = GoUInt32;
/**
    // An objset is a set of objects identified by their unique id.
    // The zero value for objset is a ready-to-use empty objset.
**/
@:named @:using(stdgo.go.types.Types.T_objset_static_extension) private typedef T_objset = GoMap<GoString, stdgo.go.types.Types.Object>;
/**
    // An operandMode specifies the (addressing) mode of an operand.
**/
@:named private typedef T_operandMode = GoUInt8;
/**
    // inSourceOrder implements the sort.Sort interface.
**/
@:named @:using(stdgo.go.types.Types.T_inSourceOrder_static_extension) private typedef T_inSourceOrder = Slice<stdgo.go.types.Types.Object>;
/**
    // SelectionKind describes the kind of a selector expression x.f
    // (excluding qualified identifiers).
**/
@:named typedef SelectionKind = GoInt;
/**
    // stmtContext is a bitset describing which
    // control-flow statements are permissible,
    // and provides additional context information
    // for better error messages.
**/
@:named private typedef T_stmtContext = GoUInt;
/**
    // A valueMap maps a case value (of a basic Go type) to a list of positions
    // where the same case value appeared, together with the corresponding case
    // types.
    // Since two case values may have the same "underlying" value but different
    // types we need to also check the value's types (e.g., byte(1) vs myByte(1))
    // when the switch expression is of interface type.
**/
@:named private typedef T_valueMap = GoMap<AnyInterface, Slice<stdgo.go.types.Types.T_valueType>>;
@:named @:using(stdgo.go.types.Types.T_substMap_static_extension) private typedef T_substMap = GoMap<Ref<stdgo.go.types.Types.TypeParam>, stdgo.go.types.Types.Type>;
/**
    // A termlist represents the type set represented by the union
    // t1 ‚à™ y2 ‚à™ ... tn of the type sets of the terms t1 to tn.
    // A termlist is in normal form if all terms are disjoint.
    // termlist operations don't require the operands to be in
    // normal form.
**/
@:named @:using(stdgo.go.types.Types.T_termlist_static_extension) private typedef T_termlist = Slice<Ref<stdgo.go.types.Types.T_term>>;
/**
    // byUniqueMethodName method lists can be sorted by their unique method names.
**/
@:named @:using(stdgo.go.types.Types.T_byUniqueMethodName_static_extension) private typedef T_byUniqueMethodName = Slice<Ref<stdgo.go.types.Types.Func>>;
/**
    // A Qualifier controls how named package-level objects are printed in
    // calls to TypeString, ObjectString, and SelectionString.
    //
    // These three formatting routines call the Qualifier for each
    // package-level object O, and if the Qualifier returns a non-empty
    // string p, the object is printed in the form p.O.
    // If it returns an empty string, only the object name O is printed.
    //
    // Using a nil Qualifier is equivalent to using (*Package).Path: the
    // object is qualified by the import path, e.g., "encoding/json.Marshal".
**/
@:named typedef Qualifier = Ref<stdgo.go.types.Types.Package> -> GoString;
/**
    // A Term represents a term in a Union.
**/
@:named @:using(stdgo.go.types.Types.Term_static_extension) typedef Term = stdgo.go.types.Types.T_term;
/**
    // A builtinId is the id of a builtin function.
**/
@:named private typedef T_builtinId = GoInt;
private function _srcimporter_setUsesCgo(_conf:Ref<Config>):Void {
        _conf._go115UsesCgo = true;
    }
/**
    // AssertableTo reports whether a value of type V can be asserted to have type T.
    //
    // The behavior of AssertableTo is unspecified in three cases:
    //   - if T is Typ[Invalid]
    //   - if V is a generalized interface; i.e., an interface that may only be used
    //     as a type constraint in Go code
    //   - if T is an uninstantiated generic type
**/
function assertableTo(v:Ref<Interface>, t:Type):Bool {
        if (Go.toInterface(t.underlying()) == (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
            return false;
        };
        return ((null : Ref<stdgo.go.types.Types.Checker>) : Ref<Checker>)._newAssertableTo(v, t);
    }
/**
    // AssignableTo reports whether a value of type V is assignable to a variable
    // of type T.
    //
    // The behavior of AssignableTo is unspecified if V or T is Typ[Invalid] or an
    // uninstantiated generic type.
**/
function assignableTo(v:Type, t:Type):Bool {
        var _x:stdgo.go.types.Types.T_operand = ({ _mode : (7 : stdgo.go.types.Types.T_operandMode), _typ : v } : T_operand);
        var __tmp__ = _x._assignableTo(null, t, (null : Pointer<GoString>)), _ok:Bool = __tmp__._0, __0:stdgo.internal.types.errors.Errors.Code = __tmp__._1;
        return _ok;
    }
/**
    // ConvertibleTo reports whether a value of type V is convertible to a value of
    // type T.
    //
    // The behavior of ConvertibleTo is unspecified if V or T is Typ[Invalid] or an
    // uninstantiated generic type.
**/
function convertibleTo(v:Type, t:Type):Bool {
        var _x:stdgo.go.types.Types.T_operand = ({ _mode : (7 : stdgo.go.types.Types.T_operandMode), _typ : v } : T_operand);
        return _x._convertibleTo(null, t, (null : Pointer<GoString>));
    }
/**
    // Implements reports whether type V implements interface T.
    //
    // The behavior of Implements is unspecified if V is Typ[Invalid] or an uninstantiated
    // generic type.
**/
function implements_(v:Type, t:Ref<Interface>):Bool {
        if (t.empty()) {
            return true;
        };
        if (Go.toInterface(v.underlying()) == (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
            return false;
        };
        return ((null : Ref<stdgo.go.types.Types.Checker>) : Ref<Checker>)._implements(v, Go.asInterface(t), false, (null : Pointer<GoString>));
    }
/**
    // Satisfies reports whether type V satisfies the constraint T.
    //
    // The behavior of Satisfies is unspecified if V is Typ[Invalid] or an uninstantiated
    // generic type.
**/
function satisfies(v:Type, t:Ref<Interface>):Bool {
        return ((null : Ref<stdgo.go.types.Types.Checker>) : Ref<Checker>)._implements(v, Go.asInterface(t), true, (null : Pointer<GoString>));
    }
/**
    // Identical reports whether x and y are identical types.
    // Receivers of Signature types are ignored.
**/
function identical(_x:Type, _y:Type):Bool {
        return _identical(_x, _y, true, null);
    }
/**
    // IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored.
    // Receivers of Signature types are ignored.
**/
function identicalIgnoreTags(_x:Type, _y:Type):Bool {
        return _identical(_x, _y, false, null);
    }
/**
    // NewArray returns a new array type for the given element type and length.
    // A negative length indicates an unknown length.
**/
function newArray(_elem:Type, _len:GoInt64):Ref<Array_> {
        return (Go.setRef(({ _len : _len, _elem : _elem } : Array_)) : Ref<stdgo.go.types.Types.Array_>);
    }
/**
    // operandTypes returns the list of types for the given operands.
**/
private function _operandTypes(_list:Slice<Ref<T_operand>>):Slice<Type> {
        var _res:Slice<Type> = (null : Slice<stdgo.go.types.Types.Type>);
        for (__0 => _x in _list) {
            _res = (_res.__append__(_x._typ));
        };
        return _res;
    }
/**
    // varTypes returns the list of types for the given variables.
**/
private function _varTypes(_list:Slice<Ref<Var>>):Slice<Type> {
        var _res:Slice<Type> = (null : Slice<stdgo.go.types.Types.Type>);
        for (__0 => _x in _list) {
            _res = (_res.__append__(_x._object._typ));
        };
        return _res;
    }
private function _measure(_x:GoInt, _unit:GoString):GoString {
        if (_x != ((1 : GoInt))) {
            _unit = _unit + (("s" : GoString));
        };
        return stdgo.fmt.Fmt.sprintf(("%d %s" : GoString), Go.toInterface(_x), Go.toInterface(_unit));
    }
/**
    // hasVarSize reports if the size of type t is variable due to type parameters
    // or if the type is infinitely-sized due to a cycle for which the type has not
    // yet been checked.
**/
private function _hasVarSize(_t:Type, _seen:GoMap<Ref<Named>, Bool>):Bool {
        var __deferstack__:Array<Void -> Void> = [];
        var _varSized:Bool = false;
        try {
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_t) : Ref<Named>)) : Ref<Named>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
                }, _named = __tmp__.value, __0 = __tmp__.ok;
                if (_named != null && ((_named : Dynamic).__nil__ == null || !(_named : Dynamic).__nil__)) {
                    {
                        var __tmp__ = (_seen != null && _seen.exists(_named) ? { value : _seen[_named], ok : true } : { value : false, ok : false }), _v:Bool = __tmp__.value, _ok:Bool = __tmp__.ok;
                        if (_ok) {
                            return _v;
                        };
                    };
                    if (_seen == null) {
                        _seen = ({
                            final x = new GoRefMap<Ref<stdgo.go.types.Types.Named>, Bool>();
                            @:mergeBlock {};
                            cast x;
                        } : GoMap<Ref<stdgo.go.types.Types.Named>, Bool>);
                    };
                    _seen[_named] = true;
                    __deferstack__.unshift(() -> {
                        var a = function():Void {
                            _seen[_named] = _varSized;
                        };
                        a();
                    });
                };
            };
            {
                final __type__ = _under(_t);
                if (Go.typeEquals((__type__ : Ref<Array_>))) {
                    var _u:Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _hasVarSize(_u._elem, _seen);
                    };
                } else if (Go.typeEquals((__type__ : Ref<Struct>))) {
                    var _u:Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                    for (__9 => _f in _u._fields) {
                        if (_hasVarSize(_f._object._typ, _seen)) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return true;
                            };
                        };
                    };
                } else if (Go.typeEquals((__type__ : Ref<Interface>))) {
                    var _u:Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _isTypeParam(_t);
                    };
                } else if (Go.typeEquals((__type__ : Ref<Named>)) || Go.typeEquals((__type__ : Ref<Union>))) {
                    var _u:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                    _unreachable();
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return false;
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return _varSized;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return _varSized;
        };
    }
/**
    // makeSig makes a signature for the given argument and result types.
    // Default types are used for untyped arguments, and res may be nil.
**/
private function _makeSig(_res:Type, _args:haxe.Rest<Type>):Ref<Signature> {
        var _args = new Slice<Type>(_args.length, 0, ..._args);
        var _list = new Slice<Ref<stdgo.go.types.Types.Var>>((_args.length : GoInt).toBasic(), 0);
        for (_i => _param in _args) {
            _list[(_i : GoInt)] = newVar((0 : stdgo.go.token.Token.Pos), null, Go.str(), default_(_param));
        };
        var _params = newTuple(..._list.__toArray__());
        var _result:Ref<Tuple> = (null : Ref<stdgo.go.types.Types.Tuple>);
        if (_res != null) {
            _assert(!_isUntyped(_res));
            _result = newTuple(newVar((0 : stdgo.go.token.Token.Pos), null, Go.str(), _res));
        };
        return (Go.setRef(({ _params : _params, _results : _result } : Signature)) : Ref<stdgo.go.types.Types.Signature>);
    }
/**
    // arrayPtrDeref returns A if typ is of the form *A and A is an array;
    // otherwise it returns typ.
**/
private function _arrayPtrDeref(_typ:Type):Type {
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_typ) : Ref<Pointer_>)) : Ref<Pointer_>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Pointer_>), ok : false };
            }, _p = __tmp__.value, _ok = __tmp__.ok;
            if (_ok) {
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_under(_p._base)) : Ref<Array_>)) : Ref<Array_>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Array_>), ok : false };
                    }, _a = __tmp__.value, __0 = __tmp__.ok;
                    if (_a != null && ((_a : Dynamic).__nil__ == null || !(_a : Dynamic).__nil__)) {
                        return Go.asInterface(_a);
                    };
                };
            };
        };
        return _typ;
    }
/**
    // unparen returns e with any enclosing parentheses stripped.
**/
private function _unparen(_e:stdgo.go.ast.Ast.Expr):stdgo.go.ast.Ast.Expr {
        while (true) {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_e) : Ref<stdgo.go.ast.Ast.ParenExpr>)) : Ref<stdgo.go.ast.Ast.ParenExpr>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.ast.Ast.ParenExpr>), ok : false };
            }, _p = __tmp__.value, _ok = __tmp__.ok;
            if (!_ok) {
                return _e;
            };
            _e = _p.x;
        };
    }
/**
    // NewChan returns a new channel type for the given direction and element type.
**/
function newChan(_dir:ChanDir, _elem:Type):Ref<Chan> {
        return (Go.setRef(({ _dir : _dir, _elem : _elem } : Chan)) : Ref<stdgo.go.types.Types.Chan>);
    }
/**
    // NewChecker returns a new Checker instance for a given package.
    // Package files may be added incrementally via checker.Files.
**/
function newChecker(_conf:Ref<Config>, _fset:Ref<stdgo.go.token.Token.FileSet>, _pkg:Ref<Package>, _info:Ref<Info>):Ref<Checker> {
        if (_conf == null || (_conf : Dynamic).__nil__) {
            _conf = (Go.setRef(({} : stdgo.go.types.Types.Config)) : Ref<stdgo.go.types.Types.Config>);
        };
        if (_info == null || (_info : Dynamic).__nil__) {
            _info = (Go.setRef(({} : stdgo.go.types.Types.Info)) : Ref<stdgo.go.types.Types.Info>);
        };
        var __tmp__ = _parseGoVersion(_conf.goVersion), _version:stdgo.go.types.Types.T_version = __tmp__._0, _err:Error = __tmp__._1;
        if (_err != null) {
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("invalid Go version %q (%v)" : GoString), Go.toInterface(_conf.goVersion), Go.toInterface(_err)));
        };
        return (Go.setRef(({ _conf : _conf, _ctxt : _conf.context, _fset : _fset, _pkg : _pkg, info : _info, _version : _version?.__copy__(), _objMap : ({
            final x = new GoObjectMap<stdgo.go.types.Types.Object, Ref<stdgo.go.types.Types.T_declInfo>>();
            x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Object", [], stdgo.internal.reflect.Reflect.GoType.named("Object", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
            x.__defaultValue__ = () -> (null : Ref<stdgo.go.types.Types.T_declInfo>);
            @:mergeBlock {};
            cast x;
        } : GoMap<stdgo.go.types.Types.Object, Ref<stdgo.go.types.Types.T_declInfo>>), _impMap : ({
            final x = new GoObjectMap<stdgo.go.types.Types.T_importKey, Ref<stdgo.go.types.Types.Package>>();
            x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.T_importKey", [], stdgo.internal.reflect.Reflect.GoType.structType([{ name : "_path", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.basic(string_kind) }, optional : false }, { name : "_dir", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.basic(string_kind) }, optional : false }]), false, { get : () -> null }));
            x.__defaultValue__ = () -> (null : Ref<stdgo.go.types.Types.Package>);
            @:mergeBlock {};
            cast x;
        } : GoMap<stdgo.go.types.Types.T_importKey, Ref<stdgo.go.types.Types.Package>>) } : Checker)) : Ref<stdgo.go.types.Types.Checker>);
    }
private function _instantiatedIdent(_expr:stdgo.go.ast.Ast.Expr):Ref<stdgo.go.ast.Ast.Ident> {
        var _selOrIdent:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
        {
            final __type__ = _expr;
            if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexExpr>))) {
                var _e:Ref<stdgo.go.ast.Ast.IndexExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IndexExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.IndexExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IndexExpr>) : __type__.__underlying__().value;
                _selOrIdent = _e.x;
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexListExpr>))) {
                var _e:Ref<stdgo.go.ast.Ast.IndexListExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IndexListExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.IndexListExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IndexListExpr>) : __type__.__underlying__().value;
                _selOrIdent = _e.x;
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectorExpr>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ident>))) {
                var _e:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                _selOrIdent = _e;
            };
        };
        {
            final __type__ = _selOrIdent;
            if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ident>))) {
                var _x:Ref<stdgo.go.ast.Ast.Ident> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__().value;
                return _x;
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectorExpr>))) {
                var _x:Ref<stdgo.go.ast.Ast.SelectorExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__().value;
                return _x.sel;
            };
        };
        throw Go.toInterface(("instantiated ident not found" : GoString));
    }
/**
    // NewContext creates a new Context.
**/
function newContext():Ref<Context> {
        return (Go.setRef(({ _typeMap : ({
            final x = new stdgo.GoMap.GoStringMap<Slice<stdgo.go.types.Types.T_ctxtEntry>>();
            x.__defaultValue__ = () -> (null : Slice<stdgo.go.types.Types.T_ctxtEntry>);
            @:mergeBlock {};
            x;
        } : GoMap<GoString, Slice<stdgo.go.types.Types.T_ctxtEntry>>), _originIDs : ({
            final x = new GoObjectMap<stdgo.go.types.Types.Type, GoInt>();
            x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Type", [], stdgo.internal.reflect.Reflect.GoType.named("Type", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
            x.__defaultValue__ = () -> (0 : GoInt);
            @:mergeBlock {};
            cast x;
        } : GoMap<stdgo.go.types.Types.Type, GoInt>) } : Context)) : Ref<stdgo.go.types.Types.Context>);
    }
function testContextHashCollisions(_t:Ref<stdgo.testing.Testing.T>):Void {
        if (false) {
            _t.skip(Go.toInterface(("hash collisions are expected, and would fail debug assertions" : GoString)));
        };
        var __0:Type = (null : stdgo.go.types.Types.Type), __1:Type = (null : stdgo.go.types.Types.Type), __2:Type = (null : stdgo.go.types.Types.Type), _unaryP:Type = __2, _nullaryQ:Type = __1, _nullaryP:Type = __0;
        {
            var _tparam = newTypeParam(newTypeName((0 : stdgo.go.token.Token.Pos), null, ("P" : GoString), (null : stdgo.go.types.Types.Type)), Go.asInterface((Go.setRef(_emptyInterface) : Ref<stdgo.go.types.Types.Interface>)));
            _nullaryP = Go.asInterface(newSignatureType(null, (null : Slice<Ref<stdgo.go.types.Types.TypeParam>>), (new Slice<Ref<stdgo.go.types.Types.TypeParam>>(1, 1, _tparam) : Slice<Ref<stdgo.go.types.Types.TypeParam>>), null, null, false));
        };
        {
            var _tparam = newTypeParam(newTypeName((0 : stdgo.go.token.Token.Pos), null, ("Q" : GoString), (null : stdgo.go.types.Types.Type)), Go.asInterface((Go.setRef(_emptyInterface) : Ref<stdgo.go.types.Types.Interface>)));
            _nullaryQ = Go.asInterface(newSignatureType(null, (null : Slice<Ref<stdgo.go.types.Types.TypeParam>>), (new Slice<Ref<stdgo.go.types.Types.TypeParam>>(1, 1, _tparam) : Slice<Ref<stdgo.go.types.Types.TypeParam>>), null, null, false));
        };
        {
            var _tparam = newTypeParam(newTypeName((0 : stdgo.go.token.Token.Pos), null, ("P" : GoString), (null : stdgo.go.types.Types.Type)), Go.asInterface((Go.setRef(_emptyInterface) : Ref<stdgo.go.types.Types.Interface>)));
            var _params = newTuple(newVar((0 : stdgo.go.token.Token.Pos), null, ("_" : GoString), Go.asInterface(_tparam)));
            _unaryP = Go.asInterface(newSignatureType(null, (null : Slice<Ref<stdgo.go.types.Types.TypeParam>>), (new Slice<Ref<stdgo.go.types.Types.TypeParam>>(1, 1, _tparam) : Slice<Ref<stdgo.go.types.Types.TypeParam>>), _params, null, false));
        };
        var _ctxt = newContext();
        var _inst = newSignatureType(null, (null : Slice<Ref<stdgo.go.types.Types.TypeParam>>), (null : Slice<Ref<stdgo.go.types.Types.TypeParam>>), null, null, false);
        {
            var _got:stdgo.go.types.Types.Type = _ctxt._update(Go.str(), _nullaryP, (new Slice<stdgo.go.types.Types.Type>(1, 1, Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : GoInt)])) : Slice<stdgo.go.types.Types.Type>), Go.asInterface(_inst));
            if (Go.toInterface(_got) != (Go.toInterface(Go.asInterface(_inst)))) {
                _t.error(Go.toInterface(("bad" : GoString)));
            };
        };
        {
            var _got:stdgo.go.types.Types.Type = _ctxt._lookup(Go.str(), _unaryP, (new Slice<stdgo.go.types.Types.Type>(1, 1, Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : GoInt)])) : Slice<stdgo.go.types.Types.Type>));
            if (_got != null) {
                _t.error(Go.toInterface(("bad" : GoString)));
            };
        };
        {
            var _got:stdgo.go.types.Types.Type = _ctxt._lookup(Go.str(), _nullaryQ, (new Slice<stdgo.go.types.Types.Type>(1, 1, Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : GoInt)])) : Slice<stdgo.go.types.Types.Type>));
            if (Go.toInterface(_got) != (Go.toInterface(Go.asInterface(_inst)))) {
                _t.error(Go.toInterface(("bad" : GoString)));
            };
        };
        {
            var _got:stdgo.go.types.Types.Type = _ctxt._lookup(Go.str(), _nullaryQ, (new Slice<stdgo.go.types.Types.Type>(1, 1, Go.asInterface(typ[((17 : stdgo.go.types.Types.BasicKind) : GoInt)])) : Slice<stdgo.go.types.Types.Type>));
            if (_got != null) {
                _t.error(Go.toInterface(("bad" : GoString)));
            };
        };
    }
private function _isUintptr(_typ:Type):Bool {
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Basic>)) : Ref<Basic>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.Basic>), ok : false };
        }, _t = __tmp__.value, __0 = __tmp__.ok;
        return ((_t != null) && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) && (_t._kind == (12 : stdgo.go.types.Types.BasicKind));
    }
private function _isUnsafePointer(_typ:Type):Bool {
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Basic>)) : Ref<Basic>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.Basic>), ok : false };
        }, _t = __tmp__.value, __0 = __tmp__.ok;
        return ((_t != null) && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) && (_t._kind == (18 : stdgo.go.types.Types.BasicKind));
    }
private function _isPointer(_typ:Type):Bool {
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Pointer_>)) : Ref<Pointer_>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.Pointer_>), ok : false };
        }, __0 = __tmp__.value, _ok = __tmp__.ok;
        return _ok;
    }
private function _isBytesOrRunes(_typ:Type):Bool {
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Slice_>)) : Ref<Slice_>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Slice_>), ok : false };
            }, _s = __tmp__.value, __0 = __tmp__.ok;
            if (_s != null && ((_s : Dynamic).__nil__ == null || !(_s : Dynamic).__nil__)) {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_under(_s._elem)) : Ref<Basic>)) : Ref<Basic>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.Basic>), ok : false };
                }, _t = __tmp__.value, __1 = __tmp__.ok;
                return ((_t != null) && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) && ((_t._kind == (8 : stdgo.go.types.Types.BasicKind)) || (_t._kind == (5 : stdgo.go.types.Types.BasicKind)));
            };
        };
        return false;
    }
/**
    // pathString returns a string of the form a->b-> ... ->g for a path [a, b, ... g].
**/
private function _pathString(_path:Slice<Object>):GoString {
        var _s:GoString = ("" : GoString);
        for (_i => _p in _path) {
            if (_i > (0 : GoInt)) {
                _s = _s + (("->" : GoString));
            };
            _s = _s + (_p.name());
        };
        return _s;
    }
/**
    // firstInSrc reports the index of the object with the "smallest"
    // source position in path. path must not be empty.
**/
private function _firstInSrc(_path:Slice<Object>):GoInt {
        var __0:GoInt = (0 : GoInt), __1:stdgo.go.token.Token.Pos = _path[(0 : GoInt)].pos(), _pos:stdgo.go.token.Token.Pos = __1, _fst:GoInt = __0;
        for (_i => _t in (_path.__slice__((1 : GoInt)) : Slice<stdgo.go.types.Types.Object>)) {
            if (_t.pos() < _pos) {
                {
                    final __tmp__0 = _i + (1 : GoInt);
                    final __tmp__1 = _t.pos();
                    _fst = __tmp__0;
                    _pos = __tmp__1;
                };
            };
        };
        return _fst;
    }
private function _assert(_p:Bool):Void {
        if (!_p) {
            var _msg:GoString = ("assertion failed" : GoString);
            {
                var __tmp__ = stdgo.runtime.Runtime.caller((1 : GoInt)), __0:GoUIntptr = __tmp__._0, _file:GoString = __tmp__._1, _line:GoInt = __tmp__._2, _ok:Bool = __tmp__._3;
                if (_ok) {
                    _msg = stdgo.fmt.Fmt.sprintf(("%s:%d: %s" : GoString), Go.toInterface(_file), Go.toInterface(_line), Go.toInterface(_msg));
                };
            };
            throw Go.toInterface(_msg);
        };
    }
private function _unreachable():Void {
        throw Go.toInterface(("unreachable" : GoString));
    }
private function _sprintf(_fset:Ref<stdgo.go.token.Token.FileSet>, _qf:Qualifier, _tpSubscripts:Bool, _format:GoString, _args:haxe.Rest<AnyInterface>):GoString {
        var _args = new Slice<AnyInterface>(_args.length, 0, ..._args);
        for (_i => _arg in _args) {
            {
                final __type__ = _arg;
                if (__type__ == null) {
                    var _a:AnyInterface = __type__ == null ? (null : AnyInterface) : __type__.__underlying__();
                    _arg = Go.toInterface(("<nil>" : GoString));
                } else if (Go.typeEquals((__type__ : T_operand))) {
                    var _a:stdgo.go.types.Types.T_operand = __type__ == null ? ({} : stdgo.go.types.Types.T_operand) : __type__.__underlying__() == null ? ({} : stdgo.go.types.Types.T_operand) : __type__ == null ? ({} : stdgo.go.types.Types.T_operand) : __type__.__underlying__().value;
                    throw Go.toInterface(("got operand instead of *operand" : GoString));
                } else if (Go.typeEquals((__type__ : Ref<T_operand>))) {
                    var _a:Ref<stdgo.go.types.Types.T_operand> = __type__ == null ? (null : Ref<stdgo.go.types.Types.T_operand>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.T_operand>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.T_operand>) : __type__.__underlying__().value;
                    _arg = Go.toInterface(_operandString(_a, _qf));
                } else if (Go.typeEquals((__type__ : stdgo.go.token.Token.Pos))) {
                    var _a:stdgo.go.token.Token.Pos = __type__ == null ? ((0 : GoInt) : stdgo.go.token.Token.Pos) : __type__.__underlying__() == null ? ((0 : GoInt) : stdgo.go.token.Token.Pos) : __type__ == null ? ((0 : GoInt) : stdgo.go.token.Token.Pos) : __type__.__underlying__().value;
                    if (_fset != null && ((_fset : Dynamic).__nil__ == null || !(_fset : Dynamic).__nil__)) {
                        _arg = Go.toInterface((_fset.position(_a).string() : GoString));
                    };
                } else if (Go.typeEquals((__type__ : stdgo.go.ast.Ast.Expr))) {
                    var _a:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : __type__.__underlying__() == null ? (null : stdgo.go.ast.Ast.Expr) : __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : __type__.__underlying__().value;
                    _arg = Go.toInterface(exprString(_a));
                } else if (Go.typeEquals((__type__ : Slice<stdgo.go.ast.Ast.Expr>))) {
                    var _a:Slice<stdgo.go.ast.Ast.Expr> = __type__ == null ? (null : Slice<stdgo.go.ast.Ast.Expr>) : __type__.__underlying__() == null ? (null : Slice<stdgo.go.ast.Ast.Expr>) : __type__ == null ? (null : Slice<stdgo.go.ast.Ast.Expr>) : __type__.__underlying__().value;
                    var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
                    _buf.writeByte((91 : GoUInt8));
                    _writeExprList((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>), _a);
                    _buf.writeByte((93 : GoUInt8));
                    _arg = Go.toInterface((_buf.string() : GoString));
                } else if (Go.typeEquals((__type__ : Object))) {
                    var _a:stdgo.go.types.Types.Object = __type__ == null ? (null : stdgo.go.types.Types.Object) : __type__.__underlying__() == null ? (null : stdgo.go.types.Types.Object) : __type__ == null ? (null : stdgo.go.types.Types.Object) : __type__.__underlying__().value;
                    _arg = Go.toInterface(objectString(_a, _qf));
                } else if (Go.typeEquals((__type__ : Type))) {
                    var _a:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : __type__.__underlying__() == null ? (null : stdgo.go.types.Types.Type) : __type__ == null ? (null : stdgo.go.types.Types.Type) : __type__.__underlying__().value;
                    var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
                    var _w = _newTypeWriter((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>), _qf);
                    _w._tpSubscripts = _tpSubscripts;
                    _w._typ(_a);
                    _arg = Go.toInterface((_buf.string() : GoString));
                } else if (Go.typeEquals((__type__ : Slice<Type>))) {
                    var _a:Slice<stdgo.go.types.Types.Type> = __type__ == null ? (null : Slice<stdgo.go.types.Types.Type>) : __type__.__underlying__() == null ? (null : Slice<stdgo.go.types.Types.Type>) : __type__ == null ? (null : Slice<stdgo.go.types.Types.Type>) : __type__.__underlying__().value;
                    var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
                    var _w = _newTypeWriter((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>), _qf);
                    _w._tpSubscripts = _tpSubscripts;
                    _buf.writeByte((91 : GoUInt8));
                    for (_i => _x in _a) {
                        if (_i > (0 : GoInt)) {
                            _buf.writeString((", " : GoString));
                        };
                        _w._typ(_x);
                    };
                    _buf.writeByte((93 : GoUInt8));
                    _arg = Go.toInterface((_buf.string() : GoString));
                } else if (Go.typeEquals((__type__ : Slice<Ref<TypeParam>>))) {
                    var _a:Slice<Ref<stdgo.go.types.Types.TypeParam>> = __type__ == null ? (null : Slice<Ref<stdgo.go.types.Types.TypeParam>>) : __type__.__underlying__() == null ? (null : Slice<Ref<stdgo.go.types.Types.TypeParam>>) : __type__ == null ? (null : Slice<Ref<stdgo.go.types.Types.TypeParam>>) : __type__.__underlying__().value;
                    var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
                    var _w = _newTypeWriter((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>), _qf);
                    _w._tpSubscripts = _tpSubscripts;
                    _buf.writeByte((91 : GoUInt8));
                    for (_i => _x in _a) {
                        if (_i > (0 : GoInt)) {
                            _buf.writeString((", " : GoString));
                        };
                        _w._typ(Go.asInterface(_x));
                    };
                    _buf.writeByte((93 : GoUInt8));
                    _arg = Go.toInterface((_buf.string() : GoString));
                };
            };
            _args[(_i : GoInt)] = _arg;
        };
        return stdgo.fmt.Fmt.sprintf(_format, ..._args.__toArray__());
    }
/**
    // newErrorf creates a new error_ for later reporting with check.report.
**/
private function _newErrorf(_at:T_positioner, _code:Code, _format:GoString, _args:haxe.Rest<AnyInterface>):Ref<T_error_> {
        var _args = new Slice<AnyInterface>(_args.length, 0, ..._args);
        return (Go.setRef(({ _desc : (new Slice<stdgo.go.types.Types.T_errorDesc>(1, 1, (new stdgo.go.types.Types.T_errorDesc(_at, _format, _args) : stdgo.go.types.Types.T_errorDesc)) : Slice<stdgo.go.types.Types.T_errorDesc>), _code : _code } : T_error_)) : Ref<stdgo.go.types.Types.T_error_>);
    }
/**
    // inNode creates a posSpan for the given node.
    // Invariant: node.Pos() <= pos < node.End() (node.End() is the position of the
    // first byte after node within the source).
**/
private function _inNode(_node:stdgo.go.ast.Ast.Node, _pos:stdgo.go.token.Token.Pos):T_posSpan {
        var __0:stdgo.go.token.Token.Pos = _node.pos(), __1:stdgo.go.token.Token.Pos = _node.end(), _end:stdgo.go.token.Token.Pos = __1, _start:stdgo.go.token.Token.Pos = __0;
        if (false) {
            _assert((_start <= _pos) && (_pos < _end));
        };
        return (new T_posSpan(_start, _pos, _end) : T_posSpan);
    }
/**
    // spanOf extracts an error span from the given positioner. By default this is
    // the trivial span starting and ending at pos, but this span is expanded when
    // the argument naturally corresponds to a span of source code.
**/
private function _spanOf(_at:T_positioner):T_posSpan {
        {
            final __type__ = _at;
            if (__type__ == null) {
                var _x:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
                throw Go.toInterface(("nil positioner" : GoString));
            } else if (Go.typeEquals((__type__ : T_posSpan))) {
                var _x:stdgo.go.types.Types.T_posSpan = __type__ == null ? ({} : stdgo.go.types.Types.T_posSpan) : __type__.__underlying__() == null ? ({} : stdgo.go.types.Types.T_posSpan) : __type__ == null ? ({} : stdgo.go.types.Types.T_posSpan) : __type__.__underlying__().value;
                return _x?.__copy__();
            } else if (Go.typeEquals((__type__ : stdgo.go.ast.Ast.Node))) {
                var _x:stdgo.go.ast.Ast.Node = __type__ == null ? (null : stdgo.go.ast.Ast.Node) : cast __type__;
                var _pos:stdgo.go.token.Token.Pos = _x.pos();
                return (new T_posSpan(_pos, _pos, _x.end()) : T_posSpan);
            } else if (Go.typeEquals((__type__ : Ref<T_operand>))) {
                var _x:Ref<stdgo.go.types.Types.T_operand> = __type__ == null ? (null : Ref<stdgo.go.types.Types.T_operand>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.T_operand>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.T_operand>) : __type__.__underlying__().value;
                if (_x._expr != null) {
                    var _pos:stdgo.go.token.Token.Pos = _x.pos();
                    return (new T_posSpan(_pos, _pos, _x._expr.end()) : T_posSpan);
                };
                return (new T_posSpan((0 : stdgo.go.token.Token.Pos), (0 : stdgo.go.token.Token.Pos), (0 : stdgo.go.token.Token.Pos)) : T_posSpan);
            } else {
                var _x:stdgo.go.types.Types.T_positioner = __type__ == null ? (null : stdgo.go.types.Types.T_positioner) : cast __type__;
                var _pos:stdgo.go.token.Token.Pos = _at.pos();
                return (new T_posSpan(_pos, _pos, _pos) : T_posSpan);
            };
        };
    }
/**
    // stripAnnotations removes internal (type) annotations from s.
**/
private function _stripAnnotations(_s:GoString):GoString {
        var _buf:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
        for (__0 => _r in _s) {
            if ((_r < (8320 : GoInt32)) || ((8330 : GoInt32) <= _r)) {
                _buf.writeRune(_r);
            };
        };
        if (_buf.len() < (_s.length)) {
            return (_buf.string() : GoString);
        };
        return _s;
    }
function testError(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _err:T_error_ = ({} : stdgo.go.types.Types.T_error_);
        var _want:GoString = ("no error" : GoString);
        {
            var _got:GoString = (_err.string() : GoString);
            if (_got != (_want)) {
                _t.errorf(("empty error: got %q, want %q" : GoString), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
        _want = ("0: foo 42" : GoString);
        _err._errorf((0 : stdgo.go.token.Token.Pos), ("foo %d" : GoString), Go.toInterface((42 : GoInt)));
        {
            var _got:GoString = (_err.string() : GoString);
            if (_got != (_want)) {
                _t.errorf(("simple error: got %q, want %q" : GoString), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
        _want = ("0: foo 42\n\tbar 43" : GoString);
        _err._errorf((0 : stdgo.go.token.Token.Pos), ("bar %d" : GoString), Go.toInterface((43 : GoInt)));
        {
            var _got:GoString = (_err.string() : GoString);
            if (_got != (_want)) {
                _t.errorf(("simple error: got %q, want %q" : GoString), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function testStripAnnotations(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_0>(5, 5, ({ _in : Go.str(), _want : Go.str() } : T__struct_0), ({ _in : ("   " : GoString), _want : ("   " : GoString) } : T__struct_0), ({ _in : ("foo" : GoString), _want : ("foo" : GoString) } : T__struct_0), ({ _in : ("foo‚ÇÄ" : GoString), _want : ("foo" : GoString) } : T__struct_0), ({ _in : ("foo(T‚ÇÄ)" : GoString), _want : ("foo(T)" : GoString) } : T__struct_0)) : Slice<T__struct_0>)) {
            var _got:GoString = _stripAnnotations(_test._in);
            if (_got != (_test._want)) {
                _t.errorf(("%q: got %q; want %q" : GoString), Go.toInterface(_test._in), Go.toInterface(_got), Go.toInterface(_test._want));
            };
        };
    }
/**
    // Eval returns the type and, if constant, the value for the
    // expression expr, evaluated at position pos of package pkg,
    // which must have been derived from type-checking an AST with
    // complete position information relative to the provided file
    // set.
    //
    // The meaning of the parameters fset, pkg, and pos is the
    // same as in CheckExpr. An error is returned if expr cannot
    // be parsed successfully, or the resulting expr AST cannot be
    // type-checked.
**/
function eval(_fset:Ref<stdgo.go.token.Token.FileSet>, _pkg:Ref<Package>, _pos:stdgo.go.token.Token.Pos, _expr:GoString):{ var _0 : TypeAndValue; var _1 : Error; } {
        var _0:TypeAndValue = ({} : stdgo.go.types.Types.TypeAndValue), _err:Error = (null : Error);
        var __tmp__ = stdgo.go.parser.Parser.parseExprFrom(_fset, ("eval" : GoString), Go.toInterface(_expr), (0u32 : stdgo.go.parser.Parser.Mode)), _node:stdgo.go.ast.Ast.Expr = __tmp__._0, _err:Error = __tmp__._1;
        if (_err != null) {
            return { _0 : (new TypeAndValue() : TypeAndValue), _1 : _err };
        };
        var _info = (Go.setRef(({ types : ({
            final x = new GoObjectMap<stdgo.go.ast.Ast.Expr, stdgo.go.types.Types.TypeAndValue>();
            x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.ast.Ast.Expr", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }));
            x.__defaultValue__ = () -> ({} : stdgo.go.types.Types.TypeAndValue);
            @:mergeBlock {};
            cast x;
        } : GoMap<stdgo.go.ast.Ast.Expr, stdgo.go.types.Types.TypeAndValue>) } : Info)) : Ref<stdgo.go.types.Types.Info>);
        _err = checkExpr(_fset, _pkg, _pos, _node, _info);
        return { _0 : _info.types[_node], _1 : _err };
    }
/**
    // CheckExpr type checks the expression expr as if it had appeared at position
    // pos of package pkg. Type information about the expression is recorded in
    // info. The expression may be an identifier denoting an uninstantiated generic
    // function or type.
    //
    // If pkg == nil, the Universe scope is used and the provided
    // position pos is ignored. If pkg != nil, and pos is invalid,
    // the package scope is used. Otherwise, pos must belong to the
    // package.
    //
    // An error is returned if pos is not within the package or
    // if the node cannot be type-checked.
    //
    // Note: Eval and CheckExpr should not be used instead of running Check
    // to compute types and values, but in addition to Check, as these
    // functions ignore the context in which an expression is used (e.g., an
    // assignment). Thus, top-level untyped constants will return an
    // untyped type rather then the respective context-specific type.
**/
function checkExpr(_fset:Ref<stdgo.go.token.Token.FileSet>, _pkg:Ref<Package>, _pos:stdgo.go.token.Token.Pos, _expr:stdgo.go.ast.Ast.Expr, _info:Ref<Info>):Error {
        var __deferstack__:Array<Void -> Void> = [];
        var _err:Error = (null : Error);
        try {
            var _scope:Ref<Scope> = (null : Ref<stdgo.go.types.Types.Scope>);
            if (_pkg == null || (_pkg : Dynamic).__nil__) {
                _scope = universe;
                _pos = (0 : stdgo.go.token.Token.Pos);
            } else if (!_pos.isValid()) {
                _scope = _pkg._scope;
            } else {
                for (__0 => _fscope in _pkg._scope._children) {
                    {
                        _scope = _fscope.innermost(_pos);
                        if (_scope != null && ((_scope : Dynamic).__nil__ == null || !(_scope : Dynamic).__nil__)) {
                            break;
                        };
                    };
                };
                if (((_scope == null) || (_scope : Dynamic).__nil__) || false) {
                    var _s = _scope;
                    while (((_s != null) && ((_s : Dynamic).__nil__ == null || !(_s : Dynamic).__nil__)) && (_s != _pkg._scope)) {
                        _s = _s._parent;
                    };
                    if (_s == null || (_s : Dynamic).__nil__) {
                        return stdgo.fmt.Fmt.errorf(("no position %s found in package %s" : GoString), Go.toInterface(Go.asInterface(_fset.position(_pos))), Go.toInterface(_pkg._name));
                    };
                };
            };
            var _check = newChecker(null, _fset, _pkg, _info);
            _check._pkg._scope = _scope;
            _check._pkg._scope._pos = _pos;
            {
                var _a0 = (Go.setRef(_err) : Ref<Error>);
                __deferstack__.unshift(() -> _check._handleBailout(_a0));
            };
            var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
            _check._rawExpr((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), _expr, (null : stdgo.go.types.Types.Type), true);
            _check._processDelayed((0 : GoInt));
            _check._recordUntyped();
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return (null : Error);
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return _err;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return _err;
        };
    }
/**
    // opName returns the name of the operation if x is an operation
    // that might overflow; otherwise it returns the empty string.
**/
private function _opName(_e:stdgo.go.ast.Ast.Expr):GoString {
        {
            final __type__ = _e;
            if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BinaryExpr>))) {
                var _e:Ref<stdgo.go.ast.Ast.BinaryExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__().value;
                if ((_e.op : GoInt) < (_op2str2.length)) {
                    return _op2str2[(_e.op : GoInt)];
                };
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.UnaryExpr>))) {
                var _e:Ref<stdgo.go.ast.Ast.UnaryExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__().value;
                if ((_e.op : GoInt) < (_op2str1.length)) {
                    return _op2str1[(_e.op : GoInt)];
                };
            };
        };
        return Go.str();
    }
/**
    // If typ is a type parameter, underIs returns the result of typ.underIs(f).
    // Otherwise, underIs returns the result of f(under(typ)).
**/
private function _underIs(_typ:Type, _f:Type -> Bool):Bool {
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_typ) : Ref<TypeParam>)) : Ref<TypeParam>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.TypeParam>), ok : false };
            }, _tpar = __tmp__.value, __0 = __tmp__.ok;
            if (_tpar != null && ((_tpar : Dynamic).__nil__ == null || !(_tpar : Dynamic).__nil__)) {
                return _tpar._underIs(_f);
            };
        };
        return _f(_under(_typ));
    }
private function _isShift(_op:stdgo.go.token.Token.Token):Bool {
        return (_op == (20 : stdgo.go.token.Token.Token)) || (_op == (21 : stdgo.go.token.Token.Token));
    }
private function _isComparison(_op:stdgo.go.token.Token.Token):Bool {
        {
            final __value__ = _op;
            if (__value__ == ((39 : stdgo.go.token.Token.Token)) || __value__ == ((44 : stdgo.go.token.Token.Token)) || __value__ == ((40 : stdgo.go.token.Token.Token)) || __value__ == ((45 : stdgo.go.token.Token.Token)) || __value__ == ((41 : stdgo.go.token.Token.Token)) || __value__ == ((46 : stdgo.go.token.Token.Token))) {
                return true;
            };
        };
        return false;
    }
private function _fitsFloat32(_x:stdgo.go.constant.Constant.Value):Bool {
        var __tmp__ = stdgo.go.constant.Constant.float32Val(_x), _f32:GoFloat32 = __tmp__._0, __0:Bool = __tmp__._1;
        var _f:GoFloat64 = (_f32 : GoFloat64);
        return !stdgo.math.Math.isInf(_f, (0 : GoInt));
    }
private function _roundFloat32(_x:stdgo.go.constant.Constant.Value):stdgo.go.constant.Constant.Value {
        var __tmp__ = stdgo.go.constant.Constant.float32Val(_x), _f32:GoFloat32 = __tmp__._0, __0:Bool = __tmp__._1;
        var _f:GoFloat64 = (_f32 : GoFloat64);
        if (!stdgo.math.Math.isInf(_f, (0 : GoInt))) {
            return stdgo.go.constant.Constant.makeFloat64(_f);
        };
        return (null : stdgo.go.constant.Constant.Value);
    }
private function _fitsFloat64(_x:stdgo.go.constant.Constant.Value):Bool {
        var __tmp__ = stdgo.go.constant.Constant.float64Val(_x), _f:GoFloat64 = __tmp__._0, __0:Bool = __tmp__._1;
        return !stdgo.math.Math.isInf(_f, (0 : GoInt));
    }
private function _roundFloat64(_x:stdgo.go.constant.Constant.Value):stdgo.go.constant.Constant.Value {
        var __tmp__ = stdgo.go.constant.Constant.float64Val(_x), _f:GoFloat64 = __tmp__._0, __0:Bool = __tmp__._1;
        if (!stdgo.math.Math.isInf(_f, (0 : GoInt))) {
            return stdgo.go.constant.Constant.makeFloat64(_f);
        };
        return (null : stdgo.go.constant.Constant.Value);
    }
/**
    // representableConst reports whether x can be represented as
    // value of the given basic type and for the configuration
    // provided (only needed for int/uint sizes).
    //
    // If rounded != nil, *rounded is set to the rounded value of x for
    // representable floating-point and complex values, and to an Int
    // value for integer values; it is left alone otherwise.
    // It is ok to provide the addressof the first argument for rounded.
    //
    // The check parameter may be nil if representableConst is invoked
    // (indirectly) through an exported API call (AssignableTo, ConvertibleTo)
    // because we don't need the Checker's config for those calls.
**/
private function _representableConst(_x:stdgo.go.constant.Constant.Value, _check:Ref<Checker>, _typ:Ref<Basic>, _rounded:Ref<stdgo.go.constant.Constant.Value>):Bool {
        if (_x.kind() == ((0 : stdgo.go.constant.Constant.Kind))) {
            return true;
        };
        var _conf:Ref<Config> = (null : Ref<stdgo.go.types.Types.Config>);
        if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
            _conf = _check._conf;
        };
        if (_isInteger(Go.asInterface(_typ))) {
            var _x:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.toInt(_x);
            if (_x.kind() != ((3 : stdgo.go.constant.Constant.Kind))) {
                return false;
            };
            if (_rounded != null && ((_rounded : Dynamic).__nil__ == null || !(_rounded : Dynamic).__nil__)) {
                {
                    var __tmp__ = _x;
                    _rounded.exactString = __tmp__.exactString;
                    _rounded.kind = __tmp__.kind;
                    _rounded.string = __tmp__.string;
                    _rounded._implementsValue = __tmp__._implementsValue;
                };
            };
            {
                var __tmp__ = stdgo.go.constant.Constant.int64Val(_x), _x:GoInt64 = __tmp__._0, _ok:Bool = __tmp__._1;
                if (_ok) {
                    {
                        final __value__ = _typ._kind;
                        if (__value__ == ((2 : stdgo.go.types.Types.BasicKind))) {
                            var _s:GoUInt = (_conf._sizeof(Go.asInterface(_typ)) : GoUInt) * (8u32 : GoUInt);
                            return ((((-1i64 : GoInt64) : GoInt64) << (_s - (1u32 : GoUInt))) <= _x) && (_x <= ((((1i64 : GoInt64) : GoInt64) << (_s - (1u32 : GoUInt))) - (1i64 : GoInt64)));
                        } else if (__value__ == ((3 : stdgo.go.types.Types.BasicKind))) {
                            {};
                            return ((-128i64 : GoInt64) <= _x) && (_x <= (127i64 : GoInt64));
                        } else if (__value__ == ((4 : stdgo.go.types.Types.BasicKind))) {
                            {};
                            return ((-32768i64 : GoInt64) <= _x) && (_x <= (32767i64 : GoInt64));
                        } else if (__value__ == ((5 : stdgo.go.types.Types.BasicKind))) {
                            {};
                            return ((-2147483648i64 : GoInt64) <= _x) && (_x <= (2147483647i64 : GoInt64));
                        } else if (__value__ == ((6 : stdgo.go.types.Types.BasicKind)) || __value__ == ((20 : stdgo.go.types.Types.BasicKind))) {
                            return true;
                        } else if (__value__ == ((7 : stdgo.go.types.Types.BasicKind)) || __value__ == ((12 : stdgo.go.types.Types.BasicKind))) {
                            {
                                var _s:GoUInt = (_conf._sizeof(Go.asInterface(_typ)) : GoUInt) * (8u32 : GoUInt);
                                if (_s < (64u32 : GoUInt)) {
                                    return ((0i64 : GoInt64) <= _x) && (_x <= ((((1i64 : GoInt64) : GoInt64) << _s) - (1i64 : GoInt64)));
                                };
                            };
                            return (0i64 : GoInt64) <= _x;
                        } else if (__value__ == ((8 : stdgo.go.types.Types.BasicKind))) {
                            {};
                            return ((0i64 : GoInt64) <= _x) && (_x <= (255i64 : GoInt64));
                        } else if (__value__ == ((9 : stdgo.go.types.Types.BasicKind))) {
                            {};
                            return ((0i64 : GoInt64) <= _x) && (_x <= (65535i64 : GoInt64));
                        } else if (__value__ == ((10 : stdgo.go.types.Types.BasicKind))) {
                            {};
                            return ((0i64 : GoInt64) <= _x) && (_x <= (4294967295i64 : GoInt64));
                        } else if (__value__ == ((11 : stdgo.go.types.Types.BasicKind))) {
                            return (0i64 : GoInt64) <= _x;
                        } else {
                            _unreachable();
                        };
                    };
                };
            };
            {
                var _n:GoInt = stdgo.go.constant.Constant.bitLen(_x);
                {
                    final __value__ = _typ._kind;
                    if (__value__ == ((7 : stdgo.go.types.Types.BasicKind)) || __value__ == ((12 : stdgo.go.types.Types.BasicKind))) {
                        var _s:GoUInt = (_conf._sizeof(Go.asInterface(_typ)) : GoUInt) * (8u32 : GoUInt);
                        return (stdgo.go.constant.Constant.sign(_x) >= (0 : GoInt)) && (_n <= (_s : GoInt));
                    } else if (__value__ == ((11 : stdgo.go.types.Types.BasicKind))) {
                        return (stdgo.go.constant.Constant.sign(_x) >= (0 : GoInt)) && (_n <= (64 : GoInt));
                    } else if (__value__ == ((20 : stdgo.go.types.Types.BasicKind))) {
                        return true;
                    };
                };
            };
        } else if (_isFloat(Go.asInterface(_typ))) {
            var _x:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.toFloat(_x);
            if (_x.kind() != ((4 : stdgo.go.constant.Constant.Kind))) {
                return false;
            };
            {
                final __value__ = _typ._kind;
                if (__value__ == ((13 : stdgo.go.types.Types.BasicKind))) {
                    if (_rounded == null || (_rounded : Dynamic).__nil__) {
                        return _fitsFloat32(_x);
                    };
                    var _r:stdgo.go.constant.Constant.Value = _roundFloat32(_x);
                    if (_r != null) {
                        {
                            var __tmp__ = _r;
                            _rounded.exactString = __tmp__.exactString;
                            _rounded.kind = __tmp__.kind;
                            _rounded.string = __tmp__.string;
                            _rounded._implementsValue = __tmp__._implementsValue;
                        };
                        return true;
                    };
                } else if (__value__ == ((14 : stdgo.go.types.Types.BasicKind))) {
                    if (_rounded == null || (_rounded : Dynamic).__nil__) {
                        return _fitsFloat64(_x);
                    };
                    var _r:stdgo.go.constant.Constant.Value = _roundFloat64(_x);
                    if (_r != null) {
                        {
                            var __tmp__ = _r;
                            _rounded.exactString = __tmp__.exactString;
                            _rounded.kind = __tmp__.kind;
                            _rounded.string = __tmp__.string;
                            _rounded._implementsValue = __tmp__._implementsValue;
                        };
                        return true;
                    };
                } else if (__value__ == ((22 : stdgo.go.types.Types.BasicKind))) {
                    return true;
                } else {
                    _unreachable();
                };
            };
        } else if (_isComplex(Go.asInterface(_typ))) {
            var _x:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.toComplex(_x);
            if (_x.kind() != ((5 : stdgo.go.constant.Constant.Kind))) {
                return false;
            };
            {
                final __value__ = _typ._kind;
                if (__value__ == ((15 : stdgo.go.types.Types.BasicKind))) {
                    if (_rounded == null || (_rounded : Dynamic).__nil__) {
                        return _fitsFloat32(stdgo.go.constant.Constant.real(_x)) && _fitsFloat32(stdgo.go.constant.Constant.imag(_x));
                    };
                    var _re:stdgo.go.constant.Constant.Value = _roundFloat32(stdgo.go.constant.Constant.real(_x));
                    var _im:stdgo.go.constant.Constant.Value = _roundFloat32(stdgo.go.constant.Constant.imag(_x));
                    if ((_re != null) && (_im != null)) {
                        {
                            var __tmp__ = stdgo.go.constant.Constant.binaryOp(_re, (12 : stdgo.go.token.Token.Token), stdgo.go.constant.Constant.makeImag(_im));
                            _rounded.exactString = __tmp__.exactString;
                            _rounded.kind = __tmp__.kind;
                            _rounded.string = __tmp__.string;
                            _rounded._implementsValue = __tmp__._implementsValue;
                        };
                        return true;
                    };
                } else if (__value__ == ((16 : stdgo.go.types.Types.BasicKind))) {
                    if (_rounded == null || (_rounded : Dynamic).__nil__) {
                        return _fitsFloat64(stdgo.go.constant.Constant.real(_x)) && _fitsFloat64(stdgo.go.constant.Constant.imag(_x));
                    };
                    var _re:stdgo.go.constant.Constant.Value = _roundFloat64(stdgo.go.constant.Constant.real(_x));
                    var _im:stdgo.go.constant.Constant.Value = _roundFloat64(stdgo.go.constant.Constant.imag(_x));
                    if ((_re != null) && (_im != null)) {
                        {
                            var __tmp__ = stdgo.go.constant.Constant.binaryOp(_re, (12 : stdgo.go.token.Token.Token), stdgo.go.constant.Constant.makeImag(_im));
                            _rounded.exactString = __tmp__.exactString;
                            _rounded.kind = __tmp__.kind;
                            _rounded.string = __tmp__.string;
                            _rounded._implementsValue = __tmp__._implementsValue;
                        };
                        return true;
                    };
                } else if (__value__ == ((23 : stdgo.go.types.Types.BasicKind))) {
                    return true;
                } else {
                    _unreachable();
                };
            };
        } else if (_isString(Go.asInterface(_typ))) {
            return _x.kind() == ((2 : stdgo.go.constant.Constant.Kind));
        } else if (_isBoolean(Go.asInterface(_typ))) {
            return _x.kind() == ((1 : stdgo.go.constant.Constant.Kind));
        };
        return false;
    }
/**
    // keyVal maps a complex, float, integer, string or boolean constant value
    // to the corresponding complex128, float64, int64, uint64, string, or bool
    // Go value if possible; otherwise it returns x.
    // A complex constant that can be represented as a float (such as 1.2 + 0i)
    // is returned as a floating point value; if a floating point value can be
    // represented as an integer (such as 1.0) it is returned as an integer value.
    // This ensures that constants of different kind but equal value (such as
    // 1.0 + 0i, 1.0, 1) result in the same value.
**/
private function _keyVal(_x:stdgo.go.constant.Constant.Value):AnyInterface {
        {
            var __switchIndex__ = -1;
            var __run__ = true;
            while (__run__) {
                __run__ = false;
                {
                    final __value__ = _x.kind();
                    if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (__value__ == (5 : stdgo.go.constant.Constant.Kind)))) {
                        var _f:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.toFloat(_x);
                        if (_f.kind() != ((4 : stdgo.go.constant.Constant.Kind))) {
                            var __tmp__ = stdgo.go.constant.Constant.float64Val(stdgo.go.constant.Constant.real(_x)), _r:GoFloat64 = __tmp__._0, __0:Bool = __tmp__._1;
                            var __tmp__ = stdgo.go.constant.Constant.float64Val(stdgo.go.constant.Constant.imag(_x)), _i:GoFloat64 = __tmp__._0, __1:Bool = __tmp__._1;
                            return Go.toInterface(new GoComplex128(_r, _i));
                        };
                        _x = _f;
                        @:fallthrough {
                            __switchIndex__ = 1;
                            __run__ = true;
                            continue;
                        };
                        break;
                    } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && (__value__ == (4 : stdgo.go.constant.Constant.Kind)))) {
                        var _i:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.toInt(_x);
                        if (_i.kind() != ((3 : stdgo.go.constant.Constant.Kind))) {
                            var __tmp__ = stdgo.go.constant.Constant.float64Val(_x), _v:GoFloat64 = __tmp__._0, __2:Bool = __tmp__._1;
                            return Go.toInterface(_v);
                        };
                        _x = _i;
                        @:fallthrough {
                            __switchIndex__ = 2;
                            __run__ = true;
                            continue;
                        };
                        break;
                    } else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && (__value__ == (3 : stdgo.go.constant.Constant.Kind)))) {
                        {
                            var __tmp__ = stdgo.go.constant.Constant.int64Val(_x), _v:GoInt64 = __tmp__._0, _ok:Bool = __tmp__._1;
                            if (_ok) {
                                return Go.toInterface(_v);
                            };
                        };
                        {
                            var __tmp__ = stdgo.go.constant.Constant.uint64Val(_x), _v:GoUInt64 = __tmp__._0, _ok:Bool = __tmp__._1;
                            if (_ok) {
                                return Go.toInterface(_v);
                            };
                        };
                        break;
                        break;
                    } else if (__switchIndex__ == 3 || (__switchIndex__ == -1 && (__value__ == (2 : stdgo.go.constant.Constant.Kind)))) {
                        return Go.toInterface(stdgo.go.constant.Constant.stringVal(_x));
                        break;
                        break;
                    } else if (__switchIndex__ == 4 || (__switchIndex__ == -1 && (__value__ == (1 : stdgo.go.constant.Constant.Kind)))) {
                        return Go.toInterface(stdgo.go.constant.Constant.boolVal(_x));
                        break;
                        break;
                    };
                };
                break;
            };
        };
        return Go.toInterface(_x);
    }
/**
    // ExprString returns the (possibly shortened) string representation for x.
    // Shortened representations are suitable for user interfaces but may not
    // necessarily follow Go syntax.
**/
function exprString(_x:stdgo.go.ast.Ast.Expr):GoString {
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        writeExpr((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>), _x);
        return (_buf.string() : GoString);
    }
/**
    // WriteExpr writes the (possibly shortened) string representation for x to buf.
    // Shortened representations are suitable for user interfaces but may not
    // necessarily follow Go syntax.
**/
function writeExpr(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _x:stdgo.go.ast.Ast.Expr):Void {
        {
            final __type__ = _x;
            if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ident>))) {
                var _x:Ref<stdgo.go.ast.Ast.Ident> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__().value;
                _buf.writeString(_x.name);
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ellipsis>))) {
                var _x:Ref<stdgo.go.ast.Ast.Ellipsis> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__.__underlying__().value;
                _buf.writeString(("..." : GoString));
                if (_x.elt != null) {
                    writeExpr(_buf, _x.elt);
                };
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BasicLit>))) {
                var _x:Ref<stdgo.go.ast.Ast.BasicLit> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BasicLit>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BasicLit>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BasicLit>) : __type__.__underlying__().value;
                _buf.writeString(_x.value);
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.FuncLit>))) {
                var _x:Ref<stdgo.go.ast.Ast.FuncLit> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.FuncLit>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.FuncLit>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.FuncLit>) : __type__.__underlying__().value;
                _buf.writeByte((40 : GoUInt8));
                writeExpr(_buf, Go.asInterface(_x.type));
                _buf.writeString((" literal)" : GoString));
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CompositeLit>))) {
                var _x:Ref<stdgo.go.ast.Ast.CompositeLit> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CompositeLit>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.CompositeLit>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CompositeLit>) : __type__.__underlying__().value;
                writeExpr(_buf, _x.type);
                _buf.writeByte((123 : GoUInt8));
                if ((_x.elts.length) > (0 : GoInt)) {
                    _buf.writeString(("‚Ä¶" : GoString));
                };
                _buf.writeByte((125 : GoUInt8));
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ParenExpr>))) {
                var _x:Ref<stdgo.go.ast.Ast.ParenExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__().value;
                _buf.writeByte((40 : GoUInt8));
                writeExpr(_buf, _x.x);
                _buf.writeByte((41 : GoUInt8));
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectorExpr>))) {
                var _x:Ref<stdgo.go.ast.Ast.SelectorExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__().value;
                writeExpr(_buf, _x.x);
                _buf.writeByte((46 : GoUInt8));
                _buf.writeString(_x.sel.name);
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexExpr>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexListExpr>))) {
                var _x:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                var _ix = stdgo.go.internal.typeparams.Typeparams.unpackIndexExpr(_x);
                writeExpr(_buf, _ix.indexListExpr.x);
                _buf.writeByte((91 : GoUInt8));
                _writeExprList(_buf, _ix.indexListExpr.indices);
                _buf.writeByte((93 : GoUInt8));
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SliceExpr>))) {
                var _x:Ref<stdgo.go.ast.Ast.SliceExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SliceExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SliceExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SliceExpr>) : __type__.__underlying__().value;
                writeExpr(_buf, _x.x);
                _buf.writeByte((91 : GoUInt8));
                if (_x.low != null) {
                    writeExpr(_buf, _x.low);
                };
                _buf.writeByte((58 : GoUInt8));
                if (_x.high != null) {
                    writeExpr(_buf, _x.high);
                };
                if (_x.slice3) {
                    _buf.writeByte((58 : GoUInt8));
                    if (_x.max != null) {
                        writeExpr(_buf, _x.max);
                    };
                };
                _buf.writeByte((93 : GoUInt8));
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.TypeAssertExpr>))) {
                var _x:Ref<stdgo.go.ast.Ast.TypeAssertExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeAssertExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.TypeAssertExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeAssertExpr>) : __type__.__underlying__().value;
                writeExpr(_buf, _x.x);
                _buf.writeString((".(" : GoString));
                writeExpr(_buf, _x.type);
                _buf.writeByte((41 : GoUInt8));
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CallExpr>))) {
                var _x:Ref<stdgo.go.ast.Ast.CallExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CallExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.CallExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CallExpr>) : __type__.__underlying__().value;
                writeExpr(_buf, _x.fun);
                _buf.writeByte((40 : GoUInt8));
                _writeExprList(_buf, _x.args);
                if (_x.ellipsis.isValid()) {
                    _buf.writeString(("..." : GoString));
                };
                _buf.writeByte((41 : GoUInt8));
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.StarExpr>))) {
                var _x:Ref<stdgo.go.ast.Ast.StarExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__().value;
                _buf.writeByte((42 : GoUInt8));
                writeExpr(_buf, _x.x);
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.UnaryExpr>))) {
                var _x:Ref<stdgo.go.ast.Ast.UnaryExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__().value;
                _buf.writeString((_x.op.string() : GoString));
                writeExpr(_buf, _x.x);
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BinaryExpr>))) {
                var _x:Ref<stdgo.go.ast.Ast.BinaryExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__().value;
                writeExpr(_buf, _x.x);
                _buf.writeByte((32 : GoUInt8));
                _buf.writeString((_x.op.string() : GoString));
                _buf.writeByte((32 : GoUInt8));
                writeExpr(_buf, _x.y);
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ArrayType>))) {
                var _x:Ref<stdgo.go.ast.Ast.ArrayType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ArrayType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ArrayType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ArrayType>) : __type__.__underlying__().value;
                _buf.writeByte((91 : GoUInt8));
                if (_x.len != null) {
                    writeExpr(_buf, _x.len);
                };
                _buf.writeByte((93 : GoUInt8));
                writeExpr(_buf, _x.elt);
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.StructType>))) {
                var _x:Ref<stdgo.go.ast.Ast.StructType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StructType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.StructType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StructType>) : __type__.__underlying__().value;
                _buf.writeString(("struct{" : GoString));
                _writeFieldList(_buf, _x.fields.list, ("; " : GoString), false);
                _buf.writeByte((125 : GoUInt8));
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.FuncType>))) {
                var _x:Ref<stdgo.go.ast.Ast.FuncType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.FuncType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.FuncType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.FuncType>) : __type__.__underlying__().value;
                _buf.writeString(("func" : GoString));
                _writeSigExpr(_buf, _x);
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.InterfaceType>))) {
                var _x:Ref<stdgo.go.ast.Ast.InterfaceType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.InterfaceType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.InterfaceType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.InterfaceType>) : __type__.__underlying__().value;
                _buf.writeString(("interface{" : GoString));
                _writeFieldList(_buf, _x.methods.list, ("; " : GoString), true);
                _buf.writeByte((125 : GoUInt8));
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.MapType>))) {
                var _x:Ref<stdgo.go.ast.Ast.MapType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.MapType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.MapType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.MapType>) : __type__.__underlying__().value;
                _buf.writeString(("map[" : GoString));
                writeExpr(_buf, _x.key);
                _buf.writeByte((93 : GoUInt8));
                writeExpr(_buf, _x.value);
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ChanType>))) {
                var _x:Ref<stdgo.go.ast.Ast.ChanType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ChanType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ChanType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ChanType>) : __type__.__underlying__().value;
                var _s:GoString = ("" : GoString);
                {
                    final __value__ = _x.dir;
                    if (__value__ == ((1 : stdgo.go.ast.Ast.ChanDir))) {
                        _s = ("chan<- " : GoString);
                    } else if (__value__ == ((2 : stdgo.go.ast.Ast.ChanDir))) {
                        _s = ("<-chan " : GoString);
                    } else {
                        _s = ("chan " : GoString);
                    };
                };
                _buf.writeString(_s);
                writeExpr(_buf, _x.value);
            } else {
                var _x:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                stdgo.fmt.Fmt.fprintf(Go.asInterface(_buf), ("(ast: %T)" : GoString), Go.toInterface(_x));
            };
        };
    }
private function _writeSigExpr(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _sig:Ref<stdgo.go.ast.Ast.FuncType>):Void {
        _buf.writeByte((40 : GoUInt8));
        _writeFieldList(_buf, _sig.params.list, (", " : GoString), false);
        _buf.writeByte((41 : GoUInt8));
        var _res = _sig.results;
        var _n:GoInt = _res.numFields();
        if (_n == ((0 : GoInt))) {
            return;
        };
        _buf.writeByte((32 : GoUInt8));
        if ((_n == (1 : GoInt)) && (_res.list[(0 : GoInt)].names.length == (0 : GoInt))) {
            writeExpr(_buf, _res.list[(0 : GoInt)].type);
            return;
        };
        _buf.writeByte((40 : GoUInt8));
        _writeFieldList(_buf, _res.list, (", " : GoString), false);
        _buf.writeByte((41 : GoUInt8));
    }
private function _writeFieldList(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _list:Slice<Ref<stdgo.go.ast.Ast.Field>>, _sep:GoString, _iface:Bool):Void {
        for (_i => _f in _list) {
            if (_i > (0 : GoInt)) {
                _buf.writeString(_sep);
            };
            _writeIdentList(_buf, _f.names);
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_f.type) : Ref<stdgo.go.ast.Ast.FuncType>)) : Ref<stdgo.go.ast.Ast.FuncType>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.ast.Ast.FuncType>), ok : false };
                }, _sig = __tmp__.value, __0 = __tmp__.ok;
                if (((_sig != null) && ((_sig : Dynamic).__nil__ == null || !(_sig : Dynamic).__nil__)) && _iface) {
                    _writeSigExpr(_buf, _sig);
                    continue;
                };
            };
            if ((_f.names.length) > (0 : GoInt)) {
                _buf.writeByte((32 : GoUInt8));
            };
            writeExpr(_buf, _f.type);
        };
    }
private function _writeIdentList(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _list:Slice<Ref<stdgo.go.ast.Ast.Ident>>):Void {
        for (_i => _x in _list) {
            if (_i > (0 : GoInt)) {
                _buf.writeString((", " : GoString));
            };
            _buf.writeString(_x.name);
        };
    }
private function _writeExprList(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _list:Slice<stdgo.go.ast.Ast.Expr>):Void {
        for (_i => _x in _list) {
            if (_i > (0 : GoInt)) {
                _buf.writeString((", " : GoString));
            };
            writeExpr(_buf, _x);
        };
    }
/**
    // typeParamsString produces a string containing all the type parameter names
    // in list suitable for human consumption.
**/
private function _typeParamsString(_list:Slice<Ref<TypeParam>>):GoString {
        var _n:GoInt = (_list.length);
        {
            final __value__ = _n;
            if (__value__ == ((0 : GoInt))) {
                return Go.str();
            } else if (__value__ == ((1 : GoInt))) {
                return _list[(0 : GoInt)]._obj._object._name;
            } else if (__value__ == ((2 : GoInt))) {
                return (_list[(0 : GoInt)]._obj._object._name + (" and " : GoString)) + _list[(1 : GoInt)]._obj._object._name;
            };
        };
        var _buf:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
        for (_i => _tname in (_list.__slice__(0, _n - (1 : GoInt)) : Slice<Ref<stdgo.go.types.Types.TypeParam>>)) {
            if (_i > (0 : GoInt)) {
                _buf.writeString((", " : GoString));
            };
            _buf.writeString(_tname._obj._object._name);
        };
        _buf.writeString((", and " : GoString));
        _buf.writeString(_list[(_n - (1 : GoInt) : GoInt)]._obj._object._name);
        return (_buf.string() : GoString);
    }
/**
    // isParameterized reports whether typ contains any of the type parameters of tparams.
**/
private function _isParameterized(_tparams:Slice<Ref<TypeParam>>, _typ:Type):Bool {
        var _w:stdgo.go.types.Types.T_tpWalker = ({ _seen : ({
            final x = new GoObjectMap<stdgo.go.types.Types.Type, Bool>();
            x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Type", [], stdgo.internal.reflect.Reflect.GoType.named("Type", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
            x.__defaultValue__ = () -> false;
            @:mergeBlock {};
            cast x;
        } : GoMap<stdgo.go.types.Types.Type, Bool>), _tparams : _tparams } : T_tpWalker);
        return _w._isParameterized(_typ);
    }
/**
    // If the type parameter has a single specific type S, coreTerm returns (S, true).
    // Otherwise, if tpar has a core type T, it returns a term corresponding to that
    // core type and false. In that case, if any term of tpar has a tilde, the core
    // term has a tilde. In all other cases coreTerm returns (nil, false).
**/
private function _coreTerm(_tpar:Ref<TypeParam>):{ var _0 : Ref<T_term>; var _1 : Bool; } {
        var _n:GoInt = (0 : GoInt);
        var _single:Ref<T_term> = (null : Ref<stdgo.go.types.Types.T_term>);
        var _tilde:Bool = false;
        _tpar._is(function(_t:Ref<T_term>):Bool {
            if (_t == null || (_t : Dynamic).__nil__) {
                _assert(_n == ((0 : GoInt)));
                return false;
            };
            _n++;
            _single = _t;
            if (_t._tilde) {
                _tilde = true;
            };
            return true;
        });
        if (_n == ((1 : GoInt))) {
            if (false) {
                _assert(false && (Go.toInterface(_under(_single._typ)) == Go.toInterface(_coreType(Go.asInterface(_tpar)))));
            };
            return { _0 : _single, _1 : true };
        };
        {
            var _typ:stdgo.go.types.Types.Type = _coreType(Go.asInterface(_tpar));
            if (_typ != null) {
                return { _0 : (Go.setRef((new T_term(_tilde, _typ) : T_term)) : Ref<stdgo.go.types.Types.T_term>), _1 : false };
            };
        };
        return { _0 : (null : Ref<stdgo.go.types.Types.T_term>), _1 : false };
    }
/**
    // findPath returns the (reversed) list of objects []Object{to, ... from}
    // such that there is a path of object dependencies from 'from' to 'to'.
    // If there is no such path, the result is nil.
**/
private function _findPath(_objMap:GoMap<Object, Ref<T_declInfo>>, _from:Object, _to:Object, _seen:GoMap<Object, Bool>):Slice<Object> {
        if (_seen[_from]) {
            return (null : Slice<stdgo.go.types.Types.Object>);
        };
        _seen[_from] = true;
        for (_d => _ in _objMap[_from]._deps) {
            if (Go.toInterface(_d) == (Go.toInterface(_to))) {
                return (new Slice<stdgo.go.types.Types.Object>(1, 1, _d) : Slice<stdgo.go.types.Types.Object>);
            };
            {
                var p = _findPath(_objMap, _d, _to, _seen);
                if (p != null) {
                    return (p.__append__(_d));
                };
            };
        };
        return (null : Slice<stdgo.go.types.Types.Object>);
    }
/**
    // dependencyGraph computes the object dependency graph from the given objMap,
    // with any function nodes removed. The resulting graph contains only constants
    // and variables.
**/
private function _dependencyGraph(_objMap:GoMap<Object, Ref<T_declInfo>>):Slice<Ref<T_graphNode>> {
        var m = ({
            final x = new GoObjectMap<stdgo.go.types.Types.T_dependency, Ref<stdgo.go.types.Types.T_graphNode>>();
            x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.T_dependency", [], stdgo.internal.reflect.Reflect.GoType.named("T_dependency", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
            x.__defaultValue__ = () -> (null : Ref<stdgo.go.types.Types.T_graphNode>);
            @:mergeBlock {};
            cast x;
        } : GoMap<stdgo.go.types.Types.T_dependency, Ref<stdgo.go.types.Types.T_graphNode>>);
        for (_obj => _ in _objMap) {
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_obj) : T_dependency)) : T_dependency), ok : true };
                } catch(_) {
                    { value : (null : stdgo.go.types.Types.T_dependency), ok : false };
                }, _obj = __tmp__.value, __0 = __tmp__.ok;
                if (_obj != null) {
                    m[_obj] = (Go.setRef(({ _obj : _obj } : T_graphNode)) : Ref<stdgo.go.types.Types.T_graphNode>);
                };
            };
        };
        for (_obj => _n in m) {
            for (_d => _ in _objMap[_obj]._deps) {
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_d) : T_dependency)) : T_dependency), ok : true };
                    } catch(_) {
                        { value : (null : stdgo.go.types.Types.T_dependency), ok : false };
                    }, _d = __tmp__.value, __1 = __tmp__.ok;
                    if (_d != null) {
                        var _d = m[_d];
                        _n._succ._add(_d);
                        _d._pred._add(_n);
                    };
                };
            };
        };
        var __0:Slice<Ref<T_graphNode>> = (null : Slice<Ref<stdgo.go.types.Types.T_graphNode>>), __1:Slice<Ref<T_graphNode>> = (null : Slice<Ref<stdgo.go.types.Types.T_graphNode>>), _funcG:Slice<Ref<T_graphNode>> = __1, g:Slice<Ref<T_graphNode>> = __0;
        for (__2 => _n in m) {
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_n._obj) : Ref<Func>)) : Ref<Func>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.Func>), ok : false };
                }, __3 = __tmp__.value, _ok = __tmp__.ok;
                if (_ok) {
                    _funcG = (_funcG.__append__(_n));
                } else {
                    g = (g.__append__(_n));
                };
            };
        };
        stdgo.sort.Sort.slice(Go.toInterface(_funcG), function(_i:GoInt, _j:GoInt):Bool {
            return _funcG[(_i : GoInt)]._cost() < _funcG[(_j : GoInt)]._cost();
        });
        for (__4 => _n in _funcG) {
            for (_p => _ in _n._pred) {
                if (_p != (_n)) {
                    for (_s => _ in _n._succ) {
                        if (_s != (_n)) {
                            _p._succ._add(_s);
                            _s._pred._add(_p);
                        };
                    };
                    if (_p._succ != null) _p._succ.remove(_n);
                };
            };
            for (_s => _ in _n._succ) {
                if (_s._pred != null) _s._pred.remove(_n);
            };
        };
        for (_i => _n in g) {
            _n._index = _i;
            _n._ndeps = (_n._succ.length);
        };
        return g;
    }
/**
    // Instantiate instantiates the type orig with the given type arguments targs.
    // orig must be a *Named or a *Signature type. If there is no error, the
    // resulting Type is an instantiated type of the same kind (either a *Named or
    // a *Signature). Methods attached to a *Named type are also instantiated, and
    // associated with a new *Func that has the same position as the original
    // method, but nil function scope.
    //
    // If ctxt is non-nil, it may be used to de-duplicate the instance against
    // previous instances with the same identity. As a special case, generic
    // *Signature origin types are only considered identical if they are pointer
    // equivalent, so that instantiating distinct (but possibly identical)
    // signatures will yield different instances. The use of a shared context does
    // not guarantee that identical instances are deduplicated in all cases.
    //
    // If validate is set, Instantiate verifies that the number of type arguments
    // and parameters match, and that the type arguments satisfy their
    // corresponding type constraints. If verification fails, the resulting error
    // may wrap an *ArgumentError indicating which type argument did not satisfy
    // its corresponding type parameter constraint, and why.
    //
    // If validate is not set, Instantiate does not verify the type argument count
    // or whether the type arguments satisfy their constraints. Instantiate is
    // guaranteed to not return an error, but may panic. Specifically, for
    // *Signature types, Instantiate will panic immediately if the type argument
    // count is incorrect; for *Named types, a panic may occur later inside the
    // *Named API.
**/
function instantiate(_ctxt:Ref<Context>, _orig:Type, _targs:Slice<Type>, _validate:Bool):{ var _0 : Type; var _1 : Error; } {
        if (_ctxt == null || (_ctxt : Dynamic).__nil__) {
            _ctxt = newContext();
        };
        if (_validate) {
            var _tparams:Slice<Ref<TypeParam>> = (null : Slice<Ref<stdgo.go.types.Types.TypeParam>>);
            {
                final __type__ = _orig;
                if (Go.typeEquals((__type__ : Ref<Named>))) {
                    var _t:Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                    _tparams = _t.typeParams()._list();
                } else if (Go.typeEquals((__type__ : Ref<Signature>))) {
                    var _t:Ref<stdgo.go.types.Types.Signature> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__().value;
                    _tparams = _t.typeParams()._list();
                };
            };
            if ((_targs.length) != ((_tparams.length))) {
                return { _0 : (null : stdgo.go.types.Types.Type), _1 : stdgo.fmt.Fmt.errorf(("got %d type arguments but %s has %d type parameters" : GoString), Go.toInterface((_targs.length)), Go.toInterface(_orig), Go.toInterface((_tparams.length))) };
            };
            {
                var __tmp__ = ((null : Ref<stdgo.go.types.Types.Checker>) : Ref<Checker>)._verify((0 : stdgo.go.token.Token.Pos), _tparams, _targs, _ctxt), _i:GoInt = __tmp__._0, _err:Error = __tmp__._1;
                if (_err != null) {
                    return { _0 : (null : stdgo.go.types.Types.Type), _1 : Go.asInterface((Go.setRef((new ArgumentError(_i, _err) : ArgumentError)) : Ref<stdgo.go.types.Types.ArgumentError>)) };
                };
            };
        };
        var _inst:stdgo.go.types.Types.Type = ((null : Ref<stdgo.go.types.Types.Checker>) : Ref<Checker>)._instance((0 : stdgo.go.token.Token.Pos), _orig, _targs, null, _ctxt);
        return { _0 : _inst, _1 : (null : Error) };
    }
/**
    // mentions reports whether type T "mentions" typ in an (embedded) element or term
    // of T (whether typ is in the type set of T or not). For better error messages.
**/
private function _mentions(t:Type, _typ:Type):Bool {
        {
            final __type__ = t;
            if (Go.typeEquals((__type__ : Ref<Interface>))) {
                var t:Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                for (__0 => _e in t._embeddeds) {
                    if (_mentions(_e, _typ)) {
                        return true;
                    };
                };
            } else if (Go.typeEquals((__type__ : Ref<Union>))) {
                var t:Ref<stdgo.go.types.Types.Union> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Union>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__().value;
                for (__9 => _t in t._terms) {
                    if (_mentions(_t._typ, _typ)) {
                        return true;
                    };
                };
            } else {
                var t:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                if (identical(t, _typ)) {
                    return true;
                };
            };
        };
        return false;
    }
/**
    // NewInterface returns a new interface for the given methods and embedded types.
    // NewInterface takes ownership of the provided methods and may modify their types
    // by setting missing receivers.
    //
    // Deprecated: Use NewInterfaceType instead which allows arbitrary embedded types.
**/
function newInterface(_methods:Slice<Ref<Func>>, _embeddeds:Slice<Ref<Named>>):Ref<Interface> {
        var _tnames = new Slice<stdgo.go.types.Types.Type>((_embeddeds.length : GoInt).toBasic(), 0);
        for (_i => _t in _embeddeds) {
            _tnames[(_i : GoInt)] = Go.asInterface(_t);
        };
        return newInterfaceType(_methods, _tnames);
    }
/**
    // NewInterfaceType returns a new interface for the given methods and embedded
    // types. NewInterfaceType takes ownership of the provided methods and may
    // modify their types by setting missing receivers.
    //
    // To avoid race conditions, the interface's type set should be computed before
    // concurrent use of the interface, by explicitly calling Complete.
**/
function newInterfaceType(_methods:Slice<Ref<Func>>, _embeddeds:Slice<Type>):Ref<Interface> {
        if ((_methods.length == (0 : GoInt)) && (_embeddeds.length == (0 : GoInt))) {
            return (Go.setRef(_emptyInterface) : Ref<stdgo.go.types.Types.Interface>);
        };
        var _typ = ((null : Ref<stdgo.go.types.Types.Checker>) : Ref<Checker>)._newInterface();
        for (__0 => _m in _methods) {
            {
                var _sig = (Go.typeAssert((Go.toInterface(_m._object._typ) : Ref<Signature>)) : Ref<Signature>);
                if (_sig._recv == null || (_sig._recv : Dynamic).__nil__) {
                    _sig._recv = newVar(_m._object._pos, _m._object._pkg, Go.str(), Go.asInterface(_typ));
                };
            };
        };
        _sortMethods(_methods);
        _typ._methods = _methods;
        _typ._embeddeds = _embeddeds;
        _typ._complete = true;
        return _typ;
    }
/**
    // LookupFieldOrMethod looks up a field or method with given package and name
    // in T and returns the corresponding *Var or *Func, an index sequence, and a
    // bool indicating if there were any pointer indirections on the path to the
    // field or method. If addressable is set, T is the type of an addressable
    // variable (only matters for method lookups). T must not be nil.
    //
    // The last index entry is the field or method index in the (possibly embedded)
    // type where the entry was found, either:
    //
    //  1. the list of declared methods of a named type; or
    //  2. the list of all methods (method set) of an interface type; or
    //  3. the list of fields of a struct type.
    //
    // The earlier index entries are the indices of the embedded struct fields
    // traversed to get to the found entry, starting at depth 0.
    //
    // If no entry is found, a nil object is returned. In this case, the returned
    // index and indirect values have the following meaning:
    //
    //   - If index != nil, the index sequence points to an ambiguous entry
    //     (the same name appeared more than once at the same embedding level).
    //
    //   - If indirect is set, a method with a pointer receiver type was found
    //     but there was no pointer on the path from the actual receiver type to
    //     the method's formal receiver base type, nor was the receiver addressable.
**/
function lookupFieldOrMethod(t:Type, _addressable:Bool, _pkg:Ref<Package>, _name:GoString):{ var _0 : Object; var _1 : Slice<GoInt>; var _2 : Bool; } {
        var _obj:Object = (null : stdgo.go.types.Types.Object), _index:Slice<GoInt> = (null : Slice<GoInt>), _indirect:Bool = false;
        if (t == null) {
            throw Go.toInterface(("LookupFieldOrMethod on nil type" : GoString));
        };
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(t) : Ref<Named>)) : Ref<Named>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
            }, _t = __tmp__.value, __0 = __tmp__.ok;
            if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_t.underlying()) : Ref<Pointer_>)) : Ref<Pointer_>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Pointer_>), ok : false };
                    }, _p = __tmp__.value, __1 = __tmp__.ok;
                    if (_p != null && ((_p : Dynamic).__nil__ == null || !(_p : Dynamic).__nil__)) {
                        {
                            var __tmp__ = _lookupFieldOrMethod(Go.asInterface(_p), false, _pkg, _name, false);
                            _obj = __tmp__._0;
                            _index = __tmp__._1;
                            _indirect = __tmp__._2;
                        };
                        {
                            var __tmp__ = try {
                                { value : (Go.typeAssert((Go.toInterface(_obj) : Ref<Func>)) : Ref<Func>), ok : true };
                            } catch(_) {
                                { value : (null : Ref<stdgo.go.types.Types.Func>), ok : false };
                            }, __2 = __tmp__.value, _ok = __tmp__.ok;
                            if (_ok) {
                                return { _0 : (null : stdgo.go.types.Types.Object), _1 : (null : Slice<GoInt>), _2 : false };
                            };
                        };
                        return { _0 : _obj, _1 : _index, _2 : _indirect };
                    };
                };
            };
        };
        {
            var __tmp__ = _lookupFieldOrMethod(t, _addressable, _pkg, _name, false);
            _obj = __tmp__._0;
            _index = __tmp__._1;
            _indirect = __tmp__._2;
        };
        {};
        if ((false && (_obj == null)) && _isTypeParam(t)) {
            {
                var _t:stdgo.go.types.Types.Type = _coreType(t);
                if (_t != null) {
                    {
                        var __tmp__ = _lookupFieldOrMethod(_t, _addressable, _pkg, _name, false);
                        _obj = __tmp__._0;
                        _index = __tmp__._1;
                        _indirect = __tmp__._2;
                    };
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_obj) : Ref<Var>)) : Ref<Var>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.types.Types.Var>), ok : false };
                        }, __3 = __tmp__.value, _ok = __tmp__.ok;
                        if (!_ok) {
                            {
                                final __tmp__0 = (null : stdgo.go.types.Types.Object);
                                final __tmp__1 = (null : Slice<GoInt>);
                                final __tmp__2 = false;
                                _obj = __tmp__0;
                                _index = __tmp__1;
                                _indirect = __tmp__2;
                            };
                        };
                    };
                };
            };
        };
        return { _0 : _obj, _1 : _index, _2 : _indirect };
    }
/**
    // lookupFieldOrMethod should only be called by LookupFieldOrMethod and missingMethod.
    // If foldCase is true, the lookup for methods will include looking for any method
    // which case-folds to the same as 'name' (used for giving helpful error messages).
    //
    // The resulting object may not be fully type-checked.
**/
private function _lookupFieldOrMethod(t:Type, _addressable:Bool, _pkg:Ref<Package>, _name:GoString, _foldCase:Bool):{ var _0 : Object; var _1 : Slice<GoInt>; var _2 : Bool; } {
        var _obj:Object = (null : stdgo.go.types.Types.Object), _index:Slice<GoInt> = (null : Slice<GoInt>), _indirect:Bool = false;
        if (_name == (("_" : GoString))) {
            return { _0 : _obj, _1 : _index, _2 : _indirect };
        };
        var __tmp__ = _deref(t), _typ:stdgo.go.types.Types.Type = __tmp__._0, _isPtr:Bool = __tmp__._1;
        if (_isPtr) {
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Interface>)) : Ref<Interface>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.Interface>), ok : false };
                }, __0 = __tmp__.value, _ok = __tmp__.ok;
                if (_ok) {
                    return { _0 : _obj, _1 : _index, _2 : _indirect };
                };
            };
        };
        var _current = (new Slice<stdgo.go.types.Types.T_embeddedType>(1, 1, (new stdgo.go.types.Types.T_embeddedType(_typ, (null : Slice<GoInt>), _isPtr, false) : stdgo.go.types.Types.T_embeddedType)) : Slice<stdgo.go.types.Types.T_embeddedType>);
        var _seen:T_instanceLookup = ({} : stdgo.go.types.Types.T_instanceLookup);
        while ((_current.length) > (0 : GoInt)) {
            var _next:Slice<T_embeddedType> = (null : Slice<stdgo.go.types.Types.T_embeddedType>);
            for (__1 => _e in _current) {
                var _typ:stdgo.go.types.Types.Type = _e._typ;
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_typ) : Ref<Named>)) : Ref<Named>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
                    }, _named = __tmp__.value, __2 = __tmp__.ok;
                    if (_named != null && ((_named : Dynamic).__nil__ == null || !(_named : Dynamic).__nil__)) {
                        {
                            var _alt = _seen._lookup(_named);
                            if (_alt != null && ((_alt : Dynamic).__nil__ == null || !(_alt : Dynamic).__nil__)) {
                                continue;
                            };
                        };
                        _seen._add(_named);
                        {
                            var __tmp__ = _named._lookupMethod(_pkg, _name, _foldCase), _i:GoInt = __tmp__._0, _m:Ref<stdgo.go.types.Types.Func> = __tmp__._1;
                            if (_m != null && ((_m : Dynamic).__nil__ == null || !(_m : Dynamic).__nil__)) {
                                _index = _concat(_e._index, _i);
                                if ((_obj != null) || _e._multiples) {
                                    return { _0 : (null : stdgo.go.types.Types.Object), _1 : _index, _2 : false };
                                };
                                _obj = Go.asInterface(_m);
                                _indirect = _e._indirect;
                                continue;
                            };
                        };
                    };
                };
                {
                    final __type__ = _under(_typ);
                    if (Go.typeEquals((__type__ : Ref<Struct>))) {
                        var _t:Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                        for (_i => _f in _t._fields) {
                            if (_f._sameId(_pkg, _name)) {
                                _assert(_f._object._typ != null);
                                _index = _concat(_e._index, _i);
                                if ((_obj != null) || _e._multiples) {
                                    return { _0 : (null : stdgo.go.types.Types.Object), _1 : _index, _2 : false };
                                };
                                _obj = Go.asInterface(_f);
                                _indirect = _e._indirect;
                                continue;
                            };
                            if ((_obj == null) && _f._embedded) {
                                var __tmp__ = _deref(_f._object._typ), _typ:stdgo.go.types.Types.Type = __tmp__._0, _isPtr:Bool = __tmp__._1;
                                _next = (_next.__append__((new T_embeddedType(_typ, _concat(_e._index, _i), _e._indirect || _isPtr, _e._multiples) : T_embeddedType)));
                            };
                        };
                    } else if (Go.typeEquals((__type__ : Ref<Interface>))) {
                        var _t:Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                        {
                            var __tmp__ = _t._typeSet().lookupMethod(_pkg, _name, _foldCase), _i:GoInt = __tmp__._0, _m:Ref<stdgo.go.types.Types.Func> = __tmp__._1;
                            if (_m != null && ((_m : Dynamic).__nil__ == null || !(_m : Dynamic).__nil__)) {
                                _assert(_m._object._typ != null);
                                _index = _concat(_e._index, _i);
                                if ((_obj != null) || _e._multiples) {
                                    return { _0 : (null : stdgo.go.types.Types.Object), _1 : _index, _2 : false };
                                };
                                _obj = Go.asInterface(_m);
                                _indirect = _e._indirect;
                            };
                        };
                    };
                };
            };
            if (_obj != null) {
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_obj) : Ref<Func>)) : Ref<Func>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Func>), ok : false };
                    }, _f = __tmp__.value, __3 = __tmp__.ok;
                    if (_f != null && ((_f : Dynamic).__nil__ == null || !(_f : Dynamic).__nil__)) {
                        if ((_f._hasPtrRecv() && !_indirect) && !_addressable) {
                            return { _0 : (null : stdgo.go.types.Types.Object), _1 : (null : Slice<GoInt>), _2 : true };
                        };
                    };
                };
                return { _0 : _obj, _1 : _index, _2 : _indirect };
            };
            _current = _consolidateMultiples(_next);
        };
        return { _0 : (null : stdgo.go.types.Types.Object), _1 : (null : Slice<GoInt>), _2 : false };
    }
/**
    // consolidateMultiples collects multiple list entries with the same type
    // into a single entry marked as containing multiples. The result is the
    // consolidated list.
**/
private function _consolidateMultiples(_list:Slice<T_embeddedType>):Slice<T_embeddedType> {
        if ((_list.length) <= (1 : GoInt)) {
            return _list;
        };
        var _n:GoInt = (0 : GoInt);
        var _prev = ({
            final x = new GoObjectMap<stdgo.go.types.Types.Type, GoInt>();
            x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Type", [], stdgo.internal.reflect.Reflect.GoType.named("Type", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
            x.__defaultValue__ = () -> (0 : GoInt);
            @:mergeBlock {};
            cast x;
        } : GoMap<stdgo.go.types.Types.Type, GoInt>);
        for (__0 => _e in _list) {
            {
                var __tmp__ = _lookupType(_prev, _e._typ), _i:GoInt = __tmp__._0, _found:Bool = __tmp__._1;
                if (_found) {
                    _list[(_i : GoInt)]._multiples = true;
                } else {
                    _prev[_e._typ] = _n;
                    _list[(_n : GoInt)] = _e?.__copy__();
                    _n++;
                };
            };
        };
        return (_list.__slice__(0, _n) : Slice<stdgo.go.types.Types.T_embeddedType>);
    }
private function _lookupType(_m:GoMap<Type, GoInt>, _typ:Type):{ var _0 : GoInt; var _1 : Bool; } {
        {
            var __tmp__ = (_m != null && _m.exists(_typ) ? { value : _m[_typ], ok : true } : { value : (0 : GoInt), ok : false }), _i:GoInt = __tmp__.value, _found:Bool = __tmp__.ok;
            if (_found) {
                return { _0 : _i, _1 : true };
            };
        };
        for (_t => _i in _m) {
            if (identical(_t, _typ)) {
                return { _0 : _i, _1 : true };
            };
        };
        return { _0 : (0 : GoInt), _1 : false };
    }
/**
    // MissingMethod returns (nil, false) if V implements T, otherwise it
    // returns a missing method required by T and whether it is missing or
    // just has the wrong type.
    //
    // For non-interface types V, or if static is set, V implements T if all
    // methods of T are present in V. Otherwise (V is an interface and static
    // is not set), MissingMethod only checks that methods of T which are also
    // present in V have matching types (e.g., for a type assertion x.(T) where
    // x is of interface type V).
**/
function missingMethod(v:Type, t:Ref<Interface>, _static:Bool):{ var _0 : Ref<Func>; var _1 : Bool; } {
        var _method:Ref<Func> = (null : Ref<stdgo.go.types.Types.Func>), _wrongType:Bool = false;
        var __tmp__ = ((null : Ref<stdgo.go.types.Types.Checker>) : Ref<Checker>)._missingMethod(v, t, _static), _m:Ref<stdgo.go.types.Types.Func> = __tmp__._0, _alt:Ref<stdgo.go.types.Types.Func> = __tmp__._1;
        return { _0 : _m, _1 : ((_alt != null) && ((_alt : Dynamic).__nil__ == null || !(_alt : Dynamic).__nil__)) && (_alt._object._name == _m._object._name) };
    }
private function _isInterfacePtr(t:Type):Bool {
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(_under(t)) : Ref<Pointer_>)) : Ref<Pointer_>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.Pointer_>), ok : false };
        }, _p = __tmp__.value, __0 = __tmp__.ok;
        return ((_p != null) && ((_p : Dynamic).__nil__ == null || !(_p : Dynamic).__nil__)) && isInterface(_p._base);
    }
/**
    // deref dereferences typ if it is a *Pointer and returns its base and true.
    // Otherwise it returns (typ, false).
**/
private function _deref(_typ:Type):{ var _0 : Type; var _1 : Bool; } {
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_typ) : Ref<Pointer_>)) : Ref<Pointer_>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Pointer_>), ok : false };
            }, _p = __tmp__.value, __0 = __tmp__.ok;
            if (_p != null && ((_p : Dynamic).__nil__ == null || !(_p : Dynamic).__nil__)) {
                if (_p._base == null) {
                    if (false) {
                        throw Go.toInterface(("pointer with nil base type (possibly due to an invalid cyclic declaration)" : GoString));
                    };
                    return { _0 : Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]), _1 : true };
                };
                return { _0 : _p._base, _1 : true };
            };
        };
        return { _0 : _typ, _1 : false };
    }
/**
    // derefStructPtr dereferences typ if it is a (named or unnamed) pointer to a
    // (named or unnamed) struct and returns its base. Otherwise it returns typ.
**/
private function _derefStructPtr(_typ:Type):Type {
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Pointer_>)) : Ref<Pointer_>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Pointer_>), ok : false };
            }, _p = __tmp__.value, __0 = __tmp__.ok;
            if (_p != null && ((_p : Dynamic).__nil__ == null || !(_p : Dynamic).__nil__)) {
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_under(_p._base)) : Ref<Struct>)) : Ref<Struct>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Struct>), ok : false };
                    }, __1 = __tmp__.value, _ok = __tmp__.ok;
                    if (_ok) {
                        return _p._base;
                    };
                };
            };
        };
        return _typ;
    }
/**
    // concat returns the result of concatenating list and i.
    // The result does not share its underlying array with list.
**/
private function _concat(_list:Slice<GoInt>, _i:GoInt):Slice<GoInt> {
        var _t:Slice<GoInt> = (null : Slice<GoInt>);
        _t = (_t.__append__(..._list.__toArray__()));
        return (_t.__append__(_i));
    }
/**
    // fieldIndex returns the index for the field with matching package and name, or a value < 0.
**/
private function _fieldIndex(_fields:Slice<Ref<Var>>, _pkg:Ref<Package>, _name:GoString):GoInt {
        if (_name != (("_" : GoString))) {
            for (_i => _f in _fields) {
                if (_f._sameId(_pkg, _name)) {
                    return _i;
                };
            };
        };
        return (-1 : GoInt);
    }
/**
    // lookupMethod returns the index of and method with matching package and name, or (-1, nil).
    // If foldCase is true, method names are considered equal if they are equal with case folding.
**/
private function _lookupMethod(_methods:Slice<Ref<Func>>, _pkg:Ref<Package>, _name:GoString, _foldCase:Bool):{ var _0 : GoInt; var _1 : Ref<Func>; } {
        if (_name != (("_" : GoString))) {
            for (_i => _m in _methods) {
                if (((_m._object._name == _name) || (_foldCase && stdgo.strings.Strings.equalFold(_m._object._name, _name))) && _m._sameId(_pkg, _m._object._name)) {
                    return { _0 : _i, _1 : _m };
                };
            };
        };
        return { _0 : (-1 : GoInt), _1 : null };
    }
/**
    // NewMap returns a new map for the given key and element types.
**/
function newMap(_key:Type, _elem:Type):Ref<Map_> {
        return (Go.setRef(({ _key : _key, _elem : _elem } : Map_)) : Ref<stdgo.go.types.Types.Map_>);
    }
/**
    // NewMethodSet returns the method set for the given type T.
    // It always returns a non-nil method set, even if it is empty.
**/
function newMethodSet(t:Type):Ref<MethodSet> {
        var _base:T_methodSet = (null : stdgo.go.types.Types.T_methodSet);
        var __tmp__ = _deref(t), _typ:stdgo.go.types.Types.Type = __tmp__._0, _isPtr:Bool = __tmp__._1;
        if (_isPtr && isInterface(_typ)) {
            return (Go.setRef(_emptyMethodSet) : Ref<stdgo.go.types.Types.MethodSet>);
        };
        var _current = (new Slice<stdgo.go.types.Types.T_embeddedType>(1, 1, (new stdgo.go.types.Types.T_embeddedType(_typ, (null : Slice<GoInt>), _isPtr, false) : stdgo.go.types.Types.T_embeddedType)) : Slice<stdgo.go.types.Types.T_embeddedType>);
        var _seen:T_instanceLookup = ({} : stdgo.go.types.Types.T_instanceLookup);
        while ((_current.length) > (0 : GoInt)) {
            var _next:Slice<T_embeddedType> = (null : Slice<stdgo.go.types.Types.T_embeddedType>);
            var _fset:GoMap<GoString, Bool> = (null : GoMap<GoString, Bool>);
            var _mset:T_methodSet = (null : stdgo.go.types.Types.T_methodSet);
            for (__0 => _e in _current) {
                var _typ:stdgo.go.types.Types.Type = _e._typ;
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_typ) : Ref<Named>)) : Ref<Named>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
                    }, _named = __tmp__.value, __1 = __tmp__.ok;
                    if (_named != null && ((_named : Dynamic).__nil__ == null || !(_named : Dynamic).__nil__)) {
                        {
                            var _alt = _seen._lookup(_named);
                            if (_alt != null && ((_alt : Dynamic).__nil__ == null || !(_alt : Dynamic).__nil__)) {
                                continue;
                            };
                        };
                        _seen._add(_named);
                        {
                            var _i:GoInt = (0 : GoInt);
                            Go.cfor(_i < _named.numMethods(), _i++, {
                                _mset = _mset._addOne(_named.method(_i), _concat(_e._index, _i), _e._indirect, _e._multiples);
                            });
                        };
                    };
                };
                {
                    final __type__ = _under(_typ);
                    if (Go.typeEquals((__type__ : Ref<Struct>))) {
                        var _t:Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                        for (_i => _f in _t._fields) {
                            if (_fset == null) {
                                _fset = ({
                                    final x = new stdgo.GoMap.GoStringMap<Bool>();
                                    x.__defaultValue__ = () -> false;
                                    @:mergeBlock {};
                                    x;
                                } : GoMap<GoString, Bool>);
                            };
                            _fset[_f.id()] = true;
                            if (_f._embedded) {
                                var __tmp__ = _deref(_f._object._typ), _typ:stdgo.go.types.Types.Type = __tmp__._0, _isPtr:Bool = __tmp__._1;
                                _next = (_next.__append__((new T_embeddedType(_typ, _concat(_e._index, _i), _e._indirect || _isPtr, _e._multiples) : T_embeddedType)));
                            };
                        };
                    } else if (Go.typeEquals((__type__ : Ref<Interface>))) {
                        var _t:Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                        _mset = _mset._add(_t._typeSet()._methods, _e._index, true, _e._multiples);
                    };
                };
            };
            for (_k => _m in _mset) {
                {
                    var __tmp__ = (_base != null && _base.exists(_k) ? { value : _base[_k], ok : true } : { value : (null : Ref<stdgo.go.types.Types.Selection>), ok : false }), __2:Ref<stdgo.go.types.Types.Selection> = __tmp__.value, _found:Bool = __tmp__.ok;
                    if (!_found) {
                        if (_fset[_k]) {
                            _m = null;
                        };
                        if (_base == null) {
                            _base = ({
                                final x = new stdgo.GoMap.GoStringMap<Ref<stdgo.go.types.Types.Selection>>();
                                x.__defaultValue__ = () -> (null : Ref<stdgo.go.types.Types.Selection>);
                                @:mergeBlock {};
                                x;
                            } : GoMap<GoString, Ref<stdgo.go.types.Types.Selection>>);
                        };
                        _base[_k] = _m;
                    };
                };
            };
            for (_k => _ in _fset) {
                {
                    var __tmp__ = (_base != null && _base.exists(_k) ? { value : _base[_k], ok : true } : { value : (null : Ref<stdgo.go.types.Types.Selection>), ok : false }), __3:Ref<stdgo.go.types.Types.Selection> = __tmp__.value, _found:Bool = __tmp__.ok;
                    if (!_found) {
                        if (_base == null) {
                            _base = ({
                                final x = new stdgo.GoMap.GoStringMap<Ref<stdgo.go.types.Types.Selection>>();
                                x.__defaultValue__ = () -> (null : Ref<stdgo.go.types.Types.Selection>);
                                @:mergeBlock {};
                                x;
                            } : GoMap<GoString, Ref<stdgo.go.types.Types.Selection>>);
                        };
                        _base[_k] = null;
                    };
                };
            };
            _current = _consolidateMultiples(_next);
        };
        if ((_base.length) == ((0 : GoInt))) {
            return (Go.setRef(_emptyMethodSet) : Ref<stdgo.go.types.Types.MethodSet>);
        };
        var _list:Slice<Ref<Selection>> = (null : Slice<Ref<stdgo.go.types.Types.Selection>>);
        for (__4 => _m in _base) {
            if (_m != null && ((_m : Dynamic).__nil__ == null || !(_m : Dynamic).__nil__)) {
                _m._recv = t;
                _list = (_list.__append__(_m));
            };
        };
        stdgo.sort.Sort.slice(Go.toInterface(_list), function(_i:GoInt, _j:GoInt):Bool {
            return _list[(_i : GoInt)]._obj.id() < _list[(_j : GoInt)]._obj.id();
        });
        return (Go.setRef((new MethodSet(_list) : MethodSet)) : Ref<stdgo.go.types.Types.MethodSet>);
    }
/**
    // NewNamed returns a new named type for the given type name, underlying type, and associated methods.
    // If the given type name obj doesn't have a type yet, its type is set to the returned named type.
    // The underlying type must not be a *Named.
**/
function newNamed(_obj:Ref<TypeName>, _underlying:Type, _methods:Slice<Ref<Func>>):Ref<Named> {
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_underlying) : Ref<Named>)) : Ref<Named>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
            }, __0 = __tmp__.value, _ok = __tmp__.ok;
            if (_ok) {
                throw Go.toInterface(("underlying type must not be *Named" : GoString));
            };
        };
        return ((null : Ref<stdgo.go.types.Types.Checker>) : Ref<Checker>)._newNamed(_obj, _underlying, _methods);
    }
/**
    // safeUnderlying returns the underlying type of typ without expanding
    // instances, to avoid infinite recursion.
    //
    // TODO(rfindley): eliminate this function or give it a better name.
**/
private function _safeUnderlying(_typ:Type):Type {
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_typ) : Ref<Named>)) : Ref<Named>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
            }, _t = __tmp__.value, __0 = __tmp__.ok;
            if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                return _t._underlying;
            };
        };
        return _typ.underlying();
    }
/**
    // Id returns name if it is exported, otherwise it
    // returns the name qualified with the package path.
**/
function id(_pkg:Ref<Package>, _name:GoString):GoString {
        if (stdgo.go.token.Token.isExported(_name)) {
            return _name;
        };
        var _path:GoString = ("_" : GoString);
        if (((_pkg != null) && ((_pkg : Dynamic).__nil__ == null || !(_pkg : Dynamic).__nil__)) && (_pkg._path != Go.str())) {
            _path = _pkg._path;
        };
        return (_path + ("." : GoString)) + _name;
    }
/**
    // colorFor returns the (initial) color for an object depending on
    // whether its type t is known or not.
**/
private function _colorFor(_t:Type):T_color {
        if (_t != null) {
            return (1u32 : stdgo.go.types.Types.T_color);
        };
        return (0u32 : stdgo.go.types.Types.T_color);
    }
/**
    // NewPkgName returns a new PkgName object representing an imported package.
    // The remaining arguments set the attributes found with all Objects.
**/
function newPkgName(_pos:stdgo.go.token.Token.Pos, _pkg:Ref<Package>, _name:GoString, _imported:Ref<Package>):Ref<PkgName> {
        return (Go.setRef((new PkgName((new T_object(null, _pos, _pkg, _name, Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]), (0u32 : GoUInt32), (1u32 : stdgo.go.types.Types.T_color), (0 : stdgo.go.token.Token.Pos)) : T_object), _imported, false) : PkgName)) : Ref<stdgo.go.types.Types.PkgName>);
    }
/**
    // NewConst returns a new constant with value val.
    // The remaining arguments set the attributes found with all Objects.
**/
function newConst(_pos:stdgo.go.token.Token.Pos, _pkg:Ref<Package>, _name:GoString, _typ:Type, _val:stdgo.go.constant.Constant.Value):Ref<Const> {
        return (Go.setRef((new Const((new T_object(null, _pos, _pkg, _name, _typ, (0u32 : GoUInt32), _colorFor(_typ), (0 : stdgo.go.token.Token.Pos)) : T_object), _val) : Const)) : Ref<stdgo.go.types.Types.Const>);
    }
/**
    // NewTypeName returns a new type name denoting the given typ.
    // The remaining arguments set the attributes found with all Objects.
    //
    // The typ argument may be a defined (Named) type or an alias type.
    // It may also be nil such that the returned TypeName can be used as
    // argument for NewNamed, which will set the TypeName's type as a side-
    // effect.
**/
function newTypeName(_pos:stdgo.go.token.Token.Pos, _pkg:Ref<Package>, _name:GoString, _typ:Type):Ref<TypeName> {
        return (Go.setRef((new TypeName((new T_object(null, _pos, _pkg, _name, _typ, (0u32 : GoUInt32), _colorFor(_typ), (0 : stdgo.go.token.Token.Pos)) : T_object)) : TypeName)) : Ref<stdgo.go.types.Types.TypeName>);
    }
/**
    // _NewTypeNameLazy returns a new defined type like NewTypeName, but it
    // lazily calls resolve to finish constructing the Named object.
**/
private function __NewTypeNameLazy(_pos:stdgo.go.token.Token.Pos, _pkg:Ref<Package>, _name:GoString, _load:(_named:Ref<Named>) -> { var _0 : Slice<Ref<TypeParam>>; var _1 : Type; var _2 : Slice<Ref<Func>>; }):Ref<TypeName> {
        var _obj = newTypeName(_pos, _pkg, _name, (null : stdgo.go.types.Types.Type));
        newNamed(_obj, (null : stdgo.go.types.Types.Type), (null : Slice<Ref<stdgo.go.types.Types.Func>>))._loader = _load;
        return _obj;
    }
/**
    // NewVar returns a new variable.
    // The arguments set the attributes found with all Objects.
**/
function newVar(_pos:stdgo.go.token.Token.Pos, _pkg:Ref<Package>, _name:GoString, _typ:Type):Ref<Var> {
        return (Go.setRef(({ _object : (new T_object(null, _pos, _pkg, _name, _typ, (0u32 : GoUInt32), _colorFor(_typ), (0 : stdgo.go.token.Token.Pos)) : T_object) } : Var)) : Ref<stdgo.go.types.Types.Var>);
    }
/**
    // NewParam returns a new variable representing a function parameter.
**/
function newParam(_pos:stdgo.go.token.Token.Pos, _pkg:Ref<Package>, _name:GoString, _typ:Type):Ref<Var> {
        return (Go.setRef(({ _object : (new T_object(null, _pos, _pkg, _name, _typ, (0u32 : GoUInt32), _colorFor(_typ), (0 : stdgo.go.token.Token.Pos)) : T_object), _used : true } : Var)) : Ref<stdgo.go.types.Types.Var>);
    }
/**
    // NewField returns a new variable representing a struct field.
    // For embedded fields, the name is the unqualified type name
    // under which the field is accessible.
**/
function newField(_pos:stdgo.go.token.Token.Pos, _pkg:Ref<Package>, _name:GoString, _typ:Type, _embedded:Bool):Ref<Var> {
        return (Go.setRef(({ _object : (new T_object(null, _pos, _pkg, _name, _typ, (0u32 : GoUInt32), _colorFor(_typ), (0 : stdgo.go.token.Token.Pos)) : T_object), _embedded : _embedded, _isField : true } : Var)) : Ref<stdgo.go.types.Types.Var>);
    }
/**
    // NewFunc returns a new function with the given signature, representing
    // the function's type.
**/
function newFunc(_pos:stdgo.go.token.Token.Pos, _pkg:Ref<Package>, _name:GoString, _sig:Ref<Signature>):Ref<Func> {
        var _typ:Type = (null : stdgo.go.types.Types.Type);
        if (_sig != null && ((_sig : Dynamic).__nil__ == null || !(_sig : Dynamic).__nil__)) {
            _typ = Go.asInterface(_sig);
        };
        return (Go.setRef((new Func((new T_object(null, _pos, _pkg, _name, _typ, (0u32 : GoUInt32), _colorFor(_typ), (0 : stdgo.go.token.Token.Pos)) : T_object), false, null) : Func)) : Ref<stdgo.go.types.Types.Func>);
    }
/**
    // NewLabel returns a new label.
**/
function newLabel(_pos:stdgo.go.token.Token.Pos, _pkg:Ref<Package>, _name:GoString):Ref<Label> {
        return (Go.setRef((new Label(({ _pos : _pos, _pkg : _pkg, _name : _name, _typ : Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]), _color_ : (1u32 : stdgo.go.types.Types.T_color) } : T_object), false) : Label)) : Ref<stdgo.go.types.Types.Label>);
    }
private function _newBuiltin(_id:T_builtinId):Ref<Builtin> {
        return (Go.setRef((new Builtin(({ _name : _predeclaredFuncs[(_id : GoInt)]._name, _typ : Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]), _color_ : (1u32 : stdgo.go.types.Types.T_color) } : T_object), _id) : Builtin)) : Ref<stdgo.go.types.Types.Builtin>);
    }
private function _writeObject(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _obj:Object, _qf:Qualifier):Void {
        var _tname:Ref<TypeName> = (null : Ref<stdgo.go.types.Types.TypeName>);
        var _typ:stdgo.go.types.Types.Type = _obj.type();
        {
            final __type__ = _obj;
            if (Go.typeEquals((__type__ : Ref<PkgName>))) {
                var _obj:Ref<stdgo.go.types.Types.PkgName> = __type__ == null ? (null : Ref<stdgo.go.types.Types.PkgName>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.PkgName>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.PkgName>) : __type__.__underlying__().value;
                stdgo.fmt.Fmt.fprintf(Go.asInterface(_buf), ("package %s" : GoString), Go.toInterface(_obj.name()));
                {
                    var _path:GoString = _obj._imported._path;
                    if ((_path != Go.str()) && (_path != _obj._object._name)) {
                        stdgo.fmt.Fmt.fprintf(Go.asInterface(_buf), (" (%q)" : GoString), Go.toInterface(_path));
                    };
                };
                return;
            } else if (Go.typeEquals((__type__ : Ref<Const>))) {
                var _obj:Ref<stdgo.go.types.Types.Const> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Const>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Const>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Const>) : __type__.__underlying__().value;
                _buf.writeString(("const" : GoString));
            } else if (Go.typeEquals((__type__ : Ref<TypeName>))) {
                var _obj:Ref<stdgo.go.types.Types.TypeName> = __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.TypeName>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__().value;
                _tname = _obj;
                _buf.writeString(("type" : GoString));
                if (_isTypeParam(_typ)) {
                    _buf.writeString((" parameter" : GoString));
                };
            } else if (Go.typeEquals((__type__ : Ref<Var>))) {
                var _obj:Ref<stdgo.go.types.Types.Var> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Var>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__().value;
                if (_obj._isField) {
                    _buf.writeString(("field" : GoString));
                } else {
                    _buf.writeString(("var" : GoString));
                };
            } else if (Go.typeEquals((__type__ : Ref<Func>))) {
                var _obj:Ref<stdgo.go.types.Types.Func> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Func>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__().value;
                _buf.writeString(("func " : GoString));
                _writeFuncName(_buf, _obj, _qf);
                if (_typ != null) {
                    writeSignature(_buf, (Go.typeAssert((Go.toInterface(_typ) : Ref<Signature>)) : Ref<Signature>), _qf);
                };
                return;
            } else if (Go.typeEquals((__type__ : Ref<Label>))) {
                var _obj:Ref<stdgo.go.types.Types.Label> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Label>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Label>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Label>) : __type__.__underlying__().value;
                _buf.writeString(("label" : GoString));
                _typ = (null : stdgo.go.types.Types.Type);
            } else if (Go.typeEquals((__type__ : Ref<Builtin>))) {
                var _obj:Ref<stdgo.go.types.Types.Builtin> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Builtin>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Builtin>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Builtin>) : __type__.__underlying__().value;
                _buf.writeString(("builtin" : GoString));
                _typ = (null : stdgo.go.types.Types.Type);
            } else if (Go.typeEquals((__type__ : Ref<Nil>))) {
                var _obj:Ref<stdgo.go.types.Types.Nil> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Nil>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Nil>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Nil>) : __type__.__underlying__().value;
                _buf.writeString(("nil" : GoString));
                return;
            } else {
                var _obj:stdgo.go.types.Types.Object = __type__ == null ? (null : stdgo.go.types.Types.Object) : cast __type__;
                throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("writeObject(%T)" : GoString), Go.toInterface(_obj)));
            };
        };
        _buf.writeByte((32 : GoUInt8));
        if (((_obj.pkg() != null) && ((_obj.pkg() : Dynamic).__nil__ == null || !(_obj.pkg() : Dynamic).__nil__)) && (Go.toInterface(_obj.pkg()._scope.lookup(_obj.name())) == Go.toInterface(_obj))) {
            _buf.writeString(_packagePrefix(_obj.pkg(), _qf));
        };
        _buf.writeString(_obj.name());
        if (_typ == null) {
            return;
        };
        if (_tname != null && ((_tname : Dynamic).__nil__ == null || !(_tname : Dynamic).__nil__)) {
            {
                final __type__ = _typ;
                if (Go.typeEquals((__type__ : Ref<Basic>))) {
                    var _t:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                    return;
                } else if (Go.typeEquals((__type__ : Ref<Named>))) {
                    var _t:Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                    if (_t.typeParams().len() > (0 : GoInt)) {
                        _newTypeWriter(_buf, _qf)._tParamList(_t.typeParams()._list());
                    };
                };
            };
            if (_tname.isAlias()) {
                _buf.writeString((" =" : GoString));
            } else {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_typ) : Ref<TypeParam>)) : Ref<TypeParam>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.TypeParam>), ok : false };
                }, _t = __tmp__.value, __0 = __tmp__.ok;
                if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                    _typ = _t._bound;
                } else {
                    _typ = _under(_typ);
                };
            };
        };
        if (Go.toInterface(_obj) == (Go.toInterface(_universeAny))) {
            _assert(identical(_typ, Go.asInterface((Go.setRef(_emptyInterface) : Ref<stdgo.go.types.Types.Interface>))));
            _typ = Go.asInterface((Go.setRef(_emptyInterface) : Ref<stdgo.go.types.Types.Interface>));
        };
        _buf.writeByte((32 : GoUInt8));
        writeType(_buf, _typ, _qf);
    }
private function _packagePrefix(_pkg:Ref<Package>, _qf:Qualifier):GoString {
        if (_pkg == null || (_pkg : Dynamic).__nil__) {
            return Go.str();
        };
        var _s:GoString = ("" : GoString);
        if (_qf != null) {
            _s = _qf(_pkg);
        } else {
            _s = _pkg.path();
        };
        if (_s != (Go.str())) {
            _s = _s + (("." : GoString));
        };
        return _s;
    }
/**
    // ObjectString returns the string form of obj.
    // The Qualifier controls the printing of
    // package-level objects, and may be nil.
**/
function objectString(_obj:Object, _qf:Qualifier):GoString {
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        _writeObject((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>), _obj, _qf);
        return (_buf.string() : GoString);
    }
private function _writeFuncName(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _f:Ref<Func>, _qf:Qualifier):Void {
        if (_f._object._typ != null) {
            var _sig = (Go.typeAssert((Go.toInterface(_f._object._typ) : Ref<Signature>)) : Ref<Signature>);
            {
                var _recv = _sig.recv();
                if (_recv != null && ((_recv : Dynamic).__nil__ == null || !(_recv : Dynamic).__nil__)) {
                    _buf.writeByte((40 : GoUInt8));
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_recv.type()) : Ref<Interface>)) : Ref<Interface>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.types.Types.Interface>), ok : false };
                        }, __0 = __tmp__.value, _ok = __tmp__.ok;
                        if (_ok) {
                            _buf.writeString(("interface" : GoString));
                        } else {
                            writeType(_buf, _recv.type(), _qf);
                        };
                    };
                    _buf.writeByte((41 : GoUInt8));
                    _buf.writeByte((46 : GoUInt8));
                } else if (_f._object._pkg != null && ((_f._object._pkg : Dynamic).__nil__ == null || !(_f._object._pkg : Dynamic).__nil__)) {
                    _buf.writeString(_packagePrefix(_f._object._pkg, _qf));
                };
            };
        };
        _buf.writeString(_f._object._name);
    }
/**
    // Operand string formats
    // (not all "untyped" cases can appear due to the type system,
    // but they fall out naturally here)
    //
    // mode       format
    //
    // invalid    <expr> (               <mode>                    )
    // novalue    <expr> (               <mode>                    )
    // builtin    <expr> (               <mode>                    )
    // typexpr    <expr> (               <mode>                    )
    //
    // constant   <expr> (<untyped kind> <mode>                    )
    // constant   <expr> (               <mode>       of type <typ>)
    // constant   <expr> (<untyped kind> <mode> <val>              )
    // constant   <expr> (               <mode> <val> of type <typ>)
    //
    // variable   <expr> (<untyped kind> <mode>                    )
    // variable   <expr> (               <mode>       of type <typ>)
    //
    // mapindex   <expr> (<untyped kind> <mode>                    )
    // mapindex   <expr> (               <mode>       of type <typ>)
    //
    // value      <expr> (<untyped kind> <mode>                    )
    // value      <expr> (               <mode>       of type <typ>)
    //
    // commaok    <expr> (<untyped kind> <mode>                    )
    // commaok    <expr> (               <mode>       of type <typ>)
    //
    // commaerr   <expr> (<untyped kind> <mode>                    )
    // commaerr   <expr> (               <mode>       of type <typ>)
    //
    // cgofunc    <expr> (<untyped kind> <mode>                    )
    // cgofunc    <expr> (               <mode>       of type <typ>)
**/
private function _operandString(_x:Ref<T_operand>, _qf:Qualifier):GoString {
        if ((_x._mode == (7 : stdgo.go.types.Types.T_operandMode)) && (Go.toInterface(_x._typ) == Go.toInterface(Go.asInterface(typ[((25 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
            return ("nil" : GoString);
        };
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        var _expr:GoString = ("" : GoString);
        if (_x._expr != null) {
            _expr = exprString(_x._expr);
        } else {
            {
                final __value__ = _x._mode;
                if (__value__ == ((2 : stdgo.go.types.Types.T_operandMode))) {
                    _expr = _predeclaredFuncs[(_x._id : GoInt)]._name;
                } else if (__value__ == ((3 : stdgo.go.types.Types.T_operandMode))) {
                    _expr = typeString(_x._typ, _qf);
                } else if (__value__ == ((4 : stdgo.go.types.Types.T_operandMode))) {
                    _expr = (_x._val.string() : GoString);
                };
            };
        };
        if (_expr != (Go.str())) {
            _buf.writeString(_expr);
            _buf.writeString((" (" : GoString));
        };
        var _hasType:Bool = false;
        {
            var __switchIndex__ = -1;
            var __run__ = true;
            while (__run__) {
                __run__ = false;
                {
                    final __value__ = _x._mode;
                    if (__value__ == ((0 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((1 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((2 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((3 : stdgo.go.types.Types.T_operandMode))) {
                        break;
                    } else {
                        if (_x._typ != null) {
                            if (_isUntyped(_x._typ)) {
                                _buf.writeString((Go.typeAssert((Go.toInterface(_x._typ) : Ref<Basic>)) : Ref<Basic>)._name);
                                _buf.writeByte((32 : GoUInt8));
                                break;
                            };
                            _hasType = true;
                        };
                    };
                };
                break;
            };
        };
        _buf.writeString(_operandModeString[(_x._mode : GoInt)]);
        if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
            {
                var _s:GoString = (_x._val.string() : GoString);
                if (_s != (_expr)) {
                    _buf.writeByte((32 : GoUInt8));
                    _buf.writeString(_s);
                };
            };
        };
        if (_hasType) {
            if (Go.toInterface(_x._typ) != (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                var _intro:GoString = ("" : GoString);
                if (_isGeneric(_x._typ)) {
                    _intro = (" of generic type " : GoString);
                } else {
                    _intro = (" of type " : GoString);
                };
                _buf.writeString(_intro);
                writeType((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>), _x._typ, _qf);
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_x._typ) : Ref<TypeParam>)) : Ref<TypeParam>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.TypeParam>), ok : false };
                    }, _tpar = __tmp__.value, __0 = __tmp__.ok;
                    if (_tpar != null && ((_tpar : Dynamic).__nil__ == null || !(_tpar : Dynamic).__nil__)) {
                        _buf.writeString((" constrained by " : GoString));
                        writeType((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>), _tpar._bound, _qf);
                        if (_hasEmptyTypeset(Go.asInterface(_tpar))) {
                            _buf.writeString((" with empty type set" : GoString));
                        };
                    };
                };
            } else {
                _buf.writeString((" with invalid type" : GoString));
            };
        };
        if (_expr != (Go.str())) {
            _buf.writeByte((41 : GoUInt8));
        };
        return (_buf.string() : GoString);
    }
/**
    // NewPackage returns a new Package for the given package path and name.
    // The package is not complete and contains no explicit imports.
**/
function newPackage(_path:GoString, _name:GoString):Ref<Package> {
        var _scope = newScope(universe, (0 : stdgo.go.token.Token.Pos), (0 : stdgo.go.token.Token.Pos), stdgo.fmt.Fmt.sprintf(("package %q" : GoString), Go.toInterface(_path)));
        return (Go.setRef(({ _path : _path, _name : _name, _scope : _scope } : Package)) : Ref<stdgo.go.types.Types.Package>);
    }
/**
    // NewPointer returns a new pointer type for the given element (base) type.
**/
function newPointer(_elem:Type):Ref<Pointer_> {
        return (Go.setRef(({ _base : _elem } : Pointer_)) : Ref<stdgo.go.types.Types.Pointer_>);
    }
private function _isBoolean(_t:Type):Bool {
        return _isBasic(_t, (1 : stdgo.go.types.Types.BasicInfo));
    }
private function _isInteger(_t:Type):Bool {
        return _isBasic(_t, (2 : stdgo.go.types.Types.BasicInfo));
    }
private function _isUnsigned(_t:Type):Bool {
        return _isBasic(_t, (4 : stdgo.go.types.Types.BasicInfo));
    }
private function _isFloat(_t:Type):Bool {
        return _isBasic(_t, (8 : stdgo.go.types.Types.BasicInfo));
    }
private function _isComplex(_t:Type):Bool {
        return _isBasic(_t, (16 : stdgo.go.types.Types.BasicInfo));
    }
private function _isNumeric(_t:Type):Bool {
        return _isBasic(_t, (26 : stdgo.go.types.Types.BasicInfo));
    }
private function _isString(_t:Type):Bool {
        return _isBasic(_t, (32 : stdgo.go.types.Types.BasicInfo));
    }
private function _isIntegerOrFloat(_t:Type):Bool {
        return _isBasic(_t, (10 : stdgo.go.types.Types.BasicInfo));
    }
private function _isConstType(_t:Type):Bool {
        return _isBasic(_t, (59 : stdgo.go.types.Types.BasicInfo));
    }
/**
    // isBasic reports whether under(t) is a basic type with the specified info.
    // If t is a type parameter the result is false; i.e.,
    // isBasic does not look inside a type parameter.
**/
private function _isBasic(_t:Type, _info:BasicInfo):Bool {
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(_under(_t)) : Ref<Basic>)) : Ref<Basic>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.Basic>), ok : false };
        }, _u = __tmp__.value, __0 = __tmp__.ok;
        return ((_u != null) && ((_u : Dynamic).__nil__ == null || !(_u : Dynamic).__nil__)) && ((_u._info & _info) != (0 : stdgo.go.types.Types.BasicInfo));
    }
private function _allBoolean(_typ:Type):Bool {
        return _allBasic(_typ, (1 : stdgo.go.types.Types.BasicInfo));
    }
private function _allInteger(_typ:Type):Bool {
        return _allBasic(_typ, (2 : stdgo.go.types.Types.BasicInfo));
    }
private function _allUnsigned(_typ:Type):Bool {
        return _allBasic(_typ, (4 : stdgo.go.types.Types.BasicInfo));
    }
private function _allNumeric(_typ:Type):Bool {
        return _allBasic(_typ, (26 : stdgo.go.types.Types.BasicInfo));
    }
private function _allString(_typ:Type):Bool {
        return _allBasic(_typ, (32 : stdgo.go.types.Types.BasicInfo));
    }
private function _allOrdered(_typ:Type):Bool {
        return _allBasic(_typ, (42 : stdgo.go.types.Types.BasicInfo));
    }
private function _allNumericOrString(_typ:Type):Bool {
        return _allBasic(_typ, (58 : stdgo.go.types.Types.BasicInfo));
    }
/**
    // allBasic reports whether under(t) is a basic type with the specified info.
    // If t is a type parameter, the result is true if isBasic(t, info) is true
    // for all specific types of the type parameter's type set.
    // allBasic(t, info) is an optimized version of isBasic(coreType(t), info).
**/
private function _allBasic(_t:Type, _info:BasicInfo):Bool {
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_t) : Ref<TypeParam>)) : Ref<TypeParam>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.TypeParam>), ok : false };
            }, _tpar = __tmp__.value, __0 = __tmp__.ok;
            if (_tpar != null && ((_tpar : Dynamic).__nil__ == null || !(_tpar : Dynamic).__nil__)) {
                return _tpar._is(function(_t:Ref<T_term>):Bool {
                    return ((_t != null) && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) && _isBasic(_t._typ, _info);
                });
            };
        };
        return _isBasic(_t, _info);
    }
/**
    // hasName reports whether t has a name. This includes
    // predeclared types, defined types, and type parameters.
    // hasName may be called with types that are not fully set up.
**/
private function _hasName(_t:Type):Bool {
        {
            final __type__ = _t;
            if (Go.typeEquals((__type__ : Ref<Basic>)) || Go.typeEquals((__type__ : Ref<Named>)) || Go.typeEquals((__type__ : Ref<TypeParam>))) {
                return true;
            };
        };
        return false;
    }
/**
    // isTyped reports whether t is typed; i.e., not an untyped
    // constant or boolean. isTyped may be called with types that
    // are not fully set up.
**/
private function _isTyped(_t:Type):Bool {
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(_t) : Ref<Basic>)) : Ref<Basic>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.Basic>), ok : false };
        }, _b = __tmp__.value, __0 = __tmp__.ok;
        return ((_b == null) || (_b : Dynamic).__nil__) || ((_b._info & (64 : stdgo.go.types.Types.BasicInfo)) == (0 : stdgo.go.types.Types.BasicInfo));
    }
/**
    // isUntyped(t) is the same as !isTyped(t).
**/
private function _isUntyped(_t:Type):Bool {
        return !_isTyped(_t);
    }
/**
    // IsInterface reports whether t is an interface type.
**/
function isInterface(_t:Type):Bool {
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(_under(_t)) : Ref<Interface>)) : Ref<Interface>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.Interface>), ok : false };
        }, __0 = __tmp__.value, _ok = __tmp__.ok;
        return _ok;
    }
/**
    // isNonTypeParamInterface reports whether t is an interface type but not a type parameter.
**/
private function _isNonTypeParamInterface(_t:Type):Bool {
        return !_isTypeParam(_t) && isInterface(_t);
    }
/**
    // isTypeParam reports whether t is a type parameter.
**/
private function _isTypeParam(_t:Type):Bool {
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(_t) : Ref<TypeParam>)) : Ref<TypeParam>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.TypeParam>), ok : false };
        }, __0 = __tmp__.value, _ok = __tmp__.ok;
        return _ok;
    }
/**
    // hasEmptyTypeset reports whether t is a type parameter with an empty type set.
    // The function does not force the computation of the type set and so is safe to
    // use anywhere, but it may report a false negative if the type set has not been
    // computed yet.
**/
private function _hasEmptyTypeset(_t:Type):Bool {
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_t) : Ref<TypeParam>)) : Ref<TypeParam>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.TypeParam>), ok : false };
            }, _tpar = __tmp__.value, __0 = __tmp__.ok;
            if (((_tpar != null) && ((_tpar : Dynamic).__nil__ == null || !(_tpar : Dynamic).__nil__)) && (_tpar._bound != null)) {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_safeUnderlying(_tpar._bound)) : Ref<Interface>)) : Ref<Interface>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.Interface>), ok : false };
                }, _iface = __tmp__.value, __17 = __tmp__.ok;
                return (((_iface != null) && ((_iface : Dynamic).__nil__ == null || !(_iface : Dynamic).__nil__)) && ((_iface._tset != null) && ((_iface._tset : Dynamic).__nil__ == null || !(_iface._tset : Dynamic).__nil__))) && _iface._tset.isEmpty();
            };
        };
        return false;
    }
/**
    // isGeneric reports whether a type is a generic, uninstantiated type
    // (generic signatures are not included).
    // TODO(gri) should we include signatures or assert that they are not present?
**/
private function _isGeneric(_t:Type):Bool {
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(_t) : Ref<Named>)) : Ref<Named>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
        }, _named = __tmp__.value, __0 = __tmp__.ok;
        return ((((_named != null) && ((_named : Dynamic).__nil__ == null || !(_named : Dynamic).__nil__)) && ((_named._obj != null) && ((_named._obj : Dynamic).__nil__ == null || !(_named._obj : Dynamic).__nil__))) && (_named._inst == null) || (_named._inst : Dynamic).__nil__) && (_named.typeParams().len() > (0 : GoInt));
    }
/**
    // Comparable reports whether values of type T are comparable.
**/
function comparable(t:Type):Bool {
        return _comparable(t, true, (null : GoMap<stdgo.go.types.Types.Type, Bool>), null);
    }
/**
    // If dynamic is set, non-type parameter interfaces are always comparable.
    // If reportf != nil, it may be used to report why T is not comparable.
**/
private function _comparable(t:Type, _dynamic:Bool, _seen:GoMap<Type, Bool>, _reportf:(GoString, haxe.Rest<AnyInterface>) -> Void):Bool {
        if (_seen[t]) {
            return true;
        };
        if (_seen == null) {
            _seen = ({
                final x = new GoObjectMap<stdgo.go.types.Types.Type, Bool>();
                x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Type", [], stdgo.internal.reflect.Reflect.GoType.named("Type", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
                x.__defaultValue__ = () -> false;
                @:mergeBlock {};
                cast x;
            } : GoMap<stdgo.go.types.Types.Type, Bool>);
        };
        _seen[t] = true;
        {
            final __type__ = _under(t);
            if (Go.typeEquals((__type__ : Ref<Basic>))) {
                var _t:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                return _t._kind != ((25 : stdgo.go.types.Types.BasicKind));
            } else if (Go.typeEquals((__type__ : Ref<Pointer_>)) || Go.typeEquals((__type__ : Ref<Chan>))) {
                var _t:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                return true;
            } else if (Go.typeEquals((__type__ : Ref<Struct>))) {
                var _t:Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                for (__0 => _f in _t._fields) {
                    if (!_comparable(_f._object._typ, _dynamic, _seen, null)) {
                        if (_reportf != null) {
                            _reportf(("struct containing %s cannot be compared" : GoString), Go.toInterface(_f._object._typ));
                        };
                        return false;
                    };
                };
                return true;
            } else if (Go.typeEquals((__type__ : Ref<Array_>))) {
                var _t:Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                if (!_comparable(_t._elem, _dynamic, _seen, null)) {
                    if (_reportf != null) {
                        _reportf(("%s cannot be compared" : GoString), Go.toInterface(Go.asInterface(_t)));
                    };
                    return false;
                };
                return true;
            } else if (Go.typeEquals((__type__ : Ref<Interface>))) {
                var _t:Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                if ((_dynamic && !_isTypeParam(t)) || _t._typeSet().isComparable(_seen)) {
                    return true;
                };
                if (_reportf != null) {
                    if (_t._typeSet().isEmpty()) {
                        _reportf(("empty type set" : GoString));
                    } else {
                        _reportf(("incomparable types in type set" : GoString));
                    };
                };
            };
        };
        return false;
    }
/**
    // hasNil reports whether type t includes the nil value.
**/
private function _hasNil(_t:Type):Bool {
        {
            final __type__ = _under(_t);
            if (Go.typeEquals((__type__ : Ref<Basic>))) {
                var _u:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                return _u._kind == ((18 : stdgo.go.types.Types.BasicKind));
            } else if (Go.typeEquals((__type__ : Ref<Slice_>)) || Go.typeEquals((__type__ : Ref<Pointer_>)) || Go.typeEquals((__type__ : Ref<Signature>)) || Go.typeEquals((__type__ : Ref<Map_>)) || Go.typeEquals((__type__ : Ref<Chan>))) {
                var _u:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                return true;
            } else if (Go.typeEquals((__type__ : Ref<Interface>))) {
                var _u:Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                return !_isTypeParam(_t) || _u._typeSet()._underIs(function(_u:Type):Bool {
                    return (_u != null) && _hasNil(_u);
                });
            };
        };
        return false;
    }
/**
    // For changes to this code the corresponding changes should be made to unifier.nify.
**/
private function _identical(_x:Type, _y:Type, _cmpTags:Bool, _p:Ref<T_ifacePair>):Bool {
        if (Go.toInterface(_x) == (Go.toInterface(_y))) {
            return true;
        };
        {
            final __type__ = _x;
            if (Go.typeEquals((__type__ : Ref<Basic>))) {
                var _x:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Basic>)) : Ref<Basic>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Basic>), ok : false };
                    }, _y = __tmp__.value, _ok = __tmp__.ok;
                    if (_ok) {
                        return _x._kind == (_y._kind);
                    };
                };
            } else if (Go.typeEquals((__type__ : Ref<Array_>))) {
                var _x:Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Array_>)) : Ref<Array_>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Array_>), ok : false };
                    }, _y = __tmp__.value, _ok = __tmp__.ok;
                    if (_ok) {
                        return (((_x._len < (0i64 : GoInt64)) || (_y._len < (0i64 : GoInt64))) || (_x._len == _y._len)) && _identical(_x._elem, _y._elem, _cmpTags, _p);
                    };
                };
            } else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
                var _x:Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Slice_>)) : Ref<Slice_>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Slice_>), ok : false };
                    }, _y = __tmp__.value, _ok = __tmp__.ok;
                    if (_ok) {
                        return _identical(_x._elem, _y._elem, _cmpTags, _p);
                    };
                };
            } else if (Go.typeEquals((__type__ : Ref<Struct>))) {
                var _x:Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Struct>)) : Ref<Struct>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Struct>), ok : false };
                    }, _y = __tmp__.value, _ok = __tmp__.ok;
                    if (_ok) {
                        if (_x.numFields() == (_y.numFields())) {
                            for (_i => _f in _x._fields) {
                                var _g = _y._fields[(_i : GoInt)];
                                if ((((_f._embedded != _g._embedded) || (_cmpTags && (_x.tag(_i) != _y.tag(_i)))) || !_f._sameId(_g._object._pkg, _g._object._name)) || !_identical(_f._object._typ, _g._object._typ, _cmpTags, _p)) {
                                    return false;
                                };
                            };
                            return true;
                        };
                    };
                };
            } else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
                var _x:Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Pointer_>)) : Ref<Pointer_>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Pointer_>), ok : false };
                    }, _y = __tmp__.value, _ok = __tmp__.ok;
                    if (_ok) {
                        return _identical(_x._base, _y._base, _cmpTags, _p);
                    };
                };
            } else if (Go.typeEquals((__type__ : Ref<Tuple>))) {
                var _x:Ref<stdgo.go.types.Types.Tuple> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Tuple>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Tuple>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Tuple>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Tuple>)) : Ref<Tuple>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Tuple>), ok : false };
                    }, _y = __tmp__.value, _ok = __tmp__.ok;
                    if (_ok) {
                        if (_x.len() == (_y.len())) {
                            if (_x != null && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) {
                                for (_i => _v in _x._vars) {
                                    var _w = _y._vars[(_i : GoInt)];
                                    if (!_identical(_v._object._typ, _w._object._typ, _cmpTags, _p)) {
                                        return false;
                                    };
                                };
                            };
                            return true;
                        };
                    };
                };
            } else if (Go.typeEquals((__type__ : Ref<Signature>))) {
                var _x:Ref<stdgo.go.types.Types.Signature> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__().value;
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Signature>)) : Ref<Signature>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.Signature>), ok : false };
                }, _y = __tmp__.value, __0 = __tmp__.ok;
                if (_y == null || (_y : Dynamic).__nil__) {
                    return false;
                };
                if (_x.typeParams().len() != (_y.typeParams().len())) {
                    return false;
                };
                var _yparams = _y._params;
                var _yresults = _y._results;
                if (_x.typeParams().len() > (0 : GoInt)) {
                    var _xtparams = _x.typeParams()._list();
                    var _ytparams = _y.typeParams()._list();
                    var _targs:Slice<Type> = (null : Slice<stdgo.go.types.Types.Type>);
                    for (_i in 0 ... _xtparams.length.toBasic()) {
                        _targs = (_targs.__append__(Go.asInterface(_x.typeParams().at(_i))));
                    };
                    var _smap:stdgo.go.types.Types.T_substMap = _makeSubstMap(_ytparams, _targs);
                    var _check:Ref<Checker> = (null : Ref<stdgo.go.types.Types.Checker>);
                    var _ctxt = newContext();
                    for (_i => _xtparam in _xtparams) {
                        var _ybound:stdgo.go.types.Types.Type = _check._subst((0 : stdgo.go.token.Token.Pos), _ytparams[(_i : GoInt)]._bound, _smap, null, _ctxt);
                        if (!_identical(_xtparam._bound, _ybound, _cmpTags, _p)) {
                            return false;
                        };
                    };
                    _yparams = (Go.typeAssert((Go.toInterface(_check._subst((0 : stdgo.go.token.Token.Pos), Go.asInterface(_y._params), _smap, null, _ctxt)) : Ref<Tuple>)) : Ref<Tuple>);
                    _yresults = (Go.typeAssert((Go.toInterface(_check._subst((0 : stdgo.go.token.Token.Pos), Go.asInterface(_y._results), _smap, null, _ctxt)) : Ref<Tuple>)) : Ref<Tuple>);
                };
                return ((_x._variadic == _y._variadic) && _identical(Go.asInterface(_x._params), Go.asInterface(_yparams), _cmpTags, _p)) && _identical(Go.asInterface(_x._results), Go.asInterface(_yresults), _cmpTags, _p);
            } else if (Go.typeEquals((__type__ : Ref<Union>))) {
                var _x:Ref<stdgo.go.types.Types.Union> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Union>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Union>)) : Ref<Union>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Union>), ok : false };
                    }, _y = __tmp__.value, __17 = __tmp__.ok;
                    if (_y != null && ((_y : Dynamic).__nil__ == null || !(_y : Dynamic).__nil__)) {
                        var _unionSets = ({
                            final x = new GoRefMap<Ref<stdgo.go.types.Types.Union>, Ref<stdgo.go.types.Types.T__TypeSet>>();
                            @:mergeBlock {};
                            cast x;
                        } : GoMap<Ref<stdgo.go.types.Types.Union>, Ref<stdgo.go.types.Types.T__TypeSet>>);
                        var _xset = _computeUnionTypeSet(null, _unionSets, (0 : stdgo.go.token.Token.Pos), _x);
                        var _yset = _computeUnionTypeSet(null, _unionSets, (0 : stdgo.go.token.Token.Pos), _y);
                        return _xset._terms._equal(_yset._terms);
                    };
                };
            } else if (Go.typeEquals((__type__ : Ref<Interface>))) {
                var _x:Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Interface>)) : Ref<Interface>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Interface>), ok : false };
                    }, _y = __tmp__.value, _ok = __tmp__.ok;
                    if (_ok) {
                        var _xset = _x._typeSet();
                        var _yset = _y._typeSet();
                        if (_xset._comparable != (_yset._comparable)) {
                            return false;
                        };
                        if (!_xset._terms._equal(_yset._terms)) {
                            return false;
                        };
                        var _a = _xset._methods;
                        var _b = _yset._methods;
                        if ((_a.length) == ((_b.length))) {
                            var _q = (Go.setRef((new T_ifacePair(_x, _y, _p) : T_ifacePair)) : Ref<stdgo.go.types.Types.T_ifacePair>);
                            while (_p != null && ((_p : Dynamic).__nil__ == null || !(_p : Dynamic).__nil__)) {
                                if (_p._identical(_q)) {
                                    return true;
                                };
                                _p = _p._prev;
                            };
                            if (false) {
                                _assertSortedMethods(_a);
                                _assertSortedMethods(_b);
                            };
                            for (_i => _f in _a) {
                                var _g = _b[(_i : GoInt)];
                                if ((_f.id() != _g.id()) || !_identical(_f._object._typ, _g._object._typ, _cmpTags, _q)) {
                                    return false;
                                };
                            };
                            return true;
                        };
                    };
                };
            } else if (Go.typeEquals((__type__ : Ref<Map_>))) {
                var _x:Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Map_>)) : Ref<Map_>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Map_>), ok : false };
                    }, _y = __tmp__.value, _ok = __tmp__.ok;
                    if (_ok) {
                        return _identical(_x._key, _y._key, _cmpTags, _p) && _identical(_x._elem, _y._elem, _cmpTags, _p);
                    };
                };
            } else if (Go.typeEquals((__type__ : Ref<Chan>))) {
                var _x:Ref<stdgo.go.types.Types.Chan> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Chan>)) : Ref<Chan>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Chan>), ok : false };
                    }, _y = __tmp__.value, _ok = __tmp__.ok;
                    if (_ok) {
                        return (_x._dir == _y._dir) && _identical(_x._elem, _y._elem, _cmpTags, _p);
                    };
                };
            } else if (Go.typeEquals((__type__ : Ref<Named>))) {
                var _x:Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Named>)) : Ref<Named>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
                    }, _y = __tmp__.value, _ok = __tmp__.ok;
                    if (_ok) {
                        var _xargs = _x.typeArgs()._list();
                        var _yargs = _y.typeArgs()._list();
                        if ((_xargs.length) != ((_yargs.length))) {
                            return false;
                        };
                        if ((_xargs.length) > (0 : GoInt)) {
                            if (!identical(Go.asInterface(_x.origin()), Go.asInterface(_y.origin()))) {
                                return false;
                            };
                            for (_i => _xa in _xargs) {
                                if (!identical(_xa, _yargs[(_i : GoInt)])) {
                                    return false;
                                };
                            };
                            return true;
                        };
                        return _x._obj == (_y._obj);
                    };
                };
            } else if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
                var _x:Ref<stdgo.go.types.Types.TypeParam> = __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__().value;
            } else if (__type__ == null) {
                var _x:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
            } else {
                var _x:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                _unreachable();
            };
        };
        return false;
    }
/**
    // identicalInstance reports if two type instantiations are identical.
    // Instantiations are identical if their origin and type arguments are
    // identical.
**/
private function _identicalInstance(_xorig:Type, _xargs:Slice<Type>, _yorig:Type, _yargs:Slice<Type>):Bool {
        if ((_xargs.length) != ((_yargs.length))) {
            return false;
        };
        for (_i => _xa in _xargs) {
            if (!identical(_xa, _yargs[(_i : GoInt)])) {
                return false;
            };
        };
        return identical(_xorig, _yorig);
    }
/**
    // Default returns the default "typed" type for an "untyped" type;
    // it returns the incoming type for all other types. The default type
    // for untyped nil is untyped nil.
**/
function default_(_t:Type):Type {
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_t) : Ref<Basic>)) : Ref<Basic>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Basic>), ok : false };
            }, _t = __tmp__.value, _ok = __tmp__.ok;
            if (_ok) {
                {
                    final __value__ = _t._kind;
                    if (__value__ == ((19 : stdgo.go.types.Types.BasicKind))) {
                        return Go.asInterface(typ[((1 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                    } else if (__value__ == ((20 : stdgo.go.types.Types.BasicKind))) {
                        return Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                    } else if (__value__ == ((21 : stdgo.go.types.Types.BasicKind))) {
                        return _universeRune;
                    } else if (__value__ == ((22 : stdgo.go.types.Types.BasicKind))) {
                        return Go.asInterface(typ[((14 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                    } else if (__value__ == ((23 : stdgo.go.types.Types.BasicKind))) {
                        return Go.asInterface(typ[((16 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                    } else if (__value__ == ((24 : stdgo.go.types.Types.BasicKind))) {
                        return Go.asInterface(typ[((17 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                    };
                };
            };
        };
        return _t;
    }
private function _validatedImportPath(_path:GoString):{ var _0 : GoString; var _1 : Error; } {
        var __tmp__ = stdgo.strconv.Strconv.unquote(_path), _s:GoString = __tmp__._0, _err:Error = __tmp__._1;
        if (_err != null) {
            return { _0 : Go.str(), _1 : _err };
        };
        if (_s == (Go.str())) {
            return { _0 : Go.str(), _1 : stdgo.fmt.Fmt.errorf(("empty string" : GoString)) };
        };
        {};
        for (__0 => _r in _s) {
            if ((!stdgo.unicode.Unicode.isGraphic(_r) || stdgo.unicode.Unicode.isSpace(_r)) || stdgo.strings.Strings.containsRune(("!\"#$$%&\'()*,:;<=>?[\\]^{|}`ÔøΩ" : GoString), _r)) {
                return { _0 : _s, _1 : stdgo.fmt.Fmt.errorf(("invalid character %#U" : GoString), Go.toInterface(_r)) };
            };
        };
        return { _0 : _s, _1 : (null : Error) };
    }
/**
    // dir makes a good-faith attempt to return the directory
    // portion of path. If path is empty, the result is ".".
    // (Per the go/build package dependency tests, we cannot import
    // path/filepath and simply use filepath.Dir.)
**/
private function _dir(_path:GoString):GoString {
        {
            var _i:GoInt = stdgo.strings.Strings.lastIndexAny(_path, ("/\\" : GoString));
            if (_i > (0 : GoInt)) {
                return (_path.__slice__(0, _i) : GoString);
            };
        };
        return ("." : GoString);
    }
/**
    // hasBreak reports if s is or contains a break statement
    // referring to the label-ed statement or implicit-ly the
    // closest outer breakable statement.
**/
private function _hasBreak(_s:stdgo.go.ast.Ast.Stmt, _label:GoString, _implicit:Bool):Bool {
        {
            final __type__ = _s;
            if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BadStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.DeclStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.EmptyStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ExprStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SendStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IncDecStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.AssignStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.GoStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.DeferStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ReturnStmt>))) {
                var _s:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.LabeledStmt>))) {
                var _s:Ref<stdgo.go.ast.Ast.LabeledStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__().value;
                return _hasBreak(_s.stmt, _label, _implicit);
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BranchStmt>))) {
                var _s:Ref<stdgo.go.ast.Ast.BranchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__().value;
                if (_s.tok == ((61 : stdgo.go.token.Token.Token))) {
                    if (_s.label == null || (_s.label : Dynamic).__nil__) {
                        return _implicit;
                    };
                    if (_s.label.name == (_label)) {
                        return true;
                    };
                };
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BlockStmt>))) {
                var _s:Ref<stdgo.go.ast.Ast.BlockStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__().value;
                return _hasBreakList(_s.list, _label, _implicit);
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IfStmt>))) {
                var _s:Ref<stdgo.go.ast.Ast.IfStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__().value;
                if (_hasBreak(Go.asInterface(_s.body), _label, _implicit) || ((_s.else_ != null) && _hasBreak(_s.else_, _label, _implicit))) {
                    return true;
                };
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CaseClause>))) {
                var _s:Ref<stdgo.go.ast.Ast.CaseClause> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CaseClause>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.CaseClause>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CaseClause>) : __type__.__underlying__().value;
                return _hasBreakList(_s.body, _label, _implicit);
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SwitchStmt>))) {
                var _s:Ref<stdgo.go.ast.Ast.SwitchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__().value;
                if ((_label != Go.str()) && _hasBreak(Go.asInterface(_s.body), _label, false)) {
                    return true;
                };
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>))) {
                var _s:Ref<stdgo.go.ast.Ast.TypeSwitchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__().value;
                if ((_label != Go.str()) && _hasBreak(Go.asInterface(_s.body), _label, false)) {
                    return true;
                };
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CommClause>))) {
                var _s:Ref<stdgo.go.ast.Ast.CommClause> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CommClause>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.CommClause>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CommClause>) : __type__.__underlying__().value;
                return _hasBreakList(_s.body, _label, _implicit);
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectStmt>))) {
                var _s:Ref<stdgo.go.ast.Ast.SelectStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__().value;
                if ((_label != Go.str()) && _hasBreak(Go.asInterface(_s.body), _label, false)) {
                    return true;
                };
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ForStmt>))) {
                var _s:Ref<stdgo.go.ast.Ast.ForStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__().value;
                if ((_label != Go.str()) && _hasBreak(Go.asInterface(_s.body), _label, false)) {
                    return true;
                };
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.RangeStmt>))) {
                var _s:Ref<stdgo.go.ast.Ast.RangeStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__.__underlying__().value;
                if ((_label != Go.str()) && _hasBreak(Go.asInterface(_s.body), _label, false)) {
                    return true;
                };
            } else {
                var _s:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
                _unreachable();
            };
        };
        return false;
    }
private function _hasBreakList(_list:Slice<stdgo.go.ast.Ast.Stmt>, _label:GoString, _implicit:Bool):Bool {
        for (__0 => _s in _list) {
            if (_hasBreak(_s, _label, _implicit)) {
                return true;
            };
        };
        return false;
    }
/**
    // NewScope returns a new, empty scope contained in the given parent
    // scope, if any. The comment is for debugging only.
**/
function newScope(_parent:Ref<Scope>, _pos:stdgo.go.token.Token.Pos, _end:stdgo.go.token.Token.Pos, _comment:GoString):Ref<Scope> {
        var _s = (Go.setRef((new Scope(_parent, (null : Slice<Ref<stdgo.go.types.Types.Scope>>), (0 : GoInt), (null : GoMap<GoString, stdgo.go.types.Types.Object>), _pos, _end, _comment, false) : Scope)) : Ref<stdgo.go.types.Types.Scope>);
        if (((_parent != null) && ((_parent : Dynamic).__nil__ == null || !(_parent : Dynamic).__nil__)) && (_parent != universe)) {
            _parent._children = (_parent._children.__append__(_s));
            _s._number = (_parent._children.length);
        };
        return _s;
    }
/**
    // resolve returns the Object represented by obj, resolving lazy
    // objects as appropriate.
**/
private function _resolve(_name:GoString, _obj:Object):Object {
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_obj) : Ref<T_lazyObject>)) : Ref<T_lazyObject>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.T_lazyObject>), ok : false };
            }, _lazy = __tmp__.value, _ok = __tmp__.ok;
            if (_ok) {
                _lazy._once.do_(function():Void {
                    var _obj:stdgo.go.types.Types.Object = _lazy._resolve();
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_obj) : Ref<T_lazyObject>)) : Ref<T_lazyObject>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.types.Types.T_lazyObject>), ok : false };
                        }, __0 = __tmp__.value, _ok = __tmp__.ok;
                        if (_ok) {
                            throw Go.toInterface(("recursive lazy object" : GoString));
                        };
                    };
                    if (_obj.name() != (_name)) {
                        throw Go.toInterface(("lazy object has unexpected name" : GoString));
                    };
                    if (_obj.parent() == null || (_obj.parent() : Dynamic).__nil__) {
                        _obj._setParent(_lazy._parent);
                    };
                    _lazy._obj = _obj;
                });
                _obj = _lazy._obj;
            };
        };
        return _obj;
    }
/**
    // SelectionString returns the string form of s.
    // The Qualifier controls the printing of
    // package-level objects, and may be nil.
    //
    // Examples:
    //
    //	"field (T) f int"
    //	"method (T) f(X) Y"
    //	"method expr (T) f(X) Y"
**/
function selectionString(_s:Ref<Selection>, _qf:Qualifier):GoString {
        var _k:GoString = ("" : GoString);
        {
            final __value__ = _s._kind;
            if (__value__ == ((0 : stdgo.go.types.Types.SelectionKind))) {
                _k = ("field " : GoString);
            } else if (__value__ == ((1 : stdgo.go.types.Types.SelectionKind))) {
                _k = ("method " : GoString);
            } else if (__value__ == ((2 : stdgo.go.types.Types.SelectionKind))) {
                _k = ("method expr " : GoString);
            } else {
                _unreachable();
            };
        };
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        _buf.writeString(_k);
        _buf.writeByte((40 : GoUInt8));
        writeType((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>), _s.recv(), _qf);
        stdgo.fmt.Fmt.fprintf(Go.asInterface((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>)), (") %s" : GoString), Go.toInterface(_s._obj.name()));
        {
            var t:stdgo.go.types.Types.Type = _s.type();
            if (_s._kind == ((0 : stdgo.go.types.Types.SelectionKind))) {
                _buf.writeByte((32 : GoUInt8));
                writeType((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>), t, _qf);
            } else {
                writeSignature((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>), (Go.typeAssert((Go.toInterface(t) : Ref<Signature>)) : Ref<Signature>), _qf);
            };
        };
        return (_buf.string() : GoString);
    }
/**
    // NewSignature returns a new function type for the given receiver, parameters,
    // and results, either of which may be nil. If variadic is set, the function
    // is variadic, it must have at least one parameter, and the last parameter
    // must be of unnamed slice type.
    //
    // Deprecated: Use NewSignatureType instead which allows for type parameters.
**/
function newSignature(_recv:Ref<Var>, _params:Ref<Tuple>, _results:Ref<Tuple>, _variadic:Bool):Ref<Signature> {
        return newSignatureType(_recv, (null : Slice<Ref<stdgo.go.types.Types.TypeParam>>), (null : Slice<Ref<stdgo.go.types.Types.TypeParam>>), _params, _results, _variadic);
    }
/**
    // NewSignatureType creates a new function type for the given receiver,
    // receiver type parameters, type parameters, parameters, and results. If
    // variadic is set, params must hold at least one parameter and the last
    // parameter's core type must be of unnamed slice or bytestring type.
    // If recv is non-nil, typeParams must be empty. If recvTypeParams is
    // non-empty, recv must be non-nil.
**/
function newSignatureType(_recv:Ref<Var>, _recvTypeParams:Slice<Ref<TypeParam>>, _typeParams:Slice<Ref<TypeParam>>, _params:Ref<Tuple>, _results:Ref<Tuple>, _variadic:Bool):Ref<Signature> {
        if (_variadic) {
            var _n:GoInt = _params.len();
            if (_n == ((0 : GoInt))) {
                throw Go.toInterface(("variadic function must have at least one parameter" : GoString));
            };
            var _core:stdgo.go.types.Types.Type = _coreString(_params.at(_n - (1 : GoInt))._object._typ);
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_core) : Ref<Slice_>)) : Ref<Slice_>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.Slice_>), ok : false };
                }, __0 = __tmp__.value, _ok = __tmp__.ok;
                if (!_ok && !_isString(_core)) {
                    throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("got %s, want variadic parameter with unnamed slice type or string as core type" : GoString), Go.toInterface((_core.string() : GoString))));
                };
            };
        };
        var _sig = (Go.setRef(({ _recv : _recv, _params : _params, _results : _results, _variadic : _variadic } : Signature)) : Ref<stdgo.go.types.Types.Signature>);
        if ((_recvTypeParams.length) != ((0 : GoInt))) {
            if (_recv == null || (_recv : Dynamic).__nil__) {
                throw Go.toInterface(("function with receiver type parameters must have a receiver" : GoString));
            };
            _sig._rparams = _bindTParams(_recvTypeParams);
        };
        if ((_typeParams.length) != ((0 : GoInt))) {
            if (_recv != null && ((_recv : Dynamic).__nil__ == null || !(_recv : Dynamic).__nil__)) {
                throw Go.toInterface(("function with type parameters cannot have a receiver" : GoString));
            };
            _sig._tparams = _bindTParams(_typeParams);
        };
        return _sig;
    }
/**
    // Signal size changes of important structures.
**/
function testSizeof(_t:Ref<stdgo.testing.Testing.T>):Void {
        {};
        var _tests:Slice<T__struct_1> = (new Slice<T__struct_1>(
25,
25,
({ _val : Go.toInterface(Go.asInterface((new Basic() : Basic))), __32bit : (16 : GoUIntptr), __64bit : (32 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new Array_() : Array_))), __32bit : (16 : GoUIntptr), __64bit : (24 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new Slice_() : Slice_))), __32bit : (8 : GoUIntptr), __64bit : (16 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new Struct() : Struct))), __32bit : (24 : GoUIntptr), __64bit : (48 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new Pointer_() : Pointer_))), __32bit : (8 : GoUIntptr), __64bit : (16 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new Tuple() : Tuple))), __32bit : (12 : GoUIntptr), __64bit : (24 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new Signature() : Signature))), __32bit : (28 : GoUIntptr), __64bit : (56 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new Union() : Union))), __32bit : (12 : GoUIntptr), __64bit : (24 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new Interface() : Interface))), __32bit : (40 : GoUIntptr), __64bit : (80 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new Map_() : Map_))), __32bit : (16 : GoUIntptr), __64bit : (32 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new Chan() : Chan))), __32bit : (12 : GoUIntptr), __64bit : (24 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new Named() : Named))), __32bit : (60 : GoUIntptr), __64bit : (112 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new TypeParam() : TypeParam))), __32bit : (28 : GoUIntptr), __64bit : (48 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new T_term() : T_term))), __32bit : (12 : GoUIntptr), __64bit : (24 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new PkgName() : PkgName))), __32bit : (48 : GoUIntptr), __64bit : (88 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new Const() : Const))), __32bit : (48 : GoUIntptr), __64bit : (88 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new TypeName() : TypeName))), __32bit : (40 : GoUIntptr), __64bit : (72 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new Var() : Var))), __32bit : (48 : GoUIntptr), __64bit : (88 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new Func() : Func))), __32bit : (48 : GoUIntptr), __64bit : (88 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new Label() : Label))), __32bit : (44 : GoUIntptr), __64bit : (80 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new Builtin() : Builtin))), __32bit : (44 : GoUIntptr), __64bit : (80 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new Nil() : Nil))), __32bit : (40 : GoUIntptr), __64bit : (72 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new Scope() : Scope))), __32bit : (44 : GoUIntptr), __64bit : (88 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new Package() : Package))), __32bit : (40 : GoUIntptr), __64bit : (80 : GoUIntptr) } : T__struct_1),
({ _val : Go.toInterface(Go.asInterface((new T__TypeSet() : T__TypeSet))), __32bit : (28 : GoUIntptr), __64bit : (56 : GoUIntptr) } : T__struct_1)) : Slice<T__struct_1>);
        for (__0 => _test in _tests) {
            var _got:GoUIntptr = stdgo.reflect.Reflect.typeOf(_test._val).size();
            var _want:GoUIntptr = _test.__32bit;
            if (false) {
                _want = _test.__64bit;
            };
            if (_got != (_want)) {
                _t.errorf(("unsafe.Sizeof(%T) = %d, want %d" : GoString), _test._val, Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
private function _isSyncAtomicAlign64(t:Type):Bool {
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(t) : Ref<Named>)) : Ref<Named>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
        }, _named = __tmp__.value, _ok = __tmp__.ok;
        if (!_ok) {
            return false;
        };
        var _obj = _named.obj();
        return ((_obj.name() == ("align64" : GoString)) && ((_obj.pkg() != null) && ((_obj.pkg() : Dynamic).__nil__ == null || !(_obj.pkg() : Dynamic).__nil__))) && ((_obj.pkg().path() == ("sync/atomic" : GoString)) || (_obj.pkg().path() == ("runtime/internal/atomic" : GoString)));
    }
/**
    // SizesFor returns the Sizes used by a compiler for an architecture.
    // The result is nil if a compiler/architecture pair is not known.
    //
    // Supported architectures for compiler "gc":
    // "386", "amd64", "amd64p32", "arm", "arm64", "loong64", "mips", "mipsle",
    // "mips64", "mips64le", "ppc64", "ppc64le", "riscv64", "s390x", "sparc64", "wasm".
**/
function sizesFor(_compiler:GoString, _arch:GoString):Sizes {
        var _m:GoMap<GoString, Ref<StdSizes>> = (null : GoMap<GoString, Ref<stdgo.go.types.Types.StdSizes>>);
        {
            final __value__ = _compiler;
            if (__value__ == (("gc" : GoString))) {
                _m = _gcArchSizes;
            } else if (__value__ == (("gccgo" : GoString))) {
                _m = _gccgoArchSizes;
            } else {
                return (null : stdgo.go.types.Types.Sizes);
            };
        };
        var __tmp__ = (_m != null && _m.exists(_arch) ? { value : _m[_arch], ok : true } : { value : (null : Ref<stdgo.go.types.Types.StdSizes>), ok : false }), _s:Ref<stdgo.go.types.Types.StdSizes> = __tmp__.value, _ok:Bool = __tmp__.ok;
        if (!_ok) {
            return (null : stdgo.go.types.Types.Sizes);
        };
        return Go.asInterface(_s);
    }
/**
    // align returns the smallest y >= x such that y % a == 0.
**/
private function _align(_x:GoInt64, _a:GoInt64):GoInt64 {
        var _y:GoInt64 = (_x + _a) - (1i64 : GoInt64);
        return _y - (_y % _a);
    }
/**
    // NewSlice returns a new slice type for the given element type.
**/
function newSlice(_elem:Type):Ref<Slice_> {
        return (Go.setRef(({ _elem : _elem } : Slice_)) : Ref<stdgo.go.types.Types.Slice_>);
    }
private function _trimTrailingEmptyStmts(_list:Slice<stdgo.go.ast.Ast.Stmt>):Slice<stdgo.go.ast.Ast.Stmt> {
        {
            var _i:GoInt = (_list.length);
            Go.cfor(_i > (0 : GoInt), _i--, {
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_list[(_i - (1 : GoInt) : GoInt)]) : Ref<stdgo.go.ast.Ast.EmptyStmt>)) : Ref<stdgo.go.ast.Ast.EmptyStmt>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.ast.Ast.EmptyStmt>), ok : false };
                    }, __0 = __tmp__.value, _ok = __tmp__.ok;
                    if (!_ok) {
                        return (_list.__slice__(0, _i) : Slice<stdgo.go.ast.Ast.Stmt>);
                    };
                };
            });
        };
        return (null : Slice<stdgo.go.ast.Ast.Stmt>);
    }
private function _assignOp(_op:stdgo.go.token.Token.Token):stdgo.go.token.Token.Token {
        if (((23 : stdgo.go.token.Token.Token) <= _op) && (_op <= (33 : stdgo.go.token.Token.Token))) {
            return _op + (-11 : stdgo.go.token.Token.Token);
        };
        return (0 : stdgo.go.token.Token.Token);
    }
/**
    // goVal returns the Go value for val, or nil.
**/
private function _goVal(_val:stdgo.go.constant.Constant.Value):AnyInterface {
        if (_val == null) {
            return (null : AnyInterface);
        };
        {
            final __value__ = _val.kind();
            if (__value__ == ((3 : stdgo.go.constant.Constant.Kind))) {
                {
                    var __tmp__ = stdgo.go.constant.Constant.int64Val(_val), _x:GoInt64 = __tmp__._0, _ok:Bool = __tmp__._1;
                    if (_ok) {
                        return Go.toInterface(_x);
                    };
                };
                {
                    var __tmp__ = stdgo.go.constant.Constant.uint64Val(_val), _x:GoUInt64 = __tmp__._0, _ok:Bool = __tmp__._1;
                    if (_ok) {
                        return Go.toInterface(_x);
                    };
                };
            } else if (__value__ == ((4 : stdgo.go.constant.Constant.Kind))) {
                {
                    var __tmp__ = stdgo.go.constant.Constant.float64Val(_val), _x:GoFloat64 = __tmp__._0, _ok:Bool = __tmp__._1;
                    if (_ok) {
                        return Go.toInterface(_x);
                    };
                };
            } else if (__value__ == ((2 : stdgo.go.constant.Constant.Kind))) {
                return Go.toInterface(stdgo.go.constant.Constant.stringVal(_val));
            };
        };
        return (null : AnyInterface);
    }
/**
    // rangeKeyVal returns the key and value type produced by a range clause
    // over an expression of type typ. If the range clause is not permitted
    // the results are nil.
**/
private function _rangeKeyVal(_typ:Type):{ var _0 : Type; var _1 : Type; } {
        var _key:Type = (null : stdgo.go.types.Types.Type), _val:Type = (null : stdgo.go.types.Types.Type);
        {
            final __type__ = _arrayPtrDeref(_typ);
            if (Go.typeEquals((__type__ : Ref<Basic>))) {
                var _typ:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                if (_isString(Go.asInterface(_typ))) {
                    return { _0 : Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : GoInt)]), _1 : _universeRune };
                };
            } else if (Go.typeEquals((__type__ : Ref<Array_>))) {
                var _typ:Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                return { _0 : Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : GoInt)]), _1 : _typ._elem };
            } else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
                var _typ:Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                return { _0 : Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : GoInt)]), _1 : _typ._elem };
            } else if (Go.typeEquals((__type__ : Ref<Map_>))) {
                var _typ:Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                return { _0 : _typ._key, _1 : _typ._elem };
            } else if (Go.typeEquals((__type__ : Ref<Chan>))) {
                var _typ:Ref<stdgo.go.types.Types.Chan> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__().value;
                return { _0 : _typ._elem, _1 : Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]) };
            };
        };
        return { _0 : _key, _1 : _val };
    }
/**
    // NewStruct returns a new struct with the given fields and corresponding field tags.
    // If a field with index i has a tag, tags[i] must be that tag, but len(tags) may be
    // only as long as required to hold the tag with the largest index i. Consequently,
    // if no field has a tag, tags may be nil.
**/
function newStruct(_fields:Slice<Ref<Var>>, _tags:Slice<GoString>):Ref<Struct> {
        var _fset:T_objset = (null : stdgo.go.types.Types.T_objset);
        for (__0 => _f in _fields) {
            if ((_f._object._name != ("_" : GoString)) && (_fset._insert(Go.asInterface(_f)) != null)) {
                throw Go.toInterface(("multiple fields with the same name" : GoString));
            };
        };
        if ((_tags.length) > (_fields.length)) {
            throw Go.toInterface(("more tags than fields" : GoString));
        };
        var _s = (Go.setRef(({ _fields : _fields, _tags : _tags } : Struct)) : Ref<stdgo.go.types.Types.Struct>);
        _s._markComplete();
        return _s;
    }
private function _embeddedFieldIdent(_e:stdgo.go.ast.Ast.Expr):Ref<stdgo.go.ast.Ast.Ident> {
        {
            final __type__ = _e;
            if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ident>))) {
                var _e:Ref<stdgo.go.ast.Ast.Ident> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__().value;
                return _e;
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.StarExpr>))) {
                var _e:Ref<stdgo.go.ast.Ast.StarExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_e.x) : Ref<stdgo.go.ast.Ast.StarExpr>)) : Ref<stdgo.go.ast.Ast.StarExpr>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.ast.Ast.StarExpr>), ok : false };
                    }, __0 = __tmp__.value, _ok = __tmp__.ok;
                    if (!_ok) {
                        return _embeddedFieldIdent(_e.x);
                    };
                };
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectorExpr>))) {
                var _e:Ref<stdgo.go.ast.Ast.SelectorExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__().value;
                return _e.sel;
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexExpr>))) {
                var _e:Ref<stdgo.go.ast.Ast.IndexExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IndexExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.IndexExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IndexExpr>) : __type__.__underlying__().value;
                return _embeddedFieldIdent(_e.x);
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexListExpr>))) {
                var _e:Ref<stdgo.go.ast.Ast.IndexListExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IndexListExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.IndexListExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IndexListExpr>) : __type__.__underlying__().value;
                return _embeddedFieldIdent(_e.x);
            };
        };
        return null;
    }
/**
    // makeSubstMap creates a new substitution map mapping tpars[i] to targs[i].
    // If targs[i] is nil, tpars[i] is not substituted.
**/
private function _makeSubstMap(_tpars:Slice<Ref<TypeParam>>, _targs:Slice<Type>):T_substMap {
        _assert((_tpars.length) == ((_targs.length)));
        var _proj:stdgo.go.types.Types.T_substMap = ({
            final x = new GoRefMap<Ref<stdgo.go.types.Types.TypeParam>, stdgo.go.types.Types.Type>();
            @:mergeBlock {};
            cast x;
        } : GoMap<Ref<stdgo.go.types.Types.TypeParam>, stdgo.go.types.Types.Type>);
        for (_i => _tpar in _tpars) {
            _proj[_tpar] = _targs[(_i : GoInt)];
        };
        return _proj;
    }
/**
    // makeRenameMap is like makeSubstMap, but creates a map used to rename type
    // parameters in from with the type parameters in to.
**/
private function _makeRenameMap(_from:Slice<Ref<TypeParam>>, _to:Slice<Ref<TypeParam>>):T_substMap {
        _assert((_from.length) == ((_to.length)));
        var _proj:stdgo.go.types.Types.T_substMap = ({
            final x = new GoRefMap<Ref<stdgo.go.types.Types.TypeParam>, stdgo.go.types.Types.Type>();
            @:mergeBlock {};
            cast x;
        } : GoMap<Ref<stdgo.go.types.Types.TypeParam>, stdgo.go.types.Types.Type>);
        for (_i => _tpar in _from) {
            _proj[_tpar] = Go.asInterface(_to[(_i : GoInt)]);
        };
        return _proj;
    }
private function _substVar(_v:Ref<Var>, _typ:Type):Ref<Var> {
        var _copy:stdgo.go.types.Types.Var = (_v : stdgo.go.types.Types.Var)?.__copy__();
        _copy._object._typ = _typ;
        _copy._origin = _v.origin();
        return (Go.setRef(_copy) : Ref<stdgo.go.types.Types.Var>);
    }
private function _substFunc(_f:Ref<Func>, _typ:Type):Ref<Func> {
        var _copy:stdgo.go.types.Types.Func = (_f : stdgo.go.types.Types.Func)?.__copy__();
        _copy._object._typ = _typ;
        _copy._origin = _f.origin();
        return (Go.setRef(_copy) : Ref<stdgo.go.types.Types.Func>);
    }
/**
    // replaceRecvType updates any function receivers that have type old to have
    // type new. It does not modify the input slice; if modifications are required,
    // the input slice and any affected signatures will be copied before mutating.
    //
    // The resulting out slice contains the updated functions, and copied reports
    // if anything was modified.
**/
private function _replaceRecvType(_in:Slice<Ref<Func>>, _old:Type, _new:Type):{ var _0 : Slice<Ref<Func>>; var _1 : Bool; } {
        var _out:Slice<Ref<Func>> = (null : Slice<Ref<stdgo.go.types.Types.Func>>), _copied:Bool = false;
        _out = _in;
        for (_i => _method in _in) {
            var _sig = (Go.typeAssert((Go.toInterface(_method.type()) : Ref<Signature>)) : Ref<Signature>);
            if (((_sig._recv != null) && ((_sig._recv : Dynamic).__nil__ == null || !(_sig._recv : Dynamic).__nil__)) && (Go.toInterface(_sig._recv.type()) == Go.toInterface(_old))) {
                if (!_copied) {
                    _out = new Slice<Ref<stdgo.go.types.Types.Func>>((_in.length : GoInt).toBasic(), 0);
                    Go.copySlice(_out, _in);
                    _copied = true;
                };
                var _newsig:stdgo.go.types.Types.Signature = (_sig : stdgo.go.types.Types.Signature)?.__copy__();
                _newsig._recv = _substVar(_sig._recv, _new);
                _out[(_i : GoInt)] = _substFunc(_method, Go.asInterface((Go.setRef(_newsig) : Ref<stdgo.go.types.Types.Signature>)));
            };
        };
        return { _0 : _out, _1 : _copied };
    }
/**
    // maketl makes a term list from a string of the term list.
**/
private function _maketl(_s:GoString):T_termlist {
        _s = stdgo.strings.Strings.replaceAll(_s, (" " : GoString), Go.str());
        var _names = stdgo.strings.Strings.split(_s, ("|" : GoString));
        var _r:stdgo.go.types.Types.T_termlist = new Slice<Ref<stdgo.go.types.Types.T_term>>((_names.length : GoInt).toBasic(), 0);
        for (_i => _n in _names) {
            _r[(_i : GoInt)] = _testTerm(_n);
        };
        return _r;
    }
function testTermlistAll(_t:Ref<stdgo.testing.Testing.T>):Void {
        if (!_allTermlist._isAll()) {
            _t.errorf(("allTermlist is not the set of all types" : GoString));
        };
    }
function testTermlistString(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _want in (new Slice<GoString>(
9,
9,
("‚àÖ" : GoString),
("ùì§" : GoString),
("int" : GoString),
("~int" : GoString),
("myInt" : GoString),
("‚àÖ | ‚àÖ" : GoString),
("ùì§ | ùì§" : GoString),
("‚àÖ | ùì§ | int" : GoString),
("‚àÖ | ùì§ | int | myInt" : GoString)) : Slice<GoString>)) {
            {
                var _got:GoString = (_maketl(_want).string() : GoString);
                if (_got != (_want)) {
                    _t.errorf(("(%v).String() == %v" : GoString), Go.toInterface(_want), Go.toInterface(_got));
                };
            };
        };
    }
function testTermlistIsEmpty(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_test => _want in ({
            final x = new stdgo.GoMap.GoStringMap<Bool>();
            x.__defaultValue__ = () -> false;
            @:mergeBlock {
                x.set(("‚àÖ" : GoString), true);
                x.set(("‚àÖ | ‚àÖ" : GoString), true);
                x.set(("‚àÖ | ‚àÖ | ùì§" : GoString), false);
                x.set(("‚àÖ | ‚àÖ | myInt" : GoString), false);
                x.set(("ùì§" : GoString), false);
                x.set(("ùì§ | int" : GoString), false);
                x.set(("ùì§ | myInt | ‚àÖ" : GoString), false);
            };
            x;
        } : GoMap<GoString, Bool>)) {
            var _xl:stdgo.go.types.Types.T_termlist = _maketl(_test);
            var _got:Bool = _xl._isEmpty();
            if (_got != (_want)) {
                _t.errorf(("(%v).isEmpty() == %v; want %v" : GoString), Go.toInterface(_test), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function testTermlistIsAll(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_test => _want in ({
            final x = new stdgo.GoMap.GoStringMap<Bool>();
            x.__defaultValue__ = () -> false;
            @:mergeBlock {
                x.set(("‚àÖ" : GoString), false);
                x.set(("‚àÖ | ‚àÖ" : GoString), false);
                x.set(("int | ~string" : GoString), false);
                x.set(("~int | myInt" : GoString), false);
                x.set(("‚àÖ | ‚àÖ | ùì§" : GoString), true);
                x.set(("ùì§" : GoString), true);
                x.set(("ùì§ | int" : GoString), true);
                x.set(("myInt | ùì§" : GoString), true);
            };
            x;
        } : GoMap<GoString, Bool>)) {
            var _xl:stdgo.go.types.Types.T_termlist = _maketl(_test);
            var _got:Bool = _xl._isAll();
            if (_got != (_want)) {
                _t.errorf(("(%v).isAll() == %v; want %v" : GoString), Go.toInterface(_test), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function testTermlistNorm(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_2>(
12,
12,
({ _xl : ("‚àÖ" : GoString), _want : ("‚àÖ" : GoString) } : T__struct_2),
({ _xl : ("‚àÖ | ‚àÖ" : GoString), _want : ("‚àÖ" : GoString) } : T__struct_2),
({ _xl : ("‚àÖ | int" : GoString), _want : ("int" : GoString) } : T__struct_2),
({ _xl : ("‚àÖ | myInt" : GoString), _want : ("myInt" : GoString) } : T__struct_2),
({ _xl : ("ùì§ | int" : GoString), _want : ("ùì§" : GoString) } : T__struct_2),
({ _xl : ("ùì§ | myInt" : GoString), _want : ("ùì§" : GoString) } : T__struct_2),
({ _xl : ("int | myInt" : GoString), _want : ("int | myInt" : GoString) } : T__struct_2),
({ _xl : ("~int | int" : GoString), _want : ("~int" : GoString) } : T__struct_2),
({ _xl : ("~int | myInt" : GoString), _want : ("~int" : GoString) } : T__struct_2),
({ _xl : ("int | ~string | int" : GoString), _want : ("int | ~string" : GoString) } : T__struct_2),
({ _xl : ("~int | string | ùì§ | ~string | int" : GoString), _want : ("ùì§" : GoString) } : T__struct_2),
({ _xl : ("~int | string | myInt | ~string | int" : GoString), _want : ("~int | ~string" : GoString) } : T__struct_2)) : Slice<T__struct_2>)) {
            var _xl:stdgo.go.types.Types.T_termlist = _maketl(_test._xl);
            var _got:stdgo.go.types.Types.T_termlist = _maketl(_test._xl)._norm();
            if ((_got.string() : GoString) != (_test._want)) {
                _t.errorf(("(%v).norm() = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_xl)), Go.toInterface(Go.asInterface(_got)), Go.toInterface(_test._want));
            };
        };
    }
function testTermlistUnion(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_3>(
14,
14,
({ _xl : ("‚àÖ" : GoString), _yl : ("‚àÖ" : GoString), _want : ("‚àÖ" : GoString) } : T__struct_3),
({ _xl : ("‚àÖ" : GoString), _yl : ("ùì§" : GoString), _want : ("ùì§" : GoString) } : T__struct_3),
({ _xl : ("‚àÖ" : GoString), _yl : ("int" : GoString), _want : ("int" : GoString) } : T__struct_3),
({ _xl : ("ùì§" : GoString), _yl : ("~int" : GoString), _want : ("ùì§" : GoString) } : T__struct_3),
({ _xl : ("int" : GoString), _yl : ("~int" : GoString), _want : ("~int" : GoString) } : T__struct_3),
({ _xl : ("int" : GoString), _yl : ("string" : GoString), _want : ("int | string" : GoString) } : T__struct_3),
({ _xl : ("int" : GoString), _yl : ("myInt" : GoString), _want : ("int | myInt" : GoString) } : T__struct_3),
({ _xl : ("~int" : GoString), _yl : ("myInt" : GoString), _want : ("~int" : GoString) } : T__struct_3),
({ _xl : ("int | string" : GoString), _yl : ("~string" : GoString), _want : ("int | ~string" : GoString) } : T__struct_3),
({ _xl : ("~int | string" : GoString), _yl : ("~string | int" : GoString), _want : ("~int | ~string" : GoString) } : T__struct_3),
({ _xl : ("~int | string | ‚àÖ" : GoString), _yl : ("~string | int" : GoString), _want : ("~int | ~string" : GoString) } : T__struct_3),
({ _xl : ("~int | myInt | ‚àÖ" : GoString), _yl : ("~string | int" : GoString), _want : ("~int | ~string" : GoString) } : T__struct_3),
({ _xl : ("~int | string | ùì§" : GoString), _yl : ("~string | int" : GoString), _want : ("ùì§" : GoString) } : T__struct_3),
({ _xl : ("~int | string | myInt" : GoString), _yl : ("~string | int" : GoString), _want : ("~int | ~string" : GoString) } : T__struct_3)) : Slice<T__struct_3>)) {
            var _xl:stdgo.go.types.Types.T_termlist = _maketl(_test._xl);
            var _yl:stdgo.go.types.Types.T_termlist = _maketl(_test._yl);
            var _got:GoString = (_xl._union(_yl).string() : GoString);
            if (_got != (_test._want)) {
                _t.errorf(("(%v).union(%v) = %v; want %v" : GoString), Go.toInterface(_test._xl), Go.toInterface(_test._yl), Go.toInterface(_got), Go.toInterface(_test._want));
            };
        };
    }
function testTermlistIntersect(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_3>(
16,
16,
({ _xl : ("‚àÖ" : GoString), _yl : ("‚àÖ" : GoString), _want : ("‚àÖ" : GoString) } : T__struct_3),
({ _xl : ("‚àÖ" : GoString), _yl : ("ùì§" : GoString), _want : ("‚àÖ" : GoString) } : T__struct_3),
({ _xl : ("‚àÖ" : GoString), _yl : ("int" : GoString), _want : ("‚àÖ" : GoString) } : T__struct_3),
({ _xl : ("‚àÖ" : GoString), _yl : ("myInt" : GoString), _want : ("‚àÖ" : GoString) } : T__struct_3),
({ _xl : ("ùì§" : GoString), _yl : ("~int" : GoString), _want : ("~int" : GoString) } : T__struct_3),
({ _xl : ("ùì§" : GoString), _yl : ("myInt" : GoString), _want : ("myInt" : GoString) } : T__struct_3),
({ _xl : ("int" : GoString), _yl : ("~int" : GoString), _want : ("int" : GoString) } : T__struct_3),
({ _xl : ("int" : GoString), _yl : ("string" : GoString), _want : ("‚àÖ" : GoString) } : T__struct_3),
({ _xl : ("int" : GoString), _yl : ("myInt" : GoString), _want : ("‚àÖ" : GoString) } : T__struct_3),
({ _xl : ("~int" : GoString), _yl : ("myInt" : GoString), _want : ("myInt" : GoString) } : T__struct_3),
({ _xl : ("int | string" : GoString), _yl : ("~string" : GoString), _want : ("string" : GoString) } : T__struct_3),
({ _xl : ("~int | string" : GoString), _yl : ("~string | int" : GoString), _want : ("int | string" : GoString) } : T__struct_3),
({ _xl : ("~int | string | ‚àÖ" : GoString), _yl : ("~string | int" : GoString), _want : ("int | string" : GoString) } : T__struct_3),
({ _xl : ("~int | myInt | ‚àÖ" : GoString), _yl : ("~string | int" : GoString), _want : ("int" : GoString) } : T__struct_3),
({ _xl : ("~int | string | ùì§" : GoString), _yl : ("~string | int" : GoString), _want : ("int | ~string" : GoString) } : T__struct_3),
({ _xl : ("~int | string | myInt" : GoString), _yl : ("~string | int" : GoString), _want : ("int | string" : GoString) } : T__struct_3)) : Slice<T__struct_3>)) {
            var _xl:stdgo.go.types.Types.T_termlist = _maketl(_test._xl);
            var _yl:stdgo.go.types.Types.T_termlist = _maketl(_test._yl);
            var _got:GoString = (_xl._intersect(_yl).string() : GoString);
            if (_got != (_test._want)) {
                _t.errorf(("(%v).intersect(%v) = %v; want %v" : GoString), Go.toInterface(_test._xl), Go.toInterface(_test._yl), Go.toInterface(_got), Go.toInterface(_test._want));
            };
        };
    }
function testTermlistEqual(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_4>(
9,
9,
({ _xl : ("‚àÖ" : GoString), _yl : ("‚àÖ" : GoString), _want : true } : T__struct_4),
({ _xl : ("‚àÖ" : GoString), _yl : ("ùì§" : GoString), _want : false } : T__struct_4),
({ _xl : ("ùì§" : GoString), _yl : ("ùì§" : GoString), _want : true } : T__struct_4),
({ _xl : ("ùì§ | int" : GoString), _yl : ("ùì§" : GoString), _want : true } : T__struct_4),
({ _xl : ("ùì§ | int" : GoString), _yl : ("string | ùì§" : GoString), _want : true } : T__struct_4),
({ _xl : ("ùì§ | myInt" : GoString), _yl : ("string | ùì§" : GoString), _want : true } : T__struct_4),
({ _xl : ("int | ~string" : GoString), _yl : ("string | int" : GoString), _want : false } : T__struct_4),
({ _xl : ("~int | string" : GoString), _yl : ("string | myInt" : GoString), _want : false } : T__struct_4),
({ _xl : ("int | ~string | ‚àÖ" : GoString), _yl : ("string | int | ~string" : GoString), _want : true } : T__struct_4)) : Slice<T__struct_4>)) {
            var _xl:stdgo.go.types.Types.T_termlist = _maketl(_test._xl);
            var _yl:stdgo.go.types.Types.T_termlist = _maketl(_test._yl);
            var _got:Bool = _xl._equal(_yl);
            if (_got != (_test._want)) {
                _t.errorf(("(%v).equal(%v) = %v; want %v" : GoString), Go.toInterface(_test._xl), Go.toInterface(_test._yl), Go.toInterface(_got), Go.toInterface(_test._want));
            };
        };
    }
function testTermlistIncludes(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_5>(
11,
11,
({ _xl : ("‚àÖ" : GoString), _typ : ("int" : GoString), _want : false } : T__struct_5),
({ _xl : ("ùì§" : GoString), _typ : ("int" : GoString), _want : true } : T__struct_5),
({ _xl : ("~int" : GoString), _typ : ("int" : GoString), _want : true } : T__struct_5),
({ _xl : ("int" : GoString), _typ : ("string" : GoString), _want : false } : T__struct_5),
({ _xl : ("~int" : GoString), _typ : ("string" : GoString), _want : false } : T__struct_5),
({ _xl : ("~int" : GoString), _typ : ("myInt" : GoString), _want : true } : T__struct_5),
({ _xl : ("int | string" : GoString), _typ : ("string" : GoString), _want : true } : T__struct_5),
({ _xl : ("~int | string" : GoString), _typ : ("int" : GoString), _want : true } : T__struct_5),
({ _xl : ("~int | string" : GoString), _typ : ("myInt" : GoString), _want : true } : T__struct_5),
({ _xl : ("~int | myInt | ‚àÖ" : GoString), _typ : ("myInt" : GoString), _want : true } : T__struct_5),
({ _xl : ("myInt | ‚àÖ | ùì§" : GoString), _typ : ("int" : GoString), _want : true } : T__struct_5)) : Slice<T__struct_5>)) {
            var _xl:stdgo.go.types.Types.T_termlist = _maketl(_test._xl);
            var _yl:stdgo.go.types.Types.Type = _testTerm(_test._typ)._typ;
            var _got:Bool = _xl._includes(_yl);
            if (_got != (_test._want)) {
                _t.errorf(("(%v).includes(%v) = %v; want %v" : GoString), Go.toInterface(_test._xl), Go.toInterface(_yl), Go.toInterface(_got), Go.toInterface(_test._want));
            };
        };
    }
function testTermlistSupersetOf(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_5>(
21,
21,
({ _xl : ("‚àÖ" : GoString), _typ : ("‚àÖ" : GoString), _want : true } : T__struct_5),
({ _xl : ("‚àÖ" : GoString), _typ : ("ùì§" : GoString), _want : false } : T__struct_5),
({ _xl : ("‚àÖ" : GoString), _typ : ("int" : GoString), _want : false } : T__struct_5),
({ _xl : ("ùì§" : GoString), _typ : ("‚àÖ" : GoString), _want : true } : T__struct_5),
({ _xl : ("ùì§" : GoString), _typ : ("ùì§" : GoString), _want : true } : T__struct_5),
({ _xl : ("ùì§" : GoString), _typ : ("int" : GoString), _want : true } : T__struct_5),
({ _xl : ("ùì§" : GoString), _typ : ("~int" : GoString), _want : true } : T__struct_5),
({ _xl : ("ùì§" : GoString), _typ : ("myInt" : GoString), _want : true } : T__struct_5),
({ _xl : ("~int" : GoString), _typ : ("int" : GoString), _want : true } : T__struct_5),
({ _xl : ("~int" : GoString), _typ : ("~int" : GoString), _want : true } : T__struct_5),
({ _xl : ("~int" : GoString), _typ : ("myInt" : GoString), _want : true } : T__struct_5),
({ _xl : ("int" : GoString), _typ : ("~int" : GoString), _want : false } : T__struct_5),
({ _xl : ("myInt" : GoString), _typ : ("~int" : GoString), _want : false } : T__struct_5),
({ _xl : ("int" : GoString), _typ : ("string" : GoString), _want : false } : T__struct_5),
({ _xl : ("~int" : GoString), _typ : ("string" : GoString), _want : false } : T__struct_5),
({ _xl : ("int | string" : GoString), _typ : ("string" : GoString), _want : true } : T__struct_5),
({ _xl : ("int | string" : GoString), _typ : ("~string" : GoString), _want : false } : T__struct_5),
({ _xl : ("~int | string" : GoString), _typ : ("int" : GoString), _want : true } : T__struct_5),
({ _xl : ("~int | string" : GoString), _typ : ("myInt" : GoString), _want : true } : T__struct_5),
({ _xl : ("~int | string | ‚àÖ" : GoString), _typ : ("string" : GoString), _want : true } : T__struct_5),
({ _xl : ("~string | ‚àÖ | ùì§" : GoString), _typ : ("myInt" : GoString), _want : true } : T__struct_5)) : Slice<T__struct_5>)) {
            var _xl:stdgo.go.types.Types.T_termlist = _maketl(_test._xl);
            var _y = _testTerm(_test._typ);
            var _got:Bool = _xl._supersetOf(_y);
            if (_got != (_test._want)) {
                _t.errorf(("(%v).supersetOf(%v) = %v; want %v" : GoString), Go.toInterface(_test._xl), Go.toInterface(Go.asInterface(_y)), Go.toInterface(_got), Go.toInterface(_test._want));
            };
        };
    }
function testTermlistSubsetOf(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_4>(
16,
16,
({ _xl : ("‚àÖ" : GoString), _yl : ("‚àÖ" : GoString), _want : true } : T__struct_4),
({ _xl : ("‚àÖ" : GoString), _yl : ("ùì§" : GoString), _want : true } : T__struct_4),
({ _xl : ("ùì§" : GoString), _yl : ("‚àÖ" : GoString), _want : false } : T__struct_4),
({ _xl : ("ùì§" : GoString), _yl : ("ùì§" : GoString), _want : true } : T__struct_4),
({ _xl : ("int" : GoString), _yl : ("int | string" : GoString), _want : true } : T__struct_4),
({ _xl : ("~int" : GoString), _yl : ("int | string" : GoString), _want : false } : T__struct_4),
({ _xl : ("~int" : GoString), _yl : ("myInt | string" : GoString), _want : false } : T__struct_4),
({ _xl : ("myInt" : GoString), _yl : ("~int | string" : GoString), _want : true } : T__struct_4),
({ _xl : ("~int" : GoString), _yl : ("string | string | int | ~int" : GoString), _want : true } : T__struct_4),
({ _xl : ("myInt" : GoString), _yl : ("string | string | ~int" : GoString), _want : true } : T__struct_4),
({ _xl : ("int | string" : GoString), _yl : ("string" : GoString), _want : false } : T__struct_4),
({ _xl : ("int | string" : GoString), _yl : ("string | int" : GoString), _want : true } : T__struct_4),
({ _xl : ("int | ~string" : GoString), _yl : ("string | int" : GoString), _want : false } : T__struct_4),
({ _xl : ("myInt | ~string" : GoString), _yl : ("string | int | ùì§" : GoString), _want : true } : T__struct_4),
({ _xl : ("int | ~string" : GoString), _yl : ("string | int | ‚àÖ | string" : GoString), _want : false } : T__struct_4),
({ _xl : ("int | myInt" : GoString), _yl : ("string | ~int | ‚àÖ | string" : GoString), _want : true } : T__struct_4)) : Slice<T__struct_4>)) {
            var _xl:stdgo.go.types.Types.T_termlist = _maketl(_test._xl);
            var _yl:stdgo.go.types.Types.T_termlist = _maketl(_test._yl);
            var _got:Bool = _xl._subsetOf(_yl);
            if (_got != (_test._want)) {
                _t.errorf(("(%v).subsetOf(%v) = %v; want %v" : GoString), Go.toInterface(_test._xl), Go.toInterface(_test._yl), Go.toInterface(_got), Go.toInterface(_test._want));
            };
        };
    }
function testZeroTok(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _zero:stdgo.go.token.Token.Token = ((0 : GoInt) : stdgo.go.token.Token.Token);
        if ((0 : stdgo.go.token.Token.Token) != (_zero)) {
            _t.errorf(("%s == %d; want 0" : GoString), Go.toInterface(Go.asInterface((0 : stdgo.go.token.Token.Token))), Go.toInterface(Go.asInterface(_zero)));
        };
    }
function testAssignOp(_t:Ref<stdgo.testing.Testing.T>):Void {
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < (256 : GoInt), _i++, {
                var _tok:stdgo.go.token.Token.Token = (_i : stdgo.go.token.Token.Token);
                var _got:stdgo.go.token.Token.Token = _assignOp(_tok);
                var _want:stdgo.go.token.Token.Token = _assignOps[_tok];
                if (_got != (_want)) {
                    _t.errorf(("for assignOp(%s): got %s; want %s" : GoString), Go.toInterface(Go.asInterface(_tok)), Go.toInterface(Go.asInterface(_got)), Go.toInterface(Go.asInterface(_want)));
                };
            });
        };
    }
/**
    // NewTuple returns a new tuple for the given variables.
**/
function newTuple(_x:haxe.Rest<Ref<Var>>):Ref<Tuple> {
        var _x = new Slice<Ref<Var>>(_x.length, 0, ..._x);
        if ((_x.length) > (0 : GoInt)) {
            return (Go.setRef(({ _vars : _x } : Tuple)) : Ref<stdgo.go.types.Types.Tuple>);
        };
        return null;
    }
/**
    // under returns the true expanded underlying type.
    // If it doesn't exist, the result is Typ[Invalid].
    // under must only be called when a type is known
    // to be fully set up.
**/
private function _under(_t:Type):Type {
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_t) : Ref<Named>)) : Ref<Named>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
            }, _t = __tmp__.value, __0 = __tmp__.ok;
            if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                return _t._under();
            };
        };
        return _t.underlying();
    }
/**
    // If t is not a type parameter, coreType returns the underlying type.
    // If t is a type parameter, coreType returns the single underlying
    // type of all types in its type set if it exists, or nil otherwise. If the
    // type set contains only unrestricted and restricted channel types (with
    // identical element types), the single underlying type is the restricted
    // channel type if the restrictions are always the same, or nil otherwise.
**/
private function _coreType(_t:Type):Type {
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(_t) : Ref<TypeParam>)) : Ref<TypeParam>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.TypeParam>), ok : false };
        }, _tpar = __tmp__.value, __0 = __tmp__.ok;
        if (_tpar == null || (_tpar : Dynamic).__nil__) {
            return _under(_t);
        };
        var _su:Type = (null : stdgo.go.types.Types.Type);
        if (_tpar._underIs(function(_u:Type):Bool {
            if (_u == null) {
                return false;
            };
            if (_su != null) {
                _u = _match(_su, _u);
                if (_u == null) {
                    return false;
                };
            };
            _su = _u;
            return true;
        })) {
            return _su;
        };
        return (null : stdgo.go.types.Types.Type);
    }
/**
    // coreString is like coreType but also considers []byte
    // and strings as identical. In this case, if successful and we saw
    // a string, the result is of type (possibly untyped) string.
**/
private function _coreString(_t:Type):Type {
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(_t) : Ref<TypeParam>)) : Ref<TypeParam>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.TypeParam>), ok : false };
        }, _tpar = __tmp__.value, __0 = __tmp__.ok;
        if (_tpar == null || (_tpar : Dynamic).__nil__) {
            return _under(_t);
        };
        var _su:Type = (null : stdgo.go.types.Types.Type);
        var _hasString:Bool = false;
        if (_tpar._underIs(function(_u:Type):Bool {
            if (_u == null) {
                return false;
            };
            if (_isString(_u)) {
                _u = Go.asInterface(newSlice(_universeByte));
                _hasString = true;
            };
            if (_su != null) {
                _u = _match(_su, _u);
                if (_u == null) {
                    return false;
                };
            };
            _su = _u;
            return true;
        })) {
            if (_hasString) {
                return Go.asInterface(typ[((17 : stdgo.go.types.Types.BasicKind) : GoInt)]);
            };
            return _su;
        };
        return (null : stdgo.go.types.Types.Type);
    }
/**
    // If x and y are identical, match returns x.
    // If x and y are identical channels but for their direction
    // and one of them is unrestricted, match returns the channel
    // with the restricted direction.
    // In all other cases, match returns nil.
**/
private function _match(_x:Type, _y:Type):Type {
        if (identical(_x, _y)) {
            return _x;
        };
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_x) : Ref<Chan>)) : Ref<Chan>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Chan>), ok : false };
            }, _x = __tmp__.value, __0 = __tmp__.ok;
            if (_x != null && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) {
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Chan>)) : Ref<Chan>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Chan>), ok : false };
                    }, _y = __tmp__.value, __1 = __tmp__.ok;
                    if (((_y != null) && ((_y : Dynamic).__nil__ == null || !(_y : Dynamic).__nil__)) && identical(_x._elem, _y._elem)) {
                        if (_x._dir == ((0 : stdgo.go.types.Types.ChanDir))) {
                            return Go.asInterface(_y);
                        } else if (_y._dir == ((0 : stdgo.go.types.Types.ChanDir))) {
                            return Go.asInterface(_x);
                        };
                    };
                };
            };
        };
        return (null : stdgo.go.types.Types.Type);
    }
/**
    // newTypeList returns a new TypeList with the types in list.
**/
private function _newTypeList(_list:Slice<Type>):Ref<TypeList> {
        if ((_list.length) == ((0 : GoInt))) {
            return null;
        };
        return (Go.setRef((new TypeList(_list) : TypeList)) : Ref<stdgo.go.types.Types.TypeList>);
    }
private function _bindTParams(_list:Slice<Ref<TypeParam>>):Ref<TypeParamList> {
        if ((_list.length) == ((0 : GoInt))) {
            return null;
        };
        for (_i => _typ in _list) {
            if (_typ._index >= (0 : GoInt)) {
                throw Go.toInterface(("type parameter bound more than once" : GoString));
            };
            _typ._index = _i;
        };
        return (Go.setRef(({ _tparams : _list } : TypeParamList)) : Ref<stdgo.go.types.Types.TypeParamList>);
    }
/**
    // nextID returns a value increasing monotonically by 1 with
    // each call, starting with 1. It may be called concurrently.
**/
private function _nextID():GoUInt64 {
        return (stdgo.sync.atomic.Atomic.addUint32(Go.pointer(_lastID), (1u32 : GoUInt32)) : GoUInt64);
    }
/**
    // NewTypeParam returns a new TypeParam. Type parameters may be set on a Named
    // or Signature type by calling SetTypeParams. Setting a type parameter on more
    // than one type will result in a panic.
    //
    // The constraint argument can be nil, and set later via SetConstraint. If the
    // constraint is non-nil, it must be fully defined.
**/
function newTypeParam(_obj:Ref<TypeName>, _constraint:Type):Ref<TypeParam> {
        return ((null : Ref<stdgo.go.types.Types.Checker>) : Ref<Checker>)._newTypeParam(_obj, _constraint);
    }
/**
    // computeInterfaceTypeSet may be called with check == nil.
**/
private function _computeInterfaceTypeSet(_check:Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _ityp:Ref<Interface>):Ref<T__TypeSet> {
        var __deferstack__:Array<Void -> Void> = [];
        if (_ityp._tset != null && ((_ityp._tset : Dynamic).__nil__ == null || !(_ityp._tset : Dynamic).__nil__)) {
            return _ityp._tset;
        };
        try {
            if (!_ityp._complete) {
                return (Go.setRef(_topTypeSet) : Ref<stdgo.go.types.Types.T__TypeSet>);
            };
            if (((_check != null) && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) && false) {
                if (!_pos.isValid() && (_ityp._methods.length > (0 : GoInt))) {
                    _pos = _ityp._methods[(0 : GoInt)]._object._pos;
                };
                _check._trace(_pos, ("-- type set for %s" : GoString), Go.toInterface(Go.asInterface(_ityp)));
                _check._indent++;
                __deferstack__.unshift(() -> {
                    var a = function():Void {
                        _check._indent--;
                        _check._trace(_pos, ("=> %s " : GoString), Go.toInterface(Go.asInterface(_ityp._typeSet())));
                    };
                    a();
                });
            };
            _ityp._tset = (Go.setRef(({ _terms : _allTermlist } : T__TypeSet)) : Ref<stdgo.go.types.Types.T__TypeSet>);
            var _unionSets:GoMap<Ref<Union>, Ref<T__TypeSet>> = (null : GoMap<Ref<stdgo.go.types.Types.Union>, Ref<stdgo.go.types.Types.T__TypeSet>>);
            if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
                if (_check._unionTypeSets == null) {
                    _check._unionTypeSets = ({
                        final x = new GoRefMap<Ref<stdgo.go.types.Types.Union>, Ref<stdgo.go.types.Types.T__TypeSet>>();
                        @:mergeBlock {};
                        cast x;
                    } : GoMap<Ref<stdgo.go.types.Types.Union>, Ref<stdgo.go.types.Types.T__TypeSet>>);
                };
                _unionSets = _check._unionTypeSets;
            } else {
                _unionSets = ({
                    final x = new GoRefMap<Ref<stdgo.go.types.Types.Union>, Ref<stdgo.go.types.Types.T__TypeSet>>();
                    @:mergeBlock {};
                    cast x;
                } : GoMap<Ref<stdgo.go.types.Types.Union>, Ref<stdgo.go.types.Types.T__TypeSet>>);
            };
            var _todo:Slice<Ref<Func>> = (null : Slice<Ref<stdgo.go.types.Types.Func>>);
            var _seen:T_objset = (null : stdgo.go.types.Types.T_objset);
            var _allMethods:Slice<Ref<Func>> = (null : Slice<Ref<stdgo.go.types.Types.Func>>);
            var _mpos = ({
                final x = new GoRefMap<Ref<stdgo.go.types.Types.Func>, stdgo.go.token.Token.Pos>();
                @:mergeBlock {};
                cast x;
            } : GoMap<Ref<stdgo.go.types.Types.Func>, stdgo.go.token.Token.Pos>);
            var _addMethod = function(_pos:stdgo.go.token.Token.Pos, _m:Ref<Func>, _explicit:Bool):Void {
                {
                    var _other:stdgo.go.types.Types.Object = _seen._insert(Go.asInterface(_m));
                    {
                        var __switchIndex__ = -1;
                        var __run__ = true;
                        while (__run__) {
                            __run__ = false;
                            if (_other == null) {
                                _allMethods = (_allMethods.__append__(_m));
                                _mpos[_m] = _pos;
                                break;
                            } else if (_explicit) {
                                if (_check == null || (_check : Dynamic).__nil__) {
                                    throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("%v: duplicate method %s" : GoString), Go.toInterface(Go.asInterface(_m._object._pos)), Go.toInterface(_m._object._name)));
                                };
                                _check._errorf(Go.asInterface((_pos : T_atPos)), (10 : stdgo.internal.types.errors.Errors.Code), ("duplicate method %s" : GoString), Go.toInterface(_m._object._name));
                                _check._errorf(Go.asInterface((_mpos[(Go.typeAssert((Go.toInterface(_other) : Ref<Func>)) : Ref<Func>)] : T_atPos)), (10 : stdgo.internal.types.errors.Errors.Code), ("\tother declaration of %s" : GoString), Go.toInterface(_m._object._name));
                                break;
                            } else {
                                if (_check == null || (_check : Dynamic).__nil__) {
                                    _todo = (_todo.__append__(_m, (Go.typeAssert((Go.toInterface(_other) : Ref<Func>)) : Ref<Func>)));
                                    break;
                                };
                                _check._later(function():Void {
                                    if (!_check._allowVersion(_m._object._pkg, (1 : GoInt), (14 : GoInt)) || !identical(_m._object._typ, _other.type())) {
                                        _check._errorf(Go.asInterface((_pos : T_atPos)), (10 : stdgo.internal.types.errors.Errors.Code), ("duplicate method %s" : GoString), Go.toInterface(_m._object._name));
                                        _check._errorf(Go.asInterface((_mpos[(Go.typeAssert((Go.toInterface(_other) : Ref<Func>)) : Ref<Func>)] : T_atPos)), (10 : stdgo.internal.types.errors.Errors.Code), ("\tother declaration of %s" : GoString), Go.toInterface(_m._object._name));
                                    };
                                })._describef(Go.asInterface((_pos : T_atPos)), ("duplicate method check for %s" : GoString), Go.toInterface(_m._object._name));
                            };
                            break;
                        };
                    };
                };
            };
            for (__80 => _m in _ityp._methods) {
                _addMethod(_m._object._pos, _m, true);
            };
            var _allTerms:stdgo.go.types.Types.T_termlist = _allTermlist;
            var _allComparable:Bool = false;
            for (_i => _typ in _ityp._embeddeds) {
                var _pos:stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos);
                if (_ityp._embedPos != null && ((_ityp._embedPos : Dynamic).__nil__ == null || !(_ityp._embedPos : Dynamic).__nil__)) {
                    _pos = ((_ityp._embedPos : Slice<stdgo.go.token.Token.Pos>))[(_i : GoInt)];
                };
                var _comparable:Bool = false;
                var _terms:T_termlist = new stdgo.go.types.Types.T_termlist(0, 0);
                {
                    final __type__ = _under(_typ);
                    if (Go.typeEquals((__type__ : Ref<Interface>))) {
                        var _u:Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                        _assert(!_isTypeParam(_typ));
                        var _tset = _computeInterfaceTypeSet(_check, _pos, _u);
                        if ((((_check != null) && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) && _check._isImportedConstraint(_typ)) && !_check._allowVersion(_check._pkg, (1 : GoInt), (18 : GoInt))) {
                            _check._errorf(Go.asInterface((_pos : T_atPos)), (135 : stdgo.internal.types.errors.Errors.Code), ("embedding constraint interface %s requires go1.18 or later" : GoString), Go.toInterface(_typ));
                            continue;
                        };
                        _comparable = _tset._comparable;
                        for (__121 => _m in _tset._methods) {
                            _addMethod(_pos, _m, false);
                        };
                        _terms = _tset._terms;
                    } else if (Go.typeEquals((__type__ : Ref<Union>))) {
                        var _u:Ref<stdgo.go.types.Types.Union> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Union>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__().value;
                        if (((_check != null) && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) && !_check._allowVersion(_check._pkg, (1 : GoInt), (18 : GoInt))) {
                            _check._errorf(Go.asInterface((_pos : T_atPos)), (135 : stdgo.internal.types.errors.Errors.Code), ("embedding interface element %s requires go1.18 or later" : GoString), Go.toInterface(Go.asInterface(_u)));
                            continue;
                        };
                        var _tset = _computeUnionTypeSet(_check, _unionSets, _pos, _u);
                        if (_tset == ((Go.setRef(_invalidTypeSet) : Ref<stdgo.go.types.Types.T__TypeSet>))) {
                            continue;
                        };
                        _assert(!_tset._comparable);
                        _assert((_tset._methods.length) == ((0 : GoInt)));
                        _terms = _tset._terms;
                    } else {
                        var _u:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                        if (Go.toInterface(_u) == (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                            continue;
                        };
                        if (((_check != null) && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) && !_check._allowVersion(_check._pkg, (1 : GoInt), (18 : GoInt))) {
                            _check._errorf(Go.asInterface((_pos : T_atPos)), (135 : stdgo.internal.types.errors.Errors.Code), ("embedding non-interface type %s requires go1.18 or later" : GoString), Go.toInterface(_typ));
                            continue;
                        };
                        _terms = (new Slice<Ref<stdgo.go.types.Types.T_term>>(1, 1, (new stdgo.go.types.Types.T_term(false, _typ) : stdgo.go.types.Types.T_term)) : stdgo.go.types.Types.T_termlist);
                    };
                };
                {
                    var __tmp__ = _intersectTermLists(_allTerms, _allComparable, _terms, _comparable);
                    _allTerms = __tmp__._0;
                    _allComparable = __tmp__._1;
                };
            };
            _ityp._embedPos = (null : Ref<Slice<stdgo.go.token.Token.Pos>>);
            {
                var _i:GoInt = (0 : GoInt);
                Go.cfor(_i < (_todo.length), _i = _i + ((2 : GoInt)), {
                    var _m = _todo[(_i : GoInt)];
                    var _other = _todo[(_i + (1 : GoInt) : GoInt)];
                    if (!identical(_m._object._typ, _other._object._typ)) {
                        throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("%v: duplicate method %s" : GoString), Go.toInterface(Go.asInterface(_m._object._pos)), Go.toInterface(_m._object._name)));
                    };
                });
            };
            _ityp._tset._comparable = _allComparable;
            if ((_allMethods.length) != ((0 : GoInt))) {
                _sortMethods(_allMethods);
                _ityp._tset._methods = _allMethods;
            };
            _ityp._tset._terms = _allTerms;
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _ityp._tset;
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return (null : Ref<stdgo.go.types.Types.T__TypeSet>);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return (null : Ref<stdgo.go.types.Types.T__TypeSet>);
        };
    }
/**
    // intersectTermLists computes the intersection of two term lists and respective comparable bits.
    // xcomp, ycomp are valid only if xterms.isAll() and yterms.isAll() respectively.
**/
private function _intersectTermLists(_xterms:T_termlist, _xcomp:Bool, _yterms:T_termlist, _ycomp:Bool):{ var _0 : T_termlist; var _1 : Bool; } {
        var _terms:stdgo.go.types.Types.T_termlist = _xterms._intersect(_yterms);
        var _comp:Bool = _xcomp || _ycomp;
        if (_comp && !_terms._isAll()) {
            var _i:GoInt = (0 : GoInt);
            for (__0 => _t in _terms) {
                _assert(_t._typ != null);
                if (_comparable(_t._typ, false, (null : GoMap<stdgo.go.types.Types.Type, Bool>), null)) {
                    _terms[(_i : GoInt)] = _t;
                    _i++;
                };
            };
            _terms = (_terms.__slice__(0, _i) : stdgo.go.types.Types.T_termlist);
            if (!_terms._isAll()) {
                _comp = false;
            };
        };
        _assert(!_comp || _terms._isAll());
        return { _0 : _terms, _1 : _comp };
    }
private function _sortMethods(_list:Slice<Ref<Func>>):Void {
        stdgo.sort.Sort.sort(Go.asInterface((_list : T_byUniqueMethodName)));
    }
private function _assertSortedMethods(_list:Slice<Ref<Func>>):Void {
        if (true) {
            throw Go.toInterface(("assertSortedMethods called outside debug mode" : GoString));
        };
        if (!stdgo.sort.Sort.isSorted(Go.asInterface((_list : T_byUniqueMethodName)))) {
            throw Go.toInterface(("methods not sorted" : GoString));
        };
    }
/**
    // computeUnionTypeSet may be called with check == nil.
    // The result is &invalidTypeSet if the union overflows.
**/
private function _computeUnionTypeSet(_check:Ref<Checker>, _unionSets:GoMap<Ref<Union>, Ref<T__TypeSet>>, _pos:stdgo.go.token.Token.Pos, _utyp:Ref<Union>):Ref<T__TypeSet> {
        {
            var __tmp__ = (_unionSets != null && _unionSets.exists(_utyp) ? { value : _unionSets[_utyp], ok : true } : { value : (null : Ref<stdgo.go.types.Types.T__TypeSet>), ok : false }), _tset:Ref<stdgo.go.types.Types.T__TypeSet> = __tmp__.value, __0:Bool = __tmp__.ok;
            if (_tset != null && ((_tset : Dynamic).__nil__ == null || !(_tset : Dynamic).__nil__)) {
                return _tset;
            };
        };
        _unionSets[_utyp] = (Go.setRef(({} : stdgo.go.types.Types.T__TypeSet)) : Ref<stdgo.go.types.Types.T__TypeSet>);
        var _allTerms:T_termlist = new stdgo.go.types.Types.T_termlist(0, 0);
        for (__1 => _t in _utyp._terms) {
            var _terms:T_termlist = new stdgo.go.types.Types.T_termlist(0, 0);
            var _u:stdgo.go.types.Types.Type = _under(_t._typ);
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_u) : Ref<Interface>)) : Ref<Interface>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.Interface>), ok : false };
                }, _ui = __tmp__.value, __2 = __tmp__.ok;
                if (_ui != null && ((_ui : Dynamic).__nil__ == null || !(_ui : Dynamic).__nil__)) {
                    _assert(!_isTypeParam(_t._typ));
                    _terms = _computeInterfaceTypeSet(_check, _pos, _ui)._terms;
                } else if (Go.toInterface(_u) == (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                    continue;
                } else {
                    if (_t._tilde && !identical(_t._typ, _u)) {
                        _t = null;
                    };
                    _terms = (new Slice<Ref<stdgo.go.types.Types.T_term>>(1, 1, {
                        final e = _t;
                        ({ _tilde : e._tilde, _typ : e._typ } : stdgo.go.types.Types.T_term);
                    }) : stdgo.go.types.Types.T_termlist);
                };
            };
            _allTerms = _allTerms._union(_terms);
            if ((_allTerms.length) > (100 : GoInt)) {
                if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
                    _check._errorf(Go.asInterface((_pos : T_atPos)), (141 : stdgo.internal.types.errors.Errors.Code), ("cannot handle more than %d union terms (implementation limitation)" : GoString), Go.toInterface((100 : GoInt)));
                };
                _unionSets[_utyp] = (Go.setRef(_invalidTypeSet) : Ref<stdgo.go.types.Types.T__TypeSet>);
                return _unionSets[_utyp];
            };
        };
        _unionSets[_utyp]._terms = _allTerms;
        return _unionSets[_utyp];
    }
function testInvalidTypeSet(_t:Ref<stdgo.testing.Testing.T>):Void {
        if (!_invalidTypeSet.isEmpty()) {
            _t.error(Go.toInterface(("invalidTypeSet is not empty" : GoString)));
        };
    }
function testTypeSetString(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_body => _want in ({
            final x = new stdgo.GoMap.GoStringMap<GoString>();
            x.__defaultValue__ = () -> ("" : GoString);
            @:mergeBlock {
                x.set(("{}" : GoString), ("ùì§" : GoString));
                x.set(("{int}" : GoString), ("{int}" : GoString));
                x.set(("{~int}" : GoString), ("{~int}" : GoString));
                x.set(("{int|string}" : GoString), ("{int | string}" : GoString));
                x.set(("{int; string}" : GoString), ("‚àÖ" : GoString));
                x.set(("{comparable}" : GoString), ("{comparable}" : GoString));
                x.set(("{comparable; int}" : GoString), ("{int}" : GoString));
                x.set(("{~int; comparable}" : GoString), ("{~int}" : GoString));
                x.set(("{int|string; comparable}" : GoString), ("{int | string}" : GoString));
                x.set(("{comparable; int; string}" : GoString), ("‚àÖ" : GoString));
                x.set(("{m()}" : GoString), ("{func (p.T).m()}" : GoString));
                x.set(("{m1(); m2() int }" : GoString), ("{func (p.T).m1(); func (p.T).m2() int}" : GoString));
                x.set(("{error}" : GoString), ("{func (error).Error() string}" : GoString));
                x.set(("{m(); comparable}" : GoString), ("{comparable; func (p.T).m()}" : GoString));
                x.set(("{m1(); comparable; m2() int }" : GoString), ("{comparable; func (p.T).m1(); func (p.T).m2() int}" : GoString));
                x.set(("{comparable; error}" : GoString), ("{comparable; func (error).Error() string}" : GoString));
                x.set(("{m(); comparable; int|float32|string}" : GoString), ("{func (p.T).m(); int | float32 | string}" : GoString));
                x.set(("{m1(); int; m2(); comparable }" : GoString), ("{func (p.T).m1(); func (p.T).m2(); int}" : GoString));
                x.set(("{E}; type E interface{}" : GoString), ("ùì§" : GoString));
                x.set(("{E}; type E interface{int;string}" : GoString), ("‚àÖ" : GoString));
                x.set(("{E}; type E interface{comparable}" : GoString), ("{comparable}" : GoString));
            };
            x;
        } : GoMap<GoString, GoString>)) {
            var _src:GoString = ("package p; type T interface" : GoString) + _body;
            var _fset = stdgo.go.token.Token.newFileSet();
            var __tmp__ = stdgo.go.parser.Parser.parseFile(_fset, ("p.go" : GoString), Go.toInterface(_src), (32u32 : stdgo.go.parser.Parser.Mode)), _file:Ref<stdgo.go.ast.Ast.File> = __tmp__._0, _err:Error = __tmp__._1;
            if (_file == null || (_file : Dynamic).__nil__) {
                _t.fatalf(("%s: %v (invalid test case)" : GoString), Go.toInterface(_body), Go.toInterface(_err));
            };
            var _conf:Config = ({} : stdgo.go.types.Types.Config);
            var __tmp__ = _conf.check(_file.name.name, _fset, (new Slice<Ref<stdgo.go.ast.Ast.File>>(1, 1, _file) : Slice<Ref<stdgo.go.ast.Ast.File>>), null), _pkg:Ref<stdgo.go.types.Types.Package> = __tmp__._0, _err:Error = __tmp__._1;
            if (_err != null) {
                _t.fatalf(("%s: %v (invalid test case)" : GoString), Go.toInterface(_body), Go.toInterface(_err));
            };
            var _obj:stdgo.go.types.Types.Object = _pkg._scope.lookup(("T" : GoString));
            if (_obj == null) {
                _t.fatalf(("%s: T not found (invalid test case)" : GoString), Go.toInterface(_body));
            };
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_under(_obj.type())) : Ref<Interface>)) : Ref<Interface>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Interface>), ok : false };
            }, t = __tmp__.value, _ok = __tmp__.ok;
            if (!_ok) {
                _t.fatalf(("%s: %v is not an interface (invalid test case)" : GoString), Go.toInterface(_body), Go.toInterface(_obj));
            };
            var _got:GoString = (t._typeSet().string() : GoString);
            if (_got != (_want)) {
                _t.errorf(("%s: got %s; want %s" : GoString), Go.toInterface(_body), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
/**
    // RelativeTo returns a Qualifier that fully qualifies members of
    // all packages other than pkg.
**/
function relativeTo(_pkg:Ref<Package>):Qualifier {
        if (_pkg == null || (_pkg : Dynamic).__nil__) {
            return null;
        };
        return function(_other:Ref<Package>):GoString {
            if (_pkg == (_other)) {
                return Go.str();
            };
            return _other.path();
        };
    }
/**
    // TypeString returns the string representation of typ.
    // The Qualifier controls the printing of
    // package-level objects, and may be nil.
**/
function typeString(_typ:Type, _qf:Qualifier):GoString {
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        writeType((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>), _typ, _qf);
        return (_buf.string() : GoString);
    }
/**
    // WriteType writes the string representation of typ to buf.
    // The Qualifier controls the printing of
    // package-level objects, and may be nil.
**/
function writeType(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _typ:Type, _qf:Qualifier):Void {
        _newTypeWriter(_buf, _qf)._typ(_typ);
    }
/**
    // WriteSignature writes the representation of the signature sig to buf,
    // without a leading "func" keyword. The Qualifier controls the printing
    // of package-level objects, and may be nil.
**/
function writeSignature(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _sig:Ref<Signature>, _qf:Qualifier):Void {
        _newTypeWriter(_buf, _qf)._signature(_sig);
    }
private function _newTypeWriter(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _qf:Qualifier):Ref<T_typeWriter> {
        return (Go.setRef((new T_typeWriter(_buf, ({
            final x = new GoObjectMap<stdgo.go.types.Types.Type, Bool>();
            x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Type", [], stdgo.internal.reflect.Reflect.GoType.named("Type", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
            x.__defaultValue__ = () -> false;
            @:mergeBlock {};
            cast x;
        } : GoMap<stdgo.go.types.Types.Type, Bool>), _qf, null, null, true, false, false) : T_typeWriter)) : Ref<stdgo.go.types.Types.T_typeWriter>);
    }
private function _newTypeHasher(_buf:Ref<stdgo.bytes.Bytes.Buffer>, _ctxt:Ref<Context>):Ref<T_typeWriter> {
        _assert(_ctxt != null && ((_ctxt : Dynamic).__nil__ == null || !(_ctxt : Dynamic).__nil__));
        return (Go.setRef((new T_typeWriter(_buf, ({
            final x = new GoObjectMap<stdgo.go.types.Types.Type, Bool>();
            x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Type", [], stdgo.internal.reflect.Reflect.GoType.named("Type", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
            x.__defaultValue__ = () -> false;
            @:mergeBlock {};
            cast x;
        } : GoMap<stdgo.go.types.Types.Type, Bool>), null, _ctxt, null, false, false, false) : T_typeWriter)) : Ref<stdgo.go.types.Types.T_typeWriter>);
    }
/**
    // subscript returns the decimal (utf8) representation of x using subscript digits.
**/
private function _subscript(_x:GoUInt64):GoString {
        {};
        var _buf:GoArray<GoByte> = new GoArray<GoUInt8>(...[for (i in 0 ... 96) (0 : GoUInt8)]);
        var _i:GoInt = (_buf.length);
        while (true) {
            _i = _i - ((3 : GoInt));
            stdgo.unicode.utf8.Utf8.encodeRune((_buf.__slice__(_i) : Slice<GoUInt8>), (8320 : GoInt32) + (_x % (10i64 : GoUInt64) : GoRune));
            _x = _x / ((10i64 : GoUInt64));
            if (_x == ((0i64 : GoUInt64))) {
                break;
            };
        };
        return ((_buf.__slice__(_i) : Slice<GoUInt8>) : GoString);
    }
function testTermString(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_want => _x in _testTerms) {
            {
                var _got:GoString = (_x.string() : GoString);
                if (_got != (_want)) {
                    _t.errorf(("%v.String() == %v; want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(_got), Go.toInterface(_want));
                };
            };
        };
    }
private function _split(_s:GoString, _n:GoInt):Slice<GoString> {
        var _r = stdgo.strings.Strings.split(_s, (" " : GoString));
        if ((_r.length) != (_n)) {
            throw Go.toInterface(("invalid test case: " : GoString) + _s);
        };
        return _r;
    }
private function _testTerm(_name:GoString):Ref<T_term> {
        var __tmp__ = (_testTerms != null && _testTerms.exists(_name) ? { value : _testTerms[_name], ok : true } : { value : (null : Ref<stdgo.go.types.Types.T_term>), ok : false }), _r:Ref<stdgo.go.types.Types.T_term> = __tmp__.value, _ok:Bool = __tmp__.ok;
        if (!_ok) {
            throw Go.toInterface(("invalid test argument: " : GoString) + _name);
        };
        return _r;
    }
function testTermEqual(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<GoString>(
14,
14,
("‚àÖ ‚àÖ T" : GoString),
("ùì§ ùì§ T" : GoString),
("int int T" : GoString),
("~int ~int T" : GoString),
("myInt myInt T" : GoString),
("‚àÖ ùì§ F" : GoString),
("‚àÖ int F" : GoString),
("‚àÖ ~int F" : GoString),
("ùì§ int F" : GoString),
("ùì§ ~int F" : GoString),
("ùì§ myInt F" : GoString),
("int ~int F" : GoString),
("int myInt F" : GoString),
("~int myInt F" : GoString)) : Slice<GoString>)) {
            var _args = _split(_test, (3 : GoInt));
            var _x = _testTerm(_args[(0 : GoInt)]);
            var _y = _testTerm(_args[(1 : GoInt)]);
            var _want:Bool = _args[(2 : GoInt)] == (("T" : GoString));
            {
                var _got:Bool = _x._equal(_y);
                if (_got != (_want)) {
                    _t.errorf(("%v.equal(%v) = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(_got), Go.toInterface(_want));
                };
            };
            {
                final __tmp__0 = _y;
                final __tmp__1 = _x;
                _x = __tmp__0;
                _y = __tmp__1;
            };
            {
                var _got:Bool = _x._equal(_y);
                if (_got != (_want)) {
                    _t.errorf(("%v.equal(%v) = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(_got), Go.toInterface(_want));
                };
            };
        };
    }
function testTermUnion(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<GoString>(
29,
29,
("‚àÖ ‚àÖ ‚àÖ ‚àÖ" : GoString),
("‚àÖ ùì§ ùì§ ‚àÖ" : GoString),
("‚àÖ int int ‚àÖ" : GoString),
("‚àÖ ~int ~int ‚àÖ" : GoString),
("‚àÖ myInt myInt ‚àÖ" : GoString),
("ùì§ ùì§ ùì§ ‚àÖ" : GoString),
("ùì§ int ùì§ ‚àÖ" : GoString),
("ùì§ ~int ùì§ ‚àÖ" : GoString),
("ùì§ myInt ùì§ ‚àÖ" : GoString),
("int int int ‚àÖ" : GoString),
("int ~int ~int ‚àÖ" : GoString),
("int string int string" : GoString),
("int ~string int ~string" : GoString),
("int myInt int myInt" : GoString),
("~int ~string ~int ~string" : GoString),
("~int myInt ~int ‚àÖ" : GoString),
("ùì§ ‚àÖ ùì§ ‚àÖ" : GoString),
("int ‚àÖ int ‚àÖ" : GoString),
("~int ‚àÖ ~int ‚àÖ" : GoString),
("myInt ‚àÖ myInt ‚àÖ" : GoString),
("int ùì§ ùì§ ‚àÖ" : GoString),
("~int ùì§ ùì§ ‚àÖ" : GoString),
("myInt ùì§ ùì§ ‚àÖ" : GoString),
("~int int ~int ‚àÖ" : GoString),
("string int string int" : GoString),
("~string int ~string int" : GoString),
("myInt int myInt int" : GoString),
("~string ~int ~string ~int" : GoString),
("myInt ~int ~int ‚àÖ" : GoString)) : Slice<GoString>)) {
            var _args = _split(_test, (4 : GoInt));
            var _x = _testTerm(_args[(0 : GoInt)]);
            var _y = _testTerm(_args[(1 : GoInt)]);
            var _want1 = _testTerm(_args[(2 : GoInt)]);
            var _want2 = _testTerm(_args[(3 : GoInt)]);
            {
                var __tmp__ = _x._union(_y), _got1:Ref<stdgo.go.types.Types.T_term> = __tmp__._0, _got2:Ref<stdgo.go.types.Types.T_term> = __tmp__._1;
                if (!_got1._equal(_want1) || !_got2._equal(_want2)) {
                    _t.errorf(("%v.union(%v) = %v, %v; want %v, %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_got1)), Go.toInterface(Go.asInterface(_got2)), Go.toInterface(Go.asInterface(_want1)), Go.toInterface(Go.asInterface(_want2)));
                };
            };
        };
    }
function testTermIntersection(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<GoString>(
16,
16,
("‚àÖ ‚àÖ ‚àÖ" : GoString),
("‚àÖ ùì§ ‚àÖ" : GoString),
("‚àÖ int ‚àÖ" : GoString),
("‚àÖ ~int ‚àÖ" : GoString),
("‚àÖ myInt ‚àÖ" : GoString),
("ùì§ ùì§ ùì§" : GoString),
("ùì§ int int" : GoString),
("ùì§ ~int ~int" : GoString),
("ùì§ myInt myInt" : GoString),
("int int int" : GoString),
("int ~int int" : GoString),
("int string ‚àÖ" : GoString),
("int ~string ‚àÖ" : GoString),
("int string ‚àÖ" : GoString),
("~int ~string ‚àÖ" : GoString),
("~int myInt myInt" : GoString)) : Slice<GoString>)) {
            var _args = _split(_test, (3 : GoInt));
            var _x = _testTerm(_args[(0 : GoInt)]);
            var _y = _testTerm(_args[(1 : GoInt)]);
            var _want = _testTerm(_args[(2 : GoInt)]);
            {
                var _got = _x._intersect(_y);
                if (!_got._equal(_want)) {
                    _t.errorf(("%v.intersect(%v) = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_got)), Go.toInterface(Go.asInterface(_want)));
                };
            };
            {
                final __tmp__0 = _y;
                final __tmp__1 = _x;
                _x = __tmp__0;
                _y = __tmp__1;
            };
            {
                var _got = _x._intersect(_y);
                if (!_got._equal(_want)) {
                    _t.errorf(("%v.intersect(%v) = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_got)), Go.toInterface(Go.asInterface(_want)));
                };
            };
        };
    }
function testTermIncludes(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<GoString>(8, 8, ("‚àÖ int F" : GoString), ("ùì§ int T" : GoString), ("int int T" : GoString), ("~int int T" : GoString), ("~int myInt T" : GoString), ("string int F" : GoString), ("~string int F" : GoString), ("myInt int F" : GoString)) : Slice<GoString>)) {
            var _args = _split(_test, (3 : GoInt));
            var _x = _testTerm(_args[(0 : GoInt)]);
            var _y:stdgo.go.types.Types.Type = _testTerm(_args[(1 : GoInt)])._typ;
            var _want:Bool = _args[(2 : GoInt)] == (("T" : GoString));
            {
                var _got:Bool = _x._includes(_y);
                if (_got != (_want)) {
                    _t.errorf(("%v.includes(%v) = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(_y), Go.toInterface(_got), Go.toInterface(_want));
                };
            };
        };
    }
function testTermSubsetOf(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<GoString>(
17,
17,
("‚àÖ ‚àÖ T" : GoString),
("ùì§ ùì§ T" : GoString),
("int int T" : GoString),
("~int ~int T" : GoString),
("myInt myInt T" : GoString),
("‚àÖ ùì§ T" : GoString),
("‚àÖ int T" : GoString),
("‚àÖ ~int T" : GoString),
("‚àÖ myInt T" : GoString),
("ùì§ int F" : GoString),
("ùì§ ~int F" : GoString),
("ùì§ myInt F" : GoString),
("int ~int T" : GoString),
("int myInt F" : GoString),
("~int myInt F" : GoString),
("myInt int F" : GoString),
("myInt ~int T" : GoString)) : Slice<GoString>)) {
            var _args = _split(_test, (3 : GoInt));
            var _x = _testTerm(_args[(0 : GoInt)]);
            var _y = _testTerm(_args[(1 : GoInt)]);
            var _want:Bool = _args[(2 : GoInt)] == (("T" : GoString));
            {
                var _got:Bool = _x._subsetOf(_y);
                if (_got != (_want)) {
                    _t.errorf(("%v.subsetOf(%v) = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(_got), Go.toInterface(_want));
                };
            };
        };
    }
function testTermDisjoint(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<GoString>(
10,
10,
("int int F" : GoString),
("~int ~int F" : GoString),
("int ~int F" : GoString),
("int string T" : GoString),
("int ~string T" : GoString),
("int myInt T" : GoString),
("~int ~string T" : GoString),
("~int myInt F" : GoString),
("string myInt T" : GoString),
("~string myInt T" : GoString)) : Slice<GoString>)) {
            var _args = _split(_test, (3 : GoInt));
            var _x = _testTerm(_args[(0 : GoInt)]);
            var _y = _testTerm(_args[(1 : GoInt)]);
            var _want:Bool = _args[(2 : GoInt)] == (("T" : GoString));
            {
                var _got:Bool = _x._disjoint(_y);
                if (_got != (_want)) {
                    _t.errorf(("%v.disjoint(%v) = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(_got), Go.toInterface(_want));
                };
            };
            {
                final __tmp__0 = _y;
                final __tmp__1 = _x;
                _x = __tmp__0;
                _y = __tmp__1;
            };
            {
                var _got:Bool = _x._disjoint(_y);
                if (_got != (_want)) {
                    _t.errorf(("%v.disjoint(%v) = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(_got), Go.toInterface(_want));
                };
            };
        };
    }
/**
    // goTypeName returns the Go type name for typ and
    // removes any occurrences of "types." from that name.
**/
private function _goTypeName(_typ:Type):GoString {
        return stdgo.strings.Strings.replaceAll(stdgo.fmt.Fmt.sprintf(("%T" : GoString), Go.toInterface(_typ)), ("types." : GoString), Go.str());
    }
/**
    // newUnifier returns a new unifier.
    // If exact is set, unification requires unified types to match
    // exactly. If exact is not set, a named type's underlying type
    // is considered if unification would fail otherwise, and the
    // direction of channels is ignored.
    // TODO(gri) exact is not set anymore by a caller. Consider removing it.
**/
private function _newUnifier(_exact:Bool):Ref<T_unifier> {
        var _u = (Go.setRef(({ _exact : _exact } : T_unifier)) : Ref<stdgo.go.types.Types.T_unifier>);
        _u._x._unifier = _u;
        _u._y._unifier = _u;
        return _u;
    }
/**
    // If tpar is a type parameter in list, tparamIndex returns the type parameter index.
    // Otherwise, the result is < 0. tpar must not be nil.
**/
private function _tparamIndex(_list:Slice<Ref<TypeParam>>, _tpar:Ref<TypeParam>):GoInt {
        {
            var _i:GoInt = _tpar._index;
            if ((((0 : GoInt) <= _i) && (_i < _list.length)) && (_list[(_i : GoInt)] == _tpar)) {
                return _i;
            };
        };
        return (-1 : GoInt);
    }
/**
    // NewUnion returns a new Union type with the given terms.
    // It is an error to create an empty union; they are syntactically not possible.
**/
function newUnion(_terms:Slice<Ref<Term>>):Ref<Union> {
        if ((_terms.length) == ((0 : GoInt))) {
            throw Go.toInterface(("empty union" : GoString));
        };
        return (Go.setRef((new Union(_terms) : Union)) : Ref<stdgo.go.types.Types.Union>);
    }
/**
    // NewTerm returns a new union term.
**/
function newTerm(_tilde:Bool, _typ:Type):Ref<Term> {
        return (Go.setRef((new Term(_tilde, _typ) : Term)) : Ref<stdgo.go.types.Types.Term>);
    }
/**
    // parseUnion parses uexpr as a union of expressions.
    // The result is a Union type, or Typ[Invalid] for some errors.
**/
private function _parseUnion(_check:Ref<Checker>, _uexpr:stdgo.go.ast.Ast.Expr):Type {
        var __tmp__ = _flattenUnion((null : Slice<stdgo.go.ast.Ast.Expr>), _uexpr), _blist:Slice<stdgo.go.ast.Ast.Expr> = __tmp__._0, _tlist:Slice<stdgo.go.ast.Ast.Expr> = __tmp__._1;
        _assert((_blist.length) == (_tlist.length - (1 : GoInt)));
        var _terms:Slice<Ref<Term>> = (null : Slice<Ref<stdgo.go.types.Types.Term>>);
        var _u:Type = (null : stdgo.go.types.Types.Type);
        for (_i => _x in _tlist) {
            var _term = _parseTilde(_check, _x);
            if ((_tlist.length == (1 : GoInt)) && !_term._tilde) {
                return _term._typ;
            };
            if ((_terms.length) >= (100 : GoInt)) {
                if (Go.toInterface(_u) != (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                    _check._errorf(_x, (141 : stdgo.internal.types.errors.Errors.Code), ("cannot handle more than %d union terms (implementation limitation)" : GoString), Go.toInterface((100 : GoInt)));
                    _u = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                };
            } else {
                _terms = (_terms.__append__(_term));
                _u = Go.asInterface((Go.setRef((new Union(_terms) : Union)) : Ref<stdgo.go.types.Types.Union>));
            };
            if (_i > (0 : GoInt)) {
                _check._recordTypeAndValue(_blist[(_i - (1 : GoInt) : GoInt)], (3 : stdgo.go.types.Types.T_operandMode), _u, (null : stdgo.go.constant.Constant.Value));
            };
        };
        if (Go.toInterface(_u) == (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
            return _u;
        };
        _check._later(function():Void {
            for (_i => _t in _terms) {
                if (Go.toInterface(_t._typ) == (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                    continue;
                };
                var _u:stdgo.go.types.Types.Type = _under(_t._typ);
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_u) : Ref<Interface>)) : Ref<Interface>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.Interface>), ok : false };
                }, _f = __tmp__.value, __0 = __tmp__.ok;
                if (_t._tilde) {
                    if (_f != null && ((_f : Dynamic).__nil__ == null || !(_f : Dynamic).__nil__)) {
                        _check._errorf(_tlist[(_i : GoInt)], (141 : stdgo.internal.types.errors.Errors.Code), ("invalid use of ~ (%s is an interface)" : GoString), Go.toInterface(_t._typ));
                        continue;
                    };
                    if (!identical(_u, _t._typ)) {
                        _check._errorf(_tlist[(_i : GoInt)], (141 : stdgo.internal.types.errors.Errors.Code), ("invalid use of ~ (underlying type of %s is %s)" : GoString), Go.toInterface(_t._typ), Go.toInterface(_u));
                        continue;
                    };
                };
                if (_f != null && ((_f : Dynamic).__nil__ == null || !(_f : Dynamic).__nil__)) {
                    var _tset = _f._typeSet();
                    if (_tset.numMethods() != ((0 : GoInt))) {
                        _check._errorf(_tlist[(_i : GoInt)], (141 : stdgo.internal.types.errors.Errors.Code), ("cannot use %s in union (%s contains methods)" : GoString), Go.toInterface(Go.asInterface(_t)), Go.toInterface(Go.asInterface(_t)));
                    } else if (Go.toInterface(_t._typ) == (Go.toInterface(_universeComparable.type()))) {
                        _check._error(_tlist[(_i : GoInt)], (141 : stdgo.internal.types.errors.Errors.Code), ("cannot use comparable in union" : GoString));
                    } else if (_tset._comparable) {
                        _check._errorf(_tlist[(_i : GoInt)], (141 : stdgo.internal.types.errors.Errors.Code), ("cannot use %s in union (%s embeds comparable)" : GoString), Go.toInterface(Go.asInterface(_t)), Go.toInterface(Go.asInterface(_t)));
                    };
                    continue;
                };
                {
                    var _j:GoInt = _overlappingTerm((_terms.__slice__(0, _i) : Slice<Ref<stdgo.go.types.Types.Term>>), _t);
                    if (_j >= (0 : GoInt)) {
                        _check._softErrorf(_tlist[(_i : GoInt)], (141 : stdgo.internal.types.errors.Errors.Code), ("overlapping terms %s and %s" : GoString), Go.toInterface(Go.asInterface(_t)), Go.toInterface(Go.asInterface(_terms[(_j : GoInt)])));
                    };
                };
            };
        })._describef(_uexpr, ("check term validity %s" : GoString), Go.toInterface(_uexpr));
        return _u;
    }
private function _parseTilde(_check:Ref<Checker>, _tx:stdgo.go.ast.Ast.Expr):Ref<Term> {
        var _x:stdgo.go.ast.Ast.Expr = _tx;
        var _tilde:Bool = false;
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_x) : Ref<stdgo.go.ast.Ast.UnaryExpr>)) : Ref<stdgo.go.ast.Ast.UnaryExpr>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.ast.Ast.UnaryExpr>), ok : false };
            }, _op = __tmp__.value, __0 = __tmp__.ok;
            if (((_op != null) && ((_op : Dynamic).__nil__ == null || !(_op : Dynamic).__nil__)) && (_op.op == (88 : stdgo.go.token.Token.Token))) {
                _x = _op.x;
                _tilde = true;
            };
        };
        var _typ:stdgo.go.types.Types.Type = _check._typ(_x);
        if (_isTypeParam(_typ)) {
            if (_tilde) {
                _check._errorf(_x, (144 : stdgo.internal.types.errors.Errors.Code), ("type in term %s cannot be a type parameter" : GoString), Go.toInterface(_tx));
            } else {
                _check._error(_x, (144 : stdgo.internal.types.errors.Errors.Code), ("term cannot be a type parameter" : GoString));
            };
            _typ = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
        };
        var _term = newTerm(_tilde, _typ);
        if (_tilde) {
            _check._recordTypeAndValue(_tx, (3 : stdgo.go.types.Types.T_operandMode), Go.asInterface((Go.setRef((new Union((new Slice<Ref<stdgo.go.types.Types.Term>>(1, 1, _term) : Slice<Ref<stdgo.go.types.Types.Term>>)) : Union)) : Ref<stdgo.go.types.Types.Union>)), (null : stdgo.go.constant.Constant.Value));
        };
        return _term;
    }
/**
    // overlappingTerm reports the index of the term x in terms which is
    // overlapping (not disjoint) from y. The result is < 0 if there is no
    // such term. The type of term y must not be an interface, and terms
    // with an interface type are ignored in the terms list.
**/
private function _overlappingTerm(_terms:Slice<Ref<Term>>, _y:Ref<Term>):GoInt {
        _assert(!isInterface(_y._typ));
        for (_i => _x in _terms) {
            if (isInterface(_x._typ)) {
                continue;
            };
            if (false) {
                if (((((_x == null) || (_x : Dynamic).__nil__) || (_x._typ == null)) || ((_y == null) || (_y : Dynamic).__nil__)) || (_y._typ == null)) {
                    throw Go.toInterface(("empty or top union term" : GoString));
                };
            };
            if (!{
                final e = _x;
                ({ _tilde : e._tilde, _typ : e._typ } : stdgo.go.types.Types.T_term);
            }._disjoint({
                final e = _y;
                ({ _tilde : e._tilde, _typ : e._typ } : stdgo.go.types.Types.T_term);
            })) {
                return _i;
            };
        };
        return (-1 : GoInt);
    }
/**
    // flattenUnion walks a union type expression of the form A | B | C | ...,
    // extracting both the binary exprs (blist) and leaf types (tlist).
**/
private function _flattenUnion(_list:Slice<stdgo.go.ast.Ast.Expr>, _x:stdgo.go.ast.Ast.Expr):{ var _0 : Slice<stdgo.go.ast.Ast.Expr>; var _1 : Slice<stdgo.go.ast.Ast.Expr>; } {
        var _blist:Slice<stdgo.go.ast.Ast.Expr> = (null : Slice<stdgo.go.ast.Ast.Expr>), _tlist:Slice<stdgo.go.ast.Ast.Expr> = (null : Slice<stdgo.go.ast.Ast.Expr>);
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_x) : Ref<stdgo.go.ast.Ast.BinaryExpr>)) : Ref<stdgo.go.ast.Ast.BinaryExpr>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.ast.Ast.BinaryExpr>), ok : false };
            }, _o = __tmp__.value, __0 = __tmp__.ok;
            if (((_o != null) && ((_o : Dynamic).__nil__ == null || !(_o : Dynamic).__nil__)) && (_o.op == (18 : stdgo.go.token.Token.Token))) {
                {
                    var __tmp__ = _flattenUnion(_list, _o.x);
                    _blist = __tmp__._0;
                    _tlist = __tmp__._1;
                };
                _blist = (_blist.__append__(Go.asInterface(_o)));
                _x = _o.y;
            };
        };
        return { _0 : _blist, _1 : (_tlist.__append__(_x)) };
    }
private function _defPredeclaredTypes():Void {
        for (__0 => _t in typ) {
            _def(Go.asInterface(newTypeName((0 : stdgo.go.token.Token.Pos), null, _t._name, Go.asInterface(_t))));
        };
        for (__1 => _t in _aliases) {
            _def(Go.asInterface(newTypeName((0 : stdgo.go.token.Token.Pos), null, _t._name, Go.asInterface(_t))));
        };
        _def(Go.asInterface(newTypeName((0 : stdgo.go.token.Token.Pos), null, ("any" : GoString), Go.asInterface((Go.setRef(({ _complete : true, _tset : (Go.setRef(_topTypeSet) : Ref<stdgo.go.types.Types.T__TypeSet>) } : Interface)) : Ref<stdgo.go.types.Types.Interface>)))));
        {
            var _obj = newTypeName((0 : stdgo.go.token.Token.Pos), null, ("error" : GoString), (null : stdgo.go.types.Types.Type));
            _obj._setColor((1u32 : stdgo.go.types.Types.T_color));
            var _typ = newNamed(_obj, (null : stdgo.go.types.Types.Type), (null : Slice<Ref<stdgo.go.types.Types.Func>>));
            var _recv = newVar((0 : stdgo.go.token.Token.Pos), null, Go.str(), Go.asInterface(_typ));
            var _res = newVar((0 : stdgo.go.token.Token.Pos), null, Go.str(), Go.asInterface(typ[((17 : stdgo.go.types.Types.BasicKind) : GoInt)]));
            var _sig = newSignatureType(_recv, (null : Slice<Ref<stdgo.go.types.Types.TypeParam>>), (null : Slice<Ref<stdgo.go.types.Types.TypeParam>>), null, newTuple(_res), false);
            var _err = newFunc((0 : stdgo.go.token.Token.Pos), null, ("Error" : GoString), _sig);
            var _ityp = (Go.setRef(({ _methods : (new Slice<Ref<stdgo.go.types.Types.Func>>(1, 1, _err) : Slice<Ref<stdgo.go.types.Types.Func>>), _complete : true } : Interface)) : Ref<stdgo.go.types.Types.Interface>);
            _computeInterfaceTypeSet(null, (0 : stdgo.go.token.Token.Pos), _ityp);
            _typ.setUnderlying(Go.asInterface(_ityp));
            _def(Go.asInterface(_obj));
        };
        {
            var _obj = newTypeName((0 : stdgo.go.token.Token.Pos), null, ("comparable" : GoString), (null : stdgo.go.types.Types.Type));
            _obj._setColor((1u32 : stdgo.go.types.Types.T_color));
            var _typ = newNamed(_obj, (null : stdgo.go.types.Types.Type), (null : Slice<Ref<stdgo.go.types.Types.Func>>));
            var _ityp = (Go.setRef(({ _complete : true, _tset : (Go.setRef((new T__TypeSet((null : Slice<Ref<stdgo.go.types.Types.Func>>), _allTermlist, true) : T__TypeSet)) : Ref<stdgo.go.types.Types.T__TypeSet>) } : Interface)) : Ref<stdgo.go.types.Types.Interface>);
            _typ.setUnderlying(Go.asInterface(_ityp));
            _def(Go.asInterface(_obj));
        };
    }
private function _defPredeclaredConsts():Void {
        for (__0 => _c in _predeclaredConsts) {
            _def(Go.asInterface(newConst((0 : stdgo.go.token.Token.Pos), null, _c._name, Go.asInterface(typ[(_c._kind : GoInt)]), _c._val)));
        };
    }
private function _defPredeclaredNil():Void {
        _def(Go.asInterface((Go.setRef((new Nil(({ _name : ("nil" : GoString), _typ : Go.asInterface(typ[((25 : stdgo.go.types.Types.BasicKind) : GoInt)]), _color_ : (1u32 : stdgo.go.types.Types.T_color) } : T_object)) : Nil)) : Ref<stdgo.go.types.Types.Nil>)));
    }
private function _defPredeclaredFuncs():Void {
        for (_i in 0 ... _predeclaredFuncs.length.toBasic()) {
            var _id:stdgo.go.types.Types.T_builtinId = (_i : T_builtinId);
            if ((_id == (24 : stdgo.go.types.Types.T_builtinId)) || (_id == (25 : stdgo.go.types.Types.T_builtinId))) {
                continue;
            };
            _def(Go.asInterface(_newBuiltin(_id)));
        };
    }
/**
    // DefPredeclaredTestFuncs defines the assert and trace built-ins.
    // These built-ins are intended for debugging and testing of this
    // package only.
**/
function defPredeclaredTestFuncs():Void {
        if (universe.lookup(("assert" : GoString)) != null) {
            return;
        };
        _def(Go.asInterface(_newBuiltin((24 : stdgo.go.types.Types.T_builtinId))));
        _def(Go.asInterface(_newBuiltin((25 : stdgo.go.types.Types.T_builtinId))));
    }
/**
    // Objects with names containing blanks are internal and not entered into
    // a scope. Objects with exported names are inserted in the unsafe package
    // scope; other objects are inserted in the universe scope.
**/
private function _def(_obj:Object):Void {
        _assert(_obj._color() == ((1u32 : stdgo.go.types.Types.T_color)));
        var _name:GoString = _obj.name();
        if (stdgo.strings.Strings.contains(_name, (" " : GoString))) {
            return;
        };
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_obj.type()) : Ref<Named>)) : Ref<Named>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
            }, _typ = __tmp__.value, __0 = __tmp__.ok;
            if (_typ != null && ((_typ : Dynamic).__nil__ == null || !(_typ : Dynamic).__nil__)) {
                _typ._obj = (Go.typeAssert((Go.toInterface(_obj) : Ref<TypeName>)) : Ref<TypeName>);
            };
        };
        var _scope = universe;
        if (_obj.exported()) {
            _scope = unsafe._scope;
            {
                final __type__ = _obj;
                if (Go.typeEquals((__type__ : Ref<TypeName>))) {
                    var _obj:Ref<stdgo.go.types.Types.TypeName> = __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.TypeName>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__().value;
                    _obj._object._pkg = unsafe;
                } else if (Go.typeEquals((__type__ : Ref<Builtin>))) {
                    var _obj:Ref<stdgo.go.types.Types.Builtin> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Builtin>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Builtin>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Builtin>) : __type__.__underlying__().value;
                    _obj._object._pkg = unsafe;
                } else {
                    var _obj:stdgo.go.types.Types.Object = __type__ == null ? (null : stdgo.go.types.Types.Object) : cast __type__;
                    _unreachable();
                };
            };
        };
        if (_scope.insert(_obj) != null) {
            throw Go.toInterface(("double declaration of predeclared identifier" : GoString));
        };
    }
/**
    // makeObjList returns the list of type name objects for the given
    // list of named types.
**/
private function _makeObjList(_tlist:Slice<Ref<Named>>):Slice<Object> {
        var _olist = new Slice<stdgo.go.types.Types.Object>((_tlist.length : GoInt).toBasic(), 0);
        for (_i => _t in _tlist) {
            _olist[(_i : GoInt)] = Go.asInterface(_t._obj);
        };
        return _olist;
    }
/**
    // parseGoVersion parses a Go version string (such as "go1.12")
    // and returns the version, or an error. If s is the empty
    // string, the version is 0.0.
**/
private function _parseGoVersion(_s:GoString):{ var _0 : T_version; var _1 : Error; } {
        var _v:T_version = ({} : stdgo.go.types.Types.T_version), _err:Error = (null : Error);
        if (_s == (Go.str())) {
            return { _0 : _v, _1 : _err };
        };
        var _matches = _goVersionRx.findStringSubmatch(_s);
        if (_matches == null) {
            _err = stdgo.fmt.Fmt.errorf(("should be something like \"go1.12\"" : GoString));
            return { _0 : _v, _1 : _err };
        };
        {
            var __tmp__ = stdgo.strconv.Strconv.atoi(_matches[(1 : GoInt)]);
            _v._major = __tmp__._0;
            _err = __tmp__._1;
        };
        if (_err != null) {
            return { _0 : _v, _1 : _err };
        };
        {
            var __tmp__ = stdgo.strconv.Strconv.atoi(_matches[(2 : GoInt)]);
            _v._minor = __tmp__._0;
            _err = __tmp__._1;
        };
        return { _0 : _v, _1 : _err };
    }
@:keep var _ = {
        try {
            _unaryOpPredicates = ({
                final x = new stdgo.GoMap.GoIntMap<stdgo.go.types.Types.Type -> Bool>();
                x.__defaultValue__ = () -> @:implicitReturn throw "__return__";
                @:mergeBlock {
                    x.set((12 : stdgo.go.token.Token.Token), _allNumeric);
                    x.set((13 : stdgo.go.token.Token.Token), _allNumeric);
                    x.set((19 : stdgo.go.token.Token.Token), _allInteger);
                    x.set((43 : stdgo.go.token.Token.Token), _allBoolean);
                };
                x;
            } : GoMap<stdgo.go.token.Token.Token, stdgo.go.types.Types.Type -> Bool>);
            _binaryOpPredicates = ({
                final x = new stdgo.GoMap.GoIntMap<stdgo.go.types.Types.Type -> Bool>();
                x.__defaultValue__ = () -> @:implicitReturn throw "__return__";
                @:mergeBlock {
                    x.set((12 : stdgo.go.token.Token.Token), _allNumericOrString);
                    x.set((13 : stdgo.go.token.Token.Token), _allNumeric);
                    x.set((14 : stdgo.go.token.Token.Token), _allNumeric);
                    x.set((15 : stdgo.go.token.Token.Token), _allNumeric);
                    x.set((16 : stdgo.go.token.Token.Token), _allInteger);
                    x.set((17 : stdgo.go.token.Token.Token), _allInteger);
                    x.set((18 : stdgo.go.token.Token.Token), _allInteger);
                    x.set((19 : stdgo.go.token.Token.Token), _allInteger);
                    x.set((22 : stdgo.go.token.Token.Token), _allInteger);
                    x.set((34 : stdgo.go.token.Token.Token), _allBoolean);
                    x.set((35 : stdgo.go.token.Token.Token), _allBoolean);
                };
                x;
            } : GoMap<stdgo.go.token.Token.Token, stdgo.go.types.Types.Type -> Bool>);
            universe = newScope(null, (0 : stdgo.go.token.Token.Pos), (0 : stdgo.go.token.Token.Pos), ("universe" : GoString));
            unsafe = newPackage(("unsafe" : GoString), ("unsafe" : GoString));
            unsafe._complete = true;
            _defPredeclaredTypes();
            _defPredeclaredConsts();
            _defPredeclaredNil();
            _defPredeclaredFuncs();
            _universeIota = universe.lookup(("iota" : GoString));
            _universeByte = universe.lookup(("byte" : GoString)).type();
            _universeRune = universe.lookup(("rune" : GoString)).type();
            _universeAny = universe.lookup(("any" : GoString));
            _universeError = universe.lookup(("error" : GoString)).type();
            _universeComparable = universe.lookup(("comparable" : GoString));
        } catch(__exception__) if (__exception__.message != "__return__") throw __exception__;
        true;
    };
class T_error_asInterface {
    /**
        // Error returns an error string formatted as follows:
        // filename:line:column: message
    **/
    @:keep
    public dynamic function error():GoString return __self__.value.error();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_error>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_error_asInterface) class T_error_static_extension {
    /**
        // Error returns an error string formatted as follows:
        // filename:line:column: message
    **/
    @:keep
    static public function error( _err:T_error):GoString {
        return stdgo.fmt.Fmt.sprintf(("%s: %s" : GoString), Go.toInterface(Go.asInterface(_err.fset.position(_err.pos))), Go.toInterface(_err.msg));
    }
}
class ArgumentError_asInterface {
    @:keep
    public dynamic function unwrap():Error return __self__.value.unwrap();
    @:keep
    public dynamic function error():GoString return __self__.value.error();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<ArgumentError>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.ArgumentError_asInterface) class ArgumentError_static_extension {
    @:keep
    static public function unwrap( _e:Ref<ArgumentError>):Error {
        return _e.err;
    }
    @:keep
    static public function error( _e:Ref<ArgumentError>):GoString {
        return _e.err.error();
    }
}
class Config_asInterface {
    @:keep
    public dynamic function _sizeof(t:Type):GoInt64 return __self__.value._sizeof(t);
    /**
        // offsetof returns the offset of the field specified via
        // the index sequence relative to typ. All embedded fields
        // must be structs (rather than pointer to structs).
    **/
    @:keep
    public dynamic function _offsetof(_typ:Type, _index:Slice<GoInt>):GoInt64 return __self__.value._offsetof(_typ, _index);
    @:keep
    public dynamic function _offsetsof(t:Ref<Struct>):Slice<GoInt64> return __self__.value._offsetsof(t);
    @:keep
    public dynamic function _alignof(t:Type):GoInt64 return __self__.value._alignof(t);
    /**
        // Check type-checks a package and returns the resulting package object and
        // the first error if any. Additionally, if info != nil, Check populates each
        // of the non-nil maps in the Info struct.
        //
        // The package is marked as complete if no errors occurred, otherwise it is
        // incomplete. See Config.Error for controlling behavior in the presence of
        // errors.
        //
        // The package is specified by a list of *ast.Files and corresponding
        // file set, and the package path the package is identified with.
        // The clean path must not be empty or dot (".").
    **/
    @:keep
    public dynamic function check(_path:GoString, _fset:Ref<stdgo.go.token.Token.FileSet>, _files:Slice<Ref<stdgo.go.ast.Ast.File>>, _info:Ref<Info>):{ var _0 : Ref<Package>; var _1 : Error; } return __self__.value.check(_path, _fset, _files, _info);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Config>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Config_asInterface) class Config_static_extension {
    @:keep
    static public function _sizeof( _conf:Ref<Config>, t:Type):GoInt64 {
        {
            var _s:stdgo.go.types.Types.Sizes = _conf.sizes;
            if (_s != null) {
                {
                    var _z:GoInt64 = _s.sizeof(t);
                    if (_z >= (0i64 : GoInt64)) {
                        return _z;
                    };
                };
                throw Go.toInterface(("Config.Sizes.Sizeof returned a size < 0" : GoString));
            };
        };
        return _stdSizes.sizeof(t);
    }
    /**
        // offsetof returns the offset of the field specified via
        // the index sequence relative to typ. All embedded fields
        // must be structs (rather than pointer to structs).
    **/
    @:keep
    static public function _offsetof( _conf:Ref<Config>, _typ:Type, _index:Slice<GoInt>):GoInt64 {
        var _o:GoInt64 = (0 : GoInt64);
        for (__0 => _i in _index) {
            var _s = (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Struct>)) : Ref<Struct>);
            _o = _o + (_conf._offsetsof(_s)[(_i : GoInt)]);
            _typ = _s._fields[(_i : GoInt)]._object._typ;
        };
        return _o;
    }
    @:keep
    static public function _offsetsof( _conf:Ref<Config>, t:Ref<Struct>):Slice<GoInt64> {
        var _offsets:Slice<GoInt64> = (null : Slice<GoInt64>);
        if (t.numFields() > (0 : GoInt)) {
            {
                var _s:stdgo.go.types.Types.Sizes = _conf.sizes;
                if (_s != null) {
                    _offsets = _s.offsetsof(t._fields);
                    if ((_offsets.length) != (t.numFields())) {
                        throw Go.toInterface(("Config.Sizes.Offsetsof returned the wrong number of offsets" : GoString));
                    };
                    for (__0 => _o in _offsets) {
                        if (_o < (0i64 : GoInt64)) {
                            throw Go.toInterface(("Config.Sizes.Offsetsof returned an offset < 0" : GoString));
                        };
                    };
                } else {
                    _offsets = _stdSizes.offsetsof(t._fields);
                };
            };
        };
        return _offsets;
    }
    @:keep
    static public function _alignof( _conf:Ref<Config>, t:Type):GoInt64 {
        {
            var _s:stdgo.go.types.Types.Sizes = _conf.sizes;
            if (_s != null) {
                {
                    var _a:GoInt64 = _s.alignof_(t);
                    if (_a >= (1i64 : GoInt64)) {
                        return _a;
                    };
                };
                throw Go.toInterface(("Config.Sizes.Alignof returned an alignment < 1" : GoString));
            };
        };
        return _stdSizes.alignof_(t);
    }
    /**
        // Check type-checks a package and returns the resulting package object and
        // the first error if any. Additionally, if info != nil, Check populates each
        // of the non-nil maps in the Info struct.
        //
        // The package is marked as complete if no errors occurred, otherwise it is
        // incomplete. See Config.Error for controlling behavior in the presence of
        // errors.
        //
        // The package is specified by a list of *ast.Files and corresponding
        // file set, and the package path the package is identified with.
        // The clean path must not be empty or dot (".").
    **/
    @:keep
    static public function check( _conf:Ref<Config>, _path:GoString, _fset:Ref<stdgo.go.token.Token.FileSet>, _files:Slice<Ref<stdgo.go.ast.Ast.File>>, _info:Ref<Info>):{ var _0 : Ref<Package>; var _1 : Error; } {
        var _pkg = newPackage(_path, Go.str());
        return { _0 : _pkg, _1 : newChecker(_conf, _fset, _pkg, _info).files(_files) };
    }
}
class Info_asInterface {
    /**
        // ObjectOf returns the object denoted by the specified id,
        // or nil if not found.
        //
        // If id is an embedded struct field, ObjectOf returns the field (*Var)
        // it defines, not the type (*TypeName) it uses.
        //
        // Precondition: the Uses and Defs maps are populated.
    **/
    @:keep
    public dynamic function objectOf(_id:Ref<stdgo.go.ast.Ast.Ident>):Object return __self__.value.objectOf(_id);
    /**
        // TypeOf returns the type of expression e, or nil if not found.
        // Precondition: the Types, Uses and Defs maps are populated.
    **/
    @:keep
    public dynamic function typeOf(_e:stdgo.go.ast.Ast.Expr):Type return __self__.value.typeOf(_e);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Info>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Info_asInterface) class Info_static_extension {
    /**
        // ObjectOf returns the object denoted by the specified id,
        // or nil if not found.
        //
        // If id is an embedded struct field, ObjectOf returns the field (*Var)
        // it defines, not the type (*TypeName) it uses.
        //
        // Precondition: the Uses and Defs maps are populated.
    **/
    @:keep
    static public function objectOf( _info:Ref<Info>, _id:Ref<stdgo.go.ast.Ast.Ident>):Object {
        {
            var _obj:stdgo.go.types.Types.Object = _info.defs[_id];
            if (_obj != null) {
                return _obj;
            };
        };
        return _info.uses[_id];
    }
    /**
        // TypeOf returns the type of expression e, or nil if not found.
        // Precondition: the Types, Uses and Defs maps are populated.
    **/
    @:keep
    static public function typeOf( _info:Ref<Info>, _e:stdgo.go.ast.Ast.Expr):Type {
        {
            var __tmp__ = (_info.types != null && _info.types.exists(_e) ? { value : _info.types[_e], ok : true } : { value : ({} : stdgo.go.types.Types.TypeAndValue), ok : false }), _t:stdgo.go.types.Types.TypeAndValue = __tmp__.value, _ok:Bool = __tmp__.ok;
            if (_ok) {
                return _t.type;
            };
        };
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_e) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.ast.Ast.Ident>), ok : false };
            }, _id = __tmp__.value, __0 = __tmp__.ok;
            if (_id != null && ((_id : Dynamic).__nil__ == null || !(_id : Dynamic).__nil__)) {
                {
                    var _obj:stdgo.go.types.Types.Object = _info.objectOf(_id);
                    if (_obj != null) {
                        return _obj.type();
                    };
                };
            };
        };
        return (null : stdgo.go.types.Types.Type);
    }
}
class TypeAndValue_asInterface {
    /**
        // HasOk reports whether the corresponding expression may be
        // used on the rhs of a comma-ok assignment.
    **/
    @:keep
    public dynamic function hasOk():Bool return __self__.value.hasOk();
    /**
        // Assignable reports whether the corresponding expression
        // is assignable to (provided a value of the right type).
    **/
    @:keep
    public dynamic function assignable():Bool return __self__.value.assignable();
    /**
        // Addressable reports whether the corresponding expression
        // is addressable (https://golang.org/ref/spec#Address_operators).
    **/
    @:keep
    public dynamic function addressable():Bool return __self__.value.addressable();
    /**
        // IsNil reports whether the corresponding expression denotes the
        // predeclared value nil.
    **/
    @:keep
    public dynamic function isNil():Bool return __self__.value.isNil();
    /**
        // IsValue reports whether the corresponding expression is a value.
        // Builtins are not considered values. Constant values have a non-
        // nil Value.
    **/
    @:keep
    public dynamic function isValue():Bool return __self__.value.isValue();
    /**
        // IsBuiltin reports whether the corresponding expression denotes
        // a (possibly parenthesized) built-in function.
    **/
    @:keep
    public dynamic function isBuiltin():Bool return __self__.value.isBuiltin();
    /**
        // IsType reports whether the corresponding expression specifies a type.
    **/
    @:keep
    public dynamic function isType():Bool return __self__.value.isType();
    /**
        // IsVoid reports whether the corresponding expression
        // is a function call without results.
    **/
    @:keep
    public dynamic function isVoid():Bool return __self__.value.isVoid();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<TypeAndValue>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.TypeAndValue_asInterface) class TypeAndValue_static_extension {
    /**
        // HasOk reports whether the corresponding expression may be
        // used on the rhs of a comma-ok assignment.
    **/
    @:keep
    static public function hasOk( _tv:TypeAndValue):Bool {
        return (_tv._mode == (8 : stdgo.go.types.Types.T_operandMode)) || (_tv._mode == (6 : stdgo.go.types.Types.T_operandMode));
    }
    /**
        // Assignable reports whether the corresponding expression
        // is assignable to (provided a value of the right type).
    **/
    @:keep
    static public function assignable( _tv:TypeAndValue):Bool {
        return (_tv._mode == (5 : stdgo.go.types.Types.T_operandMode)) || (_tv._mode == (6 : stdgo.go.types.Types.T_operandMode));
    }
    /**
        // Addressable reports whether the corresponding expression
        // is addressable (https://golang.org/ref/spec#Address_operators).
    **/
    @:keep
    static public function addressable( _tv:TypeAndValue):Bool {
        return _tv._mode == ((5 : stdgo.go.types.Types.T_operandMode));
    }
    /**
        // IsNil reports whether the corresponding expression denotes the
        // predeclared value nil.
    **/
    @:keep
    static public function isNil( _tv:TypeAndValue):Bool {
        return (_tv._mode == (7 : stdgo.go.types.Types.T_operandMode)) && (Go.toInterface(_tv.type) == Go.toInterface(Go.asInterface(typ[((25 : stdgo.go.types.Types.BasicKind) : GoInt)])));
    }
    /**
        // IsValue reports whether the corresponding expression is a value.
        // Builtins are not considered values. Constant values have a non-
        // nil Value.
    **/
    @:keep
    static public function isValue( _tv:TypeAndValue):Bool {
        {
            final __value__ = _tv._mode;
            if (__value__ == ((4 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((5 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((6 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((7 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((8 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((9 : stdgo.go.types.Types.T_operandMode))) {
                return true;
            };
        };
        return false;
    }
    /**
        // IsBuiltin reports whether the corresponding expression denotes
        // a (possibly parenthesized) built-in function.
    **/
    @:keep
    static public function isBuiltin( _tv:TypeAndValue):Bool {
        return _tv._mode == ((2 : stdgo.go.types.Types.T_operandMode));
    }
    /**
        // IsType reports whether the corresponding expression specifies a type.
    **/
    @:keep
    static public function isType( _tv:TypeAndValue):Bool {
        return _tv._mode == ((3 : stdgo.go.types.Types.T_operandMode));
    }
    /**
        // IsVoid reports whether the corresponding expression
        // is a function call without results.
    **/
    @:keep
    static public function isVoid( _tv:TypeAndValue):Bool {
        return _tv._mode == ((1 : stdgo.go.types.Types.T_operandMode));
    }
}
class Initializer_asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Initializer>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Initializer_asInterface) class Initializer_static_extension {
    @:keep
    static public function string( _init:Ref<Initializer>):GoString {
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        for (_i => _lhs in _init.lhs) {
            if (_i > (0 : GoInt)) {
                _buf.writeString((", " : GoString));
            };
            _buf.writeString(_lhs.name());
        };
        _buf.writeString((" = " : GoString));
        writeExpr((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>), _init.rhs);
        return (_buf.string() : GoString);
    }
}
class Array__asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type return __self__.value.underlying();
    /**
        // Elem returns element type of array a.
    **/
    @:keep
    public dynamic function elem():Type return __self__.value.elem();
    /**
        // Len returns the length of array a.
        // A negative result indicates an unknown length.
    **/
    @:keep
    public dynamic function len():GoInt64 return __self__.value.len();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Array_>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Array__asInterface) class Array__static_extension {
    @:keep
    static public function string( _t:Ref<Array_>):GoString {
        return typeString(Go.asInterface(_t), null);
    }
    @:keep
    static public function underlying( _t:Ref<Array_>):Type {
        return Go.asInterface(_t);
    }
    /**
        // Elem returns element type of array a.
    **/
    @:keep
    static public function elem( _a:Ref<Array_>):Type {
        return _a._elem;
    }
    /**
        // Len returns the length of array a.
        // A negative result indicates an unknown length.
    **/
    @:keep
    static public function len( _a:Ref<Array_>):GoInt64 {
        return _a._len;
    }
}
class Basic_asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type return __self__.value.underlying();
    /**
        // Name returns the name of basic type b.
    **/
    @:keep
    public dynamic function name():GoString return __self__.value.name();
    /**
        // Info returns information about properties of basic type b.
    **/
    @:keep
    public dynamic function info():BasicInfo return __self__.value.info();
    /**
        // Kind returns the kind of basic type b.
    **/
    @:keep
    public dynamic function kind():BasicKind return __self__.value.kind();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Basic>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Basic_asInterface) class Basic_static_extension {
    @:keep
    static public function string( _t:Ref<Basic>):GoString {
        return typeString(Go.asInterface(_t), null);
    }
    @:keep
    static public function underlying( _t:Ref<Basic>):Type {
        return Go.asInterface(_t);
    }
    /**
        // Name returns the name of basic type b.
    **/
    @:keep
    static public function name( _b:Ref<Basic>):GoString {
        return _b._name;
    }
    /**
        // Info returns information about properties of basic type b.
    **/
    @:keep
    static public function info( _b:Ref<Basic>):BasicInfo {
        return _b._info;
    }
    /**
        // Kind returns the kind of basic type b.
    **/
    @:keep
    static public function kind( _b:Ref<Basic>):BasicKind {
        return _b._kind;
    }
}
class Chan_asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type return __self__.value.underlying();
    /**
        // Elem returns the element type of channel c.
    **/
    @:keep
    public dynamic function elem():Type return __self__.value.elem();
    /**
        // Dir returns the direction of channel c.
    **/
    @:keep
    public dynamic function dir():ChanDir return __self__.value.dir();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Chan>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Chan_asInterface) class Chan_static_extension {
    @:keep
    static public function string( _t:Ref<Chan>):GoString {
        return typeString(Go.asInterface(_t), null);
    }
    @:keep
    static public function underlying( _t:Ref<Chan>):Type {
        return Go.asInterface(_t);
    }
    /**
        // Elem returns the element type of channel c.
    **/
    @:keep
    static public function elem( _c:Ref<Chan>):Type {
        return _c._elem;
    }
    /**
        // Dir returns the direction of channel c.
    **/
    @:keep
    static public function dir( _c:Ref<Chan>):ChanDir {
        return _c._dir;
    }
}
class T_environment_asInterface {
    /**
        // lookup looks up name in the current environment and returns the matching object, or nil.
    **/
    @:keep
    public dynamic function _lookup(_name:GoString):Object return __self__.value._lookup(_name);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_environment>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_environment_asInterface) class T_environment_static_extension {
    /**
        // lookup looks up name in the current environment and returns the matching object, or nil.
    **/
    @:keep
    static public function _lookup( _env:Ref<T_environment>, _name:GoString):Object {
        var __tmp__ = _env._scope.lookupParent(_name, _env._pos), __0:Ref<stdgo.go.types.Types.Scope> = __tmp__._0, _obj:stdgo.go.types.Types.Object = __tmp__._1;
        return _obj;
    }
}
class T_action_asInterface {
    /**
        // If debug is set, describef sets a printf-formatted description for action a.
        // Otherwise, it is a no-op.
    **/
    @:keep
    public dynamic function _describef(_pos:T_positioner, _format:GoString, _args:haxe.Rest<AnyInterface>):Void __self__.value._describef(_pos, _format, ..._args);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_action>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_action_asInterface) class T_action_static_extension {
    /**
        // If debug is set, describef sets a printf-formatted description for action a.
        // Otherwise, it is a no-op.
    **/
    @:keep
    static public function _describef( _a:Ref<T_action>, _pos:T_positioner, _format:GoString, _args:haxe.Rest<AnyInterface>):Void {
        var _args = new Slice<AnyInterface>(_args.length, 0, ..._args);
        if (false) {
            _a._desc = (Go.setRef((new T_actionDesc(_pos, _format, _args) : T_actionDesc)) : Ref<stdgo.go.types.Types.T_actionDesc>);
        };
    }
}
class Checker_asInterface {
    /**
        // allowVersion reports whether the given package
        // is allowed to use version major.minor.
    **/
    @:keep
    public dynamic function _allowVersion(_pkg:Ref<Package>, _major:GoInt, _minor:GoInt):Bool return __self__.value._allowVersion(_pkg, _major, _minor);
    /**
        // langCompat reports an error if the representation of a numeric
        // literal is not compatible with the current language version.
    **/
    @:keep
    public dynamic function _langCompat(_lit:Ref<stdgo.go.ast.Ast.BasicLit>):Void __self__.value._langCompat(_lit);
    /**
        // validType0 checks if the given type is valid. If typ is a type parameter
        // its value is looked up in the type argument list of the instantiated
        // (enclosing) type, if it exists. Otherwise the type parameter must be from
        // an enclosing function and can be ignored.
        // The nest list describes the stack (the "nest in memory") of types which
        // contain (or embed in the case of interfaces) other types. For instance, a
        // struct named S which contains a field of named type F contains (the memory
        // of) F in S, leading to the nest S->F. If a type appears in its own nest
        // (say S->F->S) we have an invalid recursive type. The path list is the full
        // path of named types in a cycle, it is only needed for error reporting.
    **/
    @:keep
    public dynamic function _validType0(_typ:Type, _nest:Slice<Ref<Named>>, _path:Slice<Ref<Named>>):Bool return __self__.value._validType0(_typ, _nest, _path);
    /**
        // validType verifies that the given type does not "expand" indefinitely
        // producing a cycle in the type graph.
        // (Cycles involving alias types, as in "type A = [10]A" are detected
        // earlier, via the objDecl cycle detection mechanism.)
    **/
    @:keep
    public dynamic function _validType(_typ:Ref<Named>):Void __self__.value._validType(_typ);
    /**
        // typeList provides the list of types corresponding to the incoming expression list.
        // If an error occurred, the result is nil, but all list elements were type-checked.
    **/
    @:keep
    public dynamic function _typeList(_list:Slice<stdgo.go.ast.Ast.Expr>):Slice<Type> return __self__.value._typeList(_list);
    /**
        // arrayLength type-checks the array length expression e
        // and returns the constant length >= 0, or a value < 0
        // to indicate an error (and thus an unknown length).
    **/
    @:keep
    public dynamic function _arrayLength(_e:stdgo.go.ast.Ast.Expr):GoInt64 return __self__.value._arrayLength(_e);
    @:keep
    public dynamic function _instantiatedType(_ix:Ref<stdgo.go.internal.typeparams.Typeparams.IndexExpr>, _def:Ref<Named>):Type return __self__.value._instantiatedType(_ix, _def);
    /**
        // typInternal drives type checking of types.
        // Must only be called by definedType or genericType.
    **/
    @:keep
    public dynamic function _typInternal(_e0:stdgo.go.ast.Ast.Expr, _def:Ref<Named>):Type return __self__.value._typInternal(_e0, _def);
    /**
        // genericType is like typ but the type must be an (uninstantiated) generic
        // type. If cause is non-nil and the type expression was a valid type but not
        // generic, cause will be populated with a message describing the error.
    **/
    @:keep
    public dynamic function _genericType(_e:stdgo.go.ast.Ast.Expr, _cause:Pointer<GoString>):Type return __self__.value._genericType(_e, _cause);
    /**
        // definedType is like typ but also accepts a type name def.
        // If def != nil, e is the type specification for the defined type def, declared
        // in a type declaration, and def.underlying will be set to the type of e before
        // any components of e are type-checked.
    **/
    @:keep
    public dynamic function _definedType(_e:stdgo.go.ast.Ast.Expr, _def:Ref<Named>):Type return __self__.value._definedType(_e, _def);
    /**
        // validVarType reports an error if typ is a constraint interface.
        // The expression e is used for error reporting, if any.
    **/
    @:keep
    public dynamic function _validVarType(_e:stdgo.go.ast.Ast.Expr, _typ:Type):Void __self__.value._validVarType(_e, _typ);
    /**
        // varType type-checks the type expression e and returns its type, or Typ[Invalid].
        // The type must not be an (uninstantiated) generic type and it must not be a
        // constraint interface.
    **/
    @:keep
    public dynamic function _varType(_e:stdgo.go.ast.Ast.Expr):Type return __self__.value._varType(_e);
    /**
        // typ type-checks the type expression e and returns its type, or Typ[Invalid].
        // The type must not be an (uninstantiated) generic type.
    **/
    @:keep
    public dynamic function _typ(_e:stdgo.go.ast.Ast.Expr):Type return __self__.value._typ(_e);
    /**
        // ident type-checks identifier e and initializes x with the value or type of e.
        // If an error occurred, x.mode is set to invalid.
        // For the meaning of def, see Checker.definedType, below.
        // If wantType is set, the identifier e is expected to denote a type.
    **/
    @:keep
    public dynamic function _ident(_x:Ref<T_operand>, _e:Ref<stdgo.go.ast.Ast.Ident>, _def:Ref<Named>, _wantType:Bool):Void __self__.value._ident(_x, _e, _def, _wantType);
    /**
        // check may be nil
    **/
    @:keep
    public dynamic function _newTypeParam(_obj:Ref<TypeName>, _constraint:Type):Ref<TypeParam> return __self__.value._newTypeParam(_obj, _constraint);
    /**
        // subst returns the type typ with its type parameters tpars replaced by the
        // corresponding type arguments targs, recursively. subst is pure in the sense
        // that it doesn't modify the incoming type. If a substitution took place, the
        // result type is different from the incoming type.
        //
        // If expanding is non-nil, it is the instance type currently being expanded.
        // One of expanding or ctxt must be non-nil.
    **/
    @:keep
    public dynamic function _subst(_pos:stdgo.go.token.Token.Pos, _typ:Type, _smap:T_substMap, _expanding:Ref<Named>, _ctxt:Ref<Context>):Type return __self__.value._subst(_pos, _typ, _smap, _expanding, _ctxt);
    @:keep
    public dynamic function _tag(_t:Ref<stdgo.go.ast.Ast.BasicLit>):GoString return __self__.value._tag(_t);
    @:keep
    public dynamic function _declareInSet(_oset:Ref<T_objset>, _pos:stdgo.go.token.Token.Pos, _obj:Object):Bool return __self__.value._declareInSet(_oset, _pos, _obj);
    @:keep
    public dynamic function _structType(_styp:Ref<Struct>, _e:Ref<stdgo.go.ast.Ast.StructType>):Void __self__.value._structType(_styp, _e);
    /**
        // stmt typechecks statement s.
    **/
    @:keep
    public dynamic function _stmt(_ctxt:T_stmtContext, _s:stdgo.go.ast.Ast.Stmt):Void __self__.value._stmt(_ctxt, _s);
    /**
        // If the type switch expression is invalid, x is nil.
    **/
    @:keep
    public dynamic function _caseTypes(_x:Ref<T_operand>, _types:Slice<stdgo.go.ast.Ast.Expr>, _seen:GoMap<Type, stdgo.go.ast.Ast.Expr>):Type return __self__.value._caseTypes(_x, _types, _seen);
    /**
        // isNil reports whether the expression e denotes the predeclared value nil.
    **/
    @:keep
    public dynamic function _isNil(_e:stdgo.go.ast.Ast.Expr):Bool return __self__.value._isNil(_e);
    @:keep
    public dynamic function _caseValues(_x:Ref<T_operand>, _values:Slice<stdgo.go.ast.Ast.Expr>, _seen:T_valueMap):Void __self__.value._caseValues(_x, _values, _seen);
    @:keep
    public dynamic function _suspendedCall(_keyword:GoString, _call:Ref<stdgo.go.ast.Ast.CallExpr>):Void __self__.value._suspendedCall(_keyword, _call);
    @:keep
    public dynamic function _closeScope():Void __self__.value._closeScope();
    @:keep
    public dynamic function _openScope(_node:stdgo.go.ast.Ast.Node, _comment:GoString):Void __self__.value._openScope(_node, _comment);
    @:keep
    public dynamic function _multipleDefaults(_list:Slice<stdgo.go.ast.Ast.Stmt>):Void __self__.value._multipleDefaults(_list);
    @:keep
    public dynamic function _stmtList(_ctxt:T_stmtContext, _list:Slice<stdgo.go.ast.Ast.Stmt>):Void __self__.value._stmtList(_ctxt, _list);
    @:keep
    public dynamic function _simpleStmt(_s:stdgo.go.ast.Ast.Stmt):Void __self__.value._simpleStmt(_s);
    @:keep
    public dynamic function _usage(_scope:Ref<Scope>):Void __self__.value._usage(_scope);
    @:keep
    public dynamic function _funcBody(_decl:Ref<T_declInfo>, _name:GoString, _sig:Ref<Signature>, _body:Ref<stdgo.go.ast.Ast.BlockStmt>, _iota:stdgo.go.constant.Constant.Value):Void __self__.value._funcBody(_decl, _name, _sig, _body, _iota);
    /**
        // collectParams declares the parameters of list in scope and returns the corresponding
        // variable list.
    **/
    @:keep
    public dynamic function _collectParams(_scope:Ref<Scope>, _list:Ref<stdgo.go.ast.Ast.FieldList>, _variadicOk:Bool):{ var _0 : Slice<Ref<Var>>; var _1 : Bool; } return __self__.value._collectParams(_scope, _list, _variadicOk);
    /**
        // funcType type-checks a function or method type.
    **/
    @:keep
    public dynamic function _funcType(_sig:Ref<Signature>, _recvPar:Ref<stdgo.go.ast.Ast.FieldList>, _ftyp:Ref<stdgo.go.ast.Ast.FuncType>):Void __self__.value._funcType(_sig, _recvPar, _ftyp);
    @:keep
    public dynamic function _isTerminatingSwitch(_body:Ref<stdgo.go.ast.Ast.BlockStmt>, _label:GoString):Bool return __self__.value._isTerminatingSwitch(_body, _label);
    @:keep
    public dynamic function _isTerminatingList(_list:Slice<stdgo.go.ast.Ast.Stmt>, _label:GoString):Bool return __self__.value._isTerminatingList(_list, _label);
    /**
        // isTerminating reports if s is a terminating statement.
        // If s is labeled, label is the label name; otherwise s
        // is "".
    **/
    @:keep
    public dynamic function _isTerminating(_s:stdgo.go.ast.Ast.Stmt, _label:GoString):Bool return __self__.value._isTerminating(_s, _label);
    @:keep
    public dynamic function _errorUnusedPkg(_obj:Ref<PkgName>):Void __self__.value._errorUnusedPkg(_obj);
    /**
        // unusedImports checks for unused imports.
    **/
    @:keep
    public dynamic function _unusedImports():Void __self__.value._unusedImports();
    /**
        // packageObjects typechecks all package objects, but not function bodies.
    **/
    @:keep
    public dynamic function _packageObjects():Void __self__.value._packageObjects();
    /**
        // resolveBaseTypeName returns the non-alias base type name for typ, and whether
        // there was a pointer indirection to get to it. The base type name must be declared
        // in package scope, and there can be at most one pointer indirection. If no such type
        // name exists, the returned base is nil.
    **/
    @:keep
    public dynamic function _resolveBaseTypeName(_seenPtr:Bool, _name:Ref<stdgo.go.ast.Ast.Ident>):{ var _0 : Bool; var _1 : Ref<TypeName>; } return __self__.value._resolveBaseTypeName(_seenPtr, _name);
    /**
        // unpackRecv unpacks a receiver type and returns its components: ptr indicates whether
        // rtyp is a pointer receiver, rname is the receiver type name, and tparams are its
        // type parameters, if any. The type parameters are only unpacked if unpackParams is
        // set. If rname is nil, the receiver is unusable (i.e., the source has a bug which we
        // cannot easily work around).
    **/
    @:keep
    public dynamic function _unpackRecv(_rtyp:stdgo.go.ast.Ast.Expr, _unpackParams:Bool):{ var _0 : Bool; var _1 : Ref<stdgo.go.ast.Ast.Ident>; var _2 : Slice<Ref<stdgo.go.ast.Ast.Ident>>; } return __self__.value._unpackRecv(_rtyp, _unpackParams);
    /**
        // collectObjects collects all file and package objects and inserts them
        // into their respective scopes. It also performs imports and associates
        // methods with receiver base type names.
    **/
    @:keep
    public dynamic function _collectObjects():Void __self__.value._collectObjects();
    @:keep
    public dynamic function _importPackage(_at:T_positioner, _path:GoString, _dir:GoString):Ref<Package> return __self__.value._importPackage(_at, _path, _dir);
    /**
        // filename returns a filename suitable for debugging output.
    **/
    @:keep
    public dynamic function _filename(_fileNo:GoInt):GoString return __self__.value._filename(_fileNo);
    /**
        // declarePkgObj declares obj in the package scope, records its ident -> obj mapping,
        // and updates check.objMap. The object must not be a function or method.
    **/
    @:keep
    public dynamic function _declarePkgObj(_ident:Ref<stdgo.go.ast.Ast.Ident>, _obj:Object, _d:Ref<T_declInfo>):Void __self__.value._declarePkgObj(_ident, _obj, _d);
    /**
        // arityMatch checks that the lhs and rhs of a const or var decl
        // have the appropriate number of names and init exprs. For const
        // decls, init is the value spec providing the init exprs; for
        // var decls, init is nil (the init exprs are in s in this case).
    **/
    @:keep
    public dynamic function _arityMatch(_s:Ref<stdgo.go.ast.Ast.ValueSpec>, _init:Ref<stdgo.go.ast.Ast.ValueSpec>):Void __self__.value._arityMatch(_s, _init);
    /**
        // context returns the type-checker context.
    **/
    @:keep
    public dynamic function _context():Ref<Context> return __self__.value._context();
    /**
        // newNamedInstance creates a new named instance for the given origin and type
        // arguments, recording pos as the position of its synthetic object (for error
        // reporting).
        //
        // If set, expanding is the named type instance currently being expanded, that
        // led to the creation of this instance.
    **/
    @:keep
    public dynamic function _newNamedInstance(_pos:stdgo.go.token.Token.Pos, _orig:Ref<Named>, _targs:Slice<Type>, _expanding:Ref<Named>):Ref<Named> return __self__.value._newNamedInstance(_pos, _orig, _targs, _expanding);
    /**
        // newNamed is like NewNamed but with a *Checker receiver and additional orig argument.
    **/
    @:keep
    public dynamic function _newNamed(_obj:Ref<TypeName>, _underlying:Type, _methods:Slice<Ref<Func>>):Ref<Named> return __self__.value._newNamed(_obj, _underlying, _methods);
    @:keep
    public dynamic function _reportInstanceLoop(_v:GoInt):Void __self__.value._reportInstanceLoop(_v);
    @:keep
    public dynamic function _monomorph():Void __self__.value._monomorph();
    /**
        // newAssertableTo reports whether a value of type V can be asserted to have type T.
        // It also implements behavior for interfaces that currently are only permitted
        // in constraint position (we have not yet defined that behavior in the spec).
    **/
    @:keep
    public dynamic function _newAssertableTo(v:Ref<Interface>, t:Type):Bool return __self__.value._newAssertableTo(v, t);
    /**
        // assertableTo reports whether a value of type V can be asserted to have type T.
        // It returns (nil, false) as affirmative answer. Otherwise it returns a missing
        // method required by V and whether it is missing or just has the wrong type.
        // The receiver may be nil if assertableTo is invoked through an exported API call
        // (such as AssertableTo), i.e., when all methods have been type-checked.
        // TODO(gri) replace calls to this function with calls to newAssertableTo.
    **/
    @:keep
    public dynamic function _assertableTo(v:Ref<Interface>, t:Type):{ var _0 : Ref<Func>; var _1 : Ref<Func>; } return __self__.value._assertableTo(v, t);
    /**
        // funcString returns a string of the form name + signature for f.
        // check may be nil.
    **/
    @:keep
    public dynamic function _funcString(_f:Ref<Func>, _pkgInfo:Bool):GoString return __self__.value._funcString(_f, _pkgInfo);
    /**
        // check may be nil.
    **/
    @:keep
    public dynamic function _interfacePtrError(t:Type):GoString return __self__.value._interfacePtrError(t);
    /**
        // missingMethodCause returns a string giving the detailed cause for a missing method m,
        // where m is missing from V, but required by T. It puts the cause in parentheses,
        // and may include more have/want info after that. If non-nil, alt is a relevant
        // method that matches in some way. It may have the correct name, but wrong type, or
        // it may have a pointer receiver, or it may have the correct name except wrong case.
        // check may be nil.
    **/
    @:keep
    public dynamic function _missingMethodCause(v:Type, t:Type, _m:Ref<Func>, _alt:Ref<Func>):GoString return __self__.value._missingMethodCause(v, t, _m, _alt);
    /**
        // missingMethod is like MissingMethod but accepts a *Checker as receiver.
        // The receiver may be nil if missingMethod is invoked through an exported
        // API call (such as MissingMethod), i.e., when all methods have been type-
        // checked.
        //
        // If a method is missing on T but is found on *T, or if a method is found
        // on T when looked up with case-folding, this alternative method is returned
        // as the second result.
    **/
    @:keep
    public dynamic function _missingMethod(v:Type, t:Ref<Interface>, _static:Bool):{ var _0 : Ref<Func>; var _1 : Ref<Func>; } return __self__.value._missingMethod(v, t, _static);
    /**
        // blockBranches processes a block's statement list and returns the set of outgoing forward jumps.
        // all is the scope of all declared labels, parent the set of labels declared in the immediately
        // enclosing block, and lstmt is the labeled statement this block is associated with (or nil).
    **/
    @:keep
    public dynamic function _blockBranches(_all:Ref<Scope>, _parent:Ref<T_block>, _lstmt:Ref<stdgo.go.ast.Ast.LabeledStmt>, _list:Slice<stdgo.go.ast.Ast.Stmt>):Slice<Ref<stdgo.go.ast.Ast.BranchStmt>> return __self__.value._blockBranches(_all, _parent, _lstmt, _list);
    /**
        // labels checks correct label use in body.
    **/
    @:keep
    public dynamic function _labels(_body:Ref<stdgo.go.ast.Ast.BlockStmt>):Void __self__.value._labels(_body);
    @:keep
    public dynamic function _interfaceType(_ityp:Ref<Interface>, _iface:Ref<stdgo.go.ast.Ast.InterfaceType>, _def:Ref<Named>):Void __self__.value._interfaceType(_ityp, _iface, _def);
    /**
        // check may be nil
    **/
    @:keep
    public dynamic function _newInterface():Ref<Interface> return __self__.value._newInterface();
    /**
        // implements checks if V implements T. The receiver may be nil if implements
        // is called through an exported API call such as AssignableTo. If constraint
        // is set, T is a type constraint.
        //
        // If the provided cause is non-nil, it may be set to an error string
        // explaining why V does not implement (or satisfy, for constraints) T.
    **/
    @:keep
    public dynamic function _implements(v:Type, t:Type, _constraint:Bool, _cause:Pointer<GoString>):Bool return __self__.value._implements(v, t, _constraint, _cause);
    @:keep
    public dynamic function _verify(_pos:stdgo.go.token.Token.Pos, _tparams:Slice<Ref<TypeParam>>, _targs:Slice<Type>, _ctxt:Ref<Context>):{ var _0 : GoInt; var _1 : Error; } return __self__.value._verify(_pos, _tparams, _targs, _ctxt);
    /**
        // validateTArgLen verifies that the length of targs and tparams matches,
        // reporting an error if not. If validation fails and check is nil,
        // validateTArgLen panics.
    **/
    @:keep
    public dynamic function _validateTArgLen(_pos:stdgo.go.token.Token.Pos, _ntparams:GoInt, _ntargs:GoInt):Bool return __self__.value._validateTArgLen(_pos, _ntparams, _ntargs);
    /**
        // instance instantiates the given original (generic) function or type with the
        // provided type arguments and returns the resulting instance. If an identical
        // instance exists already in the given contexts, it returns that instance,
        // otherwise it creates a new one.
        //
        // If expanding is non-nil, it is the Named instance type currently being
        // expanded. If ctxt is non-nil, it is the context associated with the current
        // type-checking pass or call to Instantiate. At least one of expanding or ctxt
        // must be non-nil.
        //
        // For Named types the resulting instance may be unexpanded.
    **/
    @:keep
    public dynamic function _instance(_pos:stdgo.go.token.Token.Pos, _orig:Type, _targs:Slice<Type>, _expanding:Ref<Named>, _ctxt:Ref<Context>):Type return __self__.value._instance(_pos, _orig, _targs, _expanding, _ctxt);
    /**
        // reportCycle reports an error for the given cycle.
    **/
    @:keep
    public dynamic function _reportCycle(_cycle:Slice<Object>):Void __self__.value._reportCycle(_cycle);
    /**
        // initOrder computes the Info.InitOrder for package variables.
    **/
    @:keep
    public dynamic function _initOrder():Void __self__.value._initOrder();
    /**
        // inferB returns the list of actual type arguments inferred from the type parameters'
        // bounds and an initial set of type arguments. If type inference is impossible because
        // unification fails, an error is reported if report is set to true, the resulting types
        // list is nil, and index is 0.
        // Otherwise, types is the list of inferred type arguments, and index is the index of the
        // first type argument in that list that couldn't be inferred (and thus is nil). If all
        // type arguments were inferred successfully, index is < 0. The number of type arguments
        // provided may be less than the number of type parameters, but there must be at least one.
    **/
    @:keep
    public dynamic function _inferB(_posn:T_positioner, _tparams:Slice<Ref<TypeParam>>, _targs:Slice<Type>):{ var _0 : Slice<Type>; var _1 : GoInt; } return __self__.value._inferB(_posn, _tparams, _targs);
    /**
        // infer attempts to infer the complete set of type arguments for generic function instantiation/call
        // based on the given type parameters tparams, type arguments targs, function parameters params, and
        // function arguments args, if any. There must be at least one type parameter, no more type arguments
        // than type parameters, and params and args must match in number (incl. zero).
        // If successful, infer returns the complete list of type arguments, one for each type parameter.
        // Otherwise the result is nil and appropriate errors will be reported.
        //
        // Inference proceeds as follows:
        //
        //	Starting with given type arguments
        //	1) apply FTI (function type inference) with typed arguments,
        //	2) apply CTI (constraint type inference),
        //	3) apply FTI with untyped function arguments,
        //	4) apply CTI.
        //
        // The process stops as soon as all type arguments are known or an error occurs.
    **/
    @:keep
    public dynamic function _infer(_posn:T_positioner, _tparams:Slice<Ref<TypeParam>>, _targs:Slice<Type>, _params:Ref<Tuple>, _args:Slice<Ref<T_operand>>):Slice<Type> return __self__.value._infer(_posn, _tparams, _targs, _params, _args);
    /**
        // indexElts checks the elements (elts) of an array or slice composite literal
        // against the literal's element type (typ), and the element indices against
        // the literal length if known (length >= 0). It returns the length of the
        // literal (maximum index value + 1).
    **/
    @:keep
    public dynamic function _indexedElts(_elts:Slice<stdgo.go.ast.Ast.Expr>, _typ:Type, _length:GoInt64):GoInt64 return __self__.value._indexedElts(_elts, _typ, _length);
    @:keep
    public dynamic function _isValidIndex(_x:Ref<T_operand>, _code:Code, _what:GoString, _allowNegative:Bool):Bool return __self__.value._isValidIndex(_x, _code, _what, _allowNegative);
    /**
        // index checks an index expression for validity.
        // If max >= 0, it is the upper bound for index.
        // If the result typ is != Typ[Invalid], index is valid and typ is its (possibly named) integer type.
        // If the result val >= 0, index is valid and val is its constant int value.
    **/
    @:keep
    public dynamic function _index(_index:stdgo.go.ast.Ast.Expr, _max:GoInt64):{ var _0 : Type; var _1 : GoInt64; } return __self__.value._index(_index, _max);
    /**
        // singleIndex returns the (single) index from the index expression e.
        // If the index is missing, or if there are multiple indices, an error
        // is reported and the result is nil.
    **/
    @:keep
    public dynamic function _singleIndex(_expr:Ref<stdgo.go.internal.typeparams.Typeparams.IndexExpr>):stdgo.go.ast.Ast.Expr return __self__.value._singleIndex(_expr);
    @:keep
    public dynamic function _sliceExpr(_x:Ref<T_operand>, _e:Ref<stdgo.go.ast.Ast.SliceExpr>):Void __self__.value._sliceExpr(_x, _e);
    /**
        // If e is a valid function instantiation, indexExpr returns true.
        // In that case x represents the uninstantiated function value and
        // it is the caller's responsibility to instantiate the function.
    **/
    @:keep
    public dynamic function _indexExpr(_x:Ref<T_operand>, _e:Ref<stdgo.go.internal.typeparams.Typeparams.IndexExpr>):Bool return __self__.value._indexExpr(_x, _e);
    /**
        // singleValue reports an error if x describes a tuple and sets x.mode to invalid.
    **/
    @:keep
    public dynamic function _singleValue(_x:Ref<T_operand>):Void __self__.value._singleValue(_x);
    /**
        // exclude reports an error if x.mode is in modeset and sets x.mode to invalid.
        // The modeset may contain any of 1<<novalue, 1<<builtin, 1<<typexpr.
    **/
    @:keep
    public dynamic function _exclude(_x:Ref<T_operand>, _modeset:GoUInt):Void __self__.value._exclude(_x, _modeset);
    /**
        // exprOrType typechecks expression or type e and initializes x with the expression value or type.
        // If allowGeneric is set, the operand type may be an uninstantiated parameterized type or function
        // value.
        // If an error occurred, x.mode is set to invalid.
    **/
    @:keep
    public dynamic function _exprOrType(_x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _allowGeneric:Bool):Void __self__.value._exprOrType(_x, _e, _allowGeneric);
    /**
        // exprWithHint typechecks expression e and initializes x with the expression value;
        // hint is the type of a composite literal element.
        // If an error occurred, x.mode is set to invalid.
    **/
    @:keep
    public dynamic function _exprWithHint(_x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _hint:Type):Void __self__.value._exprWithHint(_x, _e, _hint);
    /**
        // multiExpr is like expr but the result may also be a multi-value.
    **/
    @:keep
    public dynamic function _multiExpr(_x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr):Void __self__.value._multiExpr(_x, _e);
    /**
        // expr typechecks expression e and initializes x with the expression value.
        // The result must be a single value.
        // If an error occurred, x.mode is set to invalid.
    **/
    @:keep
    public dynamic function _expr(_x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr):Void __self__.value._expr(_x, _e);
    /**
        // typeAssertion checks x.(T). The type of x must be an interface.
    **/
    @:keep
    public dynamic function _typeAssertion(_e:stdgo.go.ast.Ast.Expr, _x:Ref<T_operand>, t:Type, _typeSwitch:Bool):Void __self__.value._typeAssertion(_e, _x, t, _typeSwitch);
    /**
        // exprInternal contains the core of type checking of expressions.
        // Must only be called by rawExpr.
    **/
    @:keep
    public dynamic function _exprInternal(_x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _hint:Type):T_exprKind return __self__.value._exprInternal(_x, _e, _hint);
    /**
        // If x is a generic function or type, nonGeneric reports an error and invalidates x.mode and x.typ.
        // Otherwise it leaves x alone.
    **/
    @:keep
    public dynamic function _nonGeneric(_x:Ref<T_operand>):Void __self__.value._nonGeneric(_x);
    /**
        // rawExpr typechecks expression e and initializes x with the expression
        // value or type. If an error occurred, x.mode is set to invalid.
        // If hint != nil, it is the type of a composite literal element.
        // If allowGeneric is set, the operand type may be an uninstantiated
        // parameterized type or function value.
    **/
    @:keep
    public dynamic function _rawExpr(_x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _hint:Type, _allowGeneric:Bool):T_exprKind return __self__.value._rawExpr(_x, _e, _hint, _allowGeneric);
    /**
        // If e != nil, it must be the binary expression; it may be nil for non-constant expressions
        // (when invoked for an assignment operation where the binary expression is implicit).
    **/
    @:keep
    public dynamic function _binary(_x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _lhs:stdgo.go.ast.Ast.Expr, _rhs:stdgo.go.ast.Ast.Expr, _op:stdgo.go.token.Token.Token, _opPos:stdgo.go.token.Token.Pos):Void __self__.value._binary(_x, _e, _lhs, _rhs, _op, _opPos);
    /**
        // If e != nil, it must be the shift expression; it may be nil for non-constant shifts.
    **/
    @:keep
    public dynamic function _shift(_x:Ref<T_operand>, _y:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _op:stdgo.go.token.Token.Token):Void __self__.value._shift(_x, _y, _e, _op);
    /**
        // kindString returns the type kind as a string.
    **/
    @:keep
    public dynamic function _kindString(_typ:Type):GoString return __self__.value._kindString(_typ);
    /**
        // incomparableCause returns a more specific cause why typ is not comparable.
        // If there is no more specific cause, the result is "".
    **/
    @:keep
    public dynamic function _incomparableCause(_typ:Type):GoString return __self__.value._incomparableCause(_typ);
    /**
        // If switchCase is true, the operator op is ignored.
    **/
    @:keep
    public dynamic function _comparison(_x:Ref<T_operand>, _y:Ref<T_operand>, _op:stdgo.go.token.Token.Token, _switchCase:Bool):Void __self__.value._comparison(_x, _y, _op, _switchCase);
    /**
        // implicitTypeAndValue returns the implicit type of x when used in a context
        // where the target type is expected. If no such implicit conversion is
        // possible, it returns a nil Type and non-zero error code.
        //
        // If x is a constant operand, the returned constant.Value will be the
        // representation of x in this context.
    **/
    @:keep
    public dynamic function _implicitTypeAndValue(_x:Ref<T_operand>, _target:Type):{ var _0 : Type; var _1 : stdgo.go.constant.Constant.Value; var _2 : Code; } return __self__.value._implicitTypeAndValue(_x, _target);
    /**
        // convertUntyped attempts to set the type of an untyped value to the target type.
    **/
    @:keep
    public dynamic function _convertUntyped(_x:Ref<T_operand>, _target:Type):Void __self__.value._convertUntyped(_x, _target);
    /**
        // updateExprVal updates the value of x to val.
    **/
    @:keep
    public dynamic function _updateExprVal(_x:stdgo.go.ast.Ast.Expr, _val:stdgo.go.constant.Constant.Value):Void __self__.value._updateExprVal(_x, _val);
    @:keep
    public dynamic function _updateExprType0(_parent:stdgo.go.ast.Ast.Expr, _x:stdgo.go.ast.Ast.Expr, _typ:Type, _final:Bool):Void __self__.value._updateExprType0(_parent, _x, _typ, _final);
    /**
        // updateExprType updates the type of x to typ and invokes itself
        // recursively for the operands of x, depending on expression kind.
        // If typ is still an untyped and not the final type, updateExprType
        // only updates the recorded untyped type for x and possibly its
        // operands. Otherwise (i.e., typ is not an untyped type anymore,
        // or it is the final type for x), the type and value are recorded.
        // Also, if x is a constant, it must be representable as a value of typ,
        // and if x is the (formerly untyped) lhs operand of a non-constant
        // shift, it must be an integer value.
    **/
    @:keep
    public dynamic function _updateExprType(_x:stdgo.go.ast.Ast.Expr, _typ:Type, _final:Bool):Void __self__.value._updateExprType(_x, _typ, _final);
    @:keep
    public dynamic function _invalidConversion(_code:Code, _x:Ref<T_operand>, _target:Type):Void __self__.value._invalidConversion(_code, _x, _target);
    /**
        // representation returns the representation of the constant operand x as the
        // basic type typ.
        //
        // If no such representation is possible, it returns a non-zero error code.
    **/
    @:keep
    public dynamic function _representation(_x:Ref<T_operand>, _typ:Ref<Basic>):{ var _0 : stdgo.go.constant.Constant.Value; var _1 : Code; } return __self__.value._representation(_x, _typ);
    /**
        // representable checks that a constant operand is representable in the given
        // basic type.
    **/
    @:keep
    public dynamic function _representable(_x:Ref<T_operand>, _typ:Ref<Basic>):Void __self__.value._representable(_x, _typ);
    /**
        // The unary expression e may be nil. It's passed in for better error messages only.
    **/
    @:keep
    public dynamic function _unary(_x:Ref<T_operand>, _e:Ref<stdgo.go.ast.Ast.UnaryExpr>):Void __self__.value._unary(_x, _e);
    /**
        // overflow checks that the constant x is representable by its type.
        // For untyped constants, it checks that the value doesn't become
        // arbitrarily large.
    **/
    @:keep
    public dynamic function _overflow(_x:Ref<T_operand>, _opPos:stdgo.go.token.Token.Pos):Void __self__.value._overflow(_x, _opPos);
    @:keep
    public dynamic function _op(_m:T_opPredicates, _x:Ref<T_operand>, _op:stdgo.go.token.Token.Token):Bool return __self__.value._op(_m, _x, _op);
    @:keep
    public dynamic function _versionErrorf(_at:T_positioner, _goVersion:GoString, _format:GoString, _args:haxe.Rest<AnyInterface>):Void __self__.value._versionErrorf(_at, _goVersion, _format, ..._args);
    @:keep
    public dynamic function _softErrorf(_at:T_positioner, _code:Code, _format:GoString, _args:haxe.Rest<AnyInterface>):Void __self__.value._softErrorf(_at, _code, _format, ..._args);
    @:keep
    public dynamic function _errorf(_at:T_positioner, _code:Code, _format:GoString, _args:haxe.Rest<AnyInterface>):Void __self__.value._errorf(_at, _code, _format, ..._args);
    @:keep
    public dynamic function _error(_at:T_positioner, _code:Code, _msg:GoString):Void __self__.value._error(_at, _code, _msg);
    /**
        // Report records the error pointed to by errp, setting check.firstError if
        // necessary.
    **/
    @:keep
    public dynamic function _report(_errp:Ref<T_error_>):Void __self__.value._report(_errp);
    /**
        // dump is only needed for debugging
    **/
    @:keep
    public dynamic function _dump(_format:GoString, _args:haxe.Rest<AnyInterface>):Void __self__.value._dump(_format, ..._args);
    @:keep
    public dynamic function _trace(_pos:stdgo.go.token.Token.Pos, _format:GoString, _args:haxe.Rest<AnyInterface>):Void __self__.value._trace(_pos, _format, ..._args);
    /**
        // check may be nil.
    **/
    @:keep
    public dynamic function _sprintf(_format:GoString, _args:haxe.Rest<AnyInterface>):GoString return __self__.value._sprintf(_format, ..._args);
    /**
        // markImports recursively walks pkg and its imports, to record unique import
        // paths in pkgPathMap.
    **/
    @:keep
    public dynamic function _markImports(_pkg:Ref<Package>):Void __self__.value._markImports(_pkg);
    @:keep
    public dynamic function _qualifier(_pkg:Ref<Package>):GoString return __self__.value._qualifier(_pkg);
    @:keep
    public dynamic function _declStmt(_d:stdgo.go.ast.Ast.Decl):Void __self__.value._declStmt(_d);
    @:keep
    public dynamic function _funcDecl(_obj:Ref<Func>, _decl:Ref<T_declInfo>):Void __self__.value._funcDecl(_obj, _decl);
    @:keep
    public dynamic function _checkFieldUniqueness(_base:Ref<Named>):Void __self__.value._checkFieldUniqueness(_base);
    @:keep
    public dynamic function _collectMethods(_obj:Ref<TypeName>):Void __self__.value._collectMethods(_obj);
    @:keep
    public dynamic function _declareTypeParams(_tparams:Slice<Ref<TypeParam>>, _names:Slice<Ref<stdgo.go.ast.Ast.Ident>>):Slice<Ref<TypeParam>> return __self__.value._declareTypeParams(_tparams, _names);
    @:keep
    public dynamic function _bound(_x:stdgo.go.ast.Ast.Expr):Type return __self__.value._bound(_x);
    @:keep
    public dynamic function _collectTypeParams(_dst:Ref<Ref<TypeParamList>>, _list:Ref<stdgo.go.ast.Ast.FieldList>):Void __self__.value._collectTypeParams(_dst, _list);
    @:keep
    public dynamic function _typeDecl(_obj:Ref<TypeName>, _tdecl:Ref<stdgo.go.ast.Ast.TypeSpec>, _def:Ref<Named>):Void __self__.value._typeDecl(_obj, _tdecl, _def);
    /**
        // isImportedConstraint reports whether typ is an imported type constraint.
    **/
    @:keep
    public dynamic function _isImportedConstraint(_typ:Type):Bool return __self__.value._isImportedConstraint(_typ);
    @:keep
    public dynamic function _varDecl(_obj:Ref<Var>, _lhs:Slice<Ref<Var>>, _typ:stdgo.go.ast.Ast.Expr, _init:stdgo.go.ast.Ast.Expr):Void __self__.value._varDecl(_obj, _lhs, _typ, _init);
    @:keep
    public dynamic function _constDecl(_obj:Ref<Const>, _typ:stdgo.go.ast.Ast.Expr, _init:stdgo.go.ast.Ast.Expr, _inherited:Bool):Void __self__.value._constDecl(_obj, _typ, _init, _inherited);
    @:keep
    public dynamic function _walkDecl(_d:stdgo.go.ast.Ast.Decl, _f:T_decl -> Void):Void __self__.value._walkDecl(_d, _f);
    @:keep
    public dynamic function _walkDecls(_decls:Slice<stdgo.go.ast.Ast.Decl>, _f:T_decl -> Void):Void __self__.value._walkDecls(_decls, _f);
    /**
        // cycleError reports a declaration cycle starting with
        // the object in cycle that is "first" in the source.
    **/
    @:keep
    public dynamic function _cycleError(_cycle:Slice<Object>):Void __self__.value._cycleError(_cycle);
    /**
        // validCycle checks if the cycle starting with obj is valid and
        // reports an error if it is not.
    **/
    @:keep
    public dynamic function _validCycle(_obj:Object):Bool return __self__.value._validCycle(_obj);
    /**
        // objDecl type-checks the declaration of obj in its respective (file) environment.
        // For the meaning of def, see Checker.definedType, in typexpr.go.
    **/
    @:keep
    public dynamic function _objDecl(_obj:Object, _def:Ref<Named>):Void __self__.value._objDecl(_obj, _def);
    @:keep
    public dynamic function _declare(_scope:Ref<Scope>, _id:Ref<stdgo.go.ast.Ast.Ident>, _obj:Object, _pos:stdgo.go.token.Token.Pos):Void __self__.value._declare(_scope, _id, _obj, _pos);
    @:keep
    public dynamic function _reportAltDecl(_obj:Object):Void __self__.value._reportAltDecl(_obj);
    /**
        // Conversion type-checks the conversion T(x).
        // The result is in x.
    **/
    @:keep
    public dynamic function _conversion(_x:Ref<T_operand>, t:Type):Void __self__.value._conversion(_x, t);
    @:keep
    public dynamic function _recordScope(_node:stdgo.go.ast.Ast.Node, _scope:Ref<Scope>):Void __self__.value._recordScope(_node, _scope);
    @:keep
    public dynamic function _recordSelection(_x:Ref<stdgo.go.ast.Ast.SelectorExpr>, _kind:SelectionKind, _recv:Type, _obj:Object, _index:Slice<GoInt>, _indirect:Bool):Void __self__.value._recordSelection(_x, _kind, _recv, _obj, _index, _indirect);
    @:keep
    public dynamic function _recordImplicit(_node:stdgo.go.ast.Ast.Node, _obj:Object):Void __self__.value._recordImplicit(_node, _obj);
    @:keep
    public dynamic function _recordUse(_id:Ref<stdgo.go.ast.Ast.Ident>, _obj:Object):Void __self__.value._recordUse(_id, _obj);
    @:keep
    public dynamic function _recordDef(_id:Ref<stdgo.go.ast.Ast.Ident>, _obj:Object):Void __self__.value._recordDef(_id, _obj);
    /**
        // recordInstance records instantiation information into check.Info, if the
        // Instances map is non-nil. The given expr must be an ident, selector, or
        // index (list) expr with ident or selector operand.
        //
        // TODO(rfindley): the expr parameter is fragile. See if we can access the
        // instantiated identifier in some other way.
    **/
    @:keep
    public dynamic function _recordInstance(_expr:stdgo.go.ast.Ast.Expr, _targs:Slice<Type>, _typ:Type):Void __self__.value._recordInstance(_expr, _targs, _typ);
    @:keep
    public dynamic function _recordCommaOkTypes(_x:stdgo.go.ast.Ast.Expr, _a:GoArray<Type>):Void __self__.value._recordCommaOkTypes(_x, _a);
    @:keep
    public dynamic function _recordBuiltinType(_f:stdgo.go.ast.Ast.Expr, _sig:Ref<Signature>):Void __self__.value._recordBuiltinType(_f, _sig);
    @:keep
    public dynamic function _recordTypeAndValue(_x:stdgo.go.ast.Ast.Expr, _mode:T_operandMode, _typ:Type, _val:stdgo.go.constant.Constant.Value):Void __self__.value._recordTypeAndValue(_x, _mode, _typ, _val);
    @:keep
    public dynamic function _recordUntyped():Void __self__.value._recordUntyped();
    @:keep
    public dynamic function _record(_x:Ref<T_operand>):Void __self__.value._record(_x);
    /**
        // cleanup runs cleanup for all collected cleaners.
    **/
    @:keep
    public dynamic function _cleanup():Void __self__.value._cleanup();
    /**
        // processDelayed processes all delayed actions pushed after top.
    **/
    @:keep
    public dynamic function _processDelayed(_top:GoInt):Void __self__.value._processDelayed(_top);
    @:keep
    public dynamic function _checkFiles(_files:Slice<Ref<stdgo.go.ast.Ast.File>>):Error return __self__.value._checkFiles(_files);
    /**
        // Files checks the provided files as part of the checker's package.
    **/
    @:keep
    public dynamic function files(_files:Slice<Ref<stdgo.go.ast.Ast.File>>):Error return __self__.value.files(_files);
    @:keep
    public dynamic function _handleBailout(_err:Ref<Error>):Void __self__.value._handleBailout(_err);
    /**
        // initFiles initializes the files-specific portion of checker.
        // The provided files must all belong to the same package.
    **/
    @:keep
    public dynamic function _initFiles(_files:Slice<Ref<stdgo.go.ast.Ast.File>>):Void __self__.value._initFiles(_files);
    /**
        // needsCleanup records objects/types that implement the cleanup method
        // which will be called at the end of type-checking.
    **/
    @:keep
    public dynamic function _needsCleanup(_c:T_cleaner):Void __self__.value._needsCleanup(_c);
    /**
        // pop pops and returns the topmost object from the object path.
    **/
    @:keep
    public dynamic function _pop():Object return __self__.value._pop();
    /**
        // push pushes obj onto the object path and returns its index in the path.
    **/
    @:keep
    public dynamic function _push(_obj:Object):GoInt return __self__.value._push(_obj);
    /**
        // later pushes f on to the stack of actions that will be processed later;
        // either at the end of the current statement, or in case of a local constant
        // or variable declaration, before the constant or variable is in scope
        // (so that f still sees the scope before any new declarations).
        // later returns the pushed action so one can provide a description
        // via action.describef for debugging, if desired.
    **/
    @:keep
    public dynamic function _later(_f:() -> Void):Ref<T_action> return __self__.value._later(_f);
    @:keep
    public dynamic function _rememberUntyped(_e:stdgo.go.ast.Ast.Expr, _lhs:Bool, _mode:T_operandMode, _typ:Ref<Basic>, _val:stdgo.go.constant.Constant.Value):Void __self__.value._rememberUntyped(_e, _lhs, _mode, _typ, _val);
    /**
        // isBrokenAlias reports whether alias doesn't have a determined type yet.
    **/
    @:keep
    public dynamic function _isBrokenAlias(_alias:Ref<TypeName>):Bool return __self__.value._isBrokenAlias(_alias);
    /**
        // validAlias records that alias has the valid type typ (possibly Typ[Invalid]).
    **/
    @:keep
    public dynamic function _validAlias(_alias:Ref<TypeName>, _typ:Type):Void __self__.value._validAlias(_alias, _typ);
    /**
        // brokenAlias records that alias doesn't have a determined type yet.
        // It also sets alias.typ to Typ[Invalid].
    **/
    @:keep
    public dynamic function _brokenAlias(_alias:Ref<TypeName>):Void __self__.value._brokenAlias(_alias);
    /**
        // addDeclDep adds the dependency edge (check.decl -> to) if check.decl exists
    **/
    @:keep
    public dynamic function _addDeclDep(_to:Object):Void __self__.value._addDeclDep(_to);
    /**
        // useLHS is like use, but doesn't "use" top-level identifiers.
        // It should be called instead of use if the arguments are
        // expressions on the lhs of an assignment.
        // The arguments must not be nil.
    **/
    @:keep
    public dynamic function _useLHS(_arg:haxe.Rest<stdgo.go.ast.Ast.Expr>):Void __self__.value._useLHS(..._arg);
    /**
        // use type-checks each argument.
        // Useful to make sure expressions are evaluated
        // (and variables are "used") in the presence of other errors.
        // The arguments may be nil.
    **/
    @:keep
    public dynamic function _use(_arg:haxe.Rest<stdgo.go.ast.Ast.Expr>):Void __self__.value._use(..._arg);
    @:keep
    public dynamic function _selector(_x:Ref<T_operand>, _e:Ref<stdgo.go.ast.Ast.SelectorExpr>, _def:Ref<Named>, _wantType:Bool):Void __self__.value._selector(_x, _e, _def, _wantType);
    /**
        // xlist is the list of type argument expressions supplied in the source code.
    **/
    @:keep
    public dynamic function _arguments(_call:Ref<stdgo.go.ast.Ast.CallExpr>, _sig:Ref<Signature>, _targs:Slice<Type>, _args:Slice<Ref<T_operand>>, _xlist:Slice<stdgo.go.ast.Ast.Expr>):Ref<Signature> return __self__.value._arguments(_call, _sig, _targs, _args, _xlist);
    @:keep
    public dynamic function _exprList(_elist:Slice<stdgo.go.ast.Ast.Expr>, _allowCommaOk:Bool):{ var _0 : Slice<Ref<T_operand>>; var _1 : Bool; } return __self__.value._exprList(_elist, _allowCommaOk);
    @:keep
    public dynamic function _callExpr(_x:Ref<T_operand>, _call:Ref<stdgo.go.ast.Ast.CallExpr>):T_exprKind return __self__.value._callExpr(_x, _call);
    @:keep
    public dynamic function _instantiateSignature(_pos:stdgo.go.token.Token.Pos, _typ:Ref<Signature>, _targs:Slice<Type>, _xlist:Slice<stdgo.go.ast.Ast.Expr>):Ref<Signature> return __self__.value._instantiateSignature(_pos, _typ, _targs, _xlist);
    /**
        // funcInst type-checks a function instantiation inst and returns the result in x.
        // The operand x must be the evaluation of inst.X and its type must be a signature.
    **/
    @:keep
    public dynamic function _funcInst(_x:Ref<T_operand>, _ix:Ref<stdgo.go.internal.typeparams.Typeparams.IndexExpr>):Void __self__.value._funcInst(_x, _ix);
    /**
        // applyTypeFunc applies f to x. If x is a type parameter,
        // the result is a type parameter constrained by an new
        // interface bound. The type bounds for that interface
        // are computed by applying f to each of the type bounds
        // of x. If any of these applications of f return nil,
        // applyTypeFunc returns nil.
        // If x is not a type parameter, the result is f(x).
    **/
    @:keep
    public dynamic function _applyTypeFunc(_f:Type -> Type, _x:Ref<T_operand>, _id:T_builtinId):Type return __self__.value._applyTypeFunc(_f, _x, _id);
    /**
        // builtin type-checks a call to the built-in specified by id and
        // reports whether the call is valid, with *x holding the result;
        // but x.expr is not set. If the call is invalid, the result is
        // false, and *x is undefined.
    **/
    @:keep
    public dynamic function _builtin(_x:Ref<T_operand>, _call:Ref<stdgo.go.ast.Ast.CallExpr>, _id:T_builtinId):Bool return __self__.value._builtin(_x, _call, _id);
    @:keep
    public dynamic function _shortVarDecl(_pos:T_positioner, _lhs:Slice<stdgo.go.ast.Ast.Expr>, _rhs:Slice<stdgo.go.ast.Ast.Expr>):Void __self__.value._shortVarDecl(_pos, _lhs, _rhs);
    @:keep
    public dynamic function _assignVars(_lhs:Slice<stdgo.go.ast.Ast.Expr>, _origRHS:Slice<stdgo.go.ast.Ast.Expr>):Void __self__.value._assignVars(_lhs, _origRHS);
    /**
        // If returnStmt != nil, initVars is called to type-check the assignment
        // of return expressions, and returnStmt is the return statement.
    **/
    @:keep
    public dynamic function _initVars(_lhs:Slice<Ref<Var>>, _origRHS:Slice<stdgo.go.ast.Ast.Expr>, _returnStmt:stdgo.go.ast.Ast.Stmt):Void __self__.value._initVars(_lhs, _origRHS, _returnStmt);
    @:keep
    public dynamic function _assignError(_rhs:Slice<stdgo.go.ast.Ast.Expr>, _nvars:GoInt, _nvals:GoInt):Void __self__.value._assignError(_rhs, _nvars, _nvals);
    /**
        // typesSummary returns a string of the form "(t1, t2, ...)" where the
        // ti's are user-friendly string representations for the given types.
        // If variadic is set and the last type is a slice, its string is of
        // the form "...E" where E is the slice's element type.
    **/
    @:keep
    public dynamic function _typesSummary(_list:Slice<Type>, _variadic:Bool):GoString return __self__.value._typesSummary(_list, _variadic);
    @:keep
    public dynamic function _assignVar(_lhs:stdgo.go.ast.Ast.Expr, _x:Ref<T_operand>):Type return __self__.value._assignVar(_lhs, _x);
    @:keep
    public dynamic function _initVar(_lhs:Ref<Var>, _x:Ref<T_operand>, _context:GoString):Type return __self__.value._initVar(_lhs, _x, _context);
    @:keep
    public dynamic function _initConst(_lhs:Ref<Const>, _x:Ref<T_operand>):Void __self__.value._initConst(_lhs, _x);
    /**
        // assignment reports whether x can be assigned to a variable of type T,
        // if necessary by attempting to convert untyped values to the appropriate
        // type. context describes the context in which the assignment takes place.
        // Use T == nil to indicate assignment to an untyped blank identifier.
        // x.mode is set to invalid if the assignment failed.
    **/
    @:keep
    public dynamic function _assignment(_x:Ref<T_operand>, t:Type, _context:GoString):Void __self__.value._assignment(_x, t, _context);
    @:embedded
    public dynamic function _lookup(__0:GoString):stdgo.go.types.Types.Object return __self__.value._lookup(__0);
    @:embedded
    public dynamic function typeOf(_e:stdgo.go.ast.Ast.Expr):stdgo.go.types.Types.Type return __self__.value.typeOf(_e);
    @:embedded
    public dynamic function objectOf(_id:Ref<stdgo.go.ast.Ast.Ident>):stdgo.go.types.Types.Object return __self__.value.objectOf(_id);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Checker>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Checker_asInterface) class Checker_static_extension {
    /**
        // allowVersion reports whether the given package
        // is allowed to use version major.minor.
    **/
    @:keep
    static public function _allowVersion( _check:Ref<Checker>, _pkg:Ref<Package>, _major:GoInt, _minor:GoInt):Bool {
        if (_pkg != (_check._pkg)) {
            return true;
        };
        var __0:GoInt = _check._version._major, __1:GoInt = _check._version._minor, _mi:GoInt = __1, _ma:GoInt = __0;
        return (((_ma == (0 : GoInt)) && (_mi == (0 : GoInt))) || (_ma > _major)) || ((_ma == _major) && (_mi >= _minor));
    }
    /**
        // langCompat reports an error if the representation of a numeric
        // literal is not compatible with the current language version.
    **/
    @:keep
    static public function _langCompat( _check:Ref<Checker>, _lit:Ref<stdgo.go.ast.Ast.BasicLit>):Void {
        var _s:GoString = _lit.value;
        if ((_s.length <= (2 : GoInt)) || _check._allowVersion(_check._pkg, (1 : GoInt), (13 : GoInt))) {
            return;
        };
        if (stdgo.strings.Strings.contains(_s, ("_" : GoString))) {
            _check._error(Go.asInterface(_lit), (135 : stdgo.internal.types.errors.Errors.Code), ("underscores in numeric literals requires go1.13 or later" : GoString));
            return;
        };
        if (_s[(0 : GoInt)] != ((48 : GoUInt8))) {
            return;
        };
        var _radix:GoUInt8 = _s[(1 : GoInt)];
        if ((_radix == (98 : GoUInt8)) || (_radix == (66 : GoUInt8))) {
            _check._error(Go.asInterface(_lit), (135 : stdgo.internal.types.errors.Errors.Code), ("binary literals requires go1.13 or later" : GoString));
            return;
        };
        if ((_radix == (111 : GoUInt8)) || (_radix == (79 : GoUInt8))) {
            _check._error(Go.asInterface(_lit), (135 : stdgo.internal.types.errors.Errors.Code), ("0o/0O-style octal literals requires go1.13 or later" : GoString));
            return;
        };
        if ((_lit.kind != (5 : stdgo.go.token.Token.Token)) && ((_radix == (120 : GoUInt8)) || (_radix == (88 : GoUInt8)))) {
            _check._error(Go.asInterface(_lit), (135 : stdgo.internal.types.errors.Errors.Code), ("hexadecimal floating-point literals requires go1.13 or later" : GoString));
        };
    }
    /**
        // validType0 checks if the given type is valid. If typ is a type parameter
        // its value is looked up in the type argument list of the instantiated
        // (enclosing) type, if it exists. Otherwise the type parameter must be from
        // an enclosing function and can be ignored.
        // The nest list describes the stack (the "nest in memory") of types which
        // contain (or embed in the case of interfaces) other types. For instance, a
        // struct named S which contains a field of named type F contains (the memory
        // of) F in S, leading to the nest S->F. If a type appears in its own nest
        // (say S->F->S) we have an invalid recursive type. The path list is the full
        // path of named types in a cycle, it is only needed for error reporting.
    **/
    @:keep
    static public function _validType0( _check:Ref<Checker>, _typ:Type, _nest:Slice<Ref<Named>>, _path:Slice<Ref<Named>>):Bool {
        {
            final __type__ = _typ;
            {
                var __bool__ = true;
                while (__bool__) {
                    __bool__ = false;
                    if (__type__ == null) {
                        var _t:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
                        if (false) {
                            throw Go.toInterface(("validType0(nil)" : GoString));
                        };
                    } else if (Go.typeEquals((__type__ : Ref<Array_>))) {
                        var _t:Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                        return _check._validType0(_t._elem, _nest, _path);
                    } else if (Go.typeEquals((__type__ : Ref<Struct>))) {
                        var _t:Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                        for (__0 => _f in _t._fields) {
                            if (!_check._validType0(_f._object._typ, _nest, _path)) {
                                return false;
                            };
                        };
                    } else if (Go.typeEquals((__type__ : Ref<Union>))) {
                        var _t:Ref<stdgo.go.types.Types.Union> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Union>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__().value;
                        for (__1 => _t in _t._terms) {
                            if (!_check._validType0(_t._typ, _nest, _path)) {
                                return false;
                            };
                        };
                    } else if (Go.typeEquals((__type__ : Ref<Interface>))) {
                        var _t:Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                        for (__2 => _etyp in _t._embeddeds) {
                            if (!_check._validType0(_etyp, _nest, _path)) {
                                return false;
                            };
                        };
                    } else if (Go.typeEquals((__type__ : Ref<Named>))) {
                        var _t:Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                        if (_check._valids._lookup(_t) != null && ((_check._valids._lookup(_t) : Dynamic).__nil__ == null || !(_check._valids._lookup(_t) : Dynamic).__nil__)) {
                            break;
                        };
                        if (Go.toInterface(_t.underlying()) == (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                            return false;
                        };
                        for (__19 => _e in _nest) {
                            if (identical(Go.asInterface(_e), Go.asInterface(_t))) {
                                _assert(_t._obj._object._pkg == (_check._pkg));
                                _assert(_t.origin()._obj._object._pkg == (_check._pkg));
                                _t._underlying = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                                _t.origin()._underlying = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                                for (_start => _p in _path) {
                                    if (identical(Go.asInterface(_p), Go.asInterface(_t))) {
                                        _check._cycleError(_makeObjList((_path.__slice__(_start) : Slice<Ref<stdgo.go.types.Types.Named>>)));
                                        return false;
                                    };
                                };
                                throw Go.toInterface(("cycle start not found" : GoString));
                            };
                        };
                        if (!_check._validType0(_t.origin()._fromRHS, (_nest.__append__(_t)), (_path.__append__(_t)))) {
                            return false;
                        };
                        _check._valids._add(_t);
                    } else if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
                        var _t:Ref<stdgo.go.types.Types.TypeParam> = __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__().value;
                        if ((_nest.length) > (0 : GoInt)) {
                            var _inst = _nest[((_nest.length) - (1 : GoInt) : GoInt)];
                            for (_i => _tparam in _inst.typeParams()._list()) {
                                if ((_t == _tparam) && (_i < _inst.typeArgs().len())) {
                                    var _targ:stdgo.go.types.Types.Type = _inst.typeArgs().at(_i);
                                    return _check._validType0(_targ, (_nest.__slice__(0, (_nest.length) - (1 : GoInt)) : Slice<Ref<stdgo.go.types.Types.Named>>), _path);
                                };
                            };
                        };
                    };
                    break;
                };
            };
        };
        return true;
    }
    /**
        // validType verifies that the given type does not "expand" indefinitely
        // producing a cycle in the type graph.
        // (Cycles involving alias types, as in "type A = [10]A" are detected
        // earlier, via the objDecl cycle detection mechanism.)
    **/
    @:keep
    static public function _validType( _check:Ref<Checker>, _typ:Ref<Named>):Void {
        _check._validType0(Go.asInterface(_typ), (null : Slice<Ref<stdgo.go.types.Types.Named>>), (null : Slice<Ref<stdgo.go.types.Types.Named>>));
    }
    /**
        // typeList provides the list of types corresponding to the incoming expression list.
        // If an error occurred, the result is nil, but all list elements were type-checked.
    **/
    @:keep
    static public function _typeList( _check:Ref<Checker>, _list:Slice<stdgo.go.ast.Ast.Expr>):Slice<Type> {
        var _res = new Slice<stdgo.go.types.Types.Type>((_list.length : GoInt).toBasic(), 0);
        for (_i => _x in _list) {
            var _t:stdgo.go.types.Types.Type = _check._varType(_x);
            if (Go.toInterface(_t) == (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                _res = (null : Slice<stdgo.go.types.Types.Type>);
            };
            if (_res != null) {
                _res[(_i : GoInt)] = _t;
            };
        };
        return _res;
    }
    /**
        // arrayLength type-checks the array length expression e
        // and returns the constant length >= 0, or a value < 0
        // to indicate an error (and thus an unknown length).
    **/
    @:keep
    static public function _arrayLength( _check:Ref<Checker>, _e:stdgo.go.ast.Ast.Expr):GoInt64 {
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_e) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.ast.Ast.Ident>), ok : false };
            }, _name = __tmp__.value, __0 = __tmp__.ok;
            if (_name != null && ((_name : Dynamic).__nil__ == null || !(_name : Dynamic).__nil__)) {
                var _obj:stdgo.go.types.Types.Object = _check._lookup(_name.name);
                if (_obj == null) {
                    _check._errorf(Go.asInterface(_name), (26 : stdgo.internal.types.errors.Errors.Code), ("undefined array length %s or missing type constraint" : GoString), Go.toInterface(_name.name));
                    return (-1i64 : GoInt64);
                };
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_obj) : Ref<Const>)) : Ref<Const>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Const>), ok : false };
                    }, __1 = __tmp__.value, _ok = __tmp__.ok;
                    if (!_ok) {
                        _check._errorf(Go.asInterface(_name), (26 : stdgo.internal.types.errors.Errors.Code), ("invalid array length %s" : GoString), Go.toInterface(_name.name));
                        return (-1i64 : GoInt64);
                    };
                };
            };
        };
        var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
        _check._expr((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), _e);
        if (_x._mode != ((4 : stdgo.go.types.Types.T_operandMode))) {
            if (_x._mode != ((0 : stdgo.go.types.Types.T_operandMode))) {
                _check._errorf(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>)), (26 : stdgo.internal.types.errors.Errors.Code), ("array length %s must be constant" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>))));
            };
            return (-1i64 : GoInt64);
        };
        if (_isUntyped(_x._typ) || _isInteger(_x._typ)) {
            {
                var _val:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.toInt(_x._val);
                if (_val.kind() == ((3 : stdgo.go.constant.Constant.Kind))) {
                    if (_representableConst(_val, _check, typ[((2 : stdgo.go.types.Types.BasicKind) : GoInt)], (null : Ref<stdgo.go.constant.Constant.Value>))) {
                        {
                            var __tmp__ = stdgo.go.constant.Constant.int64Val(_val), _n:GoInt64 = __tmp__._0, _ok:Bool = __tmp__._1;
                            if (_ok && (_n >= (0i64 : GoInt64))) {
                                return _n;
                            };
                        };
                        _check._errorf(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>)), (26 : stdgo.internal.types.errors.Errors.Code), ("invalid array length %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>))));
                        return (-1i64 : GoInt64);
                    };
                };
            };
        };
        _check._errorf(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>)), (26 : stdgo.internal.types.errors.Errors.Code), ("array length %s must be integer" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>))));
        return (-1i64 : GoInt64);
    }
    @:keep
    static public function _instantiatedType( _check:Ref<Checker>, _ix:Ref<stdgo.go.internal.typeparams.Typeparams.IndexExpr>, _def:Ref<Named>):Type {
        var __deferstack__:Array<Void -> Void> = [];
        var _res:Type = (null : stdgo.go.types.Types.Type);
        try {
            if (false) {
                _check._trace(_ix.pos(), ("-- instantiating type %s with %s" : GoString), Go.toInterface(_ix.indexListExpr.x), Go.toInterface(_ix.indexListExpr.indices));
                _check._indent++;
                __deferstack__.unshift(() -> {
                    var a = function():Void {
                        _check._indent--;
                        _check._trace(_ix.pos(), ("=> %s" : GoString), Go.toInterface(_res));
                    };
                    a();
                });
            };
            var _cause:GoString = ("" : GoString);
            var _gtyp:stdgo.go.types.Types.Type = _check._genericType(_ix.indexListExpr.x, Go.pointer(_cause));
            if (_cause != (Go.str())) {
                _check._errorf(_ix.orig, (136 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: %s (%s)" : GoString), Go.toInterface(_ix.orig), Go.toInterface(_cause));
            };
            if (Go.toInterface(_gtyp) == (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return _gtyp;
                };
            };
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_gtyp) : Ref<Named>)) : Ref<Named>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
            }, _orig = __tmp__.value, __8 = __tmp__.ok;
            if (_orig == null || (_orig : Dynamic).__nil__) {
                throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("%v: cannot instantiate %v" : GoString), Go.toInterface(Go.asInterface(_ix.pos())), Go.toInterface(_gtyp)));
            };
            var _targs = _check._typeList(_ix.indexListExpr.indices);
            if (_targs == null) {
                _def._setUnderlying(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]));
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                };
            };
            var _inst = (Go.typeAssert((Go.toInterface(_check._instance(_ix.pos(), Go.asInterface(_orig), _targs, null, _check._context())) : Ref<Named>)) : Ref<Named>);
            _def._setUnderlying(Go.asInterface(_inst));
            _check._later(function():Void {
                _check._recordInstance(_ix.orig, _inst.typeArgs()._list(), Go.asInterface(_inst));
                if (_check._validateTArgLen(_ix.pos(), _inst.typeParams().len(), _inst.typeArgs().len())) {
                    {
                        var __tmp__ = _check._verify(_ix.pos(), _inst.typeParams()._list(), _inst.typeArgs()._list(), _check._context()), _i:GoInt = __tmp__._0, _err:Error = __tmp__._1;
                        if (_err != null) {
                            var _pos:stdgo.go.token.Token.Pos = _ix.pos();
                            if (_i < (_ix.indexListExpr.indices.length)) {
                                _pos = _ix.indexListExpr.indices[(_i : GoInt)].pos();
                            };
                            _check._softErrorf(Go.asInterface((_pos : T_atPos)), (139 : stdgo.internal.types.errors.Errors.Code), _err.error());
                        } else {
                            _check._mono._recordInstance(_check._pkg, _ix.pos(), _inst.typeParams()._list(), _inst.typeArgs()._list(), _ix.indexListExpr.indices);
                        };
                    };
                };
                _check._validType(_inst);
            })._describef(Go.asInterface(_ix), ("resolve instance %s" : GoString), Go.toInterface(Go.asInterface(_inst)));
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return Go.asInterface(_inst);
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return _res;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return _res;
        };
    }
    /**
        // typInternal drives type checking of types.
        // Must only be called by definedType or genericType.
    **/
    @:keep
    static public function _typInternal( _check:Ref<Checker>, _e0:stdgo.go.ast.Ast.Expr, _def:Ref<Named>):Type {
        var __deferstack__:Array<Void -> Void> = [];
        var t:Type = (null : stdgo.go.types.Types.Type);
        try {
            if (false) {
                _check._trace(_e0.pos(), ("-- type %s" : GoString), Go.toInterface(_e0));
                _check._indent++;
                __deferstack__.unshift(() -> {
                    var a = function():Void {
                        _check._indent--;
                        var _under:Type = (null : stdgo.go.types.Types.Type);
                        if (t != null) {
                            _under = _safeUnderlying(t);
                        };
                        if (Go.toInterface(t) == (Go.toInterface(_under))) {
                            _check._trace(_e0.pos(), ("=> %s // %s" : GoString), Go.toInterface(t), Go.toInterface(_goTypeName(t)));
                        } else {
                            _check._trace(_e0.pos(), ("=> %s (under = %s) // %s" : GoString), Go.toInterface(t), Go.toInterface(_under), Go.toInterface(_goTypeName(t)));
                        };
                    };
                    a();
                });
            };
            {
                final __type__ = _e0;
                if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BadExpr>))) {
                    var _e:Ref<stdgo.go.ast.Ast.BadExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BadExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BadExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BadExpr>) : __type__.__underlying__().value;
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ident>))) {
                    var _e:Ref<stdgo.go.ast.Ast.Ident> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__().value;
                    var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                    _check._ident((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), _e, _def, true);
                    {
                        final __value__ = _x._mode;
                        if (__value__ == ((3 : stdgo.go.types.Types.T_operandMode))) {
                            var _typ:stdgo.go.types.Types.Type = _x._typ;
                            _def._setUnderlying(_typ);
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _typ;
                            };
                        } else if (__value__ == ((0 : stdgo.go.types.Types.T_operandMode))) {} else if (__value__ == ((1 : stdgo.go.types.Types.T_operandMode))) {
                            _check._errorf(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>)), (25 : stdgo.internal.types.errors.Errors.Code), ("%s used as type" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>))));
                        } else {
                            _check._errorf(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>)), (25 : stdgo.internal.types.errors.Errors.Code), ("%s is not a type" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>))));
                        };
                    };
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectorExpr>))) {
                    var _e:Ref<stdgo.go.ast.Ast.SelectorExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__().value;
                    var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                    _check._selector((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), _e, _def, true);
                    {
                        final __value__ = _x._mode;
                        if (__value__ == ((3 : stdgo.go.types.Types.T_operandMode))) {
                            var _typ:stdgo.go.types.Types.Type = _x._typ;
                            _def._setUnderlying(_typ);
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _typ;
                            };
                        } else if (__value__ == ((0 : stdgo.go.types.Types.T_operandMode))) {} else if (__value__ == ((1 : stdgo.go.types.Types.T_operandMode))) {
                            _check._errorf(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>)), (25 : stdgo.internal.types.errors.Errors.Code), ("%s used as type" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>))));
                        } else {
                            _check._errorf(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>)), (25 : stdgo.internal.types.errors.Errors.Code), ("%s is not a type" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>))));
                        };
                    };
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexExpr>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexListExpr>))) {
                    var _e:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                    var _ix = stdgo.go.internal.typeparams.Typeparams.unpackIndexExpr(_e);
                    if (!_check._allowVersion(_check._pkg, (1 : GoInt), (18 : GoInt))) {
                        _check._softErrorf(Go.asInterface(_inNode(_e, _ix.indexListExpr.lbrack)), (135 : stdgo.internal.types.errors.Errors.Code), ("type instantiation requires go1.18 or later" : GoString));
                    };
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _check._instantiatedType(_ix, _def);
                    };
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ParenExpr>))) {
                    var _e:Ref<stdgo.go.ast.Ast.ParenExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__().value;
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _check._definedType(_e.x, _def);
                    };
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ArrayType>))) {
                    var _e:Ref<stdgo.go.ast.Ast.ArrayType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ArrayType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ArrayType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ArrayType>) : __type__.__underlying__().value;
                    if (_e.len == null) {
                        var _typ = (Go.setRef(({} : stdgo.go.types.Types.Slice_)) : Ref<stdgo.go.types.Types.Slice_>);
                        _def._setUnderlying(Go.asInterface(_typ));
                        _typ._elem = _check._varType(_e.elt);
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return Go.asInterface(_typ);
                        };
                    };
                    var _typ = (Go.setRef(({} : stdgo.go.types.Types.Array_)) : Ref<stdgo.go.types.Types.Array_>);
                    _def._setUnderlying(Go.asInterface(_typ));
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_e.len) : Ref<stdgo.go.ast.Ast.Ellipsis>)) : Ref<stdgo.go.ast.Ast.Ellipsis>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.ast.Ast.Ellipsis>), ok : false };
                        }, __16 = __tmp__.value, _ok = __tmp__.ok;
                        if (_ok) {
                            _check._error(_e.len, (77 : stdgo.internal.types.errors.Errors.Code), ("invalid use of [...] array (outside a composite literal)" : GoString));
                            _typ._len = (-1i64 : GoInt64);
                        } else {
                            _typ._len = _check._arrayLength(_e.len);
                        };
                    };
                    _typ._elem = _check._varType(_e.elt);
                    if (_typ._len >= (0i64 : GoInt64)) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return Go.asInterface(_typ);
                        };
                    };
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ellipsis>))) {
                    var _e:Ref<stdgo.go.ast.Ast.Ellipsis> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__.__underlying__().value;
                    _check._error(Go.asInterface(_e), (81 : stdgo.internal.types.errors.Errors.Code), ("invalid use of \'...\'" : GoString));
                    _check._use(_e.elt);
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.StructType>))) {
                    var _e:Ref<stdgo.go.ast.Ast.StructType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StructType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.StructType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StructType>) : __type__.__underlying__().value;
                    var _typ = (Go.setRef(({} : stdgo.go.types.Types.Struct)) : Ref<stdgo.go.types.Types.Struct>);
                    _def._setUnderlying(Go.asInterface(_typ));
                    _check._structType(_typ, _e);
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return Go.asInterface(_typ);
                    };
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.StarExpr>))) {
                    var _e:Ref<stdgo.go.ast.Ast.StarExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__().value;
                    var _typ = (Go.setRef(({} : stdgo.go.types.Types.Pointer_)) : Ref<stdgo.go.types.Types.Pointer_>);
                    _typ._base = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                    _def._setUnderlying(Go.asInterface(_typ));
                    _typ._base = _check._varType(_e.x);
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return Go.asInterface(_typ);
                    };
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.FuncType>))) {
                    var _e:Ref<stdgo.go.ast.Ast.FuncType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.FuncType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.FuncType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.FuncType>) : __type__.__underlying__().value;
                    var _typ = (Go.setRef(({} : stdgo.go.types.Types.Signature)) : Ref<stdgo.go.types.Types.Signature>);
                    _def._setUnderlying(Go.asInterface(_typ));
                    _check._funcType(_typ, null, _e);
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return Go.asInterface(_typ);
                    };
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.InterfaceType>))) {
                    var _e:Ref<stdgo.go.ast.Ast.InterfaceType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.InterfaceType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.InterfaceType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.InterfaceType>) : __type__.__underlying__().value;
                    var _typ = _check._newInterface();
                    _def._setUnderlying(Go.asInterface(_typ));
                    _check._interfaceType(_typ, _e, _def);
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return Go.asInterface(_typ);
                    };
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.MapType>))) {
                    var _e:Ref<stdgo.go.ast.Ast.MapType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.MapType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.MapType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.MapType>) : __type__.__underlying__().value;
                    var _typ = (Go.setRef(({} : stdgo.go.types.Types.Map_)) : Ref<stdgo.go.types.Types.Map_>);
                    _def._setUnderlying(Go.asInterface(_typ));
                    _typ._key = _check._varType(_e.key);
                    _typ._elem = _check._varType(_e.value);
                    _check._later(function():Void {
                        if (!comparable(_typ._key)) {
                            var _why:GoString = ("" : GoString);
                            if (_isTypeParam(_typ._key)) {
                                _why = (" (missing comparable constraint)" : GoString);
                            };
                            _check._errorf(_e.key, (28 : stdgo.internal.types.errors.Errors.Code), ("invalid map key type %s%s" : GoString), Go.toInterface(_typ._key), Go.toInterface(_why));
                        };
                    })._describef(_e.key, ("check map key %s" : GoString), Go.toInterface(_typ._key));
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return Go.asInterface(_typ);
                    };
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ChanType>))) {
                    var _e:Ref<stdgo.go.ast.Ast.ChanType> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ChanType>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ChanType>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ChanType>) : __type__.__underlying__().value;
                    var _typ = (Go.setRef(({} : stdgo.go.types.Types.Chan)) : Ref<stdgo.go.types.Types.Chan>);
                    _def._setUnderlying(Go.asInterface(_typ));
                    var _dir:stdgo.go.types.Types.ChanDir = (0 : stdgo.go.types.Types.ChanDir);
                    {
                        final __value__ = _e.dir;
                        if (__value__ == ((3 : stdgo.go.ast.Ast.ChanDir))) {} else if (__value__ == ((1 : stdgo.go.ast.Ast.ChanDir))) {
                            _dir = (1 : stdgo.go.types.Types.ChanDir);
                        } else if (__value__ == ((2 : stdgo.go.ast.Ast.ChanDir))) {
                            _dir = (2 : stdgo.go.types.Types.ChanDir);
                        } else {
                            _check._errorf(Go.asInterface(_e), (-1 : stdgo.internal.types.errors.Errors.Code), ("unknown channel direction %d" : GoString), Go.toInterface(_e.dir));
                        };
                    };
                    _typ._dir = _dir;
                    _typ._elem = _check._varType(_e.value);
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return Go.asInterface(_typ);
                    };
                } else {
                    var _e:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                    _check._errorf(_e0, (25 : stdgo.internal.types.errors.Errors.Code), ("%s is not a type" : GoString), Go.toInterface(_e0));
                    _check._use(_e0);
                };
            };
            var _typ = typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)];
            _def._setUnderlying(Go.asInterface(_typ));
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return Go.asInterface(_typ);
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return t;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return t;
        };
    }
    /**
        // genericType is like typ but the type must be an (uninstantiated) generic
        // type. If cause is non-nil and the type expression was a valid type but not
        // generic, cause will be populated with a message describing the error.
    **/
    @:keep
    static public function _genericType( _check:Ref<Checker>, _e:stdgo.go.ast.Ast.Expr, _cause:Pointer<GoString>):Type {
        var _typ:stdgo.go.types.Types.Type = _check._typInternal(_e, null);
        _assert(_isTyped(_typ));
        if ((Go.toInterface(_typ) != Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]))) && !_isGeneric(_typ)) {
            if (_cause != null) {
                _cause.value = _check._sprintf(("%s is not a generic type" : GoString), Go.toInterface(_typ));
            };
            _typ = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
        };
        _check._recordTypeAndValue(_e, (3 : stdgo.go.types.Types.T_operandMode), _typ, (null : stdgo.go.constant.Constant.Value));
        return _typ;
    }
    /**
        // definedType is like typ but also accepts a type name def.
        // If def != nil, e is the type specification for the defined type def, declared
        // in a type declaration, and def.underlying will be set to the type of e before
        // any components of e are type-checked.
    **/
    @:keep
    static public function _definedType( _check:Ref<Checker>, _e:stdgo.go.ast.Ast.Expr, _def:Ref<Named>):Type {
        var _typ:stdgo.go.types.Types.Type = _check._typInternal(_e, _def);
        _assert(_isTyped(_typ));
        if (_isGeneric(_typ)) {
            _check._errorf(_e, (137 : stdgo.internal.types.errors.Errors.Code), ("cannot use generic type %s without instantiation" : GoString), Go.toInterface(_typ));
            _typ = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
        };
        _check._recordTypeAndValue(_e, (3 : stdgo.go.types.Types.T_operandMode), _typ, (null : stdgo.go.constant.Constant.Value));
        return _typ;
    }
    /**
        // validVarType reports an error if typ is a constraint interface.
        // The expression e is used for error reporting, if any.
    **/
    @:keep
    static public function _validVarType( _check:Ref<Checker>, _e:stdgo.go.ast.Ast.Expr, _typ:Type):Void {
        if (_isTypeParam(_typ)) {
            return;
        };
        _check._later(function():Void {
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Interface>)) : Ref<Interface>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.Interface>), ok : false };
                }, _t = __tmp__.value, __0 = __tmp__.ok;
                if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                    var _tset = _computeInterfaceTypeSet(_check, _e.pos(), _t);
                    if (!_tset.isMethodSet()) {
                        if (_tset._comparable) {
                            _check._softErrorf(_e, (142 : stdgo.internal.types.errors.Errors.Code), ("cannot use type %s outside a type constraint: interface is (or embeds) comparable" : GoString), Go.toInterface(_typ));
                        } else {
                            _check._softErrorf(_e, (142 : stdgo.internal.types.errors.Errors.Code), ("cannot use type %s outside a type constraint: interface contains type constraints" : GoString), Go.toInterface(_typ));
                        };
                    };
                };
            };
        })._describef(_e, ("check var type %s" : GoString), Go.toInterface(_typ));
    }
    /**
        // varType type-checks the type expression e and returns its type, or Typ[Invalid].
        // The type must not be an (uninstantiated) generic type and it must not be a
        // constraint interface.
    **/
    @:keep
    static public function _varType( _check:Ref<Checker>, _e:stdgo.go.ast.Ast.Expr):Type {
        var _typ:stdgo.go.types.Types.Type = _check._definedType(_e, null);
        _check._validVarType(_e, _typ);
        return _typ;
    }
    /**
        // typ type-checks the type expression e and returns its type, or Typ[Invalid].
        // The type must not be an (uninstantiated) generic type.
    **/
    @:keep
    static public function _typ( _check:Ref<Checker>, _e:stdgo.go.ast.Ast.Expr):Type {
        return _check._definedType(_e, null);
    }
    /**
        // ident type-checks identifier e and initializes x with the value or type of e.
        // If an error occurred, x.mode is set to invalid.
        // For the meaning of def, see Checker.definedType, below.
        // If wantType is set, the identifier e is expected to denote a type.
    **/
    @:keep
    static public function _ident( _check:Ref<Checker>, _x:Ref<T_operand>, _e:Ref<stdgo.go.ast.Ast.Ident>, _def:Ref<Named>, _wantType:Bool):Void {
        _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
        _x._expr = Go.asInterface(_e);
        var __tmp__ = _check._pkg._scope.lookupParent(_e.name, _check._pkg._scope._pos), _scope:Ref<stdgo.go.types.Types.Scope> = __tmp__._0, _obj:stdgo.go.types.Types.Object = __tmp__._1;
        {
            final __value__ = _obj;
            if (__value__ == null) {
                if (_e.name == (("_" : GoString))) {
                    {
                        var _tpar = _check._recvTParamMap[_e];
                        if (_tpar != null && ((_tpar : Dynamic).__nil__ == null || !(_tpar : Dynamic).__nil__)) {
                            _x._mode = (3 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = Go.asInterface(_tpar);
                        } else {
                            _check._error(Go.asInterface(_e), (35 : stdgo.internal.types.errors.Errors.Code), ("cannot use _ as value or type" : GoString));
                        };
                    };
                } else {
                    _check._errorf(Go.asInterface(_e), (75 : stdgo.internal.types.errors.Errors.Code), ("undefined: %s" : GoString), Go.toInterface(_e.name));
                };
                return;
            } else if (Go.toInterface(__value__) == (Go.toInterface(_universeAny)) || Go.toInterface(__value__) == (Go.toInterface(_universeComparable))) {
                if (!_check._allowVersion(_check._pkg, (1 : GoInt), (18 : GoInt))) {
                    _check._versionErrorf(Go.asInterface(_e), ("go1.18" : GoString), ("predeclared %s" : GoString), Go.toInterface(_e.name));
                    return;
                };
            };
        };
        _check._recordUse(_e, _obj);
        var _typ:stdgo.go.types.Types.Type = _obj.type();
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_obj) : Ref<TypeName>)) : Ref<TypeName>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.TypeName>), ok : false };
            }, __32 = __tmp__.value, _gotType = __tmp__.ok;
            if ((_typ == null) || (_gotType && _wantType)) {
                _check._objDecl(_obj, _def);
                _typ = _obj.type();
            };
        };
        _assert(_typ != null);
        {
            var _pkgName = _check._dotImportMap[(new T_dotImportKey(_scope, _obj.name()) : T_dotImportKey)];
            if (_pkgName != null && ((_pkgName : Dynamic).__nil__ == null || !(_pkgName : Dynamic).__nil__)) {
                _pkgName._used = true;
            };
        };
        {
            final __type__ = _obj;
            if (Go.typeEquals((__type__ : Ref<PkgName>))) {
                var _obj:Ref<stdgo.go.types.Types.PkgName> = __type__ == null ? (null : Ref<stdgo.go.types.Types.PkgName>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.PkgName>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.PkgName>) : __type__.__underlying__().value;
                _check._errorf(Go.asInterface(_e), (4 : stdgo.internal.types.errors.Errors.Code), ("use of package %s not in selector" : GoString), Go.toInterface(_obj._object._name));
                return;
            } else if (Go.typeEquals((__type__ : Ref<Const>))) {
                var _obj:Ref<stdgo.go.types.Types.Const> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Const>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Const>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Const>) : __type__.__underlying__().value;
                _check._addDeclDep(Go.asInterface(_obj));
                if (Go.toInterface(_typ) == (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                    return;
                };
                if (Go.toInterface(Go.asInterface(_obj)) == (Go.toInterface(_universeIota))) {
                    if (_check._environment._iota == null) {
                        _check._error(Go.asInterface(_e), (36 : stdgo.internal.types.errors.Errors.Code), ("cannot use iota outside constant declaration" : GoString));
                        return;
                    };
                    _x._val = _check._environment._iota;
                } else {
                    _x._val = _obj._val;
                };
                _assert(_x._val != null);
                _x._mode = (4 : stdgo.go.types.Types.T_operandMode);
            } else if (Go.typeEquals((__type__ : Ref<TypeName>))) {
                var _obj:Ref<stdgo.go.types.Types.TypeName> = __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.TypeName>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__().value;
                if (_check._isBrokenAlias(_obj)) {
                    _check._errorf(Go.asInterface(_e), (11 : stdgo.internal.types.errors.Errors.Code), ("invalid use of type alias %s in recursive type (see issue #50729)" : GoString), Go.toInterface(_obj._object._name));
                    return;
                };
                _x._mode = (3 : stdgo.go.types.Types.T_operandMode);
            } else if (Go.typeEquals((__type__ : Ref<Var>))) {
                var _obj:Ref<stdgo.go.types.Types.Var> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Var>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__().value;
                if (_obj._object._pkg == (_check._pkg)) {
                    _obj._used = true;
                };
                _check._addDeclDep(Go.asInterface(_obj));
                if (Go.toInterface(_typ) == (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                    return;
                };
                _x._mode = (5 : stdgo.go.types.Types.T_operandMode);
            } else if (Go.typeEquals((__type__ : Ref<Func>))) {
                var _obj:Ref<stdgo.go.types.Types.Func> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Func>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__().value;
                _check._addDeclDep(Go.asInterface(_obj));
                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
            } else if (Go.typeEquals((__type__ : Ref<Builtin>))) {
                var _obj:Ref<stdgo.go.types.Types.Builtin> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Builtin>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Builtin>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Builtin>) : __type__.__underlying__().value;
                _x._id = _obj._id;
                _x._mode = (2 : stdgo.go.types.Types.T_operandMode);
            } else if (Go.typeEquals((__type__ : Ref<Nil>))) {
                var _obj:Ref<stdgo.go.types.Types.Nil> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Nil>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Nil>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Nil>) : __type__.__underlying__().value;
                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
            } else {
                var _obj:stdgo.go.types.Types.Object = __type__ == null ? (null : stdgo.go.types.Types.Object) : cast __type__;
                _unreachable();
            };
        };
        _x._typ = _typ;
    }
    /**
        // check may be nil
    **/
    @:keep
    static public function _newTypeParam( _check:Ref<Checker>, _obj:Ref<TypeName>, _constraint:Type):Ref<TypeParam> {
        var _id:GoUInt64 = _nextID();
        if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
            _check._nextID++;
            _id = _check._nextID;
        };
        var _typ = (Go.setRef(({ _check : _check, _id : _id, _obj : _obj, _index : (-1 : GoInt), _bound : _constraint } : TypeParam)) : Ref<stdgo.go.types.Types.TypeParam>);
        if (_obj._object._typ == null) {
            _obj._object._typ = Go.asInterface(_typ);
        };
        if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
            _check._needsCleanup(Go.asInterface(_typ));
        } else if (_constraint != null) {
            _typ._iface();
        };
        return _typ;
    }
    /**
        // subst returns the type typ with its type parameters tpars replaced by the
        // corresponding type arguments targs, recursively. subst is pure in the sense
        // that it doesn't modify the incoming type. If a substitution took place, the
        // result type is different from the incoming type.
        //
        // If expanding is non-nil, it is the instance type currently being expanded.
        // One of expanding or ctxt must be non-nil.
    **/
    @:keep
    static public function _subst( _check:Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _typ:Type, _smap:T_substMap, _expanding:Ref<Named>, _ctxt:Ref<Context>):Type {
        _assert(((_expanding != null) && ((_expanding : Dynamic).__nil__ == null || !(_expanding : Dynamic).__nil__)) || ((_ctxt != null) && ((_ctxt : Dynamic).__nil__ == null || !(_ctxt : Dynamic).__nil__)));
        if (_smap._empty()) {
            return _typ;
        };
        {
            final __type__ = _typ;
            if (Go.typeEquals((__type__ : Ref<Basic>))) {
                var _t:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                return _typ;
            } else if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
                var _t:Ref<stdgo.go.types.Types.TypeParam> = __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__().value;
                return _smap._lookup(_t);
            };
        };
        var _subst:stdgo.go.types.Types.T_subster = ({ _pos : _pos, _smap : _smap, _check : _check, _expanding : _expanding, _ctxt : _ctxt } : T_subster);
        return _subst._typ(_typ);
    }
    @:keep
    static public function _tag( _check:Ref<Checker>, _t:Ref<stdgo.go.ast.Ast.BasicLit>):GoString {
        if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
            if (_t.kind == ((9 : stdgo.go.token.Token.Token))) {
                {
                    var __tmp__ = stdgo.strconv.Strconv.unquote(_t.value), _val:GoString = __tmp__._0, _err:Error = __tmp__._1;
                    if (_err == null) {
                        return _val;
                    };
                };
            };
            _check._errorf(Go.asInterface(_t), (-1 : stdgo.internal.types.errors.Errors.Code), ("incorrect tag syntax: %q" : GoString), Go.toInterface(_t.value));
        };
        return Go.str();
    }
    @:keep
    static public function _declareInSet( _check:Ref<Checker>, _oset:Ref<T_objset>, _pos:stdgo.go.token.Token.Pos, _obj:Object):Bool {
        {
            var _alt:stdgo.go.types.Types.Object = _oset._insert(_obj);
            if (_alt != null) {
                _check._errorf(Go.asInterface((_pos : T_atPos)), (10 : stdgo.internal.types.errors.Errors.Code), ("%s redeclared" : GoString), Go.toInterface(_obj.name()));
                _check._reportAltDecl(_alt);
                return false;
            };
        };
        return true;
    }
    @:keep
    static public function _structType( _check:Ref<Checker>, _styp:Ref<Struct>, _e:Ref<stdgo.go.ast.Ast.StructType>):Void {
        var _list = _e.fields;
        if (_list == null || (_list : Dynamic).__nil__) {
            _styp._markComplete();
            return;
        };
        var _fields:Slice<Ref<Var>> = (null : Slice<Ref<stdgo.go.types.Types.Var>>);
        var _tags:Slice<GoString> = (null : Slice<GoString>);
        var _fset:T_objset = (null : stdgo.go.types.Types.T_objset);
        var _typ:Type = (null : stdgo.go.types.Types.Type);
        var _tag:GoString = ("" : GoString);
        var _add = function(_ident:Ref<stdgo.go.ast.Ast.Ident>, _embedded:Bool, _pos:stdgo.go.token.Token.Pos):Void {
            if ((_tag != Go.str()) && (_tags == null)) {
                _tags = new Slice<GoString>((_fields.length : GoInt).toBasic(), 0).__setString__();
            };
            if (_tags != null) {
                _tags = (_tags.__append__(_tag));
            };
            var _name:GoString = _ident.name;
            var _fld = newField(_pos, _check._pkg, _name, _typ, _embedded);
            if ((_name == ("_" : GoString)) || _check._declareInSet((Go.setRef(_fset) : Ref<stdgo.go.types.Types.T_objset>), _pos, Go.asInterface(_fld))) {
                _fields = (_fields.__append__(_fld));
                _check._recordDef(_ident, Go.asInterface(_fld));
            };
        };
        var _addInvalid = function(_ident:Ref<stdgo.go.ast.Ast.Ident>, _pos:stdgo.go.token.Token.Pos):Void {
            _typ = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
            _tag = Go.str();
            _add(_ident, true, _pos);
        };
        for (__0 => _f in _list.list) {
            _typ = _check._varType(_f.type);
            _tag = _check._tag(_f.tag);
            if ((_f.names.length) > (0 : GoInt)) {
                for (__1 => _name in _f.names) {
                    _add(_name, false, _name.pos());
                };
            } else {
                var _pos:stdgo.go.token.Token.Pos = _f.type.pos();
                var _name = _embeddedFieldIdent(_f.type);
                if (_name == null || (_name : Dynamic).__nil__) {
                    _check._errorf(_f.type, (-1 : stdgo.internal.types.errors.Errors.Code), ("embedded field type %s has no name" : GoString), Go.toInterface(_f.type));
                    _name = stdgo.go.ast.Ast.newIdent(("_" : GoString));
                    _name.namePos = _pos;
                    _addInvalid(_name, _pos);
                    continue;
                };
                _add(_name, true, _pos);
                var _embeddedTyp:stdgo.go.types.Types.Type = _typ;
                var _embeddedPos:stdgo.go.ast.Ast.Expr = _f.type;
                _check._later(function():Void {
                    var __tmp__ = _deref(_embeddedTyp), _t:stdgo.go.types.Types.Type = __tmp__._0, _isPtr:Bool = __tmp__._1;
                    {
                        final __type__ = _under(_t);
                        {
                            var __bool__ = true;
                            while (__bool__) {
                                __bool__ = false;
                                if (Go.typeEquals((__type__ : Ref<Basic>))) {
                                    var _u:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                                    if (Go.toInterface(_t) == (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                                        return;
                                    };
                                    if (_u._kind == ((18 : stdgo.go.types.Types.BasicKind))) {
                                        _check._error(_embeddedPos, (30 : stdgo.internal.types.errors.Errors.Code), ("embedded field type cannot be unsafe.Pointer" : GoString));
                                    };
                                } else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
                                    var _u:Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                                    _check._error(_embeddedPos, (30 : stdgo.internal.types.errors.Errors.Code), ("embedded field type cannot be a pointer" : GoString));
                                } else if (Go.typeEquals((__type__ : Ref<Interface>))) {
                                    var _u:Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                                    if (_isTypeParam(_t)) {
                                        _check._error(_embeddedPos, (144 : stdgo.internal.types.errors.Errors.Code), ("embedded field type cannot be a (pointer to a) type parameter" : GoString));
                                        break;
                                    };
                                    if (_isPtr) {
                                        _check._error(_embeddedPos, (30 : stdgo.internal.types.errors.Errors.Code), ("embedded field type cannot be a pointer to an interface" : GoString));
                                    };
                                };
                                break;
                            };
                        };
                    };
                })._describef(_embeddedPos, ("check embedded type %s" : GoString), Go.toInterface(_embeddedTyp));
            };
        };
        _styp._fields = _fields;
        _styp._tags = _tags;
        _styp._markComplete();
    }
    /**
        // stmt typechecks statement s.
    **/
    @:keep
    static public function _stmt( _check:Ref<Checker>, _ctxt:T_stmtContext, _s:stdgo.go.ast.Ast.Stmt):Void {
        var __deferstack__:Array<Void -> Void> = [];
        try {
            if (false) {
                {
                    var _a0 = _check._pkg._scope;
                    __deferstack__.unshift(() -> {
                        var a = function(_scope:Ref<Scope>):Void {
                            {
                                var _p:AnyInterface = ({
                                    final r = Go.recover_exception;
                                    Go.recover_exception = null;
                                    r;
                                });
                                if (_p != null) {
                                    throw Go.toInterface(_p);
                                };
                            };
                            _assert(_scope == (_check._pkg._scope));
                        };
                        a(_a0);
                    });
                };
            };
            {
                var _a0 = (_check._delayed.length);
                __deferstack__.unshift(() -> _check._processDelayed(_a0));
            };
            var _inner:stdgo.go.types.Types.T_stmtContext = _ctxt & ((28u32 : stdgo.go.types.Types.T_stmtContext) ^ (-1i32 : GoInt));
            {
                final __type__ = _s;
                if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BadStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.EmptyStmt>))) {
                    var _s:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.DeclStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.DeclStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.DeclStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.DeclStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.DeclStmt>) : __type__.__underlying__().value;
                    _check._declStmt(_s.decl);
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.LabeledStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.LabeledStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__().value;
                    _check._environment._hasLabel = true;
                    _check._stmt(_ctxt, _s.stmt);
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ExprStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.ExprStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__().value;
                    var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                    var _kind:stdgo.go.types.Types.T_exprKind = _check._rawExpr((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), _s.x, (null : stdgo.go.types.Types.Type), false);
                    var _msg:GoString = ("" : GoString);
                    var _code:Code = ((0 : GoInt) : stdgo.internal.types.errors.Errors.Code);
                    {
                        final __value__ = _x._mode;
                        if (__value__ == ((2 : stdgo.go.types.Types.T_operandMode))) {
                            _msg = ("must be called" : GoString);
                            _code = (82 : stdgo.internal.types.errors.Errors.Code);
                        } else if (__value__ == ((3 : stdgo.go.types.Types.T_operandMode))) {
                            _msg = ("is not an expression" : GoString);
                            _code = (42 : stdgo.internal.types.errors.Errors.Code);
                        } else {
                            if (_kind == ((2 : stdgo.go.types.Types.T_exprKind))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return;
                                };
                            };
                            _msg = ("is not used" : GoString);
                            _code = (100 : stdgo.internal.types.errors.Errors.Code);
                        };
                    };
                    _check._errorf(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>)), _code, ("%s %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>))), Go.toInterface(_msg));
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SendStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.SendStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SendStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SendStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SendStmt>) : __type__.__underlying__().value;
                    var __0:T_operand = ({} : stdgo.go.types.Types.T_operand), __1:T_operand = ({} : stdgo.go.types.Types.T_operand), _val:T_operand = __1, _ch:T_operand = __0;
                    _check._expr((Go.setRef(_ch) : Ref<stdgo.go.types.Types.T_operand>), _s.chan);
                    _check._expr((Go.setRef(_val) : Ref<stdgo.go.types.Types.T_operand>), _s.value);
                    if ((_ch._mode == (0 : stdgo.go.types.Types.T_operandMode)) || (_val._mode == (0 : stdgo.go.types.Types.T_operandMode))) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return;
                        };
                    };
                    var _u:stdgo.go.types.Types.Type = _coreType(_ch._typ);
                    if (_u == null) {
                        _check._errorf(Go.asInterface(_inNode(Go.asInterface(_s), _s.arrow)), (59 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot send to %s: no core type" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_ch) : Ref<stdgo.go.types.Types.T_operand>))));
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return;
                        };
                    };
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_u) : Ref<Chan>)) : Ref<Chan>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Chan>), ok : false };
                    }, _uch = __tmp__.value, __24 = __tmp__.ok;
                    if (_uch == null || (_uch : Dynamic).__nil__) {
                        _check._errorf(Go.asInterface(_inNode(Go.asInterface(_s), _s.arrow)), (59 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot send to non-channel %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_ch) : Ref<stdgo.go.types.Types.T_operand>))));
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return;
                        };
                    };
                    if (_uch._dir == ((2 : stdgo.go.types.Types.ChanDir))) {
                        _check._errorf(Go.asInterface(_inNode(Go.asInterface(_s), _s.arrow)), (59 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot send to receive-only channel %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_ch) : Ref<stdgo.go.types.Types.T_operand>))));
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return;
                        };
                    };
                    _check._assignment((Go.setRef(_val) : Ref<stdgo.go.types.Types.T_operand>), _uch._elem, ("send" : GoString));
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IncDecStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.IncDecStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IncDecStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.IncDecStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IncDecStmt>) : __type__.__underlying__().value;
                    var _op:stdgo.go.token.Token.Token = ((0 : GoInt) : stdgo.go.token.Token.Token);
                    {
                        final __value__ = _s.tok;
                        if (__value__ == ((37 : stdgo.go.token.Token.Token))) {
                            _op = (12 : stdgo.go.token.Token.Token);
                        } else if (__value__ == ((38 : stdgo.go.token.Token.Token))) {
                            _op = (13 : stdgo.go.token.Token.Token);
                        } else {
                            _check._errorf(Go.asInterface(_inNode(Go.asInterface(_s), _s.tokPos)), (-1 : stdgo.internal.types.errors.Errors.Code), ("unknown inc/dec operation %s" : GoString), Go.toInterface(Go.asInterface(_s.tok)));
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return;
                            };
                        };
                    };
                    var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                    _check._expr((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), _s.x);
                    if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return;
                        };
                    };
                    if (!_allNumeric(_x._typ)) {
                        _check._errorf(_s.x, (48 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: %s%s (non-numeric type %s)" : GoString), Go.toInterface(_s.x), Go.toInterface(Go.asInterface(_s.tok)), Go.toInterface(_x._typ));
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return;
                        };
                    };
                    var y = (Go.setRef(({ valuePos : _s.x.pos(), kind : (5 : stdgo.go.token.Token.Token), value : ("1" : GoString) } : stdgo.go.ast.Ast.BasicLit)) : Ref<stdgo.go.ast.Ast.BasicLit>);
                    _check._binary((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), (null : stdgo.go.ast.Ast.Expr), _s.x, Go.asInterface(y), _op, _s.tokPos);
                    if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return;
                        };
                    };
                    _check._assignVar(_s.x, (Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>));
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.AssignStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.AssignStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__().value;
                    {
                        final __value__ = _s.tok;
                        if (__value__ == ((42 : stdgo.go.token.Token.Token)) || __value__ == ((47 : stdgo.go.token.Token.Token))) {
                            if ((_s.lhs.length) == ((0 : GoInt))) {
                                _check._error(Go.asInterface(_s), (-1 : stdgo.internal.types.errors.Errors.Code), ("missing lhs in assignment" : GoString));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return;
                                };
                            };
                            if (_s.tok == ((47 : stdgo.go.token.Token.Token))) {
                                _check._shortVarDecl(Go.asInterface(_inNode(Go.asInterface(_s), _s.tokPos)), _s.lhs, _s.rhs);
                            } else {
                                _check._assignVars(_s.lhs, _s.rhs);
                            };
                        } else {
                            if ((_s.lhs.length != (1 : GoInt)) || (_s.rhs.length != (1 : GoInt))) {
                                _check._errorf(Go.asInterface(_inNode(Go.asInterface(_s), _s.tokPos)), (20 : stdgo.internal.types.errors.Errors.Code), ("assignment operation %s requires single-valued expressions" : GoString), Go.toInterface(Go.asInterface(_s.tok)));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return;
                                };
                            };
                            var _op:stdgo.go.token.Token.Token = _assignOp(_s.tok);
                            if (_op == ((0 : stdgo.go.token.Token.Token))) {
                                _check._errorf(Go.asInterface((_s.tokPos : T_atPos)), (-1 : stdgo.internal.types.errors.Errors.Code), ("unknown assignment operation %s" : GoString), Go.toInterface(Go.asInterface(_s.tok)));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return;
                                };
                            };
                            var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                            _check._binary((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), (null : stdgo.go.ast.Ast.Expr), _s.lhs[(0 : GoInt)], _s.rhs[(0 : GoInt)], _op, _s.tokPos);
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return;
                                };
                            };
                            _check._assignVar(_s.lhs[(0 : GoInt)], (Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>));
                        };
                    };
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.GoStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.GoStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.GoStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.GoStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.GoStmt>) : __type__.__underlying__().value;
                    _check._suspendedCall(("go" : GoString), _s.call);
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.DeferStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.DeferStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.DeferStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.DeferStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.DeferStmt>) : __type__.__underlying__().value;
                    _check._suspendedCall(("defer" : GoString), _s.call);
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ReturnStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.ReturnStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ReturnStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ReturnStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ReturnStmt>) : __type__.__underlying__().value;
                    var _res = _check._environment._sig._results;
                    if (((_s.results.length == (0 : GoInt)) && (_res.len() > (0 : GoInt))) && (_res._vars[(0 : GoInt)]._object._name != Go.str())) {
                        for (__33 => _obj in _res._vars) {
                            {
                                var _alt:stdgo.go.types.Types.Object = _check._lookup(_obj._object._name);
                                if ((_alt != null) && (Go.toInterface(_alt) != Go.toInterface(Go.asInterface(_obj)))) {
                                    _check._errorf(Go.asInterface(_s), (104 : stdgo.internal.types.errors.Errors.Code), ("result parameter %s not in scope at return" : GoString), Go.toInterface(_obj._object._name));
                                    _check._errorf(_alt, (104 : stdgo.internal.types.errors.Errors.Code), ("\tinner declaration of %s" : GoString), Go.toInterface(Go.asInterface(_obj)));
                                };
                            };
                        };
                    } else {
                        var _lhs:Slice<Ref<Var>> = (null : Slice<Ref<stdgo.go.types.Types.Var>>);
                        if (_res.len() > (0 : GoInt)) {
                            _lhs = _res._vars;
                        };
                        _check._initVars(_lhs, _s.results, Go.asInterface(_s));
                    };
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BranchStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.BranchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__().value;
                    if (_s.label != null && ((_s.label : Dynamic).__nil__ == null || !(_s.label : Dynamic).__nil__)) {
                        _check._environment._hasLabel = true;
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return;
                        };
                    };
                    {
                        final __value__ = _s.tok;
                        if (__value__ == ((61 : stdgo.go.token.Token.Token))) {
                            if (_ctxt & (1u32 : stdgo.go.types.Types.T_stmtContext) == ((0u32 : stdgo.go.types.Types.T_stmtContext))) {
                                _check._error(Go.asInterface(_s), (110 : stdgo.internal.types.errors.Errors.Code), ("break not in for, switch, or select statement" : GoString));
                            };
                        } else if (__value__ == ((65 : stdgo.go.token.Token.Token))) {
                            if (_ctxt & (2u32 : stdgo.go.types.Types.T_stmtContext) == ((0u32 : stdgo.go.types.Types.T_stmtContext))) {
                                _check._error(Go.asInterface(_s), (111 : stdgo.internal.types.errors.Errors.Code), ("continue not in for statement" : GoString));
                            };
                        } else if (__value__ == ((69 : stdgo.go.token.Token.Token))) {
                            if (_ctxt & (4u32 : stdgo.go.types.Types.T_stmtContext) == ((0u32 : stdgo.go.types.Types.T_stmtContext))) {
                                var _msg:GoString = ("" : GoString);
                                if (_ctxt & (8u32 : stdgo.go.types.Types.T_stmtContext) != ((0u32 : stdgo.go.types.Types.T_stmtContext))) {
                                    _msg = ("cannot fallthrough final case in switch" : GoString);
                                } else if (_ctxt & (16u32 : stdgo.go.types.Types.T_stmtContext) != ((0u32 : stdgo.go.types.Types.T_stmtContext))) {
                                    _msg = ("cannot fallthrough in type switch" : GoString);
                                } else {
                                    _msg = ("fallthrough statement out of place" : GoString);
                                };
                                _check._error(Go.asInterface(_s), (112 : stdgo.internal.types.errors.Errors.Code), _msg);
                            };
                        } else {
                            _check._errorf(Go.asInterface(_s), (-1 : stdgo.internal.types.errors.Errors.Code), ("branch statement: %s" : GoString), Go.toInterface(Go.asInterface(_s.tok)));
                        };
                    };
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BlockStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.BlockStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__().value;
                    _check._openScope(Go.asInterface(_s), ("block" : GoString));
                    __deferstack__.unshift(() -> _check._closeScope());
                    _check._stmtList(_inner, _s.list);
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IfStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.IfStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__().value;
                    _check._openScope(Go.asInterface(_s), ("if" : GoString));
                    __deferstack__.unshift(() -> _check._closeScope());
                    _check._simpleStmt(_s.init);
                    var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                    _check._expr((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), _s.cond);
                    if ((_x._mode != (0 : stdgo.go.types.Types.T_operandMode)) && !_allBoolean(_x._typ)) {
                        _check._error(_s.cond, (105 : stdgo.internal.types.errors.Errors.Code), ("non-boolean condition in if statement" : GoString));
                    };
                    _check._stmt(_inner, Go.asInterface(_s.body));
                    {
                        final __type__ = _s.else_;
                        if (__type__ == null || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BadStmt>))) {} else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IfStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BlockStmt>))) {
                            _check._stmt(_inner, _s.else_);
                        } else {
                            _check._error(_s.else_, (-1 : stdgo.internal.types.errors.Errors.Code), ("invalid else branch in if statement" : GoString));
                        };
                    };
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SwitchStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.SwitchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__().value;
                    _inner = _inner | ((1u32 : stdgo.go.types.Types.T_stmtContext));
                    _check._openScope(Go.asInterface(_s), ("switch" : GoString));
                    __deferstack__.unshift(() -> _check._closeScope());
                    _check._simpleStmt(_s.init);
                    var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                    if (_s.tag != null) {
                        _check._expr((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), _s.tag);
                        _check._assignment((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), (null : stdgo.go.types.Types.Type), ("switch expression" : GoString));
                        if (((_x._mode != (0 : stdgo.go.types.Types.T_operandMode)) && !comparable(_x._typ)) && !_hasNil(_x._typ)) {
                            _check._errorf(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>)), (117 : stdgo.internal.types.errors.Errors.Code), ("cannot switch on %s (%s is not comparable)" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>))), Go.toInterface(_x._typ));
                            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                        };
                    } else {
                        _x._mode = (4 : stdgo.go.types.Types.T_operandMode);
                        _x._typ = Go.asInterface(typ[((1 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                        _x._val = stdgo.go.constant.Constant.makeBool(true);
                        _x._expr = Go.asInterface((Go.setRef(({ namePos : _s.body.lbrace, name : ("true" : GoString) } : stdgo.go.ast.Ast.Ident)) : Ref<stdgo.go.ast.Ast.Ident>));
                    };
                    _check._multipleDefaults(_s.body.list);
                    var _seen:stdgo.go.types.Types.T_valueMap = ({
                        final x = new GoAnyInterfaceMap<Slice<stdgo.go.types.Types.T_valueType>>();
                        x.__defaultValue__ = () -> (null : Slice<stdgo.go.types.Types.T_valueType>);
                        @:mergeBlock {};
                        cast x;
                    } : GoMap<AnyInterface, Slice<stdgo.go.types.Types.T_valueType>>);
                    for (_i => _c in _s.body.list) {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_c) : Ref<stdgo.go.ast.Ast.CaseClause>)) : Ref<stdgo.go.ast.Ast.CaseClause>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.ast.Ast.CaseClause>), ok : false };
                        }, _clause = __tmp__.value, __42 = __tmp__.ok;
                        if (_clause == null || (_clause : Dynamic).__nil__) {
                            _check._error(_c, (-1 : stdgo.internal.types.errors.Errors.Code), ("incorrect expression switch case" : GoString));
                            continue;
                        };
                        _check._caseValues((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), _clause.list, _seen);
                        _check._openScope(Go.asInterface(_clause), ("case" : GoString));
                        var _inner:stdgo.go.types.Types.T_stmtContext = _inner;
                        if ((_i + (1 : GoInt)) < (_s.body.list.length)) {
                            _inner = _inner | ((4u32 : stdgo.go.types.Types.T_stmtContext));
                        } else {
                            _inner = _inner | ((8u32 : stdgo.go.types.Types.T_stmtContext));
                        };
                        _check._stmtList(_inner, _clause.body);
                        _check._closeScope();
                    };
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.TypeSwitchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__().value;
                    _inner = _inner | ((17u32 : stdgo.go.types.Types.T_stmtContext));
                    _check._openScope(Go.asInterface(_s), ("type switch" : GoString));
                    __deferstack__.unshift(() -> _check._closeScope());
                    _check._simpleStmt(_s.init);
                    var _lhs:Ref<stdgo.go.ast.Ast.Ident> = (null : Ref<stdgo.go.ast.Ast.Ident>);
                    var _rhs:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
                    {
                        final __type__ = _s.assign;
                        if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ExprStmt>))) {
                            var _guard:Ref<stdgo.go.ast.Ast.ExprStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__().value;
                            _rhs = _guard.x;
                        } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.AssignStmt>))) {
                            var _guard:Ref<stdgo.go.ast.Ast.AssignStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__().value;
                            if (((_guard.lhs.length != (1 : GoInt)) || (_guard.tok != (47 : stdgo.go.token.Token.Token))) || (_guard.rhs.length != (1 : GoInt))) {
                                _check._error(Go.asInterface(_s), (-1 : stdgo.internal.types.errors.Errors.Code), ("incorrect form of type switch guard" : GoString));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return;
                                };
                            };
                            {
                                var __tmp__ = try {
                                    { value : (Go.typeAssert((Go.toInterface(_guard.lhs[(0 : GoInt)]) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>), ok : true };
                                } catch(_) {
                                    { value : (null : Ref<stdgo.go.ast.Ast.Ident>), ok : false };
                                };
                                _lhs = __tmp__.value;
                            };
                            if (_lhs == null || (_lhs : Dynamic).__nil__) {
                                _check._error(Go.asInterface(_s), (-1 : stdgo.internal.types.errors.Errors.Code), ("incorrect form of type switch guard" : GoString));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return;
                                };
                            };
                            if (_lhs.name == (("_" : GoString))) {
                                _check._softErrorf(Go.asInterface(_lhs), (19 : stdgo.internal.types.errors.Errors.Code), ("no new variable on left side of :=" : GoString));
                                _lhs = null;
                            } else {
                                _check._recordDef(_lhs, (null : stdgo.go.types.Types.Object));
                            };
                            _rhs = _guard.rhs[(0 : GoInt)];
                        } else {
                            var _guard:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
                            _check._error(Go.asInterface(_s), (-1 : stdgo.internal.types.errors.Errors.Code), ("incorrect form of type switch guard" : GoString));
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return;
                            };
                        };
                    };
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_rhs) : Ref<stdgo.go.ast.Ast.TypeAssertExpr>)) : Ref<stdgo.go.ast.Ast.TypeAssertExpr>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.ast.Ast.TypeAssertExpr>), ok : false };
                    }, _expr = __tmp__.value, __43 = __tmp__.ok;
                    if (((_expr == null) || (_expr : Dynamic).__nil__) || (_expr.type != null)) {
                        _check._error(Go.asInterface(_s), (-1 : stdgo.internal.types.errors.Errors.Code), ("incorrect form of type switch guard" : GoString));
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return;
                        };
                    };
                    var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                    _check._expr((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), _expr.x);
                    if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return;
                        };
                    };
                    var _sx:Ref<T_operand> = (null : Ref<stdgo.go.types.Types.T_operand>);
                    if (_isTypeParam(_x._typ)) {
                        _check._errorf(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>)), (116 : stdgo.internal.types.errors.Errors.Code), ("cannot use type switch on type parameter value %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>))));
                    } else {
                        {
                            var __tmp__ = try {
                                { value : (Go.typeAssert((Go.toInterface(_under(_x._typ)) : Ref<Interface>)) : Ref<Interface>), ok : true };
                            } catch(_) {
                                { value : (null : Ref<stdgo.go.types.Types.Interface>), ok : false };
                            }, __44 = __tmp__.value, _ok = __tmp__.ok;
                            if (_ok) {
                                _sx = (Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>);
                            } else {
                                _check._errorf(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>)), (116 : stdgo.internal.types.errors.Errors.Code), ("%s is not an interface" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>))));
                            };
                        };
                    };
                    _check._multipleDefaults(_s.body.list);
                    var _lhsVars:Slice<Ref<Var>> = (null : Slice<Ref<stdgo.go.types.Types.Var>>);
                    var _seen = ({
                        final x = new GoObjectMap<stdgo.go.types.Types.Type, stdgo.go.ast.Ast.Expr>();
                        x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Type", [], stdgo.internal.reflect.Reflect.GoType.named("Type", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
                        x.__defaultValue__ = () -> (null : stdgo.go.ast.Ast.Expr);
                        @:mergeBlock {};
                        cast x;
                    } : GoMap<stdgo.go.types.Types.Type, stdgo.go.ast.Ast.Expr>);
                    for (__45 => _s in _s.body.list) {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_s) : Ref<stdgo.go.ast.Ast.CaseClause>)) : Ref<stdgo.go.ast.Ast.CaseClause>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.ast.Ast.CaseClause>), ok : false };
                        }, _clause = __tmp__.value, __46 = __tmp__.ok;
                        if (_clause == null || (_clause : Dynamic).__nil__) {
                            _check._error(_s, (-1 : stdgo.internal.types.errors.Errors.Code), ("incorrect type switch case" : GoString));
                            continue;
                        };
                        var t:stdgo.go.types.Types.Type = _check._caseTypes(_sx, _clause.list, _seen);
                        _check._openScope(Go.asInterface(_clause), ("case" : GoString));
                        if (_lhs != null && ((_lhs : Dynamic).__nil__ == null || !(_lhs : Dynamic).__nil__)) {
                            if ((_clause.list.length != (1 : GoInt)) || (t == null)) {
                                t = _x._typ;
                            };
                            var _obj = newVar(_lhs.pos(), _check._pkg, _lhs.name, t);
                            var _scopePos:stdgo.go.token.Token.Pos = _clause.pos() + (("default" : GoString).length : stdgo.go.token.Token.Pos);
                            {
                                var _n:GoInt = (_clause.list.length);
                                if (_n > (0 : GoInt)) {
                                    _scopePos = _clause.list[(_n - (1 : GoInt) : GoInt)].end();
                                };
                            };
                            _check._declare(_check._pkg._scope, null, Go.asInterface(_obj), _scopePos);
                            _check._recordImplicit(Go.asInterface(_clause), Go.asInterface(_obj));
                            _lhsVars = (_lhsVars.__append__(_obj));
                        };
                        _check._stmtList(_inner, _clause.body);
                        _check._closeScope();
                    };
                    if (_lhs != null && ((_lhs : Dynamic).__nil__ == null || !(_lhs : Dynamic).__nil__)) {
                        var _used:Bool = false;
                        for (__63 => _v in _lhsVars) {
                            if (_v._used) {
                                _used = true;
                            };
                            _v._used = true;
                        };
                        if (!_used) {
                            _check._softErrorf(Go.asInterface(_lhs), (101 : stdgo.internal.types.errors.Errors.Code), ("%s declared and not used" : GoString), Go.toInterface(_lhs.name));
                        };
                    };
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.SelectStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__().value;
                    _inner = _inner | ((1u32 : stdgo.go.types.Types.T_stmtContext));
                    _check._multipleDefaults(_s.body.list);
                    for (__64 => _s in _s.body.list) {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_s) : Ref<stdgo.go.ast.Ast.CommClause>)) : Ref<stdgo.go.ast.Ast.CommClause>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.ast.Ast.CommClause>), ok : false };
                        }, _clause = __tmp__.value, __65 = __tmp__.ok;
                        if (_clause == null || (_clause : Dynamic).__nil__) {
                            continue;
                        };
                        var _valid:Bool = false;
                        var _rhs:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
                        {
                            final __type__ = _clause.comm;
                            if (__type__ == null || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SendStmt>))) {
                                var _s:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
                                _valid = true;
                            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.AssignStmt>))) {
                                var _s:Ref<stdgo.go.ast.Ast.AssignStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__().value;
                                if ((_s.rhs.length) == ((1 : GoInt))) {
                                    _rhs = _s.rhs[(0 : GoInt)];
                                };
                            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ExprStmt>))) {
                                var _s:Ref<stdgo.go.ast.Ast.ExprStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__().value;
                                _rhs = _s.x;
                            };
                        };
                        if (_rhs != null) {
                            {
                                var __tmp__ = try {
                                    { value : (Go.typeAssert((Go.toInterface(_unparen(_rhs)) : Ref<stdgo.go.ast.Ast.UnaryExpr>)) : Ref<stdgo.go.ast.Ast.UnaryExpr>), ok : true };
                                } catch(_) {
                                    { value : (null : Ref<stdgo.go.ast.Ast.UnaryExpr>), ok : false };
                                }, _x = __tmp__.value, __66 = __tmp__.ok;
                                if (((_x != null) && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) && (_x.op == (36 : stdgo.go.token.Token.Token))) {
                                    _valid = true;
                                };
                            };
                        };
                        if (!_valid) {
                            _check._error(_clause.comm, (118 : stdgo.internal.types.errors.Errors.Code), ("select case must be send or receive (possibly with assignment)" : GoString));
                            continue;
                        };
                        _check._openScope(_s, ("case" : GoString));
                        if (_clause.comm != null) {
                            _check._stmt(_inner, _clause.comm);
                        };
                        _check._stmtList(_inner, _clause.body);
                        _check._closeScope();
                    };
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ForStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.ForStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__().value;
                    _inner = _inner | ((3u32 : stdgo.go.types.Types.T_stmtContext));
                    _check._openScope(Go.asInterface(_s), ("for" : GoString));
                    __deferstack__.unshift(() -> _check._closeScope());
                    _check._simpleStmt(_s.init);
                    if (_s.cond != null) {
                        var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                        _check._expr((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), _s.cond);
                        if ((_x._mode != (0 : stdgo.go.types.Types.T_operandMode)) && !_allBoolean(_x._typ)) {
                            _check._error(_s.cond, (105 : stdgo.internal.types.errors.Errors.Code), ("non-boolean condition in for statement" : GoString));
                        };
                    };
                    _check._simpleStmt(_s.post);
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_s.post) : Ref<stdgo.go.ast.Ast.AssignStmt>)) : Ref<stdgo.go.ast.Ast.AssignStmt>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.ast.Ast.AssignStmt>), ok : false };
                        }, _s = __tmp__.value, __67 = __tmp__.ok;
                        if (((_s != null) && ((_s : Dynamic).__nil__ == null || !(_s : Dynamic).__nil__)) && (_s.tok == (47 : stdgo.go.token.Token.Token))) {
                            _check._softErrorf(Go.asInterface(_s), (106 : stdgo.internal.types.errors.Errors.Code), ("cannot declare in post statement" : GoString));
                            _check._use(..._s.lhs.__toArray__());
                        };
                    };
                    _check._stmt(_inner, Go.asInterface(_s.body));
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.RangeStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.RangeStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__.__underlying__().value;
                    _inner = _inner | ((3u32 : stdgo.go.types.Types.T_stmtContext));
                    var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                    _check._expr((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), _s.x);
                    var __0:Type = (null : stdgo.go.types.Types.Type), __1:Type = (null : stdgo.go.types.Types.Type), _val:Type = __1, _key:Type = __0;
                    if (_x._mode != ((0 : stdgo.go.types.Types.T_operandMode))) {
                        var _cause:GoString = ("" : GoString);
                        var _u:stdgo.go.types.Types.Type = _coreType(_x._typ);
                        {
                            final __type__ = _u;
                            if (__type__ == null) {
                                var _t:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
                                _cause = _check._sprintf(("%s has no core type" : GoString), Go.toInterface(_x._typ));
                            } else if (Go.typeEquals((__type__ : Ref<Chan>))) {
                                var _t:Ref<stdgo.go.types.Types.Chan> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__().value;
                                if (_s.value != null) {
                                    _check._softErrorf(_s.value, (108 : stdgo.internal.types.errors.Errors.Code), ("range over %s permits only one iteration variable" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>))));
                                };
                                if (_t._dir == ((1 : stdgo.go.types.Types.ChanDir))) {
                                    _cause = ("receive from send-only channel" : GoString);
                                };
                            };
                        };
                        {
                            var __tmp__ = _rangeKeyVal(_u);
                            _key = __tmp__._0;
                            _val = __tmp__._1;
                        };
                        if ((_key == null) || (_cause != Go.str())) {
                            if (_cause == (Go.str())) {
                                _check._softErrorf(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>)), (109 : stdgo.internal.types.errors.Errors.Code), ("cannot range over %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>))));
                            } else {
                                _check._softErrorf(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>)), (109 : stdgo.internal.types.errors.Errors.Code), ("cannot range over %s (%s)" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>))), Go.toInterface(_cause));
                            };
                        };
                    };
                    _check._openScope(Go.asInterface(_s), ("range" : GoString));
                    __deferstack__.unshift(() -> _check._closeScope());
                    var _lhs = (new GoArray<stdgo.go.ast.Ast.Expr>(_s.key, _s.value) : GoArray<stdgo.go.ast.Ast.Expr>);
                    var _rhs = (new GoArray<stdgo.go.types.Types.Type>(_key, _val) : GoArray<stdgo.go.types.Types.Type>);
                    if (_s.tok == ((47 : stdgo.go.token.Token.Token))) {
                        var _vars:Slice<Ref<Var>> = (null : Slice<Ref<stdgo.go.types.Types.Var>>);
                        for (_i => _lhs in _lhs) {
                            if (_lhs == null) {
                                continue;
                            };
                            var _obj:Ref<Var> = (null : Ref<stdgo.go.types.Types.Var>);
                            {
                                var __tmp__ = try {
                                    { value : (Go.typeAssert((Go.toInterface(_lhs) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>), ok : true };
                                } catch(_) {
                                    { value : (null : Ref<stdgo.go.ast.Ast.Ident>), ok : false };
                                }, _ident = __tmp__.value, __68 = __tmp__.ok;
                                if (_ident != null && ((_ident : Dynamic).__nil__ == null || !(_ident : Dynamic).__nil__)) {
                                    var _name:GoString = _ident.name;
                                    _obj = newVar(_ident.pos(), _check._pkg, _name, (null : stdgo.go.types.Types.Type));
                                    _check._recordDef(_ident, Go.asInterface(_obj));
                                    if (_name != (("_" : GoString))) {
                                        _vars = (_vars.__append__(_obj));
                                    };
                                } else {
                                    _check._errorf(_lhs, (-1 : stdgo.internal.types.errors.Errors.Code), ("cannot declare %s" : GoString), Go.toInterface(_lhs));
                                    _obj = newVar(_lhs.pos(), _check._pkg, ("_" : GoString), (null : stdgo.go.types.Types.Type));
                                };
                            };
                            {
                                var _typ:stdgo.go.types.Types.Type = _rhs[(_i : GoInt)];
                                if (_typ != null) {
                                    _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                                    _x._expr = _lhs;
                                    _x._typ = _typ;
                                    _check._initVar(_obj, (Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), ("range clause" : GoString));
                                } else {
                                    _obj._object._typ = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                                    _obj._used = true;
                                };
                            };
                        };
                        if ((_vars.length) > (0 : GoInt)) {
                            var _scopePos:stdgo.go.token.Token.Pos = _s.body.pos();
                            for (__85 => _obj in _vars) {
                                _check._declare(_check._pkg._scope, null, Go.asInterface(_obj), _scopePos);
                            };
                        } else {
                            _check._error(Go.asInterface(_inNode(Go.asInterface(_s), _s.tokPos)), (19 : stdgo.internal.types.errors.Errors.Code), ("no new variables on left side of :=" : GoString));
                        };
                    } else {
                        for (_i => _lhs in _lhs) {
                            if (_lhs == null) {
                                continue;
                            };
                            {
                                var _typ:stdgo.go.types.Types.Type = _rhs[(_i : GoInt)];
                                if (_typ != null) {
                                    _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                                    _x._expr = _lhs;
                                    _x._typ = _typ;
                                    _check._assignVar(_lhs, (Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>));
                                };
                            };
                        };
                    };
                    _check._stmt(_inner, Go.asInterface(_s.body));
                } else {
                    var _s:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
                    _check._error(_s, (-1 : stdgo.internal.types.errors.Errors.Code), ("invalid statement" : GoString));
                };
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return;
        };
    }
    /**
        // If the type switch expression is invalid, x is nil.
    **/
    @:keep
    static public function _caseTypes( _check:Ref<Checker>, _x:Ref<T_operand>, _types:Slice<stdgo.go.ast.Ast.Expr>, _seen:GoMap<Type, stdgo.go.ast.Ast.Expr>):Type {
        stdgo.internal.Macro.controlFlow({
            var t:Type = (null : stdgo.go.types.Types.Type);
            var _dummy:T_operand = ({} : stdgo.go.types.Types.T_operand);
            @:label("L") for (__0 => _e in _types) {
                if (_check._isNil(_e)) {
                    t = (null : stdgo.go.types.Types.Type);
                    _check._expr((Go.setRef(_dummy) : Ref<stdgo.go.types.Types.T_operand>), _e);
                } else {
                    t = _check._varType(_e);
                    if (Go.toInterface(t) == (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                        @:jump("L") continue;
                    };
                };
                for (_t => _other in _seen) {
                    if (((t == null) && (_t == null)) || (((t != null) && (_t != null)) && identical(t, _t))) {
                        var ts:GoString = ("nil" : GoString);
                        if (t != null) {
                            ts = typeString(t, _check._qualifier);
                        };
                        _check._errorf(_e, (113 : stdgo.internal.types.errors.Errors.Code), ("duplicate case %s in type switch" : GoString), Go.toInterface(ts));
                        _check._error(_other, (113 : stdgo.internal.types.errors.Errors.Code), ("\tprevious case" : GoString));
                        @:jump("L") continue;
                    };
                };
                _seen[t] = _e;
                if (((_x != null) && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) && (t != null)) {
                    _check._typeAssertion(_e, _x, t, true);
                };
            };
            return t;
        });
        throw "controlFlow did not return";
    }
    /**
        // isNil reports whether the expression e denotes the predeclared value nil.
    **/
    @:keep
    static public function _isNil( _check:Ref<Checker>, _e:stdgo.go.ast.Ast.Expr):Bool {
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_unparen(_e)) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.ast.Ast.Ident>), ok : false };
            }, _name = __tmp__.value, __0 = __tmp__.ok;
            if (_name != null && ((_name : Dynamic).__nil__ == null || !(_name : Dynamic).__nil__)) {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_check._lookup(_name.name)) : Ref<Nil>)) : Ref<Nil>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.Nil>), ok : false };
                }, __1 = __tmp__.value, _ok = __tmp__.ok;
                return _ok;
            };
        };
        return false;
    }
    @:keep
    static public function _caseValues( _check:Ref<Checker>, _x:Ref<T_operand>, _values:Slice<stdgo.go.ast.Ast.Expr>, _seen:T_valueMap):Void {
        stdgo.internal.Macro.controlFlow({
            @:label("L") for (__0 => _e in _values) {
                var _v:T_operand = ({} : stdgo.go.types.Types.T_operand);
                _check._expr((Go.setRef(_v) : Ref<stdgo.go.types.Types.T_operand>), _e);
                if ((_x._mode == (0 : stdgo.go.types.Types.T_operandMode)) || (_v._mode == (0 : stdgo.go.types.Types.T_operandMode))) {
                    @:jump("L") continue;
                };
                _check._convertUntyped((Go.setRef(_v) : Ref<stdgo.go.types.Types.T_operand>), _x._typ);
                if (_v._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                    @:jump("L") continue;
                };
                var _res:stdgo.go.types.Types.T_operand = _v?.__copy__();
                _check._comparison((Go.setRef(_res) : Ref<stdgo.go.types.Types.T_operand>), _x, (39 : stdgo.go.token.Token.Token), true);
                if (_res._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                    @:jump("L") continue;
                };
                if (_v._mode != ((4 : stdgo.go.types.Types.T_operandMode))) {
                    @:jump("L") continue;
                };
                {
                    var _val:AnyInterface = _goVal(_v._val);
                    if (_val != null) {
                        for (__1 => _vt in _seen[_val]) {
                            if (identical(_v._typ, _vt._typ)) {
                                _check._errorf(Go.asInterface((Go.setRef(_v) : Ref<stdgo.go.types.Types.T_operand>)), (113 : stdgo.internal.types.errors.Errors.Code), ("duplicate case %s in expression switch" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_v) : Ref<stdgo.go.types.Types.T_operand>))));
                                _check._error(Go.asInterface((_vt._pos : T_atPos)), (113 : stdgo.internal.types.errors.Errors.Code), ("\tprevious case" : GoString));
                                @:jump("L") continue;
                            };
                        };
                        _seen[_val] = (_seen[_val].__append__((new T_valueType(_v.pos(), _v._typ) : T_valueType)));
                    };
                };
            };
        });
    }
    @:keep
    static public function _suspendedCall( _check:Ref<Checker>, _keyword:GoString, _call:Ref<stdgo.go.ast.Ast.CallExpr>):Void {
        var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
        var _msg:GoString = ("" : GoString);
        var _code:Code = ((0 : GoInt) : stdgo.internal.types.errors.Errors.Code);
        {
            final __value__ = _check._rawExpr((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), Go.asInterface(_call), (null : stdgo.go.types.Types.Type), false);
            if (__value__ == ((0 : stdgo.go.types.Types.T_exprKind))) {
                _msg = ("requires function call, not conversion" : GoString);
                _code = (129 : stdgo.internal.types.errors.Errors.Code);
                if (_keyword == (("go" : GoString))) {
                    _code = (130 : stdgo.internal.types.errors.Errors.Code);
                };
            } else if (__value__ == ((1 : stdgo.go.types.Types.T_exprKind))) {
                _msg = ("discards result of" : GoString);
                _code = (128 : stdgo.internal.types.errors.Errors.Code);
            } else if (__value__ == ((2 : stdgo.go.types.Types.T_exprKind))) {
                return;
            } else {
                _unreachable();
            };
        };
        _check._errorf(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>)), _code, ("%s %s %s" : GoString), Go.toInterface(_keyword), Go.toInterface(_msg), Go.toInterface(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>))));
    }
    @:keep
    static public function _closeScope( _check:Ref<Checker>):Void {
        _check._pkg._scope = _check._pkg._scope.parent();
    }
    @:keep
    static public function _openScope( _check:Ref<Checker>, _node:stdgo.go.ast.Ast.Node, _comment:GoString):Void {
        var _scope = newScope(_check._pkg._scope, _node.pos(), _node.end(), _comment);
        _check._recordScope(_node, _scope);
        _check._pkg._scope = _scope;
    }
    @:keep
    static public function _multipleDefaults( _check:Ref<Checker>, _list:Slice<stdgo.go.ast.Ast.Stmt>):Void {
        var _first:stdgo.go.ast.Ast.Stmt = (null : stdgo.go.ast.Ast.Stmt);
        for (__0 => _s in _list) {
            var _d:stdgo.go.ast.Ast.Stmt = (null : stdgo.go.ast.Ast.Stmt);
            {
                final __type__ = _s;
                if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CaseClause>))) {
                    var _c:Ref<stdgo.go.ast.Ast.CaseClause> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CaseClause>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.CaseClause>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CaseClause>) : __type__.__underlying__().value;
                    if ((_c.list.length) == ((0 : GoInt))) {
                        _d = _s;
                    };
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CommClause>))) {
                    var _c:Ref<stdgo.go.ast.Ast.CommClause> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CommClause>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.CommClause>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CommClause>) : __type__.__underlying__().value;
                    if (_c.comm == null) {
                        _d = _s;
                    };
                } else {
                    var _c:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
                    _check._error(_s, (-1 : stdgo.internal.types.errors.Errors.Code), ("case/communication clause expected" : GoString));
                };
            };
            if (_d != null) {
                if (_first != null) {
                    _check._errorf(_d, (114 : stdgo.internal.types.errors.Errors.Code), ("multiple defaults (first at %s)" : GoString), Go.toInterface(Go.asInterface(_check._fset.position(_first.pos()))));
                } else {
                    _first = _d;
                };
            };
        };
    }
    @:keep
    static public function _stmtList( _check:Ref<Checker>, _ctxt:T_stmtContext, _list:Slice<stdgo.go.ast.Ast.Stmt>):Void {
        var _ok:Bool = _ctxt & (4u32 : stdgo.go.types.Types.T_stmtContext) != ((0u32 : stdgo.go.types.Types.T_stmtContext));
        var _inner:stdgo.go.types.Types.T_stmtContext = _ctxt & ((4u32 : stdgo.go.types.Types.T_stmtContext) ^ (-1i32 : GoInt));
        _list = _trimTrailingEmptyStmts(_list);
        for (_i => _s in _list) {
            var _inner:stdgo.go.types.Types.T_stmtContext = _inner;
            if (_ok && ((_i + (1 : GoInt)) == (_list.length))) {
                _inner = _inner | ((4u32 : stdgo.go.types.Types.T_stmtContext));
            };
            _check._stmt(_inner, _s);
        };
    }
    @:keep
    static public function _simpleStmt( _check:Ref<Checker>, _s:stdgo.go.ast.Ast.Stmt):Void {
        if (_s != null) {
            _check._stmt((0u32 : stdgo.go.types.Types.T_stmtContext), _s);
        };
    }
    @:keep
    static public function _usage( _check:Ref<Checker>, _scope:Ref<Scope>):Void {
        var _unused:Slice<Ref<Var>> = (null : Slice<Ref<stdgo.go.types.Types.Var>>);
        for (_name => _elem in _scope._elems) {
            _elem = _resolve(_name, _elem);
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_elem) : Ref<Var>)) : Ref<Var>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.Var>), ok : false };
                }, _v = __tmp__.value, __0 = __tmp__.ok;
                if (((_v != null) && ((_v : Dynamic).__nil__ == null || !(_v : Dynamic).__nil__)) && !_v._used) {
                    _unused = (_unused.__append__(_v));
                };
            };
        };
        stdgo.sort.Sort.slice(Go.toInterface(_unused), function(_i:GoInt, _j:GoInt):Bool {
            return _unused[(_i : GoInt)]._object._pos < _unused[(_j : GoInt)]._object._pos;
        });
        for (__1 => _v in _unused) {
            _check._softErrorf(Go.asInterface(_v), (101 : stdgo.internal.types.errors.Errors.Code), ("%s declared and not used" : GoString), Go.toInterface(_v._object._name));
        };
        for (__2 => _scope in _scope._children) {
            if (!_scope._isFunc) {
                _check._usage(_scope);
            };
        };
    }
    @:keep
    static public function _funcBody( _check:Ref<Checker>, _decl:Ref<T_declInfo>, _name:GoString, _sig:Ref<Signature>, _body:Ref<stdgo.go.ast.Ast.BlockStmt>, _iota:stdgo.go.constant.Constant.Value):Void {
        var __deferstack__:Array<Void -> Void> = [];
        try {
            if (_check._conf.ignoreFuncBodies) {
                throw Go.toInterface(("function body not ignored" : GoString));
            };
            if (false) {
                _check._trace(_body.pos(), ("-- %s: %s" : GoString), Go.toInterface(_name), Go.toInterface(Go.asInterface(_sig)));
            };
            _sig._scope._pos = _body.pos();
            _sig._scope._end = _body.end();
            {
                var _a0 = _check._environment;
                var _a1 = _check._indent;
                __deferstack__.unshift(() -> {
                    var a = function(_env:T_environment, _indent:GoInt):Void {
                        _check._environment = _env?.__copy__();
                        _check._indent = _indent;
                    };
                    a(_a0?.__copy__(), _a1);
                });
            };
            _check._environment = ({ _decl : _decl, _scope : _sig._scope, _iota : _iota, _sig : _sig } : T_environment);
            _check._indent = (0 : GoInt);
            _check._stmtList((0u32 : stdgo.go.types.Types.T_stmtContext), _body.list);
            if (_check._environment._hasLabel) {
                _check._labels(_body);
            };
            if ((_sig._results.len() > (0 : GoInt)) && !_check._isTerminating(Go.asInterface(_body), Go.str())) {
                _check._error(Go.asInterface((_body.rbrace : T_atPos)), (102 : stdgo.internal.types.errors.Errors.Code), ("missing return" : GoString));
            };
            _check._usage(_sig._scope);
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return;
        };
    }
    /**
        // collectParams declares the parameters of list in scope and returns the corresponding
        // variable list.
    **/
    @:keep
    static public function _collectParams( _check:Ref<Checker>, _scope:Ref<Scope>, _list:Ref<stdgo.go.ast.Ast.FieldList>, _variadicOk:Bool):{ var _0 : Slice<Ref<Var>>; var _1 : Bool; } {
        var _params:Slice<Ref<Var>> = (null : Slice<Ref<stdgo.go.types.Types.Var>>), _variadic:Bool = false;
        if (_list == null || (_list : Dynamic).__nil__) {
            return { _0 : _params, _1 : _variadic };
        };
        var __0:Bool = false, __1:Bool = false, _anonymous:Bool = __1, _named:Bool = __0;
        for (_i => _field in _list.list) {
            var _ftype:stdgo.go.ast.Ast.Expr = _field.type;
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_ftype) : Ref<stdgo.go.ast.Ast.Ellipsis>)) : Ref<stdgo.go.ast.Ast.Ellipsis>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.ast.Ast.Ellipsis>), ok : false };
                }, _t = __tmp__.value, __0 = __tmp__.ok;
                if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                    _ftype = _t.elt;
                    if ((_variadicOk && (_i == (_list.list.length - (1 : GoInt)))) && (_field.names.length <= (1 : GoInt))) {
                        _variadic = true;
                    } else {
                        _check._softErrorf(Go.asInterface(_t), (79 : stdgo.internal.types.errors.Errors.Code), ("can only use ... with final parameter in list" : GoString));
                    };
                };
            };
            var _typ:stdgo.go.types.Types.Type = _check._varType(_ftype);
            if ((_field.names.length) > (0 : GoInt)) {
                for (__1 => _name in _field.names) {
                    if (_name.name == (Go.str())) {
                        _check._error(Go.asInterface(_name), (-1 : stdgo.internal.types.errors.Errors.Code), ("anonymous parameter" : GoString));
                    };
                    var _par = newParam(_name.pos(), _check._pkg, _name.name, _typ);
                    _check._declare(_scope, _name, Go.asInterface(_par), _scope._pos);
                    _params = (_params.__append__(_par));
                };
                _named = true;
            } else {
                var _par = newParam(_ftype.pos(), _check._pkg, Go.str(), _typ);
                _check._recordImplicit(Go.asInterface(_field), Go.asInterface(_par));
                _params = (_params.__append__(_par));
                _anonymous = true;
            };
        };
        if (_named && _anonymous) {
            _check._error(Go.asInterface(_list), (-1 : stdgo.internal.types.errors.Errors.Code), ("list contains both named and anonymous parameters" : GoString));
        };
        if (_variadic) {
            var _last = _params[((_params.length) - (1 : GoInt) : GoInt)];
            _last._object._typ = Go.asInterface((Go.setRef(({ _elem : _last._object._typ } : Slice_)) : Ref<stdgo.go.types.Types.Slice_>));
            _check._recordTypeAndValue(_list.list[((_list.list.length) - (1 : GoInt) : GoInt)].type, (3 : stdgo.go.types.Types.T_operandMode), _last._object._typ, (null : stdgo.go.constant.Constant.Value));
        };
        return { _0 : _params, _1 : _variadic };
    }
    /**
        // funcType type-checks a function or method type.
    **/
    @:keep
    static public function _funcType( _check:Ref<Checker>, _sig:Ref<Signature>, _recvPar:Ref<stdgo.go.ast.Ast.FieldList>, _ftyp:Ref<stdgo.go.ast.Ast.FuncType>):Void {
        var __deferstack__:Array<Void -> Void> = [];
        try {
            _check._openScope(Go.asInterface(_ftyp), ("function" : GoString));
            _check._pkg._scope._isFunc = true;
            _check._recordScope(Go.asInterface(_ftyp), _check._pkg._scope);
            _sig._scope = _check._pkg._scope;
            __deferstack__.unshift(() -> _check._closeScope());
            if (((_recvPar != null) && ((_recvPar : Dynamic).__nil__ == null || !(_recvPar : Dynamic).__nil__)) && (_recvPar.list.length > (0 : GoInt))) {
                var __tmp__ = _check._unpackRecv(_recvPar.list[(0 : GoInt)].type, true), __24:Bool = __tmp__._0, _rname:Ref<stdgo.go.ast.Ast.Ident> = __tmp__._1, _rparams:Slice<Ref<stdgo.go.ast.Ast.Ident>> = __tmp__._2;
                if ((_rparams.length) > (0 : GoInt)) {
                    var _tparams = _check._declareTypeParams((null : Slice<Ref<stdgo.go.types.Types.TypeParam>>), _rparams);
                    _sig._rparams = _bindTParams(_tparams);
                    for (_i => _p in _rparams) {
                        if (_p.name == (("_" : GoString))) {
                            if (_check._recvTParamMap == null) {
                                _check._recvTParamMap = ({
                                    final x = new GoRefMap<Ref<stdgo.go.ast.Ast.Ident>, Ref<stdgo.go.types.Types.TypeParam>>();
                                    @:mergeBlock {};
                                    cast x;
                                } : GoMap<Ref<stdgo.go.ast.Ast.Ident>, Ref<stdgo.go.types.Types.TypeParam>>);
                            };
                            _check._recvTParamMap[_p] = _tparams[(_i : GoInt)];
                        };
                    };
                    var _recvTParams:Slice<Ref<TypeParam>> = (null : Slice<Ref<stdgo.go.types.Types.TypeParam>>);
                    if (_rname != null && ((_rname : Dynamic).__nil__ == null || !(_rname : Dynamic).__nil__)) {
                        {
                            var __tmp__ = try {
                                { value : (Go.typeAssert((Go.toInterface(_check._genericType(Go.asInterface(_rname), (null : Pointer<GoString>))) : Ref<Named>)) : Ref<Named>), ok : true };
                            } catch(_) {
                                { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
                            }, _recv = __tmp__.value, __49 = __tmp__.ok;
                            if (_recv != null && ((_recv : Dynamic).__nil__ == null || !(_recv : Dynamic).__nil__)) {
                                _recvTParams = _recv.typeParams()._list();
                            };
                        };
                    };
                    if ((_tparams.length) == ((_recvTParams.length))) {
                        var _smap:stdgo.go.types.Types.T_substMap = _makeRenameMap(_recvTParams, _tparams);
                        for (_i => _tpar in _tparams) {
                            var _recvTPar = _recvTParams[(_i : GoInt)];
                            _check._mono._recordCanon(_tpar, _recvTPar);
                            _tpar._bound = _check._subst(_tpar._obj._object._pos, _recvTPar._bound, _smap, null, _check._context());
                        };
                    } else if ((_tparams.length) < (_recvTParams.length)) {
                        var _got:GoString = _measure((_tparams.length), ("type parameter" : GoString));
                        _check._errorf(Go.asInterface(_recvPar), (31 : stdgo.internal.types.errors.Errors.Code), ("got %s, but receiver base type declares %d" : GoString), Go.toInterface(_got), Go.toInterface((_recvTParams.length)));
                    };
                };
            };
            if (_ftyp.typeParams != null && ((_ftyp.typeParams : Dynamic).__nil__ == null || !(_ftyp.typeParams : Dynamic).__nil__)) {
                _check._collectTypeParams((Go.setRef(_sig._tparams) : Ref<Ref<stdgo.go.types.Types.TypeParamList>>), _ftyp.typeParams);
                if (_recvPar != null && ((_recvPar : Dynamic).__nil__ == null || !(_recvPar : Dynamic).__nil__)) {
                    _check._error(Go.asInterface(_ftyp.typeParams), (143 : stdgo.internal.types.errors.Errors.Code), ("methods cannot have type parameters" : GoString));
                };
            };
            var _scope = newScope(_check._pkg._scope, (0 : stdgo.go.token.Token.Pos), (0 : stdgo.go.token.Token.Pos), ("function body (temp. scope)" : GoString));
            var __tmp__ = _check._collectParams(_scope, _recvPar, false), _recvList:Slice<Ref<stdgo.go.types.Types.Var>> = __tmp__._0, __90:Bool = __tmp__._1;
            var __tmp__ = _check._collectParams(_scope, _ftyp.params, true), _params:Slice<Ref<stdgo.go.types.Types.Var>> = __tmp__._0, _variadic:Bool = __tmp__._1;
            var __tmp__ = _check._collectParams(_scope, _ftyp.results, false), _results:Slice<Ref<stdgo.go.types.Types.Var>> = __tmp__._0, __91:Bool = __tmp__._1;
            _scope._squash(function(_obj:Object, _alt:Object):Void {
                _check._errorf(_obj, (10 : stdgo.internal.types.errors.Errors.Code), ("%s redeclared in this block" : GoString), Go.toInterface(_obj.name()));
                _check._reportAltDecl(_alt);
            });
            if (_recvPar != null && ((_recvPar : Dynamic).__nil__ == null || !(_recvPar : Dynamic).__nil__)) {
                var _recv:Ref<Var> = (null : Ref<stdgo.go.types.Types.Var>);
                {
                    var __switchIndex__ = -1;
                    var __run__ = true;
                    while (__run__) {
                        __run__ = false;
                        {
                            final __value__ = (_recvList.length);
                            if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (__value__ == (0 : GoInt)))) {
                                _recv = newParam((0 : stdgo.go.token.Token.Pos), null, Go.str(), Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]));
                                break;
                                break;
                            } else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && (__value__ == (1 : GoInt)))) {
                                _recv = _recvList[(0 : GoInt)];
                                break;
                                break;
                            } else {
                                _check._error(Go.asInterface(_recvList[((_recvList.length) - (1 : GoInt) : GoInt)]), (32 : stdgo.internal.types.errors.Errors.Code), ("method has multiple receivers" : GoString));
                                @:fallthrough {
                                    __switchIndex__ = 2;
                                    __run__ = true;
                                    continue;
                                };
                            };
                        };
                        break;
                    };
                };
                _sig._recv = _recv;
                _check._later(function():Void {
                    var __tmp__ = _deref(_recv._object._typ), _rtyp:stdgo.go.types.Types.Type = __tmp__._0, __0:Bool = __tmp__._1;
                    if (Go.toInterface(_rtyp) == (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                        return;
                    };
                    {
                        final __type__ = _rtyp;
                        {
                            var __bool__ = true;
                            while (__bool__) {
                                __bool__ = false;
                                if (Go.typeEquals((__type__ : Ref<Named>))) {
                                    var t:Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                                    if (((t.typeArgs() != null) && ((t.typeArgs() : Dynamic).__nil__ == null || !(t.typeArgs() : Dynamic).__nil__)) && (_sig.recvTypeParams() == null) || (_sig.recvTypeParams() : Dynamic).__nil__) {
                                        _check._errorf(Go.asInterface(_recv), (32 : stdgo.internal.types.errors.Errors.Code), ("cannot define new methods on instantiated type %s" : GoString), Go.toInterface(_rtyp));
                                        break;
                                    };
                                    if (t._obj._object._pkg != (_check._pkg)) {
                                        _check._errorf(Go.asInterface(_recv), (32 : stdgo.internal.types.errors.Errors.Code), ("cannot define new methods on non-local type %s" : GoString), Go.toInterface(_rtyp));
                                        break;
                                    };
                                    var _cause:GoString = ("" : GoString);
                                    {
                                        final __type__ = t._under();
                                        if (Go.typeEquals((__type__ : Ref<Basic>))) {
                                            var _u:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                                            if (_u._kind == ((18 : stdgo.go.types.Types.BasicKind))) {
                                                _cause = ("unsafe.Pointer" : GoString);
                                            };
                                        } else if (Go.typeEquals((__type__ : Ref<Pointer_>)) || Go.typeEquals((__type__ : Ref<Interface>))) {
                                            var _u:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                                            _cause = ("pointer or interface type" : GoString);
                                        } else if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
                                            var _u:Ref<stdgo.go.types.Types.TypeParam> = __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__().value;
                                            _unreachable();
                                        };
                                    };
                                    if (_cause != (Go.str())) {
                                        _check._errorf(Go.asInterface(_recv), (32 : stdgo.internal.types.errors.Errors.Code), ("invalid receiver type %s (%s)" : GoString), Go.toInterface(_rtyp), Go.toInterface(_cause));
                                    };
                                } else if (Go.typeEquals((__type__ : Ref<Basic>))) {
                                    var t:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                                    _check._errorf(Go.asInterface(_recv), (32 : stdgo.internal.types.errors.Errors.Code), ("cannot define new methods on non-local type %s" : GoString), Go.toInterface(_rtyp));
                                } else {
                                    var t:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                                    _check._errorf(Go.asInterface(_recv), (32 : stdgo.internal.types.errors.Errors.Code), ("invalid receiver type %s" : GoString), Go.toInterface(_recv._object._typ));
                                };
                                break;
                            };
                        };
                    };
                })._describef(Go.asInterface(_recv), ("validate receiver %s" : GoString), Go.toInterface(Go.asInterface(_recv)));
            };
            _sig._params = newTuple(..._params.__toArray__());
            _sig._results = newTuple(..._results.__toArray__());
            _sig._variadic = _variadic;
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return;
        };
    }
    @:keep
    static public function _isTerminatingSwitch( _check:Ref<Checker>, _body:Ref<stdgo.go.ast.Ast.BlockStmt>, _label:GoString):Bool {
        var _hasDefault:Bool = false;
        for (__0 => _s in _body.list) {
            var _cc = (Go.typeAssert((Go.toInterface(_s) : Ref<stdgo.go.ast.Ast.CaseClause>)) : Ref<stdgo.go.ast.Ast.CaseClause>);
            if (_cc.list == null) {
                _hasDefault = true;
            };
            if (!_check._isTerminatingList(_cc.body, Go.str()) || _hasBreakList(_cc.body, _label, true)) {
                return false;
            };
        };
        return _hasDefault;
    }
    @:keep
    static public function _isTerminatingList( _check:Ref<Checker>, _list:Slice<stdgo.go.ast.Ast.Stmt>, _label:GoString):Bool {
        {
            var _i:GoInt = (_list.length) - (1 : GoInt);
            Go.cfor(_i >= (0 : GoInt), _i--, {
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_list[(_i : GoInt)]) : Ref<stdgo.go.ast.Ast.EmptyStmt>)) : Ref<stdgo.go.ast.Ast.EmptyStmt>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.ast.Ast.EmptyStmt>), ok : false };
                    }, __0 = __tmp__.value, _ok = __tmp__.ok;
                    if (!_ok) {
                        return _check._isTerminating(_list[(_i : GoInt)], _label);
                    };
                };
            });
        };
        return false;
    }
    /**
        // isTerminating reports if s is a terminating statement.
        // If s is labeled, label is the label name; otherwise s
        // is "".
    **/
    @:keep
    static public function _isTerminating( _check:Ref<Checker>, _s:stdgo.go.ast.Ast.Stmt, _label:GoString):Bool {
        {
            final __type__ = _s;
            if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BadStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.DeclStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.EmptyStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SendStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IncDecStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.AssignStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.GoStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.DeferStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.RangeStmt>))) {
                var _s:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.LabeledStmt>))) {
                var _s:Ref<stdgo.go.ast.Ast.LabeledStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__().value;
                return _check._isTerminating(_s.stmt, _s.label.name);
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ExprStmt>))) {
                var _s:Ref<stdgo.go.ast.Ast.ExprStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ExprStmt>) : __type__.__underlying__().value;
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_unparen(_s.x)) : Ref<stdgo.go.ast.Ast.CallExpr>)) : Ref<stdgo.go.ast.Ast.CallExpr>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.ast.Ast.CallExpr>), ok : false };
                    }, _call = __tmp__.value, _ok = __tmp__.ok;
                    if (_ok && _check._environment._isPanic[_call]) {
                        return true;
                    };
                };
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ReturnStmt>))) {
                var _s:Ref<stdgo.go.ast.Ast.ReturnStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ReturnStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ReturnStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ReturnStmt>) : __type__.__underlying__().value;
                return true;
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BranchStmt>))) {
                var _s:Ref<stdgo.go.ast.Ast.BranchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__().value;
                if ((_s.tok == (73 : stdgo.go.token.Token.Token)) || (_s.tok == (69 : stdgo.go.token.Token.Token))) {
                    return true;
                };
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BlockStmt>))) {
                var _s:Ref<stdgo.go.ast.Ast.BlockStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__().value;
                return _check._isTerminatingList(_s.list, Go.str());
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IfStmt>))) {
                var _s:Ref<stdgo.go.ast.Ast.IfStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__().value;
                if (((_s.else_ != null) && _check._isTerminating(Go.asInterface(_s.body), Go.str())) && _check._isTerminating(_s.else_, Go.str())) {
                    return true;
                };
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SwitchStmt>))) {
                var _s:Ref<stdgo.go.ast.Ast.SwitchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__().value;
                return _check._isTerminatingSwitch(_s.body, _label);
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>))) {
                var _s:Ref<stdgo.go.ast.Ast.TypeSwitchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__().value;
                return _check._isTerminatingSwitch(_s.body, _label);
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectStmt>))) {
                var _s:Ref<stdgo.go.ast.Ast.SelectStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__().value;
                for (__8 => _s in _s.body.list) {
                    var _cc = (Go.typeAssert((Go.toInterface(_s) : Ref<stdgo.go.ast.Ast.CommClause>)) : Ref<stdgo.go.ast.Ast.CommClause>);
                    if (!_check._isTerminatingList(_cc.body, Go.str()) || _hasBreakList(_cc.body, _label, true)) {
                        return false;
                    };
                };
                return true;
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ForStmt>))) {
                var _s:Ref<stdgo.go.ast.Ast.ForStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__().value;
                if ((_s.cond == null) && !_hasBreak(Go.asInterface(_s.body), _label, true)) {
                    return true;
                };
            } else {
                var _s:stdgo.go.ast.Ast.Stmt = __type__ == null ? (null : stdgo.go.ast.Ast.Stmt) : cast __type__;
                _unreachable();
            };
        };
        return false;
    }
    @:keep
    static public function _errorUnusedPkg( _check:Ref<Checker>, _obj:Ref<PkgName>):Void {
        var _path:GoString = _obj._imported._path;
        var _elem:GoString = _path;
        {
            var _i:GoInt = stdgo.strings.Strings.lastIndex(_elem, ("/" : GoString));
            if (_i >= (0 : GoInt)) {
                _elem = (_elem.__slice__(_i + (1 : GoInt)) : GoString);
            };
        };
        if (((_obj._object._name == Go.str()) || (_obj._object._name == ("." : GoString))) || (_obj._object._name == _elem)) {
            _check._softErrorf(Go.asInterface(_obj), (8 : stdgo.internal.types.errors.Errors.Code), ("%q imported and not used" : GoString), Go.toInterface(_path));
        } else {
            _check._softErrorf(Go.asInterface(_obj), (8 : stdgo.internal.types.errors.Errors.Code), ("%q imported as %s and not used" : GoString), Go.toInterface(_path), Go.toInterface(_obj._object._name));
        };
    }
    /**
        // unusedImports checks for unused imports.
    **/
    @:keep
    static public function _unusedImports( _check:Ref<Checker>):Void {
        if (_check._conf.ignoreFuncBodies) {
            return;
        };
        for (__8 => _obj in _check._imports) {
            if (!_obj._used && (_obj._object._name != ("_" : GoString))) {
                _check._errorUnusedPkg(_obj);
            };
        };
    }
    /**
        // packageObjects typechecks all package objects, but not function bodies.
    **/
    @:keep
    static public function _packageObjects( _check:Ref<Checker>):Void {
        var _objList = new Slice<stdgo.go.types.Types.Object>((_check._objMap.length : GoInt).toBasic(), 0);
        var _i:GoInt = (0 : GoInt);
        for (_obj => _ in _check._objMap) {
            _objList[(_i : GoInt)] = _obj;
            _i++;
        };
        stdgo.sort.Sort.sort(Go.asInterface((_objList : T_inSourceOrder)));
        for (__16 => _obj in _objList) {
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_obj) : Ref<TypeName>)) : Ref<TypeName>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.TypeName>), ok : false };
                }, _obj = __tmp__.value, __17 = __tmp__.ok;
                if (((_obj != null) && ((_obj : Dynamic).__nil__ == null || !(_obj : Dynamic).__nil__)) && (_obj._object._typ != null)) {
                    _check._collectMethods(_obj);
                };
            };
        };
        var _aliasList:Slice<Ref<TypeName>> = (null : Slice<Ref<stdgo.go.types.Types.TypeName>>);
        var _othersList:Slice<Object> = (null : Slice<stdgo.go.types.Types.Object>);
        for (__18 => _obj in _objList) {
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_obj) : Ref<TypeName>)) : Ref<TypeName>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.TypeName>), ok : false };
                }, _tname = __tmp__.value, __19 = __tmp__.ok;
                if (_tname != null && ((_tname : Dynamic).__nil__ == null || !(_tname : Dynamic).__nil__)) {
                    if (_check._objMap[Go.asInterface(_tname)]._tdecl.assign.isValid()) {
                        _aliasList = (_aliasList.__append__(_tname));
                    } else {
                        _check._objDecl(_obj, null);
                    };
                } else {
                    _othersList = (_othersList.__append__(_obj));
                };
            };
        };
        for (__28 => _obj in _aliasList) {
            _check._objDecl(Go.asInterface(_obj), null);
        };
        for (__29 => _obj in _othersList) {
            _check._objDecl(_obj, null);
        };
        _check._methods = (null : GoMap<Ref<stdgo.go.types.Types.TypeName>, Slice<Ref<stdgo.go.types.Types.Func>>>);
    }
    /**
        // resolveBaseTypeName returns the non-alias base type name for typ, and whether
        // there was a pointer indirection to get to it. The base type name must be declared
        // in package scope, and there can be at most one pointer indirection. If no such type
        // name exists, the returned base is nil.
    **/
    @:keep
    static public function _resolveBaseTypeName( _check:Ref<Checker>, _seenPtr:Bool, _name:Ref<stdgo.go.ast.Ast.Ident>):{ var _0 : Bool; var _1 : Ref<TypeName>; } {
        var _ptr:Bool = false, _base:Ref<TypeName> = (null : Ref<stdgo.go.types.Types.TypeName>);
        _ptr = _seenPtr;
        var _seen:GoMap<Ref<TypeName>, Bool> = (null : GoMap<Ref<stdgo.go.types.Types.TypeName>, Bool>);
        var _typ:stdgo.go.ast.Ast.Expr = Go.asInterface(_name);
        while (true) {
            _typ = _unparen(_typ);
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_typ) : Ref<stdgo.go.ast.Ast.StarExpr>)) : Ref<stdgo.go.ast.Ast.StarExpr>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.ast.Ast.StarExpr>), ok : false };
                }, _pexpr = __tmp__.value, __0 = __tmp__.ok;
                if (_pexpr != null && ((_pexpr : Dynamic).__nil__ == null || !(_pexpr : Dynamic).__nil__)) {
                    if (_ptr) {
                        return { _0 : false, _1 : null };
                    };
                    _ptr = true;
                    _typ = _unparen(_pexpr.x);
                };
            };
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_typ) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.ast.Ast.Ident>), ok : false };
            }, _name = __tmp__.value, __1 = __tmp__.ok;
            if (_name == null || (_name : Dynamic).__nil__) {
                return { _0 : false, _1 : null };
            };
            var _obj:stdgo.go.types.Types.Object = _check._pkg._scope.lookup(_name.name);
            if (_obj == null) {
                return { _0 : false, _1 : null };
            };
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_obj) : Ref<TypeName>)) : Ref<TypeName>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.TypeName>), ok : false };
            }, _tname = __tmp__.value, __10 = __tmp__.ok;
            if (_tname == null || (_tname : Dynamic).__nil__) {
                return { _0 : false, _1 : null };
            };
            if (_seen[_tname]) {
                return { _0 : false, _1 : null };
            };
            var _tdecl = _check._objMap[Go.asInterface(_tname)]._tdecl;
            if (!_tdecl.assign.isValid()) {
                return { _0 : _ptr, _1 : _tname };
            };
            _typ = _tdecl.type;
            if (_seen == null) {
                _seen = ({
                    final x = new GoRefMap<Ref<stdgo.go.types.Types.TypeName>, Bool>();
                    @:mergeBlock {};
                    cast x;
                } : GoMap<Ref<stdgo.go.types.Types.TypeName>, Bool>);
            };
            _seen[_tname] = true;
        };
    }
    /**
        // unpackRecv unpacks a receiver type and returns its components: ptr indicates whether
        // rtyp is a pointer receiver, rname is the receiver type name, and tparams are its
        // type parameters, if any. The type parameters are only unpacked if unpackParams is
        // set. If rname is nil, the receiver is unusable (i.e., the source has a bug which we
        // cannot easily work around).
    **/
    @:keep
    static public function _unpackRecv( _check:Ref<Checker>, _rtyp:stdgo.go.ast.Ast.Expr, _unpackParams:Bool):{ var _0 : Bool; var _1 : Ref<stdgo.go.ast.Ast.Ident>; var _2 : Slice<Ref<stdgo.go.ast.Ast.Ident>>; } {
        stdgo.internal.Macro.controlFlow({
            var _ptr:Bool = false, _rname:Ref<stdgo.go.ast.Ast.Ident> = (null : Ref<stdgo.go.ast.Ast.Ident>), _tparams:Slice<Ref<stdgo.go.ast.Ast.Ident>> = (null : Slice<Ref<stdgo.go.ast.Ast.Ident>>);
            @:label("L") while (true) {
                {
                    final __type__ = _rtyp;
                    {
                        var __bool__ = true;
                        while (__bool__) {
                            __bool__ = false;
                            if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ParenExpr>))) {
                                var _t:Ref<stdgo.go.ast.Ast.ParenExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__().value;
                                _rtyp = _t.x;
                            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.StarExpr>))) {
                                var _t:Ref<stdgo.go.ast.Ast.StarExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__().value;
                                _ptr = true;
                                _rtyp = _t.x;
                            } else {
                                var _t:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                                @:jump("L") break;
                            };
                            break;
                        };
                    };
                };
            };
            {
                final __type__ = _rtyp;
                if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexExpr>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexListExpr>))) {
                    var _ix = stdgo.go.internal.typeparams.Typeparams.unpackIndexExpr(_rtyp);
                    _rtyp = _ix.indexListExpr.x;
                    if (_unpackParams) {
                        for (__0 => _arg in _ix.indexListExpr.indices) {
                            var _par:Ref<stdgo.go.ast.Ast.Ident> = (null : Ref<stdgo.go.ast.Ast.Ident>);
                            {
                                final __type__ = _arg;
                                if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ident>))) {
                                    var _arg:Ref<stdgo.go.ast.Ast.Ident> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__().value;
                                    _par = _arg;
                                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BadExpr>))) {
                                    var _arg:Ref<stdgo.go.ast.Ast.BadExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BadExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BadExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BadExpr>) : __type__.__underlying__().value;
                                } else if (__type__ == null) {
                                    var _arg:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
                                    _check._error(_ix.orig, (-1 : stdgo.internal.types.errors.Errors.Code), ("parameterized receiver contains nil parameters" : GoString));
                                } else {
                                    var _arg:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                                    _check._errorf(_arg, (131 : stdgo.internal.types.errors.Errors.Code), ("receiver type parameter %s must be an identifier" : GoString), Go.toInterface(_arg));
                                };
                            };
                            if (_par == null || (_par : Dynamic).__nil__) {
                                _par = (Go.setRef(({ namePos : _arg.pos(), name : ("_" : GoString) } : stdgo.go.ast.Ast.Ident)) : Ref<stdgo.go.ast.Ast.Ident>);
                            };
                            _tparams = (_tparams.__append__(_par));
                        };
                    };
                };
            };
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_rtyp) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.ast.Ast.Ident>), ok : false };
                }, _name = __tmp__.value, __1 = __tmp__.ok;
                if (_name != null && ((_name : Dynamic).__nil__ == null || !(_name : Dynamic).__nil__)) {
                    _rname = _name;
                };
            };
            return { _0 : _ptr, _1 : _rname, _2 : _tparams };
        });
        throw "controlFlow did not return";
    }
    /**
        // collectObjects collects all file and package objects and inserts them
        // into their respective scopes. It also performs imports and associates
        // methods with receiver base type names.
    **/
    @:keep
    static public function _collectObjects( _check:Ref<Checker>):Void {
        var _pkg = _check._pkg;
        var _pkgImports:GoMap<Ref<stdgo.go.types.Types.Package>, Bool> = ({
            final x = new GoRefMap<Ref<stdgo.go.types.Types.Package>, Bool>();
            @:mergeBlock {};
            cast x;
        } : GoMap<Ref<stdgo.go.types.Types.Package>, Bool>);
        for (__8 => _imp in _pkg._imports) {
            _pkgImports[_imp] = true;
        };
        {};
        var _methods:Slice<T__collectObjects_0___localname___methodInfo> = (null : Slice<stdgo.go.types.Types.T__collectObjects_0___localname___methodInfo>);
        var _fileScopes:Slice<Ref<Scope>> = (null : Slice<Ref<stdgo.go.types.Types.Scope>>);
        for (_fileNo => _file in _check._files) {
            _check._recordDef(_file.name, (null : stdgo.go.types.Types.Object));
            var __0:stdgo.go.token.Token.Pos = _file.pos(), __1:stdgo.go.token.Token.Pos = _file.end(), _end:stdgo.go.token.Token.Pos = __1, _pos:stdgo.go.token.Token.Pos = __0;
            {
                var _f = _check._fset.file(_file.pos());
                if (_f != null && ((_f : Dynamic).__nil__ == null || !(_f : Dynamic).__nil__)) {
                    {
                        final __tmp__0 = (_f.base() : stdgo.go.token.Token.Pos);
                        final __tmp__1 = (_f.base() + _f.size() : stdgo.go.token.Token.Pos);
                        _pos = __tmp__0;
                        _end = __tmp__1;
                    };
                };
            };
            var _fileScope = newScope(_check._pkg._scope, _pos, _end, _check._filename(_fileNo));
            _fileScopes = (_fileScopes.__append__(_fileScope));
            _check._recordScope(Go.asInterface(_file), _fileScope);
            var _fileDir:GoString = _dir(_check._fset.position(_file.name.pos()).filename);
            _check._walkDecls(_file.decls, function(_d:T_decl):Void {
                {
                    final __type__ = _d;
                    if (Go.typeEquals((__type__ : T_importDecl))) {
                        var _d:stdgo.go.types.Types.T_importDecl = __type__ == null ? ({} : stdgo.go.types.Types.T_importDecl) : __type__.__underlying__() == null ? ({} : stdgo.go.types.Types.T_importDecl) : __type__ == null ? ({} : stdgo.go.types.Types.T_importDecl) : __type__.__underlying__().value;
                        if (_d._spec.path.value == (Go.str())) {
                            return;
                        };
                        var __tmp__ = _validatedImportPath(_d._spec.path.value), _path:GoString = __tmp__._0, _err:Error = __tmp__._1;
                        if (_err != null) {
                            _check._errorf(Go.asInterface(_d._spec.path), (5 : stdgo.internal.types.errors.Errors.Code), ("invalid import path (%s)" : GoString), Go.toInterface(_err));
                            return;
                        };
                        var _imp = _check._importPackage(Go.asInterface(_d._spec.path), _path, _fileDir);
                        if (_imp == null || (_imp : Dynamic).__nil__) {
                            return;
                        };
                        var _name:GoString = _imp._name;
                        if (_d._spec.name != null && ((_d._spec.name : Dynamic).__nil__ == null || !(_d._spec.name : Dynamic).__nil__)) {
                            _name = _d._spec.name.name;
                            if (_path == (("C" : GoString))) {
                                _check._error(Go.asInterface(_d._spec.name), (7 : stdgo.internal.types.errors.Errors.Code), ("cannot rename import \"C\"" : GoString));
                                return;
                            };
                        };
                        if (_name == (("init" : GoString))) {
                            _check._error(Go.asInterface(_d._spec), (39 : stdgo.internal.types.errors.Errors.Code), ("cannot import package as init - init must be a func" : GoString));
                            return;
                        };
                        if (!_pkgImports[_imp]) {
                            _pkgImports[_imp] = true;
                            _pkg._imports = (_pkg._imports.__append__(_imp));
                        };
                        var _pkgName = newPkgName(_d._spec.pos(), _pkg, _name, _imp);
                        if (_d._spec.name != null && ((_d._spec.name : Dynamic).__nil__ == null || !(_d._spec.name : Dynamic).__nil__)) {
                            _check._recordDef(_d._spec.name, Go.asInterface(_pkgName));
                        } else {
                            _check._recordImplicit(Go.asInterface(_d._spec), Go.asInterface(_pkgName));
                        };
                        if (_imp._fake) {
                            _pkgName._used = true;
                        };
                        _check._imports = (_check._imports.__append__(_pkgName));
                        if (_name == (("." : GoString))) {
                            if (_check._dotImportMap == null) {
                                _check._dotImportMap = ({
                                    final x = new GoObjectMap<stdgo.go.types.Types.T_dotImportKey, Ref<stdgo.go.types.Types.PkgName>>();
                                    x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.T_dotImportKey", [], stdgo.internal.reflect.Reflect.GoType.structType([{ name : "_scope", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.refType({ get : () -> stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Scope", [], stdgo.internal.reflect.Reflect.GoType.structType([{ name : "_parent", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.refType({ get : () -> stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Scope", [], stdgo.internal.reflect.Reflect.GoType.invalidType, false, { get : () -> null }) }) }, optional : false }, { name : "_children", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.sliceType({ get : () -> stdgo.internal.reflect.Reflect.GoType.refType({ get : () -> stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Scope", [], stdgo.internal.reflect.Reflect.GoType.invalidType, false, { get : () -> null }) }) }) }, optional : false }, { name : "_number", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.basic(int_kind) }, optional : false }, { name : "_elems", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.mapType({ get : () -> stdgo.internal.reflect.Reflect.GoType.basic(string_kind) }, { get : () -> stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Object", [], stdgo.internal.reflect.Reflect.GoType.named("Object", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }) }) }, optional : false }, { name : "_pos", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.token.Token.Pos", [], stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.token.Token.Pos", [], stdgo.internal.reflect.Reflect.GoType.invalidType, false, { get : () -> null }), false, { get : () -> null }) }, optional : false }, { name : "_end", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.token.Token.Pos", [], stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.token.Token.Pos", [], stdgo.internal.reflect.Reflect.GoType.invalidType, false, { get : () -> null }), false, { get : () -> null }) }, optional : false }, { name : "_comment", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.basic(string_kind) }, optional : false }, { name : "_isFunc", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind) }, optional : false }]), false, { get : () -> null }) }) }, optional : false }, { name : "_name", embedded : false, tag : "", type : { get : () -> stdgo.internal.reflect.Reflect.GoType.basic(string_kind) }, optional : false }]), false, { get : () -> null }));
                                    x.__defaultValue__ = () -> (null : Ref<stdgo.go.types.Types.PkgName>);
                                    @:mergeBlock {};
                                    cast x;
                                } : GoMap<stdgo.go.types.Types.T_dotImportKey, Ref<stdgo.go.types.Types.PkgName>>);
                            };
                            for (_name => _obj in _imp._scope._elems) {
                                if (stdgo.go.token.Token.isExported(_name)) {
                                    {
                                        var _alt:stdgo.go.types.Types.Object = _fileScope.lookup(_name);
                                        if (_alt != null) {
                                            _check._errorf(Go.asInterface(_d._spec.name), (10 : stdgo.internal.types.errors.Errors.Code), ("%s redeclared in this block" : GoString), Go.toInterface(_alt.name()));
                                            _check._reportAltDecl(_alt);
                                        } else {
                                            _fileScope._insert(_name, _obj);
                                            _check._dotImportMap[(new T_dotImportKey(_fileScope, _name) : T_dotImportKey)] = _pkgName;
                                        };
                                    };
                                };
                            };
                        } else {
                            _check._declare(_fileScope, null, Go.asInterface(_pkgName), (0 : stdgo.go.token.Token.Pos));
                        };
                    } else if (Go.typeEquals((__type__ : T_constDecl))) {
                        var _d:stdgo.go.types.Types.T_constDecl = __type__ == null ? ({} : stdgo.go.types.Types.T_constDecl) : __type__.__underlying__() == null ? ({} : stdgo.go.types.Types.T_constDecl) : __type__ == null ? ({} : stdgo.go.types.Types.T_constDecl) : __type__.__underlying__().value;
                        for (_i => _name in _d._spec.names) {
                            var _obj = newConst(_name.pos(), _pkg, _name.name, (null : stdgo.go.types.Types.Type), stdgo.go.constant.Constant.makeInt64((_d._iota : GoInt64)));
                            var _init:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
                            if (_i < (_d._init.length)) {
                                _init = _d._init[(_i : GoInt)];
                            };
                            var _d = (Go.setRef(({ _file : _fileScope, _vtyp : _d._typ, _init : _init, _inherited : _d._inherited } : T_declInfo)) : Ref<stdgo.go.types.Types.T_declInfo>);
                            _check._declarePkgObj(_name, Go.asInterface(_obj), _d);
                        };
                    } else if (Go.typeEquals((__type__ : T_varDecl))) {
                        var _d:stdgo.go.types.Types.T_varDecl = __type__ == null ? ({} : stdgo.go.types.Types.T_varDecl) : __type__.__underlying__() == null ? ({} : stdgo.go.types.Types.T_varDecl) : __type__ == null ? ({} : stdgo.go.types.Types.T_varDecl) : __type__.__underlying__().value;
                        var _lhs = new Slice<Ref<stdgo.go.types.Types.Var>>((_d._spec.names.length : GoInt).toBasic(), 0);
                        var _d1:Ref<T_declInfo> = (null : Ref<stdgo.go.types.Types.T_declInfo>);
                        if ((_d._spec.values.length) == ((1 : GoInt))) {
                            _d1 = (Go.setRef(({ _file : _fileScope, _lhs : _lhs, _vtyp : _d._spec.type, _init : _d._spec.values[(0 : GoInt)] } : T_declInfo)) : Ref<stdgo.go.types.Types.T_declInfo>);
                        };
                        for (_i => _name in _d._spec.names) {
                            var _obj = newVar(_name.pos(), _pkg, _name.name, (null : stdgo.go.types.Types.Type));
                            _lhs[(_i : GoInt)] = _obj;
                            var _di = _d1;
                            if (_di == null || (_di : Dynamic).__nil__) {
                                var _init:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
                                if (_i < (_d._spec.values.length)) {
                                    _init = _d._spec.values[(_i : GoInt)];
                                };
                                _di = (Go.setRef(({ _file : _fileScope, _vtyp : _d._spec.type, _init : _init } : T_declInfo)) : Ref<stdgo.go.types.Types.T_declInfo>);
                            };
                            _check._declarePkgObj(_name, Go.asInterface(_obj), _di);
                        };
                    } else if (Go.typeEquals((__type__ : T_typeDecl))) {
                        var _d:stdgo.go.types.Types.T_typeDecl = __type__ == null ? ({} : stdgo.go.types.Types.T_typeDecl) : __type__.__underlying__() == null ? ({} : stdgo.go.types.Types.T_typeDecl) : __type__ == null ? ({} : stdgo.go.types.Types.T_typeDecl) : __type__.__underlying__().value;
                        if ((_d._spec.typeParams.numFields() != (0 : GoInt)) && !_check._allowVersion(_pkg, (1 : GoInt), (18 : GoInt))) {
                            _check._softErrorf(Go.asInterface(_d._spec.typeParams.list[(0 : GoInt)]), (135 : stdgo.internal.types.errors.Errors.Code), ("type parameter requires go1.18 or later" : GoString));
                        };
                        var _obj = newTypeName(_d._spec.name.pos(), _pkg, _d._spec.name.name, (null : stdgo.go.types.Types.Type));
                        _check._declarePkgObj(_d._spec.name, Go.asInterface(_obj), (Go.setRef(({ _file : _fileScope, _tdecl : _d._spec } : T_declInfo)) : Ref<stdgo.go.types.Types.T_declInfo>));
                    } else if (Go.typeEquals((__type__ : T_funcDecl))) {
                        var _d:stdgo.go.types.Types.T_funcDecl = __type__ == null ? ({} : stdgo.go.types.Types.T_funcDecl) : __type__.__underlying__() == null ? ({} : stdgo.go.types.Types.T_funcDecl) : __type__ == null ? ({} : stdgo.go.types.Types.T_funcDecl) : __type__.__underlying__().value;
                        var _name:GoString = _d._decl.name.name;
                        var _obj = newFunc(_d._decl.name.pos(), _pkg, _name, null);
                        var _hasTParamError:Bool = false;
                        if (_d._decl.recv.numFields() == ((0 : GoInt))) {
                            if (_d._decl.recv != null && ((_d._decl.recv : Dynamic).__nil__ == null || !(_d._decl.recv : Dynamic).__nil__)) {
                                _check._error(Go.asInterface(_d._decl.recv), (31 : stdgo.internal.types.errors.Errors.Code), ("method has no receiver" : GoString));
                            };
                            if ((_name == ("init" : GoString)) || ((_name == ("main" : GoString)) && (_check._pkg._name == ("main" : GoString)))) {
                                var _code:stdgo.internal.types.errors.Errors.Code = (39 : stdgo.internal.types.errors.Errors.Code);
                                if (_name == (("main" : GoString))) {
                                    _code = (40 : stdgo.internal.types.errors.Errors.Code);
                                };
                                if (_d._decl.type.typeParams.numFields() != ((0 : GoInt))) {
                                    _check._softErrorf(Go.asInterface(_d._decl.type.typeParams.list[(0 : GoInt)]), _code, ("func %s must have no type parameters" : GoString), Go.toInterface(_name));
                                    _hasTParamError = true;
                                };
                                {
                                    var _t = _d._decl.type;
                                    if ((_t.params.numFields() != (0 : GoInt)) || ((_t.results != null) && ((_t.results : Dynamic).__nil__ == null || !(_t.results : Dynamic).__nil__))) {
                                        _check._softErrorf(Go.asInterface(_d._decl.name), _code, ("func %s must have no arguments and no return values" : GoString), Go.toInterface(_name));
                                    };
                                };
                            };
                            if (_name == (("init" : GoString))) {
                                _obj._object._parent = _pkg._scope;
                                _check._recordDef(_d._decl.name, Go.asInterface(_obj));
                                if (_d._decl.body == null || (_d._decl.body : Dynamic).__nil__) {
                                    _check._softErrorf(Go.asInterface(_obj), (37 : stdgo.internal.types.errors.Errors.Code), ("missing function body" : GoString));
                                };
                            } else {
                                _check._declare(_pkg._scope, _d._decl.name, Go.asInterface(_obj), (0 : stdgo.go.token.Token.Pos));
                            };
                        } else {
                            var __tmp__ = _check._unpackRecv(_d._decl.recv.list[(0 : GoInt)].type, false), _ptr:Bool = __tmp__._0, _recv:Ref<stdgo.go.ast.Ast.Ident> = __tmp__._1, __48:Slice<Ref<stdgo.go.ast.Ast.Ident>> = __tmp__._2;
                            if (((_recv != null) && ((_recv : Dynamic).__nil__ == null || !(_recv : Dynamic).__nil__)) && (_name != ("_" : GoString))) {
                                _methods = (_methods.__append__((new T__collectObjects_0___localname___methodInfo(_obj, _ptr, _recv) : T__collectObjects_0___localname___methodInfo)));
                            };
                            _check._recordDef(_d._decl.name, Go.asInterface(_obj));
                        };
                        if (((_d._decl.type.typeParams.numFields() != (0 : GoInt)) && !_check._allowVersion(_pkg, (1 : GoInt), (18 : GoInt))) && !_hasTParamError) {
                            _check._softErrorf(Go.asInterface(_d._decl.type.typeParams.list[(0 : GoInt)]), (135 : stdgo.internal.types.errors.Errors.Code), ("type parameter requires go1.18 or later" : GoString));
                        };
                        var _info = (Go.setRef(({ _file : _fileScope, _fdecl : _d._decl } : T_declInfo)) : Ref<stdgo.go.types.Types.T_declInfo>);
                        _check._objMap[Go.asInterface(_obj)] = _info;
                        _obj._setOrder((_check._objMap.length : GoUInt32));
                    };
                };
            });
        };
        for (__41 => _scope in _fileScopes) {
            for (_name => _obj in _scope._elems) {
                {
                    var _alt:stdgo.go.types.Types.Object = _pkg._scope.lookup(_name);
                    if (_alt != null) {
                        _obj = _resolve(_name, _obj);
                        {
                            var __tmp__ = try {
                                { value : (Go.typeAssert((Go.toInterface(_obj) : Ref<PkgName>)) : Ref<PkgName>), ok : true };
                            } catch(_) {
                                { value : (null : Ref<stdgo.go.types.Types.PkgName>), ok : false };
                            }, _pkg = __tmp__.value, _ok = __tmp__.ok;
                            if (_ok) {
                                _check._errorf(_alt, (10 : stdgo.internal.types.errors.Errors.Code), ("%s already declared through import of %s" : GoString), Go.toInterface(_alt.name()), Go.toInterface(Go.asInterface(_pkg.imported())));
                                _check._reportAltDecl(Go.asInterface(_pkg));
                            } else {
                                _check._errorf(_alt, (10 : stdgo.internal.types.errors.Errors.Code), ("%s already declared through dot-import of %s" : GoString), Go.toInterface(_alt.name()), Go.toInterface(Go.asInterface(_obj.pkg())));
                                _check._reportAltDecl(_obj);
                            };
                        };
                    };
                };
            };
        };
        if (_methods == null) {
            return;
        };
        _check._methods = ({
            final x = new GoRefMap<Ref<stdgo.go.types.Types.TypeName>, Slice<Ref<stdgo.go.types.Types.Func>>>();
            @:mergeBlock {};
            cast x;
        } : GoMap<Ref<stdgo.go.types.Types.TypeName>, Slice<Ref<stdgo.go.types.Types.Func>>>);
        for (_i in 0 ... _methods.length.toBasic()) {
            var _m = (Go.setRef(_methods[(_i : GoInt)]) : Ref<stdgo.go.types.Types.T__collectObjects_0___localname___methodInfo>);
            var __tmp__ = _check._resolveBaseTypeName(_m._ptr, _m._recv), _ptr:Bool = __tmp__._0, _base:Ref<stdgo.go.types.Types.TypeName> = __tmp__._1;
            if (_base != null && ((_base : Dynamic).__nil__ == null || !(_base : Dynamic).__nil__)) {
                _m._obj._hasPtrRecv_ = _ptr;
                _check._methods[_base] = (_check._methods[_base].__append__(_m._obj));
            };
        };
    }
    @:keep
    static public function _importPackage( _check:Ref<Checker>, _at:T_positioner, _path:GoString, _dir:GoString):Ref<Package> {
        var _key:stdgo.go.types.Types.T_importKey = (new T_importKey(_path, _dir) : T_importKey);
        var _imp = _check._impMap[_key?.__copy__()];
        if (_imp != null && ((_imp : Dynamic).__nil__ == null || !(_imp : Dynamic).__nil__)) {
            return _imp;
        };
        if ((_path == ("C" : GoString)) && (_check._conf.fakeImportC || _check._conf._go115UsesCgo)) {
            _imp = newPackage(("C" : GoString), ("C" : GoString));
            _imp._fake = true;
            _imp._cgo = _check._conf._go115UsesCgo;
        } else {
            var _err:Error = (null : Error);
            {
                var _importer:stdgo.go.types.Types.Importer = _check._conf.importer;
                if (_importer == null) {
                    _err = stdgo.fmt.Fmt.errorf(("Config.Importer not installed" : GoString));
                } else {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_importer) : ImporterFrom)) : ImporterFrom), ok : true };
                    } catch(_) {
                        { value : (null : stdgo.go.types.Types.ImporterFrom), ok : false };
                    }, _importerFrom = __tmp__.value, _ok = __tmp__.ok;
                    if (_ok) {
                        {
                            var __tmp__ = _importerFrom.importFrom(_path, _dir, (0 : stdgo.go.types.Types.ImportMode));
                            _imp = __tmp__._0;
                            _err = __tmp__._1;
                        };
                        if ((_imp == null) || (_imp : Dynamic).__nil__ && (_err == null)) {
                            _err = stdgo.fmt.Fmt.errorf(("Config.Importer.ImportFrom(%s, %s, 0) returned nil but no error" : GoString), Go.toInterface(_path), Go.toInterface(_dir));
                        };
                    } else {
                        {
                            var __tmp__ = _importer.import_(_path);
                            _imp = __tmp__._0;
                            _err = __tmp__._1;
                        };
                        if ((_imp == null) || (_imp : Dynamic).__nil__ && (_err == null)) {
                            _err = stdgo.fmt.Fmt.errorf(("Config.Importer.Import(%s) returned nil but no error" : GoString), Go.toInterface(_path));
                        };
                    };
                };
            };
            if (((_err == null) && ((_imp != null) && ((_imp : Dynamic).__nil__ == null || !(_imp : Dynamic).__nil__))) && ((_imp._name == ("_" : GoString)) || (_imp._name == Go.str()))) {
                _err = stdgo.fmt.Fmt.errorf(("invalid package name: %q" : GoString), Go.toInterface(_imp._name));
                _imp = null;
            };
            if (_err != null) {
                _check._errorf(_at, (6 : stdgo.internal.types.errors.Errors.Code), ("could not import %s (%s)" : GoString), Go.toInterface(_path), Go.toInterface(_err));
                if (_imp == null || (_imp : Dynamic).__nil__) {
                    var _name:GoString = _path;
                    {
                        var _i:GoInt = (_name.length);
                        if ((_i > (0 : GoInt)) && (_name[(_i - (1 : GoInt) : GoInt)] == (47 : GoUInt8))) {
                            _name = (_name.__slice__(0, _i - (1 : GoInt)) : GoString);
                        };
                    };
                    {
                        var _i:GoInt = stdgo.strings.Strings.lastIndex(_name, ("/" : GoString));
                        if (_i >= (0 : GoInt)) {
                            _name = (_name.__slice__(_i + (1 : GoInt)) : GoString);
                        };
                    };
                    _imp = newPackage(_path, _name);
                };
                _imp._fake = true;
            };
        };
        if (_imp._complete || _imp._fake) {
            _check._impMap[_key?.__copy__()] = _imp;
            if (_check._pkgPathMap != null) {
                _check._markImports(_imp);
            };
            return _imp;
        };
        return null;
    }
    /**
        // filename returns a filename suitable for debugging output.
    **/
    @:keep
    static public function _filename( _check:Ref<Checker>, _fileNo:GoInt):GoString {
        var _file = _check._files[(_fileNo : GoInt)];
        {
            var _pos:stdgo.go.token.Token.Pos = _file.pos();
            if (_pos.isValid()) {
                return _check._fset.file(_pos).name();
            };
        };
        return stdgo.fmt.Fmt.sprintf(("file[%d]" : GoString), Go.toInterface(_fileNo));
    }
    /**
        // declarePkgObj declares obj in the package scope, records its ident -> obj mapping,
        // and updates check.objMap. The object must not be a function or method.
    **/
    @:keep
    static public function _declarePkgObj( _check:Ref<Checker>, _ident:Ref<stdgo.go.ast.Ast.Ident>, _obj:Object, _d:Ref<T_declInfo>):Void {
        _assert(_ident.name == (_obj.name()));
        if (_ident.name == (("init" : GoString))) {
            _check._error(Go.asInterface(_ident), (39 : stdgo.internal.types.errors.Errors.Code), ("cannot declare init - must be func" : GoString));
            return;
        };
        if ((_ident.name == ("main" : GoString)) && (_check._pkg._name == ("main" : GoString))) {
            _check._error(Go.asInterface(_ident), (40 : stdgo.internal.types.errors.Errors.Code), ("cannot declare main - must be func" : GoString));
            return;
        };
        _check._declare(_check._pkg._scope, _ident, _obj, (0 : stdgo.go.token.Token.Pos));
        _check._objMap[_obj] = _d;
        _obj._setOrder((_check._objMap.length : GoUInt32));
    }
    /**
        // arityMatch checks that the lhs and rhs of a const or var decl
        // have the appropriate number of names and init exprs. For const
        // decls, init is the value spec providing the init exprs; for
        // var decls, init is nil (the init exprs are in s in this case).
    **/
    @:keep
    static public function _arityMatch( _check:Ref<Checker>, _s:Ref<stdgo.go.ast.Ast.ValueSpec>, _init:Ref<stdgo.go.ast.Ast.ValueSpec>):Void {
        var _l:GoInt = (_s.names.length);
        var _r:GoInt = (_s.values.length);
        if (_init != null && ((_init : Dynamic).__nil__ == null || !(_init : Dynamic).__nil__)) {
            _r = (_init.values.length);
        };
        {};
        if ((_init == null) || (_init : Dynamic).__nil__ && (_r == (0 : GoInt))) {
            if (_s.type == null) {
                _check._error(Go.asInterface(_s), (17 : stdgo.internal.types.errors.Errors.Code), ("missing type or init expr" : GoString));
            };
        } else if (_l < _r) {
            if (_l < (_s.values.length)) {
                var _n:stdgo.go.ast.Ast.Expr = _s.values[(_l : GoInt)];
                _check._errorf(_n, (17 : stdgo.internal.types.errors.Errors.Code), ("extra init expr %s" : GoString), Go.toInterface(_n));
            } else {
                _check._errorf(Go.asInterface(_s), (17 : stdgo.internal.types.errors.Errors.Code), ("extra init expr at %s" : GoString), Go.toInterface(Go.asInterface(_check._fset.position(_init.pos()))));
            };
        } else if ((_l > _r) && (((_init != null) && ((_init : Dynamic).__nil__ == null || !(_init : Dynamic).__nil__)) || (_r != (1 : GoInt)))) {
            var _n = _s.names[(_r : GoInt)];
            _check._errorf(Go.asInterface(_n), (17 : stdgo.internal.types.errors.Errors.Code), ("missing init expr for %s" : GoString), Go.toInterface(Go.asInterface(_n)));
        };
    }
    /**
        // context returns the type-checker context.
    **/
    @:keep
    static public function _context( _check:Ref<Checker>):Ref<Context> {
        if (_check._ctxt == null || (_check._ctxt : Dynamic).__nil__) {
            _check._ctxt = newContext();
        };
        return _check._ctxt;
    }
    /**
        // newNamedInstance creates a new named instance for the given origin and type
        // arguments, recording pos as the position of its synthetic object (for error
        // reporting).
        //
        // If set, expanding is the named type instance currently being expanded, that
        // led to the creation of this instance.
    **/
    @:keep
    static public function _newNamedInstance( _check:Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _orig:Ref<Named>, _targs:Slice<Type>, _expanding:Ref<Named>):Ref<Named> {
        _assert((_targs.length) > (0 : GoInt));
        var _obj = newTypeName(_pos, _orig._obj._object._pkg, _orig._obj._object._name, (null : stdgo.go.types.Types.Type));
        var _inst = (Go.setRef(({ _orig : _orig, _targs : _newTypeList(_targs) } : T_instance)) : Ref<stdgo.go.types.Types.T_instance>);
        if (((_expanding != null) && ((_expanding : Dynamic).__nil__ == null || !(_expanding : Dynamic).__nil__)) && (_expanding.obj()._object._pkg == _obj._object._pkg)) {
            _inst._ctxt = _expanding._inst._ctxt;
        };
        var _typ = (Go.setRef(({ _check : _check, _obj : _obj, _inst : _inst } : Named)) : Ref<stdgo.go.types.Types.Named>);
        _obj._object._typ = Go.asInterface(_typ);
        if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
            _check._needsCleanup(Go.asInterface(_typ));
        };
        return _typ;
    }
    /**
        // newNamed is like NewNamed but with a *Checker receiver and additional orig argument.
    **/
    @:keep
    static public function _newNamed( _check:Ref<Checker>, _obj:Ref<TypeName>, _underlying:Type, _methods:Slice<Ref<Func>>):Ref<Named> {
        var _typ = (Go.setRef(({ _check : _check, _obj : _obj, _fromRHS : _underlying, _underlying : _underlying, _methods : _methods } : Named)) : Ref<stdgo.go.types.Types.Named>);
        if (_obj._object._typ == null) {
            _obj._object._typ = Go.asInterface(_typ);
        };
        if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
            _check._needsCleanup(Go.asInterface(_typ));
        };
        return _typ;
    }
    @:keep
    static public function _reportInstanceLoop( _check:Ref<Checker>, _v:GoInt):Void {
        var _stack:Slice<GoInt> = (null : Slice<GoInt>);
        var _seen = new Slice<Bool>((_check._mono._vertices.length : GoInt).toBasic(), 0);
        while (!_seen[(_v : GoInt)]) {
            _stack = (_stack.__append__(_v));
            _seen[(_v : GoInt)] = true;
            _v = _check._mono._edges[(_check._mono._vertices[(_v : GoInt)]._pre : GoInt)]._src;
        };
        while (_stack[(0 : GoInt)] != (_v)) {
            _stack = (_stack.__slice__((1 : GoInt)) : Slice<GoInt>);
        };
        var _obj0 = _check._mono._vertices[(_v : GoInt)]._obj;
        _check._error(Go.asInterface(_obj0), (140 : stdgo.internal.types.errors.Errors.Code), ("instantiation cycle:" : GoString));
        var _qf:stdgo.go.types.Types.Qualifier = relativeTo(_check._pkg);
        for (__40 => _v in _stack) {
            var _edge:stdgo.go.types.Types.T_monoEdge = _check._mono._edges[(_check._mono._vertices[(_v : GoInt)]._pre : GoInt)];
            var _obj = _check._mono._vertices[(_edge._dst : GoInt)]._obj;
            {
                final __type__ = _obj.type();
                if (Go.typeEquals((__type__ : Ref<Named>))) {
                    _check._errorf(Go.asInterface((_edge._pos : T_atPos)), (140 : stdgo.internal.types.errors.Errors.Code), ("\t%s implicitly parameterized by %s" : GoString), Go.toInterface(_obj.name()), Go.toInterface(typeString(_edge._typ, _qf)));
                } else if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
                    _check._errorf(Go.asInterface((_edge._pos : T_atPos)), (140 : stdgo.internal.types.errors.Errors.Code), ("\t%s instantiated as %s" : GoString), Go.toInterface(_obj.name()), Go.toInterface(typeString(_edge._typ, _qf)));
                } else {
                    throw Go.toInterface(("unexpected type" : GoString));
                };
            };
        };
    }
    @:keep
    static public function _monomorph( _check:Ref<Checker>):Void {
        var _again:Bool = true;
        while (_again) {
            _again = false;
            for (_i => _edge in _check._mono._edges) {
                var _src = (Go.setRef(_check._mono._vertices[(_edge._src : GoInt)]) : Ref<stdgo.go.types.Types.T_monoVertex>);
                var _dst = (Go.setRef(_check._mono._vertices[(_edge._dst : GoInt)]) : Ref<stdgo.go.types.Types.T_monoVertex>);
                var _w:GoInt = _src._weight + _edge._weight;
                if (_w <= _dst._weight) {
                    continue;
                };
                _dst._pre = _i;
                _dst._len = _src._len + (1 : GoInt);
                if (_dst._len == ((_check._mono._vertices.length))) {
                    _check._reportInstanceLoop(_edge._dst);
                    return;
                };
                _dst._weight = _w;
                _again = true;
            };
        };
    }
    /**
        // newAssertableTo reports whether a value of type V can be asserted to have type T.
        // It also implements behavior for interfaces that currently are only permitted
        // in constraint position (we have not yet defined that behavior in the spec).
    **/
    @:keep
    static public function _newAssertableTo( _check:Ref<Checker>, v:Ref<Interface>, t:Type):Bool {
        if (isInterface(t)) {
            return true;
        };
        return _check._implements(t, Go.asInterface(v), false, (null : Pointer<GoString>));
    }
    /**
        // assertableTo reports whether a value of type V can be asserted to have type T.
        // It returns (nil, false) as affirmative answer. Otherwise it returns a missing
        // method required by V and whether it is missing or just has the wrong type.
        // The receiver may be nil if assertableTo is invoked through an exported API call
        // (such as AssertableTo), i.e., when all methods have been type-checked.
        // TODO(gri) replace calls to this function with calls to newAssertableTo.
    **/
    @:keep
    static public function _assertableTo( _check:Ref<Checker>, v:Ref<Interface>, t:Type):{ var _0 : Ref<Func>; var _1 : Ref<Func>; } {
        var _method:Ref<Func> = (null : Ref<stdgo.go.types.Types.Func>), _wrongType:Ref<Func> = (null : Ref<stdgo.go.types.Types.Func>);
        if (isInterface(t)) {
            return { _0 : _method, _1 : _wrongType };
        };
        return _check._missingMethod(t, v, false);
    }
    /**
        // funcString returns a string of the form name + signature for f.
        // check may be nil.
    **/
    @:keep
    static public function _funcString( _check:Ref<Checker>, _f:Ref<Func>, _pkgInfo:Bool):GoString {
        var _buf = stdgo.bytes.Bytes.newBufferString(_f._object._name);
        var _qf:Qualifier = (null : stdgo.go.types.Types.Qualifier);
        if (((_check != null) && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) && !_pkgInfo) {
            _qf = _check._qualifier;
        };
        var _w = _newTypeWriter(_buf, _qf);
        _w._pkgInfo = _pkgInfo;
        _w._paramNames = false;
        _w._signature((Go.typeAssert((Go.toInterface(_f._object._typ) : Ref<Signature>)) : Ref<Signature>));
        return (_buf.string() : GoString);
    }
    /**
        // check may be nil.
    **/
    @:keep
    static public function _interfacePtrError( _check:Ref<Checker>, t:Type):GoString {
        _assert(_isInterfacePtr(t));
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_under(t)) : Ref<Pointer_>)) : Ref<Pointer_>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Pointer_>), ok : false };
            }, _p = __tmp__.value, __0 = __tmp__.ok;
            if (_isTypeParam(_p._base)) {
                return _check._sprintf(("type %s is pointer to type parameter, not type parameter" : GoString), Go.toInterface(t));
            };
        };
        return _check._sprintf(("type %s is pointer to interface, not interface" : GoString), Go.toInterface(t));
    }
    /**
        // missingMethodCause returns a string giving the detailed cause for a missing method m,
        // where m is missing from V, but required by T. It puts the cause in parentheses,
        // and may include more have/want info after that. If non-nil, alt is a relevant
        // method that matches in some way. It may have the correct name, but wrong type, or
        // it may have a pointer receiver, or it may have the correct name except wrong case.
        // check may be nil.
    **/
    @:keep
    static public function _missingMethodCause( _check:Ref<Checker>, v:Type, t:Type, _m:Ref<Func>, _alt:Ref<Func>):GoString {
        var _mname:GoString = ("method " : GoString) + _m.name();
        if (_alt != null && ((_alt : Dynamic).__nil__ == null || !(_alt : Dynamic).__nil__)) {
            if (_m.name() != (_alt.name())) {
                return _check._sprintf(("(missing %s)\n\t\thave %s\n\t\twant %s" : GoString), Go.toInterface(_mname), Go.toInterface(_check._funcString(_alt, false)), Go.toInterface(_check._funcString(_m, false)));
            };
            if (identical(_m._object._typ, _alt._object._typ)) {
                return _check._sprintf(("(%s has pointer receiver)" : GoString), Go.toInterface(_mname));
            };
            var __0:GoString = _check._funcString(_alt, false), __1:GoString = _check._funcString(_m, false), _mS:GoString = __1, _altS:GoString = __0;
            if (_altS == (_mS)) {
                {
                    final __tmp__0 = _check._funcString(_alt, true);
                    final __tmp__1 = _check._funcString(_m, true);
                    _altS = __tmp__0;
                    _mS = __tmp__1;
                };
            };
            return _check._sprintf(("(wrong type for %s)\n\t\thave %s\n\t\twant %s" : GoString), Go.toInterface(_mname), Go.toInterface(_altS), Go.toInterface(_mS));
        };
        if (_isInterfacePtr(v)) {
            return (("(" : GoString) + _check._interfacePtrError(v)) + (")" : GoString);
        };
        if (_isInterfacePtr(t)) {
            return (("(" : GoString) + _check._interfacePtrError(t)) + (")" : GoString);
        };
        var __tmp__ = _lookupFieldOrMethod(v, true, _m._object._pkg, _m._object._name, false), _obj:stdgo.go.types.Types.Object = __tmp__._0, __0:Slice<GoInt> = __tmp__._1, __1:Bool = __tmp__._2;
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_obj) : Ref<Var>)) : Ref<Var>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Var>), ok : false };
            }, _fld = __tmp__.value, __2 = __tmp__.ok;
            if (_fld != null && ((_fld : Dynamic).__nil__ == null || !(_fld : Dynamic).__nil__)) {
                return _check._sprintf(("(%s.%s is a field, not a method)" : GoString), Go.toInterface(v), Go.toInterface(_fld.name()));
            };
        };
        return _check._sprintf(("(missing %s)" : GoString), Go.toInterface(_mname));
    }
    /**
        // missingMethod is like MissingMethod but accepts a *Checker as receiver.
        // The receiver may be nil if missingMethod is invoked through an exported
        // API call (such as MissingMethod), i.e., when all methods have been type-
        // checked.
        //
        // If a method is missing on T but is found on *T, or if a method is found
        // on T when looked up with case-folding, this alternative method is returned
        // as the second result.
    **/
    @:keep
    static public function _missingMethod( _check:Ref<Checker>, v:Type, t:Ref<Interface>, _static:Bool):{ var _0 : Ref<Func>; var _1 : Ref<Func>; } {
        var _method:Ref<Func> = (null : Ref<stdgo.go.types.Types.Func>), _alt:Ref<Func> = (null : Ref<stdgo.go.types.Types.Func>);
        if (t.numMethods() == ((0 : GoInt))) {
            return { _0 : _method, _1 : _alt };
        };
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_under(v)) : Ref<Interface>)) : Ref<Interface>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Interface>), ok : false };
            }, _u = __tmp__.value, __0 = __tmp__.ok;
            if (_u != null && ((_u : Dynamic).__nil__ == null || !(_u : Dynamic).__nil__)) {
                var _tset = _u._typeSet();
                for (__1 => _m in t._typeSet()._methods) {
                    var __tmp__ = _tset.lookupMethod(_m._object._pkg, _m._object._name, false), __2:GoInt = __tmp__._0, _f:Ref<stdgo.go.types.Types.Func> = __tmp__._1;
                    if (_f == null || (_f : Dynamic).__nil__) {
                        if (!_static) {
                            continue;
                        };
                        return { _0 : _m, _1 : null };
                    };
                    if (!identical(_f._object._typ, _m._object._typ)) {
                        return { _0 : _m, _1 : _f };
                    };
                };
                return { _0 : _method, _1 : _alt };
            };
        };
        for (__3 => _m in t._typeSet()._methods) {
            var __tmp__ = _lookupFieldOrMethod(v, false, _m._object._pkg, _m._object._name, false), _obj:stdgo.go.types.Types.Object = __tmp__._0, __4:Slice<GoInt> = __tmp__._1, __5:Bool = __tmp__._2;
            var _found:Bool = _obj != null;
            if (!_found) {
                {
                    var __tmp__ = _lookupFieldOrMethod(Go.asInterface(newPointer(v)), false, _m._object._pkg, _m._object._name, false);
                    _obj = __tmp__._0;
                };
                if (_obj == null) {
                    {
                        var __tmp__ = _lookupFieldOrMethod(v, false, _m._object._pkg, _m._object._name, true);
                        _obj = __tmp__._0;
                    };
                };
            };
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_obj) : Ref<Func>)) : Ref<Func>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Func>), ok : false };
            }, _f = __tmp__.value, __6 = __tmp__.ok;
            if (_f == null || (_f : Dynamic).__nil__) {
                return { _0 : _m, _1 : null };
            };
            if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
                _check._objDecl(Go.asInterface(_f), null);
            };
            if (!_found || !identical(_f._object._typ, _m._object._typ)) {
                return { _0 : _m, _1 : _f };
            };
        };
        return { _0 : _method, _1 : _alt };
    }
    /**
        // blockBranches processes a block's statement list and returns the set of outgoing forward jumps.
        // all is the scope of all declared labels, parent the set of labels declared in the immediately
        // enclosing block, and lstmt is the labeled statement this block is associated with (or nil).
    **/
    @:keep
    static public function _blockBranches( _check:Ref<Checker>, _all:Ref<Scope>, _parent:Ref<T_block>, _lstmt:Ref<stdgo.go.ast.Ast.LabeledStmt>, _list:Slice<stdgo.go.ast.Ast.Stmt>):Slice<Ref<stdgo.go.ast.Ast.BranchStmt>> {
        var _b = (Go.setRef(({ _parent : _parent, _lstmt : _lstmt } : T_block)) : Ref<stdgo.go.types.Types.T_block>);
        var __0:stdgo.go.token.Token.Pos = ((0 : GoInt) : stdgo.go.token.Token.Pos), __1:Slice<Ref<stdgo.go.ast.Ast.BranchStmt>> = (null : Slice<Ref<stdgo.go.ast.Ast.BranchStmt>>), __2:Slice<Ref<stdgo.go.ast.Ast.BranchStmt>> = (null : Slice<Ref<stdgo.go.ast.Ast.BranchStmt>>), _badJumps:Slice<Ref<stdgo.go.ast.Ast.BranchStmt>> = __2, _fwdJumps:Slice<Ref<stdgo.go.ast.Ast.BranchStmt>> = __1, _varDeclPos:stdgo.go.token.Token.Pos = __0;
        var _recordVarDecl:stdgo.go.token.Token.Pos -> Void = function(_pos:stdgo.go.token.Token.Pos):Void {
            _varDeclPos = _pos;
            _badJumps = ((_badJumps.__slice__(0, (0 : GoInt)) : Slice<Ref<stdgo.go.ast.Ast.BranchStmt>>).__append__(..._fwdJumps.__toArray__()));
        };
        var _jumpsOverVarDecl = function(_jmp:Ref<stdgo.go.ast.Ast.BranchStmt>):Bool {
            if (_varDeclPos.isValid()) {
                for (__0 => _bad in _badJumps) {
                    if (_jmp == (_bad)) {
                        return true;
                    };
                };
            };
            return false;
        };
        var _blockBranches = function(_lstmt:Ref<stdgo.go.ast.Ast.LabeledStmt>, _list:Slice<stdgo.go.ast.Ast.Stmt>):Void {
            _fwdJumps = (_fwdJumps.__append__(..._check._blockBranches(_all, _b, _lstmt, _list).__toArray__()));
        };
        var _stmtBranches:stdgo.go.ast.Ast.Stmt -> Void = null;
        _stmtBranches = function(_s:stdgo.go.ast.Ast.Stmt):Void {
            {
                final __type__ = _s;
                if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.DeclStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.DeclStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.DeclStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.DeclStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.DeclStmt>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_s.decl) : Ref<stdgo.go.ast.Ast.GenDecl>)) : Ref<stdgo.go.ast.Ast.GenDecl>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.ast.Ast.GenDecl>), ok : false };
                        }, _d = __tmp__.value, __0 = __tmp__.ok;
                        if (((_d != null) && ((_d : Dynamic).__nil__ == null || !(_d : Dynamic).__nil__)) && (_d.tok == (85 : stdgo.go.token.Token.Token))) {
                            _recordVarDecl(_d.pos());
                        };
                    };
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.LabeledStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.LabeledStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.LabeledStmt>) : __type__.__underlying__().value;
                    {
                        var _name:GoString = _s.label.name;
                        if (_name != (("_" : GoString))) {
                            var _lbl = newLabel(_s.label.pos(), _check._pkg, _name);
                            {
                                var _alt:stdgo.go.types.Types.Object = _all.insert(Go.asInterface(_lbl));
                                if (_alt != null) {
                                    _check._softErrorf(Go.asInterface(_lbl), (120 : stdgo.internal.types.errors.Errors.Code), ("label %s already declared" : GoString), Go.toInterface(_name));
                                    _check._reportAltDecl(_alt);
                                } else {
                                    _b._insert(_s);
                                    _check._recordDef(_s.label, Go.asInterface(_lbl));
                                };
                            };
                            var _i:GoInt = (0 : GoInt);
                            for (__9 => _jmp in _fwdJumps) {
                                if (_jmp.label.name == (_name)) {
                                    _lbl._used = true;
                                    _check._recordUse(_jmp.label, Go.asInterface(_lbl));
                                    if (_jumpsOverVarDecl(_jmp)) {
                                        _check._softErrorf(Go.asInterface(_jmp.label), (123 : stdgo.internal.types.errors.Errors.Code), ("goto %s jumps over variable declaration at line %d" : GoString), Go.toInterface(_name), Go.toInterface(_check._fset.position(_varDeclPos).line));
                                    };
                                } else {
                                    _fwdJumps[(_i : GoInt)] = _jmp;
                                    _i++;
                                };
                            };
                            _fwdJumps = (_fwdJumps.__slice__(0, _i) : Slice<Ref<stdgo.go.ast.Ast.BranchStmt>>);
                            _lstmt = _s;
                        };
                    };
                    _stmtBranches(_s.stmt);
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BranchStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.BranchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BranchStmt>) : __type__.__underlying__().value;
                    if (_s.label == null || (_s.label : Dynamic).__nil__) {
                        return;
                    };
                    var _name:GoString = _s.label.name;
                    {
                        final __value__ = _s.tok;
                        if (__value__ == ((61 : stdgo.go.token.Token.Token))) {
                            var _valid:Bool = false;
                            {
                                var _t = _b._enclosingTarget(_name);
                                if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                                    {
                                        final __type__ = _t.stmt;
                                        if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SwitchStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ForStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.RangeStmt>))) {
                                            _valid = true;
                                        };
                                    };
                                };
                            };
                            if (!_valid) {
                                _check._errorf(Go.asInterface(_s.label), (121 : stdgo.internal.types.errors.Errors.Code), ("invalid break label %s" : GoString), Go.toInterface(_name));
                                return;
                            };
                        } else if (__value__ == ((65 : stdgo.go.token.Token.Token))) {
                            var _valid:Bool = false;
                            {
                                var _t = _b._enclosingTarget(_name);
                                if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                                    {
                                        final __type__ = _t.stmt;
                                        if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ForStmt>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.RangeStmt>))) {
                                            _valid = true;
                                        };
                                    };
                                };
                            };
                            if (!_valid) {
                                _check._errorf(Go.asInterface(_s.label), (121 : stdgo.internal.types.errors.Errors.Code), ("invalid continue label %s" : GoString), Go.toInterface(_name));
                                return;
                            };
                        } else if (__value__ == ((73 : stdgo.go.token.Token.Token))) {
                            if (_b._gotoTarget(_name) == null || (_b._gotoTarget(_name) : Dynamic).__nil__) {
                                _fwdJumps = (_fwdJumps.__append__(_s));
                                return;
                            };
                        } else {
                            _check._errorf(Go.asInterface(_s), (-1 : stdgo.internal.types.errors.Errors.Code), ("branch statement: %s %s" : GoString), Go.toInterface(Go.asInterface(_s.tok)), Go.toInterface(_name));
                            return;
                        };
                    };
                    var _obj:stdgo.go.types.Types.Object = _all.lookup(_name);
                    (Go.typeAssert((Go.toInterface(_obj) : Ref<Label>)) : Ref<Label>)._used = true;
                    _check._recordUse(_s.label, _obj);
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.AssignStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.AssignStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.AssignStmt>) : __type__.__underlying__().value;
                    if (_s.tok == ((47 : stdgo.go.token.Token.Token))) {
                        _recordVarDecl(_s.pos());
                    };
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BlockStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.BlockStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BlockStmt>) : __type__.__underlying__().value;
                    _blockBranches(_lstmt, _s.list);
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IfStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.IfStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.IfStmt>) : __type__.__underlying__().value;
                    _stmtBranches(Go.asInterface(_s.body));
                    if (_s.else_ != null) {
                        _stmtBranches(_s.else_);
                    };
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CaseClause>))) {
                    var _s:Ref<stdgo.go.ast.Ast.CaseClause> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CaseClause>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.CaseClause>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CaseClause>) : __type__.__underlying__().value;
                    _blockBranches(null, _s.body);
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SwitchStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.SwitchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SwitchStmt>) : __type__.__underlying__().value;
                    _stmtBranches(Go.asInterface(_s.body));
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.TypeSwitchStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeSwitchStmt>) : __type__.__underlying__().value;
                    _stmtBranches(Go.asInterface(_s.body));
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CommClause>))) {
                    var _s:Ref<stdgo.go.ast.Ast.CommClause> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CommClause>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.CommClause>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CommClause>) : __type__.__underlying__().value;
                    _blockBranches(null, _s.body);
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.SelectStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectStmt>) : __type__.__underlying__().value;
                    _stmtBranches(Go.asInterface(_s.body));
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ForStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.ForStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ForStmt>) : __type__.__underlying__().value;
                    _stmtBranches(Go.asInterface(_s.body));
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.RangeStmt>))) {
                    var _s:Ref<stdgo.go.ast.Ast.RangeStmt> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.RangeStmt>) : __type__.__underlying__().value;
                    _stmtBranches(Go.asInterface(_s.body));
                };
            };
        };
        for (__0 => _s in _list) {
            _stmtBranches(_s);
        };
        return _fwdJumps;
    }
    /**
        // labels checks correct label use in body.
    **/
    @:keep
    static public function _labels( _check:Ref<Checker>, _body:Ref<stdgo.go.ast.Ast.BlockStmt>):Void {
        var _all = newScope(null, _body.pos(), _body.end(), ("label" : GoString));
        var _fwdJumps = _check._blockBranches(_all, null, null, _body.list);
        for (__0 => _jmp in _fwdJumps) {
            var _msg:GoString = ("" : GoString);
            var _code:Code = ((0 : GoInt) : stdgo.internal.types.errors.Errors.Code);
            var _name:GoString = _jmp.label.name;
            {
                var _alt:stdgo.go.types.Types.Object = _all.lookup(_name);
                if (_alt != null) {
                    _msg = ("goto %s jumps into block" : GoString);
                    (Go.typeAssert((Go.toInterface(_alt) : Ref<Label>)) : Ref<Label>)._used = true;
                    _code = (124 : stdgo.internal.types.errors.Errors.Code);
                } else {
                    _msg = ("label %s not declared" : GoString);
                    _code = (119 : stdgo.internal.types.errors.Errors.Code);
                };
            };
            _check._errorf(Go.asInterface(_jmp.label), _code, _msg, Go.toInterface(_name));
        };
        for (_name => _obj in _all._elems) {
            _obj = _resolve(_name, _obj);
            {
                var _lbl = (Go.typeAssert((Go.toInterface(_obj) : Ref<Label>)) : Ref<Label>);
                if (!_lbl._used) {
                    _check._softErrorf(Go.asInterface(_lbl), (122 : stdgo.internal.types.errors.Errors.Code), ("label %s declared and not used" : GoString), Go.toInterface(_lbl._object._name));
                };
            };
        };
    }
    @:keep
    static public function _interfaceType( _check:Ref<Checker>, _ityp:Ref<Interface>, _iface:Ref<stdgo.go.ast.Ast.InterfaceType>, _def:Ref<Named>):Void {
        var _addEmbedded:(stdgo.go.token.Token.Pos, stdgo.go.types.Types.Type) -> Void = function(_pos:stdgo.go.token.Token.Pos, _typ:Type):Void {
            _ityp._embeddeds = (_ityp._embeddeds.__append__(_typ));
            if (_ityp._embedPos == null || (_ityp._embedPos : Dynamic).__nil__) {
                _ityp._embedPos = (Go.setRef((null : Slice<stdgo.go.token.Token.Pos>)) : Ref<Slice<stdgo.go.token.Token.Pos>>);
            };
            _ityp._embedPos.__setData__(((_ityp._embedPos : Slice<stdgo.go.token.Token.Pos>).__append__(_pos)));
        };
        for (__0 => _f in _iface.methods.list) {
            if ((_f.names.length) == ((0 : GoInt))) {
                _addEmbedded(_f.type.pos(), _parseUnion(_check, _f.type));
                continue;
            };
            var _name = _f.names[(0 : GoInt)];
            if (_name.name == (("_" : GoString))) {
                _check._error(Go.asInterface(_name), (27 : stdgo.internal.types.errors.Errors.Code), ("methods must have a unique non-blank name" : GoString));
                continue;
            };
            var _typ:stdgo.go.types.Types.Type = _check._typ(_f.type);
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_typ) : Ref<Signature>)) : Ref<Signature>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Signature>), ok : false };
            }, _sig = __tmp__.value, __1 = __tmp__.ok;
            if (_sig == null || (_sig : Dynamic).__nil__) {
                if (Go.toInterface(_typ) != (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                    _check._errorf(_f.type, (-1 : stdgo.internal.types.errors.Errors.Code), ("%s is not a method signature" : GoString), Go.toInterface(_typ));
                };
                continue;
            };
            if (_sig._tparams != null && ((_sig._tparams : Dynamic).__nil__ == null || !(_sig._tparams : Dynamic).__nil__)) {
                var _at:T_positioner = _f.type;
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_f.type) : Ref<stdgo.go.ast.Ast.FuncType>)) : Ref<stdgo.go.ast.Ast.FuncType>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.ast.Ast.FuncType>), ok : false };
                    }, _ftyp = __tmp__.value, __2 = __tmp__.ok;
                    if (((_ftyp != null) && ((_ftyp : Dynamic).__nil__ == null || !(_ftyp : Dynamic).__nil__)) && ((_ftyp.typeParams != null) && ((_ftyp.typeParams : Dynamic).__nil__ == null || !(_ftyp.typeParams : Dynamic).__nil__))) {
                        _at = Go.asInterface(_ftyp.typeParams);
                    };
                };
                _check._error(_at, (143 : stdgo.internal.types.errors.Errors.Code), ("methods cannot have type parameters" : GoString));
            };
            var _recvTyp:Type = Go.asInterface(_ityp);
            if (_def != null && ((_def : Dynamic).__nil__ == null || !(_def : Dynamic).__nil__)) {
                _recvTyp = Go.asInterface(_def);
            };
            _sig._recv = newVar(_name.pos(), _check._pkg, Go.str(), _recvTyp);
            var _m = newFunc(_name.pos(), _check._pkg, _name.name, _sig);
            _check._recordDef(_name, Go.asInterface(_m));
            _ityp._methods = (_ityp._methods.__append__(_m));
        };
        _ityp._complete = true;
        if ((_ityp._methods.length == (0 : GoInt)) && (_ityp._embeddeds.length == (0 : GoInt))) {
            _ityp._tset = (Go.setRef(_topTypeSet) : Ref<stdgo.go.types.Types.T__TypeSet>);
            return;
        };
        _sortMethods(_ityp._methods);
        _check._later(function():Void {
            _computeInterfaceTypeSet(_check, _iface.pos(), _ityp);
        })._describef(Go.asInterface(_iface), ("compute type set for %s" : GoString), Go.toInterface(Go.asInterface(_ityp)));
    }
    /**
        // check may be nil
    **/
    @:keep
    static public function _newInterface( _check:Ref<Checker>):Ref<Interface> {
        var _typ = (Go.setRef(({ _check : _check } : Interface)) : Ref<stdgo.go.types.Types.Interface>);
        if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
            _check._needsCleanup(Go.asInterface(_typ));
        };
        return _typ;
    }
    /**
        // implements checks if V implements T. The receiver may be nil if implements
        // is called through an exported API call such as AssignableTo. If constraint
        // is set, T is a type constraint.
        //
        // If the provided cause is non-nil, it may be set to an error string
        // explaining why V does not implement (or satisfy, for constraints) T.
    **/
    @:keep
    static public function _implements( _check:Ref<Checker>, v:Type, t:Type, _constraint:Bool, _cause:Pointer<GoString>):Bool {
        var vu:stdgo.go.types.Types.Type = _under(v);
        var tu:stdgo.go.types.Types.Type = _under(t);
        if ((Go.toInterface(vu) == Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]))) || (Go.toInterface(tu) == Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
            return true;
        };
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(vu) : Ref<Pointer_>)) : Ref<Pointer_>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Pointer_>), ok : false };
            }, _p = __tmp__.value, __0 = __tmp__.ok;
            if (((_p != null) && ((_p : Dynamic).__nil__ == null || !(_p : Dynamic).__nil__)) && (Go.toInterface(_under(_p._base)) == Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                return true;
            };
        };
        var _verb:GoString = ("implement" : GoString);
        if (_constraint) {
            _verb = ("satisfy" : GoString);
        };
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(tu) : Ref<Interface>)) : Ref<Interface>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.Interface>), ok : false };
        }, ti = __tmp__.value, __1 = __tmp__.ok;
        if (ti == null || (ti : Dynamic).__nil__) {
            if (_cause != null) {
                var _detail:GoString = ("" : GoString);
                if (_isInterfacePtr(tu)) {
                    _detail = _check._sprintf(("type %s is pointer to interface, not interface" : GoString), Go.toInterface(t));
                } else {
                    _detail = _check._sprintf(("%s is not an interface" : GoString), Go.toInterface(t));
                };
                _cause.value = _check._sprintf(("%s does not %s %s (%s)" : GoString), Go.toInterface(v), Go.toInterface(_verb), Go.toInterface(t), Go.toInterface(_detail));
            };
            return false;
        };
        if (ti.empty()) {
            return true;
        };
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(vu) : Ref<Interface>)) : Ref<Interface>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.Interface>), ok : false };
        }, vi = __tmp__.value, __2 = __tmp__.ok;
        if (((vi != null) && ((vi : Dynamic).__nil__ == null || !(vi : Dynamic).__nil__)) && vi._typeSet().isEmpty()) {
            return true;
        };
        if (ti._typeSet().isEmpty()) {
            if (_cause != null) {
                _cause.value = _check._sprintf(("cannot %s %s (empty type set)" : GoString), Go.toInterface(_verb), Go.toInterface(t));
            };
            return false;
        };
        {
            var __tmp__ = _check._missingMethod(v, ti, true), _m:Ref<stdgo.go.types.Types.Func> = __tmp__._0, _wrong:Ref<stdgo.go.types.Types.Func> = __tmp__._1;
            if (_m != null && ((_m : Dynamic).__nil__ == null || !(_m : Dynamic).__nil__)) {
                if (_cause != null) {
                    _cause.value = _check._sprintf(("%s does not %s %s %s" : GoString), Go.toInterface(v), Go.toInterface(_verb), Go.toInterface(t), Go.toInterface(_check._missingMethodCause(v, t, _m, _wrong)));
                };
                return false;
            };
        };
        var _checkComparability:() -> Bool = function():Bool {
            if (!ti.isComparable()) {
                return true;
            };
            if (_comparable(v, false, (null : GoMap<stdgo.go.types.Types.Type, Bool>), null)) {
                return true;
            };
            if (((_check != null) && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) && _check._conf._oldComparableSemantics) {
                if (_cause != null) {
                    _cause.value = _check._sprintf(("%s does not %s comparable" : GoString), Go.toInterface(v), Go.toInterface(_verb));
                };
                return false;
            };
            if (_constraint && _comparable(v, true, (null : GoMap<stdgo.go.types.Types.Type, Bool>), null)) {
                if (((_check == null) || (_check : Dynamic).__nil__) || _check._allowVersion(_check._pkg, (1 : GoInt), (20 : GoInt))) {
                    return true;
                };
                if (_cause != null) {
                    _cause.value = _check._sprintf(("%s to %s comparable requires go1.20 or later" : GoString), Go.toInterface(v), Go.toInterface(_verb));
                };
                return false;
            };
            if (_cause != null) {
                _cause.value = _check._sprintf(("%s does not %s comparable" : GoString), Go.toInterface(v), Go.toInterface(_verb));
            };
            return false;
        };
        if (!ti._typeSet()._hasTerms()) {
            return _checkComparability();
        };
        if (vi != null && ((vi : Dynamic).__nil__ == null || !(vi : Dynamic).__nil__)) {
            if (!vi._typeSet()._subsetOf(ti._typeSet())) {
                if (_cause != null) {
                    _cause.value = _check._sprintf(("%s does not %s %s" : GoString), Go.toInterface(v), Go.toInterface(_verb), Go.toInterface(t));
                };
                return false;
            };
            return _checkComparability();
        };
        var _alt:Type = (null : stdgo.go.types.Types.Type);
        if (ti._typeSet()._is(function(_t:Ref<T_term>):Bool {
            if (!_t._includes(v)) {
                if (((_alt == null) && !_t._tilde) && identical(_t._typ, _under(_t._typ))) {
                    var _tt:stdgo.go.types.Types.T_term = (_t : stdgo.go.types.Types.T_term)?.__copy__();
                    _tt._tilde = true;
                    if (_tt._includes(v)) {
                        _alt = _t._typ;
                    };
                };
                return true;
            };
            return false;
        })) {
            if (_cause != null) {
                var _detail:GoString = ("" : GoString);
                if (_alt != null) {
                    _detail = _check._sprintf(("possibly missing ~ for %s in %s" : GoString), Go.toInterface(_alt), Go.toInterface(t));
                } else if (_mentions(Go.asInterface(ti), v)) {
                    _detail = _check._sprintf(("%s mentions %s, but %s is not in the type set of %s" : GoString), Go.toInterface(t), Go.toInterface(v), Go.toInterface(v), Go.toInterface(t));
                } else {
                    _detail = _check._sprintf(("%s missing in %s" : GoString), Go.toInterface(v), Go.toInterface(Go.asInterface(ti._typeSet()._terms)));
                };
                _cause.value = _check._sprintf(("%s does not %s %s (%s)" : GoString), Go.toInterface(v), Go.toInterface(_verb), Go.toInterface(t), Go.toInterface(_detail));
            };
            return false;
        };
        return _checkComparability();
    }
    @:keep
    static public function _verify( _check:Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _tparams:Slice<Ref<TypeParam>>, _targs:Slice<Type>, _ctxt:Ref<Context>):{ var _0 : GoInt; var _1 : Error; } {
        var _smap:stdgo.go.types.Types.T_substMap = _makeSubstMap(_tparams, _targs);
        for (_i => _tpar in _tparams) {
            _tpar._iface();
            var _bound:stdgo.go.types.Types.Type = _check._subst(_pos, _tpar._bound, _smap, null, _ctxt);
            var _cause:GoString = ("" : GoString);
            if (!_check._implements(_targs[(_i : GoInt)], _bound, true, Go.pointer(_cause))) {
                return { _0 : _i, _1 : stdgo.errors.Errors.new_(_cause) };
            };
        };
        return { _0 : (-1 : GoInt), _1 : (null : Error) };
    }
    /**
        // validateTArgLen verifies that the length of targs and tparams matches,
        // reporting an error if not. If validation fails and check is nil,
        // validateTArgLen panics.
    **/
    @:keep
    static public function _validateTArgLen( _check:Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _ntparams:GoInt, _ntargs:GoInt):Bool {
        if (_ntargs != (_ntparams)) {
            if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
                _check._errorf(Go.asInterface((_pos : T_atPos)), (137 : stdgo.internal.types.errors.Errors.Code), ("got %d arguments but %d type parameters" : GoString), Go.toInterface(_ntargs), Go.toInterface(_ntparams));
                return false;
            };
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("%v: got %d arguments but %d type parameters" : GoString), Go.toInterface(Go.asInterface(_pos)), Go.toInterface(_ntargs), Go.toInterface(_ntparams)));
        };
        return true;
    }
    /**
        // instance instantiates the given original (generic) function or type with the
        // provided type arguments and returns the resulting instance. If an identical
        // instance exists already in the given contexts, it returns that instance,
        // otherwise it creates a new one.
        //
        // If expanding is non-nil, it is the Named instance type currently being
        // expanded. If ctxt is non-nil, it is the context associated with the current
        // type-checking pass or call to Instantiate. At least one of expanding or ctxt
        // must be non-nil.
        //
        // For Named types the resulting instance may be unexpanded.
    **/
    @:keep
    static public function _instance( _check:Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _orig:Type, _targs:Slice<Type>, _expanding:Ref<Named>, _ctxt:Ref<Context>):Type {
        var _res:Type = (null : stdgo.go.types.Types.Type);
        var _ctxts:Slice<Ref<Context>> = (null : Slice<Ref<stdgo.go.types.Types.Context>>);
        if (_expanding != null && ((_expanding : Dynamic).__nil__ == null || !(_expanding : Dynamic).__nil__)) {
            _ctxts = (_ctxts.__append__(_expanding._inst._ctxt));
        };
        if (_ctxt != null && ((_ctxt : Dynamic).__nil__ == null || !(_ctxt : Dynamic).__nil__)) {
            _ctxts = (_ctxts.__append__(_ctxt));
        };
        _assert((_ctxts.length) > (0 : GoInt));
        var _hashes = new Slice<GoString>((_ctxts.length : GoInt).toBasic(), 0).__setString__();
        for (_i => _ctxt in _ctxts) {
            _hashes[(_i : GoInt)] = _ctxt._instanceHash(_orig, _targs);
        };
        var _updateContexts:stdgo.go.types.Types.Type -> stdgo.go.types.Types.Type = function(_res:Type):Type {
            {
                var _i:GoInt = (_ctxts.length) - (1 : GoInt);
                Go.cfor(_i >= (0 : GoInt), _i--, {
                    _res = _ctxts[(_i : GoInt)]._update(_hashes[(_i : GoInt)], _orig, _targs, _res);
                });
            };
            return _res;
        };
        for (_i => _ctxt in _ctxts) {
            {
                var _inst:stdgo.go.types.Types.Type = _ctxt._lookup(_hashes[(_i : GoInt)], _orig, _targs);
                if (_inst != null) {
                    return _updateContexts(_inst);
                };
            };
        };
        {
            final __type__ = _orig;
            if (Go.typeEquals((__type__ : Ref<Named>))) {
                var _orig:Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                _res = Go.asInterface(_check._newNamedInstance(_pos, _orig, _targs, _expanding));
            } else if (Go.typeEquals((__type__ : Ref<Signature>))) {
                var _orig:Ref<stdgo.go.types.Types.Signature> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__().value;
                _assert(_expanding == null || (_expanding : Dynamic).__nil__);
                var _tparams = _orig.typeParams();
                if (!_check._validateTArgLen(_pos, _tparams.len(), (_targs.length))) {
                    return Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                };
                if (_tparams.len() == ((0 : GoInt))) {
                    return Go.asInterface(_orig);
                };
                var _sig = (Go.typeAssert((Go.toInterface(_check._subst(_pos, Go.asInterface(_orig), _makeSubstMap(_tparams._list(), _targs), null, _ctxt)) : Ref<Signature>)) : Ref<Signature>);
                if (_sig == (_orig)) {
                    var _copy:stdgo.go.types.Types.Signature = (_sig : stdgo.go.types.Types.Signature)?.__copy__();
                    _sig = (Go.setRef(_copy) : Ref<stdgo.go.types.Types.Signature>);
                };
                _sig._tparams = null;
                _res = Go.asInterface(_sig);
            } else {
                var _orig:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("%v: cannot instantiate %v" : GoString), Go.toInterface(Go.asInterface(_pos)), Go.toInterface(_orig)));
            };
        };
        return _updateContexts(_res);
    }
    /**
        // reportCycle reports an error for the given cycle.
    **/
    @:keep
    static public function _reportCycle( _check:Ref<Checker>, _cycle:Slice<Object>):Void {
        var _obj:stdgo.go.types.Types.Object = _cycle[(0 : GoInt)];
        if ((_cycle.length) == ((1 : GoInt))) {
            _check._errorf(_obj, (9 : stdgo.internal.types.errors.Errors.Code), ("initialization cycle: %s refers to itself" : GoString), Go.toInterface(_obj.name()));
            return;
        };
        _check._errorf(_obj, (9 : stdgo.internal.types.errors.Errors.Code), ("initialization cycle for %s" : GoString), Go.toInterface(_obj.name()));
        {
            var _i:GoInt = (_cycle.length) - (1 : GoInt);
            Go.cfor(_i >= (0 : GoInt), _i--, {
                _check._errorf(_obj, (9 : stdgo.internal.types.errors.Errors.Code), ("\t%s refers to" : GoString), Go.toInterface(_obj.name()));
                _obj = _cycle[(_i : GoInt)];
            });
        };
        _check._errorf(_obj, (9 : stdgo.internal.types.errors.Errors.Code), ("\t%s" : GoString), Go.toInterface(_obj.name()));
    }
    /**
        // initOrder computes the Info.InitOrder for package variables.
    **/
    @:keep
    static public function _initOrder( _check:Ref<Checker>):Void {
        _check.info.initOrder = (_check.info.initOrder.__slice__(0, (0 : GoInt)) : Slice<Ref<stdgo.go.types.Types.Initializer>>);
        var _pq:stdgo.go.types.Types.T_nodeQueue = (_dependencyGraph(_check._objMap) : T_nodeQueue);
        stdgo.container.heap.Heap.init(Go.asInterface((Go.setRef(_pq) : Ref<stdgo.go.types.Types.T_nodeQueue>)));
        {};
        if (false) {
            stdgo.fmt.Fmt.printf(("Computing initialization order for %s\n\n" : GoString), Go.toInterface(Go.asInterface(_check._pkg)));
            stdgo.fmt.Fmt.println(Go.toInterface(("Object dependency graph:" : GoString)));
            for (_obj => _d in _check._objMap) {
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_obj) : T_dependency)) : T_dependency), ok : true };
                    } catch(_) {
                        { value : (null : stdgo.go.types.Types.T_dependency), ok : false };
                    }, _obj = __tmp__.value, __40 = __tmp__.ok;
                    if (_obj != null) {
                        if ((_d._deps.length) > (0 : GoInt)) {
                            stdgo.fmt.Fmt.printf(("\t%s depends on\n" : GoString), Go.toInterface(_obj.name()));
                            for (_dep => _ in _d._deps) {
                                stdgo.fmt.Fmt.printf(("\t\t%s\n" : GoString), Go.toInterface(_dep.name()));
                            };
                        } else {
                            stdgo.fmt.Fmt.printf(("\t%s has no dependencies\n" : GoString), Go.toInterface(_obj.name()));
                        };
                    };
                };
            };
            stdgo.fmt.Fmt.println();
            stdgo.fmt.Fmt.println(Go.toInterface(("Transposed object dependency graph (functions eliminated):" : GoString)));
            for (__41 => _n in _pq) {
                stdgo.fmt.Fmt.printf(("\t%s depends on %d nodes\n" : GoString), Go.toInterface(_n._obj.name()), Go.toInterface(_n._ndeps));
                for (_p => _ in _n._pred) {
                    stdgo.fmt.Fmt.printf(("\t\t%s is dependent\n" : GoString), Go.toInterface(_p._obj.name()));
                };
            };
            stdgo.fmt.Fmt.println();
            stdgo.fmt.Fmt.println(Go.toInterface(("Processing nodes:" : GoString)));
        };
        var _emitted = ({
            final x = new GoRefMap<Ref<stdgo.go.types.Types.T_declInfo>, Bool>();
            @:mergeBlock {};
            cast x;
        } : GoMap<Ref<stdgo.go.types.Types.T_declInfo>, Bool>);
        while ((_pq.length) > (0 : GoInt)) {
            var _n = (Go.typeAssert((stdgo.container.heap.Heap.pop(Go.asInterface((Go.setRef(_pq) : Ref<stdgo.go.types.Types.T_nodeQueue>))) : Ref<T_graphNode>)) : Ref<T_graphNode>);
            if (false) {
                stdgo.fmt.Fmt.printf(("\t%s (src pos %d) depends on %d nodes now\n" : GoString), Go.toInterface(_n._obj.name()), Go.toInterface(_n._obj._order()), Go.toInterface(_n._ndeps));
            };
            if (_n._ndeps > (0 : GoInt)) {
                var _cycle = _findPath(_check._objMap, _n._obj, _n._obj, ({
                    final x = new GoObjectMap<stdgo.go.types.Types.Object, Bool>();
                    x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Object", [], stdgo.internal.reflect.Reflect.GoType.named("Object", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
                    x.__defaultValue__ = () -> false;
                    @:mergeBlock {};
                    cast x;
                } : GoMap<stdgo.go.types.Types.Object, Bool>));
                if (_cycle != null) {
                    _check._reportCycle(_cycle);
                };
            };
            for (_p => _ in _n._pred) {
                _p._ndeps--;
                stdgo.container.heap.Heap.fix(Go.asInterface((Go.setRef(_pq) : Ref<stdgo.go.types.Types.T_nodeQueue>)), _p._index);
            };
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_n._obj) : Ref<Var>)) : Ref<Var>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Var>), ok : false };
            }, _v = __tmp__.value, __50 = __tmp__.ok;
            var _info = _check._objMap[Go.asInterface(_v)];
            if (((_v == null) || (_v : Dynamic).__nil__) || !_info._hasInitializer()) {
                continue;
            };
            if (_emitted[_info]) {
                continue;
            };
            _emitted[_info] = true;
            var _infoLhs = _info._lhs;
            if (_infoLhs == null) {
                _infoLhs = (new Slice<Ref<stdgo.go.types.Types.Var>>(1, 1, _v) : Slice<Ref<stdgo.go.types.Types.Var>>);
            };
            var _init = (Go.setRef((new Initializer(_infoLhs, _info._init) : Initializer)) : Ref<stdgo.go.types.Types.Initializer>);
            _check.info.initOrder = (_check.info.initOrder.__append__(_init));
        };
        if (false) {
            stdgo.fmt.Fmt.println();
            stdgo.fmt.Fmt.println(Go.toInterface(("Initialization order:" : GoString)));
            for (__75 => _init in _check.info.initOrder) {
                stdgo.fmt.Fmt.printf(("\t%s\n" : GoString), Go.toInterface(Go.asInterface(_init)));
            };
            stdgo.fmt.Fmt.println();
        };
    }
    /**
        // inferB returns the list of actual type arguments inferred from the type parameters'
        // bounds and an initial set of type arguments. If type inference is impossible because
        // unification fails, an error is reported if report is set to true, the resulting types
        // list is nil, and index is 0.
        // Otherwise, types is the list of inferred type arguments, and index is the index of the
        // first type argument in that list that couldn't be inferred (and thus is nil). If all
        // type arguments were inferred successfully, index is < 0. The number of type arguments
        // provided may be less than the number of type parameters, but there must be at least one.
    **/
    @:keep
    static public function _inferB( _check:Ref<Checker>, _posn:T_positioner, _tparams:Slice<Ref<TypeParam>>, _targs:Slice<Type>):{ var _0 : Slice<Type>; var _1 : GoInt; } {
        var __deferstack__:Array<Void -> Void> = [];
        var _types:Slice<Type> = (null : Slice<stdgo.go.types.Types.Type>), _index:GoInt = (0 : GoInt);
        _assert((_tparams.length >= _targs.length) && (_targs.length > (0 : GoInt)));
        try {
            if (false) {
                _check._dump(("-- inferB %s ‚ûû %s" : GoString), Go.toInterface(_tparams), Go.toInterface(_targs));
                __deferstack__.unshift(() -> {
                    var a = function():Void {
                        _check._dump(("=> inferB %s ‚ûû %s" : GoString), Go.toInterface(_tparams), Go.toInterface(_types));
                    };
                    a();
                });
            };
            var _u = _newUnifier(false);
            _u._x._init(_tparams);
            _u._y = _u._x?.__copy__();
            for (_i => _targ in _targs) {
                if (_targ != null) {
                    _u._x._set(_i, _targ);
                };
            };
            {
                var _n:GoInt = _u._x._unknowns();
                while (_n > (0 : GoInt)) {
                    var _nn:GoInt = _n;
                    for (_i => _tpar in _tparams) {
                        {
                            var __tmp__ = _coreTerm(_tpar), _core:Ref<stdgo.go.types.Types.T_term> = __tmp__._0, _single:Bool = __tmp__._1;
                            if (_core != null && ((_core : Dynamic).__nil__ == null || !(_core : Dynamic).__nil__)) {
                                var _tx:stdgo.go.types.Types.Type = _u._x._at(_i);
                                if (_tx != null) {
                                    if (_core._tilde && !_isTypeParam(_tx)) {
                                        _tx = _under(_tx);
                                    };
                                    if (!_u._unify(_tx, _core._typ)) {
                                        var _tilde:GoString = Go.str();
                                        if (_core._tilde) {
                                            _tilde = ("~" : GoString);
                                        };
                                        _check._errorf(_posn, (139 : stdgo.internal.types.errors.Errors.Code), ("%s does not match %s%s" : GoString), Go.toInterface(_tx), Go.toInterface(_tilde), Go.toInterface(_core._typ));
                                        {
                                            for (defer in __deferstack__) {
                                                defer();
                                            };
                                            return { _0 : (null : Slice<stdgo.go.types.Types.Type>), _1 : (0 : GoInt) };
                                        };
                                    };
                                } else if (_single && !_core._tilde) {
                                    _u._x._set(_i, _core._typ);
                                } else {
                                    continue;
                                };
                                _nn = _u._x._unknowns();
                                if (_nn == ((0 : GoInt))) {
                                    break;
                                };
                            };
                        };
                    };
                    _assert(_nn <= _n);
                    if (_nn == (_n)) {
                        break;
                    };
                    _n = _nn;
                };
            };
            {
                var __tmp__ = _u._x._types();
                _types = __tmp__._0;
            };
            if (false) {
                for (_i => _targ in _targs) {
                    _assert((_targ == null) || (Go.toInterface(_types[(_i : GoInt)]) == Go.toInterface(_targ)));
                };
            };
            var _w:stdgo.go.types.Types.T_cycleFinder = (new T_cycleFinder(_tparams, _types, ({
                final x = new GoObjectMap<stdgo.go.types.Types.Type, Bool>();
                x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Type", [], stdgo.internal.reflect.Reflect.GoType.named("Type", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
                x.__defaultValue__ = () -> false;
                @:mergeBlock {};
                cast x;
            } : GoMap<stdgo.go.types.Types.Type, Bool>)) : T_cycleFinder);
            for (__0 => _t in _tparams) {
                _w._typ(Go.asInterface(_t));
            };
            var _dirty:Slice<GoInt> = (null : Slice<GoInt>);
            for (_i => _typ in _types) {
                if ((_typ != null) && ((_i >= _targs.length) || (_targs[(_i : GoInt)] == null))) {
                    _dirty = (_dirty.__append__(_i));
                };
            };
            while ((_dirty.length) > (0 : GoInt)) {
                var _smap:stdgo.go.types.Types.T_substMap = _makeSubstMap(_tparams, _types);
                var _n:GoInt = (0 : GoInt);
                for (__1 => _index in _dirty) {
                    var _t0:stdgo.go.types.Types.Type = _types[(_index : GoInt)];
                    {
                        var _t1:stdgo.go.types.Types.Type = _check._subst((0 : stdgo.go.token.Token.Pos), _t0, _smap, null, _check._context());
                        if (Go.toInterface(_t1) != (Go.toInterface(_t0))) {
                            _types[(_index : GoInt)] = _t1;
                            _dirty[(_n : GoInt)] = _index;
                            _n++;
                        };
                    };
                };
                _dirty = (_dirty.__slice__(0, _n) : Slice<GoInt>);
            };
            for (_i => _typ in _types) {
                if ((_typ != null) && _isParameterized(_tparams, _typ)) {
                    _types[(_i : GoInt)] = (null : stdgo.go.types.Types.Type);
                };
            };
            _index = (-1 : GoInt);
            for (_i => _typ in _types) {
                if (_typ == null) {
                    _index = _i;
                    break;
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return { _0 : _types, _1 : _index };
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return { _0 : _types, _1 : _index };
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return { _0 : _types, _1 : _index };
        };
    }
    /**
        // infer attempts to infer the complete set of type arguments for generic function instantiation/call
        // based on the given type parameters tparams, type arguments targs, function parameters params, and
        // function arguments args, if any. There must be at least one type parameter, no more type arguments
        // than type parameters, and params and args must match in number (incl. zero).
        // If successful, infer returns the complete list of type arguments, one for each type parameter.
        // Otherwise the result is nil and appropriate errors will be reported.
        //
        // Inference proceeds as follows:
        //
        //	Starting with given type arguments
        //	1) apply FTI (function type inference) with typed arguments,
        //	2) apply CTI (constraint type inference),
        //	3) apply FTI with untyped function arguments,
        //	4) apply CTI.
        //
        // The process stops as soon as all type arguments are known or an error occurs.
    **/
    @:keep
    static public function _infer( _check:Ref<Checker>, _posn:T_positioner, _tparams:Slice<Ref<TypeParam>>, _targs:Slice<Type>, _params:Ref<Tuple>, _args:Slice<Ref<T_operand>>):Slice<Type> {
        var __deferstack__:Array<Void -> Void> = [];
        var _result:Slice<Type> = (null : Slice<stdgo.go.types.Types.Type>);
        try {
            if (false) {
                __deferstack__.unshift(() -> {
                    var a = function():Void {
                        _assert((_result == null) || (_result.length == (_tparams.length)));
                        for (__0 => _targ in _result) {
                            _assert(_targ != null);
                        };
                    };
                    a();
                });
            };
            if (false) {
                _check._dump(("-- inferA %s%s ‚ûû %s" : GoString), Go.toInterface(_tparams), Go.toInterface(Go.asInterface(_params)), Go.toInterface(_targs));
                __deferstack__.unshift(() -> {
                    var a = function():Void {
                        _check._dump(("=> inferA %s ‚ûû %s" : GoString), Go.toInterface(_tparams), Go.toInterface(_result));
                    };
                    a();
                });
            };
            var _n:GoInt = (_tparams.length);
            _assert((_n > (0 : GoInt)) && (_targs.length <= _n));
            _assert(_params.len() == ((_args.length)));
            if ((_targs.length) == (_n)) {
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return _targs;
                };
            };
            {};
            if (true) {
                var _tparams2 = new Slice<Ref<stdgo.go.types.Types.TypeParam>>((_tparams.length : GoInt).toBasic(), 0);
                for (_i => _tparam in _tparams) {
                    var _tname = newTypeName(_tparam.obj().pos(), _tparam.obj().pkg(), _tparam.obj().name(), (null : stdgo.go.types.Types.Type));
                    _tparams2[(_i : GoInt)] = newTypeParam(_tname, (null : stdgo.go.types.Types.Type));
                    _tparams2[(_i : GoInt)]._index = _tparam._index;
                };
                var _renameMap:stdgo.go.types.Types.T_substMap = _makeRenameMap(_tparams, _tparams2);
                for (_i => _tparam in _tparams) {
                    _tparams2[(_i : GoInt)]._bound = _check._subst(_posn.pos(), _tparam._bound, _renameMap, null, _check._context());
                };
                _tparams = _tparams2;
                _params = (Go.typeAssert((Go.toInterface(_check._subst(_posn.pos(), Go.asInterface(_params), _renameMap, null, _check._context())) : Ref<Tuple>)) : Ref<Tuple>);
            };
            {};
            {
                var _m:GoInt = (_args.length);
                if ((_m >= (2 : GoInt)) && true) {
                    var __0:Slice<GoInt> = (null : Slice<GoInt>), __1:Slice<GoInt> = (null : Slice<GoInt>), _unnamed:Slice<GoInt> = __1, _named:Slice<GoInt> = __0;
                    for (_i => _arg in _args) {
                        if (_hasName(_arg._typ)) {
                            _named = (_named.__append__(_i));
                        } else {
                            _unnamed = (_unnamed.__append__(_i));
                        };
                    };
                    if ((_named.length != (0 : GoInt)) && (_unnamed.length != (0 : GoInt))) {
                        var _params2 = new Slice<Ref<stdgo.go.types.Types.Var>>((_m : GoInt).toBasic(), 0);
                        var _args2 = new Slice<Ref<stdgo.go.types.Types.T_operand>>((_m : GoInt).toBasic(), 0);
                        var _i:GoInt = (0 : GoInt);
                        for (__32 => _j in _named) {
                            _params2[(_i : GoInt)] = _params.at(_j);
                            _args2[(_i : GoInt)] = _args[(_j : GoInt)];
                            _i++;
                        };
                        for (__33 => _j in _unnamed) {
                            _params2[(_i : GoInt)] = _params.at(_j);
                            _args2[(_i : GoInt)] = _args[(_j : GoInt)];
                            _i++;
                        };
                        _params = newTuple(..._params2.__toArray__());
                        _args = _args2;
                    };
                };
            };
            if ((_targs.length) < _n) {
                var _targs2 = new Slice<stdgo.go.types.Types.Type>((_n : GoInt).toBasic(), 0);
                Go.copySlice(_targs2, _targs);
                _targs = _targs2;
            };
            if (_params.len() > (0 : GoInt)) {
                var _smap:stdgo.go.types.Types.T_substMap = _makeSubstMap(_tparams, _targs);
                _params = (Go.typeAssert((Go.toInterface(_check._subst((0 : stdgo.go.token.Token.Pos), Go.asInterface(_params), _smap, null, _check._context())) : Ref<Tuple>)) : Ref<Tuple>);
            };
            var _u = _newUnifier(false);
            _u._x._init(_tparams);
            for (_i => _targ in _targs) {
                if (_targ != null) {
                    _u._x._set(_i, _targ);
                };
            };
            var _errorf = function(_kind:GoString, _tpar:Type, _targ:Type, _arg:Ref<T_operand>):Void {
                var __tmp__ = _u._x._types(), _targs:Slice<stdgo.go.types.Types.Type> = __tmp__._0, _index:GoInt = __tmp__._1;
                if (_index == ((0 : GoInt))) {
                    var _allFailed:Bool = true;
                    for (__0 => _targ in _targs) {
                        if (_targ != null) {
                            _allFailed = false;
                            break;
                        };
                    };
                    if (_allFailed) {
                        _check._errorf(Go.asInterface(_arg), (138 : stdgo.internal.types.errors.Errors.Code), ("%s %s of %s does not match %s (cannot infer %s)" : GoString), Go.toInterface(_kind), Go.toInterface(_targ), Go.toInterface(_arg._expr), Go.toInterface(_tpar), Go.toInterface(_typeParamsString(_tparams)));
                        return;
                    };
                };
                var _smap:stdgo.go.types.Types.T_substMap = _makeSubstMap(_tparams, _targs);
                var _inferred:stdgo.go.types.Types.Type = _check._subst(_arg.pos(), _tpar, _smap, null, _check._context());
                if (Go.toInterface(_inferred) != (Go.toInterface(_tpar))) {
                    _check._errorf(Go.asInterface(_arg), (138 : stdgo.internal.types.errors.Errors.Code), ("%s %s of %s does not match inferred type %s for %s" : GoString), Go.toInterface(_kind), Go.toInterface(_targ), Go.toInterface(_arg._expr), Go.toInterface(_inferred), Go.toInterface(_tpar));
                } else {
                    _check._errorf(Go.asInterface(_arg), (138 : stdgo.internal.types.errors.Errors.Code), ("%s %s of %s does not match %s" : GoString), Go.toInterface(_kind), Go.toInterface(_targ), Go.toInterface(_arg._expr), Go.toInterface(_tpar));
                };
            };
            var _indices:Slice<GoInt> = (null : Slice<GoInt>);
            for (_i => _arg in _args) {
                var _par = _params.at(_i);
                if (_isParameterized(_tparams, _par._object._typ)) {
                    if (_arg._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                        continue;
                    };
                    {
                        var _targ:stdgo.go.types.Types.Type = _arg._typ;
                        if (_isTyped(_targ)) {
                            if (!_u._unify(_par._object._typ, _targ)) {
                                _errorf(("type" : GoString), _par._object._typ, _targ, _arg);
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return (null : Slice<stdgo.go.types.Types.Type>);
                                };
                            };
                        } else {
                            var __tmp__ = try {
                                { value : (Go.typeAssert((Go.toInterface(_par._object._typ) : Ref<TypeParam>)) : Ref<TypeParam>), ok : true };
                            } catch(_) {
                                { value : (null : Ref<stdgo.go.types.Types.TypeParam>), ok : false };
                            }, __34 = __tmp__.value, _ok = __tmp__.ok;
                            if (_ok) {
                                _indices = (_indices.__append__(_i));
                            };
                        };
                    };
                };
            };
            var _index:GoInt = (0 : GoInt);
            {
                var __tmp__ = _u._x._types();
                _targs = __tmp__._0;
                _index = __tmp__._1;
            };
            if (_index < (0 : GoInt)) {
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return _targs;
                };
            };
            {
                var __tmp__ = _check._inferB(_posn, _tparams, _targs);
                _targs = __tmp__._0;
                _index = __tmp__._1;
            };
            if ((_targs == null) || (_index < (0 : GoInt))) {
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return _targs;
                };
            };
            for (__35 => _i in _indices) {
                var _tpar = (Go.typeAssert((Go.toInterface(_params.at(_i)._object._typ) : Ref<TypeParam>)) : Ref<TypeParam>);
                if (_targs[(_tpar._index : GoInt)] == null) {
                    var _arg = _args[(_i : GoInt)];
                    var _targ:stdgo.go.types.Types.Type = default_(_arg._typ);
                    if (_isTyped(_targ) && !_u._unify(Go.asInterface(_tpar), _targ)) {
                        _errorf(("default type" : GoString), Go.asInterface(_tpar), _targ, _arg);
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return (null : Slice<stdgo.go.types.Types.Type>);
                        };
                    };
                };
            };
            {
                var __tmp__ = _u._x._types();
                _targs = __tmp__._0;
                _index = __tmp__._1;
            };
            if (_index < (0 : GoInt)) {
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return _targs;
                };
            };
            {
                var __tmp__ = _check._inferB(_posn, _tparams, _targs);
                _targs = __tmp__._0;
                _index = __tmp__._1;
            };
            if ((_targs == null) || (_index < (0 : GoInt))) {
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return _targs;
                };
            };
            _assert((_index >= (0 : GoInt)) && (_targs[(_index : GoInt)] == null));
            var _tpar = _tparams[(_index : GoInt)];
            _check._errorf(_posn, (138 : stdgo.internal.types.errors.Errors.Code), ("cannot infer %s (%v)" : GoString), Go.toInterface(_tpar._obj._object._name), Go.toInterface(Go.asInterface(_tpar._obj._object._pos)));
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return (null : Slice<stdgo.go.types.Types.Type>);
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return _result;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return _result;
        };
    }
    /**
        // indexElts checks the elements (elts) of an array or slice composite literal
        // against the literal's element type (typ), and the element indices against
        // the literal length if known (length >= 0). It returns the length of the
        // literal (maximum index value + 1).
    **/
    @:keep
    static public function _indexedElts( _check:Ref<Checker>, _elts:Slice<stdgo.go.ast.Ast.Expr>, _typ:Type, _length:GoInt64):GoInt64 {
        var _visited = ({
            final x = new stdgo.GoMap.GoInt64Map<Bool>();
            x.__defaultValue__ = () -> false;
            @:mergeBlock {};
            x;
        } : GoMap<GoInt64, Bool>);
        var __0:GoInt64 = (0 : GoInt64), __1:GoInt64 = (0 : GoInt64), _max:GoInt64 = __1, _index:GoInt64 = __0;
        for (__0 => _e in _elts) {
            var _validIndex:Bool = false;
            var _eval:stdgo.go.ast.Ast.Expr = _e;
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_e) : Ref<stdgo.go.ast.Ast.KeyValueExpr>)) : Ref<stdgo.go.ast.Ast.KeyValueExpr>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.ast.Ast.KeyValueExpr>), ok : false };
                }, _kv = __tmp__.value, __1 = __tmp__.ok;
                if (_kv != null && ((_kv : Dynamic).__nil__ == null || !(_kv : Dynamic).__nil__)) {
                    {
                        var __tmp__ = _check._index(_kv.key, _length), _typ:stdgo.go.types.Types.Type = __tmp__._0, _i:GoInt64 = __tmp__._1;
                        if (Go.toInterface(_typ) != (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                            if (_i >= (0i64 : GoInt64)) {
                                _index = _i;
                                _validIndex = true;
                            } else {
                                _check._errorf(_e, (62 : stdgo.internal.types.errors.Errors.Code), ("index %s must be integer constant" : GoString), Go.toInterface(_kv.key));
                            };
                        };
                    };
                    _eval = _kv.value;
                } else if ((_length >= (0i64 : GoInt64)) && (_index >= _length)) {
                    _check._errorf(_e, (63 : stdgo.internal.types.errors.Errors.Code), ("index %d is out of bounds (>= %d)" : GoString), Go.toInterface(_index), Go.toInterface(_length));
                } else {
                    _validIndex = true;
                };
            };
            if (_validIndex) {
                if (_visited[_index]) {
                    _check._errorf(_e, (60 : stdgo.internal.types.errors.Errors.Code), ("duplicate index %d in array or slice literal" : GoString), Go.toInterface(_index));
                };
                _visited[_index] = true;
            };
            _index++;
            if (_index > _max) {
                _max = _index;
            };
            var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
            _check._exprWithHint((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), _eval, _typ);
            _check._assignment((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), _typ, ("array or slice literal" : GoString));
        };
        return _max;
    }
    @:keep
    static public function _isValidIndex( _check:Ref<Checker>, _x:Ref<T_operand>, _code:Code, _what:GoString, _allowNegative:Bool):Bool {
        if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
            return false;
        };
        _check._convertUntyped(_x, Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : GoInt)]));
        if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
            return false;
        };
        if (!_allInteger(_x._typ)) {
            _check._errorf(Go.asInterface(_x), _code, ("invalid argument: %s %s must be integer" : GoString), Go.toInterface(_what), Go.toInterface(Go.asInterface(_x)));
            return false;
        };
        if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
            if (!_allowNegative && (stdgo.go.constant.Constant.sign(_x._val) < (0 : GoInt))) {
                _check._errorf(Go.asInterface(_x), _code, ("invalid argument: %s %s must not be negative" : GoString), Go.toInterface(_what), Go.toInterface(Go.asInterface(_x)));
                return false;
            };
            if (!_representableConst(_x._val, _check, typ[((2 : stdgo.go.types.Types.BasicKind) : GoInt)], (Go.setRef(_x._val) : Ref<stdgo.go.constant.Constant.Value>))) {
                _check._errorf(Go.asInterface(_x), _code, ("invalid argument: %s %s overflows int" : GoString), Go.toInterface(_what), Go.toInterface(Go.asInterface(_x)));
                return false;
            };
        };
        return true;
    }
    /**
        // index checks an index expression for validity.
        // If max >= 0, it is the upper bound for index.
        // If the result typ is != Typ[Invalid], index is valid and typ is its (possibly named) integer type.
        // If the result val >= 0, index is valid and val is its constant int value.
    **/
    @:keep
    static public function _index( _check:Ref<Checker>, _index:stdgo.go.ast.Ast.Expr, _max:GoInt64):{ var _0 : Type; var _1 : GoInt64; } {
        var _typ:Type = (null : stdgo.go.types.Types.Type), _val:GoInt64 = (0 : GoInt64);
        _typ = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
        _val = (-1i64 : GoInt64);
        var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
        _check._expr((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), _index);
        if (!_check._isValidIndex((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), (52 : stdgo.internal.types.errors.Errors.Code), ("index" : GoString), false)) {
            return { _0 : _typ, _1 : _val };
        };
        if (_x._mode != ((4 : stdgo.go.types.Types.T_operandMode))) {
            return { _0 : _x._typ, _1 : (-1i64 : GoInt64) };
        };
        if (_x._val.kind() == ((0 : stdgo.go.constant.Constant.Kind))) {
            return { _0 : _typ, _1 : _val };
        };
        var __tmp__ = stdgo.go.constant.Constant.int64Val(_x._val), _v:GoInt64 = __tmp__._0, _ok:Bool = __tmp__._1;
        _assert(_ok);
        if ((_max >= (0i64 : GoInt64)) && (_v >= _max)) {
            _check._errorf(Go.asInterface((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>)), (52 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: index %s out of bounds [0:%d]" : GoString), Go.toInterface((_x._val.string() : GoString)), Go.toInterface(_max));
            return { _0 : _typ, _1 : _val };
        };
        return { _0 : _x._typ, _1 : _v };
    }
    /**
        // singleIndex returns the (single) index from the index expression e.
        // If the index is missing, or if there are multiple indices, an error
        // is reported and the result is nil.
    **/
    @:keep
    static public function _singleIndex( _check:Ref<Checker>, _expr:Ref<stdgo.go.internal.typeparams.Typeparams.IndexExpr>):stdgo.go.ast.Ast.Expr {
        if ((_expr.indexListExpr.indices.length) == ((0 : GoInt))) {
            _check._errorf(_expr.orig, (-1 : stdgo.internal.types.errors.Errors.Code), ("index expression %v with 0 indices" : GoString), Go.toInterface(Go.asInterface(_expr)));
            return (null : stdgo.go.ast.Ast.Expr);
        };
        if ((_expr.indexListExpr.indices.length) > (1 : GoInt)) {
            _check._error(_expr.indexListExpr.indices[(1 : GoInt)], (52 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: more than one index" : GoString));
        };
        return _expr.indexListExpr.indices[(0 : GoInt)];
    }
    @:keep
    static public function _sliceExpr( _check:Ref<Checker>, _x:Ref<T_operand>, _e:Ref<stdgo.go.ast.Ast.SliceExpr>):Void {
        stdgo.internal.Macro.controlFlow({
            _check._expr(_x, _e.x);
            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                _check._use(_e.low, _e.high, _e.max);
                return;
            };
            var _valid:Bool = false;
            var _length:GoInt64 = (-1i64 : GoInt64);
            {
                final __type__ = _coreString(_x._typ);
                if (__type__ == null) {
                    var _u:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
                    _check._errorf(Go.asInterface(_x), (54 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot slice %s: %s has no core type" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(_x._typ));
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                    return;
                } else if (Go.typeEquals((__type__ : Ref<Basic>))) {
                    var _u:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                    if (_isString(Go.asInterface(_u))) {
                        if (_e.slice3) {
                            var _at:stdgo.go.ast.Ast.Expr = _e.max;
                            if (_at == null) {
                                _at = Go.asInterface(_e);
                            };
                            _check._error(_at, (55 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: 3-index slice of string" : GoString));
                            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                            return;
                        };
                        _valid = true;
                        if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
                            _length = (stdgo.go.constant.Constant.stringVal(_x._val).length : GoInt64);
                        };
                        if (_isUntyped(_x._typ)) {
                            _x._typ = Go.asInterface(typ[((17 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                        };
                    };
                } else if (Go.typeEquals((__type__ : Ref<Array_>))) {
                    var _u:Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                    _valid = true;
                    _length = _u._len;
                    if (_x._mode != ((5 : stdgo.go.types.Types.T_operandMode))) {
                        _check._errorf(Go.asInterface(_x), (54 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot slice %s (value not addressable)" : GoString), Go.toInterface(Go.asInterface(_x)));
                        _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                        return;
                    };
                    _x._typ = Go.asInterface((Go.setRef(({ _elem : _u._elem } : Slice_)) : Ref<stdgo.go.types.Types.Slice_>));
                } else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
                    var _u:Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_under(_u._base)) : Ref<Array_>)) : Ref<Array_>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.types.Types.Array_>), ok : false };
                        }, _u = __tmp__.value, __0 = __tmp__.ok;
                        if (_u != null && ((_u : Dynamic).__nil__ == null || !(_u : Dynamic).__nil__)) {
                            _valid = true;
                            _length = _u._len;
                            _x._typ = Go.asInterface((Go.setRef(({ _elem : _u._elem } : Slice_)) : Ref<stdgo.go.types.Types.Slice_>));
                        };
                    };
                } else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
                    var _u:Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                    _valid = true;
                };
            };
            if (!_valid) {
                _check._errorf(Go.asInterface(_x), (54 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot slice %s" : GoString), Go.toInterface(Go.asInterface(_x)));
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                return;
            };
            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
            if (_e.slice3 && ((_e.high == null) || (_e.max == null))) {
                _check._error(Go.asInterface(_inNode(Go.asInterface(_e), _e.rbrack)), (-1 : stdgo.internal.types.errors.Errors.Code), ("2nd and 3rd index required in 3-index slice" : GoString));
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                return;
            };
            var _ind:GoArray<GoInt64> = new GoArray<GoInt64>(...[for (i in 0 ... 3) (0 : GoInt64)]);
            for (_i => _expr in (new Slice<stdgo.go.ast.Ast.Expr>(3, 3, _e.low, _e.high, _e.max) : Slice<stdgo.go.ast.Ast.Expr>)) {
                var _x:GoInt64 = (-1i64 : GoInt64);
                if (_expr != null) {
                    var _max:GoInt64 = (-1i64 : GoInt64);
                    if (_length >= (0i64 : GoInt64)) {
                        _max = _length + (1i64 : GoInt64);
                    };
                    {
                        var __tmp__ = _check._index(_expr, _max), __1:stdgo.go.types.Types.Type = __tmp__._0, _v:GoInt64 = __tmp__._1;
                        if (_v >= (0i64 : GoInt64)) {
                            _x = _v;
                        };
                    };
                } else if (_i == ((0 : GoInt))) {
                    _x = (0i64 : GoInt64);
                } else if (_length >= (0i64 : GoInt64)) {
                    _x = _length;
                };
                _ind[(_i : GoInt)] = _x;
            };
            @:label("L") for (_i => _x in (_ind.__slice__(0, (2 : GoInt)) : Slice<GoInt64>)) {
                if (_x > (0i64 : GoInt64)) {
                    for (_j => _y in (_ind.__slice__(_i + (1 : GoInt)) : Slice<GoInt64>)) {
                        if ((_y >= (0i64 : GoInt64)) && (_y < _x)) {
                            var _at:stdgo.go.ast.Ast.Expr = (new Slice<stdgo.go.ast.Ast.Expr>(3, 3, _e.low, _e.high, _e.max) : Slice<stdgo.go.ast.Ast.Expr>)[((_i + (1 : GoInt)) + _j : GoInt)];
                            _check._errorf(_at, (53 : stdgo.internal.types.errors.Errors.Code), ("invalid slice indices: %d < %d" : GoString), Go.toInterface(_y), Go.toInterface(_x));
                            @:jump("L") break;
                        };
                    };
                };
            };
        });
    }
    /**
        // If e is a valid function instantiation, indexExpr returns true.
        // In that case x represents the uninstantiated function value and
        // it is the caller's responsibility to instantiate the function.
    **/
    @:keep
    static public function _indexExpr( _check:Ref<Checker>, _x:Ref<T_operand>, _e:Ref<stdgo.go.internal.typeparams.Typeparams.IndexExpr>):Bool {
        var _isFuncInst:Bool = false;
        _check._exprOrType(_x, _e.indexListExpr.x, true);
        {
            final __value__ = _x._mode;
            if (__value__ == ((0 : stdgo.go.types.Types.T_operandMode))) {
                _check._use(..._e.indexListExpr.indices.__toArray__());
                return false;
            } else if (__value__ == ((3 : stdgo.go.types.Types.T_operandMode))) {
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                _x._typ = _check._varType(_e.orig);
                if (Go.toInterface(_x._typ) != (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                    _x._mode = (3 : stdgo.go.types.Types.T_operandMode);
                };
                return false;
            } else if (__value__ == ((7 : stdgo.go.types.Types.T_operandMode))) {
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_under(_x._typ)) : Ref<Signature>)) : Ref<Signature>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Signature>), ok : false };
                    }, _sig = __tmp__.value, __0 = __tmp__.ok;
                    if (((_sig != null) && ((_sig : Dynamic).__nil__ == null || !(_sig : Dynamic).__nil__)) && (_sig.typeParams().len() > (0 : GoInt))) {
                        return true;
                    };
                };
            };
        };
        _check._nonGeneric(_x);
        if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
            return false;
        };
        var _valid:Bool = false;
        var _length:GoInt64 = (-1i64 : GoInt64);
        {
            final __type__ = _under(_x._typ);
            {
                var __bool__ = true;
                while (__bool__) {
                    __bool__ = false;
                    if (Go.typeEquals((__type__ : Ref<Basic>))) {
                        var _typ:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                        if (_isString(Go.asInterface(_typ))) {
                            _valid = true;
                            if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
                                _length = (stdgo.go.constant.Constant.stringVal(_x._val).length : GoInt64);
                            };
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = _universeByte;
                        };
                    } else if (Go.typeEquals((__type__ : Ref<Array_>))) {
                        var _typ:Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                        _valid = true;
                        _length = _typ._len;
                        if (_x._mode != ((5 : stdgo.go.types.Types.T_operandMode))) {
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                        };
                        _x._typ = _typ._elem;
                    } else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
                        var _typ:Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                        {
                            var __tmp__ = try {
                                { value : (Go.typeAssert((Go.toInterface(_under(_typ._base)) : Ref<Array_>)) : Ref<Array_>), ok : true };
                            } catch(_) {
                                { value : (null : Ref<stdgo.go.types.Types.Array_>), ok : false };
                            }, _typ = __tmp__.value, __1 = __tmp__.ok;
                            if (_typ != null && ((_typ : Dynamic).__nil__ == null || !(_typ : Dynamic).__nil__)) {
                                _valid = true;
                                _length = _typ._len;
                                _x._mode = (5 : stdgo.go.types.Types.T_operandMode);
                                _x._typ = _typ._elem;
                            };
                        };
                    } else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
                        var _typ:Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                        _valid = true;
                        _x._mode = (5 : stdgo.go.types.Types.T_operandMode);
                        _x._typ = _typ._elem;
                    } else if (Go.typeEquals((__type__ : Ref<Map_>))) {
                        var _typ:Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                        var _index:stdgo.go.ast.Ast.Expr = _check._singleIndex(_e);
                        if (_index == null) {
                            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                            return false;
                        };
                        var _key:T_operand = ({} : stdgo.go.types.Types.T_operand);
                        _check._expr((Go.setRef(_key) : Ref<stdgo.go.types.Types.T_operand>), _index);
                        _check._assignment((Go.setRef(_key) : Ref<stdgo.go.types.Types.T_operand>), _typ._key, ("map index" : GoString));
                        _x._mode = (6 : stdgo.go.types.Types.T_operandMode);
                        _x._typ = _typ._elem;
                        _x._expr = _e.orig;
                        return false;
                    } else if (Go.typeEquals((__type__ : Ref<Interface>))) {
                        var _typ:Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                        if (!_isTypeParam(_x._typ)) {
                            break;
                        };
                        var __0:Type = (null : stdgo.go.types.Types.Type), __1:Type = (null : stdgo.go.types.Types.Type), _elem:Type = __1, _key:Type = __0;
                        var _mode:stdgo.go.types.Types.T_operandMode = (5 : stdgo.go.types.Types.T_operandMode);
                        if (_typ._typeSet()._underIs(function(_u:Type):Bool {
                            var _l:GoInt64 = (-1i64 : GoInt64);
                            var __0:Type = (null : stdgo.go.types.Types.Type), __1:Type = (null : stdgo.go.types.Types.Type), _e:Type = __1, _k:Type = __0;
                            {
                                final __type__ = _u;
                                if (Go.typeEquals((__type__ : Ref<Basic>))) {
                                    var _t:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                                    if (_isString(Go.asInterface(_t))) {
                                        _e = _universeByte;
                                        _mode = (7 : stdgo.go.types.Types.T_operandMode);
                                    };
                                } else if (Go.typeEquals((__type__ : Ref<Array_>))) {
                                    var _t:Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                                    _l = _t._len;
                                    _e = _t._elem;
                                    if (_x._mode != ((5 : stdgo.go.types.Types.T_operandMode))) {
                                        _mode = (7 : stdgo.go.types.Types.T_operandMode);
                                    };
                                } else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
                                    var _t:Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                                    {
                                        var __tmp__ = try {
                                            { value : (Go.typeAssert((Go.toInterface(_under(_t._base)) : Ref<Array_>)) : Ref<Array_>), ok : true };
                                        } catch(_) {
                                            { value : (null : Ref<stdgo.go.types.Types.Array_>), ok : false };
                                        }, _t = __tmp__.value, __0 = __tmp__.ok;
                                        if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                                            _l = _t._len;
                                            _e = _t._elem;
                                        };
                                    };
                                } else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
                                    var _t:Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                                    _e = _t._elem;
                                } else if (Go.typeEquals((__type__ : Ref<Map_>))) {
                                    var _t:Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                                    _k = _t._key;
                                    _e = _t._elem;
                                };
                            };
                            if (_e == null) {
                                return false;
                            };
                            if (_elem == null) {
                                _length = _l;
                                {
                                    final __tmp__0 = _k;
                                    final __tmp__1 = _e;
                                    _key = __tmp__0;
                                    _elem = __tmp__1;
                                };
                                return true;
                            };
                            if (!identical(_key, _k)) {
                                return false;
                            };
                            if (!identical(_elem, _e)) {
                                return false;
                            };
                            if ((_l >= (0i64 : GoInt64)) && (_l < _length)) {
                                _length = _l;
                            };
                            return true;
                        })) {
                            if (_key != null) {
                                var _index:stdgo.go.ast.Ast.Expr = _check._singleIndex(_e);
                                if (_index == null) {
                                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                                    return false;
                                };
                                var _k:T_operand = ({} : stdgo.go.types.Types.T_operand);
                                _check._expr((Go.setRef(_k) : Ref<stdgo.go.types.Types.T_operand>), _index);
                                _check._assignment((Go.setRef(_k) : Ref<stdgo.go.types.Types.T_operand>), _key, ("map index" : GoString));
                                _x._mode = (6 : stdgo.go.types.Types.T_operandMode);
                                _x._typ = _elem;
                                _x._expr = Go.asInterface(_e);
                                return false;
                            };
                            _valid = true;
                            _x._mode = _mode;
                            _x._typ = _elem;
                        };
                    };
                    break;
                };
            };
        };
        if (!_valid) {
            _check._errorf(Go.asInterface(_x), (51 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot index %s" : GoString), Go.toInterface(Go.asInterface(_x)));
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            return false;
        };
        var _index:stdgo.go.ast.Ast.Expr = _check._singleIndex(_e);
        if (_index == null) {
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            return false;
        };
        if (_x._typ == null) {
            _x._typ = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
        };
        _check._index(_index, _length);
        return false;
    }
    /**
        // singleValue reports an error if x describes a tuple and sets x.mode to invalid.
    **/
    @:keep
    static public function _singleValue( _check:Ref<Checker>, _x:Ref<T_operand>):Void {
        if (_x._mode == ((7 : stdgo.go.types.Types.T_operandMode))) {
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_x._typ) : Ref<Tuple>)) : Ref<Tuple>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.Tuple>), ok : false };
                }, _t = __tmp__.value, _ok = __tmp__.ok;
                if (_ok) {
                    _assert(_t.len() != ((1 : GoInt)));
                    _check._errorf(Go.asInterface(_x), (41 : stdgo.internal.types.errors.Errors.Code), ("multiple-value %s in single-value context" : GoString), Go.toInterface(Go.asInterface(_x)));
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                };
            };
        };
    }
    /**
        // exclude reports an error if x.mode is in modeset and sets x.mode to invalid.
        // The modeset may contain any of 1<<novalue, 1<<builtin, 1<<typexpr.
    **/
    @:keep
    static public function _exclude( _check:Ref<Checker>, _x:Ref<T_operand>, _modeset:GoUInt):Void {
        if (_modeset & ((1u32 : GoUInt) << _x._mode) != ((0u32 : GoUInt))) {
            var _msg:GoString = ("" : GoString);
            var _code:Code = ((0 : GoInt) : stdgo.internal.types.errors.Errors.Code);
            {
                final __value__ = _x._mode;
                if (__value__ == ((1 : stdgo.go.types.Types.T_operandMode))) {
                    if (_modeset & (8u32 : GoUInt) != ((0u32 : GoUInt))) {
                        _msg = ("%s used as value" : GoString);
                    } else {
                        _msg = ("%s used as value or type" : GoString);
                    };
                    _code = (41 : stdgo.internal.types.errors.Errors.Code);
                } else if (__value__ == ((2 : stdgo.go.types.Types.T_operandMode))) {
                    _msg = ("%s must be called" : GoString);
                    _code = (82 : stdgo.internal.types.errors.Errors.Code);
                } else if (__value__ == ((3 : stdgo.go.types.Types.T_operandMode))) {
                    _msg = ("%s is not an expression" : GoString);
                    _code = (42 : stdgo.internal.types.errors.Errors.Code);
                } else {
                    _unreachable();
                };
            };
            _check._errorf(Go.asInterface(_x), _code, _msg, Go.toInterface(Go.asInterface(_x)));
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
        };
    }
    /**
        // exprOrType typechecks expression or type e and initializes x with the expression value or type.
        // If allowGeneric is set, the operand type may be an uninstantiated parameterized type or function
        // value.
        // If an error occurred, x.mode is set to invalid.
    **/
    @:keep
    static public function _exprOrType( _check:Ref<Checker>, _x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _allowGeneric:Bool):Void {
        _check._rawExpr(_x, _e, (null : stdgo.go.types.Types.Type), _allowGeneric);
        _check._exclude(_x, (2u32 : GoUInt));
        _check._singleValue(_x);
    }
    /**
        // exprWithHint typechecks expression e and initializes x with the expression value;
        // hint is the type of a composite literal element.
        // If an error occurred, x.mode is set to invalid.
    **/
    @:keep
    static public function _exprWithHint( _check:Ref<Checker>, _x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _hint:Type):Void {
        _assert(_hint != null);
        _check._rawExpr(_x, _e, _hint, false);
        _check._exclude(_x, (14u32 : GoUInt));
        _check._singleValue(_x);
    }
    /**
        // multiExpr is like expr but the result may also be a multi-value.
    **/
    @:keep
    static public function _multiExpr( _check:Ref<Checker>, _x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr):Void {
        _check._rawExpr(_x, _e, (null : stdgo.go.types.Types.Type), false);
        _check._exclude(_x, (14u32 : GoUInt));
    }
    /**
        // expr typechecks expression e and initializes x with the expression value.
        // The result must be a single value.
        // If an error occurred, x.mode is set to invalid.
    **/
    @:keep
    static public function _expr( _check:Ref<Checker>, _x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr):Void {
        _check._rawExpr(_x, _e, (null : stdgo.go.types.Types.Type), false);
        _check._exclude(_x, (14u32 : GoUInt));
        _check._singleValue(_x);
    }
    /**
        // typeAssertion checks x.(T). The type of x must be an interface.
    **/
    @:keep
    static public function _typeAssertion( _check:Ref<Checker>, _e:stdgo.go.ast.Ast.Expr, _x:Ref<T_operand>, t:Type, _typeSwitch:Bool):Void {
        var __tmp__ = _check._assertableTo((Go.typeAssert((Go.toInterface(_under(_x._typ)) : Ref<Interface>)) : Ref<Interface>), t), _method:Ref<stdgo.go.types.Types.Func> = __tmp__._0, _alt:Ref<stdgo.go.types.Types.Func> = __tmp__._1;
        if (_method == null || (_method : Dynamic).__nil__) {
            return;
        };
        var _cause:GoString = _check._missingMethodCause(t, _x._typ, _method, _alt);
        if (_typeSwitch) {
            _check._errorf(_e, (95 : stdgo.internal.types.errors.Errors.Code), ("impossible type switch case: %s\n\t%s cannot have dynamic type %s %s" : GoString), Go.toInterface(_e), Go.toInterface(Go.asInterface(_x)), Go.toInterface(t), Go.toInterface(_cause));
            return;
        };
        _check._errorf(_e, (95 : stdgo.internal.types.errors.Errors.Code), ("impossible type assertion: %s\n\t%s does not implement %s %s" : GoString), Go.toInterface(_e), Go.toInterface(t), Go.toInterface(_x._typ), Go.toInterface(_cause));
    }
    /**
        // exprInternal contains the core of type checking of expressions.
        // Must only be called by rawExpr.
    **/
    @:keep
    static public function _exprInternal( _check:Ref<Checker>, _x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _hint:Type):T_exprKind {
        stdgo.internal.Macro.controlFlow({
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            _x._typ = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
            {
                final __type__ = _e;
                {
                    var __bool__ = true;
                    while (__bool__) {
                        __bool__ = false;
                        if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BadExpr>))) {
                            var _e:Ref<stdgo.go.ast.Ast.BadExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BadExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BadExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BadExpr>) : __type__.__underlying__().value;
                            @:goto "Error";
                        } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ident>))) {
                            var _e:Ref<stdgo.go.ast.Ast.Ident> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ident>) : __type__.__underlying__().value;
                            _check._ident(_x, _e, null, false);
                        } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ellipsis>))) {
                            var _e:Ref<stdgo.go.ast.Ast.Ellipsis> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.Ellipsis>) : __type__.__underlying__().value;
                            _check._error(Go.asInterface(_e), (77 : stdgo.internal.types.errors.Errors.Code), ("invalid use of \'...\'" : GoString));
                            @:goto "Error";
                        } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BasicLit>))) {
                            var _e:Ref<stdgo.go.ast.Ast.BasicLit> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BasicLit>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BasicLit>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BasicLit>) : __type__.__underlying__().value;
                            {
                                final __value__ = _e.kind;
                                if (__value__ == ((5 : stdgo.go.token.Token.Token)) || __value__ == ((6 : stdgo.go.token.Token.Token)) || __value__ == ((7 : stdgo.go.token.Token.Token))) {
                                    _check._langCompat(_e);
                                    {};
                                    if ((_e.value.length) > (10000 : GoInt)) {
                                        _check._errorf(Go.asInterface(_e), (14 : stdgo.internal.types.errors.Errors.Code), ("excessively long constant: %s... (%d chars)" : GoString), Go.toInterface((_e.value.__slice__(0, (10 : GoInt)) : GoString)), Go.toInterface((_e.value.length)));
                                        @:goto "Error";
                                    };
                                };
                            };
                            _x._setConst(_e.kind, _e.value);
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                _check._errorf(Go.asInterface(_e), (14 : stdgo.internal.types.errors.Errors.Code), ("malformed constant: %s" : GoString), Go.toInterface(_e.value));
                                @:goto "Error";
                            };
                            _check._overflow(_x, _e.pos());
                        } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.FuncLit>))) {
                            var _e:Ref<stdgo.go.ast.Ast.FuncLit> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.FuncLit>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.FuncLit>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.FuncLit>) : __type__.__underlying__().value;
                            {
                                var __tmp__ = try {
                                    { value : (Go.typeAssert((Go.toInterface(_check._typ(Go.asInterface(_e.type))) : Ref<Signature>)) : Ref<Signature>), ok : true };
                                } catch(_) {
                                    { value : (null : Ref<stdgo.go.types.Types.Signature>), ok : false };
                                }, _sig = __tmp__.value, _ok = __tmp__.ok;
                                if (_ok) {
                                    if (!_check._conf.ignoreFuncBodies && ((_e.body != null) && ((_e.body : Dynamic).__nil__ == null || !(_e.body : Dynamic).__nil__))) {
                                        var _decl = _check._environment._decl;
                                        var _iota:stdgo.go.constant.Constant.Value = _check._environment._iota;
                                        _check._later(function():Void {
                                            _check._funcBody(_decl, ("<function literal>" : GoString), _sig, _e.body, _iota);
                                        })._describef(Go.asInterface(_e), ("func literal" : GoString));
                                    };
                                    _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                                    _x._typ = Go.asInterface(_sig);
                                } else {
                                    _check._errorf(Go.asInterface(_e), (-1 : stdgo.internal.types.errors.Errors.Code), ("invalid function literal %s" : GoString), Go.toInterface(Go.asInterface(_e)));
                                    @:goto "Error";
                                };
                            };
                        } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CompositeLit>))) {
                            var _e:Ref<stdgo.go.ast.Ast.CompositeLit> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CompositeLit>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.CompositeLit>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CompositeLit>) : __type__.__underlying__().value;
                            var __0:Type = (null : stdgo.go.types.Types.Type), __1:Type = (null : stdgo.go.types.Types.Type), _base:Type = __1, _typ:Type = __0;
                            {
                                var __switchIndex__ = -1;
                                var __run__ = true;
                                while (__run__) {
                                    __run__ = false;
                                    if (_e.type != null) {
                                        {
                                            var __tmp__ = try {
                                                { value : (Go.typeAssert((Go.toInterface(_e.type) : Ref<stdgo.go.ast.Ast.ArrayType>)) : Ref<stdgo.go.ast.Ast.ArrayType>), ok : true };
                                            } catch(_) {
                                                { value : (null : Ref<stdgo.go.ast.Ast.ArrayType>), ok : false };
                                            }, _atyp = __tmp__.value, __24 = __tmp__.ok;
                                            if (((_atyp != null) && ((_atyp : Dynamic).__nil__ == null || !(_atyp : Dynamic).__nil__)) && (_atyp.len != null)) {
                                                {
                                                    var __tmp__ = try {
                                                        { value : (Go.typeAssert((Go.toInterface(_atyp.len) : Ref<stdgo.go.ast.Ast.Ellipsis>)) : Ref<stdgo.go.ast.Ast.Ellipsis>), ok : true };
                                                    } catch(_) {
                                                        { value : (null : Ref<stdgo.go.ast.Ast.Ellipsis>), ok : false };
                                                    }, _ellip = __tmp__.value, __25 = __tmp__.ok;
                                                    if (((_ellip != null) && ((_ellip : Dynamic).__nil__ == null || !(_ellip : Dynamic).__nil__)) && (_ellip.elt == null)) {
                                                        _typ = Go.asInterface((Go.setRef(({ _len : (-1i64 : GoInt64), _elem : _check._varType(_atyp.elt) } : Array_)) : Ref<stdgo.go.types.Types.Array_>));
                                                        _base = _typ;
                                                        break;
                                                    };
                                                };
                                            };
                                        };
                                        _typ = _check._typ(_e.type);
                                        _base = _typ;
                                        break;
                                    } else if (_hint != null) {
                                        _typ = _hint;
                                        {
                                            var __tmp__ = _deref(_coreType(_typ));
                                            _base = __tmp__._0;
                                        };
                                        if (_base == null) {
                                            _check._errorf(Go.asInterface(_e), (71 : stdgo.internal.types.errors.Errors.Code), ("invalid composite literal element type %s (no core type)" : GoString), Go.toInterface(_typ));
                                            @:goto "Error";
                                        };
                                        break;
                                    } else {
                                        _check._error(Go.asInterface(_e), (70 : stdgo.internal.types.errors.Errors.Code), ("missing type in composite literal" : GoString));
                                        @:goto "Error";
                                    };
                                    break;
                                };
                            };
                            {
                                final __type__ = _coreType(_base);
                                {
                                    var __bool__ = true;
                                    while (__bool__) {
                                        __bool__ = false;
                                        if (Go.typeEquals((__type__ : Ref<Struct>))) {
                                            var _utyp:Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                                            if (_utyp._fields == null) {
                                                _check._error(Go.asInterface(_e), (12 : stdgo.internal.types.errors.Errors.Code), ("invalid recursive type" : GoString));
                                                @:goto "Error";
                                            };
                                            if ((_e.elts.length) == ((0 : GoInt))) {
                                                break;
                                            };
                                            var _fields = _utyp._fields;
                                            {
                                                var __tmp__ = try {
                                                    { value : (Go.typeAssert((Go.toInterface(_e.elts[(0 : GoInt)]) : Ref<stdgo.go.ast.Ast.KeyValueExpr>)) : Ref<stdgo.go.ast.Ast.KeyValueExpr>), ok : true };
                                                } catch(_) {
                                                    { value : (null : Ref<stdgo.go.ast.Ast.KeyValueExpr>), ok : false };
                                                }, __26 = __tmp__.value, _ok = __tmp__.ok;
                                                if (_ok) {
                                                    var _visited = new Slice<Bool>((_fields.length : GoInt).toBasic(), 0);
                                                    for (__27 => _e in _e.elts) {
                                                        var __tmp__ = try {
                                                            { value : (Go.typeAssert((Go.toInterface(_e) : Ref<stdgo.go.ast.Ast.KeyValueExpr>)) : Ref<stdgo.go.ast.Ast.KeyValueExpr>), ok : true };
                                                        } catch(_) {
                                                            { value : (null : Ref<stdgo.go.ast.Ast.KeyValueExpr>), ok : false };
                                                        }, _kv = __tmp__.value, __28 = __tmp__.ok;
                                                        if (_kv == null || (_kv : Dynamic).__nil__) {
                                                            _check._error(_e, (64 : stdgo.internal.types.errors.Errors.Code), ("mixture of field:value and value elements in struct literal" : GoString));
                                                            continue;
                                                        };
                                                        var __tmp__ = try {
                                                            { value : (Go.typeAssert((Go.toInterface(_kv.key) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>), ok : true };
                                                        } catch(_) {
                                                            { value : (null : Ref<stdgo.go.ast.Ast.Ident>), ok : false };
                                                        }, _key = __tmp__.value, __29 = __tmp__.ok;
                                                        _check._expr(_x, _kv.value);
                                                        if (_key == null || (_key : Dynamic).__nil__) {
                                                            _check._errorf(Go.asInterface(_kv), (69 : stdgo.internal.types.errors.Errors.Code), ("invalid field name %s in struct literal" : GoString), Go.toInterface(_kv.key));
                                                            continue;
                                                        };
                                                        var _i:GoInt = _fieldIndex(_utyp._fields, _check._pkg, _key.name);
                                                        if (_i < (0 : GoInt)) {
                                                            _check._errorf(Go.asInterface(_kv), (66 : stdgo.internal.types.errors.Errors.Code), ("unknown field %s in struct literal of type %s" : GoString), Go.toInterface(_key.name), Go.toInterface(_base));
                                                            continue;
                                                        };
                                                        var _fld = _fields[(_i : GoInt)];
                                                        _check._recordUse(_key, Go.asInterface(_fld));
                                                        var _etyp:stdgo.go.types.Types.Type = _fld._object._typ;
                                                        _check._assignment(_x, _etyp, ("struct literal" : GoString));
                                                        if (_visited[(_i : GoInt)]) {
                                                            _check._errorf(Go.asInterface(_kv), (67 : stdgo.internal.types.errors.Errors.Code), ("duplicate field name %s in struct literal" : GoString), Go.toInterface(_key.name));
                                                            continue;
                                                        };
                                                        _visited[(_i : GoInt)] = true;
                                                    };
                                                } else {
                                                    for (_i => _e in _e.elts) {
                                                        {
                                                            var __tmp__ = try {
                                                                { value : (Go.typeAssert((Go.toInterface(_e) : Ref<stdgo.go.ast.Ast.KeyValueExpr>)) : Ref<stdgo.go.ast.Ast.KeyValueExpr>), ok : true };
                                                            } catch(_) {
                                                                { value : (null : Ref<stdgo.go.ast.Ast.KeyValueExpr>), ok : false };
                                                            }, _kv = __tmp__.value, __38 = __tmp__.ok;
                                                            if (_kv != null && ((_kv : Dynamic).__nil__ == null || !(_kv : Dynamic).__nil__)) {
                                                                _check._error(Go.asInterface(_kv), (64 : stdgo.internal.types.errors.Errors.Code), ("mixture of field:value and value elements in struct literal" : GoString));
                                                                continue;
                                                            };
                                                        };
                                                        _check._expr(_x, _e);
                                                        if (_i >= (_fields.length)) {
                                                            _check._errorf(Go.asInterface(_x), (65 : stdgo.internal.types.errors.Errors.Code), ("too many values in struct literal of type %s" : GoString), Go.toInterface(_base));
                                                            break;
                                                        };
                                                        var _fld = _fields[(_i : GoInt)];
                                                        if (!_fld.exported() && (_fld._object._pkg != _check._pkg)) {
                                                            _check._errorf(Go.asInterface(_x), (68 : stdgo.internal.types.errors.Errors.Code), ("implicit assignment to unexported field %s in struct literal of type %s" : GoString), Go.toInterface(_fld._object._name), Go.toInterface(_base));
                                                            continue;
                                                        };
                                                        var _etyp:stdgo.go.types.Types.Type = _fld._object._typ;
                                                        _check._assignment(_x, _etyp, ("struct literal" : GoString));
                                                    };
                                                    if ((_e.elts.length) < (_fields.length)) {
                                                        _check._errorf(Go.asInterface(_inNode(Go.asInterface(_e), _e.rbrace)), (65 : stdgo.internal.types.errors.Errors.Code), ("too few values in struct literal of type %s" : GoString), Go.toInterface(_base));
                                                    };
                                                };
                                            };
                                        } else if (Go.typeEquals((__type__ : Ref<Array_>))) {
                                            var _utyp:Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                                            if (_utyp._elem == null) {
                                                _check._error(Go.asInterface(_e), (12 : stdgo.internal.types.errors.Errors.Code), ("invalid recursive type" : GoString));
                                                @:goto "Error";
                                            };
                                            var _n:GoInt64 = _check._indexedElts(_e.elts, _utyp._elem, _utyp._len);
                                            if (_utyp._len < (0i64 : GoInt64)) {
                                                _utyp._len = _n;
                                                if (_e.type != null) {
                                                    _check._recordTypeAndValue(_e.type, (3 : stdgo.go.types.Types.T_operandMode), Go.asInterface(_utyp), (null : stdgo.go.constant.Constant.Value));
                                                };
                                            };
                                        } else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
                                            var _utyp:Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                                            if (_utyp._elem == null) {
                                                _check._error(Go.asInterface(_e), (12 : stdgo.internal.types.errors.Errors.Code), ("invalid recursive type" : GoString));
                                                @:goto "Error";
                                            };
                                            _check._indexedElts(_e.elts, _utyp._elem, (-1i64 : GoInt64));
                                        } else if (Go.typeEquals((__type__ : Ref<Map_>))) {
                                            var _utyp:Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                                            if ((_utyp._key == null) || (_utyp._elem == null)) {
                                                _check._error(Go.asInterface(_e), (12 : stdgo.internal.types.errors.Errors.Code), ("invalid recursive type" : GoString));
                                                @:goto "Error";
                                            };
                                            var _keyIsInterface:Bool = _isNonTypeParamInterface(_utyp._key);
                                            var _visited = ({
                                                final x = new GoAnyInterfaceMap<Slice<stdgo.go.types.Types.Type>>();
                                                x.__defaultValue__ = () -> (null : Slice<stdgo.go.types.Types.Type>);
                                                @:mergeBlock {};
                                                cast x;
                                            } : GoMap<AnyInterface, Slice<stdgo.go.types.Types.Type>>);
                                            for (__47 => _e in _e.elts) {
                                                var __tmp__ = try {
                                                    { value : (Go.typeAssert((Go.toInterface(_e) : Ref<stdgo.go.ast.Ast.KeyValueExpr>)) : Ref<stdgo.go.ast.Ast.KeyValueExpr>), ok : true };
                                                } catch(_) {
                                                    { value : (null : Ref<stdgo.go.ast.Ast.KeyValueExpr>), ok : false };
                                                }, _kv = __tmp__.value, __48 = __tmp__.ok;
                                                if (_kv == null || (_kv : Dynamic).__nil__) {
                                                    _check._error(_e, (61 : stdgo.internal.types.errors.Errors.Code), ("missing key in map literal" : GoString));
                                                    continue;
                                                };
                                                _check._exprWithHint(_x, _kv.key, _utyp._key);
                                                _check._assignment(_x, _utyp._key, ("map literal" : GoString));
                                                if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                                    continue;
                                                };
                                                if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
                                                    var _duplicate:Bool = false;
                                                    var _xkey:AnyInterface = _keyVal(_x._val);
                                                    if (_keyIsInterface) {
                                                        for (__49 => _vtyp in _visited[_xkey]) {
                                                            if (identical(_vtyp, _x._typ)) {
                                                                _duplicate = true;
                                                                break;
                                                            };
                                                        };
                                                        _visited[_xkey] = (_visited[_xkey].__append__(_x._typ));
                                                    } else {
                                                        {
                                                            var __tmp__ = (_visited != null && _visited.exists(_xkey) ? { value : _visited[_xkey], ok : true } : { value : (null : Slice<stdgo.go.types.Types.Type>), ok : false });
                                                            _duplicate = __tmp__.ok;
                                                        };
                                                        _visited[_xkey] = (null : Slice<stdgo.go.types.Types.Type>);
                                                    };
                                                    if (_duplicate) {
                                                        _check._errorf(Go.asInterface(_x), (60 : stdgo.internal.types.errors.Errors.Code), ("duplicate key %s in map literal" : GoString), Go.toInterface(_x._val));
                                                        continue;
                                                    };
                                                };
                                                _check._exprWithHint(_x, _kv.value, _utyp._elem);
                                                _check._assignment(_x, _utyp._elem, ("map literal" : GoString));
                                            };
                                        } else {
                                            var _utyp:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                                            for (__50 => _e in _e.elts) {
                                                {
                                                    var __tmp__ = try {
                                                        { value : (Go.typeAssert((Go.toInterface(_e) : Ref<stdgo.go.ast.Ast.KeyValueExpr>)) : Ref<stdgo.go.ast.Ast.KeyValueExpr>), ok : true };
                                                    } catch(_) {
                                                        { value : (null : Ref<stdgo.go.ast.Ast.KeyValueExpr>), ok : false };
                                                    }, _kv = __tmp__.value, __51 = __tmp__.ok;
                                                    if (_kv != null && ((_kv : Dynamic).__nil__ == null || !(_kv : Dynamic).__nil__)) {
                                                        _e = _kv.value;
                                                    };
                                                };
                                                _check._use(_e);
                                            };
                                            if (Go.toInterface(_utyp) != (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                                                _check._errorf(Go.asInterface(_e), (71 : stdgo.internal.types.errors.Errors.Code), ("invalid composite literal type %s" : GoString), Go.toInterface(_typ));
                                                @:goto "Error";
                                            };
                                        };
                                        break;
                                    };
                                };
                            };
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = _typ;
                        } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ParenExpr>))) {
                            var _e:Ref<stdgo.go.ast.Ast.ParenExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__().value;
                            var _kind:stdgo.go.types.Types.T_exprKind = _check._rawExpr(_x, _e.x, (null : stdgo.go.types.Types.Type), false);
                            _x._expr = Go.asInterface(_e);
                            return _kind;
                        } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectorExpr>))) {
                            var _e:Ref<stdgo.go.ast.Ast.SelectorExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SelectorExpr>) : __type__.__underlying__().value;
                            _check._selector(_x, _e, null, false);
                        } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexExpr>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexListExpr>))) {
                            var _e:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                            var _ix = stdgo.go.internal.typeparams.Typeparams.unpackIndexExpr(_e);
                            if (_check._indexExpr(_x, _ix)) {
                                _check._funcInst(_x, _ix);
                            };
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                @:goto "Error";
                            };
                        } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SliceExpr>))) {
                            var _e:Ref<stdgo.go.ast.Ast.SliceExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SliceExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.SliceExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.SliceExpr>) : __type__.__underlying__().value;
                            _check._sliceExpr(_x, _e);
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                @:goto "Error";
                            };
                        } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.TypeAssertExpr>))) {
                            var _e:Ref<stdgo.go.ast.Ast.TypeAssertExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeAssertExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.TypeAssertExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeAssertExpr>) : __type__.__underlying__().value;
                            _check._expr(_x, _e.x);
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                @:goto "Error";
                            };
                            if (_isTypeParam(_x._typ)) {
                                _check._errorf(Go.asInterface(_x), (94 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot use type assertion on type parameter value %s" : GoString), Go.toInterface(Go.asInterface(_x)));
                                @:goto "Error";
                            };
                            {
                                var __tmp__ = try {
                                    { value : (Go.typeAssert((Go.toInterface(_under(_x._typ)) : Ref<Interface>)) : Ref<Interface>), ok : true };
                                } catch(_) {
                                    { value : (null : Ref<stdgo.go.types.Types.Interface>), ok : false };
                                }, __52 = __tmp__.value, _ok = __tmp__.ok;
                                if (!_ok) {
                                    _check._errorf(Go.asInterface(_x), (94 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: %s is not an interface" : GoString), Go.toInterface(Go.asInterface(_x)));
                                    @:goto "Error";
                                };
                            };
                            if (_e.type == null) {
                                _check._error(Go.asInterface(_e), (115 : stdgo.internal.types.errors.Errors.Code), ("use of .(type) outside type switch" : GoString));
                                @:goto "Error";
                            };
                            var t:stdgo.go.types.Types.Type = _check._varType(_e.type);
                            if (Go.toInterface(t) == (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                                @:goto "Error";
                            };
                            _check._typeAssertion(Go.asInterface(_e), _x, t, false);
                            _x._mode = (8 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = t;
                        } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CallExpr>))) {
                            var _e:Ref<stdgo.go.ast.Ast.CallExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CallExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.CallExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CallExpr>) : __type__.__underlying__().value;
                            return _check._callExpr(_x, _e);
                        } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.StarExpr>))) {
                            var _e:Ref<stdgo.go.ast.Ast.StarExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.StarExpr>) : __type__.__underlying__().value;
                            _check._exprOrType(_x, _e.x, false);
                            {
                                final __value__ = _x._mode;
                                if (__value__ == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                    @:goto "Error";
                                } else if (__value__ == ((3 : stdgo.go.types.Types.T_operandMode))) {
                                    _check._validVarType(_e.x, _x._typ);
                                    _x._typ = Go.asInterface((Go.setRef(({ _base : _x._typ } : Pointer_)) : Ref<stdgo.go.types.Types.Pointer_>));
                                } else {
                                    var _base:Type = (null : stdgo.go.types.Types.Type);
                                    if (!_underIs(_x._typ, function(_u:Type):Bool {
                                        var __tmp__ = try {
                                            { value : (Go.typeAssert((Go.toInterface(_u) : Ref<Pointer_>)) : Ref<Pointer_>), ok : true };
                                        } catch(_) {
                                            { value : (null : Ref<stdgo.go.types.Types.Pointer_>), ok : false };
                                        }, _p = __tmp__.value, __0 = __tmp__.ok;
                                        if (_p == null || (_p : Dynamic).__nil__) {
                                            _check._errorf(Go.asInterface(_x), (50 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot indirect %s" : GoString), Go.toInterface(Go.asInterface(_x)));
                                            return false;
                                        };
                                        if ((_base != null) && !identical(_p._base, _base)) {
                                            _check._errorf(Go.asInterface(_x), (50 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: pointers of %s must have identical base types" : GoString), Go.toInterface(Go.asInterface(_x)));
                                            return false;
                                        };
                                        _base = _p._base;
                                        return true;
                                    })) {
                                        @:goto "Error";
                                    };
                                    _x._mode = (5 : stdgo.go.types.Types.T_operandMode);
                                    _x._typ = _base;
                                };
                            };
                        } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.UnaryExpr>))) {
                            var _e:Ref<stdgo.go.ast.Ast.UnaryExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__().value;
                            _check._unary(_x, _e);
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                @:goto "Error";
                            };
                            if (_e.op == ((36 : stdgo.go.token.Token.Token))) {
                                _x._expr = Go.asInterface(_e);
                                return (2 : stdgo.go.types.Types.T_exprKind);
                            };
                        } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BinaryExpr>))) {
                            var _e:Ref<stdgo.go.ast.Ast.BinaryExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__().value;
                            _check._binary(_x, Go.asInterface(_e), _e.x, _e.y, _e.op, _e.opPos);
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                @:goto "Error";
                            };
                        } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.KeyValueExpr>))) {
                            var _e:Ref<stdgo.go.ast.Ast.KeyValueExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.KeyValueExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.KeyValueExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.KeyValueExpr>) : __type__.__underlying__().value;
                            _check._error(Go.asInterface(_e), (-1 : stdgo.internal.types.errors.Errors.Code), ("no key:value expected" : GoString));
                            @:goto "Error";
                        } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ArrayType>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.StructType>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.FuncType>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.InterfaceType>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.MapType>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ChanType>))) {
                            var _e:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                            _x._mode = (3 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = _check._typ(_e);
                        } else {
                            var _e:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("%s: unknown expression type %T" : GoString), Go.toInterface(Go.asInterface(_check._fset.position(_e.pos()))), Go.toInterface(_e)));
                        };
                        break;
                    };
                };
            };
            _x._expr = _e;
            return (1 : stdgo.go.types.Types.T_exprKind);
            @:label("Error") _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            _x._expr = _e;
            return (2 : stdgo.go.types.Types.T_exprKind);
        });
        throw "controlFlow did not return";
    }
    /**
        // If x is a generic function or type, nonGeneric reports an error and invalidates x.mode and x.typ.
        // Otherwise it leaves x alone.
    **/
    @:keep
    static public function _nonGeneric( _check:Ref<Checker>, _x:Ref<T_operand>):Void {
        if ((_x._mode == (0 : stdgo.go.types.Types.T_operandMode)) || (_x._mode == (1 : stdgo.go.types.Types.T_operandMode))) {
            return;
        };
        var _what:GoString = ("" : GoString);
        {
            final __type__ = _x._typ;
            if (Go.typeEquals((__type__ : Ref<Named>))) {
                var _t:Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                if (_isGeneric(Go.asInterface(_t))) {
                    _what = ("type" : GoString);
                };
            } else if (Go.typeEquals((__type__ : Ref<Signature>))) {
                var _t:Ref<stdgo.go.types.Types.Signature> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__().value;
                if (_t._tparams != null && ((_t._tparams : Dynamic).__nil__ == null || !(_t._tparams : Dynamic).__nil__)) {
                    _what = ("function" : GoString);
                };
            };
        };
        if (_what != (Go.str())) {
            _check._errorf(_x._expr, (137 : stdgo.internal.types.errors.Errors.Code), ("cannot use generic %s %s without instantiation" : GoString), Go.toInterface(_what), Go.toInterface(_x._expr));
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            _x._typ = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
        };
    }
    /**
        // rawExpr typechecks expression e and initializes x with the expression
        // value or type. If an error occurred, x.mode is set to invalid.
        // If hint != nil, it is the type of a composite literal element.
        // If allowGeneric is set, the operand type may be an uninstantiated
        // parameterized type or function value.
    **/
    @:keep
    static public function _rawExpr( _check:Ref<Checker>, _x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _hint:Type, _allowGeneric:Bool):T_exprKind {
        var __deferstack__:Array<Void -> Void> = [];
        if (false) {
            _check._trace(_e.pos(), ("-- expr %s" : GoString), Go.toInterface(_e));
            _check._indent++;
            __deferstack__.unshift(() -> {
                var a = function():Void {
                    _check._indent--;
                    _check._trace(_e.pos(), ("=> %s" : GoString), Go.toInterface(Go.asInterface(_x)));
                };
                a();
            });
        };
        try {
            var _kind:stdgo.go.types.Types.T_exprKind = _check._exprInternal(_x, _e, _hint);
            if (!_allowGeneric) {
                _check._nonGeneric(_x);
            };
            _check._record(_x);
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _kind;
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return ((0 : GoInt) : stdgo.go.types.Types.T_exprKind);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return ((0 : GoInt) : stdgo.go.types.Types.T_exprKind);
        };
    }
    /**
        // If e != nil, it must be the binary expression; it may be nil for non-constant expressions
        // (when invoked for an assignment operation where the binary expression is implicit).
    **/
    @:keep
    static public function _binary( _check:Ref<Checker>, _x:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _lhs:stdgo.go.ast.Ast.Expr, _rhs:stdgo.go.ast.Ast.Expr, _op:stdgo.go.token.Token.Token, _opPos:stdgo.go.token.Token.Pos):Void {
        var _y:T_operand = ({} : stdgo.go.types.Types.T_operand);
        _check._expr(_x, _lhs);
        _check._expr((Go.setRef(_y) : Ref<stdgo.go.types.Types.T_operand>), _rhs);
        if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
            return;
        };
        if (_y._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            _x._expr = _y._expr;
            return;
        };
        if (_isShift(_op)) {
            _check._shift(_x, (Go.setRef(_y) : Ref<stdgo.go.types.Types.T_operand>), _e, _op);
            return;
        };
        var _mayConvert = function(_x:Ref<T_operand>, _y:Ref<T_operand>):Bool {
            if (_isTyped(_x._typ) && _isTyped(_y._typ)) {
                return false;
            };
            if (_isNonTypeParamInterface(_x._typ) || _isNonTypeParamInterface(_y._typ)) {
                return true;
            };
            if (_allBoolean(_x._typ) != (_allBoolean(_y._typ))) {
                return false;
            };
            if (_allString(_x._typ) != (_allString(_y._typ))) {
                return false;
            };
            if (_x._isNil()) {
                return _hasNil(_y._typ);
            };
            if (_y._isNil()) {
                return _hasNil(_x._typ);
            };
            if (_isPointer(_x._typ) || _isPointer(_y._typ)) {
                return false;
            };
            return true;
        };
        if (_mayConvert(_x, (Go.setRef(_y) : Ref<stdgo.go.types.Types.T_operand>))) {
            _check._convertUntyped(_x, _y._typ);
            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                return;
            };
            _check._convertUntyped((Go.setRef(_y) : Ref<stdgo.go.types.Types.T_operand>), _x._typ);
            if (_y._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                return;
            };
        };
        if (_isComparison(_op)) {
            _check._comparison(_x, (Go.setRef(_y) : Ref<stdgo.go.types.Types.T_operand>), _op, false);
            return;
        };
        if (!identical(_x._typ, _y._typ)) {
            if ((Go.toInterface(_x._typ) != Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]))) && (Go.toInterface(_y._typ) != Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                var _posn:T_positioner = Go.asInterface(_x);
                if (_e != null) {
                    _posn = _e;
                };
                if (_e != null) {
                    _check._errorf(_posn, (46 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: %s (mismatched types %s and %s)" : GoString), Go.toInterface(_e), Go.toInterface(_x._typ), Go.toInterface(_y._typ));
                } else {
                    _check._errorf(_posn, (46 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: %s %s= %s (mismatched types %s and %s)" : GoString), Go.toInterface(_lhs), Go.toInterface(Go.asInterface(_op)), Go.toInterface(_rhs), Go.toInterface(_x._typ), Go.toInterface(_y._typ));
                };
            };
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            return;
        };
        if (!_check._op(_binaryOpPredicates, _x, _op)) {
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            return;
        };
        if ((_op == (15 : stdgo.go.token.Token.Token)) || (_op == (16 : stdgo.go.token.Token.Token))) {
            if ((((_x._mode == (4 : stdgo.go.types.Types.T_operandMode)) || _allInteger(_x._typ)) && (_y._mode == (4 : stdgo.go.types.Types.T_operandMode))) && (stdgo.go.constant.Constant.sign(_y._val) == (0 : GoInt))) {
                _check._error(Go.asInterface((Go.setRef(_y) : Ref<stdgo.go.types.Types.T_operand>)), (47 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: division by zero" : GoString));
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                return;
            };
            if (((_x._mode == (4 : stdgo.go.types.Types.T_operandMode)) && (_y._mode == (4 : stdgo.go.types.Types.T_operandMode))) && _isComplex(_x._typ)) {
                var __0:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.real(_y._val), __1:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.imag(_y._val), _im:stdgo.go.constant.Constant.Value = __1, _re:stdgo.go.constant.Constant.Value = __0;
                var __0:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.binaryOp(_re, (14 : stdgo.go.token.Token.Token), _re), __1:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.binaryOp(_im, (14 : stdgo.go.token.Token.Token), _im), _im2:stdgo.go.constant.Constant.Value = __1, _re2:stdgo.go.constant.Constant.Value = __0;
                if ((stdgo.go.constant.Constant.sign(_re2) == (0 : GoInt)) && (stdgo.go.constant.Constant.sign(_im2) == (0 : GoInt))) {
                    _check._error(Go.asInterface((Go.setRef(_y) : Ref<stdgo.go.types.Types.T_operand>)), (47 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: division by zero" : GoString));
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                    return;
                };
            };
        };
        if ((_x._mode == (4 : stdgo.go.types.Types.T_operandMode)) && (_y._mode == (4 : stdgo.go.types.Types.T_operandMode))) {
            if ((_x._val.kind() == (0 : stdgo.go.constant.Constant.Kind)) || (_y._val.kind() == (0 : stdgo.go.constant.Constant.Kind))) {
                _x._val = stdgo.go.constant.Constant.makeUnknown();
                return;
            };
            if ((_op == (15 : stdgo.go.token.Token.Token)) && _isInteger(_x._typ)) {
                _op = (26 : stdgo.go.token.Token.Token);
            };
            _x._val = stdgo.go.constant.Constant.binaryOp(_x._val, _op, _y._val);
            _x._expr = _e;
            _check._overflow(_x, _opPos);
            return;
        };
        _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
    }
    /**
        // If e != nil, it must be the shift expression; it may be nil for non-constant shifts.
    **/
    @:keep
    static public function _shift( _check:Ref<Checker>, _x:Ref<T_operand>, _y:Ref<T_operand>, _e:stdgo.go.ast.Ast.Expr, _op:stdgo.go.token.Token.Token):Void {
        var _xval:stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
        if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
            _xval = stdgo.go.constant.Constant.toInt(_x._val);
        };
        if (_allInteger(_x._typ) || ((_isUntyped(_x._typ) && (_xval != null)) && (_xval.kind() == (3 : stdgo.go.constant.Constant.Kind)))) {} else {
            _check._errorf(Go.asInterface(_x), (57 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: shifted operand %s must be integer" : GoString), Go.toInterface(Go.asInterface(_x)));
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            return;
        };
        var _yval:stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
        if (_y._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
            _yval = stdgo.go.constant.Constant.toInt(_y._val);
            if ((_yval.kind() == (3 : stdgo.go.constant.Constant.Kind)) && (stdgo.go.constant.Constant.sign(_yval) < (0 : GoInt))) {
                _check._errorf(Go.asInterface(_y), (56 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: negative shift count %s" : GoString), Go.toInterface(Go.asInterface(_y)));
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                return;
            };
            if (_isUntyped(_y._typ)) {
                _check._representable(_y, typ[((7 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                if (_y._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                    return;
                };
            };
        } else {
            if (_allInteger(_y._typ)) {
                if (!_allUnsigned(_y._typ) && !_check._allowVersion(_check._pkg, (1 : GoInt), (13 : GoInt))) {
                    _check._errorf(Go.asInterface(_y), (135 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: signed shift count %s requires go1.13 or later" : GoString), Go.toInterface(Go.asInterface(_y)));
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                    return;
                };
            } else if (_isUntyped(_y._typ)) {
                _check._convertUntyped(_y, Go.asInterface(typ[((7 : stdgo.go.types.Types.BasicKind) : GoInt)]));
                if (_y._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                    return;
                };
            } else {
                _check._errorf(Go.asInterface(_y), (56 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: shift count %s must be integer" : GoString), Go.toInterface(Go.asInterface(_y)));
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                return;
            };
        };
        if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
            if (_y._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
                if ((_x._val.kind() == (0 : stdgo.go.constant.Constant.Kind)) || (_y._val.kind() == (0 : stdgo.go.constant.Constant.Kind))) {
                    _x._val = stdgo.go.constant.Constant.makeUnknown();
                    if (!_isInteger(_x._typ)) {
                        _x._typ = Go.asInterface(typ[((20 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                    };
                    return;
                };
                {};
                var __tmp__ = stdgo.go.constant.Constant.uint64Val(_yval), _s:GoUInt64 = __tmp__._0, _ok:Bool = __tmp__._1;
                if (!_ok || (_s > (1074i64 : GoUInt64))) {
                    _check._errorf(Go.asInterface(_y), (56 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: invalid shift count %s" : GoString), Go.toInterface(Go.asInterface(_y)));
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                    return;
                };
                if (!_isInteger(_x._typ)) {
                    _x._typ = Go.asInterface(typ[((20 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                };
                _x._val = stdgo.go.constant.Constant.shift(_xval, _op, (_s : GoUInt));
                _x._expr = _e;
                var _opPos:stdgo.go.token.Token.Pos = _x.pos();
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_e) : Ref<stdgo.go.ast.Ast.BinaryExpr>)) : Ref<stdgo.go.ast.Ast.BinaryExpr>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.ast.Ast.BinaryExpr>), ok : false };
                    }, _b = __tmp__.value, __8 = __tmp__.ok;
                    if (_b != null && ((_b : Dynamic).__nil__ == null || !(_b : Dynamic).__nil__)) {
                        _opPos = _b.opPos;
                    };
                };
                _check._overflow(_x, _opPos);
                return;
            };
            if (_isUntyped(_x._typ)) {
                {
                    var __tmp__ = (_check._untyped != null && _check._untyped.exists(_x._expr) ? { value : _check._untyped[_x._expr], ok : true } : { value : ({} : stdgo.go.types.Types.T_exprInfo), ok : false }), _info:stdgo.go.types.Types.T_exprInfo = __tmp__.value, _found:Bool = __tmp__.ok;
                    if (_found) {
                        _info._isLhs = true;
                        _check._untyped[_x._expr] = _info?.__copy__();
                    };
                };
                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                return;
            };
        };
        if (!_allInteger(_x._typ)) {
            _check._errorf(Go.asInterface(_x), (57 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: shifted operand %s must be integer" : GoString), Go.toInterface(Go.asInterface(_x)));
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            return;
        };
        _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
    }
    /**
        // kindString returns the type kind as a string.
    **/
    @:keep
    static public function _kindString( _check:Ref<Checker>, _typ:Type):GoString {
        {
            final __type__ = _under(_typ);
            if (Go.typeEquals((__type__ : Ref<Array_>))) {
                return ("array" : GoString);
            } else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
                return ("slice" : GoString);
            } else if (Go.typeEquals((__type__ : Ref<Struct>))) {
                return ("struct" : GoString);
            } else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
                return ("pointer" : GoString);
            } else if (Go.typeEquals((__type__ : Ref<Signature>))) {
                return ("func" : GoString);
            } else if (Go.typeEquals((__type__ : Ref<Interface>))) {
                if (_isTypeParam(_typ)) {
                    return _check._sprintf(("type parameter %s" : GoString), Go.toInterface(_typ));
                };
                return ("interface" : GoString);
            } else if (Go.typeEquals((__type__ : Ref<Map_>))) {
                return ("map" : GoString);
            } else if (Go.typeEquals((__type__ : Ref<Chan>))) {
                return ("chan" : GoString);
            } else {
                return _check._sprintf(("%s" : GoString), Go.toInterface(_typ));
            };
        };
    }
    /**
        // incomparableCause returns a more specific cause why typ is not comparable.
        // If there is no more specific cause, the result is "".
    **/
    @:keep
    static public function _incomparableCause( _check:Ref<Checker>, _typ:Type):GoString {
        {
            final __type__ = _under(_typ);
            if (Go.typeEquals((__type__ : Ref<Slice_>)) || Go.typeEquals((__type__ : Ref<Signature>)) || Go.typeEquals((__type__ : Ref<Map_>))) {
                return _check._kindString(_typ) + (" can only be compared to nil" : GoString);
            };
        };
        var _cause:GoString = ("" : GoString);
        _comparable(_typ, true, (null : GoMap<stdgo.go.types.Types.Type, Bool>), function(_format:GoString, _args:haxe.Rest<AnyInterface>):Void {
            _cause = _check._sprintf(_format, ..._args.__toArray__());
        });
        return _cause;
    }
    /**
        // If switchCase is true, the operator op is ignored.
    **/
    @:keep
    static public function _comparison( _check:Ref<Checker>, _x:Ref<T_operand>, _y:Ref<T_operand>, _op:stdgo.go.token.Token.Token, _switchCase:Bool):Void {
        stdgo.internal.Macro.controlFlow({
            if ((Go.toInterface(_x._typ) == Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]))) || (Go.toInterface(_y._typ) == Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                return;
            };
            if (_switchCase) {
                _op = (39 : stdgo.go.token.Token.Token);
            };
            var _errOp = _x;
            var _cause:GoString = Go.str();
            var _code:stdgo.internal.types.errors.Errors.Code = (46 : stdgo.internal.types.errors.Errors.Code);
            var __tmp__ = _x._assignableTo(_check, _y._typ, (null : Pointer<GoString>)), _ok:Bool = __tmp__._0, __0:stdgo.internal.types.errors.Errors.Code = __tmp__._1;
            if (!_ok) {
                {
                    var __tmp__ = _y._assignableTo(_check, _x._typ, (null : Pointer<GoString>));
                    _ok = __tmp__._0;
                };
            };
            if (!_ok) {
                _errOp = _y;
                _cause = _check._sprintf(("mismatched types %s and %s" : GoString), Go.toInterface(_x._typ), Go.toInterface(_y._typ));
                @:goto "Error";
            };
            _code = (45 : stdgo.internal.types.errors.Errors.Code);
            {
                final __value__ = _op;
                if (__value__ == ((39 : stdgo.go.token.Token.Token)) || __value__ == ((44 : stdgo.go.token.Token.Token))) {
                    if (_x._isNil() || _y._isNil()) {
                        var _typ:stdgo.go.types.Types.Type = _x._typ;
                        if (_x._isNil()) {
                            _typ = _y._typ;
                        };
                        if (!_hasNil(_typ)) {
                            _errOp = _y;
                            @:goto "Error";
                        };
                    } else if (!comparable(_x._typ)) {
                        _errOp = _x;
                        _cause = _check._incomparableCause(_x._typ);
                        @:goto "Error";
                    } else if (!comparable(_y._typ)) {
                        _errOp = _y;
                        _cause = _check._incomparableCause(_y._typ);
                        @:goto "Error";
                    };
                } else if (__value__ == ((40 : stdgo.go.token.Token.Token)) || __value__ == ((45 : stdgo.go.token.Token.Token)) || __value__ == ((41 : stdgo.go.token.Token.Token)) || __value__ == ((46 : stdgo.go.token.Token.Token))) {
                    if (!_allOrdered(_x._typ)) {
                        _errOp = _x;
                        @:goto "Error";
                    } else if (!_allOrdered(_y._typ)) {
                        _errOp = _y;
                        @:goto "Error";
                    };
                } else {
                    _unreachable();
                };
            };
            if ((_x._mode == (4 : stdgo.go.types.Types.T_operandMode)) && (_y._mode == (4 : stdgo.go.types.Types.T_operandMode))) {
                _x._val = stdgo.go.constant.Constant.makeBool(stdgo.go.constant.Constant.compare(_x._val, _op, _y._val));
            } else {
                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                _check._updateExprType(_x._expr, default_(_x._typ), true);
                _check._updateExprType(_y._expr, default_(_y._typ), true);
            };
            _x._typ = Go.asInterface(typ[((19 : stdgo.go.types.Types.BasicKind) : GoInt)]);
            return;
            @:label("Error") if (_cause == (Go.str())) {
                if (_isTypeParam(_x._typ) || _isTypeParam(_y._typ)) {
                    if (!_isTypeParam(_x._typ)) {
                        _errOp = _y;
                    };
                    _cause = _check._sprintf(("type parameter %s is not comparable with %s" : GoString), Go.toInterface(_errOp._typ), Go.toInterface(Go.asInterface(_op)));
                } else {
                    _cause = _check._sprintf(("operator %s not defined on %s" : GoString), Go.toInterface(Go.asInterface(_op)), Go.toInterface(_check._kindString(_errOp._typ)));
                };
            };
            if (_switchCase) {
                _check._errorf(Go.asInterface(_x), _code, ("invalid case %s in switch on %s (%s)" : GoString), Go.toInterface(_x._expr), Go.toInterface(_y._expr), Go.toInterface(_cause));
            } else {
                _check._errorf(Go.asInterface(_errOp), _code, ("invalid operation: %s %s %s (%s)" : GoString), Go.toInterface(_x._expr), Go.toInterface(Go.asInterface(_op)), Go.toInterface(_y._expr), Go.toInterface(_cause));
            };
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
        });
    }
    /**
        // implicitTypeAndValue returns the implicit type of x when used in a context
        // where the target type is expected. If no such implicit conversion is
        // possible, it returns a nil Type and non-zero error code.
        //
        // If x is a constant operand, the returned constant.Value will be the
        // representation of x in this context.
    **/
    @:keep
    static public function _implicitTypeAndValue( _check:Ref<Checker>, _x:Ref<T_operand>, _target:Type):{ var _0 : Type; var _1 : stdgo.go.constant.Constant.Value; var _2 : Code; } {
        if (((_x._mode == (0 : stdgo.go.types.Types.T_operandMode)) || _isTyped(_x._typ)) || (Go.toInterface(_target) == Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
            return { _0 : _x._typ, _1 : (null : stdgo.go.constant.Constant.Value), _2 : (0 : stdgo.internal.types.errors.Errors.Code) };
        };
        if (_isUntyped(_target)) {
            var _xkind:stdgo.go.types.Types.BasicKind = (Go.typeAssert((Go.toInterface(_x._typ) : Ref<Basic>)) : Ref<Basic>)._kind;
            var _tkind:stdgo.go.types.Types.BasicKind = (Go.typeAssert((Go.toInterface(_target) : Ref<Basic>)) : Ref<Basic>)._kind;
            if (_isNumeric(_x._typ) && _isNumeric(_target)) {
                if (_xkind < _tkind) {
                    return { _0 : _target, _1 : (null : stdgo.go.constant.Constant.Value), _2 : (0 : stdgo.internal.types.errors.Errors.Code) };
                };
            } else if (_xkind != (_tkind)) {
                return { _0 : (null : stdgo.go.types.Types.Type), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (97 : stdgo.internal.types.errors.Errors.Code) };
            };
            return { _0 : _x._typ, _1 : (null : stdgo.go.constant.Constant.Value), _2 : (0 : stdgo.internal.types.errors.Errors.Code) };
        };
        {
            final __type__ = _under(_target);
            {
                var __bool__ = true;
                while (__bool__) {
                    __bool__ = false;
                    if (Go.typeEquals((__type__ : Ref<Basic>))) {
                        var _u:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                        if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
                            var __tmp__ = _check._representation(_x, _u), _v:stdgo.go.constant.Constant.Value = __tmp__._0, _code:stdgo.internal.types.errors.Errors.Code = __tmp__._1;
                            if (_code != ((0 : stdgo.internal.types.errors.Errors.Code))) {
                                return { _0 : (null : stdgo.go.types.Types.Type), _1 : (null : stdgo.go.constant.Constant.Value), _2 : _code };
                            };
                            return { _0 : _target, _1 : _v, _2 : _code };
                        };
                        {
                            final __value__ = (Go.typeAssert((Go.toInterface(_x._typ) : Ref<Basic>)) : Ref<Basic>)._kind;
                            if (__value__ == ((19 : stdgo.go.types.Types.BasicKind))) {
                                if (!_isBoolean(_target)) {
                                    return { _0 : (null : stdgo.go.types.Types.Type), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (97 : stdgo.internal.types.errors.Errors.Code) };
                                };
                            } else if (__value__ == ((20 : stdgo.go.types.Types.BasicKind)) || __value__ == ((21 : stdgo.go.types.Types.BasicKind)) || __value__ == ((22 : stdgo.go.types.Types.BasicKind)) || __value__ == ((23 : stdgo.go.types.Types.BasicKind))) {
                                if (!_isNumeric(_target)) {
                                    return { _0 : (null : stdgo.go.types.Types.Type), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (97 : stdgo.internal.types.errors.Errors.Code) };
                                };
                            } else if (__value__ == ((24 : stdgo.go.types.Types.BasicKind))) {
                                if (!_isString(_target)) {
                                    return { _0 : (null : stdgo.go.types.Types.Type), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (97 : stdgo.internal.types.errors.Errors.Code) };
                                };
                            } else if (__value__ == ((25 : stdgo.go.types.Types.BasicKind))) {
                                if (!_hasNil(_target)) {
                                    return { _0 : (null : stdgo.go.types.Types.Type), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (97 : stdgo.internal.types.errors.Errors.Code) };
                                };
                                return { _0 : Go.asInterface(typ[((25 : stdgo.go.types.Types.BasicKind) : GoInt)]), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (0 : stdgo.internal.types.errors.Errors.Code) };
                            } else {
                                return { _0 : (null : stdgo.go.types.Types.Type), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (97 : stdgo.internal.types.errors.Errors.Code) };
                            };
                        };
                    } else if (Go.typeEquals((__type__ : Ref<Interface>))) {
                        var _u:Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                        if (_isTypeParam(_target)) {
                            if (!_u._typeSet()._underIs(function(_u:Type):Bool {
                                if (_u == null) {
                                    return false;
                                };
                                var __tmp__ = _check._implicitTypeAndValue(_x, _u), _t:stdgo.go.types.Types.Type = __tmp__._0, __0:stdgo.go.constant.Constant.Value = __tmp__._1, __1:stdgo.internal.types.errors.Errors.Code = __tmp__._2;
                                return _t != null;
                            })) {
                                return { _0 : (null : stdgo.go.types.Types.Type), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (97 : stdgo.internal.types.errors.Errors.Code) };
                            };
                            if (_x._isNil()) {
                                return { _0 : Go.asInterface(typ[((25 : stdgo.go.types.Types.BasicKind) : GoInt)]), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (0 : stdgo.internal.types.errors.Errors.Code) };
                            };
                            break;
                        };
                        if (_x._isNil()) {
                            return { _0 : Go.asInterface(typ[((25 : stdgo.go.types.Types.BasicKind) : GoInt)]), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (0 : stdgo.internal.types.errors.Errors.Code) };
                        };
                        if (!_u.empty()) {
                            return { _0 : (null : stdgo.go.types.Types.Type), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (97 : stdgo.internal.types.errors.Errors.Code) };
                        };
                        return { _0 : default_(_x._typ), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (0 : stdgo.internal.types.errors.Errors.Code) };
                    } else if (Go.typeEquals((__type__ : Ref<Pointer_>)) || Go.typeEquals((__type__ : Ref<Signature>)) || Go.typeEquals((__type__ : Ref<Slice_>)) || Go.typeEquals((__type__ : Ref<Map_>)) || Go.typeEquals((__type__ : Ref<Chan>))) {
                        var _u:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                        if (!_x._isNil()) {
                            return { _0 : (null : stdgo.go.types.Types.Type), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (97 : stdgo.internal.types.errors.Errors.Code) };
                        };
                        return { _0 : Go.asInterface(typ[((25 : stdgo.go.types.Types.BasicKind) : GoInt)]), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (0 : stdgo.internal.types.errors.Errors.Code) };
                    } else {
                        var _u:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                        return { _0 : (null : stdgo.go.types.Types.Type), _1 : (null : stdgo.go.constant.Constant.Value), _2 : (97 : stdgo.internal.types.errors.Errors.Code) };
                    };
                    break;
                };
            };
        };
        return { _0 : _target, _1 : (null : stdgo.go.constant.Constant.Value), _2 : (0 : stdgo.internal.types.errors.Errors.Code) };
    }
    /**
        // convertUntyped attempts to set the type of an untyped value to the target type.
    **/
    @:keep
    static public function _convertUntyped( _check:Ref<Checker>, _x:Ref<T_operand>, _target:Type):Void {
        var __tmp__ = _check._implicitTypeAndValue(_x, _target), _newType:stdgo.go.types.Types.Type = __tmp__._0, _val:stdgo.go.constant.Constant.Value = __tmp__._1, _code:stdgo.internal.types.errors.Errors.Code = __tmp__._2;
        if (_code != ((0 : stdgo.internal.types.errors.Errors.Code))) {
            var _t:stdgo.go.types.Types.Type = _target;
            if (!_isTypeParam(_target)) {
                _t = _safeUnderlying(_target);
            };
            _check._invalidConversion(_code, _x, _t);
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            return;
        };
        if (_val != null) {
            _x._val = _val;
            _check._updateExprVal(_x._expr, _val);
        };
        if (Go.toInterface(_newType) != (Go.toInterface(_x._typ))) {
            _x._typ = _newType;
            _check._updateExprType(_x._expr, _newType, false);
        };
    }
    /**
        // updateExprVal updates the value of x to val.
    **/
    @:keep
    static public function _updateExprVal( _check:Ref<Checker>, _x:stdgo.go.ast.Ast.Expr, _val:stdgo.go.constant.Constant.Value):Void {
        {
            var __tmp__ = (_check._untyped != null && _check._untyped.exists(_x) ? { value : _check._untyped[_x], ok : true } : { value : ({} : stdgo.go.types.Types.T_exprInfo), ok : false }), _info:stdgo.go.types.Types.T_exprInfo = __tmp__.value, _ok:Bool = __tmp__.ok;
            if (_ok) {
                _info._val = _val;
                _check._untyped[_x] = _info?.__copy__();
            };
        };
    }
    @:keep
    static public function _updateExprType0( _check:Ref<Checker>, _parent:stdgo.go.ast.Ast.Expr, _x:stdgo.go.ast.Ast.Expr, _typ:Type, _final:Bool):Void {
        var __tmp__ = (_check._untyped != null && _check._untyped.exists(_x) ? { value : _check._untyped[_x], ok : true } : { value : ({} : stdgo.go.types.Types.T_exprInfo), ok : false }), _old:stdgo.go.types.Types.T_exprInfo = __tmp__.value, _found:Bool = __tmp__.ok;
        if (!_found) {
            return;
        };
        {
            final __type__ = _x;
            {
                var __bool__ = true;
                while (__bool__) {
                    __bool__ = false;
                    if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BadExpr>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.FuncLit>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CompositeLit>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexExpr>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SliceExpr>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.TypeAssertExpr>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.StarExpr>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.KeyValueExpr>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ArrayType>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.StructType>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.FuncType>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.InterfaceType>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.MapType>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ChanType>))) {
                        var _x:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                        if (false) {
                            _check._dump(("%v: found old type(%s): %s (new: %s)" : GoString), Go.toInterface(Go.asInterface(_x.pos())), Go.toInterface(_x), Go.toInterface(Go.asInterface(_old._typ)), Go.toInterface(_typ));
                            _unreachable();
                        };
                        return;
                    } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.CallExpr>))) {
                        var _x:Ref<stdgo.go.ast.Ast.CallExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CallExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.CallExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.CallExpr>) : __type__.__underlying__().value;
                    } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ident>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BasicLit>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectorExpr>))) {
                        var _x:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                    } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ParenExpr>))) {
                        var _x:Ref<stdgo.go.ast.Ast.ParenExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__().value;
                        _check._updateExprType0(Go.asInterface(_x), _x.x, _typ, _final);
                    } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.UnaryExpr>))) {
                        var _x:Ref<stdgo.go.ast.Ast.UnaryExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__().value;
                        if (_old._val != null) {
                            break;
                        };
                        _check._updateExprType0(Go.asInterface(_x), _x.x, _typ, _final);
                    } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BinaryExpr>))) {
                        var _x:Ref<stdgo.go.ast.Ast.BinaryExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__().value;
                        if (_old._val != null) {
                            break;
                        };
                        if (_isComparison(_x.op)) {} else if (_isShift(_x.op)) {
                            _check._updateExprType0(Go.asInterface(_x), _x.x, _typ, _final);
                        } else {
                            _check._updateExprType0(Go.asInterface(_x), _x.x, _typ, _final);
                            _check._updateExprType0(Go.asInterface(_x), _x.y, _typ, _final);
                        };
                    } else {
                        var _x:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                        _unreachable();
                    };
                    break;
                };
            };
        };
        if (!_final && _isUntyped(_typ)) {
            _old._typ = (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Basic>)) : Ref<Basic>);
            _check._untyped[_x] = _old?.__copy__();
            return;
        };
        if (_check._untyped != null) _check._untyped.remove(_x);
        if (_old._isLhs) {
            if (!_allInteger(_typ)) {
                _check._errorf(_x, (57 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: shifted operand %s (type %s) must be integer" : GoString), Go.toInterface(_x), Go.toInterface(_typ));
                return;
            };
        };
        if (_old._val != null) {
            var _c:stdgo.go.types.Types.T_operand = (new T_operand(_old._mode, _x, Go.asInterface(_old._typ), _old._val, (0 : stdgo.go.types.Types.T_builtinId)) : T_operand);
            _check._convertUntyped((Go.setRef(_c) : Ref<stdgo.go.types.Types.T_operand>), _typ);
            if (_c._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                return;
            };
        };
        _check._recordTypeAndValue(_x, _old._mode, _typ, _old._val);
    }
    /**
        // updateExprType updates the type of x to typ and invokes itself
        // recursively for the operands of x, depending on expression kind.
        // If typ is still an untyped and not the final type, updateExprType
        // only updates the recorded untyped type for x and possibly its
        // operands. Otherwise (i.e., typ is not an untyped type anymore,
        // or it is the final type for x), the type and value are recorded.
        // Also, if x is a constant, it must be representable as a value of typ,
        // and if x is the (formerly untyped) lhs operand of a non-constant
        // shift, it must be an integer value.
    **/
    @:keep
    static public function _updateExprType( _check:Ref<Checker>, _x:stdgo.go.ast.Ast.Expr, _typ:Type, _final:Bool):Void {
        _check._updateExprType0((null : stdgo.go.ast.Ast.Expr), _x, _typ, _final);
    }
    @:keep
    static public function _invalidConversion( _check:Ref<Checker>, _code:Code, _x:Ref<T_operand>, _target:Type):Void {
        var _msg:GoString = ("cannot convert %s to type %s" : GoString);
        {
            final __value__ = _code;
            if (__value__ == ((43 : stdgo.internal.types.errors.Errors.Code))) {
                _msg = ("%s truncated to %s" : GoString);
            } else if (__value__ == ((44 : stdgo.internal.types.errors.Errors.Code))) {
                _msg = ("%s overflows %s" : GoString);
            };
        };
        _check._errorf(Go.asInterface(_x), _code, _msg, Go.toInterface(Go.asInterface(_x)), Go.toInterface(_target));
    }
    /**
        // representation returns the representation of the constant operand x as the
        // basic type typ.
        //
        // If no such representation is possible, it returns a non-zero error code.
    **/
    @:keep
    static public function _representation( _check:Ref<Checker>, _x:Ref<T_operand>, _typ:Ref<Basic>):{ var _0 : stdgo.go.constant.Constant.Value; var _1 : Code; } {
        _assert(_x._mode == ((4 : stdgo.go.types.Types.T_operandMode)));
        var _v:stdgo.go.constant.Constant.Value = _x._val;
        if (!_representableConst(_x._val, _check, _typ, (Go.setRef(_v) : Ref<stdgo.go.constant.Constant.Value>))) {
            if (_isNumeric(_x._typ) && _isNumeric(Go.asInterface(_typ))) {
                if (!_isInteger(_x._typ) && _isInteger(Go.asInterface(_typ))) {
                    return { _0 : (null : stdgo.go.constant.Constant.Value), _1 : (43 : stdgo.internal.types.errors.Errors.Code) };
                } else {
                    return { _0 : (null : stdgo.go.constant.Constant.Value), _1 : (44 : stdgo.internal.types.errors.Errors.Code) };
                };
            };
            return { _0 : (null : stdgo.go.constant.Constant.Value), _1 : (14 : stdgo.internal.types.errors.Errors.Code) };
        };
        return { _0 : _v, _1 : (0 : stdgo.internal.types.errors.Errors.Code) };
    }
    /**
        // representable checks that a constant operand is representable in the given
        // basic type.
    **/
    @:keep
    static public function _representable( _check:Ref<Checker>, _x:Ref<T_operand>, _typ:Ref<Basic>):Void {
        var __tmp__ = _check._representation(_x, _typ), _v:stdgo.go.constant.Constant.Value = __tmp__._0, _code:stdgo.internal.types.errors.Errors.Code = __tmp__._1;
        if (_code != ((0 : stdgo.internal.types.errors.Errors.Code))) {
            _check._invalidConversion(_code, _x, Go.asInterface(_typ));
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            return;
        };
        _assert(_v != null);
        _x._val = _v;
    }
    /**
        // The unary expression e may be nil. It's passed in for better error messages only.
    **/
    @:keep
    static public function _unary( _check:Ref<Checker>, _x:Ref<T_operand>, _e:Ref<stdgo.go.ast.Ast.UnaryExpr>):Void {
        _check._expr(_x, _e.x);
        if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
            return;
        };
        {
            final __value__ = _e.op;
            if (__value__ == ((17 : stdgo.go.token.Token.Token))) {
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_unparen(_e.x)) : Ref<stdgo.go.ast.Ast.CompositeLit>)) : Ref<stdgo.go.ast.Ast.CompositeLit>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.ast.Ast.CompositeLit>), ok : false };
                    }, __0 = __tmp__.value, _ok = __tmp__.ok;
                    if (!_ok && (_x._mode != (5 : stdgo.go.types.Types.T_operandMode))) {
                        _check._errorf(Go.asInterface(_x), (49 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot take address of %s" : GoString), Go.toInterface(Go.asInterface(_x)));
                        _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                        return;
                    };
                };
                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                _x._typ = Go.asInterface((Go.setRef(({ _base : _x._typ } : Pointer_)) : Ref<stdgo.go.types.Types.Pointer_>));
                return;
            } else if (__value__ == ((36 : stdgo.go.token.Token.Token))) {
                var _u:stdgo.go.types.Types.Type = _coreType(_x._typ);
                if (_u == null) {
                    _check._errorf(Go.asInterface(_x), (58 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot receive from %s (no core type)" : GoString), Go.toInterface(Go.asInterface(_x)));
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                    return;
                };
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_u) : Ref<Chan>)) : Ref<Chan>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.Chan>), ok : false };
                }, _ch = __tmp__.value, __1 = __tmp__.ok;
                if (_ch == null || (_ch : Dynamic).__nil__) {
                    _check._errorf(Go.asInterface(_x), (58 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot receive from non-channel %s" : GoString), Go.toInterface(Go.asInterface(_x)));
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                    return;
                };
                if (_ch._dir == ((1 : stdgo.go.types.Types.ChanDir))) {
                    _check._errorf(Go.asInterface(_x), (58 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot receive from send-only channel %s" : GoString), Go.toInterface(Go.asInterface(_x)));
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                    return;
                };
                _x._mode = (8 : stdgo.go.types.Types.T_operandMode);
                _x._typ = _ch._elem;
                _check._environment._hasCallOrRecv = true;
                return;
            } else if (__value__ == ((88 : stdgo.go.token.Token.Token))) {
                _check._error(Go.asInterface(_e), (45 : stdgo.internal.types.errors.Errors.Code), ("cannot use ~ outside of interface or type constraint" : GoString));
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                return;
            };
        };
        if (!_check._op(_unaryOpPredicates, _x, _e.op)) {
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            return;
        };
        if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
            if (_x._val.kind() == ((0 : stdgo.go.constant.Constant.Kind))) {
                return;
            };
            var _prec:GoUInt = (0 : GoUInt);
            if (_isUnsigned(_x._typ)) {
                _prec = (_check._conf._sizeof(_x._typ) * (8i64 : GoInt64) : GoUInt);
            };
            _x._val = stdgo.go.constant.Constant.unaryOp(_e.op, _x._val, _prec);
            _x._expr = Go.asInterface(_e);
            _check._overflow(_x, _x.pos());
            return;
        };
        _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
    }
    /**
        // overflow checks that the constant x is representable by its type.
        // For untyped constants, it checks that the value doesn't become
        // arbitrarily large.
    **/
    @:keep
    static public function _overflow( _check:Ref<Checker>, _x:Ref<T_operand>, _opPos:stdgo.go.token.Token.Pos):Void {
        _assert(_x._mode == ((4 : stdgo.go.types.Types.T_operandMode)));
        if (_x._val.kind() == ((0 : stdgo.go.constant.Constant.Kind))) {
            _check._error(Go.asInterface((_opPos : T_atPos)), (14 : stdgo.internal.types.errors.Errors.Code), ("constant result is not representable" : GoString));
            return;
        };
        if (_isTyped(_x._typ)) {
            _check._representable(_x, (Go.typeAssert((Go.toInterface(_under(_x._typ)) : Ref<Basic>)) : Ref<Basic>));
            return;
        };
        {};
        if ((_x._val.kind() == (3 : stdgo.go.constant.Constant.Kind)) && (stdgo.go.constant.Constant.bitLen(_x._val) > (512 : GoInt))) {
            var _op:GoString = _opName(_x._expr);
            if (_op != (Go.str())) {
                _op = _op + ((" " : GoString));
            };
            _check._errorf(Go.asInterface((_opPos : T_atPos)), (14 : stdgo.internal.types.errors.Errors.Code), ("constant %soverflow" : GoString), Go.toInterface(_op));
            _x._val = stdgo.go.constant.Constant.makeUnknown();
        };
    }
    @:keep
    static public function _op( _check:Ref<Checker>, _m:T_opPredicates, _x:Ref<T_operand>, _op:stdgo.go.token.Token.Token):Bool {
        {
            var _pred:stdgo.go.types.Types.Type -> Bool = _m[_op];
            if (_pred != null) {
                if (!_pred(_x._typ)) {
                    _check._errorf(Go.asInterface(_x), (45 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: operator %s not defined on %s" : GoString), Go.toInterface(Go.asInterface(_op)), Go.toInterface(Go.asInterface(_x)));
                    return false;
                };
            } else {
                _check._errorf(Go.asInterface(_x), (-1 : stdgo.internal.types.errors.Errors.Code), ("unknown operator %s" : GoString), Go.toInterface(Go.asInterface(_op)));
                return false;
            };
        };
        return true;
    }
    @:keep
    static public function _versionErrorf( _check:Ref<Checker>, _at:T_positioner, _goVersion:GoString, _format:GoString, _args:haxe.Rest<AnyInterface>):Void {
        var _args = new Slice<AnyInterface>(_args.length, 0, ..._args);
        var _msg:GoString = _check._sprintf(_format, ..._args.__toArray__());
        var _err:Ref<T_error_> = (null : Ref<stdgo.go.types.Types.T_error_>);
        _err = _newErrorf(_at, (135 : stdgo.internal.types.errors.Errors.Code), ("%s requires %s or later" : GoString), Go.toInterface(_msg), Go.toInterface(_goVersion));
        _check._report(_err);
    }
    @:keep
    static public function _softErrorf( _check:Ref<Checker>, _at:T_positioner, _code:Code, _format:GoString, _args:haxe.Rest<AnyInterface>):Void {
        var _args = new Slice<AnyInterface>(_args.length, 0, ..._args);
        var _err = _newErrorf(_at, _code, _format, ..._args.__toArray__());
        _err._soft = true;
        _check._report(_err);
    }
    @:keep
    static public function _errorf( _check:Ref<Checker>, _at:T_positioner, _code:Code, _format:GoString, _args:haxe.Rest<AnyInterface>):Void {
        var _args = new Slice<AnyInterface>(_args.length, 0, ..._args);
        _check._report(_newErrorf(_at, _code, _format, ..._args.__toArray__()));
    }
    @:keep
    static public function _error( _check:Ref<Checker>, _at:T_positioner, _code:Code, _msg:GoString):Void {
        _check._report(_newErrorf(_at, _code, _msg));
    }
    /**
        // Report records the error pointed to by errp, setting check.firstError if
        // necessary.
    **/
    @:keep
    static public function _report( _check:Ref<Checker>, _errp:Ref<T_error_>):Void {
        if (_errp._empty()) {
            throw Go.toInterface(("empty error details" : GoString));
        };
        var _msg:GoString = _errp._msg(_check._fset, _check._qualifier);
        {
            final __value__ = _errp._code;
            if (__value__ == ((-1 : stdgo.internal.types.errors.Errors.Code))) {
                _msg = ("invalid AST: " : GoString) + _msg;
            } else if (__value__ == ((0 : stdgo.internal.types.errors.Errors.Code))) {
                throw Go.toInterface(("no error code provided" : GoString));
            };
        };
        var _span:stdgo.go.types.Types.T_posSpan = _spanOf(_errp._desc[(0 : GoInt)]._posn)?.__copy__();
        var _e:stdgo.go.types.Types.T_error = ({ fset : _check._fset, pos : _span._pos, msg : _msg, soft : _errp._soft, _go116code : _errp._code, _go116start : _span._start, _go116end : _span._end } : T_error);
        var _isInvalidErr:Bool = (stdgo.strings.Strings.index(_e.msg, ("invalid operand" : GoString)) > (0 : GoInt)) || (stdgo.strings.Strings.index(_e.msg, ("invalid type" : GoString)) > (0 : GoInt));
        if ((_check._firstErr != null) && _isInvalidErr) {
            return;
        };
        _e.msg = _stripAnnotations(_e.msg);
        if (_check._environment._errpos != null) {
            var _span:stdgo.go.types.Types.T_posSpan = _spanOf(_check._environment._errpos)?.__copy__();
            _e.pos = _span._pos;
            _e._go116start = _span._start;
            _e._go116end = _span._end;
        };
        var _err:stdgo.go.types.Types.T_error = _e?.__copy__();
        if (_check._firstErr == null) {
            _check._firstErr = Go.asInterface(_err);
        };
        if (false) {
            var _pos:stdgo.go.token.Token.Pos = _e.pos;
            var _msg:GoString = _e.msg;
            _check._trace(_pos, ("ERROR: %s" : GoString), Go.toInterface(_msg));
        };
        var _f:Error -> Void = _check._conf.error;
        if (_f == null) {
            throw Go.toInterface((new T_bailout() : T_bailout));
        };
        _f(Go.asInterface(_err));
    }
    /**
        // dump is only needed for debugging
    **/
    @:keep
    static public function _dump( _check:Ref<Checker>, _format:GoString, _args:haxe.Rest<AnyInterface>):Void {
        var _args = new Slice<AnyInterface>(_args.length, 0, ..._args);
        stdgo.fmt.Fmt.println(Go.toInterface(stdgo.go.types.Types._sprintf(_check._fset, _check._qualifier, true, _format, ..._args.__toArray__())));
    }
    @:keep
    static public function _trace( _check:Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _format:GoString, _args:haxe.Rest<AnyInterface>):Void {
        var _args = new Slice<AnyInterface>(_args.length, 0, ..._args);
        stdgo.fmt.Fmt.printf(("%s:\t%s%s\n" : GoString), Go.toInterface(Go.asInterface(_check._fset.position(_pos))), Go.toInterface(stdgo.strings.Strings.repeat((".  " : GoString), _check._indent)), Go.toInterface(stdgo.go.types.Types._sprintf(_check._fset, _check._qualifier, true, _format, ..._args.__toArray__())));
    }
    /**
        // check may be nil.
    **/
    @:keep
    static public function _sprintf( _check:Ref<Checker>, _format:GoString, _args:haxe.Rest<AnyInterface>):GoString {
        var _args = new Slice<AnyInterface>(_args.length, 0, ..._args);
        var _fset:Ref<stdgo.go.token.Token.FileSet> = (null : Ref<stdgo.go.token.Token.FileSet>);
        var _qf:Qualifier = (null : stdgo.go.types.Types.Qualifier);
        if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
            _fset = _check._fset;
            _qf = _check._qualifier;
        };
        return stdgo.go.types.Types._sprintf(_fset, _qf, false, _format, ..._args.__toArray__());
    }
    /**
        // markImports recursively walks pkg and its imports, to record unique import
        // paths in pkgPathMap.
    **/
    @:keep
    static public function _markImports( _check:Ref<Checker>, _pkg:Ref<Package>):Void {
        if (_check._seenPkgMap[_pkg]) {
            return;
        };
        _check._seenPkgMap[_pkg] = true;
        var __tmp__ = (_check._pkgPathMap != null && _check._pkgPathMap.exists(_pkg._name) ? { value : _check._pkgPathMap[_pkg._name], ok : true } : { value : (null : GoMap<GoString, Bool>), ok : false }), _forName:GoMap<GoString, Bool> = __tmp__.value, _ok:Bool = __tmp__.ok;
        if (!_ok) {
            _forName = ({
                final x = new stdgo.GoMap.GoStringMap<Bool>();
                x.__defaultValue__ = () -> false;
                @:mergeBlock {};
                x;
            } : GoMap<GoString, Bool>);
            _check._pkgPathMap[_pkg._name] = _forName;
        };
        _forName[_pkg._path] = true;
        for (__40 => _imp in _pkg._imports) {
            _check._markImports(_imp);
        };
    }
    @:keep
    static public function _qualifier( _check:Ref<Checker>, _pkg:Ref<Package>):GoString {
        if (_pkg != (_check._pkg)) {
            if (_check._pkgPathMap == null) {
                _check._pkgPathMap = ({
                    final x = new stdgo.GoMap.GoStringMap<GoMap<GoString, Bool>>();
                    x.__defaultValue__ = () -> (null : GoMap<GoString, Bool>);
                    @:mergeBlock {};
                    x;
                } : GoMap<GoString, GoMap<GoString, Bool>>);
                _check._seenPkgMap = ({
                    final x = new GoRefMap<Ref<stdgo.go.types.Types.Package>, Bool>();
                    @:mergeBlock {};
                    cast x;
                } : GoMap<Ref<stdgo.go.types.Types.Package>, Bool>);
                _check._markImports(_check._pkg);
            };
            if ((_check._pkgPathMap[_pkg._name].length) > (1 : GoInt)) {
                return stdgo.strconv.Strconv.quote(_pkg._path);
            };
            return _pkg._name;
        };
        return Go.str();
    }
    @:keep
    static public function _declStmt( _check:Ref<Checker>, _d:stdgo.go.ast.Ast.Decl):Void {
        var _pkg = _check._pkg;
        _check._walkDecl(_d, function(_d:T_decl):Void {
            {
                final __type__ = _d;
                {
                    var __bool__ = true;
                    while (__bool__) {
                        __bool__ = false;
                        if (Go.typeEquals((__type__ : T_constDecl))) {
                            var _d:stdgo.go.types.Types.T_constDecl = __type__ == null ? ({} : stdgo.go.types.Types.T_constDecl) : __type__.__underlying__() == null ? ({} : stdgo.go.types.Types.T_constDecl) : __type__ == null ? ({} : stdgo.go.types.Types.T_constDecl) : __type__.__underlying__().value;
                            var _top:GoInt = (_check._delayed.length);
                            var _lhs = new Slice<Ref<stdgo.go.types.Types.Const>>((_d._spec.names.length : GoInt).toBasic(), 0);
                            for (_i => _name in _d._spec.names) {
                                var _obj = newConst(_name.pos(), _pkg, _name.name, (null : stdgo.go.types.Types.Type), stdgo.go.constant.Constant.makeInt64((_d._iota : GoInt64)));
                                _lhs[(_i : GoInt)] = _obj;
                                var _init:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
                                if (_i < (_d._init.length)) {
                                    _init = _d._init[(_i : GoInt)];
                                };
                                _check._constDecl(_obj, _d._typ, _init, _d._inherited);
                            };
                            _check._processDelayed(_top);
                            var _scopePos:stdgo.go.token.Token.Pos = _d._spec.end();
                            for (_i => _name in _d._spec.names) {
                                _check._declare(_check._pkg._scope, _name, Go.asInterface(_lhs[(_i : GoInt)]), _scopePos);
                            };
                        } else if (Go.typeEquals((__type__ : T_varDecl))) {
                            var _d:stdgo.go.types.Types.T_varDecl = __type__ == null ? ({} : stdgo.go.types.Types.T_varDecl) : __type__.__underlying__() == null ? ({} : stdgo.go.types.Types.T_varDecl) : __type__ == null ? ({} : stdgo.go.types.Types.T_varDecl) : __type__.__underlying__().value;
                            var _top:GoInt = (_check._delayed.length);
                            var _lhs0 = new Slice<Ref<stdgo.go.types.Types.Var>>((_d._spec.names.length : GoInt).toBasic(), 0);
                            for (_i => _name in _d._spec.names) {
                                _lhs0[(_i : GoInt)] = newVar(_name.pos(), _pkg, _name.name, (null : stdgo.go.types.Types.Type));
                            };
                            for (_i => _obj in _lhs0) {
                                var _lhs:Slice<Ref<Var>> = (null : Slice<Ref<stdgo.go.types.Types.Var>>);
                                var _init:stdgo.go.ast.Ast.Expr = (null : stdgo.go.ast.Ast.Expr);
                                {
                                    final __value__ = (_d._spec.values.length);
                                    if (__value__ == ((_d._spec.names.length))) {
                                        _init = _d._spec.values[(_i : GoInt)];
                                    } else if (__value__ == ((1 : GoInt))) {
                                        _lhs = _lhs0;
                                        _init = _d._spec.values[(0 : GoInt)];
                                    } else {
                                        if (_i < (_d._spec.values.length)) {
                                            _init = _d._spec.values[(_i : GoInt)];
                                        };
                                    };
                                };
                                _check._varDecl(_obj, _lhs, _d._spec.type, _init);
                                if ((_d._spec.values.length) == ((1 : GoInt))) {
                                    if (false) {
                                        for (__24 => _obj in _lhs0) {
                                            _assert(_obj._object._typ != null);
                                        };
                                    };
                                    break;
                                };
                            };
                            _check._processDelayed(_top);
                            var _scopePos:stdgo.go.token.Token.Pos = _d._spec.end();
                            for (_i => _name in _d._spec.names) {
                                _check._declare(_check._pkg._scope, _name, Go.asInterface(_lhs0[(_i : GoInt)]), _scopePos);
                            };
                        } else if (Go.typeEquals((__type__ : T_typeDecl))) {
                            var _d:stdgo.go.types.Types.T_typeDecl = __type__ == null ? ({} : stdgo.go.types.Types.T_typeDecl) : __type__.__underlying__() == null ? ({} : stdgo.go.types.Types.T_typeDecl) : __type__ == null ? ({} : stdgo.go.types.Types.T_typeDecl) : __type__.__underlying__().value;
                            var _obj = newTypeName(_d._spec.name.pos(), _pkg, _d._spec.name.name, (null : stdgo.go.types.Types.Type));
                            var _scopePos:stdgo.go.token.Token.Pos = _d._spec.name.pos();
                            _check._declare(_check._pkg._scope, _d._spec.name, Go.asInterface(_obj), _scopePos);
                            _obj._setColor((2u32 : stdgo.go.types.Types.T_color) + (_check._push(Go.asInterface(_obj)) : T_color));
                            _check._typeDecl(_obj, _d._spec, null);
                            _check._pop()._setColor((1u32 : stdgo.go.types.Types.T_color));
                        } else {
                            var _d:stdgo.go.types.Types.T_decl = __type__ == null ? (null : stdgo.go.types.Types.T_decl) : cast __type__;
                            _check._errorf(_d._node(), (-1 : stdgo.internal.types.errors.Errors.Code), ("unknown ast.Decl node %T" : GoString), Go.toInterface(_d._node()));
                        };
                        break;
                    };
                };
            };
        });
    }
    @:keep
    static public function _funcDecl( _check:Ref<Checker>, _obj:Ref<Func>, _decl:Ref<T_declInfo>):Void {
        _assert(_obj._object._typ == null);
        _assert(_check._environment._iota == null);
        var _sig = (Go.setRef(({} : stdgo.go.types.Types.Signature)) : Ref<stdgo.go.types.Types.Signature>);
        _obj._object._typ = Go.asInterface(_sig);
        var _saved:stdgo.go.types.Types.T_color = _obj._object._color_;
        _obj._object._color_ = (1u32 : stdgo.go.types.Types.T_color);
        var _fdecl = _decl._fdecl;
        _check._funcType(_sig, _fdecl.recv, _fdecl.type);
        _obj._object._color_ = _saved;
        if ((_fdecl.type.typeParams.numFields() > (0 : GoInt)) && (_fdecl.body == null) || (_fdecl.body : Dynamic).__nil__) {
            _check._softErrorf(Go.asInterface(_fdecl.name), (131 : stdgo.internal.types.errors.Errors.Code), ("generic function is missing function body" : GoString));
        };
        if (!_check._conf.ignoreFuncBodies && ((_fdecl.body != null) && ((_fdecl.body : Dynamic).__nil__ == null || !(_fdecl.body : Dynamic).__nil__))) {
            _check._later(function():Void {
                _check._funcBody(_decl, _obj._object._name, _sig, _fdecl.body, (null : stdgo.go.constant.Constant.Value));
            })._describef(Go.asInterface(_obj), ("func %s" : GoString), Go.toInterface(_obj._object._name));
        };
    }
    @:keep
    static public function _checkFieldUniqueness( _check:Ref<Checker>, _base:Ref<Named>):Void {
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_base._under()) : Ref<Struct>)) : Ref<Struct>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Struct>), ok : false };
            }, _t = __tmp__.value, __0 = __tmp__.ok;
            if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                var _mset:T_objset = (null : stdgo.go.types.Types.T_objset);
                {
                    var _i:GoInt = (0 : GoInt);
                    Go.cfor(_i < _base.numMethods(), _i++, {
                        var _m = _base.method(_i);
                        _assert(_m._object._name != (("_" : GoString)));
                        _assert(_mset._insert(Go.asInterface(_m)) == null);
                    });
                };
                for (__1 => _fld in _t._fields) {
                    if (_fld._object._name != (("_" : GoString))) {
                        {
                            var _alt:stdgo.go.types.Types.Object = _mset._insert(Go.asInterface(_fld));
                            if (_alt != null) {
                                (Go.typeAssert((Go.toInterface(_alt) : Ref<Func>)) : Ref<Func>);
                                _check._errorf(_alt, (33 : stdgo.internal.types.errors.Errors.Code), ("field and method with the same name %s" : GoString), Go.toInterface(_fld._object._name));
                                _check._reportAltDecl(Go.asInterface(_fld));
                            };
                        };
                    };
                };
            };
        };
    }
    @:keep
    static public function _collectMethods( _check:Ref<Checker>, _obj:Ref<TypeName>):Void {
        var _methods = _check._methods[_obj];
        if (_methods == null) {
            return;
        };
        if (_check._methods != null) _check._methods.remove(_obj);
        _assert(!_check._objMap[Go.asInterface(_obj)]._tdecl.assign.isValid());
        var _mset:T_objset = (null : stdgo.go.types.Types.T_objset);
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(_obj._object._typ) : Ref<Named>)) : Ref<Named>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
        }, _base = __tmp__.value, __24 = __tmp__.ok;
        if (_base != null && ((_base : Dynamic).__nil__ == null || !(_base : Dynamic).__nil__)) {
            _assert(_base.typeArgs().len() == ((0 : GoInt)));
            _check._later(function():Void {
                _check._checkFieldUniqueness(_base);
            })._describef(Go.asInterface(_obj), ("verifying field uniqueness for %v" : GoString), Go.toInterface(Go.asInterface(_base)));
            {
                var _i:GoInt = (0 : GoInt);
                Go.cfor(_i < _base.numMethods(), _i++, {
                    var _m = _base.method(_i);
                    _assert(_m._object._name != (("_" : GoString)));
                    _assert(_mset._insert(Go.asInterface(_m)) == null);
                });
            };
        };
        for (__25 => _m in _methods) {
            _assert(_m._object._name != (("_" : GoString)));
            {
                var _alt:stdgo.go.types.Types.Object = _mset._insert(Go.asInterface(_m));
                if (_alt != null) {
                    if (_alt.pos().isValid()) {
                        _check._errorf(Go.asInterface(_m), (34 : stdgo.internal.types.errors.Errors.Code), ("method %s.%s already declared at %s" : GoString), Go.toInterface(_obj.name()), Go.toInterface(_m._object._name), Go.toInterface(Go.asInterface(_alt.pos())));
                    } else {
                        _check._errorf(Go.asInterface(_m), (34 : stdgo.internal.types.errors.Errors.Code), ("method %s.%s already declared" : GoString), Go.toInterface(_obj.name()), Go.toInterface(_m._object._name));
                    };
                    continue;
                };
            };
            if (_base != null && ((_base : Dynamic).__nil__ == null || !(_base : Dynamic).__nil__)) {
                _base.addMethod(_m);
            };
        };
    }
    @:keep
    static public function _declareTypeParams( _check:Ref<Checker>, _tparams:Slice<Ref<TypeParam>>, _names:Slice<Ref<stdgo.go.ast.Ast.Ident>>):Slice<Ref<TypeParam>> {
        for (__0 => _name in _names) {
            var _tname = newTypeName(_name.pos(), _check._pkg, _name.name, (null : stdgo.go.types.Types.Type));
            var _tpar = _check._newTypeParam(_tname, Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]));
            _check._declare(_check._pkg._scope, _name, Go.asInterface(_tname), _check._pkg._scope._pos);
            _tparams = (_tparams.__append__(_tpar));
        };
        if (false && (_names.length > (0 : GoInt))) {
            _check._trace(_names[(0 : GoInt)].pos(), ("type params = %v" : GoString), Go.toInterface((_tparams.__slice__((_tparams.length) - (_names.length)) : Slice<Ref<stdgo.go.types.Types.TypeParam>>)));
        };
        return _tparams;
    }
    @:keep
    static public function _bound( _check:Ref<Checker>, _x:stdgo.go.ast.Ast.Expr):Type {
        var _wrap:Bool = false;
        {
            final __type__ = _x;
            if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.UnaryExpr>))) {
                var _op:Ref<stdgo.go.ast.Ast.UnaryExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.UnaryExpr>) : __type__.__underlying__().value;
                _wrap = _op.op == ((88 : stdgo.go.token.Token.Token));
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BinaryExpr>))) {
                var _op:Ref<stdgo.go.ast.Ast.BinaryExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BinaryExpr>) : __type__.__underlying__().value;
                _wrap = _op.op == ((18 : stdgo.go.token.Token.Token));
            };
        };
        if (_wrap) {
            _x = Go.asInterface((Go.setRef(({ methods : (Go.setRef(({ list : (new Slice<Ref<stdgo.go.ast.Ast.Field>>(1, 1, ({ type : _x } : stdgo.go.ast.Ast.Field)) : Slice<Ref<stdgo.go.ast.Ast.Field>>) } : stdgo.go.ast.Ast.FieldList)) : Ref<stdgo.go.ast.Ast.FieldList>) } : stdgo.go.ast.Ast.InterfaceType)) : Ref<stdgo.go.ast.Ast.InterfaceType>));
            var _t:stdgo.go.types.Types.Type = _check._typ(_x);
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_t) : Ref<Interface>)) : Ref<Interface>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.Interface>), ok : false };
                }, _t = __tmp__.value, __0 = __tmp__.ok;
                if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                    _t._implicit = true;
                };
            };
            return _t;
        };
        return _check._typ(_x);
    }
    @:keep
    static public function _collectTypeParams( _check:Ref<Checker>, _dst:Ref<Ref<TypeParamList>>, _list:Ref<stdgo.go.ast.Ast.FieldList>):Void {
        var __deferstack__:Array<Void -> Void> = [];
        try {
            var _tparams:Slice<Ref<TypeParam>> = (null : Slice<Ref<stdgo.go.types.Types.TypeParam>>);
            for (__0 => _f in _list.list) {
                _tparams = _check._declareTypeParams(_tparams, _f.names);
            };
            _dst = _bindTParams(_tparams);
            _assert(!_check._environment._inTParamList);
            _check._environment._inTParamList = true;
            __deferstack__.unshift(() -> {
                var a = function():Void {
                    _check._environment._inTParamList = false;
                };
                a();
            });
            var _index:GoInt = (0 : GoInt);
            for (__17 => _f in _list.list) {
                var _bound:Type = (null : stdgo.go.types.Types.Type);
                if (_f.type != null) {
                    _bound = _check._bound(_f.type);
                    if (_isTypeParam(_bound)) {
                        _check._error(_f.type, (144 : stdgo.internal.types.errors.Errors.Code), ("cannot use a type parameter as constraint" : GoString));
                        _bound = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                    };
                } else {
                    _bound = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                };
                for (_i in 0 ... _f.names.length.toBasic()) {
                    _tparams[(_index + _i : GoInt)]._bound = _bound;
                };
                _index = _index + ((_f.names.length));
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return;
        };
    }
    @:keep
    static public function _typeDecl( _check:Ref<Checker>, _obj:Ref<TypeName>, _tdecl:Ref<stdgo.go.ast.Ast.TypeSpec>, _def:Ref<Named>):Void {
        var __deferstack__:Array<Void -> Void> = [];
        try {
            _assert(_obj._object._typ == null);
            var _rhs:Type = (null : stdgo.go.types.Types.Type);
            _check._later(function():Void {
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_obj._object._typ) : Ref<Named>)) : Ref<Named>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
                    }, _t = __tmp__.value, __0 = __tmp__.ok;
                    if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                        _check._validType(_t);
                    };
                };
                if (_check._isImportedConstraint(_rhs) && !_check._allowVersion(_check._pkg, (1 : GoInt), (18 : GoInt))) {
                    _check._errorf(_tdecl.type, (135 : stdgo.internal.types.errors.Errors.Code), ("using type constraint %s requires go1.18 or later" : GoString), Go.toInterface(_rhs));
                };
            })._describef(Go.asInterface(_obj), ("validType(%s)" : GoString), Go.toInterface(_obj.name()));
            var _alias:Bool = _tdecl.assign.isValid();
            if (_alias && (_tdecl.typeParams.numFields() != (0 : GoInt))) {
                _check._error(Go.asInterface((_tdecl.assign : T_atPos)), (131 : stdgo.internal.types.errors.Errors.Code), ("generic type cannot be alias" : GoString));
                _alias = false;
            };
            if (_alias) {
                if (!_check._allowVersion(_check._pkg, (1 : GoInt), (9 : GoInt))) {
                    _check._error(Go.asInterface((_tdecl.assign : T_atPos)), (135 : stdgo.internal.types.errors.Errors.Code), ("type aliases requires go1.9 or later" : GoString));
                };
                _check._brokenAlias(_obj);
                _rhs = _check._typ(_tdecl.type);
                _check._validAlias(_obj, _rhs);
                return;
            };
            var _named = _check._newNamed(_obj, (null : stdgo.go.types.Types.Type), (null : Slice<Ref<stdgo.go.types.Types.Func>>));
            _def._setUnderlying(Go.asInterface(_named));
            if (_tdecl.typeParams != null && ((_tdecl.typeParams : Dynamic).__nil__ == null || !(_tdecl.typeParams : Dynamic).__nil__)) {
                _check._openScope(Go.asInterface(_tdecl), ("type parameters" : GoString));
                __deferstack__.unshift(() -> _check._closeScope());
                _check._collectTypeParams((Go.setRef(_named._tparams) : Ref<Ref<stdgo.go.types.Types.TypeParamList>>), _tdecl.typeParams);
            };
            _rhs = _check._definedType(_tdecl.type, _named);
            _assert(_rhs != null);
            _named._fromRHS = _rhs;
            if (_named._underlying == null) {
                _named._underlying = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
            };
            if (_isTypeParam(_rhs)) {
                _check._error(_tdecl.type, (144 : stdgo.internal.types.errors.Errors.Code), ("cannot use a type parameter as RHS in type declaration" : GoString));
                _named._underlying = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return;
        };
    }
    /**
        // isImportedConstraint reports whether typ is an imported type constraint.
    **/
    @:keep
    static public function _isImportedConstraint( _check:Ref<Checker>, _typ:Type):Bool {
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(_typ) : Ref<Named>)) : Ref<Named>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
        }, _named = __tmp__.value, __0 = __tmp__.ok;
        if ((((_named == null) || (_named : Dynamic).__nil__) || (_named._obj._object._pkg == _check._pkg)) || ((_named._obj._object._pkg == null) || (_named._obj._object._pkg : Dynamic).__nil__)) {
            return false;
        };
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(_named._under()) : Ref<Interface>)) : Ref<Interface>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.Interface>), ok : false };
        }, _u = __tmp__.value, __25 = __tmp__.ok;
        return ((_u != null) && ((_u : Dynamic).__nil__ == null || !(_u : Dynamic).__nil__)) && !_u.isMethodSet();
    }
    @:keep
    static public function _varDecl( _check:Ref<Checker>, _obj:Ref<Var>, _lhs:Slice<Ref<Var>>, _typ:stdgo.go.ast.Ast.Expr, _init:stdgo.go.ast.Ast.Expr):Void {
        _assert(_obj._object._typ == null);
        if (_typ != null) {
            _obj._object._typ = _check._varType(_typ);
        };
        if (_init == null) {
            if (_typ == null) {
                _obj._object._typ = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
            };
            return;
        };
        if ((_lhs == null) || (_lhs.length == (1 : GoInt))) {
            _assert((_lhs == null) || (_lhs[(0 : GoInt)] == _obj));
            var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
            _check._expr((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), _init);
            _check._initVar(_obj, (Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), ("variable declaration" : GoString));
            return;
        };
        if (false) {
            var _found:Bool = false;
            for (__0 => _lhs in _lhs) {
                if (_obj == (_lhs)) {
                    _found = true;
                    break;
                };
            };
            if (!_found) {
                throw Go.toInterface(("inconsistent lhs" : GoString));
            };
        };
        if (_typ != null) {
            for (__1 => _lhs in _lhs) {
                _lhs._object._typ = _obj._object._typ;
            };
        };
        _check._initVars(_lhs, (new Slice<stdgo.go.ast.Ast.Expr>(1, 1, _init) : Slice<stdgo.go.ast.Ast.Expr>), (null : stdgo.go.ast.Ast.Stmt));
    }
    @:keep
    static public function _constDecl( _check:Ref<Checker>, _obj:Ref<Const>, _typ:stdgo.go.ast.Ast.Expr, _init:stdgo.go.ast.Ast.Expr, _inherited:Bool):Void {
        var __deferstack__:Array<Void -> Void> = [];
        try {
            _assert(_obj._object._typ == null);
            {
                var _a0 = _check._environment._iota;
                var _a1 = _check._environment._errpos;
                __deferstack__.unshift(() -> {
                    var a = function(_iota:stdgo.go.constant.Constant.Value, _errpos:T_positioner):Void {
                        _check._environment._iota = _iota;
                        _check._environment._errpos = _errpos;
                    };
                    a(_a0, _a1);
                });
            };
            _check._environment._iota = _obj._val;
            _check._environment._errpos = (null : stdgo.go.types.Types.T_positioner);
            _obj._val = stdgo.go.constant.Constant.makeUnknown();
            if (_typ != null) {
                var _t:stdgo.go.types.Types.Type = _check._typ(_typ);
                if (!_isConstType(_t)) {
                    if (Go.toInterface(_under(_t)) != (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                        _check._errorf(_typ, (15 : stdgo.internal.types.errors.Errors.Code), ("invalid constant type %s" : GoString), Go.toInterface(_t));
                    };
                    _obj._object._typ = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return;
                    };
                };
                _obj._object._typ = _t;
            };
            var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
            if (_init != null) {
                if (_inherited) {
                    _check._environment._errpos = Go.asInterface((_obj._object._pos : T_atPos));
                };
                _check._expr((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), _init);
            };
            _check._initConst(_obj, (Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>));
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return;
        };
    }
    @:keep
    static public function _walkDecl( _check:Ref<Checker>, _d:stdgo.go.ast.Ast.Decl, _f:T_decl -> Void):Void {
        {
            final __type__ = _d;
            if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.BadDecl>))) {
                var _d:Ref<stdgo.go.ast.Ast.BadDecl> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BadDecl>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.BadDecl>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.BadDecl>) : __type__.__underlying__().value;
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.GenDecl>))) {
                var _d:Ref<stdgo.go.ast.Ast.GenDecl> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.GenDecl>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.GenDecl>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.GenDecl>) : __type__.__underlying__().value;
                var _last:Ref<stdgo.go.ast.Ast.ValueSpec> = (null : Ref<stdgo.go.ast.Ast.ValueSpec>);
                for (_iota => _s in _d.specs) {
                    {
                        final __type__ = _s;
                        if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ImportSpec>))) {
                            var _s:Ref<stdgo.go.ast.Ast.ImportSpec> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ImportSpec>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ImportSpec>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ImportSpec>) : __type__.__underlying__().value;
                            _f(Go.asInterface((new T_importDecl(_s) : T_importDecl)));
                        } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ValueSpec>))) {
                            var _s:Ref<stdgo.go.ast.Ast.ValueSpec> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ValueSpec>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ValueSpec>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ValueSpec>) : __type__.__underlying__().value;
                            {
                                final __value__ = _d.tok;
                                if (__value__ == ((64 : stdgo.go.token.Token.Token))) {
                                    var _inherited:Bool = true;
                                    if ((_s.type != null) || (_s.values.length > (0 : GoInt))) {
                                        _last = _s;
                                        _inherited = false;
                                    } else if (_last == null || (_last : Dynamic).__nil__) {
                                        _last = (Go.setRef(({} : stdgo.go.ast.Ast.ValueSpec)) : Ref<stdgo.go.ast.Ast.ValueSpec>);
                                        _inherited = false;
                                    };
                                    _check._arityMatch(_s, _last);
                                    _f(Go.asInterface(({ _spec : _s, _iota : _iota, _typ : _last.type, _init : _last.values, _inherited : _inherited } : T_constDecl)));
                                } else if (__value__ == ((85 : stdgo.go.token.Token.Token))) {
                                    _check._arityMatch(_s, null);
                                    _f(Go.asInterface((new T_varDecl(_s) : T_varDecl)));
                                } else {
                                    _check._errorf(Go.asInterface(_s), (-1 : stdgo.internal.types.errors.Errors.Code), ("invalid token %s" : GoString), Go.toInterface(Go.asInterface(_d.tok)));
                                };
                            };
                        } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.TypeSpec>))) {
                            var _s:Ref<stdgo.go.ast.Ast.TypeSpec> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeSpec>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.TypeSpec>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.TypeSpec>) : __type__.__underlying__().value;
                            _f(Go.asInterface((new T_typeDecl(_s) : T_typeDecl)));
                        } else {
                            var _s:stdgo.go.ast.Ast.Spec = __type__ == null ? (null : stdgo.go.ast.Ast.Spec) : cast __type__;
                            _check._errorf(_s, (-1 : stdgo.internal.types.errors.Errors.Code), ("unknown ast.Spec node %T" : GoString), Go.toInterface(_s));
                        };
                    };
                };
            } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.FuncDecl>))) {
                var _d:Ref<stdgo.go.ast.Ast.FuncDecl> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.FuncDecl>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.FuncDecl>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.FuncDecl>) : __type__.__underlying__().value;
                _f(Go.asInterface((new T_funcDecl(_d) : T_funcDecl)));
            } else {
                var _d:stdgo.go.ast.Ast.Decl = __type__ == null ? (null : stdgo.go.ast.Ast.Decl) : cast __type__;
                _check._errorf(_d, (-1 : stdgo.internal.types.errors.Errors.Code), ("unknown ast.Decl node %T" : GoString), Go.toInterface(_d));
            };
        };
    }
    @:keep
    static public function _walkDecls( _check:Ref<Checker>, _decls:Slice<stdgo.go.ast.Ast.Decl>, _f:T_decl -> Void):Void {
        for (__0 => _d in _decls) {
            _check._walkDecl(_d, _f);
        };
    }
    /**
        // cycleError reports a declaration cycle starting with
        // the object in cycle that is "first" in the source.
    **/
    @:keep
    static public function _cycleError( _check:Ref<Checker>, _cycle:Slice<Object>):Void {
        var _name:stdgo.go.types.Types.Object -> GoString = function(_obj:Object):GoString {
            return _packagePrefix(_obj.pkg(), _check._qualifier) + _obj.name();
        };
        var _i:GoInt = _firstInSrc(_cycle);
        var _obj:stdgo.go.types.Types.Object = _cycle[(_i : GoInt)];
        var _objName:GoString = _name(_obj);
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(_obj) : Ref<TypeName>)) : Ref<TypeName>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.TypeName>), ok : false };
        }, _tname = __tmp__.value, __0 = __tmp__.ok;
        if (((_tname != null) && ((_tname : Dynamic).__nil__ == null || !(_tname : Dynamic).__nil__)) && _tname.isAlias()) {
            _check._validAlias(_tname, Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]));
        };
        if ((_cycle.length) == ((1 : GoInt))) {
            if (_tname != null && ((_tname : Dynamic).__nil__ == null || !(_tname : Dynamic).__nil__)) {
                _check._errorf(_obj, (11 : stdgo.internal.types.errors.Errors.Code), ("invalid recursive type: %s refers to itself" : GoString), Go.toInterface(_objName));
            } else {
                _check._errorf(_obj, (11 : stdgo.internal.types.errors.Errors.Code), ("invalid cycle in declaration: %s refers to itself" : GoString), Go.toInterface(_objName));
            };
            return;
        };
        if (_tname != null && ((_tname : Dynamic).__nil__ == null || !(_tname : Dynamic).__nil__)) {
            _check._errorf(_obj, (11 : stdgo.internal.types.errors.Errors.Code), ("invalid recursive type %s" : GoString), Go.toInterface(_objName));
        } else {
            _check._errorf(_obj, (11 : stdgo.internal.types.errors.Errors.Code), ("invalid cycle in declaration of %s" : GoString), Go.toInterface(_objName));
        };
        for (_ in 0 ... _cycle.length.toBasic()) {
            _check._errorf(_obj, (11 : stdgo.internal.types.errors.Errors.Code), ("\t%s refers to" : GoString), Go.toInterface(_objName));
            _i++;
            if (_i >= (_cycle.length)) {
                _i = (0 : GoInt);
            };
            _obj = _cycle[(_i : GoInt)];
            _objName = _name(_obj);
        };
        _check._errorf(_obj, (11 : stdgo.internal.types.errors.Errors.Code), ("\t%s" : GoString), Go.toInterface(_objName));
    }
    /**
        // validCycle checks if the cycle starting with obj is valid and
        // reports an error if it is not.
    **/
    @:keep
    static public function _validCycle( _check:Ref<Checker>, _obj:Object):Bool {
        stdgo.internal.Macro.controlFlow({
            var __deferstack__:Array<Void -> Void> = [];
            var _valid:Bool = false;
            try {
                if (false) {
                    var _info = _check._objMap[_obj];
                    var _inObjMap:Bool = ((_info != null) && ((_info : Dynamic).__nil__ == null || !(_info : Dynamic).__nil__)) && (((_info._fdecl == null) || (_info._fdecl : Dynamic).__nil__) || ((_info._fdecl.recv == null) || (_info._fdecl.recv : Dynamic).__nil__));
                    var _isPkgObj:Bool = _obj.parent() == (_check._pkg._scope);
                    if (_isPkgObj != (_inObjMap)) {
                        _check._dump(("%v: inconsistent object map for %s (isPkgObj = %v, inObjMap = %v)" : GoString), Go.toInterface(Go.asInterface(_obj.pos())), Go.toInterface(_obj), Go.toInterface(_isPkgObj), Go.toInterface(_inObjMap));
                        _unreachable();
                    };
                };
                _assert(_obj._color() >= (2u32 : stdgo.go.types.Types.T_color));
                var _start:stdgo.go.types.Types.T_color = _obj._color() - (2u32 : stdgo.go.types.Types.T_color);
                var _cycle = (_check._objPath.__slice__(_start) : Slice<stdgo.go.types.Types.Object>);
                var _tparCycle:Bool = false;
                var _nval:GoInt = (0 : GoInt);
                var _ndef:GoInt = (0 : GoInt);
                @:label("loop") for (__24 => _obj in _cycle) {
                    {
                        final __type__ = _obj;
                        {
                            var __bool__ = true;
                            while (__bool__) {
                                __bool__ = false;
                                if (Go.typeEquals((__type__ : Ref<Const>)) || Go.typeEquals((__type__ : Ref<Var>))) {
                                    var _obj:stdgo.go.types.Types.Object = __type__ == null ? (null : stdgo.go.types.Types.Object) : cast __type__;
                                    _nval++;
                                } else if (Go.typeEquals((__type__ : Ref<TypeName>))) {
                                    var _obj:Ref<stdgo.go.types.Types.TypeName> = __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.TypeName>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__().value;
                                    if (_check._environment._inTParamList && _isGeneric(_obj._object._typ)) {
                                        _tparCycle = true;
                                        @:jump("loop") break;
                                    };
                                    var _alias:Bool = false;
                                    {
                                        var _d = _check._objMap[Go.asInterface(_obj)];
                                        if (_d != null && ((_d : Dynamic).__nil__ == null || !(_d : Dynamic).__nil__)) {
                                            _alias = _d._tdecl.assign.isValid();
                                        } else {
                                            _alias = _obj.isAlias();
                                        };
                                    };
                                    if (!_alias) {
                                        _ndef++;
                                    };
                                } else if (Go.typeEquals((__type__ : Ref<Func>))) {
                                    var _obj:Ref<stdgo.go.types.Types.Func> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Func>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__().value;
                                } else {
                                    var _obj:stdgo.go.types.Types.Object = __type__ == null ? (null : stdgo.go.types.Types.Object) : cast __type__;
                                    _unreachable();
                                };
                                break;
                            };
                        };
                    };
                };
                if (false) {
                    _check._trace(_obj.pos(), ("## cycle detected: objPath = %s->%s (len = %d)" : GoString), Go.toInterface(_pathString(_cycle)), Go.toInterface(_obj.name()), Go.toInterface((_cycle.length)));
                    if (_tparCycle) {
                        _check._trace(_obj.pos(), ("## cycle contains: generic type in a type parameter list" : GoString));
                    } else {
                        _check._trace(_obj.pos(), ("## cycle contains: %d values, %d type definitions" : GoString), Go.toInterface(_nval), Go.toInterface(_ndef));
                    };
                    __deferstack__.unshift(() -> {
                        var a = function():Void {
                            if (_valid) {
                                _check._trace(_obj.pos(), ("=> cycle is valid" : GoString));
                            } else {
                                _check._trace(_obj.pos(), ("=> error: cycle is invalid" : GoString));
                            };
                        };
                        a();
                    });
                };
                if (!_tparCycle) {
                    if (_nval == ((_cycle.length))) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return true;
                        };
                    };
                    if ((_nval == (0 : GoInt)) && (_ndef > (0 : GoInt))) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return true;
                        };
                    };
                };
                _check._cycleError(_cycle);
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return false;
                };
                for (defer in __deferstack__) {
                    defer();
                };
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    if (Go.recover_exception != null) throw Go.recover_exception;
                    return _valid;
                };
            } catch(__exception__) {
                var exe:Dynamic = __exception__.native;
                if ((exe is haxe.ValueException)) exe = exe.value;
                if (!(exe is AnyInterfaceData)) {
                    exe = Go.toInterface(__exception__.message);
                };
                Go.recover_exception = exe;
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return _valid;
            };
        });
        throw "controlFlow did not return";
    }
    /**
        // objDecl type-checks the declaration of obj in its respective (file) environment.
        // For the meaning of def, see Checker.definedType, in typexpr.go.
    **/
    @:keep
    static public function _objDecl( _check:Ref<Checker>, _obj:Object, _def:Ref<Named>):Void {
        var __deferstack__:Array<Void -> Void> = [];
        try {
            if (false && (_obj.type() == null)) {
                if (_check._indent == ((0 : GoInt))) {
                    stdgo.fmt.Fmt.println();
                };
                _check._trace(_obj.pos(), ("-- checking %s (%s, objPath = %s)" : GoString), Go.toInterface(_obj), Go.toInterface(Go.asInterface(_obj._color())), Go.toInterface(_pathString(_check._objPath)));
                _check._indent++;
                __deferstack__.unshift(() -> {
                    var a = function():Void {
                        _check._indent--;
                        _check._trace(_obj.pos(), ("=> %s (%s)" : GoString), Go.toInterface(_obj), Go.toInterface(Go.asInterface(_obj._color())));
                    };
                    a();
                });
            };
            if ((_obj._color() == (0u32 : stdgo.go.types.Types.T_color)) && (_obj.type() != null)) {
                _obj._setColor((1u32 : stdgo.go.types.Types.T_color));
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return;
                };
            };
            {
                var __switchIndex__ = -1;
                var __run__ = true;
                while (__run__) {
                    __run__ = false;
                    {
                        final __value__ = _obj._color();
                        if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (__value__ == (0u32 : stdgo.go.types.Types.T_color)))) {
                            _assert(_obj.type() == null);
                            _obj._setColor((2u32 : stdgo.go.types.Types.T_color) + (_check._push(_obj) : T_color));
                            __deferstack__.unshift(() -> {
                                var a = function():Void {
                                    _check._pop()._setColor((1u32 : stdgo.go.types.Types.T_color));
                                };
                                a();
                            });
                            break;
                            break;
                        } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && (__value__ == (1u32 : stdgo.go.types.Types.T_color)))) {
                            _assert(_obj.type() != null);
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return;
                            };
                            break;
                            break;
                        } else if (__switchIndex__ == 3 || (__switchIndex__ == -1 && (__value__ == (2u32 : stdgo.go.types.Types.T_color)))) {
                            {
                                final __type__ = _obj;
                                if (Go.typeEquals((__type__ : Ref<Const>))) {
                                    var _obj:Ref<stdgo.go.types.Types.Const> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Const>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Const>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Const>) : __type__.__underlying__().value;
                                    if (!_check._validCycle(Go.asInterface(_obj)) || (_obj._object._typ == null)) {
                                        _obj._object._typ = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                                    };
                                } else if (Go.typeEquals((__type__ : Ref<Var>))) {
                                    var _obj:Ref<stdgo.go.types.Types.Var> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Var>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__().value;
                                    if (!_check._validCycle(Go.asInterface(_obj)) || (_obj._object._typ == null)) {
                                        _obj._object._typ = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                                    };
                                } else if (Go.typeEquals((__type__ : Ref<TypeName>))) {
                                    var _obj:Ref<stdgo.go.types.Types.TypeName> = __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.TypeName>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__().value;
                                    if (!_check._validCycle(Go.asInterface(_obj))) {
                                        _obj._object._typ = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                                    };
                                } else if (Go.typeEquals((__type__ : Ref<Func>))) {
                                    var _obj:Ref<stdgo.go.types.Types.Func> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Func>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__().value;
                                    if (!_check._validCycle(Go.asInterface(_obj))) {};
                                } else {
                                    var _obj:stdgo.go.types.Types.Object = __type__ == null ? (null : stdgo.go.types.Types.Object) : cast __type__;
                                    _unreachable();
                                };
                            };
                            _assert(_obj.type() != null);
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return;
                            };
                            break;
                            break;
                        } else {
                            @:fallthrough {
                                __switchIndex__ = 3;
                                __run__ = true;
                                continue;
                            };
                        };
                    };
                    break;
                };
            };
            var _d = _check._objMap[_obj];
            if (_d == null || (_d : Dynamic).__nil__) {
                _check._dump(("%v: %s should have been declared" : GoString), Go.toInterface(Go.asInterface(_obj.pos())), Go.toInterface(_obj));
                _unreachable();
            };
            {
                var _a0 = _check._environment;
                __deferstack__.unshift(() -> {
                    var a = function(_env:T_environment):Void {
                        _check._environment = _env?.__copy__();
                    };
                    a(_a0?.__copy__());
                });
            };
            _check._environment = ({ _scope : _d._file } : T_environment);
            {
                final __type__ = _obj;
                if (Go.typeEquals((__type__ : Ref<Const>))) {
                    var _obj:Ref<stdgo.go.types.Types.Const> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Const>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Const>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Const>) : __type__.__underlying__().value;
                    _check._environment._decl = _d;
                    _check._constDecl(_obj, _d._vtyp, _d._init, _d._inherited);
                } else if (Go.typeEquals((__type__ : Ref<Var>))) {
                    var _obj:Ref<stdgo.go.types.Types.Var> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Var>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__().value;
                    _check._environment._decl = _d;
                    _check._varDecl(_obj, _d._lhs, _d._vtyp, _d._init);
                } else if (Go.typeEquals((__type__ : Ref<TypeName>))) {
                    var _obj:Ref<stdgo.go.types.Types.TypeName> = __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.TypeName>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__().value;
                    _check._typeDecl(_obj, _d._tdecl, _def);
                    _check._collectMethods(_obj);
                } else if (Go.typeEquals((__type__ : Ref<Func>))) {
                    var _obj:Ref<stdgo.go.types.Types.Func> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Func>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__().value;
                    _check._funcDecl(_obj, _d);
                } else {
                    var _obj:stdgo.go.types.Types.Object = __type__ == null ? (null : stdgo.go.types.Types.Object) : cast __type__;
                    _unreachable();
                };
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return;
        };
    }
    @:keep
    static public function _declare( _check:Ref<Checker>, _scope:Ref<Scope>, _id:Ref<stdgo.go.ast.Ast.Ident>, _obj:Object, _pos:stdgo.go.token.Token.Pos):Void {
        if (_obj.name() != (("_" : GoString))) {
            {
                var _alt:stdgo.go.types.Types.Object = _scope.insert(_obj);
                if (_alt != null) {
                    _check._errorf(_obj, (10 : stdgo.internal.types.errors.Errors.Code), ("%s redeclared in this block" : GoString), Go.toInterface(_obj.name()));
                    _check._reportAltDecl(_alt);
                    return;
                };
            };
            _obj._setScopePos(_pos);
        };
        if (_id != null && ((_id : Dynamic).__nil__ == null || !(_id : Dynamic).__nil__)) {
            _check._recordDef(_id, _obj);
        };
    }
    @:keep
    static public function _reportAltDecl( _check:Ref<Checker>, _obj:Object):Void {
        {
            var _pos:stdgo.go.token.Token.Pos = _obj.pos();
            if (_pos.isValid()) {
                _check._errorf(_obj, (10 : stdgo.internal.types.errors.Errors.Code), ("\tother declaration of %s" : GoString), Go.toInterface(_obj.name()));
            };
        };
    }
    /**
        // Conversion type-checks the conversion T(x).
        // The result is in x.
    **/
    @:keep
    static public function _conversion( _check:Ref<Checker>, _x:Ref<T_operand>, t:Type):Void {
        var _constArg:Bool = _x._mode == ((4 : stdgo.go.types.Types.T_operandMode));
        var _constConvertibleTo = function(t:Type, _val:Ref<stdgo.go.constant.Constant.Value>):Bool {
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_under(t)) : Ref<Basic>)) : Ref<Basic>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.Basic>), ok : false };
                }, _t = __tmp__.value, __0 = __tmp__.ok;
                if (_t == null || (_t : Dynamic).__nil__) {} else if (_representableConst(_x._val, _check, _t, _val)) {
                    return true;
                } else if (_isInteger(_x._typ) && _isString(Go.asInterface(_t))) {
                    var _codepoint:GoInt32 = (65533 : GoInt32);
                    {
                        var __tmp__ = stdgo.go.constant.Constant.uint64Val(_x._val), _i:GoUInt64 = __tmp__._0, _ok:Bool = __tmp__._1;
                        if (_ok && (_i <= (1114111i64 : GoUInt64))) {
                            _codepoint = (_i : GoRune);
                        };
                    };
                    if (_val != null && ((_val : Dynamic).__nil__ == null || !(_val : Dynamic).__nil__)) {
                        {
                            var __tmp__ = stdgo.go.constant.Constant.makeString((_codepoint : GoString));
                            _val.exactString = __tmp__.exactString;
                            _val.kind = __tmp__.kind;
                            _val.string = __tmp__.string;
                            _val._implementsValue = __tmp__._implementsValue;
                        };
                    };
                    return true;
                };
            };
            return false;
        };
        var _ok:Bool = false;
        var _cause:GoString = ("" : GoString);
        if (_constArg && _isConstType(t)) {
            _ok = _constConvertibleTo(t, (Go.setRef(_x._val) : Ref<stdgo.go.constant.Constant.Value>));
        } else if (_constArg && _isTypeParam(t)) {
            _ok = (Go.typeAssert((Go.toInterface(t) : Ref<TypeParam>)) : Ref<TypeParam>)._underIs(function(_u:Type):Bool {
                if (_u == null) {
                    _cause = _check._sprintf(("%s does not contain specific types" : GoString), Go.toInterface(t));
                    return false;
                };
                if (_isString(_x._typ) && _isBytesOrRunes(_u)) {
                    return true;
                };
                if (!_constConvertibleTo(_u, (null : Ref<stdgo.go.constant.Constant.Value>))) {
                    _cause = _check._sprintf(("cannot convert %s to type %s (in %s)" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(_u), Go.toInterface(t));
                    return false;
                };
                return true;
            });
            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
        } else if (_x._convertibleTo(_check, t, Go.pointer(_cause))) {
            _ok = true;
            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
        };
        if (!_ok) {
            if (_cause != (Go.str())) {
                _check._errorf(Go.asInterface(_x), (96 : stdgo.internal.types.errors.Errors.Code), ("cannot convert %s to type %s: %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(t), Go.toInterface(_cause));
            } else {
                _check._errorf(Go.asInterface(_x), (96 : stdgo.internal.types.errors.Errors.Code), ("cannot convert %s to type %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(t));
            };
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            return;
        };
        if (_isUntyped(_x._typ)) {
            var _final:stdgo.go.types.Types.Type = t;
            if ((_isNonTypeParamInterface(t) || (_constArg && !_isConstType(t))) || _x._isNil()) {
                _final = default_(_x._typ);
            } else if (((_x._mode == (4 : stdgo.go.types.Types.T_operandMode)) && _isInteger(_x._typ)) && _allString(t)) {
                _final = _x._typ;
            };
            _check._updateExprType(_x._expr, _final, true);
        };
        _x._typ = t;
    }
    @:keep
    static public function _recordScope( _check:Ref<Checker>, _node:stdgo.go.ast.Ast.Node, _scope:Ref<Scope>):Void {
        _assert(_node != null);
        _assert(_scope != null && ((_scope : Dynamic).__nil__ == null || !(_scope : Dynamic).__nil__));
        {
            var _m = _check.info.scopes;
            if (_m != null) {
                _m[_node] = _scope;
            };
        };
    }
    @:keep
    static public function _recordSelection( _check:Ref<Checker>, _x:Ref<stdgo.go.ast.Ast.SelectorExpr>, _kind:SelectionKind, _recv:Type, _obj:Object, _index:Slice<GoInt>, _indirect:Bool):Void {
        _assert((_obj != null) && ((_recv == null) || (_index.length > (0 : GoInt))));
        _check._recordUse(_x.sel, _obj);
        {
            var _m = _check.info.selections;
            if (_m != null) {
                _m[_x] = (Go.setRef((new Selection(_kind, _recv, _obj, _index, _indirect) : Selection)) : Ref<stdgo.go.types.Types.Selection>);
            };
        };
    }
    @:keep
    static public function _recordImplicit( _check:Ref<Checker>, _node:stdgo.go.ast.Ast.Node, _obj:Object):Void {
        _assert(_node != null);
        _assert(_obj != null);
        {
            var _m = _check.info.implicits;
            if (_m != null) {
                _m[_node] = _obj;
            };
        };
    }
    @:keep
    static public function _recordUse( _check:Ref<Checker>, _id:Ref<stdgo.go.ast.Ast.Ident>, _obj:Object):Void {
        _assert(_id != null && ((_id : Dynamic).__nil__ == null || !(_id : Dynamic).__nil__));
        _assert(_obj != null);
        {
            var _m = _check.info.uses;
            if (_m != null) {
                _m[_id] = _obj;
            };
        };
    }
    @:keep
    static public function _recordDef( _check:Ref<Checker>, _id:Ref<stdgo.go.ast.Ast.Ident>, _obj:Object):Void {
        _assert(_id != null && ((_id : Dynamic).__nil__ == null || !(_id : Dynamic).__nil__));
        {
            var _m = _check.info.defs;
            if (_m != null) {
                _m[_id] = _obj;
            };
        };
    }
    /**
        // recordInstance records instantiation information into check.Info, if the
        // Instances map is non-nil. The given expr must be an ident, selector, or
        // index (list) expr with ident or selector operand.
        //
        // TODO(rfindley): the expr parameter is fragile. See if we can access the
        // instantiated identifier in some other way.
    **/
    @:keep
    static public function _recordInstance( _check:Ref<Checker>, _expr:stdgo.go.ast.Ast.Expr, _targs:Slice<Type>, _typ:Type):Void {
        var _ident = _instantiatedIdent(_expr);
        _assert(_ident != null && ((_ident : Dynamic).__nil__ == null || !(_ident : Dynamic).__nil__));
        _assert(_typ != null);
        {
            var _m = _check.info.instances;
            if (_m != null) {
                _m[_ident] = (new Instance(_newTypeList(_targs), _typ) : Instance);
            };
        };
    }
    @:keep
    static public function _recordCommaOkTypes( _check:Ref<Checker>, _x:stdgo.go.ast.Ast.Expr, _a:GoArray<Type>):Void {
        _assert(_x != null);
        if ((_a[(0 : GoInt)] == null) || (_a[(1 : GoInt)] == null)) {
            return;
        };
        _assert((_isTyped(_a[(0 : GoInt)]) && _isTyped(_a[(1 : GoInt)])) && (_isBoolean(_a[(1 : GoInt)]) || (Go.toInterface(_a[(1 : GoInt)]) == Go.toInterface(_universeError))));
        {
            var _m = _check.info.types;
            if (_m != null) {
                while (true) {
                    var _tv:stdgo.go.types.Types.TypeAndValue = _m[_x];
                    _assert(_tv.type != null);
                    var _pos:stdgo.go.token.Token.Pos = _x.pos();
                    _tv.type = Go.asInterface(newTuple(newVar(_pos, _check._pkg, Go.str(), _a[(0 : GoInt)]), newVar(_pos, _check._pkg, Go.str(), _a[(1 : GoInt)])));
                    _m[_x] = _tv?.__copy__();
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_x) : Ref<stdgo.go.ast.Ast.ParenExpr>)) : Ref<stdgo.go.ast.Ast.ParenExpr>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.ast.Ast.ParenExpr>), ok : false };
                    }, _p = __tmp__.value, __24 = __tmp__.ok;
                    if (_p == null || (_p : Dynamic).__nil__) {
                        break;
                    };
                    _x = _p.x;
                };
            };
        };
    }
    @:keep
    static public function _recordBuiltinType( _check:Ref<Checker>, _f:stdgo.go.ast.Ast.Expr, _sig:Ref<Signature>):Void {
        while (true) {
            _check._recordTypeAndValue(_f, (2 : stdgo.go.types.Types.T_operandMode), Go.asInterface(_sig), (null : stdgo.go.constant.Constant.Value));
            {
                final __type__ = _f;
                if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.Ident>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.SelectorExpr>))) {
                    var _p:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                    return;
                } else if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.ParenExpr>))) {
                    var _p:Ref<stdgo.go.ast.Ast.ParenExpr> = __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__ == null ? (null : Ref<stdgo.go.ast.Ast.ParenExpr>) : __type__.__underlying__().value;
                    _f = _p.x;
                } else {
                    var _p:stdgo.go.ast.Ast.Expr = __type__ == null ? (null : stdgo.go.ast.Ast.Expr) : cast __type__;
                    _unreachable();
                };
            };
        };
    }
    @:keep
    static public function _recordTypeAndValue( _check:Ref<Checker>, _x:stdgo.go.ast.Ast.Expr, _mode:T_operandMode, _typ:Type, _val:stdgo.go.constant.Constant.Value):Void {
        _assert(_x != null);
        _assert(_typ != null);
        if (_mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
            return;
        };
        if (_mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
            _assert(_val != null);
            _assert((Go.toInterface(_typ) == Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]))) || _allBasic(_typ, (59 : stdgo.go.types.Types.BasicInfo)));
        };
        {
            var _m = _check.info.types;
            if (_m != null) {
                _m[_x] = (new TypeAndValue(_mode, _typ, _val) : TypeAndValue);
            };
        };
    }
    @:keep
    static public function _recordUntyped( _check:Ref<Checker>):Void {
        if (true && (_check.info.types == null)) {
            return;
        };
        for (_x => info in _check._untyped) {
            if (false && _isTyped(Go.asInterface(info._typ))) {
                _check._dump(("%v: %s (type %s) is typed" : GoString), Go.toInterface(Go.asInterface(_x.pos())), Go.toInterface(_x), Go.toInterface(Go.asInterface(info._typ)));
                _unreachable();
            };
            _check._recordTypeAndValue(_x, info._mode, Go.asInterface(info._typ), info._val);
        };
    }
    @:keep
    static public function _record( _check:Ref<Checker>, _x:Ref<T_operand>):Void {
        var _typ:Type = (null : stdgo.go.types.Types.Type);
        var _val:stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
        {
            final __value__ = _x._mode;
            if (__value__ == ((0 : stdgo.go.types.Types.T_operandMode))) {
                _typ = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
            } else if (__value__ == ((1 : stdgo.go.types.Types.T_operandMode))) {
                _typ = Go.asInterface(((null : Ref<stdgo.go.types.Types.Tuple>) : Ref<Tuple>));
            } else if (__value__ == ((4 : stdgo.go.types.Types.T_operandMode))) {
                _typ = _x._typ;
                _val = _x._val;
            } else {
                _typ = _x._typ;
            };
        };
        _assert((_x._expr != null) && (_typ != null));
        if (_isUntyped(_typ)) {
            _check._rememberUntyped(_x._expr, false, _x._mode, (Go.typeAssert((Go.toInterface(_typ) : Ref<Basic>)) : Ref<Basic>), _val);
        } else {
            _check._recordTypeAndValue(_x._expr, _x._mode, _typ, _val);
        };
    }
    /**
        // cleanup runs cleanup for all collected cleaners.
    **/
    @:keep
    static public function _cleanup( _check:Ref<Checker>):Void {
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < (_check._cleaners.length), _i++, {
                _check._cleaners[(_i : GoInt)]._cleanup();
            });
        };
        _check._cleaners = (null : Slice<stdgo.go.types.Types.T_cleaner>);
    }
    /**
        // processDelayed processes all delayed actions pushed after top.
    **/
    @:keep
    static public function _processDelayed( _check:Ref<Checker>, _top:GoInt):Void {
        {
            var _i:GoInt = _top;
            Go.cfor(_i < (_check._delayed.length), _i++, {
                var _a = (Go.setRef(_check._delayed[(_i : GoInt)]) : Ref<stdgo.go.types.Types.T_action>);
                if (false) {
                    if (_a._desc != null && ((_a._desc : Dynamic).__nil__ == null || !(_a._desc : Dynamic).__nil__)) {
                        _check._trace(_a._desc._pos.pos(), ("-- " : GoString) + _a._desc._format, ..._a._desc._args.__toArray__());
                    } else {
                        _check._trace((0 : stdgo.go.token.Token.Pos), ("-- delayed %p" : GoString), Go.toInterface(_a._f));
                    };
                };
                _a._f();
                if (false) {
                    stdgo.fmt.Fmt.println();
                };
            });
        };
        _assert(_top <= (_check._delayed.length));
        _check._delayed = (_check._delayed.__slice__(0, _top) : Slice<stdgo.go.types.Types.T_action>);
    }
    @:keep
    static public function _checkFiles( _check:Ref<Checker>, _files:Slice<Ref<stdgo.go.ast.Ast.File>>):Error {
        var __deferstack__:Array<Void -> Void> = [];
        var _err:Error = (null : Error);
        try {
            if (_check._conf.fakeImportC && _check._conf._go115UsesCgo) {
                return _errBadCgo;
            };
            {
                var _a0 = (Go.setRef(_err) : Ref<Error>);
                __deferstack__.unshift(() -> _check._handleBailout(_a0));
            };
            var _print:GoString -> Void = function(_msg:GoString):Void {
                if (false) {
                    stdgo.fmt.Fmt.println();
                    stdgo.fmt.Fmt.println(Go.toInterface(_msg));
                };
            };
            _print(("== initFiles ==" : GoString));
            _check._initFiles(_files);
            _print(("== collectObjects ==" : GoString));
            _check._collectObjects();
            _print(("== packageObjects ==" : GoString));
            _check._packageObjects();
            _print(("== processDelayed ==" : GoString));
            _check._processDelayed((0 : GoInt));
            _print(("== cleanup ==" : GoString));
            _check._cleanup();
            _print(("== initOrder ==" : GoString));
            _check._initOrder();
            if (!_check._conf.disableUnusedImportCheck) {
                _print(("== unusedImports ==" : GoString));
                _check._unusedImports();
            };
            _print(("== recordUntyped ==" : GoString));
            _check._recordUntyped();
            if (_check._firstErr == null) {
                _check._monomorph();
            };
            _check._pkg._complete = true;
            _check._imports = (null : Slice<Ref<stdgo.go.types.Types.PkgName>>);
            _check._dotImportMap = (null : GoMap<stdgo.go.types.Types.T_dotImportKey, Ref<stdgo.go.types.Types.PkgName>>);
            _check._pkgPathMap = (null : GoMap<GoString, GoMap<GoString, Bool>>);
            _check._seenPkgMap = (null : GoMap<Ref<stdgo.go.types.Types.Package>, Bool>);
            _check._recvTParamMap = (null : GoMap<Ref<stdgo.go.ast.Ast.Ident>, Ref<stdgo.go.types.Types.TypeParam>>);
            _check._brokenAliases = (null : GoMap<Ref<stdgo.go.types.Types.TypeName>, Bool>);
            _check._unionTypeSets = (null : GoMap<Ref<stdgo.go.types.Types.Union>, Ref<stdgo.go.types.Types.T__TypeSet>>);
            _check._ctxt = null;
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _err;
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return _err;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return _err;
        };
    }
    /**
        // Files checks the provided files as part of the checker's package.
    **/
    @:keep
    static public function files( _check:Ref<Checker>, _files:Slice<Ref<stdgo.go.ast.Ast.File>>):Error {
        return _check._checkFiles(_files);
    }
    @:keep
    static public function _handleBailout( _check:Ref<Checker>, _err:Ref<Error>):Void {
        {
            final __type__ = ({
                final r = Go.recover_exception;
                Go.recover_exception = null;
                r;
            });
            if (__type__ == null || Go.typeEquals((__type__ : T_bailout))) {
                var _p:AnyInterface = __type__?.__underlying__();
                {
                    var __tmp__ = _check._firstErr;
                    _err.error = __tmp__.error;
                };
            } else {
                var _p:AnyInterface = __type__?.__underlying__();
                throw Go.toInterface(_p);
            };
        };
    }
    /**
        // initFiles initializes the files-specific portion of checker.
        // The provided files must all belong to the same package.
    **/
    @:keep
    static public function _initFiles( _check:Ref<Checker>, _files:Slice<Ref<stdgo.go.ast.Ast.File>>):Void {
        _check._files = (null : Slice<Ref<stdgo.go.ast.Ast.File>>);
        _check._imports = (null : Slice<Ref<stdgo.go.types.Types.PkgName>>);
        _check._dotImportMap = (null : GoMap<stdgo.go.types.Types.T_dotImportKey, Ref<stdgo.go.types.Types.PkgName>>);
        _check._firstErr = (null : Error);
        _check._methods = (null : GoMap<Ref<stdgo.go.types.Types.TypeName>, Slice<Ref<stdgo.go.types.Types.Func>>>);
        _check._untyped = (null : GoMap<stdgo.go.ast.Ast.Expr, stdgo.go.types.Types.T_exprInfo>);
        _check._delayed = (null : Slice<stdgo.go.types.Types.T_action>);
        _check._objPath = (null : Slice<stdgo.go.types.Types.Object>);
        _check._cleaners = (null : Slice<stdgo.go.types.Types.T_cleaner>);
        var _pkg = _check._pkg;
        for (__80 => _file in _files) {
            {
                var _name:GoString = _file.name.name;
                {
                    var __switchIndex__ = -1;
                    var __run__ = true;
                    while (__run__) {
                        __run__ = false;
                        {
                            final __value__ = _pkg._name;
                            if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (__value__ == Go.str()))) {
                                if (_name != (("_" : GoString))) {
                                    _pkg._name = _name;
                                } else {
                                    _check._error(Go.asInterface(_file.name), (2 : stdgo.internal.types.errors.Errors.Code), ("invalid package name _" : GoString));
                                };
                                @:fallthrough {
                                    __switchIndex__ = 1;
                                    __run__ = true;
                                    continue;
                                };
                                break;
                            } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && (__value__ == _name))) {
                                _check._files = (_check._files.__append__(_file));
                                break;
                                break;
                            } else {
                                _check._errorf(Go.asInterface((_file.package_ : T_atPos)), (3 : stdgo.internal.types.errors.Errors.Code), ("package %s; expected %s" : GoString), Go.toInterface(_name), Go.toInterface(_pkg._name));
                                break;
                            };
                        };
                        break;
                    };
                };
            };
        };
    }
    /**
        // needsCleanup records objects/types that implement the cleanup method
        // which will be called at the end of type-checking.
    **/
    @:keep
    static public function _needsCleanup( _check:Ref<Checker>, _c:T_cleaner):Void {
        _check._cleaners = (_check._cleaners.__append__(_c));
    }
    /**
        // pop pops and returns the topmost object from the object path.
    **/
    @:keep
    static public function _pop( _check:Ref<Checker>):Object {
        var _i:GoInt = (_check._objPath.length) - (1 : GoInt);
        var _obj:stdgo.go.types.Types.Object = _check._objPath[(_i : GoInt)];
        _check._objPath[(_i : GoInt)] = (null : stdgo.go.types.Types.Object);
        _check._objPath = (_check._objPath.__slice__(0, _i) : Slice<stdgo.go.types.Types.Object>);
        return _obj;
    }
    /**
        // push pushes obj onto the object path and returns its index in the path.
    **/
    @:keep
    static public function _push( _check:Ref<Checker>, _obj:Object):GoInt {
        _check._objPath = (_check._objPath.__append__(_obj));
        return (_check._objPath.length) - (1 : GoInt);
    }
    /**
        // later pushes f on to the stack of actions that will be processed later;
        // either at the end of the current statement, or in case of a local constant
        // or variable declaration, before the constant or variable is in scope
        // (so that f still sees the scope before any new declarations).
        // later returns the pushed action so one can provide a description
        // via action.describef for debugging, if desired.
    **/
    @:keep
    static public function _later( _check:Ref<Checker>, _f:() -> Void):Ref<T_action> {
        var _i:GoInt = (_check._delayed.length);
        _check._delayed = (_check._delayed.__append__(({ _f : _f } : T_action)));
        return (Go.setRef(_check._delayed[(_i : GoInt)]) : Ref<stdgo.go.types.Types.T_action>);
    }
    @:keep
    static public function _rememberUntyped( _check:Ref<Checker>, _e:stdgo.go.ast.Ast.Expr, _lhs:Bool, _mode:T_operandMode, _typ:Ref<Basic>, _val:stdgo.go.constant.Constant.Value):Void {
        var _m = _check._untyped;
        if (_m == null) {
            _m = ({
                final x = new GoObjectMap<stdgo.go.ast.Ast.Expr, stdgo.go.types.Types.T_exprInfo>();
                x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.ast.Ast.Expr", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }));
                x.__defaultValue__ = () -> ({} : stdgo.go.types.Types.T_exprInfo);
                @:mergeBlock {};
                cast x;
            } : GoMap<stdgo.go.ast.Ast.Expr, stdgo.go.types.Types.T_exprInfo>);
            _check._untyped = _m;
        };
        _m[_e] = (new T_exprInfo(_lhs, _mode, _typ, _val) : T_exprInfo);
    }
    /**
        // isBrokenAlias reports whether alias doesn't have a determined type yet.
    **/
    @:keep
    static public function _isBrokenAlias( _check:Ref<Checker>, _alias:Ref<TypeName>):Bool {
        return (Go.toInterface(_alias._object._typ) == Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]))) && _check._brokenAliases[_alias];
    }
    /**
        // validAlias records that alias has the valid type typ (possibly Typ[Invalid]).
    **/
    @:keep
    static public function _validAlias( _check:Ref<Checker>, _alias:Ref<TypeName>, _typ:Type):Void {
        if (_check._brokenAliases != null) _check._brokenAliases.remove(_alias);
        _alias._object._typ = _typ;
    }
    /**
        // brokenAlias records that alias doesn't have a determined type yet.
        // It also sets alias.typ to Typ[Invalid].
    **/
    @:keep
    static public function _brokenAlias( _check:Ref<Checker>, _alias:Ref<TypeName>):Void {
        if (_check._brokenAliases == null) {
            _check._brokenAliases = ({
                final x = new GoRefMap<Ref<stdgo.go.types.Types.TypeName>, Bool>();
                @:mergeBlock {};
                cast x;
            } : GoMap<Ref<stdgo.go.types.Types.TypeName>, Bool>);
        };
        _check._brokenAliases[_alias] = true;
        _alias._object._typ = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
    }
    /**
        // addDeclDep adds the dependency edge (check.decl -> to) if check.decl exists
    **/
    @:keep
    static public function _addDeclDep( _check:Ref<Checker>, _to:Object):Void {
        var _from = _check._environment._decl;
        if (_from == null || (_from : Dynamic).__nil__) {
            return;
        };
        {
            var __tmp__ = (_check._objMap != null && _check._objMap.exists(_to) ? { value : _check._objMap[_to], ok : true } : { value : (null : Ref<stdgo.go.types.Types.T_declInfo>), ok : false }), __24:Ref<stdgo.go.types.Types.T_declInfo> = __tmp__.value, _found:Bool = __tmp__.ok;
            if (!_found) {
                return;
            };
        };
        _from._addDep(_to);
    }
    /**
        // useLHS is like use, but doesn't "use" top-level identifiers.
        // It should be called instead of use if the arguments are
        // expressions on the lhs of an assignment.
        // The arguments must not be nil.
    **/
    @:keep
    static public function _useLHS( _check:Ref<Checker>, _arg:haxe.Rest<stdgo.go.ast.Ast.Expr>):Void {
        var _arg = new Slice<stdgo.go.ast.Ast.Expr>(_arg.length, 0, ..._arg);
        var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
        for (__0 => _e in _arg) {
            var _v:Ref<Var> = (null : Ref<stdgo.go.types.Types.Var>);
            var _v_used:Bool = false;
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_unparen(_e)) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.ast.Ast.Ident>), ok : false };
                }, _ident = __tmp__.value, __1 = __tmp__.ok;
                if (_ident != null && ((_ident : Dynamic).__nil__ == null || !(_ident : Dynamic).__nil__)) {
                    if (_ident.name == (("_" : GoString))) {
                        continue;
                    };
                    {
                        var __tmp__ = _check._pkg._scope.lookupParent(_ident.name, (0 : stdgo.go.token.Token.Pos)), __10:Ref<stdgo.go.types.Types.Scope> = __tmp__._0, _obj:stdgo.go.types.Types.Object = __tmp__._1;
                        if (_obj != null) {
                            {
                                var __tmp__ = try {
                                    { value : (Go.typeAssert((Go.toInterface(_obj) : Ref<Var>)) : Ref<Var>), ok : true };
                                } catch(_) {
                                    { value : (null : Ref<stdgo.go.types.Types.Var>), ok : false };
                                }, _w = __tmp__.value, __11 = __tmp__.ok;
                                if (((_w != null) && ((_w : Dynamic).__nil__ == null || !(_w : Dynamic).__nil__)) && (_w._object._pkg == _check._pkg)) {
                                    _v = _w;
                                    _v_used = _v._used;
                                };
                            };
                        };
                    };
                };
            };
            _check._rawExpr((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), _e, (null : stdgo.go.types.Types.Type), false);
            if (_v != null && ((_v : Dynamic).__nil__ == null || !(_v : Dynamic).__nil__)) {
                _v._used = _v_used;
            };
        };
    }
    /**
        // use type-checks each argument.
        // Useful to make sure expressions are evaluated
        // (and variables are "used") in the presence of other errors.
        // The arguments may be nil.
    **/
    @:keep
    static public function _use( _check:Ref<Checker>, _arg:haxe.Rest<stdgo.go.ast.Ast.Expr>):Void {
        var _arg = new Slice<stdgo.go.ast.Ast.Expr>(_arg.length, 0, ..._arg);
        var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
        for (__0 => _e in _arg) {
            if (_e != null) {
                _check._rawExpr((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), _e, (null : stdgo.go.types.Types.Type), false);
            };
        };
    }
    @:keep
    static public function _selector( _check:Ref<Checker>, _x:Ref<T_operand>, _e:Ref<stdgo.go.ast.Ast.SelectorExpr>, _def:Ref<Named>, _wantType:Bool):Void {
        stdgo.internal.Macro.controlFlow({
            var __0:Object = (null : stdgo.go.types.Types.Object), __1:Slice<GoInt> = (null : Slice<GoInt>), __2:Bool = false, _indirect:Bool = __2, _index:Slice<GoInt> = __1, _obj:Object = __0;
            var _sel:GoString = _e.sel.name;
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_e.x) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.ast.Ast.Ident>), ok : false };
                }, _ident = __tmp__.value, _ok = __tmp__.ok;
                if (_ok) {
                    var _obj:stdgo.go.types.Types.Object = _check._lookup(_ident.name);
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_obj) : Ref<PkgName>)) : Ref<PkgName>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.types.Types.PkgName>), ok : false };
                        }, _pname = __tmp__.value, __0 = __tmp__.ok;
                        if (_pname != null && ((_pname : Dynamic).__nil__ == null || !(_pname : Dynamic).__nil__)) {
                            _assert(_pname._object._pkg == (_check._pkg));
                            _check._recordUse(_ident, Go.asInterface(_pname));
                            _pname._used = true;
                            var _pkg = _pname._imported;
                            var _exp:Object = (null : stdgo.go.types.Types.Object);
                            var _funcMode:stdgo.go.types.Types.T_operandMode = (7 : stdgo.go.types.Types.T_operandMode);
                            if (_pkg._cgo) {
                                if (_sel == (("malloc" : GoString))) {
                                    _sel = ("_CMalloc" : GoString);
                                } else {
                                    _funcMode = (10 : stdgo.go.types.Types.T_operandMode);
                                };
                                for (__9 => _prefix in _cgoPrefixes) {
                                    {
                                        var __tmp__ = _check._pkg._scope.lookupParent(_prefix + _sel, _check._pkg._scope._pos);
                                        _exp = __tmp__._1;
                                    };
                                    if (_exp != null) {
                                        break;
                                    };
                                };
                                if (_exp == null) {
                                    _check._errorf(Go.asInterface(_e.sel), (73 : stdgo.internal.types.errors.Errors.Code), ("undefined: %s" : GoString), Go.toInterface(Go.asInterface(_e)));
                                    @:goto "Error";
                                };
                                _check._objDecl(_exp, null);
                            } else {
                                _exp = _pkg._scope.lookup(_sel);
                                if (_exp == null) {
                                    if (!_pkg._fake) {
                                        _check._errorf(Go.asInterface(_e.sel), (73 : stdgo.internal.types.errors.Errors.Code), ("undefined: %s" : GoString), Go.toInterface(Go.asInterface(_e)));
                                    };
                                    @:goto "Error";
                                };
                                if (!_exp.exported()) {
                                    _check._errorf(Go.asInterface(_e.sel), (74 : stdgo.internal.types.errors.Errors.Code), ("%s not exported by package %s" : GoString), Go.toInterface(_sel), Go.toInterface(_pkg._name));
                                };
                            };
                            _check._recordUse(_e.sel, _exp);
                            {
                                final __type__ = _exp;
                                if (Go.typeEquals((__type__ : Ref<Const>))) {
                                    var _exp:Ref<stdgo.go.types.Types.Const> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Const>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Const>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Const>) : __type__.__underlying__().value;
                                    _assert(_exp.val() != null);
                                    _x._mode = (4 : stdgo.go.types.Types.T_operandMode);
                                    _x._typ = _exp._object._typ;
                                    _x._val = _exp._val;
                                } else if (Go.typeEquals((__type__ : Ref<TypeName>))) {
                                    var _exp:Ref<stdgo.go.types.Types.TypeName> = __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.TypeName>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeName>) : __type__.__underlying__().value;
                                    _x._mode = (3 : stdgo.go.types.Types.T_operandMode);
                                    _x._typ = _exp._object._typ;
                                } else if (Go.typeEquals((__type__ : Ref<Var>))) {
                                    var _exp:Ref<stdgo.go.types.Types.Var> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Var>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__().value;
                                    _x._mode = (5 : stdgo.go.types.Types.T_operandMode);
                                    _x._typ = _exp._object._typ;
                                    if (_pkg._cgo && stdgo.strings.Strings.hasPrefix(_exp._object._name, ("_Cvar_" : GoString))) {
                                        _x._typ = (Go.typeAssert((Go.toInterface(_x._typ) : Ref<Pointer_>)) : Ref<Pointer_>)._base;
                                    };
                                } else if (Go.typeEquals((__type__ : Ref<Func>))) {
                                    var _exp:Ref<stdgo.go.types.Types.Func> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Func>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__().value;
                                    _x._mode = _funcMode;
                                    _x._typ = _exp._object._typ;
                                    if (_pkg._cgo && stdgo.strings.Strings.hasPrefix(_exp._object._name, ("_Cmacro_" : GoString))) {
                                        _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                                        _x._typ = (Go.typeAssert((Go.toInterface(_x._typ) : Ref<Signature>)) : Ref<Signature>)._results._vars[(0 : GoInt)]._object._typ;
                                    };
                                } else if (Go.typeEquals((__type__ : Ref<Builtin>))) {
                                    var _exp:Ref<stdgo.go.types.Types.Builtin> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Builtin>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Builtin>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Builtin>) : __type__.__underlying__().value;
                                    _x._mode = (2 : stdgo.go.types.Types.T_operandMode);
                                    _x._typ = _exp._object._typ;
                                    _x._id = _exp._id;
                                } else {
                                    var _exp:stdgo.go.types.Types.Object = __type__ == null ? (null : stdgo.go.types.Types.Object) : cast __type__;
                                    _check._dump(("%v: unexpected object %v" : GoString), Go.toInterface(Go.asInterface(_e.sel.pos())), Go.toInterface(_exp));
                                    _unreachable();
                                };
                            };
                            _x._expr = Go.asInterface(_e);
                            return;
                        };
                    };
                };
            };
            _check._exprOrType(_x, _e.x, false);
            {
                final __value__ = _x._mode;
                if (__value__ == ((3 : stdgo.go.types.Types.T_operandMode))) {
                    if (((_def != null) && ((_def : Dynamic).__nil__ == null || !(_def : Dynamic).__nil__)) && (Go.toInterface(_x._typ) == Go.toInterface(Go.asInterface(_def)))) {
                        _check._cycleError((new Slice<stdgo.go.types.Types.Object>(1, 1, Go.asInterface(_def._obj)) : Slice<stdgo.go.types.Types.Object>));
                        @:goto "Error";
                    };
                } else if (__value__ == ((2 : stdgo.go.types.Types.T_operandMode))) {
                    _check._errorf(Go.asInterface(_e.sel), (82 : stdgo.internal.types.errors.Errors.Code), ("cannot select on %s" : GoString), Go.toInterface(Go.asInterface(_x)));
                    @:goto "Error";
                } else if (__value__ == ((0 : stdgo.go.types.Types.T_operandMode))) {
                    @:goto "Error";
                };
            };
            if (_wantType) {
                _check._errorf(Go.asInterface(_e.sel), (25 : stdgo.internal.types.errors.Errors.Code), ("%s is not a type" : GoString), Go.toInterface(Go.asInterface(_e)));
                @:goto "Error";
            };
            {
                var __tmp__ = lookupFieldOrMethod(_x._typ, _x._mode == ((5 : stdgo.go.types.Types.T_operandMode)), _check._pkg, _sel);
                _obj = __tmp__._0;
                _index = __tmp__._1;
                _indirect = __tmp__._2;
            };
            if (_obj == null) {
                if (Go.toInterface(_under(_x._typ)) == (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                    @:goto "Error";
                };
                if (_index != null) {
                    _check._errorf(Go.asInterface(_e.sel), (72 : stdgo.internal.types.errors.Errors.Code), ("ambiguous selector %s.%s" : GoString), Go.toInterface(_x._expr), Go.toInterface(_sel));
                    @:goto "Error";
                };
                if (_indirect) {
                    if (_x._mode == ((3 : stdgo.go.types.Types.T_operandMode))) {
                        _check._errorf(Go.asInterface(_e.sel), (125 : stdgo.internal.types.errors.Errors.Code), ("invalid method expression %s.%s (needs pointer receiver (*%s).%s)" : GoString), Go.toInterface(_x._typ), Go.toInterface(_sel), Go.toInterface(_x._typ), Go.toInterface(_sel));
                    } else {
                        _check._errorf(Go.asInterface(_e.sel), (125 : stdgo.internal.types.errors.Errors.Code), ("cannot call pointer method %s on %s" : GoString), Go.toInterface(_sel), Go.toInterface(_x._typ));
                    };
                    @:goto "Error";
                };
                var _why:GoString = ("" : GoString);
                if (_isInterfacePtr(_x._typ)) {
                    _why = _check._interfacePtrError(_x._typ);
                } else {
                    _why = _check._sprintf(("type %s has no field or method %s" : GoString), Go.toInterface(_x._typ), Go.toInterface(_sel));
                    if ((_sel.length) > (0 : GoInt)) {
                        var _changeCase:GoString = ("" : GoString);
                        {
                            var _r:GoInt32 = (_sel[(0 : GoInt)] : GoRune);
                            if (stdgo.unicode.Unicode.isUpper(_r)) {
                                _changeCase = (stdgo.unicode.Unicode.toLower(_r) : GoString) + (_sel.__slice__((1 : GoInt)) : GoString);
                            } else {
                                _changeCase = (stdgo.unicode.Unicode.toUpper(_r) : GoString) + (_sel.__slice__((1 : GoInt)) : GoString);
                            };
                        };
                        {
                            {
                                var __tmp__ = lookupFieldOrMethod(_x._typ, _x._mode == ((5 : stdgo.go.types.Types.T_operandMode)), _check._pkg, _changeCase);
                                _obj = __tmp__._0;
                            };
                            if (_obj != null) {
                                _why = _why + ((", but does have " : GoString) + _changeCase);
                            };
                        };
                    };
                };
                _check._errorf(Go.asInterface(_e.sel), (76 : stdgo.internal.types.errors.Errors.Code), ("%s.%s undefined (%s)" : GoString), Go.toInterface(_x._expr), Go.toInterface(_sel), Go.toInterface(_why));
                @:goto "Error";
            };
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_obj) : Ref<Func>)) : Ref<Func>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.Func>), ok : false };
                }, _m = __tmp__.value, __50 = __tmp__.ok;
                if (_m != null && ((_m : Dynamic).__nil__ == null || !(_m : Dynamic).__nil__)) {
                    _check._objDecl(Go.asInterface(_m), null);
                };
            };
            if (_x._mode == ((3 : stdgo.go.types.Types.T_operandMode))) {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_obj) : Ref<Func>)) : Ref<Func>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.Func>), ok : false };
                }, _m = __tmp__.value, __51 = __tmp__.ok;
                if (_m == null || (_m : Dynamic).__nil__) {
                    _check._errorf(Go.asInterface(_e.sel), (76 : stdgo.internal.types.errors.Errors.Code), ("%s.%s undefined (type %s has no method %s)" : GoString), Go.toInterface(_x._expr), Go.toInterface(_sel), Go.toInterface(_x._typ), Go.toInterface(_sel));
                    @:goto "Error";
                };
                _check._recordSelection(_e, (2 : stdgo.go.types.Types.SelectionKind), _x._typ, Go.asInterface(_m), _index, _indirect);
                var _sig = (Go.typeAssert((Go.toInterface(_m._object._typ) : Ref<Signature>)) : Ref<Signature>);
                if (_sig._recv == null || (_sig._recv : Dynamic).__nil__) {
                    _check._error(Go.asInterface(_e), (11 : stdgo.internal.types.errors.Errors.Code), ("illegal cycle in method declaration" : GoString));
                    @:goto "Error";
                };
                var _params:Slice<Ref<Var>> = (null : Slice<Ref<stdgo.go.types.Types.Var>>);
                if (_sig._params != null && ((_sig._params : Dynamic).__nil__ == null || !(_sig._params : Dynamic).__nil__)) {
                    _params = _sig._params._vars;
                };
                var _name:GoString = Go.str();
                if ((_params.length > (0 : GoInt)) && (_params[(0 : GoInt)]._object._name != Go.str())) {
                    _name = _sig._recv._object._name;
                    if (_name == (Go.str())) {
                        _name = ("_" : GoString);
                    };
                };
                _params = ((new Slice<Ref<stdgo.go.types.Types.Var>>(1, 1, newVar(_sig._recv._object._pos, _sig._recv._object._pkg, _name, _x._typ)) : Slice<Ref<stdgo.go.types.Types.Var>>).__append__(..._params.__toArray__()));
                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                _x._typ = Go.asInterface((Go.setRef(({ _tparams : _sig._tparams, _params : newTuple(..._params.__toArray__()), _results : _sig._results, _variadic : _sig._variadic } : Signature)) : Ref<stdgo.go.types.Types.Signature>));
                _check._addDeclDep(Go.asInterface(_m));
            } else {
                {
                    final __type__ = _obj;
                    if (Go.typeEquals((__type__ : Ref<Var>))) {
                        var _obj:Ref<stdgo.go.types.Types.Var> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Var>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Var>) : __type__.__underlying__().value;
                        _check._recordSelection(_e, (0 : stdgo.go.types.Types.SelectionKind), _x._typ, Go.asInterface(_obj), _index, _indirect);
                        if ((_x._mode == (5 : stdgo.go.types.Types.T_operandMode)) || _indirect) {
                            _x._mode = (5 : stdgo.go.types.Types.T_operandMode);
                        } else {
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                        };
                        _x._typ = _obj._object._typ;
                    } else if (Go.typeEquals((__type__ : Ref<Func>))) {
                        var _obj:Ref<stdgo.go.types.Types.Func> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Func>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Func>) : __type__.__underlying__().value;
                        _check._recordSelection(_e, (1 : stdgo.go.types.Types.SelectionKind), _x._typ, Go.asInterface(_obj), _index, _indirect);
                        var _disabled:Bool = true;
                        if (!_disabled && false) {
                            var _typ:stdgo.go.types.Types.Type = _x._typ;
                            if (_x._mode == ((5 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    var __tmp__ = try {
                                        { value : (Go.typeAssert((Go.toInterface(_typ) : Ref<Pointer_>)) : Ref<Pointer_>), ok : true };
                                    } catch(_) {
                                        { value : (null : Ref<stdgo.go.types.Types.Pointer_>), ok : false };
                                    }, __52 = __tmp__.value, _ok = __tmp__.ok;
                                    if (!_ok && !isInterface(_typ)) {
                                        _typ = Go.asInterface((Go.setRef(({ _base : _typ } : Pointer_)) : Ref<stdgo.go.types.Types.Pointer_>));
                                    };
                                };
                            };
                            var _mset = newMethodSet(_typ);
                            {
                                var _m = _mset.lookup(_check._pkg, _sel);
                                if (((_m == null) || (_m : Dynamic).__nil__) || (Go.toInterface(_m._obj) != Go.toInterface(Go.asInterface(_obj)))) {
                                    _check._dump(("%v: (%s).%v -> %s" : GoString), Go.toInterface(Go.asInterface(_e.pos())), Go.toInterface(_typ), Go.toInterface(_obj._object._name), Go.toInterface(Go.asInterface(_m)));
                                    _check._dump(("%s\n" : GoString), Go.toInterface(Go.asInterface(_mset)));
                                    throw Go.toInterface(("method sets and lookup don\'t agree" : GoString));
                                };
                            };
                        };
                        _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                        var _sig:stdgo.go.types.Types.Signature = ((Go.typeAssert((Go.toInterface(_obj._object._typ) : Ref<Signature>)) : Ref<Signature>) : stdgo.go.types.Types.Signature)?.__copy__();
                        _sig._recv = null;
                        _x._typ = Go.asInterface((Go.setRef(_sig) : Ref<stdgo.go.types.Types.Signature>));
                        _check._addDeclDep(Go.asInterface(_obj));
                    } else {
                        var _obj:stdgo.go.types.Types.Object = __type__ == null ? (null : stdgo.go.types.Types.Object) : cast __type__;
                        _unreachable();
                    };
                };
            };
            _x._expr = Go.asInterface(_e);
            return;
            @:label("Error") _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            _x._expr = Go.asInterface(_e);
        });
    }
    /**
        // xlist is the list of type argument expressions supplied in the source code.
    **/
    @:keep
    static public function _arguments( _check:Ref<Checker>, _call:Ref<stdgo.go.ast.Ast.CallExpr>, _sig:Ref<Signature>, _targs:Slice<Type>, _args:Slice<Ref<T_operand>>, _xlist:Slice<stdgo.go.ast.Ast.Expr>):Ref<Signature> {
        var _rsig:Ref<Signature> = (null : Ref<stdgo.go.types.Types.Signature>);
        _rsig = _sig;
        for (__0 => _a in _args) {
            {
                final __value__ = _a._mode;
                if (__value__ == ((3 : stdgo.go.types.Types.T_operandMode))) {
                    _check._errorf(Go.asInterface(_a), (42 : stdgo.internal.types.errors.Errors.Code), ("%s used as value" : GoString), Go.toInterface(Go.asInterface(_a)));
                    return _rsig;
                } else if (__value__ == ((0 : stdgo.go.types.Types.T_operandMode))) {
                    return _rsig;
                };
            };
        };
        var _nargs:GoInt = (_args.length);
        var _npars:GoInt = _sig._params.len();
        var _ddd:Bool = _call.ellipsis.isValid();
        var _sigParams = _sig._params;
        var _adjusted:Bool = false;
        if (_sig._variadic) {
            if (_ddd) {
                if ((_call.args.length == (1 : GoInt)) && (_nargs > (1 : GoInt))) {
                    _check._errorf(Go.asInterface(_inNode(Go.asInterface(_call), _call.ellipsis)), (81 : stdgo.internal.types.errors.Errors.Code), ("cannot use ... with %d-valued %s" : GoString), Go.toInterface(_nargs), Go.toInterface(_call.args[(0 : GoInt)]));
                    return _rsig;
                };
            } else {
                if (_nargs >= (_npars - (1 : GoInt))) {
                    var _vars = new Slice<Ref<stdgo.go.types.Types.Var>>((_npars - (1 : GoInt) : GoInt).toBasic(), 0);
                    Go.copySlice(_vars, _sig._params._vars);
                    var _last = _sig._params._vars[(_npars - (1 : GoInt) : GoInt)];
                    var _typ:stdgo.go.types.Types.Type = (Go.typeAssert((Go.toInterface(_last._object._typ) : Ref<Slice_>)) : Ref<Slice_>)._elem;
                    while ((_vars.length) < _nargs) {
                        _vars = (_vars.__append__(newParam(_last._object._pos, _last._object._pkg, _last._object._name, _typ)));
                    };
                    _sigParams = newTuple(..._vars.__toArray__());
                    _adjusted = true;
                    _npars = _nargs;
                } else {
                    _npars--;
                };
            };
        } else {
            if (_ddd) {
                _check._errorf(Go.asInterface(_inNode(Go.asInterface(_call), _call.ellipsis)), (78 : stdgo.internal.types.errors.Errors.Code), ("cannot use ... in call to non-variadic %s" : GoString), Go.toInterface(_call.fun));
                return _rsig;
            };
        };
        if (_nargs != (_npars)) {
            var _at:T_positioner = Go.asInterface(_call);
            var _qualifier:GoString = ("not enough" : GoString);
            if (_nargs > _npars) {
                _at = _args[(_npars : GoInt)]._expr;
                _qualifier = ("too many" : GoString);
            } else {
                _at = Go.asInterface((_call.rparen : T_atPos));
            };
            var _params:Slice<Ref<Var>> = (null : Slice<Ref<stdgo.go.types.Types.Var>>);
            if (_sig._params != null && ((_sig._params : Dynamic).__nil__ == null || !(_sig._params : Dynamic).__nil__)) {
                _params = _sig._params._vars;
            };
            var _err = _newErrorf(_at, (126 : stdgo.internal.types.errors.Errors.Code), ("%s arguments in call to %s" : GoString), Go.toInterface(_qualifier), Go.toInterface(_call.fun));
            _err._errorf((0 : stdgo.go.token.Token.Pos), ("have %s" : GoString), Go.toInterface(_check._typesSummary(_operandTypes(_args), false)));
            _err._errorf((0 : stdgo.go.token.Token.Pos), ("want %s" : GoString), Go.toInterface(_check._typesSummary(_varTypes(_params), _sig._variadic)));
            _check._report(_err);
            return _rsig;
        };
        if (_sig.typeParams().len() > (0 : GoInt)) {
            if (!_check._allowVersion(_check._pkg, (1 : GoInt), (18 : GoInt))) {
                {
                    final __type__ = _call.fun;
                    if (Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexExpr>)) || Go.typeEquals((__type__ : Ref<stdgo.go.ast.Ast.IndexListExpr>))) {
                        var _ix = stdgo.go.internal.typeparams.Typeparams.unpackIndexExpr(_call.fun);
                        _check._softErrorf(Go.asInterface(_inNode(_call.fun, _ix.indexListExpr.lbrack)), (135 : stdgo.internal.types.errors.Errors.Code), ("function instantiation requires go1.18 or later" : GoString));
                    } else {
                        _check._softErrorf(Go.asInterface(_inNode(Go.asInterface(_call), _call.lparen)), (135 : stdgo.internal.types.errors.Errors.Code), ("implicit function instantiation requires go1.18 or later" : GoString));
                    };
                };
            };
            var _targs = _check._infer(Go.asInterface(_call), _sig.typeParams()._list(), _targs, _sigParams, _args);
            if (_targs == null) {
                return _rsig;
            };
            _rsig = _check._instantiateSignature(_call.pos(), _sig, _targs, _xlist);
            _assert(_rsig.typeParams().len() == ((0 : GoInt)));
            _check._recordInstance(_call.fun, _targs, Go.asInterface(_rsig));
            if (_adjusted) {
                _sigParams = (Go.typeAssert((Go.toInterface(_check._subst(_call.pos(), Go.asInterface(_sigParams), _makeSubstMap(_sig.typeParams()._list(), _targs), null, _check._context())) : Ref<Tuple>)) : Ref<Tuple>);
            } else {
                _sigParams = _rsig._params;
            };
        };
        if ((_args.length) > (0 : GoInt)) {
            var _context:GoString = _check._sprintf(("argument to %s" : GoString), Go.toInterface(_call.fun));
            for (_i => _a in _args) {
                _check._assignment(_a, _sigParams._vars[(_i : GoInt)]._object._typ, _context);
            };
        };
        return _rsig;
    }
    @:keep
    static public function _exprList( _check:Ref<Checker>, _elist:Slice<stdgo.go.ast.Ast.Expr>, _allowCommaOk:Bool):{ var _0 : Slice<Ref<T_operand>>; var _1 : Bool; } {
        var _xlist:Slice<Ref<T_operand>> = (null : Slice<Ref<stdgo.go.types.Types.T_operand>>), _commaOk:Bool = false;
        {
            var __switchIndex__ = -1;
            var __run__ = true;
            while (__run__) {
                __run__ = false;
                {
                    final __value__ = (_elist.length);
                    if (__value__ == ((0 : GoInt))) {
                        break;
                    } else if (__value__ == ((1 : GoInt))) {
                        var _e:stdgo.go.ast.Ast.Expr = _elist[(0 : GoInt)];
                        var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                        _check._multiExpr((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), _e);
                        {
                            var __tmp__ = try {
                                { value : (Go.typeAssert((Go.toInterface(_x._typ) : Ref<Tuple>)) : Ref<Tuple>), ok : true };
                            } catch(_) {
                                { value : (null : Ref<stdgo.go.types.Types.Tuple>), ok : false };
                            }, _t = __tmp__.value, _ok = __tmp__.ok;
                            if (_ok && (_x._mode != (0 : stdgo.go.types.Types.T_operandMode))) {
                                _xlist = new Slice<Ref<stdgo.go.types.Types.T_operand>>((_t.len() : GoInt).toBasic(), 0);
                                for (_i => _v in _t._vars) {
                                    _xlist[(_i : GoInt)] = (Go.setRef(({ _mode : (7 : stdgo.go.types.Types.T_operandMode), _expr : _e, _typ : _v._object._typ } : T_operand)) : Ref<stdgo.go.types.Types.T_operand>);
                                };
                                break;
                            };
                        };
                        _xlist = (new Slice<Ref<stdgo.go.types.Types.T_operand>>(1, 1, (Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>)) : Slice<Ref<stdgo.go.types.Types.T_operand>>);
                        if (_allowCommaOk && (((_x._mode == (6 : stdgo.go.types.Types.T_operandMode)) || (_x._mode == (8 : stdgo.go.types.Types.T_operandMode))) || (_x._mode == (9 : stdgo.go.types.Types.T_operandMode)))) {
                            var _x2 = (Go.setRef(({ _mode : (7 : stdgo.go.types.Types.T_operandMode), _expr : _e, _typ : Go.asInterface(typ[((19 : stdgo.go.types.Types.BasicKind) : GoInt)]) } : T_operand)) : Ref<stdgo.go.types.Types.T_operand>);
                            if (_x._mode == ((9 : stdgo.go.types.Types.T_operandMode))) {
                                _x2._typ = _universeError;
                            };
                            _xlist = (_xlist.__append__(_x2));
                            _commaOk = true;
                        };
                        break;
                    } else {
                        _xlist = new Slice<Ref<stdgo.go.types.Types.T_operand>>((_elist.length : GoInt).toBasic(), 0);
                        for (_i => _e in _elist) {
                            var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                            _check._expr((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), _e);
                            _xlist[(_i : GoInt)] = (Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>);
                        };
                    };
                };
                break;
            };
        };
        return { _0 : _xlist, _1 : _commaOk };
    }
    @:keep
    static public function _callExpr( _check:Ref<Checker>, _x:Ref<T_operand>, _call:Ref<stdgo.go.ast.Ast.CallExpr>):T_exprKind {
        var _ix = stdgo.go.internal.typeparams.Typeparams.unpackIndexExpr(_call.fun);
        if (_ix != null && ((_ix : Dynamic).__nil__ == null || !(_ix : Dynamic).__nil__)) {
            if (_check._indexExpr(_x, _ix)) {
                _assert(_x._mode == ((7 : stdgo.go.types.Types.T_operandMode)));
            } else {
                _ix = null;
            };
            _x._expr = _call.fun;
            _check._record(_x);
        } else {
            _check._exprOrType(_x, _call.fun, true);
        };
        {
            var __switchIndex__ = -1;
            var __run__ = true;
            while (__run__) {
                __run__ = false;
                {
                    final __value__ = _x._mode;
                    if (__value__ == ((0 : stdgo.go.types.Types.T_operandMode))) {
                        _check._use(..._call.args.__toArray__());
                        _x._expr = Go.asInterface(_call);
                        return (2 : stdgo.go.types.Types.T_exprKind);
                        break;
                    } else if (__value__ == ((3 : stdgo.go.types.Types.T_operandMode))) {
                        _check._nonGeneric(_x);
                        if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                            return (0 : stdgo.go.types.Types.T_exprKind);
                        };
                        var t:stdgo.go.types.Types.Type = _x._typ;
                        _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                        {
                            var _n:GoInt = (_call.args.length);
                            {
                                var __switchIndex__ = -1;
                                var __run__ = true;
                                while (__run__) {
                                    __run__ = false;
                                    {
                                        final __value__ = _n;
                                        if (__value__ == ((0 : GoInt))) {
                                            _check._errorf(Go.asInterface(_inNode(Go.asInterface(_call), _call.rparen)), (126 : stdgo.internal.types.errors.Errors.Code), ("missing argument in conversion to %s" : GoString), Go.toInterface(t));
                                            break;
                                        } else if (__value__ == ((1 : GoInt))) {
                                            _check._expr(_x, _call.args[(0 : GoInt)]);
                                            if (_x._mode != ((0 : stdgo.go.types.Types.T_operandMode))) {
                                                if (_call.ellipsis.isValid()) {
                                                    _check._errorf(_call.args[(0 : GoInt)], (77 : stdgo.internal.types.errors.Errors.Code), ("invalid use of ... in conversion to %s" : GoString), Go.toInterface(t));
                                                    break;
                                                };
                                                {
                                                    var __tmp__ = try {
                                                        { value : (Go.typeAssert((Go.toInterface(_under(t)) : Ref<Interface>)) : Ref<Interface>), ok : true };
                                                    } catch(_) {
                                                        { value : (null : Ref<stdgo.go.types.Types.Interface>), ok : false };
                                                    }, _t = __tmp__.value, __0 = __tmp__.ok;
                                                    if (((_t != null) && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) && !_isTypeParam(t)) {
                                                        if (!_t.isMethodSet()) {
                                                            _check._errorf(Go.asInterface(_call), (142 : stdgo.internal.types.errors.Errors.Code), ("cannot use interface %s in conversion (contains specific type constraints or is comparable)" : GoString), Go.toInterface(t));
                                                            break;
                                                        };
                                                    };
                                                };
                                                _check._conversion(_x, t);
                                            };
                                            break;
                                        } else {
                                            _check._use(..._call.args.__toArray__());
                                            _check._errorf(_call.args[(_n - (1 : GoInt) : GoInt)], (126 : stdgo.internal.types.errors.Errors.Code), ("too many arguments in conversion to %s" : GoString), Go.toInterface(t));
                                        };
                                    };
                                    break;
                                };
                            };
                        };
                        _x._expr = Go.asInterface(_call);
                        return (0 : stdgo.go.types.Types.T_exprKind);
                        break;
                    } else if (__value__ == ((2 : stdgo.go.types.Types.T_operandMode))) {
                        var _id:stdgo.go.types.Types.T_builtinId = _x._id;
                        if (!_check._builtin(_x, _call, _id)) {
                            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                        };
                        _x._expr = Go.asInterface(_call);
                        if ((_x._mode != (0 : stdgo.go.types.Types.T_operandMode)) && (_x._mode != (4 : stdgo.go.types.Types.T_operandMode))) {
                            _check._environment._hasCallOrRecv = true;
                        };
                        return _predeclaredFuncs[(_id : GoInt)]._kind;
                        break;
                    };
                };
                break;
            };
        };
        var _cgocall:Bool = _x._mode == ((10 : stdgo.go.types.Types.T_operandMode));
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(_coreType(_x._typ)) : Ref<Signature>)) : Ref<Signature>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.Signature>), ok : false };
        }, _sig = __tmp__.value, __9 = __tmp__.ok;
        if (_sig == null || (_sig : Dynamic).__nil__) {
            _check._errorf(Go.asInterface(_x), (127 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot call non-function %s" : GoString), Go.toInterface(Go.asInterface(_x)));
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            _x._expr = Go.asInterface(_call);
            return (2 : stdgo.go.types.Types.T_exprKind);
        };
        var _wasGeneric:Bool = _sig.typeParams().len() > (0 : GoInt);
        var _xlist:Slice<stdgo.go.ast.Ast.Expr> = (null : Slice<stdgo.go.ast.Ast.Expr>);
        var _targs:Slice<Type> = (null : Slice<stdgo.go.types.Types.Type>);
        if (_ix != null && ((_ix : Dynamic).__nil__ == null || !(_ix : Dynamic).__nil__)) {
            _xlist = _ix.indexListExpr.indices;
            _targs = _check._typeList(_xlist);
            if (_targs == null) {
                _check._use(..._call.args.__toArray__());
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                _x._expr = Go.asInterface(_call);
                return (2 : stdgo.go.types.Types.T_exprKind);
            };
            _assert((_targs.length) == ((_xlist.length)));
            var __0:GoInt = (_targs.length), __1:GoInt = _sig.typeParams().len(), _want:GoInt = __1, _got:GoInt = __0;
            if (_got > _want) {
                _check._errorf(_xlist[(_want : GoInt)], (137 : stdgo.internal.types.errors.Errors.Code), ("got %d type arguments but want %d" : GoString), Go.toInterface(_got), Go.toInterface(_want));
                _check._use(..._call.args.__toArray__());
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                _x._expr = Go.asInterface(_call);
                return (2 : stdgo.go.types.Types.T_exprKind);
            };
            if ((_got == _want) && (_want > (0 : GoInt))) {
                if (!_check._allowVersion(_check._pkg, (1 : GoInt), (18 : GoInt))) {
                    _check._softErrorf(Go.asInterface(_inNode(_call.fun, _ix.indexListExpr.lbrack)), (135 : stdgo.internal.types.errors.Errors.Code), ("function instantiation requires go1.18 or later" : GoString));
                };
                _sig = _check._instantiateSignature(_ix.pos(), _sig, _targs, _xlist);
                _assert(_sig.typeParams().len() == ((0 : GoInt)));
                _check._recordInstance(_ix.orig, _targs, Go.asInterface(_sig));
                _targs = (null : Slice<stdgo.go.types.Types.Type>);
                _xlist = (null : Slice<stdgo.go.ast.Ast.Expr>);
            };
        };
        var __tmp__ = _check._exprList(_call.args, false), _args:Slice<Ref<stdgo.go.types.Types.T_operand>> = __tmp__._0, __18:Bool = __tmp__._1;
        _sig = _check._arguments(_call, _sig, _targs, _args, _xlist);
        if (_wasGeneric && (_sig.typeParams().len() == (0 : GoInt))) {
            _check._recordTypeAndValue(_call.fun, (7 : stdgo.go.types.Types.T_operandMode), Go.asInterface(_sig), (null : stdgo.go.constant.Constant.Value));
        };
        {
            final __value__ = _sig._results.len();
            if (__value__ == ((0 : GoInt))) {
                _x._mode = (1 : stdgo.go.types.Types.T_operandMode);
            } else if (__value__ == ((1 : GoInt))) {
                if (_cgocall) {
                    _x._mode = (9 : stdgo.go.types.Types.T_operandMode);
                } else {
                    _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                };
                _x._typ = _sig._results._vars[(0 : GoInt)]._object._typ;
            } else {
                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                _x._typ = Go.asInterface(_sig._results);
            };
        };
        _x._expr = Go.asInterface(_call);
        _check._environment._hasCallOrRecv = true;
        if (((_x._mode == (7 : stdgo.go.types.Types.T_operandMode)) && (_sig.typeParams().len() > (0 : GoInt))) && _isParameterized(_sig.typeParams()._list(), _x._typ)) {
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
        };
        return (2 : stdgo.go.types.Types.T_exprKind);
    }
    @:keep
    static public function _instantiateSignature( _check:Ref<Checker>, _pos:stdgo.go.token.Token.Pos, _typ:Ref<Signature>, _targs:Slice<Type>, _xlist:Slice<stdgo.go.ast.Ast.Expr>):Ref<Signature> {
        var __deferstack__:Array<Void -> Void> = [];
        var _res:Ref<Signature> = (null : Ref<stdgo.go.types.Types.Signature>);
        try {
            _assert(_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__));
            _assert((_targs.length) == (_typ.typeParams().len()));
            if (false) {
                _check._trace(_pos, ("-- instantiating signature %s with %s" : GoString), Go.toInterface(Go.asInterface(_typ)), Go.toInterface(_targs));
                _check._indent++;
                __deferstack__.unshift(() -> {
                    var a = function():Void {
                        _check._indent--;
                        _check._trace(_pos, ("=> %s (under = %s)" : GoString), Go.toInterface(Go.asInterface(_res)), Go.toInterface(_res.underlying()));
                    };
                    a();
                });
            };
            var _inst = (Go.typeAssert((Go.toInterface(_check._instance(_pos, Go.asInterface(_typ), _targs, null, _check._context())) : Ref<Signature>)) : Ref<Signature>);
            _assert((_xlist.length) <= (_targs.length));
            _check._later(function():Void {
                var _tparams = _typ.typeParams()._list();
                {
                    var __tmp__ = _check._verify(_pos, _tparams, _targs, _check._context()), _i:GoInt = __tmp__._0, _err:Error = __tmp__._1;
                    if (_err != null) {
                        var _pos:stdgo.go.token.Token.Pos = _pos;
                        if (_i < (_xlist.length)) {
                            _pos = _xlist[(_i : GoInt)].pos();
                        };
                        _check._softErrorf(Go.asInterface((_pos : T_atPos)), (139 : stdgo.internal.types.errors.Errors.Code), ("%s" : GoString), Go.toInterface(_err));
                    } else {
                        _check._mono._recordInstance(_check._pkg, _pos, _tparams, _targs, _xlist);
                    };
                };
            })._describef(Go.asInterface((_pos : T_atPos)), ("verify instantiation" : GoString));
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _inst;
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return _res;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return _res;
        };
    }
    /**
        // funcInst type-checks a function instantiation inst and returns the result in x.
        // The operand x must be the evaluation of inst.X and its type must be a signature.
    **/
    @:keep
    static public function _funcInst( _check:Ref<Checker>, _x:Ref<T_operand>, _ix:Ref<stdgo.go.internal.typeparams.Typeparams.IndexExpr>):Void {
        if (!_check._allowVersion(_check._pkg, (1 : GoInt), (18 : GoInt))) {
            _check._softErrorf(Go.asInterface(_inNode(_ix.orig, _ix.indexListExpr.lbrack)), (135 : stdgo.internal.types.errors.Errors.Code), ("function instantiation requires go1.18 or later" : GoString));
        };
        var _targs = _check._typeList(_ix.indexListExpr.indices);
        if (_targs == null) {
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            _x._expr = _ix.orig;
            return;
        };
        _assert((_targs.length) == ((_ix.indexListExpr.indices.length)));
        var _sig = (Go.typeAssert((Go.toInterface(_x._typ) : Ref<Signature>)) : Ref<Signature>);
        var __0:GoInt = (_targs.length), __1:GoInt = _sig.typeParams().len(), _want:GoInt = __1, _got:GoInt = __0;
        if (_got > _want) {
            _check._errorf(_ix.indexListExpr.indices[(_got - (1 : GoInt) : GoInt)], (137 : stdgo.internal.types.errors.Errors.Code), ("got %d type arguments but want %d" : GoString), Go.toInterface(_got), Go.toInterface(_want));
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            _x._expr = _ix.orig;
            return;
        };
        if (_got < _want) {
            _targs = _check._infer(_ix.orig, _sig.typeParams()._list(), _targs, null, (null : Slice<Ref<stdgo.go.types.Types.T_operand>>));
            if (_targs == null) {
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                _x._expr = _ix.orig;
                return;
            };
            _got = (_targs.length);
        };
        _assert(_got == (_want));
        _sig = _check._instantiateSignature(_x.pos(), _sig, _targs, _ix.indexListExpr.indices);
        _assert(_sig.typeParams().len() == ((0 : GoInt)));
        _check._recordInstance(_ix.orig, _targs, Go.asInterface(_sig));
        _x._typ = Go.asInterface(_sig);
        _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
        _x._expr = _ix.orig;
    }
    /**
        // applyTypeFunc applies f to x. If x is a type parameter,
        // the result is a type parameter constrained by an new
        // interface bound. The type bounds for that interface
        // are computed by applying f to each of the type bounds
        // of x. If any of these applications of f return nil,
        // applyTypeFunc returns nil.
        // If x is not a type parameter, the result is f(x).
    **/
    @:keep
    static public function _applyTypeFunc( _check:Ref<Checker>, _f:Type -> Type, _x:Ref<T_operand>, _id:T_builtinId):Type {
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_x._typ) : Ref<TypeParam>)) : Ref<TypeParam>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.TypeParam>), ok : false };
            }, _tp = __tmp__.value, __0 = __tmp__.ok;
            if (_tp != null && ((_tp : Dynamic).__nil__ == null || !(_tp : Dynamic).__nil__)) {
                var _terms:Slice<Ref<Term>> = (null : Slice<Ref<stdgo.go.types.Types.Term>>);
                if (!_tp._is(function(_t:Ref<T_term>):Bool {
                    if (_t == null || (_t : Dynamic).__nil__) {
                        return false;
                    };
                    {
                        var _r:stdgo.go.types.Types.Type = _f(_t._typ);
                        if (_r != null) {
                            _terms = (_terms.__append__(newTerm(_t._tilde, _r)));
                            return true;
                        };
                    };
                    return false;
                })) {
                    return (null : stdgo.go.types.Types.Type);
                };
                var _code:Code = ((0 : GoInt) : stdgo.internal.types.errors.Errors.Code);
                {
                    final __value__ = _id;
                    if (__value__ == ((14 : stdgo.go.types.Types.T_builtinId))) {
                        _code = (93 : stdgo.internal.types.errors.Errors.Code);
                    } else if (__value__ == ((7 : stdgo.go.types.Types.T_builtinId))) {
                        _code = (89 : stdgo.internal.types.errors.Errors.Code);
                    } else if (__value__ == ((4 : stdgo.go.types.Types.T_builtinId))) {
                        _code = (87 : stdgo.internal.types.errors.Errors.Code);
                    } else {
                        _unreachable();
                    };
                };
                _check._softErrorf(Go.asInterface(_x), _code, ("%s not supported as argument to %s for go1.18 (see issue #50937)" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(_predeclaredFuncs[(_id : GoInt)]._name));
                var _tpar = newTypeName((0 : stdgo.go.token.Token.Pos), _check._pkg, _tp._obj._object._name, (null : stdgo.go.types.Types.Type));
                var _ptyp = _check._newTypeParam(_tpar, Go.asInterface(newInterfaceType((null : Slice<Ref<stdgo.go.types.Types.Func>>), (new Slice<stdgo.go.types.Types.Type>(1, 1, Go.asInterface(newUnion(_terms))) : Slice<stdgo.go.types.Types.Type>))));
                _ptyp._index = _tp._index;
                return Go.asInterface(_ptyp);
            };
        };
        return _f(_x._typ);
    }
    /**
        // builtin type-checks a call to the built-in specified by id and
        // reports whether the call is valid, with *x holding the result;
        // but x.expr is not set. If the call is invalid, the result is
        // false, and *x is undefined.
    **/
    @:keep
    static public function _builtin( _check:Ref<Checker>, _x:Ref<T_operand>, _call:Ref<stdgo.go.ast.Ast.CallExpr>, _id:T_builtinId):Bool {
        var __deferstack__:Array<Void -> Void> = [];
        var _0:Bool = false;
        try {
            var _bin:T__struct_7 = {
                final x = _predeclaredFuncs[(_id : GoInt)];
                ({ _name : x._name, _nargs : x._nargs, _variadic : x._variadic, _kind : x._kind } : T__struct_7);
            };
            if (_call.ellipsis.isValid() && (_id != (0 : stdgo.go.types.Types.T_builtinId))) {
                _check._errorf(Go.asInterface((_call.ellipsis : T_atPos)), (81 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: invalid use of ... with built-in %s" : GoString), Go.toInterface(_bin._name));
                _check._use(..._call.args.__toArray__());
                return _0;
            };
            if ((_id == (8 : stdgo.go.types.Types.T_builtinId)) || (_id == (1 : stdgo.go.types.Types.T_builtinId))) {
                {
                    var _a0 = _check._environment._hasCallOrRecv;
                    __deferstack__.unshift(() -> {
                        var a = function(_b:Bool):Void {
                            _check._environment._hasCallOrRecv = _b;
                        };
                        a(_a0);
                    });
                };
                _check._environment._hasCallOrRecv = false;
            };
            var _arg:(Ref<T_operand>, GoInt) -> Void = null;
            var _nargs:GoInt = (_call.args.length);
            {
                final __value__ = _id;
                if (__value__ == ((9 : stdgo.go.types.Types.T_builtinId)) || __value__ == ((10 : stdgo.go.types.Types.T_builtinId)) || __value__ == ((18 : stdgo.go.types.Types.T_builtinId)) || __value__ == ((25 : stdgo.go.types.Types.T_builtinId))) {} else {
                    var __tmp__ = _check._exprList(_call.args, false), _xlist:Slice<Ref<stdgo.go.types.Types.T_operand>> = __tmp__._0, __16:Bool = __tmp__._1;
                    _arg = function(_x:Ref<T_operand>, _i:GoInt):Void {
                        {
                            var __tmp__ = (_xlist[(_i : GoInt)] : stdgo.go.types.Types.T_operand)?.__copy__();
                            _x._mode = __tmp__._mode;
                            _x._expr = __tmp__._expr;
                            _x._typ = __tmp__._typ;
                            _x._val = __tmp__._val;
                            _x._id = __tmp__._id;
                        };
                    };
                    _nargs = (_xlist.length);
                    if (_nargs > (0 : GoInt)) {
                        _arg(_x, (0 : GoInt));
                        if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _0;
                            };
                        };
                    };
                };
            };
            {
                var _msg:GoString = Go.str();
                if (_nargs < _bin._nargs) {
                    _msg = ("not enough" : GoString);
                } else if (!_bin._variadic && (_nargs > _bin._nargs)) {
                    _msg = ("too many" : GoString);
                };
                if (_msg != (Go.str())) {
                    _check._errorf(Go.asInterface(_inNode(Go.asInterface(_call), _call.rparen)), (126 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: %s arguments for %s (expected %d, found %d)" : GoString), Go.toInterface(_msg), Go.toInterface(Go.asInterface(_call)), Go.toInterface(_bin._nargs), Go.toInterface(_nargs));
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _0;
                    };
                };
            };
            {
                var __switchIndex__ = -1;
                var __run__ = true;
                while (__run__) {
                    __run__ = false;
                    {
                        final __value__ = _id;
                        if (__value__ == ((0 : stdgo.go.types.Types.T_builtinId))) {
                            var s:stdgo.go.types.Types.Type = _x._typ;
                            var t:Type = (null : stdgo.go.types.Types.Type);
                            {
                                var __tmp__ = try {
                                    { value : (Go.typeAssert((Go.toInterface(_coreType(s)) : Ref<Slice_>)) : Ref<Slice_>), ok : true };
                                } catch(_) {
                                    { value : (null : Ref<stdgo.go.types.Types.Slice_>), ok : false };
                                }, _s = __tmp__.value, __17 = __tmp__.ok;
                                if (_s != null && ((_s : Dynamic).__nil__ == null || !(_s : Dynamic).__nil__)) {
                                    t = _s._elem;
                                } else {
                                    var _cause:GoString = ("" : GoString);
                                    if (_x._isNil()) {
                                        _cause = ("have untyped nil" : GoString);
                                    } else if (_isTypeParam(s)) {
                                        {
                                            var _u:stdgo.go.types.Types.Type = _coreType(s);
                                            if (_u != null) {
                                                _cause = _check._sprintf(("%s has core type %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(_u));
                                            } else {
                                                _cause = _check._sprintf(("%s has no core type" : GoString), Go.toInterface(Go.asInterface(_x)));
                                            };
                                        };
                                    } else {
                                        _cause = _check._sprintf(("have %s" : GoString), Go.toInterface(Go.asInterface(_x)));
                                    };
                                    _check._errorf(Go.asInterface(_x), (83 : stdgo.internal.types.errors.Errors.Code), ("first argument to append must be a slice; %s" : GoString), Go.toInterface(_cause));
                                    {
                                        for (defer in __deferstack__) {
                                            defer();
                                        };
                                        return _0;
                                    };
                                };
                            };
                            var _alist = (new Slice<stdgo.go.types.Types.T_operand>(1, 1, (_x : stdgo.go.types.Types.T_operand).__copy__()) : Slice<stdgo.go.types.Types.T_operand>);
                            if ((_nargs == (2 : GoInt)) && _call.ellipsis.isValid()) {
                                {
                                    var __tmp__ = _x._assignableTo(_check, Go.asInterface(newSlice(_universeByte)), (null : Pointer<GoString>)), _ok:Bool = __tmp__._0, __18:stdgo.internal.types.errors.Errors.Code = __tmp__._1;
                                    if (_ok) {
                                        _arg(_x, (1 : GoInt));
                                        if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                            {
                                                for (defer in __deferstack__) {
                                                    defer();
                                                };
                                                return _0;
                                            };
                                        };
                                        {
                                            var _t:stdgo.go.types.Types.Type = _coreString(_x._typ);
                                            if ((_t != null) && _isString(_t)) {
                                                if (_check.info.types != null) {
                                                    var _sig = _makeSig(s, s, _x._typ);
                                                    _sig._variadic = true;
                                                    _check._recordBuiltinType(_call.fun, _sig);
                                                };
                                                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                                                _x._typ = s;
                                                break;
                                            };
                                        };
                                        _alist = (_alist.__append__((_x : stdgo.go.types.Types.T_operand).__copy__()));
                                    };
                                };
                            };
                            var _sig = _makeSig(s, s, Go.asInterface(newSlice(t)));
                            _sig._variadic = true;
                            var _xlist:Slice<Ref<T_operand>> = (null : Slice<Ref<stdgo.go.types.Types.T_operand>>);
                            for (_i in 0 ... _alist.length.toBasic()) {
                                _xlist = (_xlist.__append__((Go.setRef(_alist[(_i : GoInt)]) : Ref<stdgo.go.types.Types.T_operand>)));
                            };
                            {
                                var _i:GoInt = (_alist.length);
                                Go.cfor(_i < _nargs, _i++, {
                                    var _x:T_operand = ({} : stdgo.go.types.Types.T_operand);
                                    _arg((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>), _i);
                                    _xlist = (_xlist.__append__((Go.setRef(_x) : Ref<stdgo.go.types.Types.T_operand>)));
                                });
                            };
                            _check._arguments(_call, _sig, (null : Slice<stdgo.go.types.Types.Type>), _xlist, (null : Slice<stdgo.go.ast.Ast.Expr>));
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = s;
                            if (_check.info.types != null) {
                                _check._recordBuiltinType(_call.fun, _sig);
                            };
                            break;
                        } else if (__value__ == ((1 : stdgo.go.types.Types.T_builtinId)) || __value__ == ((8 : stdgo.go.types.Types.T_builtinId))) {
                            var _mode:stdgo.go.types.Types.T_operandMode = (0 : stdgo.go.types.Types.T_operandMode);
                            var _val:stdgo.go.constant.Constant.Value = (null : stdgo.go.constant.Constant.Value);
                            {
                                final __type__ = _arrayPtrDeref(_under(_x._typ));
                                {
                                    var __bool__ = true;
                                    while (__bool__) {
                                        __bool__ = false;
                                        if (Go.typeEquals((__type__ : Ref<Basic>))) {
                                            var _t:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                                            if (_isString(Go.asInterface(_t)) && (_id == (8 : stdgo.go.types.Types.T_builtinId))) {
                                                if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
                                                    _mode = (4 : stdgo.go.types.Types.T_operandMode);
                                                    _val = stdgo.go.constant.Constant.makeInt64((stdgo.go.constant.Constant.stringVal(_x._val).length : GoInt64));
                                                } else {
                                                    _mode = (7 : stdgo.go.types.Types.T_operandMode);
                                                };
                                            };
                                        } else if (Go.typeEquals((__type__ : Ref<Array_>))) {
                                            var _t:Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                                            _mode = (7 : stdgo.go.types.Types.T_operandMode);
                                            if (!_check._environment._hasCallOrRecv) {
                                                _mode = (4 : stdgo.go.types.Types.T_operandMode);
                                                if (_t._len >= (0i64 : GoInt64)) {
                                                    _val = stdgo.go.constant.Constant.makeInt64(_t._len);
                                                } else {
                                                    _val = stdgo.go.constant.Constant.makeUnknown();
                                                };
                                            };
                                        } else if (Go.typeEquals((__type__ : Ref<Slice_>)) || Go.typeEquals((__type__ : Ref<Chan>))) {
                                            var _t:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                                            _mode = (7 : stdgo.go.types.Types.T_operandMode);
                                        } else if (Go.typeEquals((__type__ : Ref<Map_>))) {
                                            var _t:Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                                            if (_id == ((8 : stdgo.go.types.Types.T_builtinId))) {
                                                _mode = (7 : stdgo.go.types.Types.T_operandMode);
                                            };
                                        } else if (Go.typeEquals((__type__ : Ref<Interface>))) {
                                            var _t:Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                                            if (!_isTypeParam(_x._typ)) {
                                                break;
                                            };
                                            if (_t._typeSet()._underIs(function(_t:Type):Bool {
                                                {
                                                    final __type__ = _arrayPtrDeref(_t);
                                                    if (Go.typeEquals((__type__ : Ref<Basic>))) {
                                                        var _t:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                                                        if (_isString(Go.asInterface(_t)) && (_id == (8 : stdgo.go.types.Types.T_builtinId))) {
                                                            return true;
                                                        };
                                                    } else if (Go.typeEquals((__type__ : Ref<Array_>)) || Go.typeEquals((__type__ : Ref<Slice_>)) || Go.typeEquals((__type__ : Ref<Chan>))) {
                                                        var _t:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                                                        return true;
                                                    } else if (Go.typeEquals((__type__ : Ref<Map_>))) {
                                                        var _t:Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                                                        if (_id == ((8 : stdgo.go.types.Types.T_builtinId))) {
                                                            return true;
                                                        };
                                                    };
                                                };
                                                return false;
                                            })) {
                                                _mode = (7 : stdgo.go.types.Types.T_operandMode);
                                            };
                                        };
                                        break;
                                    };
                                };
                            };
                            if ((_mode == (0 : stdgo.go.types.Types.T_operandMode)) && (Go.toInterface(_under(_x._typ)) != Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                                var _code:stdgo.internal.types.errors.Errors.Code = (84 : stdgo.internal.types.errors.Errors.Code);
                                if (_id == ((8 : stdgo.go.types.Types.T_builtinId))) {
                                    _code = (90 : stdgo.internal.types.errors.Errors.Code);
                                };
                                _check._errorf(Go.asInterface(_x), _code, ("invalid argument: %s for %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(_bin._name));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            if ((_check.info.types != null) && (_mode != (4 : stdgo.go.types.Types.T_operandMode))) {
                                _check._recordBuiltinType(_call.fun, _makeSig(Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : GoInt)]), _x._typ));
                            };
                            _x._mode = _mode;
                            _x._typ = Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                            _x._val = _val;
                            break;
                        } else if (__value__ == ((2 : stdgo.go.types.Types.T_builtinId))) {
                            if (!_check._allowVersion(_check._pkg, (1 : GoInt), (21 : GoInt))) {
                                _check._error(_call.fun, (135 : stdgo.internal.types.errors.Errors.Code), ("clear requires go1.21 or later" : GoString));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            if (!_underIs(_x._typ, function(_u:Type):Bool {
                                {
                                    final __type__ = _u;
                                    if (Go.typeEquals((__type__ : Ref<Map_>)) || Go.typeEquals((__type__ : Ref<Slice_>))) {
                                        var _u:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                                        return true;
                                    } else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
                                        var _u:Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                                        {
                                            var __tmp__ = try {
                                                { value : (Go.typeAssert((Go.toInterface(_under(_u._base)) : Ref<Array_>)) : Ref<Array_>), ok : true };
                                            } catch(_) {
                                                { value : (null : Ref<stdgo.go.types.Types.Array_>), ok : false };
                                            }, __0 = __tmp__.value, _ok = __tmp__.ok;
                                            if (_ok) {
                                                return true;
                                            };
                                        };
                                    };
                                };
                                _check._errorf(Go.asInterface(_x), (148 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: cannot clear %s: argument must be (or constrained by) map, slice, or array pointer" : GoString), Go.toInterface(Go.asInterface(_x)));
                                return false;
                            })) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _x._mode = (1 : stdgo.go.types.Types.T_operandMode);
                            if (_check.info.types != null) {
                                _check._recordBuiltinType(_call.fun, _makeSig((null : stdgo.go.types.Types.Type), _x._typ));
                            };
                            break;
                        } else if (__value__ == ((3 : stdgo.go.types.Types.T_builtinId))) {
                            if (!_underIs(_x._typ, function(_u:Type):Bool {
                                var __tmp__ = try {
                                    { value : (Go.typeAssert((Go.toInterface(_u) : Ref<Chan>)) : Ref<Chan>), ok : true };
                                } catch(_) {
                                    { value : (null : Ref<stdgo.go.types.Types.Chan>), ok : false };
                                }, _uch = __tmp__.value, __0 = __tmp__.ok;
                                if (_uch == null || (_uch : Dynamic).__nil__) {
                                    _check._errorf(Go.asInterface(_x), (85 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot close non-channel %s" : GoString), Go.toInterface(Go.asInterface(_x)));
                                    return false;
                                };
                                if (_uch._dir == ((2 : stdgo.go.types.Types.ChanDir))) {
                                    _check._errorf(Go.asInterface(_x), (85 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: cannot close receive-only channel %s" : GoString), Go.toInterface(Go.asInterface(_x)));
                                    return false;
                                };
                                return true;
                            })) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _x._mode = (1 : stdgo.go.types.Types.T_operandMode);
                            if (_check.info.types != null) {
                                _check._recordBuiltinType(_call.fun, _makeSig((null : stdgo.go.types.Types.Type), _x._typ));
                            };
                            break;
                        } else if (__value__ == ((4 : stdgo.go.types.Types.T_builtinId))) {
                            var _y:T_operand = ({} : stdgo.go.types.Types.T_operand);
                            _arg((Go.setRef(_y) : Ref<stdgo.go.types.Types.T_operand>), (1 : GoInt));
                            if (_y._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            var _d:GoInt = (0 : GoInt);
                            if (_isUntyped(_x._typ)) {
                                _d = _d | ((1 : GoInt));
                            };
                            if (_isUntyped(_y._typ)) {
                                _d = _d | ((2 : GoInt));
                            };
                            {
                                final __value__ = _d;
                                if (__value__ == ((0 : GoInt))) {} else if (__value__ == ((1 : GoInt))) {
                                    _check._convertUntyped(_x, _y._typ);
                                } else if (__value__ == ((2 : GoInt))) {
                                    _check._convertUntyped((Go.setRef(_y) : Ref<stdgo.go.types.Types.T_operand>), _x._typ);
                                } else if (__value__ == ((3 : GoInt))) {
                                    if ((_x._mode == (4 : stdgo.go.types.Types.T_operandMode)) && (_y._mode == (4 : stdgo.go.types.Types.T_operandMode))) {
                                        var _toFloat = function(_x:Ref<T_operand>):Void {
                                            if (_isNumeric(_x._typ) && (stdgo.go.constant.Constant.sign(stdgo.go.constant.Constant.imag(_x._val)) == (0 : GoInt))) {
                                                _x._typ = Go.asInterface(typ[((22 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                                            };
                                        };
                                        _toFloat(_x);
                                        _toFloat((Go.setRef(_y) : Ref<stdgo.go.types.Types.T_operand>));
                                    } else {
                                        _check._convertUntyped(_x, Go.asInterface(typ[((14 : stdgo.go.types.Types.BasicKind) : GoInt)]));
                                        _check._convertUntyped((Go.setRef(_y) : Ref<stdgo.go.types.Types.T_operand>), Go.asInterface(typ[((14 : stdgo.go.types.Types.BasicKind) : GoInt)]));
                                    };
                                };
                            };
                            if ((_x._mode == (0 : stdgo.go.types.Types.T_operandMode)) || (_y._mode == (0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            if (!identical(_x._typ, _y._typ)) {
                                _check._errorf(Go.asInterface(_x), (87 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: mismatched types %s and %s" : GoString), Go.toInterface(_x._typ), Go.toInterface(_y._typ));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            var _f:stdgo.go.types.Types.Type -> stdgo.go.types.Types.Type = function(_typ:Type):Type {
                                _assert(!_isTypeParam(_typ));
                                {
                                    var __tmp__ = try {
                                        { value : (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Basic>)) : Ref<Basic>), ok : true };
                                    } catch(_) {
                                        { value : (null : Ref<stdgo.go.types.Types.Basic>), ok : false };
                                    }, _t = __tmp__.value, __0 = __tmp__.ok;
                                    if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                                        {
                                            final __value__ = _t._kind;
                                            if (__value__ == ((13 : stdgo.go.types.Types.BasicKind))) {
                                                return Go.asInterface(typ[((15 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                                            } else if (__value__ == ((14 : stdgo.go.types.Types.BasicKind))) {
                                                return Go.asInterface(typ[((16 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                                            } else if (__value__ == ((22 : stdgo.go.types.Types.BasicKind))) {
                                                return Go.asInterface(typ[((23 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                                            };
                                        };
                                    };
                                };
                                return (null : stdgo.go.types.Types.Type);
                            };
                            var _resTyp:stdgo.go.types.Types.Type = _check._applyTypeFunc(_f, _x, _id);
                            if (_resTyp == null) {
                                _check._errorf(Go.asInterface(_x), (87 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: arguments have type %s, expected floating-point" : GoString), Go.toInterface(_x._typ));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            if ((_x._mode == (4 : stdgo.go.types.Types.T_operandMode)) && (_y._mode == (4 : stdgo.go.types.Types.T_operandMode))) {
                                _x._val = stdgo.go.constant.Constant.binaryOp(stdgo.go.constant.Constant.toFloat(_x._val), (12 : stdgo.go.token.Token.Token), stdgo.go.constant.Constant.makeImag(stdgo.go.constant.Constant.toFloat(_y._val)));
                            } else {
                                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            };
                            if ((_check.info.types != null) && (_x._mode != (4 : stdgo.go.types.Types.T_operandMode))) {
                                _check._recordBuiltinType(_call.fun, _makeSig(_resTyp, _x._typ, _x._typ));
                            };
                            _x._typ = _resTyp;
                            break;
                        } else if (__value__ == ((5 : stdgo.go.types.Types.T_builtinId))) {
                            var __tmp__ = try {
                                { value : (Go.typeAssert((Go.toInterface(_coreType(_x._typ)) : Ref<Slice_>)) : Ref<Slice_>), ok : true };
                            } catch(_) {
                                { value : (null : Ref<stdgo.go.types.Types.Slice_>), ok : false };
                            }, _dst = __tmp__.value, __83 = __tmp__.ok;
                            var _y:T_operand = ({} : stdgo.go.types.Types.T_operand);
                            _arg((Go.setRef(_y) : Ref<stdgo.go.types.Types.T_operand>), (1 : GoInt));
                            if (_y._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            var _src0:stdgo.go.types.Types.Type = _coreString(_y._typ);
                            if ((_src0 != null) && _isString(_src0)) {
                                _src0 = Go.asInterface(newSlice(_universeByte));
                            };
                            var __tmp__ = try {
                                { value : (Go.typeAssert((Go.toInterface(_src0) : Ref<Slice_>)) : Ref<Slice_>), ok : true };
                            } catch(_) {
                                { value : (null : Ref<stdgo.go.types.Types.Slice_>), ok : false };
                            }, _src = __tmp__.value, __84 = __tmp__.ok;
                            if (((_dst == null) || (_dst : Dynamic).__nil__) || ((_src == null) || (_src : Dynamic).__nil__)) {
                                _check._errorf(Go.asInterface(_x), (86 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: copy expects slice arguments; found %s and %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface((Go.setRef(_y) : Ref<stdgo.go.types.Types.T_operand>))));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            if (!identical(_dst._elem, _src._elem)) {
                                _check._errorf(Go.asInterface(_x), (86 : stdgo.internal.types.errors.Errors.Code), ("arguments to copy %s and %s have different element types %s and %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface((Go.setRef(_y) : Ref<stdgo.go.types.Types.T_operand>))), Go.toInterface(_dst._elem), Go.toInterface(_src._elem));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            if (_check.info.types != null) {
                                _check._recordBuiltinType(_call.fun, _makeSig(Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : GoInt)]), _x._typ, _y._typ));
                            };
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = Go.asInterface(typ[((2 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                            break;
                        } else if (__value__ == ((6 : stdgo.go.types.Types.T_builtinId))) {
                            var _map_:stdgo.go.types.Types.Type = _x._typ;
                            var _key:Type = (null : stdgo.go.types.Types.Type);
                            if (!_underIs(_map_, function(_u:Type):Bool {
                                var __tmp__ = try {
                                    { value : (Go.typeAssert((Go.toInterface(_u) : Ref<Map_>)) : Ref<Map_>), ok : true };
                                } catch(_) {
                                    { value : (null : Ref<stdgo.go.types.Types.Map_>), ok : false };
                                }, _map_ = __tmp__.value, __0 = __tmp__.ok;
                                if (_map_ == null || (_map_ : Dynamic).__nil__) {
                                    _check._errorf(Go.asInterface(_x), (88 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: %s is not a map" : GoString), Go.toInterface(Go.asInterface(_x)));
                                    return false;
                                };
                                if ((_key != null) && !identical(_map_._key, _key)) {
                                    _check._errorf(Go.asInterface(_x), (88 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: maps of %s must have identical key types" : GoString), Go.toInterface(Go.asInterface(_x)));
                                    return false;
                                };
                                _key = _map_._key;
                                return true;
                            })) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _arg(_x, (1 : GoInt));
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _check._assignment(_x, _key, ("argument to delete" : GoString));
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _x._mode = (1 : stdgo.go.types.Types.T_operandMode);
                            if (_check.info.types != null) {
                                _check._recordBuiltinType(_call.fun, _makeSig((null : stdgo.go.types.Types.Type), _map_, _key));
                            };
                            break;
                        } else if (__value__ == ((7 : stdgo.go.types.Types.T_builtinId)) || __value__ == ((14 : stdgo.go.types.Types.T_builtinId))) {
                            if (_isUntyped(_x._typ)) {
                                if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
                                    if (_isNumeric(_x._typ)) {
                                        _x._typ = Go.asInterface(typ[((23 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                                    };
                                } else {
                                    _check._convertUntyped(_x, Go.asInterface(typ[((16 : stdgo.go.types.Types.BasicKind) : GoInt)]));
                                    if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                        {
                                            for (defer in __deferstack__) {
                                                defer();
                                            };
                                            return _0;
                                        };
                                    };
                                };
                            };
                            var _f:stdgo.go.types.Types.Type -> stdgo.go.types.Types.Type = function(_typ:Type):Type {
                                _assert(!_isTypeParam(_typ));
                                {
                                    var __tmp__ = try {
                                        { value : (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Basic>)) : Ref<Basic>), ok : true };
                                    } catch(_) {
                                        { value : (null : Ref<stdgo.go.types.Types.Basic>), ok : false };
                                    }, _t = __tmp__.value, __0 = __tmp__.ok;
                                    if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                                        {
                                            final __value__ = _t._kind;
                                            if (__value__ == ((15 : stdgo.go.types.Types.BasicKind))) {
                                                return Go.asInterface(typ[((13 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                                            } else if (__value__ == ((16 : stdgo.go.types.Types.BasicKind))) {
                                                return Go.asInterface(typ[((14 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                                            } else if (__value__ == ((23 : stdgo.go.types.Types.BasicKind))) {
                                                return Go.asInterface(typ[((22 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                                            };
                                        };
                                    };
                                };
                                return (null : stdgo.go.types.Types.Type);
                            };
                            var _resTyp:stdgo.go.types.Types.Type = _check._applyTypeFunc(_f, _x, _id);
                            if (_resTyp == null) {
                                var _code:stdgo.internal.types.errors.Errors.Code = (89 : stdgo.internal.types.errors.Errors.Code);
                                if (_id == ((14 : stdgo.go.types.Types.T_builtinId))) {
                                    _code = (93 : stdgo.internal.types.errors.Errors.Code);
                                };
                                _check._errorf(Go.asInterface(_x), _code, ("invalid argument: argument has type %s, expected complex type" : GoString), Go.toInterface(_x._typ));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            if (_x._mode == ((4 : stdgo.go.types.Types.T_operandMode))) {
                                if (_id == ((14 : stdgo.go.types.Types.T_builtinId))) {
                                    _x._val = stdgo.go.constant.Constant.real(_x._val);
                                } else {
                                    _x._val = stdgo.go.constant.Constant.imag(_x._val);
                                };
                            } else {
                                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            };
                            if ((_check.info.types != null) && (_x._mode != (4 : stdgo.go.types.Types.T_operandMode))) {
                                _check._recordBuiltinType(_call.fun, _makeSig(_resTyp, _x._typ));
                            };
                            _x._typ = _resTyp;
                            break;
                        } else if (__value__ == ((9 : stdgo.go.types.Types.T_builtinId))) {
                            var _arg0:stdgo.go.ast.Ast.Expr = _call.args[(0 : GoInt)];
                            var t:stdgo.go.types.Types.Type = _check._varType(_arg0);
                            if (Go.toInterface(t) == (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            var _min:GoInt = (0 : GoInt);
                            {
                                final __type__ = _coreType(t);
                                if (Go.typeEquals((__type__ : Ref<Slice_>))) {
                                    _min = (2 : GoInt);
                                } else if (Go.typeEquals((__type__ : Ref<Map_>)) || Go.typeEquals((__type__ : Ref<Chan>))) {
                                    _min = (1 : GoInt);
                                } else if (__type__ == null) {
                                    _check._errorf(_arg0, (92 : stdgo.internal.types.errors.Errors.Code), ("cannot make %s: no core type" : GoString), Go.toInterface(_arg0));
                                    {
                                        for (defer in __deferstack__) {
                                            defer();
                                        };
                                        return _0;
                                    };
                                } else {
                                    _check._errorf(_arg0, (92 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: cannot make %s; type must be slice, map, or channel" : GoString), Go.toInterface(_arg0));
                                    {
                                        for (defer in __deferstack__) {
                                            defer();
                                        };
                                        return _0;
                                    };
                                };
                            };
                            if ((_nargs < _min) || ((_min + (1 : GoInt)) < _nargs)) {
                                _check._errorf(Go.asInterface(_call), (126 : stdgo.internal.types.errors.Errors.Code), ("invalid operation: %v expects %d or %d arguments; found %d" : GoString), Go.toInterface(Go.asInterface(_call)), Go.toInterface(_min), Go.toInterface(_min + (1 : GoInt)), Go.toInterface(_nargs));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            var _types = (new Slice<stdgo.go.types.Types.Type>(1, 1, t) : Slice<stdgo.go.types.Types.Type>);
                            var _sizes:Slice<GoInt64> = (null : Slice<GoInt64>);
                            for (__109 => _arg in (_call.args.__slice__((1 : GoInt)) : Slice<stdgo.go.ast.Ast.Expr>)) {
                                var __tmp__ = _check._index(_arg, (-1i64 : GoInt64)), _typ:stdgo.go.types.Types.Type = __tmp__._0, _size:GoInt64 = __tmp__._1;
                                _types = (_types.__append__(_typ));
                                if (_size >= (0i64 : GoInt64)) {
                                    _sizes = (_sizes.__append__(_size));
                                };
                            };
                            if ((_sizes.length == (2 : GoInt)) && (_sizes[(0 : GoInt)] > _sizes[(1 : GoInt)])) {
                                _check._error(_call.args[(1 : GoInt)], (91 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: length and capacity swapped" : GoString));
                            };
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = t;
                            if (_check.info.types != null) {
                                _check._recordBuiltinType(_call.fun, _makeSig(_x._typ, ..._types.__toArray__()));
                            };
                            break;
                        } else if (__value__ == ((10 : stdgo.go.types.Types.T_builtinId))) {
                            var t:stdgo.go.types.Types.Type = _check._varType(_call.args[(0 : GoInt)]);
                            if (Go.toInterface(t) == (Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = Go.asInterface((Go.setRef(({ _base : t } : Pointer_)) : Ref<stdgo.go.types.Types.Pointer_>));
                            if (_check.info.types != null) {
                                _check._recordBuiltinType(_call.fun, _makeSig(_x._typ, t));
                            };
                            break;
                        } else if (__value__ == ((11 : stdgo.go.types.Types.T_builtinId))) {
                            if (((_check._environment._sig != null) && ((_check._environment._sig : Dynamic).__nil__ == null || !(_check._environment._sig : Dynamic).__nil__)) && (_check._environment._sig._results.len() > (0 : GoInt))) {
                                var _p = _check._environment._isPanic;
                                if (_p == null) {
                                    _p = ({
                                        final x = new GoRefMap<Ref<stdgo.go.ast.Ast.CallExpr>, Bool>();
                                        @:mergeBlock {};
                                        cast x;
                                    } : GoMap<Ref<stdgo.go.ast.Ast.CallExpr>, Bool>);
                                    _check._environment._isPanic = _p;
                                };
                                _p[_call] = true;
                            };
                            _check._assignment(_x, Go.asInterface((Go.setRef(_emptyInterface) : Ref<stdgo.go.types.Types.Interface>)), ("argument to panic" : GoString));
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _x._mode = (1 : stdgo.go.types.Types.T_operandMode);
                            if (_check.info.types != null) {
                                _check._recordBuiltinType(_call.fun, _makeSig((null : stdgo.go.types.Types.Type), Go.asInterface((Go.setRef(_emptyInterface) : Ref<stdgo.go.types.Types.Interface>))));
                            };
                            break;
                        } else if (__value__ == ((12 : stdgo.go.types.Types.T_builtinId)) || __value__ == ((13 : stdgo.go.types.Types.T_builtinId))) {
                            var _params:Slice<Type> = (null : Slice<stdgo.go.types.Types.Type>);
                            if (_nargs > (0 : GoInt)) {
                                _params = new Slice<stdgo.go.types.Types.Type>((_nargs : GoInt).toBasic(), 0);
                                {
                                    var _i:GoInt = (0 : GoInt);
                                    Go.cfor(_i < _nargs, _i++, {
                                        if (_i > (0 : GoInt)) {
                                            _arg(_x, _i);
                                        };
                                        _check._assignment(_x, (null : stdgo.go.types.Types.Type), ("argument to " : GoString) + _predeclaredFuncs[(_id : GoInt)]._name);
                                        if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                            {
                                                for (defer in __deferstack__) {
                                                    defer();
                                                };
                                                return _0;
                                            };
                                        };
                                        _params[(_i : GoInt)] = _x._typ;
                                    });
                                };
                            };
                            _x._mode = (1 : stdgo.go.types.Types.T_operandMode);
                            if (_check.info.types != null) {
                                _check._recordBuiltinType(_call.fun, _makeSig((null : stdgo.go.types.Types.Type), ..._params.__toArray__()));
                            };
                            break;
                        } else if (__value__ == ((15 : stdgo.go.types.Types.T_builtinId))) {
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = Go.asInterface((Go.setRef(_emptyInterface) : Ref<stdgo.go.types.Types.Interface>));
                            if (_check.info.types != null) {
                                _check._recordBuiltinType(_call.fun, _makeSig(_x._typ));
                            };
                            break;
                        } else if (__value__ == ((16 : stdgo.go.types.Types.T_builtinId))) {
                            if (!_check._allowVersion(_check._pkg, (1 : GoInt), (17 : GoInt))) {
                                _check._error(_call.fun, (135 : stdgo.internal.types.errors.Errors.Code), ("unsafe.Add requires go1.17 or later" : GoString));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _check._assignment(_x, Go.asInterface(typ[((18 : stdgo.go.types.Types.BasicKind) : GoInt)]), ("argument to unsafe.Add" : GoString));
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            var _y:T_operand = ({} : stdgo.go.types.Types.T_operand);
                            _arg((Go.setRef(_y) : Ref<stdgo.go.types.Types.T_operand>), (1 : GoInt));
                            if (!_check._isValidIndex((Go.setRef(_y) : Ref<stdgo.go.types.Types.T_operand>), (133 : stdgo.internal.types.errors.Errors.Code), ("length" : GoString), true)) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = Go.asInterface(typ[((18 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                            if (_check.info.types != null) {
                                _check._recordBuiltinType(_call.fun, _makeSig(_x._typ, _x._typ, _y._typ));
                            };
                            break;
                        } else if (__value__ == ((17 : stdgo.go.types.Types.T_builtinId))) {
                            _check._assignment(_x, (null : stdgo.go.types.Types.Type), ("argument to unsafe.Alignof" : GoString));
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            if (_hasVarSize(_x._typ, (null : GoMap<Ref<stdgo.go.types.Types.Named>, Bool>))) {
                                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                                if (_check.info.types != null) {
                                    _check._recordBuiltinType(_call.fun, _makeSig(Go.asInterface(typ[((12 : stdgo.go.types.Types.BasicKind) : GoInt)]), _x._typ));
                                };
                            } else {
                                _x._mode = (4 : stdgo.go.types.Types.T_operandMode);
                                _x._val = stdgo.go.constant.Constant.makeInt64(_check._conf._alignof(_x._typ));
                            };
                            _x._typ = Go.asInterface(typ[((12 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                            break;
                        } else if (__value__ == ((18 : stdgo.go.types.Types.T_builtinId))) {
                            var _arg0:stdgo.go.ast.Ast.Expr = _call.args[(0 : GoInt)];
                            var __tmp__ = try {
                                { value : (Go.typeAssert((Go.toInterface(_unparen(_arg0)) : Ref<stdgo.go.ast.Ast.SelectorExpr>)) : Ref<stdgo.go.ast.Ast.SelectorExpr>), ok : true };
                            } catch(_) {
                                { value : (null : Ref<stdgo.go.ast.Ast.SelectorExpr>), ok : false };
                            }, _selx = __tmp__.value, __214 = __tmp__.ok;
                            if (_selx == null || (_selx : Dynamic).__nil__) {
                                _check._errorf(_arg0, (98 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: %s is not a selector expression" : GoString), Go.toInterface(_arg0));
                                _check._use(_arg0);
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _check._expr(_x, _selx.x);
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            var _base:stdgo.go.types.Types.Type = _derefStructPtr(_x._typ);
                            var _sel:GoString = _selx.sel.name;
                            var __tmp__ = lookupFieldOrMethod(_base, false, _check._pkg, _sel), _obj:stdgo.go.types.Types.Object = __tmp__._0, _index:Slice<GoInt> = __tmp__._1, _indirect:Bool = __tmp__._2;
                            {
                                final __type__ = _obj;
                                if (__type__ == null) {
                                    _check._errorf(Go.asInterface(_x), (76 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: %s has no single field %s" : GoString), Go.toInterface(_base), Go.toInterface(_sel));
                                    {
                                        for (defer in __deferstack__) {
                                            defer();
                                        };
                                        return _0;
                                    };
                                } else if (Go.typeEquals((__type__ : Ref<Func>))) {
                                    _check._errorf(_arg0, (99 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: %s is a method value" : GoString), Go.toInterface(_arg0));
                                    {
                                        for (defer in __deferstack__) {
                                            defer();
                                        };
                                        return _0;
                                    };
                                };
                            };
                            if (_indirect) {
                                _check._errorf(Go.asInterface(_x), (99 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: field %s is embedded via a pointer in %s" : GoString), Go.toInterface(_sel), Go.toInterface(_base));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _check._recordSelection(_selx, (0 : stdgo.go.types.Types.SelectionKind), _base, _obj, _index, false);
                            {
                                var _mode:stdgo.go.types.Types.T_operandMode = (7 : stdgo.go.types.Types.T_operandMode);
                                if ((_x._mode == (5 : stdgo.go.types.Types.T_operandMode)) || _indirect) {
                                    _mode = (5 : stdgo.go.types.Types.T_operandMode);
                                };
                                _check._record((Go.setRef((new T_operand(_mode, Go.asInterface(_selx), _obj.type(), (null : stdgo.go.constant.Constant.Value), (0 : stdgo.go.types.Types.T_builtinId)) : T_operand)) : Ref<stdgo.go.types.Types.T_operand>));
                            };
                            if (_hasVarSize(_base, (null : GoMap<Ref<stdgo.go.types.Types.Named>, Bool>))) {
                                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                                if (_check.info.types != null) {
                                    _check._recordBuiltinType(_call.fun, _makeSig(Go.asInterface(typ[((12 : stdgo.go.types.Types.BasicKind) : GoInt)]), _obj.type()));
                                };
                            } else {
                                _x._mode = (4 : stdgo.go.types.Types.T_operandMode);
                                _x._val = stdgo.go.constant.Constant.makeInt64(_check._conf._offsetof(_base, _index));
                            };
                            _x._typ = Go.asInterface(typ[((12 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                            break;
                        } else if (__value__ == ((19 : stdgo.go.types.Types.T_builtinId))) {
                            _check._assignment(_x, (null : stdgo.go.types.Types.Type), ("argument to unsafe.Sizeof" : GoString));
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            if (_hasVarSize(_x._typ, (null : GoMap<Ref<stdgo.go.types.Types.Named>, Bool>))) {
                                _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                                if (_check.info.types != null) {
                                    _check._recordBuiltinType(_call.fun, _makeSig(Go.asInterface(typ[((12 : stdgo.go.types.Types.BasicKind) : GoInt)]), _x._typ));
                                };
                            } else {
                                _x._mode = (4 : stdgo.go.types.Types.T_operandMode);
                                _x._val = stdgo.go.constant.Constant.makeInt64(_check._conf._sizeof(_x._typ));
                            };
                            _x._typ = Go.asInterface(typ[((12 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                            break;
                        } else if (__value__ == ((20 : stdgo.go.types.Types.T_builtinId))) {
                            if (!_check._allowVersion(_check._pkg, (1 : GoInt), (17 : GoInt))) {
                                _check._error(_call.fun, (135 : stdgo.internal.types.errors.Errors.Code), ("unsafe.Slice requires go1.17 or later" : GoString));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            var __tmp__ = try {
                                { value : (Go.typeAssert((Go.toInterface(_under(_x._typ)) : Ref<Pointer_>)) : Ref<Pointer_>), ok : true };
                            } catch(_) {
                                { value : (null : Ref<stdgo.go.types.Types.Pointer_>), ok : false };
                            }, _ptr = __tmp__.value, __263 = __tmp__.ok;
                            if (_ptr == null || (_ptr : Dynamic).__nil__) {
                                _check._errorf(Go.asInterface(_x), (134 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: %s is not a pointer" : GoString), Go.toInterface(Go.asInterface(_x)));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            var _y:T_operand = ({} : stdgo.go.types.Types.T_operand);
                            _arg((Go.setRef(_y) : Ref<stdgo.go.types.Types.T_operand>), (1 : GoInt));
                            if (!_check._isValidIndex((Go.setRef(_y) : Ref<stdgo.go.types.Types.T_operand>), (134 : stdgo.internal.types.errors.Errors.Code), ("length" : GoString), false)) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = Go.asInterface(newSlice(_ptr._base));
                            if (_check.info.types != null) {
                                _check._recordBuiltinType(_call.fun, _makeSig(_x._typ, Go.asInterface(_ptr), _y._typ));
                            };
                            break;
                        } else if (__value__ == ((21 : stdgo.go.types.Types.T_builtinId))) {
                            if (!_check._allowVersion(_check._pkg, (1 : GoInt), (20 : GoInt))) {
                                _check._error(_call.fun, (135 : stdgo.internal.types.errors.Errors.Code), ("unsafe.SliceData requires go1.20 or later" : GoString));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            var __tmp__ = try {
                                { value : (Go.typeAssert((Go.toInterface(_under(_x._typ)) : Ref<Slice_>)) : Ref<Slice_>), ok : true };
                            } catch(_) {
                                { value : (null : Ref<stdgo.go.types.Types.Slice_>), ok : false };
                            }, _slice = __tmp__.value, __280 = __tmp__.ok;
                            if (_slice == null || (_slice : Dynamic).__nil__) {
                                _check._errorf(Go.asInterface(_x), (145 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: %s is not a slice" : GoString), Go.toInterface(Go.asInterface(_x)));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = Go.asInterface(newPointer(_slice._elem));
                            if (_check.info.types != null) {
                                _check._recordBuiltinType(_call.fun, _makeSig(_x._typ, Go.asInterface(_slice)));
                            };
                            break;
                        } else if (__value__ == ((22 : stdgo.go.types.Types.T_builtinId))) {
                            if (!_check._allowVersion(_check._pkg, (1 : GoInt), (20 : GoInt))) {
                                _check._error(_call.fun, (135 : stdgo.internal.types.errors.Errors.Code), ("unsafe.String requires go1.20 or later" : GoString));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _check._assignment(_x, Go.asInterface(newPointer(_universeByte)), ("argument to unsafe.String" : GoString));
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            var _y:T_operand = ({} : stdgo.go.types.Types.T_operand);
                            _arg((Go.setRef(_y) : Ref<stdgo.go.types.Types.T_operand>), (1 : GoInt));
                            if (!_check._isValidIndex((Go.setRef(_y) : Ref<stdgo.go.types.Types.T_operand>), (146 : stdgo.internal.types.errors.Errors.Code), ("length" : GoString), false)) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = Go.asInterface(typ[((17 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                            if (_check.info.types != null) {
                                _check._recordBuiltinType(_call.fun, _makeSig(_x._typ, Go.asInterface(newPointer(_universeByte)), _y._typ));
                            };
                            break;
                        } else if (__value__ == ((23 : stdgo.go.types.Types.T_builtinId))) {
                            if (!_check._allowVersion(_check._pkg, (1 : GoInt), (20 : GoInt))) {
                                _check._error(_call.fun, (135 : stdgo.internal.types.errors.Errors.Code), ("unsafe.StringData requires go1.20 or later" : GoString));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _check._assignment(_x, Go.asInterface(typ[((17 : stdgo.go.types.Types.BasicKind) : GoInt)]), ("argument to unsafe.StringData" : GoString));
                            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            _x._mode = (7 : stdgo.go.types.Types.T_operandMode);
                            _x._typ = Go.asInterface(newPointer(_universeByte));
                            if (_check.info.types != null) {
                                _check._recordBuiltinType(_call.fun, _makeSig(_x._typ, Go.asInterface(typ[((17 : stdgo.go.types.Types.BasicKind) : GoInt)])));
                            };
                            break;
                        } else if (__value__ == ((24 : stdgo.go.types.Types.T_builtinId))) {
                            if ((_x._mode != (4 : stdgo.go.types.Types.T_operandMode)) || !_isBoolean(_x._typ)) {
                                _check._errorf(Go.asInterface(_x), (1 : stdgo.internal.types.errors.Errors.Code), ("invalid argument: %s is not a boolean constant" : GoString), Go.toInterface(Go.asInterface(_x)));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            if (_x._val.kind() != ((1 : stdgo.go.constant.Constant.Kind))) {
                                _check._errorf(Go.asInterface(_x), (1 : stdgo.internal.types.errors.Errors.Code), ("internal error: value of %s should be a boolean constant" : GoString), Go.toInterface(Go.asInterface(_x)));
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return _0;
                                };
                            };
                            if (!stdgo.go.constant.Constant.boolVal(_x._val)) {
                                _check._errorf(Go.asInterface(_call), (1 : stdgo.internal.types.errors.Errors.Code), ("%v failed" : GoString), Go.toInterface(Go.asInterface(_call)));
                            };
                            break;
                        } else if (__value__ == ((25 : stdgo.go.types.Types.T_builtinId))) {
                            if (_nargs == ((0 : GoInt))) {
                                _check._dump(("%v: trace() without arguments" : GoString), Go.toInterface(Go.asInterface(_call.pos())));
                                _x._mode = (1 : stdgo.go.types.Types.T_operandMode);
                                break;
                            };
                            var _t:T_operand = ({} : stdgo.go.types.Types.T_operand);
                            var _x1 = _x;
                            for (__321 => _arg in _call.args) {
                                _check._rawExpr(_x1, _arg, (null : stdgo.go.types.Types.Type), false);
                                _check._dump(("%v: %s" : GoString), Go.toInterface(Go.asInterface(_x1.pos())), Go.toInterface(Go.asInterface(_x1)));
                                _x1 = (Go.setRef(_t) : Ref<stdgo.go.types.Types.T_operand>);
                            };
                            break;
                        } else {
                            _unreachable();
                        };
                    };
                    break;
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return true;
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return _0;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return _0;
        };
    }
    @:keep
    static public function _shortVarDecl( _check:Ref<Checker>, _pos:T_positioner, _lhs:Slice<stdgo.go.ast.Ast.Expr>, _rhs:Slice<stdgo.go.ast.Ast.Expr>):Void {
        var _top:GoInt = (_check._delayed.length);
        var _scope = _check._pkg._scope;
        var _seen = ({
            final x = new stdgo.GoMap.GoStringMap<Bool>();
            x.__defaultValue__ = () -> false;
            @:mergeBlock {};
            x;
        } : GoMap<GoString, Bool>);
        var _lhsVars = new Slice<Ref<stdgo.go.types.Types.Var>>((_lhs.length : GoInt).toBasic(), 0);
        var _newVars = new Slice<Ref<stdgo.go.types.Types.Var>>((0 : GoInt).toBasic(), (_lhs.length));
        var _hasErr:Bool = false;
        for (_i => _lhs in _lhs) {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_lhs) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.ast.Ast.Ident>), ok : false };
            }, _ident = __tmp__.value, __16 = __tmp__.ok;
            if (_ident == null || (_ident : Dynamic).__nil__) {
                _check._useLHS(_lhs);
                _check._errorf(_lhs, (131 : stdgo.internal.types.errors.Errors.Code), ("non-name %s on left side of :=" : GoString), Go.toInterface(_lhs));
                _hasErr = true;
                continue;
            };
            var _name:GoString = _ident.name;
            if (_name != (("_" : GoString))) {
                if (_seen[_name]) {
                    _check._errorf(_lhs, (132 : stdgo.internal.types.errors.Errors.Code), ("%s repeated on left side of :=" : GoString), Go.toInterface(_lhs));
                    _hasErr = true;
                    continue;
                };
                _seen[_name] = true;
            };
            {
                var _alt:stdgo.go.types.Types.Object = _scope.lookup(_name);
                if (_alt != null) {
                    _check._recordUse(_ident, _alt);
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_alt) : Ref<Var>)) : Ref<Var>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.types.Types.Var>), ok : false };
                        }, _obj = __tmp__.value, __17 = __tmp__.ok;
                        if (_obj != null && ((_obj : Dynamic).__nil__ == null || !(_obj : Dynamic).__nil__)) {
                            _lhsVars[(_i : GoInt)] = _obj;
                        } else {
                            _check._errorf(_lhs, (18 : stdgo.internal.types.errors.Errors.Code), ("cannot assign to %s" : GoString), Go.toInterface(_lhs));
                            _hasErr = true;
                        };
                    };
                    continue;
                };
            };
            var _obj = newVar(_ident.pos(), _check._pkg, _name, (null : stdgo.go.types.Types.Type));
            _lhsVars[(_i : GoInt)] = _obj;
            if (_name != (("_" : GoString))) {
                _newVars = (_newVars.__append__(_obj));
            };
            _check._recordDef(_ident, Go.asInterface(_obj));
        };
        for (_i => _obj in _lhsVars) {
            if (_obj == null || (_obj : Dynamic).__nil__) {
                _lhsVars[(_i : GoInt)] = newVar(_lhs[(_i : GoInt)].pos(), _check._pkg, ("_" : GoString), (null : stdgo.go.types.Types.Type));
            };
        };
        _check._initVars(_lhsVars, _rhs, (null : stdgo.go.ast.Ast.Stmt));
        _check._processDelayed(_top);
        if ((_newVars.length == (0 : GoInt)) && !_hasErr) {
            _check._softErrorf(_pos, (19 : stdgo.internal.types.errors.Errors.Code), ("no new variables on left side of :=" : GoString));
            return;
        };
        var _scopePos:stdgo.go.token.Token.Pos = _rhs[((_rhs.length) - (1 : GoInt) : GoInt)].end();
        for (__34 => _obj in _newVars) {
            _check._declare(_scope, null, Go.asInterface(_obj), _scopePos);
        };
    }
    @:keep
    static public function _assignVars( _check:Ref<Checker>, _lhs:Slice<stdgo.go.ast.Ast.Expr>, _origRHS:Slice<stdgo.go.ast.Ast.Expr>):Void {
        var __tmp__ = _check._exprList(_origRHS, (_lhs.length) == ((2 : GoInt))), _rhs:Slice<Ref<stdgo.go.types.Types.T_operand>> = __tmp__._0, _commaOk:Bool = __tmp__._1;
        if ((_lhs.length) != ((_rhs.length))) {
            _check._useLHS(..._lhs.__toArray__());
            for (__0 => _x in _rhs) {
                if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                    return;
                };
            };
            _check._assignError(_origRHS, (_lhs.length), (_rhs.length));
            return;
        };
        if (_commaOk) {
            var _a:GoArray<Type> = new GoArray<stdgo.go.types.Types.Type>(...[for (i in 0 ... 2) (null : stdgo.go.types.Types.Type)]);
            for (_i in 0 ... _a.length.toBasic()) {
                _a[(_i : GoInt)] = _check._assignVar(_lhs[(_i : GoInt)], _rhs[(_i : GoInt)]);
            };
            _check._recordCommaOkTypes(_origRHS[(0 : GoInt)], _a?.__copy__());
            return;
        };
        for (_i => _lhs in _lhs) {
            _check._assignVar(_lhs, _rhs[(_i : GoInt)]);
        };
    }
    /**
        // If returnStmt != nil, initVars is called to type-check the assignment
        // of return expressions, and returnStmt is the return statement.
    **/
    @:keep
    static public function _initVars( _check:Ref<Checker>, _lhs:Slice<Ref<Var>>, _origRHS:Slice<stdgo.go.ast.Ast.Expr>, _returnStmt:stdgo.go.ast.Ast.Stmt):Void {
        var __tmp__ = _check._exprList(_origRHS, (_lhs.length == (2 : GoInt)) && (_returnStmt == null)), _rhs:Slice<Ref<stdgo.go.types.Types.T_operand>> = __tmp__._0, _commaOk:Bool = __tmp__._1;
        if ((_lhs.length) != ((_rhs.length))) {
            for (__0 => _obj in _lhs) {
                _obj._used = true;
                if (_obj._object._typ == null) {
                    _obj._object._typ = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                };
            };
            for (__1 => _x in _rhs) {
                if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                    return;
                };
            };
            if (_returnStmt != null) {
                var _at:T_positioner = _returnStmt;
                var _qualifier:GoString = ("not enough" : GoString);
                if ((_rhs.length) > (_lhs.length)) {
                    _at = _rhs[(_lhs.length : GoInt)]._expr;
                    _qualifier = ("too many" : GoString);
                } else if ((_rhs.length) > (0 : GoInt)) {
                    _at = _rhs[((_rhs.length) - (1 : GoInt) : GoInt)]._expr;
                };
                var _err = _newErrorf(_at, (103 : stdgo.internal.types.errors.Errors.Code), ("%s return values" : GoString), Go.toInterface(_qualifier));
                _err._errorf((0 : stdgo.go.token.Token.Pos), ("have %s" : GoString), Go.toInterface(_check._typesSummary(_operandTypes(_rhs), false)));
                _err._errorf((0 : stdgo.go.token.Token.Pos), ("want %s" : GoString), Go.toInterface(_check._typesSummary(_varTypes(_lhs), false)));
                _check._report(_err);
                return;
            };
            _check._assignError(_origRHS, (_lhs.length), (_rhs.length));
            return;
        };
        var _context:GoString = ("assignment" : GoString);
        if (_returnStmt != null) {
            _context = ("return statement" : GoString);
        };
        if (_commaOk) {
            var _a:GoArray<Type> = new GoArray<stdgo.go.types.Types.Type>(...[for (i in 0 ... 2) (null : stdgo.go.types.Types.Type)]);
            for (_i in 0 ... _a.length.toBasic()) {
                _a[(_i : GoInt)] = _check._initVar(_lhs[(_i : GoInt)], _rhs[(_i : GoInt)], _context);
            };
            _check._recordCommaOkTypes(_origRHS[(0 : GoInt)], _a?.__copy__());
            return;
        };
        for (_i => _lhs in _lhs) {
            _check._initVar(_lhs, _rhs[(_i : GoInt)], _context);
        };
    }
    @:keep
    static public function _assignError( _check:Ref<Checker>, _rhs:Slice<stdgo.go.ast.Ast.Expr>, _nvars:GoInt, _nvals:GoInt):Void {
        var _vars:GoString = _measure(_nvars, ("variable" : GoString));
        var _vals:GoString = _measure(_nvals, ("value" : GoString));
        var _rhs0:stdgo.go.ast.Ast.Expr = _rhs[(0 : GoInt)];
        if ((_rhs.length) == ((1 : GoInt))) {
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_unparen(_rhs0)) : Ref<stdgo.go.ast.Ast.CallExpr>)) : Ref<stdgo.go.ast.Ast.CallExpr>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.ast.Ast.CallExpr>), ok : false };
                }, _call = __tmp__.value, __0 = __tmp__.ok;
                if (_call != null && ((_call : Dynamic).__nil__ == null || !(_call : Dynamic).__nil__)) {
                    _check._errorf(_rhs0, (17 : stdgo.internal.types.errors.Errors.Code), ("assignment mismatch: %s but %s returns %s" : GoString), Go.toInterface(_vars), Go.toInterface(_call.fun), Go.toInterface(_vals));
                    return;
                };
            };
        };
        _check._errorf(_rhs0, (17 : stdgo.internal.types.errors.Errors.Code), ("assignment mismatch: %s but %s" : GoString), Go.toInterface(_vars), Go.toInterface(_vals));
    }
    /**
        // typesSummary returns a string of the form "(t1, t2, ...)" where the
        // ti's are user-friendly string representations for the given types.
        // If variadic is set and the last type is a slice, its string is of
        // the form "...E" where E is the slice's element type.
    **/
    @:keep
    static public function _typesSummary( _check:Ref<Checker>, _list:Slice<Type>, _variadic:Bool):GoString {
        var _res:Slice<GoString> = (null : Slice<GoString>);
        for (_i => _t in _list) {
            var _s:GoString = ("" : GoString);
            {
                var __switchIndex__ = -1;
                var __run__ = true;
                while (__run__) {
                    __run__ = false;
                    if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (_t == null))) {
                        @:fallthrough {
                            __switchIndex__ = 1;
                            __run__ = true;
                            continue;
                        };
                        break;
                    } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && (Go.toInterface(_t) == Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]))))) {
                        _s = ("<T>" : GoString);
                        break;
                        break;
                    } else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && _isUntyped(_t))) {
                        if (_isNumeric(_t)) {
                            _s = ("number" : GoString);
                        } else {
                            _s = stdgo.strings.Strings.replace((Go.typeAssert((Go.toInterface(_t) : Ref<Basic>)) : Ref<Basic>)._name, ("untyped " : GoString), Go.str(), (-1 : GoInt));
                        };
                        break;
                        break;
                    } else if (__switchIndex__ == 3 || (__switchIndex__ == -1 && (_variadic && (_i == (_list.length - (1 : GoInt)))))) {
                        _s = _check._sprintf(("...%s" : GoString), Go.toInterface((Go.typeAssert((Go.toInterface(_t) : Ref<Slice_>)) : Ref<Slice_>)._elem));
                        break;
                        break;
                    };
                    break;
                };
            };
            if (_s == (Go.str())) {
                _s = _check._sprintf(("%s" : GoString), Go.toInterface(_t));
            };
            _res = (_res.__append__(_s));
        };
        return (("(" : GoString) + stdgo.strings.Strings.join(_res, (", " : GoString))) + (")" : GoString);
    }
    @:keep
    static public function _assignVar( _check:Ref<Checker>, _lhs:stdgo.go.ast.Ast.Expr, _x:Ref<T_operand>):Type {
        if ((_x._mode == (0 : stdgo.go.types.Types.T_operandMode)) || (Go.toInterface(_x._typ) == Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
            _check._useLHS(_lhs);
            return (null : stdgo.go.types.Types.Type);
        };
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(_unparen(_lhs)) : Ref<stdgo.go.ast.Ast.Ident>)) : Ref<stdgo.go.ast.Ast.Ident>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.ast.Ast.Ident>), ok : false };
        }, _ident = __tmp__.value, __0 = __tmp__.ok;
        if (((_ident != null) && ((_ident : Dynamic).__nil__ == null || !(_ident : Dynamic).__nil__)) && (_ident.name == ("_" : GoString))) {
            _check._recordDef(_ident, (null : stdgo.go.types.Types.Object));
            _check._assignment(_x, (null : stdgo.go.types.Types.Type), ("assignment to _ identifier" : GoString));
            if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
                return (null : stdgo.go.types.Types.Type);
            };
            return _x._typ;
        };
        var _v:Ref<Var> = (null : Ref<stdgo.go.types.Types.Var>);
        var _v_used:Bool = false;
        if (_ident != null && ((_ident : Dynamic).__nil__ == null || !(_ident : Dynamic).__nil__)) {
            {
                var _obj:stdgo.go.types.Types.Object = _check._lookup(_ident.name);
                if (_obj != null) {
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_obj) : Ref<Var>)) : Ref<Var>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.types.Types.Var>), ok : false };
                        }, _w = __tmp__.value, __1 = __tmp__.ok;
                        if (((_w != null) && ((_w : Dynamic).__nil__ == null || !(_w : Dynamic).__nil__)) && (_w._object._pkg == _check._pkg)) {
                            _v = _w;
                            _v_used = _v._used;
                        };
                    };
                };
            };
        };
        var _z:T_operand = ({} : stdgo.go.types.Types.T_operand);
        _check._expr((Go.setRef(_z) : Ref<stdgo.go.types.Types.T_operand>), _lhs);
        if (_v != null && ((_v : Dynamic).__nil__ == null || !(_v : Dynamic).__nil__)) {
            _v._used = _v_used;
        };
        if ((_z._mode == (0 : stdgo.go.types.Types.T_operandMode)) || (Go.toInterface(_z._typ) == Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
            return (null : stdgo.go.types.Types.Type);
        };
        {
            final __value__ = _z._mode;
            if (__value__ == ((0 : stdgo.go.types.Types.T_operandMode))) {
                return (null : stdgo.go.types.Types.Type);
            } else if (__value__ == ((5 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((6 : stdgo.go.types.Types.T_operandMode))) {} else {
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_z._expr) : Ref<stdgo.go.ast.Ast.SelectorExpr>)) : Ref<stdgo.go.ast.Ast.SelectorExpr>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.ast.Ast.SelectorExpr>), ok : false };
                    }, _sel = __tmp__.value, _ok = __tmp__.ok;
                    if (_ok) {
                        var _op:T_operand = ({} : stdgo.go.types.Types.T_operand);
                        _check._expr((Go.setRef(_op) : Ref<stdgo.go.types.Types.T_operand>), _sel.x);
                        if (_op._mode == ((6 : stdgo.go.types.Types.T_operandMode))) {
                            _check._errorf(Go.asInterface((Go.setRef(_z) : Ref<stdgo.go.types.Types.T_operand>)), (24 : stdgo.internal.types.errors.Errors.Code), ("cannot assign to struct field %s in map" : GoString), Go.toInterface(exprString(_z._expr)));
                            return (null : stdgo.go.types.Types.Type);
                        };
                    };
                };
                _check._errorf(Go.asInterface((Go.setRef(_z) : Ref<stdgo.go.types.Types.T_operand>)), (18 : stdgo.internal.types.errors.Errors.Code), ("cannot assign to %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_z) : Ref<stdgo.go.types.Types.T_operand>))));
                return (null : stdgo.go.types.Types.Type);
            };
        };
        _check._assignment(_x, _z._typ, ("assignment" : GoString));
        if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
            return (null : stdgo.go.types.Types.Type);
        };
        return _x._typ;
    }
    @:keep
    static public function _initVar( _check:Ref<Checker>, _lhs:Ref<Var>, _x:Ref<T_operand>, _context:GoString):Type {
        if (((_x._mode == (0 : stdgo.go.types.Types.T_operandMode)) || (Go.toInterface(_x._typ) == Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) || (Go.toInterface(_lhs._object._typ) == Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
            if (_lhs._object._typ == null) {
                _lhs._object._typ = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
            };
            return (null : stdgo.go.types.Types.Type);
        };
        if (_lhs._object._typ == null) {
            var _typ:stdgo.go.types.Types.Type = _x._typ;
            if (_isUntyped(_typ)) {
                if (Go.toInterface(_typ) == (Go.toInterface(Go.asInterface(typ[((25 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                    _check._errorf(Go.asInterface(_x), (16 : stdgo.internal.types.errors.Errors.Code), ("use of untyped nil in %s" : GoString), Go.toInterface(_context));
                    _lhs._object._typ = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                    return (null : stdgo.go.types.Types.Type);
                };
                _typ = default_(_typ);
            };
            _lhs._object._typ = _typ;
        };
        _check._assignment(_x, _lhs._object._typ, _context);
        if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
            return (null : stdgo.go.types.Types.Type);
        };
        return _x._typ;
    }
    @:keep
    static public function _initConst( _check:Ref<Checker>, _lhs:Ref<Const>, _x:Ref<T_operand>):Void {
        if (((_x._mode == (0 : stdgo.go.types.Types.T_operandMode)) || (Go.toInterface(_x._typ) == Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) || (Go.toInterface(_lhs._object._typ) == Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
            if (_lhs._object._typ == null) {
                _lhs._object._typ = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
            };
            return;
        };
        if (_x._mode != ((4 : stdgo.go.types.Types.T_operandMode))) {
            _check._errorf(Go.asInterface(_x), (13 : stdgo.internal.types.errors.Errors.Code), ("%s is not constant" : GoString), Go.toInterface(Go.asInterface(_x)));
            if (_lhs._object._typ == null) {
                _lhs._object._typ = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
            };
            return;
        };
        _assert(_isConstType(_x._typ));
        if (_lhs._object._typ == null) {
            _lhs._object._typ = _x._typ;
        };
        _check._assignment(_x, _lhs._object._typ, ("constant declaration" : GoString));
        if (_x._mode == ((0 : stdgo.go.types.Types.T_operandMode))) {
            return;
        };
        _lhs._val = _x._val;
    }
    /**
        // assignment reports whether x can be assigned to a variable of type T,
        // if necessary by attempting to convert untyped values to the appropriate
        // type. context describes the context in which the assignment takes place.
        // Use T == nil to indicate assignment to an untyped blank identifier.
        // x.mode is set to invalid if the assignment failed.
    **/
    @:keep
    static public function _assignment( _check:Ref<Checker>, _x:Ref<T_operand>, t:Type, _context:GoString):Void {
        _check._singleValue(_x);
        {
            final __value__ = _x._mode;
            if (__value__ == ((0 : stdgo.go.types.Types.T_operandMode))) {
                return;
            } else if (__value__ == ((4 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((5 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((6 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((7 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((8 : stdgo.go.types.Types.T_operandMode)) || __value__ == ((9 : stdgo.go.types.Types.T_operandMode))) {} else {
                _check._errorf(Go.asInterface(_x), (23 : stdgo.internal.types.errors.Errors.Code), ("cannot assign %s to %s in %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(t), Go.toInterface(_context));
                return;
            };
        };
        if (_isUntyped(_x._typ)) {
            var _target:stdgo.go.types.Types.Type = t;
            if ((t == null) || _isNonTypeParamInterface(t)) {
                if ((t == null) && (Go.toInterface(_x._typ) == Go.toInterface(Go.asInterface(typ[((25 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
                    _check._errorf(Go.asInterface(_x), (16 : stdgo.internal.types.errors.Errors.Code), ("use of untyped nil in %s" : GoString), Go.toInterface(_context));
                    _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                    return;
                };
                _target = default_(_x._typ);
            };
            var __tmp__ = _check._implicitTypeAndValue(_x, _target), _newType:stdgo.go.types.Types.Type = __tmp__._0, _val:stdgo.go.constant.Constant.Value = __tmp__._1, _code:stdgo.internal.types.errors.Errors.Code = __tmp__._2;
            if (_code != ((0 : stdgo.internal.types.errors.Errors.Code))) {
                var _msg:GoString = _check._sprintf(("cannot use %s as %s value in %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(_target), Go.toInterface(_context));
                {
                    final __value__ = _code;
                    if (__value__ == ((43 : stdgo.internal.types.errors.Errors.Code))) {
                        _msg = _msg + ((" (truncated)" : GoString));
                    } else if (__value__ == ((44 : stdgo.internal.types.errors.Errors.Code))) {
                        _msg = _msg + ((" (overflows)" : GoString));
                    } else {
                        _code = (23 : stdgo.internal.types.errors.Errors.Code);
                    };
                };
                _check._error(Go.asInterface(_x), _code, _msg);
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
                return;
            };
            if (_val != null) {
                _x._val = _val;
                _check._updateExprVal(_x._expr, _val);
            };
            if (Go.toInterface(_newType) != (Go.toInterface(_x._typ))) {
                _x._typ = _newType;
                _check._updateExprType(_x._expr, _newType, false);
            };
        };
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_under(_x._typ)) : Ref<Signature>)) : Ref<Signature>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Signature>), ok : false };
            }, _sig = __tmp__.value, __0 = __tmp__.ok;
            if (((_sig != null) && ((_sig : Dynamic).__nil__ == null || !(_sig : Dynamic).__nil__)) && (_sig.typeParams().len() > (0 : GoInt))) {
                _check._errorf(Go.asInterface(_x), (137 : stdgo.internal.types.errors.Errors.Code), ("cannot use generic function %s without instantiation in %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(_context));
            };
        };
        if (t == null) {
            return;
        };
        var _cause:GoString = Go.str();
        {
            var __tmp__ = _x._assignableTo(_check, t, Go.pointer(_cause)), _ok:Bool = __tmp__._0, _code:stdgo.internal.types.errors.Errors.Code = __tmp__._1;
            if (!_ok) {
                if (_cause != (Go.str())) {
                    _check._errorf(Go.asInterface(_x), _code, ("cannot use %s as %s value in %s: %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(t), Go.toInterface(_context), Go.toInterface(_cause));
                } else {
                    _check._errorf(Go.asInterface(_x), _code, ("cannot use %s as %s value in %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(t), Go.toInterface(_context));
                };
                _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            };
        };
    }
    @:embedded
    public static function _lookup( __self__:Checker, __0:GoString):stdgo.go.types.Types.Object return __self__._lookup(__0);
    @:embedded
    public static function typeOf( __self__:Checker, _e:stdgo.go.ast.Ast.Expr):stdgo.go.types.Types.Type return __self__.typeOf(_e);
    @:embedded
    public static function objectOf( __self__:Checker, _id:Ref<stdgo.go.ast.Ast.Ident>):stdgo.go.types.Types.Object return __self__.objectOf(_id);
}
/**
    
    
    
**/
@:structInit class T__collectObjects_0___localname___methodInfo {
    public var _obj : Ref<stdgo.go.types.Types.Func> = (null : Ref<stdgo.go.types.Types.Func>);
    public var _ptr : Bool = false;
    public var _recv : Ref<stdgo.go.ast.Ast.Ident> = (null : Ref<stdgo.go.ast.Ast.Ident>);
    public function new(?_obj:Ref<stdgo.go.types.Types.Func>, ?_ptr:Bool, ?_recv:Ref<stdgo.go.ast.Ast.Ident>) {
        if (_obj != null) this._obj = _obj;
        if (_ptr != null) this._ptr = _ptr;
        if (_recv != null) this._recv = _recv;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T__collectObjects_0___localname___methodInfo(_obj, _ptr, _recv);
    }
}
class Context_asInterface {
    /**
        // getID returns a unique ID for the type t.
    **/
    @:keep
    public dynamic function _getID(_t:Type):GoInt return __self__.value._getID(_t);
    /**
        // update de-duplicates n against previously seen types with the hash h.  If an
        // identical type is found with the type hash h, the previously seen type is
        // returned. Otherwise, n is returned, and recorded in the Context for the hash
        // h.
    **/
    @:keep
    public dynamic function _update(_h:GoString, _orig:Type, _targs:Slice<Type>, _inst:Type):Type return __self__.value._update(_h, _orig, _targs, _inst);
    /**
        // lookup returns an existing instantiation of orig with targs, if it exists.
        // Otherwise, it returns nil.
    **/
    @:keep
    public dynamic function _lookup(_h:GoString, _orig:Type, _targs:Slice<Type>):Type return __self__.value._lookup(_h, _orig, _targs);
    /**
        // instanceHash returns a string representation of typ instantiated with targs.
        // The hash should be a perfect hash, though out of caution the type checker
        // does not assume this. The result is guaranteed to not contain blanks.
    **/
    @:keep
    public dynamic function _instanceHash(_orig:Type, _targs:Slice<Type>):GoString return __self__.value._instanceHash(_orig, _targs);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Context>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Context_asInterface) class Context_static_extension {
    /**
        // getID returns a unique ID for the type t.
    **/
    @:keep
    static public function _getID( _ctxt:Ref<Context>, _t:Type):GoInt {
        var __deferstack__:Array<Void -> Void> = [];
        _ctxt._mu.lock();
        try {
            __deferstack__.unshift(() -> _ctxt._mu.unlock());
            var __tmp__ = (_ctxt._originIDs != null && _ctxt._originIDs.exists(_t) ? { value : _ctxt._originIDs[_t], ok : true } : { value : (0 : GoInt), ok : false }), _id:GoInt = __tmp__.value, _ok:Bool = __tmp__.ok;
            if (!_ok) {
                _id = _ctxt._nextID;
                _ctxt._originIDs[_t] = _id;
                _ctxt._nextID++;
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _id;
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return (0 : GoInt);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return (0 : GoInt);
        };
    }
    /**
        // update de-duplicates n against previously seen types with the hash h.  If an
        // identical type is found with the type hash h, the previously seen type is
        // returned. Otherwise, n is returned, and recorded in the Context for the hash
        // h.
    **/
    @:keep
    static public function _update( _ctxt:Ref<Context>, _h:GoString, _orig:Type, _targs:Slice<Type>, _inst:Type):Type {
        var __deferstack__:Array<Void -> Void> = [];
        _assert(_inst != null);
        try {
            _ctxt._mu.lock();
            __deferstack__.unshift(() -> _ctxt._mu.unlock());
            for (__0 => _e in _ctxt._typeMap[_h]) {
                if ((_inst == null) || identical(_inst, _e._instance)) {
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _e._instance;
                    };
                };
                if (false) {
                    throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("%s and %s are not identical" : GoString), Go.toInterface(_inst), Go.toInterface(_e._instance)));
                };
            };
            _ctxt._typeMap[_h] = (_ctxt._typeMap[_h].__append__(({ _orig : _orig, _targs : _targs, _instance : _inst } : T_ctxtEntry)));
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _inst;
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return (null : stdgo.go.types.Types.Type);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return (null : stdgo.go.types.Types.Type);
        };
    }
    /**
        // lookup returns an existing instantiation of orig with targs, if it exists.
        // Otherwise, it returns nil.
    **/
    @:keep
    static public function _lookup( _ctxt:Ref<Context>, _h:GoString, _orig:Type, _targs:Slice<Type>):Type {
        var __deferstack__:Array<Void -> Void> = [];
        _ctxt._mu.lock();
        try {
            __deferstack__.unshift(() -> _ctxt._mu.unlock());
            for (__0 => _e in _ctxt._typeMap[_h]) {
                if (_identicalInstance(_orig, _targs, _e._orig, _e._targs)) {
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _e._instance;
                    };
                };
                if (false) {
                    throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("non-identical instances: (orig: %s, targs: %v) and %s" : GoString), Go.toInterface(_orig), Go.toInterface(_targs), Go.toInterface(_e._instance)));
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return (null : stdgo.go.types.Types.Type);
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return (null : stdgo.go.types.Types.Type);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return (null : stdgo.go.types.Types.Type);
        };
    }
    /**
        // instanceHash returns a string representation of typ instantiated with targs.
        // The hash should be a perfect hash, though out of caution the type checker
        // does not assume this. The result is guaranteed to not contain blanks.
    **/
    @:keep
    static public function _instanceHash( _ctxt:Ref<Context>, _orig:Type, _targs:Slice<Type>):GoString {
        _assert(_ctxt != null && ((_ctxt : Dynamic).__nil__ == null || !(_ctxt : Dynamic).__nil__));
        _assert(_orig != null);
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        var _h = _newTypeHasher((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>), _ctxt);
        _h._string(stdgo.strconv.Strconv.itoa(_ctxt._getID(_orig)));
        _h._typ(_orig);
        if ((_targs.length) > (0 : GoInt)) {
            _h._typeList(_targs);
        };
        return stdgo.strings.Strings.replace((_buf.string() : GoString), (" " : GoString), ("#" : GoString), (-1 : GoInt));
    }
}
class T_importDecl_asInterface {
    @:keep
    public dynamic function _node():stdgo.go.ast.Ast.Node return __self__.value._node();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_importDecl>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_importDecl_asInterface) class T_importDecl_static_extension {
    @:keep
    static public function _node( _d:T_importDecl):stdgo.go.ast.Ast.Node {
        return Go.asInterface(_d._spec);
    }
}
class T_constDecl_asInterface {
    @:keep
    public dynamic function _node():stdgo.go.ast.Ast.Node return __self__.value._node();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_constDecl>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_constDecl_asInterface) class T_constDecl_static_extension {
    @:keep
    static public function _node( _d:T_constDecl):stdgo.go.ast.Ast.Node {
        return Go.asInterface(_d._spec);
    }
}
class T_varDecl_asInterface {
    @:keep
    public dynamic function _node():stdgo.go.ast.Ast.Node return __self__.value._node();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_varDecl>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_varDecl_asInterface) class T_varDecl_static_extension {
    @:keep
    static public function _node( _d:T_varDecl):stdgo.go.ast.Ast.Node {
        return Go.asInterface(_d._spec);
    }
}
class T_typeDecl_asInterface {
    @:keep
    public dynamic function _node():stdgo.go.ast.Ast.Node return __self__.value._node();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_typeDecl>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_typeDecl_asInterface) class T_typeDecl_static_extension {
    @:keep
    static public function _node( _d:T_typeDecl):stdgo.go.ast.Ast.Node {
        return Go.asInterface(_d._spec);
    }
}
class T_funcDecl_asInterface {
    @:keep
    public dynamic function _node():stdgo.go.ast.Ast.Node return __self__.value._node();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_funcDecl>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_funcDecl_asInterface) class T_funcDecl_static_extension {
    @:keep
    static public function _node( _d:T_funcDecl):stdgo.go.ast.Ast.Node {
        return Go.asInterface(_d._decl);
    }
}
class T_error__asInterface {
    /**
        // errorf adds formatted error information to err.
        // It may be called multiple times to provide additional information.
    **/
    @:keep
    public dynamic function _errorf(_at:stdgo.go.token.Token.Pos, _format:GoString, _args:haxe.Rest<AnyInterface>):Void __self__.value._errorf(_at, _format, ..._args);
    /**
        // String is for testing.
    **/
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:keep
    public dynamic function _msg(_fset:Ref<stdgo.go.token.Token.FileSet>, _qf:Qualifier):GoString return __self__.value._msg(_fset, _qf);
    @:keep
    public dynamic function _pos():stdgo.go.token.Token.Pos return __self__.value._pos();
    @:keep
    public dynamic function _empty():Bool return __self__.value._empty();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_error_>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_error__asInterface) class T_error__static_extension {
    /**
        // errorf adds formatted error information to err.
        // It may be called multiple times to provide additional information.
    **/
    @:keep
    static public function _errorf( _err:Ref<T_error_>, _at:stdgo.go.token.Token.Pos, _format:GoString, _args:haxe.Rest<AnyInterface>):Void {
        var _args = new Slice<AnyInterface>(_args.length, 0, ..._args);
        _err._desc = (_err._desc.__append__((new T_errorDesc(Go.asInterface((_at : T_atPos)), _format, _args) : T_errorDesc)));
    }
    /**
        // String is for testing.
    **/
    @:keep
    static public function string( _err:Ref<T_error_>):GoString {
        if (_err._empty()) {
            return ("no error" : GoString);
        };
        return stdgo.fmt.Fmt.sprintf(("%d: %s" : GoString), Go.toInterface(Go.asInterface(_err._pos())), Go.toInterface(_err._msg(null, null)));
    }
    @:keep
    static public function _msg( _err:Ref<T_error_>, _fset:Ref<stdgo.go.token.Token.FileSet>, _qf:Qualifier):GoString {
        if (_err._empty()) {
            return ("no error" : GoString);
        };
        var _buf:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
        for (_i in 0 ... _err._desc.length.toBasic()) {
            var _p = (Go.setRef(_err._desc[(_i : GoInt)]) : Ref<stdgo.go.types.Types.T_errorDesc>);
            if (_i > (0 : GoInt)) {
                stdgo.fmt.Fmt.fprint(Go.asInterface((Go.setRef(_buf) : Ref<stdgo.strings.Strings.Builder>)), Go.toInterface(("\n\t" : GoString)));
                if (_p._posn.pos().isValid()) {
                    stdgo.fmt.Fmt.fprintf(Go.asInterface((Go.setRef(_buf) : Ref<stdgo.strings.Strings.Builder>)), ("%s: " : GoString), Go.toInterface(Go.asInterface(_fset.position(_p._posn.pos()))));
                };
            };
            _buf.writeString(_sprintf(_fset, _qf, false, _p._format, ..._p._args.__toArray__()));
        };
        return (_buf.string() : GoString);
    }
    @:keep
    static public function _pos( _err:Ref<T_error_>):stdgo.go.token.Token.Pos {
        if (_err._empty()) {
            return (0 : stdgo.go.token.Token.Pos);
        };
        return _err._desc[(0 : GoInt)]._posn.pos();
    }
    @:keep
    static public function _empty( _err:Ref<T_error_>):Bool {
        return _err._desc == null;
    }
}
class T_posSpan_asInterface {
    @:keep
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_posSpan>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_posSpan_asInterface) class T_posSpan_static_extension {
    @:keep
    static public function pos( _e:T_posSpan):stdgo.go.token.Token.Pos {
        return _e._pos;
    }
}
class T_tpWalker_asInterface {
    @:keep
    public dynamic function _isParameterizedTypeList(_list:Slice<Type>):Bool return __self__.value._isParameterizedTypeList(_list);
    @:keep
    public dynamic function _isParameterized(_typ:Type):Bool return __self__.value._isParameterized(_typ);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_tpWalker>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_tpWalker_asInterface) class T_tpWalker_static_extension {
    @:keep
    static public function _isParameterizedTypeList( _w:Ref<T_tpWalker>, _list:Slice<Type>):Bool {
        for (__0 => _t in _list) {
            if (_w._isParameterized(_t)) {
                return true;
            };
        };
        return false;
    }
    @:keep
    static public function _isParameterized( _w:Ref<T_tpWalker>, _typ:Type):Bool {
        var __deferstack__:Array<Void -> Void> = [];
        var _res:Bool = false;
        try {
            {
                var __tmp__ = (_w._seen != null && _w._seen.exists(_typ) ? { value : _w._seen[_typ], ok : true } : { value : false, ok : false }), _x:Bool = __tmp__.value, _ok:Bool = __tmp__.ok;
                if (_ok) {
                    return _x;
                };
            };
            _w._seen[_typ] = false;
            __deferstack__.unshift(() -> {
                var a = function():Void {
                    _w._seen[_typ] = _res;
                };
                a();
            });
            {
                final __type__ = _typ;
                {
                    var __bool__ = true;
                    while (__bool__) {
                        __bool__ = false;
                        if (__type__ == null || Go.typeEquals((__type__ : Ref<Basic>))) {
                            var _t:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                            break;
                        } else if (Go.typeEquals((__type__ : Ref<Array_>))) {
                            var _t:Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _w._isParameterized(_t._elem);
                            };
                        } else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
                            var _t:Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _w._isParameterized(_t._elem);
                            };
                        } else if (Go.typeEquals((__type__ : Ref<Struct>))) {
                            var _t:Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                            for (__0 => _fld in _t._fields) {
                                if (_w._isParameterized(_fld._object._typ)) {
                                    {
                                        for (defer in __deferstack__) {
                                            defer();
                                        };
                                        return true;
                                    };
                                };
                            };
                        } else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
                            var _t:Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _w._isParameterized(_t._base);
                            };
                        } else if (Go.typeEquals((__type__ : Ref<Tuple>))) {
                            var _t:Ref<stdgo.go.types.Types.Tuple> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Tuple>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Tuple>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Tuple>) : __type__.__underlying__().value;
                            var _n:GoInt = _t.len();
                            {
                                var _i:GoInt = (0 : GoInt);
                                Go.cfor(_i < _n, _i++, {
                                    if (_w._isParameterized(_t.at(_i)._object._typ)) {
                                        {
                                            for (defer in __deferstack__) {
                                                defer();
                                            };
                                            return true;
                                        };
                                    };
                                });
                            };
                        } else if (Go.typeEquals((__type__ : Ref<Signature>))) {
                            var _t:Ref<stdgo.go.types.Types.Signature> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__().value;
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _w._isParameterized(Go.asInterface(_t._params)) || _w._isParameterized(Go.asInterface(_t._results));
                            };
                        } else if (Go.typeEquals((__type__ : Ref<Interface>))) {
                            var _t:Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                            var _tset = _t._typeSet();
                            for (__1 => _m in _tset._methods) {
                                if (_w._isParameterized(_m._object._typ)) {
                                    {
                                        for (defer in __deferstack__) {
                                            defer();
                                        };
                                        return true;
                                    };
                                };
                            };
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _tset._is(function(_t:Ref<T_term>):Bool {
                                    return ((_t != null) && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) && _w._isParameterized(_t._typ);
                                });
                            };
                        } else if (Go.typeEquals((__type__ : Ref<Map_>))) {
                            var _t:Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _w._isParameterized(_t._key) || _w._isParameterized(_t._elem);
                            };
                        } else if (Go.typeEquals((__type__ : Ref<Chan>))) {
                            var _t:Ref<stdgo.go.types.Types.Chan> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__().value;
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _w._isParameterized(_t._elem);
                            };
                        } else if (Go.typeEquals((__type__ : Ref<Named>))) {
                            var _t:Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _w._isParameterizedTypeList(_t.typeArgs()._list());
                            };
                        } else if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
                            var _t:Ref<stdgo.go.types.Types.TypeParam> = __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__().value;
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _tparamIndex(_w._tparams, _t) >= (0 : GoInt);
                            };
                        } else {
                            var _t:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                            _unreachable();
                        };
                        break;
                    };
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return false;
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return _res;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return _res;
        };
    }
}
class T_cycleFinder_asInterface {
    @:keep
    public dynamic function _varList(_list:Slice<Ref<Var>>):Void __self__.value._varList(_list);
    @:keep
    public dynamic function _typ(_typ:Type):Void __self__.value._typ(_typ);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_cycleFinder>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_cycleFinder_asInterface) class T_cycleFinder_static_extension {
    @:keep
    static public function _varList( _w:Ref<T_cycleFinder>, _list:Slice<Ref<Var>>):Void {
        for (__0 => _v in _list) {
            _w._typ(_v._object._typ);
        };
    }
    @:keep
    static public function _typ( _w:Ref<T_cycleFinder>, _typ:Type):Void {
        var __deferstack__:Array<Void -> Void> = [];
        try {
            if (_w._seen[_typ]) {
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_typ) : Ref<TypeParam>)) : Ref<TypeParam>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.TypeParam>), ok : false };
                    }, _tpar = __tmp__.value, __0 = __tmp__.ok;
                    if (_tpar != null && ((_tpar : Dynamic).__nil__ == null || !(_tpar : Dynamic).__nil__)) {
                        {
                            var _i:GoInt = _tparamIndex(_w._tparams, _tpar);
                            if (_i >= (0 : GoInt)) {
                                _w._types[(_i : GoInt)] = (null : stdgo.go.types.Types.Type);
                            };
                        };
                    };
                };
                return;
            };
            _w._seen[_typ] = true;
            {
                var _a0 = _w._seen;
                var _a1 = _typ;
                __deferstack__.unshift(() -> if (_a0 != null) _a0.remove(_a1));
            };
            {
                final __type__ = _typ;
                if (Go.typeEquals((__type__ : Ref<Basic>))) {
                    var _t:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                } else if (Go.typeEquals((__type__ : Ref<Array_>))) {
                    var _t:Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                    _w._typ(_t._elem);
                } else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
                    var _t:Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                    _w._typ(_t._elem);
                } else if (Go.typeEquals((__type__ : Ref<Struct>))) {
                    var _t:Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                    _w._varList(_t._fields);
                } else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
                    var _t:Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                    _w._typ(_t._base);
                } else if (Go.typeEquals((__type__ : Ref<Signature>))) {
                    var _t:Ref<stdgo.go.types.Types.Signature> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__().value;
                    if (_t._params != null && ((_t._params : Dynamic).__nil__ == null || !(_t._params : Dynamic).__nil__)) {
                        _w._varList(_t._params._vars);
                    };
                    if (_t._results != null && ((_t._results : Dynamic).__nil__ == null || !(_t._results : Dynamic).__nil__)) {
                        _w._varList(_t._results._vars);
                    };
                } else if (Go.typeEquals((__type__ : Ref<Union>))) {
                    var _t:Ref<stdgo.go.types.Types.Union> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Union>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__().value;
                    for (__1 => _t in _t._terms) {
                        _w._typ(_t._typ);
                    };
                } else if (Go.typeEquals((__type__ : Ref<Interface>))) {
                    var _t:Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                    for (__2 => _m in _t._methods) {
                        _w._typ(_m._object._typ);
                    };
                    for (__11 => _t in _t._embeddeds) {
                        _w._typ(_t);
                    };
                } else if (Go.typeEquals((__type__ : Ref<Map_>))) {
                    var _t:Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                    _w._typ(_t._key);
                    _w._typ(_t._elem);
                } else if (Go.typeEquals((__type__ : Ref<Chan>))) {
                    var _t:Ref<stdgo.go.types.Types.Chan> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__().value;
                    _w._typ(_t._elem);
                } else if (Go.typeEquals((__type__ : Ref<Named>))) {
                    var _t:Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                    for (__20 => _tpar in _t.typeArgs()._list()) {
                        _w._typ(_tpar);
                    };
                } else if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
                    var _t:Ref<stdgo.go.types.Types.TypeParam> = __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__().value;
                    {
                        var _i:GoInt = _tparamIndex(_w._tparams, _t);
                        if ((_i >= (0 : GoInt)) && (_w._types[(_i : GoInt)] != null)) {
                            _w._typ(_w._types[(_i : GoInt)]);
                        };
                    };
                } else {
                    var _t:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                    throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("unexpected %T" : GoString), Go.toInterface(_typ)));
                };
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return;
        };
    }
}
class T_graphNode_asInterface {
    /**
        // cost returns the cost of removing this node, which involves copying each
        // predecessor to each successor (and vice-versa).
    **/
    @:keep
    public dynamic function _cost():GoInt return __self__.value._cost();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_graphNode>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_graphNode_asInterface) class T_graphNode_static_extension {
    /**
        // cost returns the cost of removing this node, which involves copying each
        // predecessor to each successor (and vice-versa).
    **/
    @:keep
    static public function _cost( _n:Ref<T_graphNode>):GoInt {
        return (_n._pred.length) * (_n._succ.length);
    }
}
class Interface_asInterface {
    @:keep
    public dynamic function _cleanup():Void __self__.value._cleanup();
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type return __self__.value.underlying();
    /**
        // Complete computes the interface's type set. It must be called by users of
        // NewInterfaceType and NewInterface after the interface's embedded types are
        // fully defined and before using the interface type in any way other than to
        // form other types. The interface must not contain duplicate methods or a
        // panic occurs. Complete returns the receiver.
        //
        // Interface types that have been completed are safe for concurrent use.
    **/
    @:keep
    public dynamic function complete():Ref<Interface> return __self__.value.complete();
    /**
        // IsImplicit reports whether the interface t is a wrapper for a type set literal.
    **/
    @:keep
    public dynamic function isImplicit():Bool return __self__.value.isImplicit();
    /**
        // IsMethodSet reports whether the interface t is fully described by its method
        // set.
    **/
    @:keep
    public dynamic function isMethodSet():Bool return __self__.value.isMethodSet();
    /**
        // IsComparable reports whether each type in interface t's type set is comparable.
    **/
    @:keep
    public dynamic function isComparable():Bool return __self__.value.isComparable();
    /**
        // Empty reports whether t is the empty interface.
    **/
    @:keep
    public dynamic function empty():Bool return __self__.value.empty();
    /**
        // Method returns the i'th method of interface t for 0 <= i < t.NumMethods().
        // The methods are ordered by their unique Id.
    **/
    @:keep
    public dynamic function method(_i:GoInt):Ref<Func> return __self__.value.method(_i);
    /**
        // NumMethods returns the total number of methods of interface t.
    **/
    @:keep
    public dynamic function numMethods():GoInt return __self__.value.numMethods();
    /**
        // EmbeddedType returns the i'th embedded type of interface t for 0 <= i < t.NumEmbeddeds().
    **/
    @:keep
    public dynamic function embeddedType(_i:GoInt):Type return __self__.value.embeddedType(_i);
    /**
        // Embedded returns the i'th embedded defined (*Named) type of interface t for 0 <= i < t.NumEmbeddeds().
        // The result is nil if the i'th embedded type is not a defined type.
        //
        // Deprecated: Use EmbeddedType which is not restricted to defined (*Named) types.
    **/
    @:keep
    public dynamic function embedded(_i:GoInt):Ref<Named> return __self__.value.embedded(_i);
    /**
        // NumEmbeddeds returns the number of embedded types in interface t.
    **/
    @:keep
    public dynamic function numEmbeddeds():GoInt return __self__.value.numEmbeddeds();
    /**
        // ExplicitMethod returns the i'th explicitly declared method of interface t for 0 <= i < t.NumExplicitMethods().
        // The methods are ordered by their unique Id.
    **/
    @:keep
    public dynamic function explicitMethod(_i:GoInt):Ref<Func> return __self__.value.explicitMethod(_i);
    /**
        // NumExplicitMethods returns the number of explicitly declared methods of interface t.
    **/
    @:keep
    public dynamic function numExplicitMethods():GoInt return __self__.value.numExplicitMethods();
    /**
        // MarkImplicit marks the interface t as implicit, meaning this interface
        // corresponds to a constraint literal such as ~T or A|B without explicit
        // interface embedding. MarkImplicit should be called before any concurrent use
        // of implicit interfaces.
    **/
    @:keep
    public dynamic function markImplicit():Void __self__.value.markImplicit();
    /**
        // typeSet returns the type set for interface t.
    **/
    @:keep
    public dynamic function _typeSet():Ref<T__TypeSet> return __self__.value._typeSet();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Interface>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Interface_asInterface) class Interface_static_extension {
    @:keep
    static public function _cleanup( _t:Ref<Interface>):Void {
        _t._check = null;
        _t._embedPos = (null : Ref<Slice<stdgo.go.token.Token.Pos>>);
    }
    @:keep
    static public function string( _t:Ref<Interface>):GoString {
        return typeString(Go.asInterface(_t), null);
    }
    @:keep
    static public function underlying( _t:Ref<Interface>):Type {
        return Go.asInterface(_t);
    }
    /**
        // Complete computes the interface's type set. It must be called by users of
        // NewInterfaceType and NewInterface after the interface's embedded types are
        // fully defined and before using the interface type in any way other than to
        // form other types. The interface must not contain duplicate methods or a
        // panic occurs. Complete returns the receiver.
        //
        // Interface types that have been completed are safe for concurrent use.
    **/
    @:keep
    static public function complete( _t:Ref<Interface>):Ref<Interface> {
        if (!_t._complete) {
            _t._complete = true;
        };
        _t._typeSet();
        return _t;
    }
    /**
        // IsImplicit reports whether the interface t is a wrapper for a type set literal.
    **/
    @:keep
    static public function isImplicit( _t:Ref<Interface>):Bool {
        return _t._implicit;
    }
    /**
        // IsMethodSet reports whether the interface t is fully described by its method
        // set.
    **/
    @:keep
    static public function isMethodSet( _t:Ref<Interface>):Bool {
        return _t._typeSet().isMethodSet();
    }
    /**
        // IsComparable reports whether each type in interface t's type set is comparable.
    **/
    @:keep
    static public function isComparable( _t:Ref<Interface>):Bool {
        return _t._typeSet().isComparable((null : GoMap<stdgo.go.types.Types.Type, Bool>));
    }
    /**
        // Empty reports whether t is the empty interface.
    **/
    @:keep
    static public function empty( _t:Ref<Interface>):Bool {
        return _t._typeSet().isAll();
    }
    /**
        // Method returns the i'th method of interface t for 0 <= i < t.NumMethods().
        // The methods are ordered by their unique Id.
    **/
    @:keep
    static public function method( _t:Ref<Interface>, _i:GoInt):Ref<Func> {
        return _t._typeSet().method(_i);
    }
    /**
        // NumMethods returns the total number of methods of interface t.
    **/
    @:keep
    static public function numMethods( _t:Ref<Interface>):GoInt {
        return _t._typeSet().numMethods();
    }
    /**
        // EmbeddedType returns the i'th embedded type of interface t for 0 <= i < t.NumEmbeddeds().
    **/
    @:keep
    static public function embeddedType( _t:Ref<Interface>, _i:GoInt):Type {
        return _t._embeddeds[(_i : GoInt)];
    }
    /**
        // Embedded returns the i'th embedded defined (*Named) type of interface t for 0 <= i < t.NumEmbeddeds().
        // The result is nil if the i'th embedded type is not a defined type.
        //
        // Deprecated: Use EmbeddedType which is not restricted to defined (*Named) types.
    **/
    @:keep
    static public function embedded( _t:Ref<Interface>, _i:GoInt):Ref<Named> {
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(_t._embeddeds[(_i : GoInt)]) : Ref<Named>)) : Ref<Named>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
        }, _tname = __tmp__.value, __8 = __tmp__.ok;
        return _tname;
    }
    /**
        // NumEmbeddeds returns the number of embedded types in interface t.
    **/
    @:keep
    static public function numEmbeddeds( _t:Ref<Interface>):GoInt {
        return (_t._embeddeds.length);
    }
    /**
        // ExplicitMethod returns the i'th explicitly declared method of interface t for 0 <= i < t.NumExplicitMethods().
        // The methods are ordered by their unique Id.
    **/
    @:keep
    static public function explicitMethod( _t:Ref<Interface>, _i:GoInt):Ref<Func> {
        return _t._methods[(_i : GoInt)];
    }
    /**
        // NumExplicitMethods returns the number of explicitly declared methods of interface t.
    **/
    @:keep
    static public function numExplicitMethods( _t:Ref<Interface>):GoInt {
        return (_t._methods.length);
    }
    /**
        // MarkImplicit marks the interface t as implicit, meaning this interface
        // corresponds to a constraint literal such as ~T or A|B without explicit
        // interface embedding. MarkImplicit should be called before any concurrent use
        // of implicit interfaces.
    **/
    @:keep
    static public function markImplicit( _t:Ref<Interface>):Void {
        _t._implicit = true;
    }
    /**
        // typeSet returns the type set for interface t.
    **/
    @:keep
    static public function _typeSet( _t:Ref<Interface>):Ref<T__TypeSet> {
        return _computeInterfaceTypeSet(_t._check, (0 : stdgo.go.token.Token.Pos), _t);
    }
}
class T_block_asInterface {
    /**
        // enclosingTarget returns the innermost enclosing labeled
        // statement with the given label name, or nil.
    **/
    @:keep
    public dynamic function _enclosingTarget(_name:GoString):Ref<stdgo.go.ast.Ast.LabeledStmt> return __self__.value._enclosingTarget(_name);
    /**
        // gotoTarget returns the labeled statement in the current
        // or an enclosing block with the given label name, or nil.
    **/
    @:keep
    public dynamic function _gotoTarget(_name:GoString):Ref<stdgo.go.ast.Ast.LabeledStmt> return __self__.value._gotoTarget(_name);
    /**
        // insert records a new label declaration for the current block.
        // The label must not have been declared before in any block.
    **/
    @:keep
    public dynamic function _insert(_s:Ref<stdgo.go.ast.Ast.LabeledStmt>):Void __self__.value._insert(_s);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_block>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_block_asInterface) class T_block_static_extension {
    /**
        // enclosingTarget returns the innermost enclosing labeled
        // statement with the given label name, or nil.
    **/
    @:keep
    static public function _enclosingTarget( _b:Ref<T_block>, _name:GoString):Ref<stdgo.go.ast.Ast.LabeledStmt> {
        {
            var _s = _b;
            Go.cfor(_s != null && ((_s : Dynamic).__nil__ == null || !(_s : Dynamic).__nil__), _s = _s._parent, {
                {
                    var _t = _s._lstmt;
                    if (((_t != null) && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) && (_t.label.name == _name)) {
                        return _t;
                    };
                };
            });
        };
        return null;
    }
    /**
        // gotoTarget returns the labeled statement in the current
        // or an enclosing block with the given label name, or nil.
    **/
    @:keep
    static public function _gotoTarget( _b:Ref<T_block>, _name:GoString):Ref<stdgo.go.ast.Ast.LabeledStmt> {
        {
            var _s = _b;
            Go.cfor(_s != null && ((_s : Dynamic).__nil__ == null || !(_s : Dynamic).__nil__), _s = _s._parent, {
                {
                    var _t = _s._labels[_name];
                    if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
                        return _t;
                    };
                };
            });
        };
        return null;
    }
    /**
        // insert records a new label declaration for the current block.
        // The label must not have been declared before in any block.
    **/
    @:keep
    static public function _insert( _b:Ref<T_block>, _s:Ref<stdgo.go.ast.Ast.LabeledStmt>):Void {
        var _name:GoString = _s.label.name;
        if (false) {
            _assert(_b._gotoTarget(_name) == null || (_b._gotoTarget(_name) : Dynamic).__nil__);
        };
        var _labels = _b._labels;
        if (_labels == null) {
            _labels = ({
                final x = new stdgo.GoMap.GoStringMap<Ref<stdgo.go.ast.Ast.LabeledStmt>>();
                x.__defaultValue__ = () -> (null : Ref<stdgo.go.ast.Ast.LabeledStmt>);
                @:mergeBlock {};
                x;
            } : GoMap<GoString, Ref<stdgo.go.ast.Ast.LabeledStmt>>);
            _b._labels = _labels;
        };
        _labels[_name] = _s;
    }
}
class T_instanceLookup_asInterface {
    @:keep
    public dynamic function _add(_inst:Ref<Named>):Void __self__.value._add(_inst);
    @:keep
    public dynamic function _lookup(_inst:Ref<Named>):Ref<Named> return __self__.value._lookup(_inst);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_instanceLookup>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_instanceLookup_asInterface) class T_instanceLookup_static_extension {
    @:keep
    static public function _add( _l:Ref<T_instanceLookup>, _inst:Ref<Named>):Void {
        for (_i => _t in _l._buf) {
            if (_t == null || (_t : Dynamic).__nil__) {
                _l._buf[(_i : GoInt)] = _inst;
                return;
            };
        };
        if (_l._m == null) {
            _l._m = ({
                final x = new GoRefMap<Ref<stdgo.go.types.Types.Named>, Slice<Ref<stdgo.go.types.Types.Named>>>();
                @:mergeBlock {};
                cast x;
            } : GoMap<Ref<stdgo.go.types.Types.Named>, Slice<Ref<stdgo.go.types.Types.Named>>>);
        };
        var _insts = _l._m[_inst.origin()];
        _l._m[_inst.origin()] = (_insts.__append__(_inst));
    }
    @:keep
    static public function _lookup( _l:Ref<T_instanceLookup>, _inst:Ref<Named>):Ref<Named> {
        for (__0 => _t in _l._buf) {
            if (((_t != null) && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) && identical(Go.asInterface(_inst), Go.asInterface(_t))) {
                return _t;
            };
        };
        for (__1 => _t in _l._m[_inst.origin()]) {
            if (identical(Go.asInterface(_inst), Go.asInterface(_t))) {
                return _t;
            };
        };
        return null;
    }
}
class Map__asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type return __self__.value.underlying();
    /**
        // Elem returns the element type of map m.
    **/
    @:keep
    public dynamic function elem():Type return __self__.value.elem();
    /**
        // Key returns the key type of map m.
    **/
    @:keep
    public dynamic function key():Type return __self__.value.key();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Map_>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Map__asInterface) class Map__static_extension {
    @:keep
    static public function string( _t:Ref<Map_>):GoString {
        return typeString(Go.asInterface(_t), null);
    }
    @:keep
    static public function underlying( _t:Ref<Map_>):Type {
        return Go.asInterface(_t);
    }
    /**
        // Elem returns the element type of map m.
    **/
    @:keep
    static public function elem( _m:Ref<Map_>):Type {
        return _m._elem;
    }
    /**
        // Key returns the key type of map m.
    **/
    @:keep
    static public function key( _m:Ref<Map_>):Type {
        return _m._key;
    }
}
class MethodSet_asInterface {
    /**
        // Lookup returns the method with matching package and name, or nil if not found.
    **/
    @:keep
    public dynamic function lookup(_pkg:Ref<Package>, _name:GoString):Ref<Selection> return __self__.value.lookup(_pkg, _name);
    /**
        // At returns the i'th method in s for 0 <= i < s.Len().
    **/
    @:keep
    public dynamic function at(_i:GoInt):Ref<Selection> return __self__.value.at(_i);
    /**
        // Len returns the number of methods in s.
    **/
    @:keep
    public dynamic function len():GoInt return __self__.value.len();
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<MethodSet>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.MethodSet_asInterface) class MethodSet_static_extension {
    /**
        // Lookup returns the method with matching package and name, or nil if not found.
    **/
    @:keep
    static public function lookup( _s:Ref<MethodSet>, _pkg:Ref<Package>, _name:GoString):Ref<Selection> {
        if (_s.len() == ((0 : GoInt))) {
            return null;
        };
        var _key:GoString = id(_pkg, _name);
        var _i:GoInt = stdgo.sort.Sort.search((_s._list.length), function(_i:GoInt):Bool {
            var _m = _s._list[(_i : GoInt)];
            return _m._obj.id() >= _key;
        });
        if (_i < (_s._list.length)) {
            var _m = _s._list[(_i : GoInt)];
            if (_m._obj.id() == (_key)) {
                return _m;
            };
        };
        return null;
    }
    /**
        // At returns the i'th method in s for 0 <= i < s.Len().
    **/
    @:keep
    static public function at( _s:Ref<MethodSet>, _i:GoInt):Ref<Selection> {
        return _s._list[(_i : GoInt)];
    }
    /**
        // Len returns the number of methods in s.
    **/
    @:keep
    static public function len( _s:Ref<MethodSet>):GoInt {
        return (_s._list.length);
    }
    @:keep
    static public function string( _s:Ref<MethodSet>):GoString {
        if (_s.len() == ((0 : GoInt))) {
            return ("MethodSet {}" : GoString);
        };
        var _buf:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
        stdgo.fmt.Fmt.fprintln(Go.asInterface((Go.setRef(_buf) : Ref<stdgo.strings.Strings.Builder>)), Go.toInterface(("MethodSet {" : GoString)));
        for (__0 => _f in _s._list) {
            stdgo.fmt.Fmt.fprintf(Go.asInterface((Go.setRef(_buf) : Ref<stdgo.strings.Strings.Builder>)), ("\t%s\n" : GoString), Go.toInterface(Go.asInterface(_f)));
        };
        stdgo.fmt.Fmt.fprintln(Go.asInterface((Go.setRef(_buf) : Ref<stdgo.strings.Strings.Builder>)), Go.toInterface(("}" : GoString)));
        return (_buf.string() : GoString);
    }
}
class T_monoGraph_asInterface {
    @:keep
    public dynamic function _addEdge(_dst:GoInt, _src:GoInt, _weight:GoInt, _pos:stdgo.go.token.Token.Pos, _typ:Type):Void __self__.value._addEdge(_dst, _src, _weight, _pos, _typ);
    /**
        // typeParamVertex returns the index of the vertex representing tpar.
    **/
    @:keep
    public dynamic function _typeParamVertex(_tpar:Ref<TypeParam>):GoInt return __self__.value._typeParamVertex(_tpar);
    /**
        // localNamedVertex returns the index of the vertex representing
        // named, or -1 if named doesn't need representation.
    **/
    @:keep
    public dynamic function _localNamedVertex(_pkg:Ref<Package>, _named:Ref<Named>):GoInt return __self__.value._localNamedVertex(_pkg, _named);
    /**
        // assign records that tpar was instantiated as targ at pos.
    **/
    @:keep
    public dynamic function _assign(_pkg:Ref<Package>, _pos:stdgo.go.token.Token.Pos, _tpar:Ref<TypeParam>, _targ:Type):Void __self__.value._assign(_pkg, _pos, _tpar, _targ);
    /**
        // recordInstance records that the given type parameters were
        // instantiated with the corresponding type arguments.
    **/
    @:keep
    public dynamic function _recordInstance(_pkg:Ref<Package>, _pos:stdgo.go.token.Token.Pos, _tparams:Slice<Ref<TypeParam>>, _targs:Slice<Type>, _xlist:Slice<stdgo.go.ast.Ast.Expr>):Void __self__.value._recordInstance(_pkg, _pos, _tparams, _targs, _xlist);
    /**
        // recordCanon records that tpar is the canonical type parameter
        // corresponding to method type parameter mpar.
    **/
    @:keep
    public dynamic function _recordCanon(_mpar:Ref<TypeParam>, _tpar:Ref<TypeParam>):Void __self__.value._recordCanon(_mpar, _tpar);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_monoGraph>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_monoGraph_asInterface) class T_monoGraph_static_extension {
    @:keep
    static public function _addEdge( _w:Ref<T_monoGraph>, _dst:GoInt, _src:GoInt, _weight:GoInt, _pos:stdgo.go.token.Token.Pos, _typ:Type):Void {
        _w._edges = (_w._edges.__append__(({ _dst : _dst, _src : _src, _weight : _weight, _pos : _pos, _typ : _typ } : T_monoEdge)));
    }
    /**
        // typeParamVertex returns the index of the vertex representing tpar.
    **/
    @:keep
    static public function _typeParamVertex( _w:Ref<T_monoGraph>, _tpar:Ref<TypeParam>):GoInt {
        {
            var __tmp__ = (_w._canon != null && _w._canon.exists(_tpar) ? { value : _w._canon[_tpar], ok : true } : { value : (null : Ref<stdgo.go.types.Types.TypeParam>), ok : false }), _x:Ref<stdgo.go.types.Types.TypeParam> = __tmp__.value, _ok:Bool = __tmp__.ok;
            if (_ok) {
                _tpar = _x;
            };
        };
        var _obj = _tpar.obj();
        {
            var __tmp__ = (_w._nameIdx != null && _w._nameIdx.exists(_obj) ? { value : _w._nameIdx[_obj], ok : true } : { value : (0 : GoInt), ok : false }), _idx:GoInt = __tmp__.value, _ok:Bool = __tmp__.ok;
            if (_ok) {
                return _idx;
            };
        };
        if (_w._nameIdx == null) {
            _w._nameIdx = ({
                final x = new GoRefMap<Ref<stdgo.go.types.Types.TypeName>, GoInt>();
                @:mergeBlock {};
                cast x;
            } : GoMap<Ref<stdgo.go.types.Types.TypeName>, GoInt>);
        };
        var _idx:GoInt = (_w._vertices.length);
        _w._vertices = (_w._vertices.__append__(({ _obj : _obj } : T_monoVertex)));
        _w._nameIdx[_obj] = _idx;
        return _idx;
    }
    /**
        // localNamedVertex returns the index of the vertex representing
        // named, or -1 if named doesn't need representation.
    **/
    @:keep
    static public function _localNamedVertex( _w:Ref<T_monoGraph>, _pkg:Ref<Package>, _named:Ref<Named>):GoInt {
        var _obj = _named.obj();
        if (_obj.pkg() != (_pkg)) {
            return (-1 : GoInt);
        };
        var _root = _pkg.scope();
        if (_obj.parent() == (_root)) {
            return (-1 : GoInt);
        };
        {
            var __tmp__ = (_w._nameIdx != null && _w._nameIdx.exists(_obj) ? { value : _w._nameIdx[_obj], ok : true } : { value : (0 : GoInt), ok : false }), _idx:GoInt = __tmp__.value, _ok:Bool = __tmp__.ok;
            if (_ok) {
                return _idx;
            };
        };
        var _idx:GoInt = (-1 : GoInt);
        {
            var _scope = _obj.parent();
            Go.cfor(_scope != (_root), _scope = _scope.parent(), {
                for (__0 => _elem in _scope._elems) {
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_elem) : Ref<TypeName>)) : Ref<TypeName>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.types.Types.TypeName>), ok : false };
                        }, _elem = __tmp__.value, _ok = __tmp__.ok;
                        if ((_ok && !_elem.isAlias()) && (_elem.pos() < _obj.pos())) {
                            {
                                var __tmp__ = try {
                                    { value : (Go.typeAssert((Go.toInterface(_elem.type()) : Ref<TypeParam>)) : Ref<TypeParam>), ok : true };
                                } catch(_) {
                                    { value : (null : Ref<stdgo.go.types.Types.TypeParam>), ok : false };
                                }, _tpar = __tmp__.value, _ok = __tmp__.ok;
                                if (_ok) {
                                    if (_idx < (0 : GoInt)) {
                                        _idx = (_w._vertices.length);
                                        _w._vertices = (_w._vertices.__append__(({ _obj : _obj } : T_monoVertex)));
                                    };
                                    _w._addEdge(_idx, _w._typeParamVertex(_tpar), (1 : GoInt), _obj.pos(), Go.asInterface(_tpar));
                                };
                            };
                        };
                    };
                };
            });
        };
        if (_w._nameIdx == null) {
            _w._nameIdx = ({
                final x = new GoRefMap<Ref<stdgo.go.types.Types.TypeName>, GoInt>();
                @:mergeBlock {};
                cast x;
            } : GoMap<Ref<stdgo.go.types.Types.TypeName>, GoInt>);
        };
        _w._nameIdx[_obj] = _idx;
        return _idx;
    }
    /**
        // assign records that tpar was instantiated as targ at pos.
    **/
    @:keep
    static public function _assign( _w:Ref<T_monoGraph>, _pkg:Ref<Package>, _pos:stdgo.go.token.Token.Pos, _tpar:Ref<TypeParam>, _targ:Type):Void {
        if (_tpar.obj().pkg() != (_pkg)) {
            return;
        };
        var _flow:(GoInt, stdgo.go.types.Types.Type) -> Void = function(_src:GoInt, _typ:Type):Void {
            var _weight:GoInt = (1 : GoInt);
            if (Go.toInterface(_typ) == (Go.toInterface(_targ))) {
                _weight = (0 : GoInt);
            };
            _w._addEdge(_w._typeParamVertex(_tpar), _src, _weight, _pos, _targ);
        };
        var _do:(_typ:Type) -> Void = null;
        _do = function(_typ:Type):Void {
            {
                final __type__ = _typ;
                if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
                    var _typ:Ref<stdgo.go.types.Types.TypeParam> = __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__().value;
                    _assert(_typ.obj().pkg() == (_pkg));
                    _flow(_w._typeParamVertex(_typ), Go.asInterface(_typ));
                } else if (Go.typeEquals((__type__ : Ref<Named>))) {
                    var _typ:Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                    {
                        var _src:GoInt = _w._localNamedVertex(_pkg, _typ.origin());
                        if (_src >= (0 : GoInt)) {
                            _flow(_src, Go.asInterface(_typ));
                        };
                    };
                    var _targs = _typ.typeArgs();
                    {
                        var _i:GoInt = (0 : GoInt);
                        Go.cfor(_i < _targs.len(), _i++, {
                            _do(_targs.at(_i));
                        });
                    };
                } else if (Go.typeEquals((__type__ : Ref<Array_>))) {
                    var _typ:Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                    _do(_typ.elem());
                } else if (Go.typeEquals((__type__ : Ref<Basic>))) {
                    var _typ:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                } else if (Go.typeEquals((__type__ : Ref<Chan>))) {
                    var _typ:Ref<stdgo.go.types.Types.Chan> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__().value;
                    _do(_typ.elem());
                } else if (Go.typeEquals((__type__ : Ref<Map_>))) {
                    var _typ:Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                    _do(_typ.key());
                    _do(_typ.elem());
                } else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
                    var _typ:Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                    _do(_typ.elem());
                } else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
                    var _typ:Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                    _do(_typ.elem());
                } else if (Go.typeEquals((__type__ : Ref<Interface>))) {
                    var _typ:Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                    {
                        var _i:GoInt = (0 : GoInt);
                        Go.cfor(_i < _typ.numMethods(), _i++, {
                            _do(_typ.method(_i).type());
                        });
                    };
                } else if (Go.typeEquals((__type__ : Ref<Signature>))) {
                    var _typ:Ref<stdgo.go.types.Types.Signature> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__().value;
                    var _tuple = function(_tup:Ref<Tuple>):Void {
                        {
                            var _i:GoInt = (0 : GoInt);
                            Go.cfor(_i < _tup.len(), _i++, {
                                _do(_tup.at(_i).type());
                            });
                        };
                    };
                    _tuple(_typ.params());
                    _tuple(_typ.results());
                } else if (Go.typeEquals((__type__ : Ref<Struct>))) {
                    var _typ:Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                    {
                        var _i:GoInt = (0 : GoInt);
                        Go.cfor(_i < _typ.numFields(), _i++, {
                            _do(_typ.field(_i).type());
                        });
                    };
                } else {
                    var _typ:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                    throw Go.toInterface(("unexpected type" : GoString));
                };
            };
        };
        _do(_targ);
    }
    /**
        // recordInstance records that the given type parameters were
        // instantiated with the corresponding type arguments.
    **/
    @:keep
    static public function _recordInstance( _w:Ref<T_monoGraph>, _pkg:Ref<Package>, _pos:stdgo.go.token.Token.Pos, _tparams:Slice<Ref<TypeParam>>, _targs:Slice<Type>, _xlist:Slice<stdgo.go.ast.Ast.Expr>):Void {
        for (_i => _tpar in _tparams) {
            var _pos:stdgo.go.token.Token.Pos = _pos;
            if (_i < (_xlist.length)) {
                _pos = _xlist[(_i : GoInt)].pos();
            };
            _w._assign(_pkg, _pos, _tpar, _targs[(_i : GoInt)]);
        };
    }
    /**
        // recordCanon records that tpar is the canonical type parameter
        // corresponding to method type parameter mpar.
    **/
    @:keep
    static public function _recordCanon( _w:Ref<T_monoGraph>, _mpar:Ref<TypeParam>, _tpar:Ref<TypeParam>):Void {
        if (_w._canon == null) {
            _w._canon = ({
                final x = new GoRefMap<Ref<stdgo.go.types.Types.TypeParam>, Ref<stdgo.go.types.Types.TypeParam>>();
                @:mergeBlock {};
                cast x;
            } : GoMap<Ref<stdgo.go.types.Types.TypeParam>, Ref<stdgo.go.types.Types.TypeParam>>);
        };
        _w._canon[_mpar] = _tpar;
    }
}
class Named_asInterface {
    /**
        // expandUnderlying substitutes type arguments in the underlying type n.orig,
        // returning the result. Returns Typ[Invalid] if there was an error.
    **/
    @:keep
    public dynamic function _expandUnderlying():Type return __self__.value._expandUnderlying();
    @:keep
    public dynamic function _lookupMethod(_pkg:Ref<Package>, _name:GoString, _foldCase:Bool):{ var _0 : GoInt; var _1 : Ref<Func>; } return __self__.value._lookupMethod(_pkg, _name, _foldCase);
    @:keep
    public dynamic function _setUnderlying(_typ:Type):Void __self__.value._setUnderlying(_typ);
    /**
        // under returns the expanded underlying type of n0; possibly by following
        // forward chains of named types. If an underlying type is found, resolve
        // the chain by setting the underlying type for each defined type in the
        // chain before returning it. If no underlying type is found or a cycle
        // is detected, the result is Typ[Invalid]. If a cycle is detected and
        // n0.check != nil, the cycle is reported.
        //
        // This is necessary because the underlying type of named may be itself a
        // named type that is incomplete:
        //
        //	type (
        //		A B
        //		B *C
        //		C A
        //	)
        //
        // The type of C is the (named) type of A which is incomplete,
        // and which has as its underlying type the named type B.
    **/
    @:keep
    public dynamic function _under():Type return __self__.value._under();
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type return __self__.value.underlying();
    /**
        // AddMethod adds method m unless it is already in the method list.
        // t must not have type arguments.
    **/
    @:keep
    public dynamic function addMethod(_m:Ref<Func>):Void __self__.value.addMethod(_m);
    /**
        // SetUnderlying sets the underlying type and marks t as complete.
        // t must not have type arguments.
    **/
    @:keep
    public dynamic function setUnderlying(_underlying:Type):Void __self__.value.setUnderlying(_underlying);
    /**
        // expandMethod substitutes type arguments in the i'th method for an
        // instantiated receiver.
    **/
    @:keep
    public dynamic function _expandMethod(_i:GoInt):Ref<Func> return __self__.value._expandMethod(_i);
    /**
        // Method returns the i'th method of named type t for 0 <= i < t.NumMethods().
        //
        // For an ordinary or instantiated type t, the receiver base type of this
        // method is the named type t. For an uninstantiated generic type t, each
        // method receiver is instantiated with its receiver type parameters.
    **/
    @:keep
    public dynamic function method(_i:GoInt):Ref<Func> return __self__.value.method(_i);
    /**
        // NumMethods returns the number of explicit methods defined for t.
    **/
    @:keep
    public dynamic function numMethods():GoInt return __self__.value.numMethods();
    /**
        // TypeArgs returns the type arguments used to instantiate the named type t.
    **/
    @:keep
    public dynamic function typeArgs():Ref<TypeList> return __self__.value.typeArgs();
    /**
        // SetTypeParams sets the type parameters of the named type t.
        // t must not have type arguments.
    **/
    @:keep
    public dynamic function setTypeParams(_tparams:Slice<Ref<TypeParam>>):Void __self__.value.setTypeParams(_tparams);
    /**
        // TypeParams returns the type parameters of the named type t, or nil.
        // The result is non-nil for an (originally) generic type even if it is instantiated.
    **/
    @:keep
    public dynamic function typeParams():Ref<TypeParamList> return __self__.value.typeParams();
    /**
        // Origin returns the generic type from which the named type t is
        // instantiated. If t is not an instantiated type, the result is t.
    **/
    @:keep
    public dynamic function origin():Ref<Named> return __self__.value.origin();
    /**
        // Obj returns the type name for the declaration defining the named type t. For
        // instantiated types, this is same as the type name of the origin type.
    **/
    @:keep
    public dynamic function obj():Ref<TypeName> return __self__.value.obj();
    @:keep
    public dynamic function _cleanup():Void __self__.value._cleanup();
    /**
        // setState atomically stores the given state for n.
        // Must only be called while holding n.mu.
    **/
    @:keep
    public dynamic function _setState(_state:T_namedState):Void __self__.value._setState(_state);
    /**
        // state atomically accesses the current state of the receiver.
    **/
    @:keep
    public dynamic function _state():T_namedState return __self__.value._state();
    /**
        // resolve resolves the type parameters, methods, and underlying type of n.
        // This information may be loaded from a provided loader function, or computed
        // from an origin type (in the case of instances).
        //
        // After resolution, the type parameters, methods, and underlying type of n are
        // accessible; but if n is an instantiated type, its methods may still be
        // unexpanded.
    **/
    @:keep
    public dynamic function _resolve():Ref<Named> return __self__.value._resolve();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Named>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Named_asInterface) class Named_static_extension {
    /**
        // expandUnderlying substitutes type arguments in the underlying type n.orig,
        // returning the result. Returns Typ[Invalid] if there was an error.
    **/
    @:keep
    static public function _expandUnderlying( _n:Ref<Named>):Type {
        var __deferstack__:Array<Void -> Void> = [];
        var _check = _n._check;
        try {
            if (((_check != null) && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) && false) {
                _check._trace(_n._obj._object._pos, ("-- Named.expandUnderlying %s" : GoString), Go.toInterface(Go.asInterface(_n)));
                _check._indent++;
                __deferstack__.unshift(() -> {
                    var a = function():Void {
                        _check._indent--;
                        _check._trace(_n._obj._object._pos, ("=> %s (tparams = %s, under = %s)" : GoString), Go.toInterface(Go.asInterface(_n)), Go.toInterface(_n._tparams._list()), Go.toInterface(_n._underlying));
                    };
                    a();
                });
            };
            _assert(_n._inst._orig._underlying != null);
            if (_n._inst._ctxt == null || (_n._inst._ctxt : Dynamic).__nil__) {
                _n._inst._ctxt = newContext();
            };
            var _orig = _n._inst._orig;
            var _targs = _n._inst._targs;
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_orig._underlying) : Ref<Named>)) : Ref<Named>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
                }, __80 = __tmp__.value, _unexpanded = __tmp__.ok;
                if (_unexpanded) {
                    _assert(_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__));
                };
            };
            if (_orig._tparams.len() != (_targs.len())) {
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                };
            };
            var _h:GoString = _n._inst._ctxt._instanceHash(Go.asInterface(_orig), _targs._list());
            var _n2:stdgo.go.types.Types.Type = _n._inst._ctxt._update(_h, Go.asInterface(_orig), _n.typeArgs()._list(), Go.asInterface(_n));
            _assert(Go.toInterface(Go.asInterface(_n)) == (Go.toInterface(_n2)));
            var _smap:stdgo.go.types.Types.T_substMap = _makeSubstMap(_orig._tparams._list(), _targs._list());
            var _ctxt:Ref<Context> = (null : Ref<stdgo.go.types.Types.Context>);
            if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
                _ctxt = _check._context();
            };
            var _underlying:stdgo.go.types.Types.Type = _n._check._subst(_n._obj._object._pos, _orig._underlying, _smap, _n, _ctxt);
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_underlying) : Ref<Interface>)) : Ref<Interface>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.Interface>), ok : false };
                }, _iface = __tmp__.value, __137 = __tmp__.ok;
                if (_iface != null && ((_iface : Dynamic).__nil__ == null || !(_iface : Dynamic).__nil__)) {
                    {
                        var __tmp__ = _replaceRecvType(_iface._methods, Go.asInterface(_orig), Go.asInterface(_n)), _methods:Slice<Ref<stdgo.go.types.Types.Func>> = __tmp__._0, _copied:Bool = __tmp__._1;
                        if (_copied) {
                            if (Go.toInterface(Go.asInterface(_iface)) == (Go.toInterface(_orig._underlying))) {
                                var _old = _iface;
                                _iface = _check._newInterface();
                                _iface._embeddeds = _old._embeddeds;
                                _iface._complete = _old._complete;
                                _iface._implicit = _old._implicit;
                                _underlying = Go.asInterface(_iface);
                            };
                            _iface._methods = _methods;
                        };
                    };
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _underlying;
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return (null : stdgo.go.types.Types.Type);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return (null : stdgo.go.types.Types.Type);
        };
    }
    @:keep
    static public function _lookupMethod( _n:Ref<Named>, _pkg:Ref<Package>, _name:GoString, _foldCase:Bool):{ var _0 : GoInt; var _1 : Ref<Func>; } {
        _n._resolve();
        var __tmp__ = stdgo.go.types.Types._lookupMethod(_n.origin()._methods, _pkg, _name, _foldCase), _i:GoInt = __tmp__._0, __8:Ref<stdgo.go.types.Types.Func> = __tmp__._1;
        if (_i < (0 : GoInt)) {
            return { _0 : (-1 : GoInt), _1 : null };
        };
        return { _0 : _i, _1 : _n.method(_i) };
    }
    @:keep
    static public function _setUnderlying( _n:Ref<Named>, _typ:Type):Void {
        if (_n != null && ((_n : Dynamic).__nil__ == null || !(_n : Dynamic).__nil__)) {
            _n._underlying = _typ;
        };
    }
    /**
        // under returns the expanded underlying type of n0; possibly by following
        // forward chains of named types. If an underlying type is found, resolve
        // the chain by setting the underlying type for each defined type in the
        // chain before returning it. If no underlying type is found or a cycle
        // is detected, the result is Typ[Invalid]. If a cycle is detected and
        // n0.check != nil, the cycle is reported.
        //
        // This is necessary because the underlying type of named may be itself a
        // named type that is incomplete:
        //
        //	type (
        //		A B
        //		B *C
        //		C A
        //	)
        //
        // The type of C is the (named) type of A which is incomplete,
        // and which has as its underlying type the named type B.
    **/
    @:keep
    static public function _under( _n0:Ref<Named>):Type {
        stdgo.internal.Macro.controlFlow({
            var _u:stdgo.go.types.Types.Type = _n0.underlying();
            var _n1:Ref<Named> = (null : Ref<stdgo.go.types.Types.Named>);
            {
                final __type__ = _u;
                if (__type__ == null) {
                    var _u1:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
                    throw Go.toInterface(("nil underlying" : GoString));
                } else if (Go.typeEquals((__type__ : Ref<Named>))) {
                    var _u1:Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                    _n1 = _u1;
                } else {
                    var _u1:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                    return _u;
                };
            };
            if (_n0._check == null || (_n0._check : Dynamic).__nil__) {
                throw Go.toInterface(("Named.check == nil but type is incomplete" : GoString));
            };
            var _check = _n0._check;
            var _n = _n0;
            var _seen = ({
                final x = new GoRefMap<Ref<stdgo.go.types.Types.Named>, GoInt>();
                @:mergeBlock {};
                cast x;
            } : GoMap<Ref<stdgo.go.types.Types.Named>, GoInt>);
            var _path:Slice<Object> = (null : Slice<stdgo.go.types.Types.Object>);
            @:label("loop") while (true) {
                _seen[_n] = (_seen.length);
                _path = (_path.__append__(Go.asInterface(_n._obj)));
                _n = _n1;
                {
                    var __tmp__ = (_seen != null && _seen.exists(_n) ? { value : _seen[_n], ok : true } : { value : (0 : GoInt), ok : false }), _i:GoInt = __tmp__.value, _ok:Bool = __tmp__.ok;
                    if (_ok) {
                        _check._cycleError((_path.__slice__(_i) : Slice<stdgo.go.types.Types.Object>));
                        _u = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                        break;
                    };
                };
                _u = _n.underlying();
                {
                    final __type__ = _u;
                    {
                        var __bool__ = true;
                        while (__bool__) {
                            __bool__ = false;
                            if (__type__ == null) {
                                var _u1:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
                                _u = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                                @:jump("loop") break;
                            } else if (Go.typeEquals((__type__ : Ref<Named>))) {
                                var _u1:Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                                _n1 = _u1;
                            } else {
                                var _u1:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                                @:jump("loop") break;
                            };
                            break;
                        };
                    };
                };
            };
            for (_n => _ in _seen) {
                if (_n._obj._object._pkg != (_check._pkg)) {
                    throw Go.toInterface(("imported type with unresolved underlying type" : GoString));
                };
                _n._underlying = _u;
            };
            return _u;
        });
        throw "controlFlow did not return";
    }
    @:keep
    static public function string( _t:Ref<Named>):GoString {
        return typeString(Go.asInterface(_t), null);
    }
    @:keep
    static public function underlying( _t:Ref<Named>):Type {
        return _t._resolve()._underlying;
    }
    /**
        // AddMethod adds method m unless it is already in the method list.
        // t must not have type arguments.
    **/
    @:keep
    static public function addMethod( _t:Ref<Named>, _m:Ref<Func>):Void {
        _assert(_t._inst == null || (_t._inst : Dynamic).__nil__);
        _t._resolve();
        {
            var __tmp__ = stdgo.go.types.Types._lookupMethod(_t._methods, _m._object._pkg, _m._object._name, false), _i:GoInt = __tmp__._0, __16:Ref<stdgo.go.types.Types.Func> = __tmp__._1;
            if (_i < (0 : GoInt)) {
                _t._methods = (_t._methods.__append__(_m));
            };
        };
    }
    /**
        // SetUnderlying sets the underlying type and marks t as complete.
        // t must not have type arguments.
    **/
    @:keep
    static public function setUnderlying( _t:Ref<Named>, _underlying:Type):Void {
        _assert(_t._inst == null || (_t._inst : Dynamic).__nil__);
        if (_underlying == null) {
            throw Go.toInterface(("underlying type must not be nil" : GoString));
        };
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_underlying) : Ref<Named>)) : Ref<Named>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
            }, __8 = __tmp__.value, _ok = __tmp__.ok;
            if (_ok) {
                throw Go.toInterface(("underlying type must not be *Named" : GoString));
            };
        };
        _t._resolve()._underlying = _underlying;
        if (_t._fromRHS == null) {
            _t._fromRHS = _underlying;
        };
    }
    /**
        // expandMethod substitutes type arguments in the i'th method for an
        // instantiated receiver.
    **/
    @:keep
    static public function _expandMethod( _t:Ref<Named>, _i:GoInt):Ref<Func> {
        var _origm = _t._inst._orig.method(_i);
        _assert(_origm != null && ((_origm : Dynamic).__nil__ == null || !(_origm : Dynamic).__nil__));
        var _check = _t._check;
        if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
            _check._objDecl(Go.asInterface(_origm), null);
        };
        var _origSig = (Go.typeAssert((Go.toInterface(_origm._object._typ) : Ref<Signature>)) : Ref<Signature>);
        var __tmp__ = _deref(_origSig.recv().type()), _rbase:stdgo.go.types.Types.Type = __tmp__._0, __16:Bool = __tmp__._1;
        if (Go.toInterface(_rbase) == (Go.toInterface(Go.asInterface(_t)))) {
            return _origm;
        };
        var _sig = _origSig;
        if (_origSig.recvTypeParams().len() == (_t._inst._targs.len())) {
            var _smap:stdgo.go.types.Types.T_substMap = _makeSubstMap(_origSig.recvTypeParams()._list(), _t._inst._targs._list());
            var _ctxt:Ref<Context> = (null : Ref<stdgo.go.types.Types.Context>);
            if (_check != null && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) {
                _ctxt = _check._context();
            };
            _sig = (Go.typeAssert((Go.toInterface(_check._subst(_origm._object._pos, Go.asInterface(_origSig), _smap, _t, _ctxt)) : Ref<Signature>)) : Ref<Signature>);
        };
        if (_sig == (_origSig)) {
            var _copy:stdgo.go.types.Types.Signature = (_origSig : stdgo.go.types.Types.Signature)?.__copy__();
            _sig = (Go.setRef(_copy) : Ref<stdgo.go.types.Types.Signature>);
        };
        var _rtyp:Type = (null : stdgo.go.types.Types.Type);
        if (_origm._hasPtrRecv()) {
            _rtyp = Go.asInterface(newPointer(Go.asInterface(_t)));
        } else {
            _rtyp = Go.asInterface(_t);
        };
        _sig._recv = _substVar(_origSig._recv, _rtyp);
        return _substFunc(_origm, Go.asInterface(_sig));
    }
    /**
        // Method returns the i'th method of named type t for 0 <= i < t.NumMethods().
        //
        // For an ordinary or instantiated type t, the receiver base type of this
        // method is the named type t. For an uninstantiated generic type t, each
        // method receiver is instantiated with its receiver type parameters.
    **/
    @:keep
    static public function method( _t:Ref<Named>, _i:GoInt):Ref<Func> {
        var __deferstack__:Array<Void -> Void> = [];
        _t._resolve();
        try {
            if (_t._state() >= (2u32 : stdgo.go.types.Types.T_namedState)) {
                return _t._methods[(_i : GoInt)];
            };
            _assert(_t._inst != null && ((_t._inst : Dynamic).__nil__ == null || !(_t._inst : Dynamic).__nil__));
            var _orig = _t._inst._orig;
            _t._mu.lock();
            __deferstack__.unshift(() -> _t._mu.unlock());
            if ((_t._methods.length) != ((_orig._methods.length))) {
                _assert((_t._methods.length) == ((0 : GoInt)));
                _t._methods = new Slice<Ref<stdgo.go.types.Types.Func>>((_orig._methods.length : GoInt).toBasic(), 0);
            };
            if (_t._methods[(_i : GoInt)] == null || (_t._methods[(_i : GoInt)] : Dynamic).__nil__) {
                _assert(_t._inst._ctxt != null && ((_t._inst._ctxt : Dynamic).__nil__ == null || !(_t._inst._ctxt : Dynamic).__nil__));
                _t._methods[(_i : GoInt)] = _t._expandMethod(_i);
                _t._inst._expandedMethods++;
                if (_t._inst._expandedMethods == ((_orig._methods.length))) {
                    _t._setState((2u32 : stdgo.go.types.Types.T_namedState));
                    _t._inst._ctxt = null;
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _t._methods[(_i : GoInt)];
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return (null : Ref<stdgo.go.types.Types.Func>);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return (null : Ref<stdgo.go.types.Types.Func>);
        };
    }
    /**
        // NumMethods returns the number of explicit methods defined for t.
    **/
    @:keep
    static public function numMethods( _t:Ref<Named>):GoInt {
        return (_t.origin()._resolve()._methods.length);
    }
    /**
        // TypeArgs returns the type arguments used to instantiate the named type t.
    **/
    @:keep
    static public function typeArgs( _t:Ref<Named>):Ref<TypeList> {
        if (_t._inst == null || (_t._inst : Dynamic).__nil__) {
            return null;
        };
        return _t._inst._targs;
    }
    /**
        // SetTypeParams sets the type parameters of the named type t.
        // t must not have type arguments.
    **/
    @:keep
    static public function setTypeParams( _t:Ref<Named>, _tparams:Slice<Ref<TypeParam>>):Void {
        _assert(_t._inst == null || (_t._inst : Dynamic).__nil__);
        _t._resolve()._tparams = _bindTParams(_tparams);
    }
    /**
        // TypeParams returns the type parameters of the named type t, or nil.
        // The result is non-nil for an (originally) generic type even if it is instantiated.
    **/
    @:keep
    static public function typeParams( _t:Ref<Named>):Ref<TypeParamList> {
        return _t._resolve()._tparams;
    }
    /**
        // Origin returns the generic type from which the named type t is
        // instantiated. If t is not an instantiated type, the result is t.
    **/
    @:keep
    static public function origin( _t:Ref<Named>):Ref<Named> {
        if (_t._inst == null || (_t._inst : Dynamic).__nil__) {
            return _t;
        };
        return _t._inst._orig;
    }
    /**
        // Obj returns the type name for the declaration defining the named type t. For
        // instantiated types, this is same as the type name of the origin type.
    **/
    @:keep
    static public function obj( _t:Ref<Named>):Ref<TypeName> {
        if (_t._inst == null || (_t._inst : Dynamic).__nil__) {
            return _t._obj;
        };
        return _t._inst._orig._obj;
    }
    @:keep
    static public function _cleanup( _t:Ref<Named>):Void {
        _assert(((_t._inst == null) || (_t._inst : Dynamic).__nil__) || ((_t._inst._orig._inst == null) || (_t._inst._orig._inst : Dynamic).__nil__));
        {
            final __type__ = _t._underlying;
            if (__type__ == null) {
                if (_t.typeArgs().len() == ((0 : GoInt))) {
                    throw Go.toInterface(("nil underlying" : GoString));
                };
            } else if (Go.typeEquals((__type__ : Ref<Named>))) {
                _t._under();
            };
        };
        _t._check = null;
    }
    /**
        // setState atomically stores the given state for n.
        // Must only be called while holding n.mu.
    **/
    @:keep
    static public function _setState( _n:Ref<Named>, _state:T_namedState):Void {
        stdgo.sync.atomic.Atomic.storeUint32(Go.pointer(_n._state_), (_state : GoUInt32));
    }
    /**
        // state atomically accesses the current state of the receiver.
    **/
    @:keep
    static public function _state( _n:Ref<Named>):T_namedState {
        return (stdgo.sync.atomic.Atomic.loadUint32(Go.pointer(_n._state_)) : T_namedState);
    }
    /**
        // resolve resolves the type parameters, methods, and underlying type of n.
        // This information may be loaded from a provided loader function, or computed
        // from an origin type (in the case of instances).
        //
        // After resolution, the type parameters, methods, and underlying type of n are
        // accessible; but if n is an instantiated type, its methods may still be
        // unexpanded.
    **/
    @:keep
    static public function _resolve( _n:Ref<Named>):Ref<Named> {
        var __deferstack__:Array<Void -> Void> = [];
        if (_n._state() >= (1u32 : stdgo.go.types.Types.T_namedState)) {
            return _n;
        };
        try {
            _n._mu.lock();
            __deferstack__.unshift(() -> _n._mu.unlock());
            if (_n._state() >= (1u32 : stdgo.go.types.Types.T_namedState)) {
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return _n;
                };
            };
            if (_n._inst != null && ((_n._inst : Dynamic).__nil__ == null || !(_n._inst : Dynamic).__nil__)) {
                _assert(_n._underlying == null);
                _assert(_n._loader == null);
                var _orig = _n._inst._orig;
                _orig._resolve();
                var _underlying:stdgo.go.types.Types.Type = _n._expandUnderlying();
                _n._tparams = _orig._tparams;
                _n._underlying = _underlying;
                _n._fromRHS = _orig._fromRHS;
                if ((_orig._methods.length) == ((0 : GoInt))) {
                    _n._setState((2u32 : stdgo.go.types.Types.T_namedState));
                    _n._inst._ctxt = null;
                } else {
                    _n._setState((1u32 : stdgo.go.types.Types.T_namedState));
                };
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return _n;
                };
            };
            if (_n._loader != null) {
                _assert(_n._underlying == null);
                _assert(_n.typeArgs().len() == ((0 : GoInt)));
                var __tmp__ = _n._loader(_n), _tparams:Slice<Ref<stdgo.go.types.Types.TypeParam>> = __tmp__._0, _underlying:stdgo.go.types.Types.Type = __tmp__._1, _methods:Slice<Ref<stdgo.go.types.Types.Func>> = __tmp__._2;
                _n._tparams = _bindTParams(_tparams);
                _n._underlying = _underlying;
                _n._fromRHS = _underlying;
                _n._methods = _methods;
                _n._loader = null;
            };
            _n._setState((2u32 : stdgo.go.types.Types.T_namedState));
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _n;
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return (null : Ref<stdgo.go.types.Types.Named>);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return (null : Ref<stdgo.go.types.Types.Named>);
        };
    }
}
class T_object_asInterface {
    @:keep
    public dynamic function _sameId(_pkg:Ref<Package>, _name:GoString):Bool return __self__.value._sameId(_pkg, _name);
    @:keep
    public dynamic function _setScopePos(_pos:stdgo.go.token.Token.Pos):Void __self__.value._setScopePos(_pos);
    @:keep
    public dynamic function _setColor(_color:T_color):Void __self__.value._setColor(_color);
    @:keep
    public dynamic function _setOrder(_order:GoUInt32):Void __self__.value._setOrder(_order);
    @:keep
    public dynamic function _setType(_typ:Type):Void __self__.value._setType(_typ);
    @:keep
    public dynamic function _setParent(_parent:Ref<Scope>):Void __self__.value._setParent(_parent);
    @:keep
    public dynamic function _scopePos():stdgo.go.token.Token.Pos return __self__.value._scopePos();
    @:keep
    public dynamic function _color():T_color return __self__.value._color();
    @:keep
    public dynamic function _order():GoUInt32 return __self__.value._order();
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    /**
        // Id is a wrapper for Id(obj.Pkg(), obj.Name()).
    **/
    @:keep
    public dynamic function id():GoString return __self__.value.id();
    /**
        // Exported reports whether the object is exported (starts with a capital letter).
        // It doesn't take into account whether the object is in a local (function) scope
        // or not.
    **/
    @:keep
    public dynamic function exported():Bool return __self__.value.exported();
    /**
        // Type returns the object's type.
    **/
    @:keep
    public dynamic function type():Type return __self__.value.type();
    /**
        // Name returns the object's (package-local, unqualified) name.
    **/
    @:keep
    public dynamic function name():GoString return __self__.value.name();
    /**
        // Pkg returns the package to which the object belongs.
        // The result is nil for labels and objects in the Universe scope.
    **/
    @:keep
    public dynamic function pkg():Ref<Package> return __self__.value.pkg();
    /**
        // Pos returns the declaration position of the object's identifier.
    **/
    @:keep
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    /**
        // Parent returns the scope in which the object is declared.
        // The result is nil for methods and struct fields.
    **/
    @:keep
    public dynamic function parent():Ref<Scope> return __self__.value.parent();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_object>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_object_asInterface) class T_object_static_extension {
    @:keep
    static public function _sameId( _obj:Ref<T_object>, _pkg:Ref<Package>, _name:GoString):Bool {
        if (_name != (_obj._name)) {
            return false;
        };
        if (_obj.exported()) {
            return true;
        };
        if (((_pkg == null) || (_pkg : Dynamic).__nil__) || ((_obj._pkg == null) || (_obj._pkg : Dynamic).__nil__)) {
            return _pkg == (_obj._pkg);
        };
        return _pkg._path == (_obj._pkg._path);
    }
    @:keep
    static public function _setScopePos( _obj:Ref<T_object>, _pos:stdgo.go.token.Token.Pos):Void {
        _obj._scopePos_ = _pos;
    }
    @:keep
    static public function _setColor( _obj:Ref<T_object>, _color:T_color):Void {
        _assert(_color != ((0u32 : stdgo.go.types.Types.T_color)));
        _obj._color_ = _color;
    }
    @:keep
    static public function _setOrder( _obj:Ref<T_object>, _order:GoUInt32):Void {
        _assert(_order > (0u32 : GoUInt32));
        _obj._order_ = _order;
    }
    @:keep
    static public function _setType( _obj:Ref<T_object>, _typ:Type):Void {
        _obj._typ = _typ;
    }
    @:keep
    static public function _setParent( _obj:Ref<T_object>, _parent:Ref<Scope>):Void {
        _obj._parent = _parent;
    }
    @:keep
    static public function _scopePos( _obj:Ref<T_object>):stdgo.go.token.Token.Pos {
        return _obj._scopePos_;
    }
    @:keep
    static public function _color( _obj:Ref<T_object>):T_color {
        return _obj._color_;
    }
    @:keep
    static public function _order( _obj:Ref<T_object>):GoUInt32 {
        return _obj._order_;
    }
    @:keep
    static public function string( _obj:Ref<T_object>):GoString {
        throw Go.toInterface(("abstract" : GoString));
    }
    /**
        // Id is a wrapper for Id(obj.Pkg(), obj.Name()).
    **/
    @:keep
    static public function id( _obj:Ref<T_object>):GoString {
        return stdgo.go.types.Types.id(_obj._pkg, _obj._name);
    }
    /**
        // Exported reports whether the object is exported (starts with a capital letter).
        // It doesn't take into account whether the object is in a local (function) scope
        // or not.
    **/
    @:keep
    static public function exported( _obj:Ref<T_object>):Bool {
        return stdgo.go.token.Token.isExported(_obj._name);
    }
    /**
        // Type returns the object's type.
    **/
    @:keep
    static public function type( _obj:Ref<T_object>):Type {
        return _obj._typ;
    }
    /**
        // Name returns the object's (package-local, unqualified) name.
    **/
    @:keep
    static public function name( _obj:Ref<T_object>):GoString {
        return _obj._name;
    }
    /**
        // Pkg returns the package to which the object belongs.
        // The result is nil for labels and objects in the Universe scope.
    **/
    @:keep
    static public function pkg( _obj:Ref<T_object>):Ref<Package> {
        return _obj._pkg;
    }
    /**
        // Pos returns the declaration position of the object's identifier.
    **/
    @:keep
    static public function pos( _obj:Ref<T_object>):stdgo.go.token.Token.Pos {
        return _obj._pos;
    }
    /**
        // Parent returns the scope in which the object is declared.
        // The result is nil for methods and struct fields.
    **/
    @:keep
    static public function parent( _obj:Ref<T_object>):Ref<Scope> {
        return _obj._parent;
    }
}
class PkgName_asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    /**
        // Imported returns the package that was imported.
        // It is distinct from Pkg(), which is the package containing the import statement.
    **/
    @:keep
    public dynamic function imported():Ref<Package> return __self__.value.imported();
    @:embedded
    public dynamic function _setType(__0:stdgo.go.types.Types.Type):Void __self__.value._setType(__0);
    @:embedded
    public dynamic function _setScopePos(_p:stdgo.go.token.Token.Pos):Void __self__.value._setScopePos(_p);
    @:embedded
    public dynamic function _setParent(__0:Ref<stdgo.go.types.Types.Scope>):Void __self__.value._setParent(__0);
    @:embedded
    public dynamic function _setOrder(__0:GoUInt32):Void __self__.value._setOrder(__0);
    @:embedded
    public dynamic function _setColor(__0:stdgo.go.types.Types.T_color):Void __self__.value._setColor(__0);
    @:embedded
    public dynamic function _scopePos():stdgo.go.token.Token.Pos return __self__.value._scopePos();
    @:embedded
    public dynamic function _sameId(_pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return __self__.value._sameId(_pkg_, _name_);
    @:embedded
    public dynamic function _order():GoUInt32 return __self__.value._order();
    @:embedded
    public dynamic function _color():stdgo.go.types.Types.T_color return __self__.value._color();
    @:embedded
    public dynamic function type():stdgo.go.types.Types.Type return __self__.value.type();
    @:embedded
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    @:embedded
    public dynamic function pkg():Ref<stdgo.go.types.Types.Package> return __self__.value.pkg();
    @:embedded
    public dynamic function parent():Ref<stdgo.go.types.Types.Scope> return __self__.value.parent();
    @:embedded
    public dynamic function name():GoString return __self__.value.name();
    @:embedded
    public dynamic function id():GoString return __self__.value.id();
    @:embedded
    public dynamic function exported():Bool return __self__.value.exported();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<PkgName>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.PkgName_asInterface) class PkgName_static_extension {
    @:keep
    static public function string( _obj:Ref<PkgName>):GoString {
        return objectString(Go.asInterface(_obj), null);
    }
    /**
        // Imported returns the package that was imported.
        // It is distinct from Pkg(), which is the package containing the import statement.
    **/
    @:keep
    static public function imported( _obj:Ref<PkgName>):Ref<Package> {
        return _obj._imported;
    }
    @:embedded
    public static function _setType( __self__:PkgName, __0:stdgo.go.types.Types.Type) __self__._setType(__0);
    @:embedded
    public static function _setScopePos( __self__:PkgName, _p:stdgo.go.token.Token.Pos) __self__._setScopePos(_p);
    @:embedded
    public static function _setParent( __self__:PkgName, __0:Ref<stdgo.go.types.Types.Scope>) __self__._setParent(__0);
    @:embedded
    public static function _setOrder( __self__:PkgName, __0:GoUInt32) __self__._setOrder(__0);
    @:embedded
    public static function _setColor( __self__:PkgName, __0:stdgo.go.types.Types.T_color) __self__._setColor(__0);
    @:embedded
    public static function _scopePos( __self__:PkgName):stdgo.go.token.Token.Pos return __self__._scopePos();
    @:embedded
    public static function _sameId( __self__:PkgName, _pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return __self__._sameId(_pkg_, _name_);
    @:embedded
    public static function _order( __self__:PkgName):GoUInt32 return __self__._order();
    @:embedded
    public static function _color( __self__:PkgName):stdgo.go.types.Types.T_color return __self__._color();
    @:embedded
    public static function type( __self__:PkgName):stdgo.go.types.Types.Type return __self__.type();
    @:embedded
    public static function pos( __self__:PkgName):stdgo.go.token.Token.Pos return __self__.pos();
    @:embedded
    public static function pkg( __self__:PkgName):Ref<stdgo.go.types.Types.Package> return __self__.pkg();
    @:embedded
    public static function parent( __self__:PkgName):Ref<stdgo.go.types.Types.Scope> return __self__.parent();
    @:embedded
    public static function name( __self__:PkgName):GoString return __self__.name();
    @:embedded
    public static function id( __self__:PkgName):GoString return __self__.id();
    @:embedded
    public static function exported( __self__:PkgName):Bool return __self__.exported();
}
class Const_asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:keep
    public dynamic function _isDependency():Void __self__.value._isDependency();
    /**
        // Val returns the constant's value.
    **/
    @:keep
    public dynamic function val():stdgo.go.constant.Constant.Value return __self__.value.val();
    @:embedded
    public dynamic function _setType(__0:stdgo.go.types.Types.Type):Void __self__.value._setType(__0);
    @:embedded
    public dynamic function _setScopePos(_p:stdgo.go.token.Token.Pos):Void __self__.value._setScopePos(_p);
    @:embedded
    public dynamic function _setParent(__0:Ref<stdgo.go.types.Types.Scope>):Void __self__.value._setParent(__0);
    @:embedded
    public dynamic function _setOrder(__0:GoUInt32):Void __self__.value._setOrder(__0);
    @:embedded
    public dynamic function _setColor(__0:stdgo.go.types.Types.T_color):Void __self__.value._setColor(__0);
    @:embedded
    public dynamic function _scopePos():stdgo.go.token.Token.Pos return __self__.value._scopePos();
    @:embedded
    public dynamic function _sameId(_pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return __self__.value._sameId(_pkg_, _name_);
    @:embedded
    public dynamic function _order():GoUInt32 return __self__.value._order();
    @:embedded
    public dynamic function _color():stdgo.go.types.Types.T_color return __self__.value._color();
    @:embedded
    public dynamic function type():stdgo.go.types.Types.Type return __self__.value.type();
    @:embedded
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    @:embedded
    public dynamic function pkg():Ref<stdgo.go.types.Types.Package> return __self__.value.pkg();
    @:embedded
    public dynamic function parent():Ref<stdgo.go.types.Types.Scope> return __self__.value.parent();
    @:embedded
    public dynamic function name():GoString return __self__.value.name();
    @:embedded
    public dynamic function id():GoString return __self__.value.id();
    @:embedded
    public dynamic function exported():Bool return __self__.value.exported();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Const>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Const_asInterface) class Const_static_extension {
    @:keep
    static public function string( _obj:Ref<Const>):GoString {
        return objectString(Go.asInterface(_obj), null);
    }
    @:keep
    static public function _isDependency( _:Ref<Const>):Void {}
    /**
        // Val returns the constant's value.
    **/
    @:keep
    static public function val( _obj:Ref<Const>):stdgo.go.constant.Constant.Value {
        return _obj._val;
    }
    @:embedded
    public static function _setType( __self__:Const, __0:stdgo.go.types.Types.Type) __self__._setType(__0);
    @:embedded
    public static function _setScopePos( __self__:Const, _p:stdgo.go.token.Token.Pos) __self__._setScopePos(_p);
    @:embedded
    public static function _setParent( __self__:Const, __0:Ref<stdgo.go.types.Types.Scope>) __self__._setParent(__0);
    @:embedded
    public static function _setOrder( __self__:Const, __0:GoUInt32) __self__._setOrder(__0);
    @:embedded
    public static function _setColor( __self__:Const, __0:stdgo.go.types.Types.T_color) __self__._setColor(__0);
    @:embedded
    public static function _scopePos( __self__:Const):stdgo.go.token.Token.Pos return __self__._scopePos();
    @:embedded
    public static function _sameId( __self__:Const, _pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return __self__._sameId(_pkg_, _name_);
    @:embedded
    public static function _order( __self__:Const):GoUInt32 return __self__._order();
    @:embedded
    public static function _color( __self__:Const):stdgo.go.types.Types.T_color return __self__._color();
    @:embedded
    public static function type( __self__:Const):stdgo.go.types.Types.Type return __self__.type();
    @:embedded
    public static function pos( __self__:Const):stdgo.go.token.Token.Pos return __self__.pos();
    @:embedded
    public static function pkg( __self__:Const):Ref<stdgo.go.types.Types.Package> return __self__.pkg();
    @:embedded
    public static function parent( __self__:Const):Ref<stdgo.go.types.Types.Scope> return __self__.parent();
    @:embedded
    public static function name( __self__:Const):GoString return __self__.name();
    @:embedded
    public static function id( __self__:Const):GoString return __self__.id();
    @:embedded
    public static function exported( __self__:Const):Bool return __self__.exported();
}
class TypeName_asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    /**
        // IsAlias reports whether obj is an alias name for a type.
    **/
    @:keep
    public dynamic function isAlias():Bool return __self__.value.isAlias();
    @:embedded
    public dynamic function _setType(__0:stdgo.go.types.Types.Type):Void __self__.value._setType(__0);
    @:embedded
    public dynamic function _setScopePos(_p:stdgo.go.token.Token.Pos):Void __self__.value._setScopePos(_p);
    @:embedded
    public dynamic function _setParent(__0:Ref<stdgo.go.types.Types.Scope>):Void __self__.value._setParent(__0);
    @:embedded
    public dynamic function _setOrder(__0:GoUInt32):Void __self__.value._setOrder(__0);
    @:embedded
    public dynamic function _setColor(__0:stdgo.go.types.Types.T_color):Void __self__.value._setColor(__0);
    @:embedded
    public dynamic function _scopePos():stdgo.go.token.Token.Pos return __self__.value._scopePos();
    @:embedded
    public dynamic function _sameId(_pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return __self__.value._sameId(_pkg_, _name_);
    @:embedded
    public dynamic function _order():GoUInt32 return __self__.value._order();
    @:embedded
    public dynamic function _color():stdgo.go.types.Types.T_color return __self__.value._color();
    @:embedded
    public dynamic function type():stdgo.go.types.Types.Type return __self__.value.type();
    @:embedded
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    @:embedded
    public dynamic function pkg():Ref<stdgo.go.types.Types.Package> return __self__.value.pkg();
    @:embedded
    public dynamic function parent():Ref<stdgo.go.types.Types.Scope> return __self__.value.parent();
    @:embedded
    public dynamic function name():GoString return __self__.value.name();
    @:embedded
    public dynamic function id():GoString return __self__.value.id();
    @:embedded
    public dynamic function exported():Bool return __self__.value.exported();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<TypeName>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.TypeName_asInterface) class TypeName_static_extension {
    @:keep
    static public function string( _obj:Ref<TypeName>):GoString {
        return objectString(Go.asInterface(_obj), null);
    }
    /**
        // IsAlias reports whether obj is an alias name for a type.
    **/
    @:keep
    static public function isAlias( _obj:Ref<TypeName>):Bool {
        {
            final __type__ = _obj._object._typ;
            if (__type__ == null) {
                var _t:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
                return false;
            } else if (Go.typeEquals((__type__ : Ref<Basic>))) {
                var _t:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                if (_obj._object._pkg == (unsafe)) {
                    return false;
                };
                return ((((_obj._object._pkg != null) && ((_obj._object._pkg : Dynamic).__nil__ == null || !(_obj._object._pkg : Dynamic).__nil__)) || (_t._name != _obj._object._name)) || (Go.toInterface(Go.asInterface(_t)) == Go.toInterface(_universeByte))) || (Go.toInterface(Go.asInterface(_t)) == Go.toInterface(_universeRune));
            } else if (Go.typeEquals((__type__ : Ref<Named>))) {
                var _t:Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                return _obj != (_t._obj);
            } else if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
                var _t:Ref<stdgo.go.types.Types.TypeParam> = __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__().value;
                return _obj != (_t._obj);
            } else {
                var _t:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                return true;
            };
        };
    }
    @:embedded
    public static function _setType( __self__:TypeName, __0:stdgo.go.types.Types.Type) __self__._setType(__0);
    @:embedded
    public static function _setScopePos( __self__:TypeName, _p:stdgo.go.token.Token.Pos) __self__._setScopePos(_p);
    @:embedded
    public static function _setParent( __self__:TypeName, __0:Ref<stdgo.go.types.Types.Scope>) __self__._setParent(__0);
    @:embedded
    public static function _setOrder( __self__:TypeName, __0:GoUInt32) __self__._setOrder(__0);
    @:embedded
    public static function _setColor( __self__:TypeName, __0:stdgo.go.types.Types.T_color) __self__._setColor(__0);
    @:embedded
    public static function _scopePos( __self__:TypeName):stdgo.go.token.Token.Pos return __self__._scopePos();
    @:embedded
    public static function _sameId( __self__:TypeName, _pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return __self__._sameId(_pkg_, _name_);
    @:embedded
    public static function _order( __self__:TypeName):GoUInt32 return __self__._order();
    @:embedded
    public static function _color( __self__:TypeName):stdgo.go.types.Types.T_color return __self__._color();
    @:embedded
    public static function type( __self__:TypeName):stdgo.go.types.Types.Type return __self__.type();
    @:embedded
    public static function pos( __self__:TypeName):stdgo.go.token.Token.Pos return __self__.pos();
    @:embedded
    public static function pkg( __self__:TypeName):Ref<stdgo.go.types.Types.Package> return __self__.pkg();
    @:embedded
    public static function parent( __self__:TypeName):Ref<stdgo.go.types.Types.Scope> return __self__.parent();
    @:embedded
    public static function name( __self__:TypeName):GoString return __self__.name();
    @:embedded
    public static function id( __self__:TypeName):GoString return __self__.id();
    @:embedded
    public static function exported( __self__:TypeName):Bool return __self__.exported();
}
class Var_asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:keep
    public dynamic function _isDependency():Void __self__.value._isDependency();
    /**
        // Origin returns the canonical Var for its receiver, i.e. the Var object
        // recorded in Info.Defs.
        //
        // For synthetic Vars created during instantiation (such as struct fields or
        // function parameters that depend on type arguments), this will be the
        // corresponding Var on the generic (uninstantiated) type. For all other Vars
        // Origin returns the receiver.
    **/
    @:keep
    public dynamic function origin():Ref<Var> return __self__.value.origin();
    /**
        // IsField reports whether the variable is a struct field.
    **/
    @:keep
    public dynamic function isField():Bool return __self__.value.isField();
    /**
        // Embedded reports whether the variable is an embedded field.
    **/
    @:keep
    public dynamic function embedded():Bool return __self__.value.embedded();
    /**
        // Anonymous reports whether the variable is an embedded field.
        // Same as Embedded; only present for backward-compatibility.
    **/
    @:keep
    public dynamic function anonymous():Bool return __self__.value.anonymous();
    @:embedded
    public dynamic function _setType(__0:stdgo.go.types.Types.Type):Void __self__.value._setType(__0);
    @:embedded
    public dynamic function _setScopePos(_p:stdgo.go.token.Token.Pos):Void __self__.value._setScopePos(_p);
    @:embedded
    public dynamic function _setParent(__0:Ref<stdgo.go.types.Types.Scope>):Void __self__.value._setParent(__0);
    @:embedded
    public dynamic function _setOrder(__0:GoUInt32):Void __self__.value._setOrder(__0);
    @:embedded
    public dynamic function _setColor(__0:stdgo.go.types.Types.T_color):Void __self__.value._setColor(__0);
    @:embedded
    public dynamic function _scopePos():stdgo.go.token.Token.Pos return __self__.value._scopePos();
    @:embedded
    public dynamic function _sameId(_pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return __self__.value._sameId(_pkg_, _name_);
    @:embedded
    public dynamic function _order():GoUInt32 return __self__.value._order();
    @:embedded
    public dynamic function _color():stdgo.go.types.Types.T_color return __self__.value._color();
    @:embedded
    public dynamic function type():stdgo.go.types.Types.Type return __self__.value.type();
    @:embedded
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    @:embedded
    public dynamic function pkg():Ref<stdgo.go.types.Types.Package> return __self__.value.pkg();
    @:embedded
    public dynamic function parent():Ref<stdgo.go.types.Types.Scope> return __self__.value.parent();
    @:embedded
    public dynamic function name():GoString return __self__.value.name();
    @:embedded
    public dynamic function id():GoString return __self__.value.id();
    @:embedded
    public dynamic function exported():Bool return __self__.value.exported();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Var>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Var_asInterface) class Var_static_extension {
    @:keep
    static public function string( _obj:Ref<Var>):GoString {
        return objectString(Go.asInterface(_obj), null);
    }
    @:keep
    static public function _isDependency( _:Ref<Var>):Void {}
    /**
        // Origin returns the canonical Var for its receiver, i.e. the Var object
        // recorded in Info.Defs.
        //
        // For synthetic Vars created during instantiation (such as struct fields or
        // function parameters that depend on type arguments), this will be the
        // corresponding Var on the generic (uninstantiated) type. For all other Vars
        // Origin returns the receiver.
    **/
    @:keep
    static public function origin( _obj:Ref<Var>):Ref<Var> {
        if (_obj._origin != null && ((_obj._origin : Dynamic).__nil__ == null || !(_obj._origin : Dynamic).__nil__)) {
            return _obj._origin;
        };
        return _obj;
    }
    /**
        // IsField reports whether the variable is a struct field.
    **/
    @:keep
    static public function isField( _obj:Ref<Var>):Bool {
        return _obj._isField;
    }
    /**
        // Embedded reports whether the variable is an embedded field.
    **/
    @:keep
    static public function embedded( _obj:Ref<Var>):Bool {
        return _obj._embedded;
    }
    /**
        // Anonymous reports whether the variable is an embedded field.
        // Same as Embedded; only present for backward-compatibility.
    **/
    @:keep
    static public function anonymous( _obj:Ref<Var>):Bool {
        return _obj._embedded;
    }
    @:embedded
    public static function _setType( __self__:Var, __0:stdgo.go.types.Types.Type) __self__._setType(__0);
    @:embedded
    public static function _setScopePos( __self__:Var, _p:stdgo.go.token.Token.Pos) __self__._setScopePos(_p);
    @:embedded
    public static function _setParent( __self__:Var, __0:Ref<stdgo.go.types.Types.Scope>) __self__._setParent(__0);
    @:embedded
    public static function _setOrder( __self__:Var, __0:GoUInt32) __self__._setOrder(__0);
    @:embedded
    public static function _setColor( __self__:Var, __0:stdgo.go.types.Types.T_color) __self__._setColor(__0);
    @:embedded
    public static function _scopePos( __self__:Var):stdgo.go.token.Token.Pos return __self__._scopePos();
    @:embedded
    public static function _sameId( __self__:Var, _pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return __self__._sameId(_pkg_, _name_);
    @:embedded
    public static function _order( __self__:Var):GoUInt32 return __self__._order();
    @:embedded
    public static function _color( __self__:Var):stdgo.go.types.Types.T_color return __self__._color();
    @:embedded
    public static function type( __self__:Var):stdgo.go.types.Types.Type return __self__.type();
    @:embedded
    public static function pos( __self__:Var):stdgo.go.token.Token.Pos return __self__.pos();
    @:embedded
    public static function pkg( __self__:Var):Ref<stdgo.go.types.Types.Package> return __self__.pkg();
    @:embedded
    public static function parent( __self__:Var):Ref<stdgo.go.types.Types.Scope> return __self__.parent();
    @:embedded
    public static function name( __self__:Var):GoString return __self__.name();
    @:embedded
    public static function id( __self__:Var):GoString return __self__.id();
    @:embedded
    public static function exported( __self__:Var):Bool return __self__.exported();
}
class Func_asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:keep
    public dynamic function _isDependency():Void __self__.value._isDependency();
    /**
        // hasPtrRecv reports whether the receiver is of the form *T for the given method obj.
    **/
    @:keep
    public dynamic function _hasPtrRecv():Bool return __self__.value._hasPtrRecv();
    /**
        // Origin returns the canonical Func for its receiver, i.e. the Func object
        // recorded in Info.Defs.
        //
        // For synthetic functions created during instantiation (such as methods on an
        // instantiated Named type or interface methods that depend on type arguments),
        // this will be the corresponding Func on the generic (uninstantiated) type.
        // For all other Funcs Origin returns the receiver.
    **/
    @:keep
    public dynamic function origin():Ref<Func> return __self__.value.origin();
    /**
        // Scope returns the scope of the function's body block.
        // The result is nil for imported or instantiated functions and methods
        // (but there is also no mechanism to get to an instantiated function).
    **/
    @:keep
    public dynamic function scope():Ref<Scope> return __self__.value.scope();
    /**
        // FullName returns the package- or receiver-type-qualified name of
        // function or method obj.
    **/
    @:keep
    public dynamic function fullName():GoString return __self__.value.fullName();
    @:embedded
    public dynamic function _setType(__0:stdgo.go.types.Types.Type):Void __self__.value._setType(__0);
    @:embedded
    public dynamic function _setScopePos(_p:stdgo.go.token.Token.Pos):Void __self__.value._setScopePos(_p);
    @:embedded
    public dynamic function _setParent(__0:Ref<stdgo.go.types.Types.Scope>):Void __self__.value._setParent(__0);
    @:embedded
    public dynamic function _setOrder(__0:GoUInt32):Void __self__.value._setOrder(__0);
    @:embedded
    public dynamic function _setColor(__0:stdgo.go.types.Types.T_color):Void __self__.value._setColor(__0);
    @:embedded
    public dynamic function _scopePos():stdgo.go.token.Token.Pos return __self__.value._scopePos();
    @:embedded
    public dynamic function _sameId(_pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return __self__.value._sameId(_pkg_, _name_);
    @:embedded
    public dynamic function _order():GoUInt32 return __self__.value._order();
    @:embedded
    public dynamic function _color():stdgo.go.types.Types.T_color return __self__.value._color();
    @:embedded
    public dynamic function type():stdgo.go.types.Types.Type return __self__.value.type();
    @:embedded
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    @:embedded
    public dynamic function pkg():Ref<stdgo.go.types.Types.Package> return __self__.value.pkg();
    @:embedded
    public dynamic function parent():Ref<stdgo.go.types.Types.Scope> return __self__.value.parent();
    @:embedded
    public dynamic function name():GoString return __self__.value.name();
    @:embedded
    public dynamic function id():GoString return __self__.value.id();
    @:embedded
    public dynamic function exported():Bool return __self__.value.exported();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Func>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Func_asInterface) class Func_static_extension {
    @:keep
    static public function string( _obj:Ref<Func>):GoString {
        return objectString(Go.asInterface(_obj), null);
    }
    @:keep
    static public function _isDependency( _:Ref<Func>):Void {}
    /**
        // hasPtrRecv reports whether the receiver is of the form *T for the given method obj.
    **/
    @:keep
    static public function _hasPtrRecv( _obj:Ref<Func>):Bool {
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_obj._object._typ) : Ref<Signature>)) : Ref<Signature>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Signature>), ok : false };
            }, _sig = __tmp__.value, __0 = __tmp__.ok;
            if (((_sig != null) && ((_sig : Dynamic).__nil__ == null || !(_sig : Dynamic).__nil__)) && ((_sig._recv != null) && ((_sig._recv : Dynamic).__nil__ == null || !(_sig._recv : Dynamic).__nil__))) {
                var __tmp__ = _deref(_sig._recv._object._typ), __1:stdgo.go.types.Types.Type = __tmp__._0, _isPtr:Bool = __tmp__._1;
                return _isPtr;
            };
        };
        return _obj._hasPtrRecv_;
    }
    /**
        // Origin returns the canonical Func for its receiver, i.e. the Func object
        // recorded in Info.Defs.
        //
        // For synthetic functions created during instantiation (such as methods on an
        // instantiated Named type or interface methods that depend on type arguments),
        // this will be the corresponding Func on the generic (uninstantiated) type.
        // For all other Funcs Origin returns the receiver.
    **/
    @:keep
    static public function origin( _obj:Ref<Func>):Ref<Func> {
        if (_obj._origin != null && ((_obj._origin : Dynamic).__nil__ == null || !(_obj._origin : Dynamic).__nil__)) {
            return _obj._origin;
        };
        return _obj;
    }
    /**
        // Scope returns the scope of the function's body block.
        // The result is nil for imported or instantiated functions and methods
        // (but there is also no mechanism to get to an instantiated function).
    **/
    @:keep
    static public function scope( _obj:Ref<Func>):Ref<Scope> {
        return (Go.typeAssert((Go.toInterface(_obj._object._typ) : Ref<Signature>)) : Ref<Signature>)._scope;
    }
    /**
        // FullName returns the package- or receiver-type-qualified name of
        // function or method obj.
    **/
    @:keep
    static public function fullName( _obj:Ref<Func>):GoString {
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        _writeFuncName((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>), _obj, null);
        return (_buf.string() : GoString);
    }
    @:embedded
    public static function _setType( __self__:Func, __0:stdgo.go.types.Types.Type) __self__._setType(__0);
    @:embedded
    public static function _setScopePos( __self__:Func, _p:stdgo.go.token.Token.Pos) __self__._setScopePos(_p);
    @:embedded
    public static function _setParent( __self__:Func, __0:Ref<stdgo.go.types.Types.Scope>) __self__._setParent(__0);
    @:embedded
    public static function _setOrder( __self__:Func, __0:GoUInt32) __self__._setOrder(__0);
    @:embedded
    public static function _setColor( __self__:Func, __0:stdgo.go.types.Types.T_color) __self__._setColor(__0);
    @:embedded
    public static function _scopePos( __self__:Func):stdgo.go.token.Token.Pos return __self__._scopePos();
    @:embedded
    public static function _sameId( __self__:Func, _pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return __self__._sameId(_pkg_, _name_);
    @:embedded
    public static function _order( __self__:Func):GoUInt32 return __self__._order();
    @:embedded
    public static function _color( __self__:Func):stdgo.go.types.Types.T_color return __self__._color();
    @:embedded
    public static function type( __self__:Func):stdgo.go.types.Types.Type return __self__.type();
    @:embedded
    public static function pos( __self__:Func):stdgo.go.token.Token.Pos return __self__.pos();
    @:embedded
    public static function pkg( __self__:Func):Ref<stdgo.go.types.Types.Package> return __self__.pkg();
    @:embedded
    public static function parent( __self__:Func):Ref<stdgo.go.types.Types.Scope> return __self__.parent();
    @:embedded
    public static function name( __self__:Func):GoString return __self__.name();
    @:embedded
    public static function id( __self__:Func):GoString return __self__.id();
    @:embedded
    public static function exported( __self__:Func):Bool return __self__.exported();
}
class Label_asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:embedded
    public dynamic function _setType(__0:stdgo.go.types.Types.Type):Void __self__.value._setType(__0);
    @:embedded
    public dynamic function _setScopePos(_p:stdgo.go.token.Token.Pos):Void __self__.value._setScopePos(_p);
    @:embedded
    public dynamic function _setParent(__0:Ref<stdgo.go.types.Types.Scope>):Void __self__.value._setParent(__0);
    @:embedded
    public dynamic function _setOrder(__0:GoUInt32):Void __self__.value._setOrder(__0);
    @:embedded
    public dynamic function _setColor(__0:stdgo.go.types.Types.T_color):Void __self__.value._setColor(__0);
    @:embedded
    public dynamic function _scopePos():stdgo.go.token.Token.Pos return __self__.value._scopePos();
    @:embedded
    public dynamic function _sameId(_pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return __self__.value._sameId(_pkg_, _name_);
    @:embedded
    public dynamic function _order():GoUInt32 return __self__.value._order();
    @:embedded
    public dynamic function _color():stdgo.go.types.Types.T_color return __self__.value._color();
    @:embedded
    public dynamic function type():stdgo.go.types.Types.Type return __self__.value.type();
    @:embedded
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    @:embedded
    public dynamic function pkg():Ref<stdgo.go.types.Types.Package> return __self__.value.pkg();
    @:embedded
    public dynamic function parent():Ref<stdgo.go.types.Types.Scope> return __self__.value.parent();
    @:embedded
    public dynamic function name():GoString return __self__.value.name();
    @:embedded
    public dynamic function id():GoString return __self__.value.id();
    @:embedded
    public dynamic function exported():Bool return __self__.value.exported();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Label>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Label_asInterface) class Label_static_extension {
    @:keep
    static public function string( _obj:Ref<Label>):GoString {
        return objectString(Go.asInterface(_obj), null);
    }
    @:embedded
    public static function _setType( __self__:Label, __0:stdgo.go.types.Types.Type) __self__._setType(__0);
    @:embedded
    public static function _setScopePos( __self__:Label, _p:stdgo.go.token.Token.Pos) __self__._setScopePos(_p);
    @:embedded
    public static function _setParent( __self__:Label, __0:Ref<stdgo.go.types.Types.Scope>) __self__._setParent(__0);
    @:embedded
    public static function _setOrder( __self__:Label, __0:GoUInt32) __self__._setOrder(__0);
    @:embedded
    public static function _setColor( __self__:Label, __0:stdgo.go.types.Types.T_color) __self__._setColor(__0);
    @:embedded
    public static function _scopePos( __self__:Label):stdgo.go.token.Token.Pos return __self__._scopePos();
    @:embedded
    public static function _sameId( __self__:Label, _pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return __self__._sameId(_pkg_, _name_);
    @:embedded
    public static function _order( __self__:Label):GoUInt32 return __self__._order();
    @:embedded
    public static function _color( __self__:Label):stdgo.go.types.Types.T_color return __self__._color();
    @:embedded
    public static function type( __self__:Label):stdgo.go.types.Types.Type return __self__.type();
    @:embedded
    public static function pos( __self__:Label):stdgo.go.token.Token.Pos return __self__.pos();
    @:embedded
    public static function pkg( __self__:Label):Ref<stdgo.go.types.Types.Package> return __self__.pkg();
    @:embedded
    public static function parent( __self__:Label):Ref<stdgo.go.types.Types.Scope> return __self__.parent();
    @:embedded
    public static function name( __self__:Label):GoString return __self__.name();
    @:embedded
    public static function id( __self__:Label):GoString return __self__.id();
    @:embedded
    public static function exported( __self__:Label):Bool return __self__.exported();
}
class Builtin_asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:embedded
    public dynamic function _setType(__0:stdgo.go.types.Types.Type):Void __self__.value._setType(__0);
    @:embedded
    public dynamic function _setScopePos(_p:stdgo.go.token.Token.Pos):Void __self__.value._setScopePos(_p);
    @:embedded
    public dynamic function _setParent(__0:Ref<stdgo.go.types.Types.Scope>):Void __self__.value._setParent(__0);
    @:embedded
    public dynamic function _setOrder(__0:GoUInt32):Void __self__.value._setOrder(__0);
    @:embedded
    public dynamic function _setColor(__0:stdgo.go.types.Types.T_color):Void __self__.value._setColor(__0);
    @:embedded
    public dynamic function _scopePos():stdgo.go.token.Token.Pos return __self__.value._scopePos();
    @:embedded
    public dynamic function _sameId(_pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return __self__.value._sameId(_pkg_, _name_);
    @:embedded
    public dynamic function _order():GoUInt32 return __self__.value._order();
    @:embedded
    public dynamic function _color():stdgo.go.types.Types.T_color return __self__.value._color();
    @:embedded
    public dynamic function type():stdgo.go.types.Types.Type return __self__.value.type();
    @:embedded
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    @:embedded
    public dynamic function pkg():Ref<stdgo.go.types.Types.Package> return __self__.value.pkg();
    @:embedded
    public dynamic function parent():Ref<stdgo.go.types.Types.Scope> return __self__.value.parent();
    @:embedded
    public dynamic function name():GoString return __self__.value.name();
    @:embedded
    public dynamic function id():GoString return __self__.value.id();
    @:embedded
    public dynamic function exported():Bool return __self__.value.exported();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Builtin>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Builtin_asInterface) class Builtin_static_extension {
    @:keep
    static public function string( _obj:Ref<Builtin>):GoString {
        return objectString(Go.asInterface(_obj), null);
    }
    @:embedded
    public static function _setType( __self__:Builtin, __0:stdgo.go.types.Types.Type) __self__._setType(__0);
    @:embedded
    public static function _setScopePos( __self__:Builtin, _p:stdgo.go.token.Token.Pos) __self__._setScopePos(_p);
    @:embedded
    public static function _setParent( __self__:Builtin, __0:Ref<stdgo.go.types.Types.Scope>) __self__._setParent(__0);
    @:embedded
    public static function _setOrder( __self__:Builtin, __0:GoUInt32) __self__._setOrder(__0);
    @:embedded
    public static function _setColor( __self__:Builtin, __0:stdgo.go.types.Types.T_color) __self__._setColor(__0);
    @:embedded
    public static function _scopePos( __self__:Builtin):stdgo.go.token.Token.Pos return __self__._scopePos();
    @:embedded
    public static function _sameId( __self__:Builtin, _pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return __self__._sameId(_pkg_, _name_);
    @:embedded
    public static function _order( __self__:Builtin):GoUInt32 return __self__._order();
    @:embedded
    public static function _color( __self__:Builtin):stdgo.go.types.Types.T_color return __self__._color();
    @:embedded
    public static function type( __self__:Builtin):stdgo.go.types.Types.Type return __self__.type();
    @:embedded
    public static function pos( __self__:Builtin):stdgo.go.token.Token.Pos return __self__.pos();
    @:embedded
    public static function pkg( __self__:Builtin):Ref<stdgo.go.types.Types.Package> return __self__.pkg();
    @:embedded
    public static function parent( __self__:Builtin):Ref<stdgo.go.types.Types.Scope> return __self__.parent();
    @:embedded
    public static function name( __self__:Builtin):GoString return __self__.name();
    @:embedded
    public static function id( __self__:Builtin):GoString return __self__.id();
    @:embedded
    public static function exported( __self__:Builtin):Bool return __self__.exported();
}
class Nil_asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:embedded
    public dynamic function _setType(__0:stdgo.go.types.Types.Type):Void __self__.value._setType(__0);
    @:embedded
    public dynamic function _setScopePos(_p:stdgo.go.token.Token.Pos):Void __self__.value._setScopePos(_p);
    @:embedded
    public dynamic function _setParent(__0:Ref<stdgo.go.types.Types.Scope>):Void __self__.value._setParent(__0);
    @:embedded
    public dynamic function _setOrder(__0:GoUInt32):Void __self__.value._setOrder(__0);
    @:embedded
    public dynamic function _setColor(__0:stdgo.go.types.Types.T_color):Void __self__.value._setColor(__0);
    @:embedded
    public dynamic function _scopePos():stdgo.go.token.Token.Pos return __self__.value._scopePos();
    @:embedded
    public dynamic function _sameId(_pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return __self__.value._sameId(_pkg_, _name_);
    @:embedded
    public dynamic function _order():GoUInt32 return __self__.value._order();
    @:embedded
    public dynamic function _color():stdgo.go.types.Types.T_color return __self__.value._color();
    @:embedded
    public dynamic function type():stdgo.go.types.Types.Type return __self__.value.type();
    @:embedded
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    @:embedded
    public dynamic function pkg():Ref<stdgo.go.types.Types.Package> return __self__.value.pkg();
    @:embedded
    public dynamic function parent():Ref<stdgo.go.types.Types.Scope> return __self__.value.parent();
    @:embedded
    public dynamic function name():GoString return __self__.value.name();
    @:embedded
    public dynamic function id():GoString return __self__.value.id();
    @:embedded
    public dynamic function exported():Bool return __self__.value.exported();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Nil>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Nil_asInterface) class Nil_static_extension {
    @:keep
    static public function string( _obj:Ref<Nil>):GoString {
        return objectString(Go.asInterface(_obj), null);
    }
    @:embedded
    public static function _setType( __self__:Nil, __0:stdgo.go.types.Types.Type) __self__._setType(__0);
    @:embedded
    public static function _setScopePos( __self__:Nil, _p:stdgo.go.token.Token.Pos) __self__._setScopePos(_p);
    @:embedded
    public static function _setParent( __self__:Nil, __0:Ref<stdgo.go.types.Types.Scope>) __self__._setParent(__0);
    @:embedded
    public static function _setOrder( __self__:Nil, __0:GoUInt32) __self__._setOrder(__0);
    @:embedded
    public static function _setColor( __self__:Nil, __0:stdgo.go.types.Types.T_color) __self__._setColor(__0);
    @:embedded
    public static function _scopePos( __self__:Nil):stdgo.go.token.Token.Pos return __self__._scopePos();
    @:embedded
    public static function _sameId( __self__:Nil, _pkg_:Ref<stdgo.go.types.Types.Package>, _name_:GoString):Bool return __self__._sameId(_pkg_, _name_);
    @:embedded
    public static function _order( __self__:Nil):GoUInt32 return __self__._order();
    @:embedded
    public static function _color( __self__:Nil):stdgo.go.types.Types.T_color return __self__._color();
    @:embedded
    public static function type( __self__:Nil):stdgo.go.types.Types.Type return __self__.type();
    @:embedded
    public static function pos( __self__:Nil):stdgo.go.token.Token.Pos return __self__.pos();
    @:embedded
    public static function pkg( __self__:Nil):Ref<stdgo.go.types.Types.Package> return __self__.pkg();
    @:embedded
    public static function parent( __self__:Nil):Ref<stdgo.go.types.Types.Scope> return __self__.parent();
    @:embedded
    public static function name( __self__:Nil):GoString return __self__.name();
    @:embedded
    public static function id( __self__:Nil):GoString return __self__.id();
    @:embedded
    public static function exported( __self__:Nil):Bool return __self__.exported();
}
class T_operand_asInterface {
    /**
        // assignableTo reports whether x is assignable to a variable of type T. If the
        // result is false and a non-nil cause is provided, it may be set to a more
        // detailed explanation of the failure (result != ""). The returned error code
        // is only valid if the (first) result is false. The check parameter may be nil
        // if assignableTo is invoked through an exported API call, i.e., when all
        // methods have been type-checked.
    **/
    @:keep
    public dynamic function _assignableTo(_check:Ref<Checker>, t:Type, _cause:Pointer<GoString>):{ var _0 : Bool; var _1 : Code; } return __self__.value._assignableTo(_check, t, _cause);
    /**
        // isNil reports whether x is the nil value.
    **/
    @:keep
    public dynamic function _isNil():Bool return __self__.value._isNil();
    /**
        // setConst sets x to the untyped constant for literal lit.
    **/
    @:keep
    public dynamic function _setConst(_tok:stdgo.go.token.Token.Token, _lit:GoString):Void __self__.value._setConst(_tok, _lit);
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    /**
        // Pos returns the position of the expression corresponding to x.
        // If x is invalid the position is token.NoPos.
    **/
    @:keep
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    /**
        // convertibleTo reports whether T(x) is valid. In the failure case, *cause
        // may be set to the cause for the failure.
        // The check parameter may be nil if convertibleTo is invoked through an
        // exported API call, i.e., when all methods have been type-checked.
    **/
    @:keep
    public dynamic function _convertibleTo(_check:Ref<Checker>, t:Type, _cause:Pointer<GoString>):Bool return __self__.value._convertibleTo(_check, t, _cause);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_operand>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_operand_asInterface) class T_operand_static_extension {
    /**
        // assignableTo reports whether x is assignable to a variable of type T. If the
        // result is false and a non-nil cause is provided, it may be set to a more
        // detailed explanation of the failure (result != ""). The returned error code
        // is only valid if the (first) result is false. The check parameter may be nil
        // if assignableTo is invoked through an exported API call, i.e., when all
        // methods have been type-checked.
    **/
    @:keep
    static public function _assignableTo( _x:Ref<T_operand>, _check:Ref<Checker>, t:Type, _cause:Pointer<GoString>):{ var _0 : Bool; var _1 : Code; } {
        if ((_x._mode == (0 : stdgo.go.types.Types.T_operandMode)) || (Go.toInterface(t) == Go.toInterface(Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])))) {
            return { _0 : true, _1 : (0 : stdgo.internal.types.errors.Errors.Code) };
        };
        var v:stdgo.go.types.Types.Type = _x._typ;
        if (identical(v, t)) {
            return { _0 : true, _1 : (0 : stdgo.internal.types.errors.Errors.Code) };
        };
        var vu:stdgo.go.types.Types.Type = _under(v);
        var tu:stdgo.go.types.Types.Type = _under(t);
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(v) : Ref<TypeParam>)) : Ref<TypeParam>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.TypeParam>), ok : false };
        }, vp = __tmp__.value, __0 = __tmp__.ok;
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(t) : Ref<TypeParam>)) : Ref<TypeParam>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.TypeParam>), ok : false };
        }, tp = __tmp__.value, __1 = __tmp__.ok;
        if (_isUntyped(vu)) {
            _assert(vp == null || (vp : Dynamic).__nil__);
            if (tp != null && ((tp : Dynamic).__nil__ == null || !(tp : Dynamic).__nil__)) {
                return { _0 : tp._is(function(_t:Ref<T_term>):Bool {
                    if (_t == null || (_t : Dynamic).__nil__) {
                        return false;
                    };
                    var __tmp__ = _check._implicitTypeAndValue(_x, _t._typ), _newType:stdgo.go.types.Types.Type = __tmp__._0, __0:stdgo.go.constant.Constant.Value = __tmp__._1, __1:stdgo.internal.types.errors.Errors.Code = __tmp__._2;
                    return _newType != null;
                }), _1 : (23 : stdgo.internal.types.errors.Errors.Code) };
            };
            var __tmp__ = _check._implicitTypeAndValue(_x, t), _newType:stdgo.go.types.Types.Type = __tmp__._0, __2:stdgo.go.constant.Constant.Value = __tmp__._1, __3:stdgo.internal.types.errors.Errors.Code = __tmp__._2;
            return { _0 : _newType != null, _1 : (23 : stdgo.internal.types.errors.Errors.Code) };
        };
        if (((identical(vu, tu) && (!_hasName(v) || !_hasName(t))) && (vp == null) || (vp : Dynamic).__nil__) && (tp == null) || (tp : Dynamic).__nil__) {
            return { _0 : true, _1 : (0 : stdgo.internal.types.errors.Errors.Code) };
        };
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(tu) : Ref<Interface>)) : Ref<Interface>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Interface>), ok : false };
            }, __4 = __tmp__.value, _ok = __tmp__.ok;
            if ((_ok && (tp == null) || (tp : Dynamic).__nil__) || _isInterfacePtr(tu)) {
                if (!_check._implements(v, t, false, _cause)) {
                    return { _0 : false, _1 : (21 : stdgo.internal.types.errors.Errors.Code) };
                };
                return { _0 : true, _1 : (0 : stdgo.internal.types.errors.Errors.Code) };
            };
        };
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(vu) : Ref<Interface>)) : Ref<Interface>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Interface>), ok : false };
            }, vi = __tmp__.value, __5 = __tmp__.ok;
            if (((vi != null) && ((vi : Dynamic).__nil__ == null || !(vi : Dynamic).__nil__)) && (vp == null) || (vp : Dynamic).__nil__) {
                if (_check._implements(t, v, false, (null : Pointer<GoString>))) {
                    if (_cause != null) {
                        _cause.value = ("need type assertion" : GoString);
                    };
                    return { _0 : false, _1 : (23 : stdgo.internal.types.errors.Errors.Code) };
                };
            };
        };
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(vu) : Ref<Chan>)) : Ref<Chan>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Chan>), ok : false };
            }, vc = __tmp__.value, _ok = __tmp__.ok;
            if (_ok && (vc._dir == (0 : stdgo.go.types.Types.ChanDir))) {
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(tu) : Ref<Chan>)) : Ref<Chan>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Chan>), ok : false };
                    }, tc = __tmp__.value, _ok = __tmp__.ok;
                    if (_ok && identical(vc._elem, tc._elem)) {
                        return { _0 : !_hasName(v) || !_hasName(t), _1 : (22 : stdgo.internal.types.errors.Errors.Code) };
                    };
                };
            };
        };
        if ((vp == null) || (vp : Dynamic).__nil__ && (tp == null) || (tp : Dynamic).__nil__) {
            return { _0 : false, _1 : (23 : stdgo.internal.types.errors.Errors.Code) };
        };
        var _errorf = function(_format:GoString, _args:haxe.Rest<AnyInterface>):Void {
            if (((_check != null) && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) && (_cause != null)) {
                var _msg:GoString = _check._sprintf(_format, ..._args.__toArray__());
                if (_cause.value != (Go.str())) {
                    _msg = _msg + (("\n\t" : GoString) + _cause.value);
                };
                _cause.value = _msg;
            };
        };
        if (!_hasName(v) && ((tp != null) && ((tp : Dynamic).__nil__ == null || !(tp : Dynamic).__nil__))) {
            var _ok:Bool = false;
            var _code:stdgo.internal.types.errors.Errors.Code = (23 : stdgo.internal.types.errors.Errors.Code);
            tp._is(function(t:Ref<T_term>):Bool {
                if (t == null || (t : Dynamic).__nil__) {
                    return false;
                };
                {
                    var __tmp__ = _x._assignableTo(_check, t._typ, _cause);
                    _ok = __tmp__._0;
                    _code = __tmp__._1;
                };
                if (!_ok) {
                    _errorf(("cannot assign %s to %s (in %s)" : GoString), Go.toInterface(_x._typ), Go.toInterface(t._typ), Go.toInterface(Go.asInterface(tp)));
                    return false;
                };
                return true;
            });
            return { _0 : _ok, _1 : _code };
        };
        if (((vp != null) && ((vp : Dynamic).__nil__ == null || !(vp : Dynamic).__nil__)) && !_hasName(t)) {
            var _x:stdgo.go.types.Types.T_operand = (_x : stdgo.go.types.Types.T_operand)?.__copy__();
            var _ok:Bool = false;
            var _code:stdgo.internal.types.errors.Errors.Code = (23 : stdgo.internal.types.errors.Errors.Code);
            vp._is(function(v:Ref<T_term>):Bool {
                if (v == null || (v : Dynamic).__nil__) {
                    return false;
                };
                _x._typ = v._typ;
                {
                    var __tmp__ = _x._assignableTo(_check, t, _cause);
                    _ok = __tmp__._0;
                    _code = __tmp__._1;
                };
                if (!_ok) {
                    _errorf(("cannot assign %s (in %s) to %s" : GoString), Go.toInterface(v._typ), Go.toInterface(Go.asInterface(vp)), Go.toInterface(t));
                    return false;
                };
                return true;
            });
            return { _0 : _ok, _1 : _code };
        };
        return { _0 : false, _1 : (23 : stdgo.internal.types.errors.Errors.Code) };
    }
    /**
        // isNil reports whether x is the nil value.
    **/
    @:keep
    static public function _isNil( _x:Ref<T_operand>):Bool {
        return (_x._mode == (7 : stdgo.go.types.Types.T_operandMode)) && (Go.toInterface(_x._typ) == Go.toInterface(Go.asInterface(typ[((25 : stdgo.go.types.Types.BasicKind) : GoInt)])));
    }
    /**
        // setConst sets x to the untyped constant for literal lit.
    **/
    @:keep
    static public function _setConst( _x:Ref<T_operand>, _tok:stdgo.go.token.Token.Token, _lit:GoString):Void {
        var _kind:BasicKind = ((0 : GoInt) : stdgo.go.types.Types.BasicKind);
        {
            final __value__ = _tok;
            if (__value__ == ((5 : stdgo.go.token.Token.Token))) {
                _kind = (20 : stdgo.go.types.Types.BasicKind);
            } else if (__value__ == ((6 : stdgo.go.token.Token.Token))) {
                _kind = (22 : stdgo.go.types.Types.BasicKind);
            } else if (__value__ == ((7 : stdgo.go.token.Token.Token))) {
                _kind = (23 : stdgo.go.types.Types.BasicKind);
            } else if (__value__ == ((8 : stdgo.go.token.Token.Token))) {
                _kind = (21 : stdgo.go.types.Types.BasicKind);
            } else if (__value__ == ((9 : stdgo.go.token.Token.Token))) {
                _kind = (24 : stdgo.go.types.Types.BasicKind);
            } else {
                _unreachable();
            };
        };
        var _val:stdgo.go.constant.Constant.Value = stdgo.go.constant.Constant.makeFromLiteral(_lit, _tok, (0u32 : GoUInt));
        if (_val.kind() == ((0 : stdgo.go.constant.Constant.Kind))) {
            _x._mode = (0 : stdgo.go.types.Types.T_operandMode);
            _x._typ = Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
            return;
        };
        _x._mode = (4 : stdgo.go.types.Types.T_operandMode);
        _x._typ = Go.asInterface(typ[(_kind : GoInt)]);
        _x._val = _val;
    }
    @:keep
    static public function string( _x:Ref<T_operand>):GoString {
        return _operandString(_x, null);
    }
    /**
        // Pos returns the position of the expression corresponding to x.
        // If x is invalid the position is token.NoPos.
    **/
    @:keep
    static public function pos( _x:Ref<T_operand>):stdgo.go.token.Token.Pos {
        if (_x._expr == null) {
            return (0 : stdgo.go.token.Token.Pos);
        };
        return _x._expr.pos();
    }
    /**
        // convertibleTo reports whether T(x) is valid. In the failure case, *cause
        // may be set to the cause for the failure.
        // The check parameter may be nil if convertibleTo is invoked through an
        // exported API call, i.e., when all methods have been type-checked.
    **/
    @:keep
    static public function _convertibleTo( _x:Ref<T_operand>, _check:Ref<Checker>, t:Type, _cause:Pointer<GoString>):Bool {
        {
            var __tmp__ = _x._assignableTo(_check, t, _cause), _ok:Bool = __tmp__._0, __0:stdgo.internal.types.errors.Errors.Code = __tmp__._1;
            if (_ok) {
                return true;
            };
        };
        var v:stdgo.go.types.Types.Type = _x._typ;
        var vu:stdgo.go.types.Types.Type = _under(v);
        var tu:stdgo.go.types.Types.Type = _under(t);
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(v) : Ref<TypeParam>)) : Ref<TypeParam>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.TypeParam>), ok : false };
        }, vp = __tmp__.value, __1 = __tmp__.ok;
        var __tmp__ = try {
            { value : (Go.typeAssert((Go.toInterface(t) : Ref<TypeParam>)) : Ref<TypeParam>), ok : true };
        } catch(_) {
            { value : (null : Ref<stdgo.go.types.Types.TypeParam>), ok : false };
        }, tp = __tmp__.value, __2 = __tmp__.ok;
        if ((identicalIgnoreTags(vu, tu) && (vp == null) || (vp : Dynamic).__nil__) && (tp == null) || (tp : Dynamic).__nil__) {
            return true;
        };
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(v) : Ref<Pointer_>)) : Ref<Pointer_>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Pointer_>), ok : false };
            }, v = __tmp__.value, _ok = __tmp__.ok;
            if (_ok) {
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(t) : Ref<Pointer_>)) : Ref<Pointer_>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Pointer_>), ok : false };
                    }, t = __tmp__.value, _ok = __tmp__.ok;
                    if (_ok) {
                        if ((identicalIgnoreTags(_under(v._base), _under(t._base)) && !_isTypeParam(v._base)) && !_isTypeParam(t._base)) {
                            return true;
                        };
                    };
                };
            };
        };
        if (_isIntegerOrFloat(vu) && _isIntegerOrFloat(tu)) {
            return true;
        };
        if (_isComplex(vu) && _isComplex(tu)) {
            return true;
        };
        if ((_isInteger(vu) || _isBytesOrRunes(vu)) && _isString(tu)) {
            return true;
        };
        if (_isString(vu) && _isBytesOrRunes(tu)) {
            return true;
        };
        if ((_isPointer(vu) || _isUintptr(vu)) && _isUnsafePointer(tu)) {
            return true;
        };
        if (_isUnsafePointer(vu) && (_isPointer(tu) || _isUintptr(tu))) {
            return true;
        };
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(vu) : Ref<Slice_>)) : Ref<Slice_>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.Slice_>), ok : false };
            }, _s = __tmp__.value, __3 = __tmp__.ok;
            if (_s != null && ((_s : Dynamic).__nil__ == null || !(_s : Dynamic).__nil__)) {
                {
                    final __type__ = tu;
                    if (Go.typeEquals((__type__ : Ref<Array_>))) {
                        var _a:Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                        if (identical(_s.elem(), _a.elem())) {
                            if (((_check == null) || (_check : Dynamic).__nil__) || _check._allowVersion(_check._pkg, (1 : GoInt), (20 : GoInt))) {
                                return true;
                            };
                            if (_cause != null) {
                                _cause.value = ("conversion of slices to arrays requires go1.20 or later" : GoString);
                            };
                            return false;
                        };
                    } else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
                        var _a:Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                        {
                            var __tmp__ = try {
                                { value : (Go.typeAssert((Go.toInterface(_under(_a.elem())) : Ref<Array_>)) : Ref<Array_>), ok : true };
                            } catch(_) {
                                { value : (null : Ref<stdgo.go.types.Types.Array_>), ok : false };
                            }, _a = __tmp__.value, __12 = __tmp__.ok;
                            if (_a != null && ((_a : Dynamic).__nil__ == null || !(_a : Dynamic).__nil__)) {
                                if (identical(_s.elem(), _a.elem())) {
                                    if (((_check == null) || (_check : Dynamic).__nil__) || _check._allowVersion(_check._pkg, (1 : GoInt), (17 : GoInt))) {
                                        return true;
                                    };
                                    if (_cause != null) {
                                        _cause.value = ("conversion of slices to array pointers requires go1.17 or later" : GoString);
                                    };
                                    return false;
                                };
                            };
                        };
                    };
                };
            };
        };
        if ((vp == null) || (vp : Dynamic).__nil__ && (tp == null) || (tp : Dynamic).__nil__) {
            return false;
        };
        var _errorf = function(_format:GoString, _args:haxe.Rest<AnyInterface>):Void {
            if (((_check != null) && ((_check : Dynamic).__nil__ == null || !(_check : Dynamic).__nil__)) && (_cause != null)) {
                var _msg:GoString = _check._sprintf(_format, ..._args.__toArray__());
                if (_cause.value != (Go.str())) {
                    _msg = _msg + (("\n\t" : GoString) + _cause.value);
                };
                _cause.value = _msg;
            };
        };
        if (((vp != null) && ((vp : Dynamic).__nil__ == null || !(vp : Dynamic).__nil__)) && ((tp != null) && ((tp : Dynamic).__nil__ == null || !(tp : Dynamic).__nil__))) {
            var _x:stdgo.go.types.Types.T_operand = (_x : stdgo.go.types.Types.T_operand)?.__copy__();
            return vp._is(function(v:Ref<T_term>):Bool {
                if (v == null || (v : Dynamic).__nil__) {
                    return false;
                };
                _x._typ = v._typ;
                return tp._is(function(t:Ref<T_term>):Bool {
                    if (t == null || (t : Dynamic).__nil__) {
                        return false;
                    };
                    if (!_x._convertibleTo(_check, t._typ, _cause)) {
                        _errorf(("cannot convert %s (in %s) to type %s (in %s)" : GoString), Go.toInterface(v._typ), Go.toInterface(Go.asInterface(vp)), Go.toInterface(t._typ), Go.toInterface(Go.asInterface(tp)));
                        return false;
                    };
                    return true;
                });
            });
        } else if (vp != null && ((vp : Dynamic).__nil__ == null || !(vp : Dynamic).__nil__)) {
            var _x:stdgo.go.types.Types.T_operand = (_x : stdgo.go.types.Types.T_operand)?.__copy__();
            return vp._is(function(v:Ref<T_term>):Bool {
                if (v == null || (v : Dynamic).__nil__) {
                    return false;
                };
                _x._typ = v._typ;
                if (!_x._convertibleTo(_check, t, _cause)) {
                    _errorf(("cannot convert %s (in %s) to type %s" : GoString), Go.toInterface(v._typ), Go.toInterface(Go.asInterface(vp)), Go.toInterface(t));
                    return false;
                };
                return true;
            });
        } else if (tp != null && ((tp : Dynamic).__nil__ == null || !(tp : Dynamic).__nil__)) {
            return tp._is(function(t:Ref<T_term>):Bool {
                if (t == null || (t : Dynamic).__nil__) {
                    return false;
                };
                if (!_x._convertibleTo(_check, t._typ, _cause)) {
                    _errorf(("cannot convert %s to type %s (in %s)" : GoString), Go.toInterface(_x._typ), Go.toInterface(t._typ), Go.toInterface(Go.asInterface(tp)));
                    return false;
                };
                return true;
            });
        };
        return false;
    }
}
class Package_asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    /**
        // SetImports sets the list of explicitly imported packages to list.
        // It is the caller's responsibility to make sure list elements are unique.
    **/
    @:keep
    public dynamic function setImports(_list:Slice<Ref<Package>>):Void __self__.value.setImports(_list);
    /**
        // Imports returns the list of packages directly imported by
        // pkg; the list is in source order.
        //
        // If pkg was loaded from export data, Imports includes packages that
        // provide package-level objects referenced by pkg. This may be more or
        // less than the set of packages directly imported by pkg's source code.
        //
        // If pkg uses cgo and the FakeImportC configuration option
        // was enabled, the imports list may contain a fake "C" package.
    **/
    @:keep
    public dynamic function imports():Slice<Ref<Package>> return __self__.value.imports();
    /**
        // MarkComplete marks a package as complete.
    **/
    @:keep
    public dynamic function markComplete():Void __self__.value.markComplete();
    /**
        // A package is complete if its scope contains (at least) all
        // exported objects; otherwise it is incomplete.
    **/
    @:keep
    public dynamic function complete():Bool return __self__.value.complete();
    /**
        // Scope returns the (complete or incomplete) package scope
        // holding the objects declared at package level (TypeNames,
        // Consts, Vars, and Funcs).
        // For a nil pkg receiver, Scope returns the Universe scope.
    **/
    @:keep
    public dynamic function scope():Ref<Scope> return __self__.value.scope();
    /**
        // SetName sets the package name.
    **/
    @:keep
    public dynamic function setName(_name:GoString):Void __self__.value.setName(_name);
    /**
        // Name returns the package name.
    **/
    @:keep
    public dynamic function name():GoString return __self__.value.name();
    /**
        // Path returns the package path.
    **/
    @:keep
    public dynamic function path():GoString return __self__.value.path();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Package>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Package_asInterface) class Package_static_extension {
    @:keep
    static public function string( _pkg:Ref<Package>):GoString {
        return stdgo.fmt.Fmt.sprintf(("package %s (%q)" : GoString), Go.toInterface(_pkg._name), Go.toInterface(_pkg._path));
    }
    /**
        // SetImports sets the list of explicitly imported packages to list.
        // It is the caller's responsibility to make sure list elements are unique.
    **/
    @:keep
    static public function setImports( _pkg:Ref<Package>, _list:Slice<Ref<Package>>):Void {
        _pkg._imports = _list;
    }
    /**
        // Imports returns the list of packages directly imported by
        // pkg; the list is in source order.
        //
        // If pkg was loaded from export data, Imports includes packages that
        // provide package-level objects referenced by pkg. This may be more or
        // less than the set of packages directly imported by pkg's source code.
        //
        // If pkg uses cgo and the FakeImportC configuration option
        // was enabled, the imports list may contain a fake "C" package.
    **/
    @:keep
    static public function imports( _pkg:Ref<Package>):Slice<Ref<Package>> {
        return _pkg._imports;
    }
    /**
        // MarkComplete marks a package as complete.
    **/
    @:keep
    static public function markComplete( _pkg:Ref<Package>):Void {
        _pkg._complete = true;
    }
    /**
        // A package is complete if its scope contains (at least) all
        // exported objects; otherwise it is incomplete.
    **/
    @:keep
    static public function complete( _pkg:Ref<Package>):Bool {
        return _pkg._complete;
    }
    /**
        // Scope returns the (complete or incomplete) package scope
        // holding the objects declared at package level (TypeNames,
        // Consts, Vars, and Funcs).
        // For a nil pkg receiver, Scope returns the Universe scope.
    **/
    @:keep
    static public function scope( _pkg:Ref<Package>):Ref<Scope> {
        if (_pkg != null && ((_pkg : Dynamic).__nil__ == null || !(_pkg : Dynamic).__nil__)) {
            return _pkg._scope;
        };
        return universe;
    }
    /**
        // SetName sets the package name.
    **/
    @:keep
    static public function setName( _pkg:Ref<Package>, _name:GoString):Void {
        _pkg._name = _name;
    }
    /**
        // Name returns the package name.
    **/
    @:keep
    static public function name( _pkg:Ref<Package>):GoString {
        return _pkg._name;
    }
    /**
        // Path returns the package path.
    **/
    @:keep
    static public function path( _pkg:Ref<Package>):GoString {
        return _pkg._path;
    }
}
class Pointer__asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type return __self__.value.underlying();
    /**
        // Elem returns the element type for the given pointer p.
    **/
    @:keep
    public dynamic function elem():Type return __self__.value.elem();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Pointer_>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Pointer__asInterface) class Pointer__static_extension {
    @:keep
    static public function string( _t:Ref<Pointer_>):GoString {
        return typeString(Go.asInterface(_t), null);
    }
    @:keep
    static public function underlying( _t:Ref<Pointer_>):Type {
        return Go.asInterface(_t);
    }
    /**
        // Elem returns the element type for the given pointer p.
    **/
    @:keep
    static public function elem( _p:Ref<Pointer_>):Type {
        return _p._base;
    }
}
class T_ifacePair_asInterface {
    @:keep
    public dynamic function _identical(_q:Ref<T_ifacePair>):Bool return __self__.value._identical(_q);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_ifacePair>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_ifacePair_asInterface) class T_ifacePair_static_extension {
    @:keep
    static public function _identical( _p:Ref<T_ifacePair>, _q:Ref<T_ifacePair>):Bool {
        return ((_p._x == _q._x) && (_p._y == _q._y)) || ((_p._x == _q._y) && (_p._y == _q._x));
    }
}
class T_declInfo_asInterface {
    /**
        // addDep adds obj to the set of objects d's init expression depends on.
    **/
    @:keep
    public dynamic function _addDep(_obj:Object):Void __self__.value._addDep(_obj);
    /**
        // hasInitializer reports whether the declared object has an initialization
        // expression or function body.
    **/
    @:keep
    public dynamic function _hasInitializer():Bool return __self__.value._hasInitializer();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_declInfo>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_declInfo_asInterface) class T_declInfo_static_extension {
    /**
        // addDep adds obj to the set of objects d's init expression depends on.
    **/
    @:keep
    static public function _addDep( _d:Ref<T_declInfo>, _obj:Object):Void {
        var _m = _d._deps;
        if (_m == null) {
            _m = ({
                final x = new GoObjectMap<stdgo.go.types.Types.Object, Bool>();
                x.t = new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.named("stdgo.go.types.Types.Object", [], stdgo.internal.reflect.Reflect.GoType.named("Object", [], stdgo.internal.reflect.Reflect.GoType.interfaceType(false, []), false, { get : () -> null }), false, { get : () -> null }));
                x.__defaultValue__ = () -> false;
                @:mergeBlock {};
                cast x;
            } : GoMap<stdgo.go.types.Types.Object, Bool>);
            _d._deps = _m;
        };
        _m[_obj] = true;
    }
    /**
        // hasInitializer reports whether the declared object has an initialization
        // expression or function body.
    **/
    @:keep
    static public function _hasInitializer( _d:Ref<T_declInfo>):Bool {
        return (_d._init != null) || (((_d._fdecl != null) && ((_d._fdecl : Dynamic).__nil__ == null || !(_d._fdecl : Dynamic).__nil__)) && ((_d._fdecl.body != null) && ((_d._fdecl.body : Dynamic).__nil__ == null || !(_d._fdecl.body : Dynamic).__nil__)));
    }
}
class Scope_asInterface {
    /**
        // String returns a string representation of the scope, for debugging.
    **/
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    /**
        // WriteTo writes a string representation of the scope to w,
        // with the scope elements sorted by name.
        // The level of indentation is controlled by n >= 0, with
        // n == 0 for no indentation.
        // If recurse is set, it also writes nested (children) scopes.
    **/
    @:keep
    public dynamic function writeTo(_w:stdgo.io.Io.Writer, _n:GoInt, _recurse:Bool):Void __self__.value.writeTo(_w, _n, _recurse);
    /**
        // Innermost returns the innermost (child) scope containing
        // pos. If pos is not within any scope, the result is nil.
        // The result is also nil for the Universe scope.
        // The result is guaranteed to be valid only if the type-checked
        // AST has complete position information.
    **/
    @:keep
    public dynamic function innermost(_pos:stdgo.go.token.Token.Pos):Ref<Scope> return __self__.value.innermost(_pos);
    /**
        // Contains reports whether pos is within the scope's extent.
        // The result is guaranteed to be valid only if the type-checked
        // AST has complete position information.
    **/
    @:keep
    public dynamic function contains(_pos:stdgo.go.token.Token.Pos):Bool return __self__.value.contains(_pos);
    @:keep
    public dynamic function end():stdgo.go.token.Token.Pos return __self__.value.end();
    /**
        // Pos and End describe the scope's source code extent [pos, end).
        // The results are guaranteed to be valid only if the type-checked
        // AST has complete position information. The extent is undefined
        // for Universe and package scopes.
    **/
    @:keep
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    /**
        // squash merges s with its parent scope p by adding all
        // objects of s to p, adding all children of s to the
        // children of p, and removing s from p's children.
        // The function f is called for each object obj in s which
        // has an object alt in p. s should be discarded after
        // having been squashed.
    **/
    @:keep
    public dynamic function _squash(_err:(_obj:Object, _alt:Object) -> Void):Void __self__.value._squash(_err);
    @:keep
    public dynamic function _insert(_name:GoString, _obj:Object):Void __self__.value._insert(_name, _obj);
    /**
        // _InsertLazy is like Insert, but allows deferring construction of the
        // inserted object until it's accessed with Lookup. The Object
        // returned by resolve must have the same name as given to _InsertLazy.
        // If s already contains an alternative object with the same name,
        // _InsertLazy leaves s unchanged and returns false. Otherwise it
        // records the binding and returns true. The object's parent scope
        // will be set to s after resolve is called.
    **/
    @:keep
    public dynamic function __InsertLazy(_name:GoString, _resolve:() -> Object):Bool return __self__.value.__InsertLazy(_name, _resolve);
    /**
        // Insert attempts to insert an object obj into scope s.
        // If s already contains an alternative object alt with
        // the same name, Insert leaves s unchanged and returns alt.
        // Otherwise it inserts obj, sets the object's parent scope
        // if not already set, and returns nil.
    **/
    @:keep
    public dynamic function insert(_obj:Object):Object return __self__.value.insert(_obj);
    /**
        // LookupParent follows the parent chain of scopes starting with s until
        // it finds a scope where Lookup(name) returns a non-nil object, and then
        // returns that scope and object. If a valid position pos is provided,
        // only objects that were declared at or before pos are considered.
        // If no such scope and object exists, the result is (nil, nil).
        //
        // Note that obj.Parent() may be different from the returned scope if the
        // object was inserted into the scope and already had a parent at that
        // time (see Insert). This can only happen for dot-imported objects
        // whose scope is the scope of the package that exported them.
    **/
    @:keep
    public dynamic function lookupParent(_name:GoString, _pos:stdgo.go.token.Token.Pos):{ var _0 : Ref<Scope>; var _1 : Object; } return __self__.value.lookupParent(_name, _pos);
    /**
        // Lookup returns the object in scope s with the given name if such an
        // object exists; otherwise the result is nil.
    **/
    @:keep
    public dynamic function lookup(_name:GoString):Object return __self__.value.lookup(_name);
    /**
        // Child returns the i'th child scope for 0 <= i < NumChildren().
    **/
    @:keep
    public dynamic function child(_i:GoInt):Ref<Scope> return __self__.value.child(_i);
    /**
        // NumChildren returns the number of scopes nested in s.
    **/
    @:keep
    public dynamic function numChildren():GoInt return __self__.value.numChildren();
    /**
        // Names returns the scope's element names in sorted order.
    **/
    @:keep
    public dynamic function names():Slice<GoString> return __self__.value.names();
    /**
        // Len returns the number of scope elements.
    **/
    @:keep
    public dynamic function len():GoInt return __self__.value.len();
    /**
        // Parent returns the scope's containing (parent) scope.
    **/
    @:keep
    public dynamic function parent():Ref<Scope> return __self__.value.parent();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Scope>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Scope_asInterface) class Scope_static_extension {
    /**
        // String returns a string representation of the scope, for debugging.
    **/
    @:keep
    static public function string( _s:Ref<Scope>):GoString {
        var _buf:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
        _s.writeTo(Go.asInterface((Go.setRef(_buf) : Ref<stdgo.strings.Strings.Builder>)), (0 : GoInt), false);
        return (_buf.string() : GoString);
    }
    /**
        // WriteTo writes a string representation of the scope to w,
        // with the scope elements sorted by name.
        // The level of indentation is controlled by n >= 0, with
        // n == 0 for no indentation.
        // If recurse is set, it also writes nested (children) scopes.
    **/
    @:keep
    static public function writeTo( _s:Ref<Scope>, _w:stdgo.io.Io.Writer, _n:GoInt, _recurse:Bool):Void {
        {};
        var _indn:GoString = stdgo.strings.Strings.repeat((".  " : GoString), _n);
        stdgo.fmt.Fmt.fprintf(_w, ("%s%s scope %p {\n" : GoString), Go.toInterface(_indn), Go.toInterface(_s._comment), Go.toInterface(Go.asInterface(_s)));
        var _indn1:GoString = _indn + (".  " : GoString);
        for (__0 => _name in _s.names()) {
            stdgo.fmt.Fmt.fprintf(_w, ("%s%s\n" : GoString), Go.toInterface(_indn1), Go.toInterface(_s.lookup(_name)));
        };
        if (_recurse) {
            for (__1 => _s in _s._children) {
                _s.writeTo(_w, _n + (1 : GoInt), _recurse);
            };
        };
        stdgo.fmt.Fmt.fprintf(_w, ("%s}\n" : GoString), Go.toInterface(_indn));
    }
    /**
        // Innermost returns the innermost (child) scope containing
        // pos. If pos is not within any scope, the result is nil.
        // The result is also nil for the Universe scope.
        // The result is guaranteed to be valid only if the type-checked
        // AST has complete position information.
    **/
    @:keep
    static public function innermost( _s:Ref<Scope>, _pos:stdgo.go.token.Token.Pos):Ref<Scope> {
        if (_s._parent == (universe)) {
            for (__0 => _s in _s._children) {
                {
                    var _inner = _s.innermost(_pos);
                    if (_inner != null && ((_inner : Dynamic).__nil__ == null || !(_inner : Dynamic).__nil__)) {
                        return _inner;
                    };
                };
            };
        };
        if (_s.contains(_pos)) {
            for (__1 => _s in _s._children) {
                if (_s.contains(_pos)) {
                    return _s.innermost(_pos);
                };
            };
            return _s;
        };
        return null;
    }
    /**
        // Contains reports whether pos is within the scope's extent.
        // The result is guaranteed to be valid only if the type-checked
        // AST has complete position information.
    **/
    @:keep
    static public function contains( _s:Ref<Scope>, _pos:stdgo.go.token.Token.Pos):Bool {
        return (_s._pos <= _pos) && (_pos < _s._end);
    }
    @:keep
    static public function end( _s:Ref<Scope>):stdgo.go.token.Token.Pos {
        return _s._end;
    }
    /**
        // Pos and End describe the scope's source code extent [pos, end).
        // The results are guaranteed to be valid only if the type-checked
        // AST has complete position information. The extent is undefined
        // for Universe and package scopes.
    **/
    @:keep
    static public function pos( _s:Ref<Scope>):stdgo.go.token.Token.Pos {
        return _s._pos;
    }
    /**
        // squash merges s with its parent scope p by adding all
        // objects of s to p, adding all children of s to the
        // children of p, and removing s from p's children.
        // The function f is called for each object obj in s which
        // has an object alt in p. s should be discarded after
        // having been squashed.
    **/
    @:keep
    static public function _squash( _s:Ref<Scope>, _err:(_obj:Object, _alt:Object) -> Void):Void {
        var _p = _s._parent;
        _assert(_p != null && ((_p : Dynamic).__nil__ == null || !(_p : Dynamic).__nil__));
        for (_name => _obj in _s._elems) {
            _obj = _resolve(_name, _obj);
            _obj._setParent(null);
            {
                var _alt:stdgo.go.types.Types.Object = _p.insert(_obj);
                if (_alt != null) {
                    _err(_obj, _alt);
                };
            };
        };
        var _j:GoInt = (-1 : GoInt);
        for (_i => _ch in _p._children) {
            if (_ch == (_s)) {
                _j = _i;
                break;
            };
        };
        _assert(_j >= (0 : GoInt));
        var _k:GoInt = (_p._children.length) - (1 : GoInt);
        _p._children[(_j : GoInt)] = _p._children[(_k : GoInt)];
        _p._children = (_p._children.__slice__(0, _k) : Slice<Ref<stdgo.go.types.Types.Scope>>);
        _p._children = (_p._children.__append__(..._s._children.__toArray__()));
        _s._children = (null : Slice<Ref<stdgo.go.types.Types.Scope>>);
        _s._elems = (null : GoMap<GoString, stdgo.go.types.Types.Object>);
    }
    @:keep
    static public function _insert( _s:Ref<Scope>, _name:GoString, _obj:Object):Void {
        if (_s._elems == null) {
            _s._elems = ({
                final x = new stdgo.GoMap.GoStringMap<stdgo.go.types.Types.Object>();
                x.__defaultValue__ = () -> (null : stdgo.go.types.Types.Object);
                @:mergeBlock {};
                x;
            } : GoMap<GoString, stdgo.go.types.Types.Object>);
        };
        _s._elems[_name] = _obj;
    }
    /**
        // _InsertLazy is like Insert, but allows deferring construction of the
        // inserted object until it's accessed with Lookup. The Object
        // returned by resolve must have the same name as given to _InsertLazy.
        // If s already contains an alternative object with the same name,
        // _InsertLazy leaves s unchanged and returns false. Otherwise it
        // records the binding and returns true. The object's parent scope
        // will be set to s after resolve is called.
    **/
    @:keep
    static public function __InsertLazy( _s:Ref<Scope>, _name:GoString, _resolve:() -> Object):Bool {
        if (_s._elems[_name] != null) {
            return false;
        };
        _s._insert(_name, Go.asInterface((Go.setRef(({ _parent : _s, _resolve : _resolve } : T_lazyObject)) : Ref<stdgo.go.types.Types.T_lazyObject>)));
        return true;
    }
    /**
        // Insert attempts to insert an object obj into scope s.
        // If s already contains an alternative object alt with
        // the same name, Insert leaves s unchanged and returns alt.
        // Otherwise it inserts obj, sets the object's parent scope
        // if not already set, and returns nil.
    **/
    @:keep
    static public function insert( _s:Ref<Scope>, _obj:Object):Object {
        var _name:GoString = _obj.name();
        {
            var _alt:stdgo.go.types.Types.Object = _s.lookup(_name);
            if (_alt != null) {
                return _alt;
            };
        };
        _s._insert(_name, _obj);
        if (_obj.parent() == null || (_obj.parent() : Dynamic).__nil__) {
            _obj._setParent(_s);
        };
        return (null : stdgo.go.types.Types.Object);
    }
    /**
        // LookupParent follows the parent chain of scopes starting with s until
        // it finds a scope where Lookup(name) returns a non-nil object, and then
        // returns that scope and object. If a valid position pos is provided,
        // only objects that were declared at or before pos are considered.
        // If no such scope and object exists, the result is (nil, nil).
        //
        // Note that obj.Parent() may be different from the returned scope if the
        // object was inserted into the scope and already had a parent at that
        // time (see Insert). This can only happen for dot-imported objects
        // whose scope is the scope of the package that exported them.
    **/
    @:keep
    static public function lookupParent( _s:Ref<Scope>, _name:GoString, _pos:stdgo.go.token.Token.Pos):{ var _0 : Ref<Scope>; var _1 : Object; } {
        Go.cfor(_s != null && ((_s : Dynamic).__nil__ == null || !(_s : Dynamic).__nil__), _s = _s._parent, {
            {
                var _obj:stdgo.go.types.Types.Object = _s.lookup(_name);
                if ((_obj != null) && (!_pos.isValid() || (_obj._scopePos() <= _pos))) {
                    return { _0 : _s, _1 : _obj };
                };
            };
        });
        return { _0 : null, _1 : (null : stdgo.go.types.Types.Object) };
    }
    /**
        // Lookup returns the object in scope s with the given name if such an
        // object exists; otherwise the result is nil.
    **/
    @:keep
    static public function lookup( _s:Ref<Scope>, _name:GoString):Object {
        return _resolve(_name, _s._elems[_name]);
    }
    /**
        // Child returns the i'th child scope for 0 <= i < NumChildren().
    **/
    @:keep
    static public function child( _s:Ref<Scope>, _i:GoInt):Ref<Scope> {
        return _s._children[(_i : GoInt)];
    }
    /**
        // NumChildren returns the number of scopes nested in s.
    **/
    @:keep
    static public function numChildren( _s:Ref<Scope>):GoInt {
        return (_s._children.length);
    }
    /**
        // Names returns the scope's element names in sorted order.
    **/
    @:keep
    static public function names( _s:Ref<Scope>):Slice<GoString> {
        var _names = new Slice<GoString>((_s._elems.length : GoInt).toBasic(), 0).__setString__();
        var _i:GoInt = (0 : GoInt);
        for (_name => _ in _s._elems) {
            _names[(_i : GoInt)] = _name;
            _i++;
        };
        stdgo.sort.Sort.strings(_names);
        return _names;
    }
    /**
        // Len returns the number of scope elements.
    **/
    @:keep
    static public function len( _s:Ref<Scope>):GoInt {
        return (_s._elems.length);
    }
    /**
        // Parent returns the scope's containing (parent) scope.
    **/
    @:keep
    static public function parent( _s:Ref<Scope>):Ref<Scope> {
        return _s._parent;
    }
}
class T_lazyObject_asInterface {
    @:keep
    public dynamic function _setScopePos(_pos:stdgo.go.token.Token.Pos):Void __self__.value._setScopePos(_pos);
    @:keep
    public dynamic function _scopePos():stdgo.go.token.Token.Pos return __self__.value._scopePos();
    @:keep
    public dynamic function _sameId(_pkg:Ref<Package>, _name:GoString):Bool return __self__.value._sameId(_pkg, _name);
    @:keep
    public dynamic function _setParent(_0:Ref<Scope>):Void __self__.value._setParent(_0);
    @:keep
    public dynamic function _setColor(_color:T_color):Void __self__.value._setColor(_color);
    @:keep
    public dynamic function _setOrder(_0:GoUInt32):Void __self__.value._setOrder(_0);
    @:keep
    public dynamic function _setType(_0:Type):Void __self__.value._setType(_0);
    @:keep
    public dynamic function _color():T_color return __self__.value._color();
    @:keep
    public dynamic function _order():GoUInt32 return __self__.value._order();
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:keep
    public dynamic function id():GoString return __self__.value.id();
    @:keep
    public dynamic function exported():Bool return __self__.value.exported();
    @:keep
    public dynamic function type():Type return __self__.value.type();
    @:keep
    public dynamic function name():GoString return __self__.value.name();
    @:keep
    public dynamic function pkg():Ref<Package> return __self__.value.pkg();
    @:keep
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    /**
        // stub implementations so *lazyObject implements Object and we can
        // store them directly into Scope.elems.
    **/
    @:keep
    public dynamic function parent():Ref<Scope> return __self__.value.parent();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_lazyObject>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_lazyObject_asInterface) class T_lazyObject_static_extension {
    @:keep
    static public function _setScopePos( _:Ref<T_lazyObject>, _pos:stdgo.go.token.Token.Pos):Void {
        throw Go.toInterface(("unreachable" : GoString));
    }
    @:keep
    static public function _scopePos( _:Ref<T_lazyObject>):stdgo.go.token.Token.Pos {
        throw Go.toInterface(("unreachable" : GoString));
    }
    @:keep
    static public function _sameId( _:Ref<T_lazyObject>, _pkg:Ref<Package>, _name:GoString):Bool {
        throw Go.toInterface(("unreachable" : GoString));
    }
    @:keep
    static public function _setParent( _:Ref<T_lazyObject>, _0:Ref<Scope>):Void {
        throw Go.toInterface(("unreachable" : GoString));
    }
    @:keep
    static public function _setColor( _:Ref<T_lazyObject>, _color:T_color):Void {
        throw Go.toInterface(("unreachable" : GoString));
    }
    @:keep
    static public function _setOrder( _:Ref<T_lazyObject>, _0:GoUInt32):Void {
        throw Go.toInterface(("unreachable" : GoString));
    }
    @:keep
    static public function _setType( _:Ref<T_lazyObject>, _0:Type):Void {
        throw Go.toInterface(("unreachable" : GoString));
    }
    @:keep
    static public function _color( _:Ref<T_lazyObject>):T_color {
        throw Go.toInterface(("unreachable" : GoString));
    }
    @:keep
    static public function _order( _:Ref<T_lazyObject>):GoUInt32 {
        throw Go.toInterface(("unreachable" : GoString));
    }
    @:keep
    static public function string( _:Ref<T_lazyObject>):GoString {
        throw Go.toInterface(("unreachable" : GoString));
    }
    @:keep
    static public function id( _:Ref<T_lazyObject>):GoString {
        throw Go.toInterface(("unreachable" : GoString));
    }
    @:keep
    static public function exported( _:Ref<T_lazyObject>):Bool {
        throw Go.toInterface(("unreachable" : GoString));
    }
    @:keep
    static public function type( _:Ref<T_lazyObject>):Type {
        throw Go.toInterface(("unreachable" : GoString));
    }
    @:keep
    static public function name( _:Ref<T_lazyObject>):GoString {
        throw Go.toInterface(("unreachable" : GoString));
    }
    @:keep
    static public function pkg( _:Ref<T_lazyObject>):Ref<Package> {
        throw Go.toInterface(("unreachable" : GoString));
    }
    @:keep
    static public function pos( _:Ref<T_lazyObject>):stdgo.go.token.Token.Pos {
        throw Go.toInterface(("unreachable" : GoString));
    }
    /**
        // stub implementations so *lazyObject implements Object and we can
        // store them directly into Scope.elems.
    **/
    @:keep
    static public function parent( _:Ref<T_lazyObject>):Ref<Scope> {
        throw Go.toInterface(("unreachable" : GoString));
    }
}
class Selection_asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    /**
        // Indirect reports whether any pointer indirection was required to get from
        // x to f in x.f.
    **/
    @:keep
    public dynamic function indirect():Bool return __self__.value.indirect();
    /**
        // Index describes the path from x to f in x.f.
        // The last index entry is the field or method index of the type declaring f;
        // either:
        //
        //  1. the list of declared methods of a named type; or
        //  2. the list of methods of an interface type; or
        //  3. the list of fields of a struct type.
        //
        // The earlier index entries are the indices of the embedded fields implicitly
        // traversed to get from (the type of) x to f, starting at embedding depth 0.
    **/
    @:keep
    public dynamic function index():Slice<GoInt> return __self__.value.index();
    /**
        // Type returns the type of x.f, which may be different from the type of f.
        // See Selection for more information.
    **/
    @:keep
    public dynamic function type():Type return __self__.value.type();
    /**
        // Obj returns the object denoted by x.f; a *Var for
        // a field selection, and a *Func in all other cases.
    **/
    @:keep
    public dynamic function obj():Object return __self__.value.obj();
    /**
        // Recv returns the type of x in x.f.
    **/
    @:keep
    public dynamic function recv():Type return __self__.value.recv();
    /**
        // Kind returns the selection kind.
    **/
    @:keep
    public dynamic function kind():SelectionKind return __self__.value.kind();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Selection>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Selection_asInterface) class Selection_static_extension {
    @:keep
    static public function string( _s:Ref<Selection>):GoString {
        return selectionString(_s, null);
    }
    /**
        // Indirect reports whether any pointer indirection was required to get from
        // x to f in x.f.
    **/
    @:keep
    static public function indirect( _s:Ref<Selection>):Bool {
        return _s._indirect;
    }
    /**
        // Index describes the path from x to f in x.f.
        // The last index entry is the field or method index of the type declaring f;
        // either:
        //
        //  1. the list of declared methods of a named type; or
        //  2. the list of methods of an interface type; or
        //  3. the list of fields of a struct type.
        //
        // The earlier index entries are the indices of the embedded fields implicitly
        // traversed to get from (the type of) x to f, starting at embedding depth 0.
    **/
    @:keep
    static public function index( _s:Ref<Selection>):Slice<GoInt> {
        return _s._index;
    }
    /**
        // Type returns the type of x.f, which may be different from the type of f.
        // See Selection for more information.
    **/
    @:keep
    static public function type( _s:Ref<Selection>):Type {
        {
            final __value__ = _s._kind;
            if (__value__ == ((1 : stdgo.go.types.Types.SelectionKind))) {
                var _sig:stdgo.go.types.Types.Signature = ((Go.typeAssert((Go.toInterface((Go.typeAssert((Go.toInterface(_s._obj) : Ref<Func>)) : Ref<Func>)._object._typ) : Ref<Signature>)) : Ref<Signature>) : stdgo.go.types.Types.Signature)?.__copy__();
                var _recv:stdgo.go.types.Types.Var = (_sig._recv : stdgo.go.types.Types.Var)?.__copy__();
                _recv._object._typ = _s._recv;
                _sig._recv = (Go.setRef(_recv) : Ref<stdgo.go.types.Types.Var>);
                return Go.asInterface((Go.setRef(_sig) : Ref<stdgo.go.types.Types.Signature>));
            } else if (__value__ == ((2 : stdgo.go.types.Types.SelectionKind))) {
                var _sig:stdgo.go.types.Types.Signature = ((Go.typeAssert((Go.toInterface((Go.typeAssert((Go.toInterface(_s._obj) : Ref<Func>)) : Ref<Func>)._object._typ) : Ref<Signature>)) : Ref<Signature>) : stdgo.go.types.Types.Signature)?.__copy__();
                var _arg0:stdgo.go.types.Types.Var = (_sig._recv : stdgo.go.types.Types.Var)?.__copy__();
                _sig._recv = null;
                _arg0._object._typ = _s._recv;
                var _params:Slice<Ref<Var>> = (null : Slice<Ref<stdgo.go.types.Types.Var>>);
                if (_sig._params != null && ((_sig._params : Dynamic).__nil__ == null || !(_sig._params : Dynamic).__nil__)) {
                    _params = _sig._params._vars;
                };
                _sig._params = newTuple(...((new Slice<Ref<stdgo.go.types.Types.Var>>(1, 1, (Go.setRef(_arg0) : Ref<stdgo.go.types.Types.Var>)) : Slice<Ref<stdgo.go.types.Types.Var>>).__append__(..._params.__toArray__())).__toArray__());
                return Go.asInterface((Go.setRef(_sig) : Ref<stdgo.go.types.Types.Signature>));
            };
        };
        return _s._obj.type();
    }
    /**
        // Obj returns the object denoted by x.f; a *Var for
        // a field selection, and a *Func in all other cases.
    **/
    @:keep
    static public function obj( _s:Ref<Selection>):Object {
        return _s._obj;
    }
    /**
        // Recv returns the type of x in x.f.
    **/
    @:keep
    static public function recv( _s:Ref<Selection>):Type {
        return _s._recv;
    }
    /**
        // Kind returns the selection kind.
    **/
    @:keep
    static public function kind( _s:Ref<Selection>):SelectionKind {
        return _s._kind;
    }
}
class Signature_asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type return __self__.value.underlying();
    /**
        // Variadic reports whether the signature s is variadic.
    **/
    @:keep
    public dynamic function variadic():Bool return __self__.value.variadic();
    /**
        // Results returns the results of signature s, or nil.
    **/
    @:keep
    public dynamic function results():Ref<Tuple> return __self__.value.results();
    /**
        // Params returns the parameters of signature s, or nil.
    **/
    @:keep
    public dynamic function params():Ref<Tuple> return __self__.value.params();
    /**
        // RecvTypeParams returns the receiver type parameters of signature s, or nil.
    **/
    @:keep
    public dynamic function recvTypeParams():Ref<TypeParamList> return __self__.value.recvTypeParams();
    /**
        // TypeParams returns the type parameters of signature s, or nil.
    **/
    @:keep
    public dynamic function typeParams():Ref<TypeParamList> return __self__.value.typeParams();
    /**
        // Recv returns the receiver of signature s (if a method), or nil if a
        // function. It is ignored when comparing signatures for identity.
        //
        // For an abstract method, Recv returns the enclosing interface either
        // as a *Named or an *Interface. Due to embedding, an interface may
        // contain methods whose receiver type is a different interface.
    **/
    @:keep
    public dynamic function recv():Ref<Var> return __self__.value.recv();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Signature>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Signature_asInterface) class Signature_static_extension {
    @:keep
    static public function string( _t:Ref<Signature>):GoString {
        return typeString(Go.asInterface(_t), null);
    }
    @:keep
    static public function underlying( _t:Ref<Signature>):Type {
        return Go.asInterface(_t);
    }
    /**
        // Variadic reports whether the signature s is variadic.
    **/
    @:keep
    static public function variadic( _s:Ref<Signature>):Bool {
        return _s._variadic;
    }
    /**
        // Results returns the results of signature s, or nil.
    **/
    @:keep
    static public function results( _s:Ref<Signature>):Ref<Tuple> {
        return _s._results;
    }
    /**
        // Params returns the parameters of signature s, or nil.
    **/
    @:keep
    static public function params( _s:Ref<Signature>):Ref<Tuple> {
        return _s._params;
    }
    /**
        // RecvTypeParams returns the receiver type parameters of signature s, or nil.
    **/
    @:keep
    static public function recvTypeParams( _s:Ref<Signature>):Ref<TypeParamList> {
        return _s._rparams;
    }
    /**
        // TypeParams returns the type parameters of signature s, or nil.
    **/
    @:keep
    static public function typeParams( _s:Ref<Signature>):Ref<TypeParamList> {
        return _s._tparams;
    }
    /**
        // Recv returns the receiver of signature s (if a method), or nil if a
        // function. It is ignored when comparing signatures for identity.
        //
        // For an abstract method, Recv returns the enclosing interface either
        // as a *Named or an *Interface. Due to embedding, an interface may
        // contain methods whose receiver type is a different interface.
    **/
    @:keep
    static public function recv( _s:Ref<Signature>):Ref<Var> {
        return _s._recv;
    }
}
class StdSizes_asInterface {
    @:keep
    public dynamic function sizeof(t:Type):GoInt64 return __self__.value.sizeof(t);
    @:keep
    public dynamic function offsetsof(_fields:Slice<Ref<Var>>):Slice<GoInt64> return __self__.value.offsetsof(_fields);
    @:keep
    public dynamic function alignof_(t:Type):GoInt64 return __self__.value.alignof_(t);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<StdSizes>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.StdSizes_asInterface) class StdSizes_static_extension {
    @:keep
    static public function sizeof( _s:Ref<StdSizes>, t:Type):GoInt64 {
        {
            final __type__ = _under(t);
            if (Go.typeEquals((__type__ : Ref<Basic>))) {
                var _t:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                _assert(_isTyped(t));
                var _k:stdgo.go.types.Types.BasicKind = _t._kind;
                if ((_k : GoInt) < (_basicSizes.length)) {
                    {
                        var _s:GoUInt8 = _basicSizes[(_k : GoInt)];
                        if (_s > (0 : GoUInt8)) {
                            return (_s : GoInt64);
                        };
                    };
                };
                if (_k == ((17 : stdgo.go.types.Types.BasicKind))) {
                    return _s.wordSize * (2i64 : GoInt64);
                };
            } else if (Go.typeEquals((__type__ : Ref<Array_>))) {
                var _t:Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                var _n:GoInt64 = _t._len;
                if (_n <= (0i64 : GoInt64)) {
                    return (0i64 : GoInt64);
                };
                var _a:GoInt64 = _s.alignof_(_t._elem);
                var _z:GoInt64 = _s.sizeof(_t._elem);
                return (_align(_z, _a) * (_n - (1i64 : GoInt64))) + _z;
            } else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
                var _t:Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                return _s.wordSize * (3i64 : GoInt64);
            } else if (Go.typeEquals((__type__ : Ref<Struct>))) {
                var _t:Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                var _n:GoInt = _t.numFields();
                if (_n == ((0 : GoInt))) {
                    return (0i64 : GoInt64);
                };
                var _offsets = _s.offsetsof(_t._fields);
                return _offsets[(_n - (1 : GoInt) : GoInt)] + _s.sizeof(_t._fields[(_n - (1 : GoInt) : GoInt)]._object._typ);
            } else if (Go.typeEquals((__type__ : Ref<Interface>))) {
                var _t:Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                _assert(!_isTypeParam(t));
                return _s.wordSize * (2i64 : GoInt64);
            } else if (Go.typeEquals((__type__ : Ref<TypeParam>)) || Go.typeEquals((__type__ : Ref<Union>))) {
                var _t:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                _unreachable();
            };
        };
        return _s.wordSize;
    }
    @:keep
    static public function offsetsof( _s:Ref<StdSizes>, _fields:Slice<Ref<Var>>):Slice<GoInt64> {
        var _offsets = new Slice<GoInt64>((_fields.length : GoInt).toBasic(), 0).__setNumber64__();
        var _o:GoInt64 = (0 : GoInt64);
        for (_i => _f in _fields) {
            var _a:GoInt64 = _s.alignof_(_f._object._typ);
            _o = _align(_o, _a);
            _offsets[(_i : GoInt)] = _o;
            _o = _o + (_s.sizeof(_f._object._typ));
        };
        return _offsets;
    }
    @:keep
    static public function alignof_( _s:Ref<StdSizes>, t:Type):GoInt64 {
        {
            final __type__ = _under(t);
            if (Go.typeEquals((__type__ : Ref<Array_>))) {
                var _t:Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                return _s.alignof_(_t._elem);
            } else if (Go.typeEquals((__type__ : Ref<Struct>))) {
                var _t:Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                if ((_t._fields.length == (0 : GoInt)) && _isSyncAtomicAlign64(t)) {
                    return (8i64 : GoInt64);
                };
                var _max:GoInt64 = (1i64 : GoInt64);
                for (__0 => _f in _t._fields) {
                    {
                        var _a:GoInt64 = _s.alignof_(_f._object._typ);
                        if (_a > _max) {
                            _max = _a;
                        };
                    };
                };
                return _max;
            } else if (Go.typeEquals((__type__ : Ref<Slice_>)) || Go.typeEquals((__type__ : Ref<Interface>))) {
                var _t:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                _assert(!_isTypeParam(t));
                return _s.wordSize;
            } else if (Go.typeEquals((__type__ : Ref<Basic>))) {
                var _t:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                if (_t.info() & (32 : stdgo.go.types.Types.BasicInfo) != ((0 : stdgo.go.types.Types.BasicInfo))) {
                    return _s.wordSize;
                };
            } else if (Go.typeEquals((__type__ : Ref<TypeParam>)) || Go.typeEquals((__type__ : Ref<Union>))) {
                var _t:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                _unreachable();
            };
        };
        var _a:GoInt64 = _s.sizeof(t);
        if (_a < (1i64 : GoInt64)) {
            return (1i64 : GoInt64);
        };
        if (_isComplex(t)) {
            _a = _a / ((2i64 : GoInt64));
        };
        if (_a > _s.maxAlign) {
            return _s.maxAlign;
        };
        return _a;
    }
}
class Slice__asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type return __self__.value.underlying();
    /**
        // Elem returns the element type of slice s.
    **/
    @:keep
    public dynamic function elem():Type return __self__.value.elem();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Slice_>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Slice__asInterface) class Slice__static_extension {
    @:keep
    static public function string( _t:Ref<Slice_>):GoString {
        return typeString(Go.asInterface(_t), null);
    }
    @:keep
    static public function underlying( _t:Ref<Slice_>):Type {
        return Go.asInterface(_t);
    }
    /**
        // Elem returns the element type of slice s.
    **/
    @:keep
    static public function elem( _s:Ref<Slice_>):Type {
        return _s._elem;
    }
}
class Struct_asInterface {
    @:keep
    public dynamic function _markComplete():Void __self__.value._markComplete();
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type return __self__.value.underlying();
    /**
        // Tag returns the i'th field tag for 0 <= i < NumFields().
    **/
    @:keep
    public dynamic function tag(_i:GoInt):GoString return __self__.value.tag(_i);
    /**
        // Field returns the i'th field for 0 <= i < NumFields().
    **/
    @:keep
    public dynamic function field(_i:GoInt):Ref<Var> return __self__.value.field(_i);
    /**
        // NumFields returns the number of fields in the struct (including blank and embedded fields).
    **/
    @:keep
    public dynamic function numFields():GoInt return __self__.value.numFields();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Struct>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Struct_asInterface) class Struct_static_extension {
    @:keep
    static public function _markComplete( _s:Ref<Struct>):Void {
        if (_s._fields == null) {
            _s._fields = new Slice<Ref<stdgo.go.types.Types.Var>>((0 : GoInt).toBasic(), 0);
        };
    }
    @:keep
    static public function string( _t:Ref<Struct>):GoString {
        return typeString(Go.asInterface(_t), null);
    }
    @:keep
    static public function underlying( _t:Ref<Struct>):Type {
        return Go.asInterface(_t);
    }
    /**
        // Tag returns the i'th field tag for 0 <= i < NumFields().
    **/
    @:keep
    static public function tag( _s:Ref<Struct>, _i:GoInt):GoString {
        if (_i < (_s._tags.length)) {
            return _s._tags[(_i : GoInt)];
        };
        return Go.str();
    }
    /**
        // Field returns the i'th field for 0 <= i < NumFields().
    **/
    @:keep
    static public function field( _s:Ref<Struct>, _i:GoInt):Ref<Var> {
        return _s._fields[(_i : GoInt)];
    }
    /**
        // NumFields returns the number of fields in the struct (including blank and embedded fields).
    **/
    @:keep
    static public function numFields( _s:Ref<Struct>):GoInt {
        return (_s._fields.length);
    }
}
class T_subster_asInterface {
    @:keep
    public dynamic function _termlist(_in:Slice<Ref<Term>>):{ var _0 : Slice<Ref<Term>>; var _1 : Bool; } return __self__.value._termlist(_in);
    @:keep
    public dynamic function _typeList(_in:Slice<Type>):{ var _0 : Slice<Type>; var _1 : Bool; } return __self__.value._typeList(_in);
    @:keep
    public dynamic function _funcList(_in:Slice<Ref<Func>>):{ var _0 : Slice<Ref<Func>>; var _1 : Bool; } return __self__.value._funcList(_in);
    @:keep
    public dynamic function _func_(_f:Ref<Func>):Ref<Func> return __self__.value._func_(_f);
    @:keep
    public dynamic function _varList(_in:Slice<Ref<Var>>):{ var _0 : Slice<Ref<Var>>; var _1 : Bool; } return __self__.value._varList(_in);
    @:keep
    public dynamic function _tuple(_t:Ref<Tuple>):Ref<Tuple> return __self__.value._tuple(_t);
    @:keep
    public dynamic function _var_(_v:Ref<Var>):Ref<Var> return __self__.value._var_(_v);
    /**
        // typOrNil is like typ but if the argument is nil it is replaced with Typ[Invalid].
        // A nil type may appear in pathological cases such as type T[P any] []func(_ T([]_))
        // where an array/slice element is accessed before it is set up.
    **/
    @:keep
    public dynamic function _typOrNil(_typ:Type):Type return __self__.value._typOrNil(_typ);
    @:keep
    public dynamic function _typ(_typ:Type):Type return __self__.value._typ(_typ);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_subster>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_subster_asInterface) class T_subster_static_extension {
    @:keep
    static public function _termlist( _subst:Ref<T_subster>, _in:Slice<Ref<Term>>):{ var _0 : Slice<Ref<Term>>; var _1 : Bool; } {
        var _out:Slice<Ref<Term>> = (null : Slice<Ref<stdgo.go.types.Types.Term>>), _copied:Bool = false;
        _out = _in;
        for (_i => _t in _in) {
            {
                var _u:stdgo.go.types.Types.Type = _subst._typ(_t._typ);
                if (Go.toInterface(_u) != (Go.toInterface(_t._typ))) {
                    if (!_copied) {
                        var _new = new Slice<Ref<stdgo.go.types.Types.Term>>((_in.length : GoInt).toBasic(), 0);
                        Go.copySlice(_new, _out);
                        _out = _new;
                        _copied = true;
                    };
                    _out[(_i : GoInt)] = newTerm(_t._tilde, _u);
                };
            };
        };
        return { _0 : _out, _1 : _copied };
    }
    @:keep
    static public function _typeList( _subst:Ref<T_subster>, _in:Slice<Type>):{ var _0 : Slice<Type>; var _1 : Bool; } {
        var _out:Slice<Type> = (null : Slice<stdgo.go.types.Types.Type>), _copied:Bool = false;
        _out = _in;
        for (_i => _t in _in) {
            {
                var _u:stdgo.go.types.Types.Type = _subst._typ(_t);
                if (Go.toInterface(_u) != (Go.toInterface(_t))) {
                    if (!_copied) {
                        var _new = new Slice<stdgo.go.types.Types.Type>((_in.length : GoInt).toBasic(), 0);
                        Go.copySlice(_new, _out);
                        _out = _new;
                        _copied = true;
                    };
                    _out[(_i : GoInt)] = _u;
                };
            };
        };
        return { _0 : _out, _1 : _copied };
    }
    @:keep
    static public function _funcList( _subst:Ref<T_subster>, _in:Slice<Ref<Func>>):{ var _0 : Slice<Ref<Func>>; var _1 : Bool; } {
        var _out:Slice<Ref<Func>> = (null : Slice<Ref<stdgo.go.types.Types.Func>>), _copied:Bool = false;
        _out = _in;
        for (_i => _f in _in) {
            {
                var _g = _subst._func_(_f);
                if (_g != (_f)) {
                    if (!_copied) {
                        var _new = new Slice<Ref<stdgo.go.types.Types.Func>>((_in.length : GoInt).toBasic(), 0);
                        Go.copySlice(_new, _out);
                        _out = _new;
                        _copied = true;
                    };
                    _out[(_i : GoInt)] = _g;
                };
            };
        };
        return { _0 : _out, _1 : _copied };
    }
    @:keep
    static public function _func_( _subst:Ref<T_subster>, _f:Ref<Func>):Ref<Func> {
        if (_f != null && ((_f : Dynamic).__nil__ == null || !(_f : Dynamic).__nil__)) {
            {
                var _typ:stdgo.go.types.Types.Type = _subst._typ(_f._object._typ);
                if (Go.toInterface(_typ) != (Go.toInterface(_f._object._typ))) {
                    return _substFunc(_f, _typ);
                };
            };
        };
        return _f;
    }
    @:keep
    static public function _varList( _subst:Ref<T_subster>, _in:Slice<Ref<Var>>):{ var _0 : Slice<Ref<Var>>; var _1 : Bool; } {
        var _out:Slice<Ref<Var>> = (null : Slice<Ref<stdgo.go.types.Types.Var>>), _copied:Bool = false;
        _out = _in;
        for (_i => _v in _in) {
            {
                var _w = _subst._var_(_v);
                if (_w != (_v)) {
                    if (!_copied) {
                        var _new = new Slice<Ref<stdgo.go.types.Types.Var>>((_in.length : GoInt).toBasic(), 0);
                        Go.copySlice(_new, _out);
                        _out = _new;
                        _copied = true;
                    };
                    _out[(_i : GoInt)] = _w;
                };
            };
        };
        return { _0 : _out, _1 : _copied };
    }
    @:keep
    static public function _tuple( _subst:Ref<T_subster>, _t:Ref<Tuple>):Ref<Tuple> {
        if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
            {
                var __tmp__ = _subst._varList(_t._vars), _vars:Slice<Ref<stdgo.go.types.Types.Var>> = __tmp__._0, _copied:Bool = __tmp__._1;
                if (_copied) {
                    return (Go.setRef(({ _vars : _vars } : Tuple)) : Ref<stdgo.go.types.Types.Tuple>);
                };
            };
        };
        return _t;
    }
    @:keep
    static public function _var_( _subst:Ref<T_subster>, _v:Ref<Var>):Ref<Var> {
        if (_v != null && ((_v : Dynamic).__nil__ == null || !(_v : Dynamic).__nil__)) {
            {
                var _typ:stdgo.go.types.Types.Type = _subst._typ(_v._object._typ);
                if (Go.toInterface(_typ) != (Go.toInterface(_v._object._typ))) {
                    return _substVar(_v, _typ);
                };
            };
        };
        return _v;
    }
    /**
        // typOrNil is like typ but if the argument is nil it is replaced with Typ[Invalid].
        // A nil type may appear in pathological cases such as type T[P any] []func(_ T([]_))
        // where an array/slice element is accessed before it is set up.
    **/
    @:keep
    static public function _typOrNil( _subst:Ref<T_subster>, _typ:Type):Type {
        if (_typ == null) {
            return Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
        };
        return _subst._typ(_typ);
    }
    @:keep
    static public function _typ( _subst:Ref<T_subster>, _typ:Type):Type {
        var __deferstack__:Array<Void -> Void> = [];
        {
            final __type__ = _typ;
            if (__type__ == null) {
                var _t:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
                throw Go.toInterface(("nil typ" : GoString));
            } else if (Go.typeEquals((__type__ : Ref<Basic>))) {
                var _t:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
            } else if (Go.typeEquals((__type__ : Ref<Array_>))) {
                var _t:Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                var _elem:stdgo.go.types.Types.Type = _subst._typOrNil(_t._elem);
                if (Go.toInterface(_elem) != (Go.toInterface(_t._elem))) {
                    return Go.asInterface((Go.setRef(({ _len : _t._len, _elem : _elem } : Array_)) : Ref<stdgo.go.types.Types.Array_>));
                };
            } else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
                var _t:Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                var _elem:stdgo.go.types.Types.Type = _subst._typOrNil(_t._elem);
                if (Go.toInterface(_elem) != (Go.toInterface(_t._elem))) {
                    return Go.asInterface((Go.setRef(({ _elem : _elem } : Slice_)) : Ref<stdgo.go.types.Types.Slice_>));
                };
            } else if (Go.typeEquals((__type__ : Ref<Struct>))) {
                var _t:Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                {
                    var __tmp__ = _subst._varList(_t._fields), _fields:Slice<Ref<stdgo.go.types.Types.Var>> = __tmp__._0, _copied:Bool = __tmp__._1;
                    if (_copied) {
                        var _s = (Go.setRef(({ _fields : _fields, _tags : _t._tags } : Struct)) : Ref<stdgo.go.types.Types.Struct>);
                        _s._markComplete();
                        return Go.asInterface(_s);
                    };
                };
            } else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
                var _t:Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                var _base:stdgo.go.types.Types.Type = _subst._typ(_t._base);
                if (Go.toInterface(_base) != (Go.toInterface(_t._base))) {
                    return Go.asInterface((Go.setRef(({ _base : _base } : Pointer_)) : Ref<stdgo.go.types.Types.Pointer_>));
                };
            } else if (Go.typeEquals((__type__ : Ref<Tuple>))) {
                var _t:Ref<stdgo.go.types.Types.Tuple> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Tuple>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Tuple>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Tuple>) : __type__.__underlying__().value;
                return Go.asInterface(_subst._tuple(_t));
            } else if (Go.typeEquals((__type__ : Ref<Signature>))) {
                var _t:Ref<stdgo.go.types.Types.Signature> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__().value;
                var _recv = _t._recv;
                var _params = _subst._tuple(_t._params);
                var _results = _subst._tuple(_t._results);
                if ((_params != _t._params) || (_results != _t._results)) {
                    return Go.asInterface((Go.setRef(({ _rparams : _t._rparams, _tparams : _t._tparams, _recv : _recv, _params : _params, _results : _results, _variadic : _t._variadic } : Signature)) : Ref<stdgo.go.types.Types.Signature>));
                };
            } else if (Go.typeEquals((__type__ : Ref<Union>))) {
                var _t:Ref<stdgo.go.types.Types.Union> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Union>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__().value;
                var __tmp__ = _subst._termlist(_t._terms), _terms:Slice<Ref<stdgo.go.types.Types.Term>> = __tmp__._0, _copied:Bool = __tmp__._1;
                if (_copied) {
                    return Go.asInterface((Go.setRef((new Union(_terms) : Union)) : Ref<stdgo.go.types.Types.Union>));
                };
            } else if (Go.typeEquals((__type__ : Ref<Interface>))) {
                var _t:Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                var __tmp__ = _subst._funcList(_t._methods), _methods:Slice<Ref<stdgo.go.types.Types.Func>> = __tmp__._0, _mcopied:Bool = __tmp__._1;
                var __tmp__ = _subst._typeList(_t._embeddeds), _embeddeds:Slice<stdgo.go.types.Types.Type> = __tmp__._0, _ecopied:Bool = __tmp__._1;
                if (_mcopied || _ecopied) {
                    var _iface = _subst._check._newInterface();
                    _iface._embeddeds = _embeddeds;
                    _iface._implicit = _t._implicit;
                    _iface._complete = _t._complete;
                    {
                        var __tmp__ = _replaceRecvType(_methods, Go.asInterface(_t), Go.asInterface(_iface));
                        _iface._methods = __tmp__._0;
                    };
                    return Go.asInterface(_iface);
                };
            } else if (Go.typeEquals((__type__ : Ref<Map_>))) {
                var _t:Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                var _key:stdgo.go.types.Types.Type = _subst._typ(_t._key);
                var _elem:stdgo.go.types.Types.Type = _subst._typ(_t._elem);
                if ((Go.toInterface(_key) != Go.toInterface(_t._key)) || (Go.toInterface(_elem) != Go.toInterface(_t._elem))) {
                    return Go.asInterface((Go.setRef(({ _key : _key, _elem : _elem } : Map_)) : Ref<stdgo.go.types.Types.Map_>));
                };
            } else if (Go.typeEquals((__type__ : Ref<Chan>))) {
                var _t:Ref<stdgo.go.types.Types.Chan> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__().value;
                var _elem:stdgo.go.types.Types.Type = _subst._typ(_t._elem);
                if (Go.toInterface(_elem) != (Go.toInterface(_t._elem))) {
                    return Go.asInterface((Go.setRef(({ _dir : _t._dir, _elem : _elem } : Chan)) : Ref<stdgo.go.types.Types.Chan>));
                };
            } else if (Go.typeEquals((__type__ : Ref<Named>))) {
                var _t:Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                var _dump = function(_0:GoString, _1:haxe.Rest<AnyInterface>):Void {};
                if (((_subst._check != null) && ((_subst._check : Dynamic).__nil__ == null || !(_subst._check : Dynamic).__nil__)) && false) {
                    _subst._check._indent++;
                    __deferstack__.unshift(() -> {
                        var a = function():Void {
                            _subst._check._indent--;
                        };
                        a();
                    });
                    _dump = function(_format:GoString, _args:haxe.Rest<AnyInterface>):Void {
                        _subst._check._trace(_subst._pos, _format, ..._args.__toArray__());
                    };
                };
                var _orig = _t.origin();
                var _n:GoInt = _orig.typeParams().len();
                if (_n == ((0 : GoInt))) {
                    _dump((">>> %s is not parameterized" : GoString), Go.toInterface(Go.asInterface(_t)));
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return Go.asInterface(_t);
                    };
                };
                var _newTArgs:Slice<Type> = (null : Slice<stdgo.go.types.Types.Type>);
                if (_t.typeArgs().len() != (_n)) {
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return Go.asInterface(typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)]);
                    };
                };
                _dump((">>> %s already instantiated" : GoString), Go.toInterface(Go.asInterface(_t)));
                for (_i => _targ in _t.typeArgs()._list()) {
                    _dump((">>> %d targ = %s" : GoString), Go.toInterface(_i), Go.toInterface(_targ));
                    var _new_targ:stdgo.go.types.Types.Type = _subst._typ(_targ);
                    if (Go.toInterface(_new_targ) != (Go.toInterface(_targ))) {
                        _dump((">>> substituted %d targ %s => %s" : GoString), Go.toInterface(_i), Go.toInterface(_targ), Go.toInterface(_new_targ));
                        if (_newTArgs == null) {
                            _newTArgs = new Slice<stdgo.go.types.Types.Type>((_n : GoInt).toBasic(), 0);
                            Go.copySlice(_newTArgs, _t.typeArgs()._list());
                        };
                        _newTArgs[(_i : GoInt)] = _new_targ;
                    };
                };
                if (_newTArgs == null) {
                    _dump((">>> nothing to substitute in %s" : GoString), Go.toInterface(Go.asInterface(_t)));
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return Go.asInterface(_t);
                    };
                };
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return _subst._check._instance(_subst._pos, Go.asInterface(_orig), _newTArgs, _subst._expanding, _subst._ctxt);
                };
            } else if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
                var _t:Ref<stdgo.go.types.Types.TypeParam> = __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__().value;
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return _subst._smap._lookup(_t);
                };
            } else {
                var _t:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                _unreachable();
            };
        };
        try {
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _typ;
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return (null : stdgo.go.types.Types.Type);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return (null : stdgo.go.types.Types.Type);
        };
    }
}
class Tuple_asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type return __self__.value.underlying();
    /**
        // At returns the i'th variable of tuple t.
    **/
    @:keep
    public dynamic function at(_i:GoInt):Ref<Var> return __self__.value.at(_i);
    /**
        // Len returns the number variables of tuple t.
    **/
    @:keep
    public dynamic function len():GoInt return __self__.value.len();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Tuple>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Tuple_asInterface) class Tuple_static_extension {
    @:keep
    static public function string( _t:Ref<Tuple>):GoString {
        return typeString(Go.asInterface(_t), null);
    }
    @:keep
    static public function underlying( _t:Ref<Tuple>):Type {
        return Go.asInterface(_t);
    }
    /**
        // At returns the i'th variable of tuple t.
    **/
    @:keep
    static public function at( _t:Ref<Tuple>, _i:GoInt):Ref<Var> {
        return _t._vars[(_i : GoInt)];
    }
    /**
        // Len returns the number variables of tuple t.
    **/
    @:keep
    static public function len( _t:Ref<Tuple>):GoInt {
        if (_t != null && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) {
            return (_t._vars.length);
        };
        return (0 : GoInt);
    }
}
class TypeParamList_asInterface {
    /**
        // list is for internal use where we expect a []*TypeParam.
        // TODO(rfindley): list should probably be eliminated: we can pass around a
        // TypeParamList instead.
    **/
    @:keep
    public dynamic function _list():Slice<Ref<TypeParam>> return __self__.value._list();
    /**
        // At returns the i'th type parameter in the list.
    **/
    @:keep
    public dynamic function at(_i:GoInt):Ref<TypeParam> return __self__.value.at(_i);
    /**
        // Len returns the number of type parameters in the list.
        // It is safe to call on a nil receiver.
    **/
    @:keep
    public dynamic function len():GoInt return __self__.value.len();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<TypeParamList>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.TypeParamList_asInterface) class TypeParamList_static_extension {
    /**
        // list is for internal use where we expect a []*TypeParam.
        // TODO(rfindley): list should probably be eliminated: we can pass around a
        // TypeParamList instead.
    **/
    @:keep
    static public function _list( _l:Ref<TypeParamList>):Slice<Ref<TypeParam>> {
        if (_l == null || (_l : Dynamic).__nil__) {
            return (null : Slice<Ref<stdgo.go.types.Types.TypeParam>>);
        };
        return _l._tparams;
    }
    /**
        // At returns the i'th type parameter in the list.
    **/
    @:keep
    static public function at( _l:Ref<TypeParamList>, _i:GoInt):Ref<TypeParam> {
        return _l._tparams[(_i : GoInt)];
    }
    /**
        // Len returns the number of type parameters in the list.
        // It is safe to call on a nil receiver.
    **/
    @:keep
    static public function len( _l:Ref<TypeParamList>):GoInt {
        return (_l._list().length);
    }
}
class TypeList_asInterface {
    /**
        // list is for internal use where we expect a []Type.
        // TODO(rfindley): list should probably be eliminated: we can pass around a
        // TypeList instead.
    **/
    @:keep
    public dynamic function _list():Slice<Type> return __self__.value._list();
    /**
        // At returns the i'th type in the list.
    **/
    @:keep
    public dynamic function at(_i:GoInt):Type return __self__.value.at(_i);
    /**
        // Len returns the number of types in the list.
        // It is safe to call on a nil receiver.
    **/
    @:keep
    public dynamic function len():GoInt return __self__.value.len();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<TypeList>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.TypeList_asInterface) class TypeList_static_extension {
    /**
        // list is for internal use where we expect a []Type.
        // TODO(rfindley): list should probably be eliminated: we can pass around a
        // TypeList instead.
    **/
    @:keep
    static public function _list( _l:Ref<TypeList>):Slice<Type> {
        if (_l == null || (_l : Dynamic).__nil__) {
            return (null : Slice<stdgo.go.types.Types.Type>);
        };
        return _l._types;
    }
    /**
        // At returns the i'th type in the list.
    **/
    @:keep
    static public function at( _l:Ref<TypeList>, _i:GoInt):Type {
        return _l._types[(_i : GoInt)];
    }
    /**
        // Len returns the number of types in the list.
        // It is safe to call on a nil receiver.
    **/
    @:keep
    static public function len( _l:Ref<TypeList>):GoInt {
        return (_l._list().length);
    }
}
class TypeParam_asInterface {
    /**
        // underIs calls f with the underlying types of the specific type terms
        // of t's constraint and reports whether all calls to f returned true.
        // If there are no specific terms, underIs returns the result of f(nil).
    **/
    @:keep
    public dynamic function _underIs(_f:Type -> Bool):Bool return __self__.value._underIs(_f);
    /**
        // is calls f with the specific type terms of t's constraint and reports whether
        // all calls to f returned true. If there are no specific terms, is
        // returns the result of f(nil).
    **/
    @:keep
    public dynamic function _is(_f:Ref<T_term> -> Bool):Bool return __self__.value._is(_f);
    /**
        // iface returns the constraint interface of t.
    **/
    @:keep
    public dynamic function _iface():Ref<Interface> return __self__.value._iface();
    @:keep
    public dynamic function _cleanup():Void __self__.value._cleanup();
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type return __self__.value.underlying();
    /**
        // SetConstraint sets the type constraint for t.
        //
        // It must be called by users of NewTypeParam after the bound's underlying is
        // fully defined, and before using the type parameter in any way other than to
        // form other types. Once SetConstraint returns the receiver, t is safe for
        // concurrent use.
    **/
    @:keep
    public dynamic function setConstraint(_bound:Type):Void __self__.value.setConstraint(_bound);
    /**
        // Constraint returns the type constraint specified for t.
    **/
    @:keep
    public dynamic function constraint():Type return __self__.value.constraint();
    /**
        // Obj returns the type name for t.
    **/
    @:keep
    public dynamic function obj():Ref<TypeName> return __self__.value.obj();
    /**
        // Index returns the index of the type param within its param list, or -1 if
        // the type parameter has not yet been bound to a type.
    **/
    @:keep
    public dynamic function index():GoInt return __self__.value.index();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<TypeParam>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.TypeParam_asInterface) class TypeParam_static_extension {
    /**
        // underIs calls f with the underlying types of the specific type terms
        // of t's constraint and reports whether all calls to f returned true.
        // If there are no specific terms, underIs returns the result of f(nil).
    **/
    @:keep
    static public function _underIs( _t:Ref<TypeParam>, _f:Type -> Bool):Bool {
        return _t._iface()._typeSet()._underIs(_f);
    }
    /**
        // is calls f with the specific type terms of t's constraint and reports whether
        // all calls to f returned true. If there are no specific terms, is
        // returns the result of f(nil).
    **/
    @:keep
    static public function _is( _t:Ref<TypeParam>, _f:Ref<T_term> -> Bool):Bool {
        return _t._iface()._typeSet()._is(_f);
    }
    /**
        // iface returns the constraint interface of t.
    **/
    @:keep
    static public function _iface( _t:Ref<TypeParam>):Ref<Interface> {
        var _bound:stdgo.go.types.Types.Type = _t._bound;
        var _ityp:Ref<Interface> = (null : Ref<stdgo.go.types.Types.Interface>);
        {
            final __type__ = _under(_bound);
            if (Go.typeEquals((__type__ : Ref<Basic>))) {
                var _u:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                if (_u == (typ[((0 : stdgo.go.types.Types.BasicKind) : GoInt)])) {
                    return (Go.setRef(_emptyInterface) : Ref<stdgo.go.types.Types.Interface>);
                };
            } else if (Go.typeEquals((__type__ : Ref<Interface>))) {
                var _u:Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                if (_isTypeParam(_bound)) {
                    return (Go.setRef(_emptyInterface) : Ref<stdgo.go.types.Types.Interface>);
                };
                _ityp = _u;
            };
        };
        if (_ityp == null || (_ityp : Dynamic).__nil__) {
            _ityp = newInterfaceType((null : Slice<Ref<stdgo.go.types.Types.Func>>), (new Slice<stdgo.go.types.Types.Type>(1, 1, _bound) : Slice<stdgo.go.types.Types.Type>));
            _ityp._implicit = true;
            _t._bound = Go.asInterface(_ityp);
        };
        if (_ityp._tset == null || (_ityp._tset : Dynamic).__nil__) {
            var _pos:stdgo.go.token.Token.Pos = _t._obj._object._pos;
            {
                var __tmp__ = try {
                    { value : (Go.typeAssert((Go.toInterface(_bound) : Ref<Named>)) : Ref<Named>), ok : true };
                } catch(_) {
                    { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
                }, _n = __tmp__.value, __40 = __tmp__.ok;
                if (_n != null && ((_n : Dynamic).__nil__ == null || !(_n : Dynamic).__nil__)) {
                    _pos = _n._obj._object._pos;
                };
            };
            _computeInterfaceTypeSet(_t._check, _pos, _ityp);
        };
        return _ityp;
    }
    @:keep
    static public function _cleanup( _t:Ref<TypeParam>):Void {
        _t._iface();
        _t._check = null;
    }
    @:keep
    static public function string( _t:Ref<TypeParam>):GoString {
        return typeString(Go.asInterface(_t), null);
    }
    @:keep
    static public function underlying( _t:Ref<TypeParam>):Type {
        return Go.asInterface(_t._iface());
    }
    /**
        // SetConstraint sets the type constraint for t.
        //
        // It must be called by users of NewTypeParam after the bound's underlying is
        // fully defined, and before using the type parameter in any way other than to
        // form other types. Once SetConstraint returns the receiver, t is safe for
        // concurrent use.
    **/
    @:keep
    static public function setConstraint( _t:Ref<TypeParam>, _bound:Type):Void {
        if (_bound == null) {
            throw Go.toInterface(("nil constraint" : GoString));
        };
        _t._bound = _bound;
        _t._iface();
    }
    /**
        // Constraint returns the type constraint specified for t.
    **/
    @:keep
    static public function constraint( _t:Ref<TypeParam>):Type {
        return _t._bound;
    }
    /**
        // Obj returns the type name for t.
    **/
    @:keep
    static public function obj( _t:Ref<TypeParam>):Ref<TypeName> {
        return _t._obj;
    }
    /**
        // Index returns the index of the type param within its param list, or -1 if
        // the type parameter has not yet been bound to a type.
    **/
    @:keep
    static public function index( _t:Ref<TypeParam>):GoInt {
        return _t._index;
    }
}
class T__TypeSet_asInterface {
    /**
        // underIs calls f with the underlying types of the specific type terms
        // of s and reports whether all calls to f returned true. If there are
        // no specific terms, underIs returns the result of f(nil).
    **/
    @:keep
    public dynamic function _underIs(_f:Type -> Bool):Bool return __self__.value._underIs(_f);
    /**
        // is calls f with the specific type terms of s and reports whether
        // all calls to f returned true. If there are no specific terms, is
        // returns the result of f(nil).
    **/
    @:keep
    public dynamic function _is(_f:Ref<T_term> -> Bool):Bool return __self__.value._is(_f);
    /**
        // subsetOf reports whether s1 ‚äÜ s2.
    **/
    @:keep
    public dynamic function _subsetOf(_s2:Ref<T__TypeSet>):Bool return __self__.value._subsetOf(_s2);
    /**
        // hasTerms reports whether the type set has specific type terms.
    **/
    @:keep
    public dynamic function _hasTerms():Bool return __self__.value._hasTerms();
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    /**
        // LookupMethod returns the index of and method with matching package and name, or (-1, nil).
    **/
    @:keep
    public dynamic function lookupMethod(_pkg:Ref<Package>, _name:GoString, _foldCase:Bool):{ var _0 : GoInt; var _1 : Ref<Func>; } return __self__.value.lookupMethod(_pkg, _name, _foldCase);
    /**
        // Method returns the i'th method of type set s for 0 <= i < s.NumMethods().
        // The methods are ordered by their unique ID.
    **/
    @:keep
    public dynamic function method(_i:GoInt):Ref<Func> return __self__.value.method(_i);
    /**
        // NumMethods returns the number of methods available.
    **/
    @:keep
    public dynamic function numMethods():GoInt return __self__.value.numMethods();
    /**
        // IsComparable reports whether each type in the set is comparable.
    **/
    @:keep
    public dynamic function isComparable(_seen:GoMap<Type, Bool>):Bool return __self__.value.isComparable(_seen);
    /**
        // IsMethodSet reports whether the interface t is fully described by its method set.
    **/
    @:keep
    public dynamic function isMethodSet():Bool return __self__.value.isMethodSet();
    /**
        // IsAll reports whether type set s is the set of all types (corresponding to the empty interface).
    **/
    @:keep
    public dynamic function isAll():Bool return __self__.value.isAll();
    /**
        // IsEmpty reports whether type set s is the empty set.
    **/
    @:keep
    public dynamic function isEmpty():Bool return __self__.value.isEmpty();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__TypeSet>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T__TypeSet_asInterface) class T__TypeSet_static_extension {
    /**
        // underIs calls f with the underlying types of the specific type terms
        // of s and reports whether all calls to f returned true. If there are
        // no specific terms, underIs returns the result of f(nil).
    **/
    @:keep
    static public function _underIs( _s:Ref<T__TypeSet>, _f:Type -> Bool):Bool {
        if (!_s._hasTerms()) {
            return _f((null : stdgo.go.types.Types.Type));
        };
        for (__0 => _t in _s._terms) {
            _assert(_t._typ != null);
            var _u:stdgo.go.types.Types.Type = _t._typ;
            if (!_t._tilde) {
                _u = _under(_u);
            };
            if (false) {
                _assert(identical(_u, _under(_u)));
            };
            if (!_f(_u)) {
                return false;
            };
        };
        return true;
    }
    /**
        // is calls f with the specific type terms of s and reports whether
        // all calls to f returned true. If there are no specific terms, is
        // returns the result of f(nil).
    **/
    @:keep
    static public function _is( _s:Ref<T__TypeSet>, _f:Ref<T_term> -> Bool):Bool {
        if (!_s._hasTerms()) {
            return _f((null : Ref<stdgo.go.types.Types.T_term>));
        };
        for (__0 => _t in _s._terms) {
            _assert(_t._typ != null);
            if (!_f(_t)) {
                return false;
            };
        };
        return true;
    }
    /**
        // subsetOf reports whether s1 ‚äÜ s2.
    **/
    @:keep
    static public function _subsetOf( _s1:Ref<T__TypeSet>, _s2:Ref<T__TypeSet>):Bool {
        return _s1._terms._subsetOf(_s2._terms);
    }
    /**
        // hasTerms reports whether the type set has specific type terms.
    **/
    @:keep
    static public function _hasTerms( _s:Ref<T__TypeSet>):Bool {
        return !_s._terms._isEmpty() && !_s._terms._isAll();
    }
    @:keep
    static public function string( _s:Ref<T__TypeSet>):GoString {
        if (_s.isEmpty()) {
            return ("‚àÖ" : GoString);
        } else if (_s.isAll()) {
            return ("ùì§" : GoString);
        };
        var _hasMethods:Bool = (_s._methods.length) > (0 : GoInt);
        var _hasTerms:Bool = _s._hasTerms();
        var _buf:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
        _buf.writeByte((123 : GoUInt8));
        if (_s._comparable) {
            _buf.writeString(("comparable" : GoString));
            if (_hasMethods || _hasTerms) {
                _buf.writeString(("; " : GoString));
            };
        };
        for (_i => _m in _s._methods) {
            if (_i > (0 : GoInt)) {
                _buf.writeString(("; " : GoString));
            };
            _buf.writeString((_m.string() : GoString));
        };
        if (_hasMethods && _hasTerms) {
            _buf.writeString(("; " : GoString));
        };
        if (_hasTerms) {
            _buf.writeString((_s._terms.string() : GoString));
        };
        _buf.writeString(("}" : GoString));
        return (_buf.string() : GoString);
    }
    /**
        // LookupMethod returns the index of and method with matching package and name, or (-1, nil).
    **/
    @:keep
    static public function lookupMethod( _s:Ref<T__TypeSet>, _pkg:Ref<Package>, _name:GoString, _foldCase:Bool):{ var _0 : GoInt; var _1 : Ref<Func>; } {
        return _lookupMethod(_s._methods, _pkg, _name, _foldCase);
    }
    /**
        // Method returns the i'th method of type set s for 0 <= i < s.NumMethods().
        // The methods are ordered by their unique ID.
    **/
    @:keep
    static public function method( _s:Ref<T__TypeSet>, _i:GoInt):Ref<Func> {
        return _s._methods[(_i : GoInt)];
    }
    /**
        // NumMethods returns the number of methods available.
    **/
    @:keep
    static public function numMethods( _s:Ref<T__TypeSet>):GoInt {
        return (_s._methods.length);
    }
    /**
        // IsComparable reports whether each type in the set is comparable.
    **/
    @:keep
    static public function isComparable( _s:Ref<T__TypeSet>, _seen:GoMap<Type, Bool>):Bool {
        if (_s._terms._isAll()) {
            return _s._comparable;
        };
        return _s._is(function(_t:Ref<T_term>):Bool {
            return ((_t != null) && ((_t : Dynamic).__nil__ == null || !(_t : Dynamic).__nil__)) && _comparable(_t._typ, false, _seen, null);
        });
    }
    /**
        // IsMethodSet reports whether the interface t is fully described by its method set.
    **/
    @:keep
    static public function isMethodSet( _s:Ref<T__TypeSet>):Bool {
        return !_s._comparable && _s._terms._isAll();
    }
    /**
        // IsAll reports whether type set s is the set of all types (corresponding to the empty interface).
    **/
    @:keep
    static public function isAll( _s:Ref<T__TypeSet>):Bool {
        return _s.isMethodSet() && (_s._methods.length == (0 : GoInt));
    }
    /**
        // IsEmpty reports whether type set s is the empty set.
    **/
    @:keep
    static public function isEmpty( _s:Ref<T__TypeSet>):Bool {
        return _s._terms._isEmpty();
    }
}
class T_typeWriter_asInterface {
    @:keep
    public dynamic function _signature(_sig:Ref<Signature>):Void __self__.value._signature(_sig);
    @:keep
    public dynamic function _tuple(_tup:Ref<Tuple>, _variadic:Bool):Void __self__.value._tuple(_tup, _variadic);
    @:keep
    public dynamic function _typeName(_obj:Ref<TypeName>):Void __self__.value._typeName(_obj);
    @:keep
    public dynamic function _tParamList(_list:Slice<Ref<TypeParam>>):Void __self__.value._tParamList(_list);
    @:keep
    public dynamic function _typeList(_list:Slice<Type>):Void __self__.value._typeList(_list);
    /**
        // typeSet writes a canonical hash for an interface type set.
    **/
    @:keep
    public dynamic function _typeSet(_s:Ref<T__TypeSet>):Void __self__.value._typeSet(_s);
    @:keep
    public dynamic function _typ(_typ:Type):Void __self__.value._typ(_typ);
    @:keep
    public dynamic function _error(_msg:GoString):Void __self__.value._error(_msg);
    @:keep
    public dynamic function _string(_s:GoString):Void __self__.value._string(_s);
    @:keep
    public dynamic function _byte(_b:GoByte):Void __self__.value._byte(_b);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_typeWriter>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_typeWriter_asInterface) class T_typeWriter_static_extension {
    @:keep
    static public function _signature( _w:Ref<T_typeWriter>, _sig:Ref<Signature>):Void {
        var __deferstack__:Array<Void -> Void> = [];
        try {
            if (_sig.typeParams().len() != ((0 : GoInt))) {
                if (_w._ctxt != null && ((_w._ctxt : Dynamic).__nil__ == null || !(_w._ctxt : Dynamic).__nil__)) {
                    _assert(_w._tparams == null || (_w._tparams : Dynamic).__nil__);
                    _w._tparams = _sig.typeParams();
                    __deferstack__.unshift(() -> {
                        var a = function():Void {
                            _w._tparams = null;
                        };
                        a();
                    });
                };
                _w._tParamList(_sig.typeParams()._list());
            };
            _w._tuple(_sig._params, _sig._variadic);
            var _n:GoInt = _sig._results.len();
            if (_n == ((0 : GoInt))) {
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return;
                };
            };
            _w._byte((32 : GoUInt8));
            if ((_n == (1 : GoInt)) && (((_w._ctxt != null) && ((_w._ctxt : Dynamic).__nil__ == null || !(_w._ctxt : Dynamic).__nil__)) || (_sig._results._vars[(0 : GoInt)]._object._name == Go.str()))) {
                _w._typ(_sig._results._vars[(0 : GoInt)]._object._typ);
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return;
                };
            };
            _w._tuple(_sig._results, false);
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return;
        };
    }
    @:keep
    static public function _tuple( _w:Ref<T_typeWriter>, _tup:Ref<Tuple>, _variadic:Bool):Void {
        _w._byte((40 : GoUInt8));
        if (_tup != null && ((_tup : Dynamic).__nil__ == null || !(_tup : Dynamic).__nil__)) {
            for (_i => _v in _tup._vars) {
                if (_i > (0 : GoInt)) {
                    _w._byte((44 : GoUInt8));
                };
                if (((_w._ctxt == null) || (_w._ctxt : Dynamic).__nil__ && (_v._object._name != Go.str())) && _w._paramNames) {
                    _w._string(_v._object._name);
                    _w._byte((32 : GoUInt8));
                };
                var _typ:stdgo.go.types.Types.Type = _v._object._typ;
                if (_variadic && (_i == (_tup._vars.length - (1 : GoInt)))) {
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_typ) : Ref<Slice_>)) : Ref<Slice_>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.types.Types.Slice_>), ok : false };
                        }, _s = __tmp__.value, _ok = __tmp__.ok;
                        if (_ok) {
                            _w._string(("..." : GoString));
                            _typ = _s._elem;
                        } else {
                            {
                                var __tmp__ = try {
                                    { value : (Go.typeAssert((Go.toInterface(_under(_typ)) : Ref<Basic>)) : Ref<Basic>), ok : true };
                                } catch(_) {
                                    { value : (null : Ref<stdgo.go.types.Types.Basic>), ok : false };
                                }, _t = __tmp__.value, __0 = __tmp__.ok;
                                if (((_t == null) || (_t : Dynamic).__nil__) || (_t._kind != (17 : stdgo.go.types.Types.BasicKind))) {
                                    _w._error(("expected string type" : GoString));
                                    continue;
                                };
                            };
                            _w._typ(_typ);
                            _w._string(("..." : GoString));
                            continue;
                        };
                    };
                };
                _w._typ(_typ);
            };
        };
        _w._byte((41 : GoUInt8));
    }
    @:keep
    static public function _typeName( _w:Ref<T_typeWriter>, _obj:Ref<TypeName>):Void {
        _w._string(_packagePrefix(_obj._object._pkg, _w._qf));
        _w._string(_obj._object._name);
    }
    @:keep
    static public function _tParamList( _w:Ref<T_typeWriter>, _list:Slice<Ref<TypeParam>>):Void {
        _w._byte((91 : GoUInt8));
        var _prev:Type = (null : stdgo.go.types.Types.Type);
        for (_i => _tpar in _list) {
            if (_tpar == null || (_tpar : Dynamic).__nil__) {
                _w._error(("nil type parameter" : GoString));
                continue;
            };
            if (_i > (0 : GoInt)) {
                if (Go.toInterface(_tpar._bound) != (Go.toInterface(_prev))) {
                    _w._byte((32 : GoUInt8));
                    _w._typ(_prev);
                };
                _w._byte((44 : GoUInt8));
            };
            _prev = _tpar._bound;
            _w._typ(Go.asInterface(_tpar));
        };
        if (_prev != null) {
            _w._byte((32 : GoUInt8));
            _w._typ(_prev);
        };
        _w._byte((93 : GoUInt8));
    }
    @:keep
    static public function _typeList( _w:Ref<T_typeWriter>, _list:Slice<Type>):Void {
        _w._byte((91 : GoUInt8));
        for (_i => _typ in _list) {
            if (_i > (0 : GoInt)) {
                _w._byte((44 : GoUInt8));
            };
            _w._typ(_typ);
        };
        _w._byte((93 : GoUInt8));
    }
    /**
        // typeSet writes a canonical hash for an interface type set.
    **/
    @:keep
    static public function _typeSet( _w:Ref<T_typeWriter>, _s:Ref<T__TypeSet>):Void {
        _assert(_w._ctxt != null && ((_w._ctxt : Dynamic).__nil__ == null || !(_w._ctxt : Dynamic).__nil__));
        var _first:Bool = true;
        for (__0 => _m in _s._methods) {
            if (!_first) {
                _w._byte((59 : GoUInt8));
            };
            _first = false;
            _w._string(_m._object._name);
            _w._signature((Go.typeAssert((Go.toInterface(_m._object._typ) : Ref<Signature>)) : Ref<Signature>));
        };
        if (_s._terms._isAll()) {} else if (_s._terms._isEmpty()) {
            _w._string((_s._terms.string() : GoString));
        } else {
            var _termHashes:Slice<GoString> = (null : Slice<GoString>);
            for (__1 => T_term_static_extension in _s._terms) {
                var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
                if (T_term_static_extension._tilde) {
                    _buf.writeByte((126 : GoUInt8));
                };
                _newTypeHasher((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>), _w._ctxt)._typ(T_term_static_extension._typ);
                _termHashes = (_termHashes.__append__((_buf.string() : GoString)));
            };
            stdgo.sort.Sort.strings(_termHashes);
            if (!_first) {
                _w._byte((59 : GoUInt8));
            };
            _w._string(stdgo.strings.Strings.join(_termHashes, ("|" : GoString)));
        };
    }
    @:keep
    static public function _typ( _w:Ref<T_typeWriter>, _typ:Type):Void {
        var __deferstack__:Array<Void -> Void> = [];
        try {
            if (_w._seen[_typ]) {
                _w._error(("cycle to " : GoString) + _goTypeName(_typ));
                return;
            };
            _w._seen[_typ] = true;
            {
                var _a0 = _w._seen;
                var _a1 = _typ;
                __deferstack__.unshift(() -> if (_a0 != null) _a0.remove(_a1));
            };
            {
                final __type__ = _typ;
                {
                    var __bool__ = true;
                    while (__bool__) {
                        __bool__ = false;
                        if (__type__ == null) {
                            var _t:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
                            _w._error(("nil" : GoString));
                        } else if (Go.typeEquals((__type__ : Ref<Basic>))) {
                            var _t:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                            if (stdgo.go.token.Token.isExported(_t._name)) {
                                {
                                    var __tmp__ = try {
                                        { value : (Go.typeAssert((Go.toInterface(unsafe._scope.lookup(_t._name)) : Ref<TypeName>)) : Ref<TypeName>), ok : true };
                                    } catch(_) {
                                        { value : (null : Ref<stdgo.go.types.Types.TypeName>), ok : false };
                                    }, _obj = __tmp__.value, __0 = __tmp__.ok;
                                    if (_obj != null && ((_obj : Dynamic).__nil__ == null || !(_obj : Dynamic).__nil__)) {
                                        _w._typeName(_obj);
                                        break;
                                    };
                                };
                            };
                            _w._string(_t._name);
                        } else if (Go.typeEquals((__type__ : Ref<Array_>))) {
                            var _t:Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                            _w._byte((91 : GoUInt8));
                            _w._string(stdgo.strconv.Strconv.formatInt(_t._len, (10 : GoInt)));
                            _w._byte((93 : GoUInt8));
                            _w._typ(_t._elem);
                        } else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
                            var _t:Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                            _w._string(("[]" : GoString));
                            _w._typ(_t._elem);
                        } else if (Go.typeEquals((__type__ : Ref<Struct>))) {
                            var _t:Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                            _w._string(("struct{" : GoString));
                            for (_i => _f in _t._fields) {
                                if (_i > (0 : GoInt)) {
                                    _w._byte((59 : GoUInt8));
                                };
                                var _pkgAnnotate:Bool = false;
                                if (((_w._qf == null) && _w._pkgInfo) && !stdgo.go.token.Token.isExported(_f._object._name)) {
                                    _pkgAnnotate = true;
                                    _w._pkgInfo = false;
                                };
                                if (!_f._embedded) {
                                    _w._string(_f._object._name);
                                    _w._byte((32 : GoUInt8));
                                };
                                _w._typ(_f._object._typ);
                                if (_pkgAnnotate) {
                                    _w._string((" /* package " : GoString));
                                    _w._string(_f._object._pkg.path());
                                    _w._string((" */ " : GoString));
                                };
                                {
                                    var _tag:GoString = _t.tag(_i);
                                    if (_tag != (Go.str())) {
                                        _w._byte((32 : GoUInt8));
                                        _w._string(stdgo.strconv.Strconv.quote(_tag));
                                    };
                                };
                            };
                            _w._byte((125 : GoUInt8));
                        } else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
                            var _t:Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                            _w._byte((42 : GoUInt8));
                            _w._typ(_t._base);
                        } else if (Go.typeEquals((__type__ : Ref<Tuple>))) {
                            var _t:Ref<stdgo.go.types.Types.Tuple> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Tuple>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Tuple>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Tuple>) : __type__.__underlying__().value;
                            _w._tuple(_t, false);
                        } else if (Go.typeEquals((__type__ : Ref<Signature>))) {
                            var _t:Ref<stdgo.go.types.Types.Signature> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__().value;
                            _w._string(("func" : GoString));
                            _w._signature(_t);
                        } else if (Go.typeEquals((__type__ : Ref<Union>))) {
                            var _t:Ref<stdgo.go.types.Types.Union> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Union>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Union>) : __type__.__underlying__().value;
                            if (_t.len() == ((0 : GoInt))) {
                                _w._error(("empty union" : GoString));
                                break;
                            };
                            for (_i => _t in _t._terms) {
                                if (_i > (0 : GoInt)) {
                                    _w._string((" | " : GoString));
                                };
                                if (_t._tilde) {
                                    _w._byte((126 : GoUInt8));
                                };
                                _w._typ(_t._typ);
                            };
                        } else if (Go.typeEquals((__type__ : Ref<Interface>))) {
                            var _t:Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                            if (_w._ctxt == null || (_w._ctxt : Dynamic).__nil__) {
                                if (Go.toInterface(Go.asInterface(_t)) == (Go.toInterface(_universeAny.type()))) {
                                    _w._string(("any" : GoString));
                                    break;
                                };
                                if (Go.toInterface(Go.asInterface(_t)) == (Go.toInterface((Go.typeAssert((Go.toInterface(_universeComparable.type()) : Ref<Named>)) : Ref<Named>)._underlying))) {
                                    _w._string(("interface{comparable}" : GoString));
                                    break;
                                };
                            };
                            if (_t._implicit) {
                                if ((_t._methods.length == (0 : GoInt)) && (_t._embeddeds.length == (1 : GoInt))) {
                                    _w._typ(_t._embeddeds[(0 : GoInt)]);
                                    break;
                                };
                                _w._string(("/* implicit */ " : GoString));
                            };
                            _w._string(("interface{" : GoString));
                            var _first:Bool = true;
                            if (_w._ctxt != null && ((_w._ctxt : Dynamic).__nil__ == null || !(_w._ctxt : Dynamic).__nil__)) {
                                _w._typeSet(_t._typeSet());
                            } else {
                                for (__41 => _m in _t._methods) {
                                    if (!_first) {
                                        _w._byte((59 : GoUInt8));
                                    };
                                    _first = false;
                                    _w._string(_m._object._name);
                                    _w._signature((Go.typeAssert((Go.toInterface(_m._object._typ) : Ref<Signature>)) : Ref<Signature>));
                                };
                                for (__50 => _typ in _t._embeddeds) {
                                    if (!_first) {
                                        _w._byte((59 : GoUInt8));
                                    };
                                    _first = false;
                                    _w._typ(_typ);
                                };
                            };
                            _w._byte((125 : GoUInt8));
                        } else if (Go.typeEquals((__type__ : Ref<Map_>))) {
                            var _t:Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                            _w._string(("map[" : GoString));
                            _w._typ(_t._key);
                            _w._byte((93 : GoUInt8));
                            _w._typ(_t._elem);
                        } else if (Go.typeEquals((__type__ : Ref<Chan>))) {
                            var _t:Ref<stdgo.go.types.Types.Chan> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__().value;
                            var _s:GoString = ("" : GoString);
                            var _parens:Bool = false;
                            {
                                final __value__ = _t._dir;
                                if (__value__ == ((0 : stdgo.go.types.Types.ChanDir))) {
                                    _s = ("chan " : GoString);
                                    {
                                        var __tmp__ = try {
                                            { value : (Go.typeAssert((Go.toInterface(_t._elem) : Ref<Chan>)) : Ref<Chan>), ok : true };
                                        } catch(_) {
                                            { value : (null : Ref<stdgo.go.types.Types.Chan>), ok : false };
                                        }, _c = __tmp__.value, __59 = __tmp__.ok;
                                        if (((_c != null) && ((_c : Dynamic).__nil__ == null || !(_c : Dynamic).__nil__)) && (_c._dir == (2 : stdgo.go.types.Types.ChanDir))) {
                                            _parens = true;
                                        };
                                    };
                                } else if (__value__ == ((1 : stdgo.go.types.Types.ChanDir))) {
                                    _s = ("chan<- " : GoString);
                                } else if (__value__ == ((2 : stdgo.go.types.Types.ChanDir))) {
                                    _s = ("<-chan " : GoString);
                                } else {
                                    _w._error(("unknown channel direction" : GoString));
                                };
                            };
                            _w._string(_s);
                            if (_parens) {
                                _w._byte((40 : GoUInt8));
                            };
                            _w._typ(_t._elem);
                            if (_parens) {
                                _w._byte((41 : GoUInt8));
                            };
                        } else if (Go.typeEquals((__type__ : Ref<Named>))) {
                            var _t:Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                            if (_w._ctxt != null && ((_w._ctxt : Dynamic).__nil__ == null || !(_w._ctxt : Dynamic).__nil__)) {
                                _w._string(stdgo.strconv.Strconv.itoa(_w._ctxt._getID(Go.asInterface(_t))));
                            };
                            _w._typeName(_t._obj);
                            if (_t._inst != null && ((_t._inst : Dynamic).__nil__ == null || !(_t._inst : Dynamic).__nil__)) {
                                _w._typeList(_t._inst._targs._list());
                            } else if ((_w._ctxt == null) || (_w._ctxt : Dynamic).__nil__ && (_t.typeParams().len() != (0 : GoInt))) {
                                _w._tParamList(_t.typeParams()._list());
                            };
                        } else if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
                            var _t:Ref<stdgo.go.types.Types.TypeParam> = __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__().value;
                            if (_t._obj == null || (_t._obj : Dynamic).__nil__) {
                                _w._error(("unnamed type parameter" : GoString));
                                break;
                            };
                            {
                                var _i:GoInt = _tparamIndex(_w._tparams._list(), _t);
                                if (_i >= (0 : GoInt)) {
                                    _w._string(stdgo.fmt.Fmt.sprintf(("$$%d" : GoString), Go.toInterface(_i)));
                                } else {
                                    _w._string(_t._obj._object._name);
                                    if (_w._tpSubscripts || ((_w._ctxt != null) && ((_w._ctxt : Dynamic).__nil__ == null || !(_w._ctxt : Dynamic).__nil__))) {
                                        _w._string(_subscript(_t._id));
                                    };
                                };
                            };
                        } else {
                            var _t:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                            _w._string((_t.string() : GoString));
                        };
                        break;
                    };
                };
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return;
        };
    }
    @:keep
    static public function _error( _w:Ref<T_typeWriter>, _msg:GoString):Void {
        if (_w._ctxt != null && ((_w._ctxt : Dynamic).__nil__ == null || !(_w._ctxt : Dynamic).__nil__)) {
            throw Go.toInterface(_msg);
        };
        _w._buf.writeString((("<" : GoString) + _msg) + (">" : GoString));
    }
    @:keep
    static public function _string( _w:Ref<T_typeWriter>, _s:GoString):Void {
        _w._buf.writeString(_s);
    }
    @:keep
    static public function _byte( _w:Ref<T_typeWriter>, _b:GoByte):Void {
        if (_w._ctxt != null && ((_w._ctxt : Dynamic).__nil__ == null || !(_w._ctxt : Dynamic).__nil__)) {
            if (_b == ((32 : GoUInt8))) {
                _b = (35 : GoUInt8);
            };
            _w._buf.writeByte(_b);
            return;
        };
        _w._buf.writeByte(_b);
        if ((_b == (44 : GoUInt8)) || (_b == (59 : GoUInt8))) {
            _w._buf.writeByte((32 : GoUInt8));
        };
    }
}
class T_term_asInterface {
    /**
        // disjoint reports whether x ‚à© y == ‚àÖ.
        // x.typ and y.typ must not be nil.
    **/
    @:keep
    public dynamic function _disjoint(_y:Ref<T_term>):Bool return __self__.value._disjoint(_y);
    /**
        // subsetOf reports whether x ‚äÜ y.
    **/
    @:keep
    public dynamic function _subsetOf(_y:Ref<T_term>):Bool return __self__.value._subsetOf(_y);
    /**
        // includes reports whether t ‚àà x.
    **/
    @:keep
    public dynamic function _includes(_t:Type):Bool return __self__.value._includes(_t);
    /**
        // intersect returns the intersection x ‚à© y.
    **/
    @:keep
    public dynamic function _intersect(_y:Ref<T_term>):Ref<T_term> return __self__.value._intersect(_y);
    /**
        // union returns the union x ‚à™ y: zero, one, or two non-nil terms.
    **/
    @:keep
    public dynamic function _union(_y:Ref<T_term>):{ var _0 : Ref<T_term>; var _1 : Ref<T_term>; } return __self__.value._union(_y);
    /**
        // equal reports whether x and y represent the same type set.
    **/
    @:keep
    public dynamic function _equal(_y:Ref<T_term>):Bool return __self__.value._equal(_y);
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_term>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_term_asInterface) class T_term_static_extension {
    /**
        // disjoint reports whether x ‚à© y == ‚àÖ.
        // x.typ and y.typ must not be nil.
    **/
    @:keep
    static public function _disjoint( _x:Ref<T_term>, _y:Ref<T_term>):Bool {
        if (false && ((_x._typ == null) || (_y._typ == null))) {
            throw Go.toInterface(("invalid argument(s)" : GoString));
        };
        var _ux:stdgo.go.types.Types.Type = _x._typ;
        if (_y._tilde) {
            _ux = _under(_ux);
        };
        var _uy:stdgo.go.types.Types.Type = _y._typ;
        if (_x._tilde) {
            _uy = _under(_uy);
        };
        return !identical(_ux, _uy);
    }
    /**
        // subsetOf reports whether x ‚äÜ y.
    **/
    @:keep
    static public function _subsetOf( _x:Ref<T_term>, _y:Ref<T_term>):Bool {
        if (_x == null || (_x : Dynamic).__nil__) {
            return true;
        } else if (_y == null || (_y : Dynamic).__nil__) {
            return false;
        } else if (_y._typ == null) {
            return true;
        } else if (_x._typ == null) {
            return false;
        };
        if (_x._disjoint(_y)) {
            return false;
        };
        return !_x._tilde || _y._tilde;
    }
    /**
        // includes reports whether t ‚àà x.
    **/
    @:keep
    static public function _includes( _x:Ref<T_term>, _t:Type):Bool {
        if (_x == null || (_x : Dynamic).__nil__) {
            return false;
        } else if (_x._typ == null) {
            return true;
        };
        var _u:stdgo.go.types.Types.Type = _t;
        if (_x._tilde) {
            _u = _under(_u);
        };
        return identical(_x._typ, _u);
    }
    /**
        // intersect returns the intersection x ‚à© y.
    **/
    @:keep
    static public function _intersect( _x:Ref<T_term>, _y:Ref<T_term>):Ref<T_term> {
        if (((_x == null) || (_x : Dynamic).__nil__) || ((_y == null) || (_y : Dynamic).__nil__)) {
            return (null : Ref<stdgo.go.types.Types.T_term>);
        } else if (_x._typ == null) {
            return _y;
        } else if (_y._typ == null) {
            return _x;
        };
        if (_x._disjoint(_y)) {
            return (null : Ref<stdgo.go.types.Types.T_term>);
        };
        if (!_x._tilde || _y._tilde) {
            return _x;
        };
        return _y;
    }
    /**
        // union returns the union x ‚à™ y: zero, one, or two non-nil terms.
    **/
    @:keep
    static public function _union( _x:Ref<T_term>, _y:Ref<T_term>):{ var _0 : Ref<T_term>; var _1 : Ref<T_term>; } {
        var _0:Ref<T_term> = (null : Ref<stdgo.go.types.Types.T_term>), _1:Ref<T_term> = (null : Ref<stdgo.go.types.Types.T_term>);
        if ((_x == null) || (_x : Dynamic).__nil__ && (_y == null) || (_y : Dynamic).__nil__) {
            return { _0 : (null : Ref<stdgo.go.types.Types.T_term>), _1 : (null : Ref<stdgo.go.types.Types.T_term>) };
        } else if (_x == null || (_x : Dynamic).__nil__) {
            return { _0 : _y, _1 : (null : Ref<stdgo.go.types.Types.T_term>) };
        } else if (_y == null || (_y : Dynamic).__nil__) {
            return { _0 : _x, _1 : (null : Ref<stdgo.go.types.Types.T_term>) };
        } else if (_x._typ == null) {
            return { _0 : _x, _1 : (null : Ref<stdgo.go.types.Types.T_term>) };
        } else if (_y._typ == null) {
            return { _0 : _y, _1 : (null : Ref<stdgo.go.types.Types.T_term>) };
        };
        if (_x._disjoint(_y)) {
            return { _0 : _x, _1 : _y };
        };
        if (_x._tilde || !_y._tilde) {
            return { _0 : _x, _1 : (null : Ref<stdgo.go.types.Types.T_term>) };
        };
        return { _0 : _y, _1 : (null : Ref<stdgo.go.types.Types.T_term>) };
    }
    /**
        // equal reports whether x and y represent the same type set.
    **/
    @:keep
    static public function _equal( _x:Ref<T_term>, _y:Ref<T_term>):Bool {
        if (((_x == null) || (_x : Dynamic).__nil__) || ((_y == null) || (_y : Dynamic).__nil__)) {
            return _x == (_y);
        } else if ((_x._typ == null) || (_y._typ == null)) {
            return Go.toInterface(_x._typ) == (Go.toInterface(_y._typ));
        };
        return (_x._tilde == _y._tilde) && identical(_x._typ, _y._typ);
    }
    @:keep
    static public function string( _x:Ref<T_term>):GoString {
        if (_x == null || (_x : Dynamic).__nil__) {
            return ("‚àÖ" : GoString);
        } else if (_x._typ == null) {
            return ("ùì§" : GoString);
        } else if (_x._tilde) {
            return ("~" : GoString) + (_x._typ.string() : GoString);
        } else {
            return (_x._typ.string() : GoString);
        };
    }
}
class T_unifier_asInterface {
    /**
        // nify implements the core unification algorithm which is an
        // adapted version of Checker.identical. For changes to that
        // code the corresponding changes should be made here.
        // Must not be called directly from outside the unifier.
    **/
    @:keep
    public dynamic function _nify(_x:Type, _y:Type, _p:Ref<T_ifacePair>):Bool return __self__.value._nify(_x, _y, _p);
    @:keep
    public dynamic function _nifyEq(_x:Type, _y:Type, _p:Ref<T_ifacePair>):Bool return __self__.value._nifyEq(_x, _y, _p);
    /**
        // join unifies the i'th type parameter of x with the j'th type parameter of y.
        // If both type parameters already have a type associated with them and they are
        // not joined, join fails and returns false.
    **/
    @:keep
    public dynamic function _join(_i:GoInt, _j:GoInt):Bool return __self__.value._join(_i, _j);
    @:keep
    public dynamic function _tracef(_format:GoString, _args:haxe.Rest<AnyInterface>):Void __self__.value._tracef(_format, ..._args);
    /**
        // unify attempts to unify x and y and reports whether it succeeded.
    **/
    @:keep
    public dynamic function _unify(_x:Type, _y:Type):Bool return __self__.value._unify(_x, _y);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_unifier>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_unifier_asInterface) class T_unifier_static_extension {
    /**
        // nify implements the core unification algorithm which is an
        // adapted version of Checker.identical. For changes to that
        // code the corresponding changes should be made here.
        // Must not be called directly from outside the unifier.
    **/
    @:keep
    static public function _nify( _u:Ref<T_unifier>, _x:Type, _y:Type, _p:Ref<T_ifacePair>):Bool {
        var __deferstack__:Array<Void -> Void> = [];
        var _result:Bool = false;
        try {
            if (false) {
                _u._tracef(("%s ‚â° %s" : GoString), Go.toInterface(_x), Go.toInterface(_y));
            };
            if (_u._depth >= (50 : GoInt)) {
                if (false) {
                    _u._tracef(("depth %d >= %d" : GoString), Go.toInterface(_u._depth), Go.toInterface((50 : GoInt)));
                };
                if (true) {
                    throw Go.toInterface(("unification reached recursion depth limit" : GoString));
                };
                return false;
            };
            _u._depth++;
            __deferstack__.unshift(() -> {
                var a = function():Void {
                    _u._depth--;
                    if (false && !_result) {
                        _u._tracef(("%s ‚â¢ %s" : GoString), Go.toInterface(_x), Go.toInterface(_y));
                    };
                };
                a();
            });
            if (!_u._exact) {
                {
                    var __tmp__ = try {
                        { value : (Go.typeAssert((Go.toInterface(_x) : Ref<Named>)) : Ref<Named>), ok : true };
                    } catch(_) {
                        { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
                    }, _nx = __tmp__.value, __0 = __tmp__.ok;
                    if (((_nx != null) && ((_nx : Dynamic).__nil__ == null || !(_nx : Dynamic).__nil__)) && !_hasName(_y)) {
                        if (false) {
                            _u._tracef(("under %s ‚â° %s" : GoString), Go.toInterface(Go.asInterface(_nx)), Go.toInterface(_y));
                        };
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return _u._nify(_nx._under(), _y, _p);
                        };
                    } else {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Named>)) : Ref<Named>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
                        }, _ny = __tmp__.value, __1 = __tmp__.ok;
                        if (((_ny != null) && ((_ny : Dynamic).__nil__ == null || !(_ny : Dynamic).__nil__)) && !_hasName(_x)) {
                            if (false) {
                                _u._tracef(("%s ‚â° under %s" : GoString), Go.toInterface(_x), Go.toInterface(Go.asInterface(_ny)));
                            };
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _u._nify(_x, _ny._under(), _p);
                            };
                        };
                    };
                };
            };
            {
                var __0:GoInt = _u._x._index(_x), __1:GoInt = _u._y._index(_y), _j:GoInt = __1, _i:GoInt = __0;
                if ((_i >= (0 : GoInt)) && (_j >= (0 : GoInt))) {
                    if (_u._join(_i, _j)) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return true;
                        };
                    };
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return _u._nifyEq(_u._x._at(_i), _u._y._at(_j), _p);
                    };
                } else if (_i >= (0 : GoInt)) {
                    {
                        var _tx:stdgo.go.types.Types.Type = _u._x._at(_i);
                        if (_tx != null) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _u._nifyEq(_tx, _y, _p);
                            };
                        };
                    };
                    _u._x._set(_i, _y);
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return true;
                    };
                } else if (_j >= (0 : GoInt)) {
                    {
                        var _ty:stdgo.go.types.Types.Type = _u._y._at(_j);
                        if (_ty != null) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _u._nifyEq(_x, _ty, _p);
                            };
                        };
                    };
                    _u._y._set(_j, _x);
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return true;
                    };
                };
            };
            if (true && !_u._exact) {
                if (_isTypeParam(_x) && !_hasName(_y)) {
                    {
                        var _cx:stdgo.go.types.Types.Type = _coreType(_x);
                        if (_cx != null) {
                            if (false) {
                                _u._tracef(("core %s ‚â° %s" : GoString), Go.toInterface(_x), Go.toInterface(_y));
                            };
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _u._nify(_cx, _y, _p);
                            };
                        };
                    };
                } else if (_isTypeParam(_y) && !_hasName(_x)) {
                    {
                        var _cy:stdgo.go.types.Types.Type = _coreType(_y);
                        if (_cy != null) {
                            if (false) {
                                _u._tracef(("%s ‚â° core %s" : GoString), Go.toInterface(_x), Go.toInterface(_y));
                            };
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _u._nify(_x, _cy, _p);
                            };
                        };
                    };
                };
            };
            {
                final __type__ = _x;
                if (Go.typeEquals((__type__ : Ref<Basic>))) {
                    var _x:Ref<stdgo.go.types.Types.Basic> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Basic>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Basic>)) : Ref<Basic>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.types.Types.Basic>), ok : false };
                        }, _y = __tmp__.value, _ok = __tmp__.ok;
                        if (_ok) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _x._kind == (_y._kind);
                            };
                        };
                    };
                } else if (Go.typeEquals((__type__ : Ref<Array_>))) {
                    var _x:Ref<stdgo.go.types.Types.Array_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Array_>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Array_>)) : Ref<Array_>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.types.Types.Array_>), ok : false };
                        }, _y = __tmp__.value, _ok = __tmp__.ok;
                        if (_ok) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return (((_x._len < (0i64 : GoInt64)) || (_y._len < (0i64 : GoInt64))) || (_x._len == _y._len)) && _u._nify(_x._elem, _y._elem, _p);
                            };
                        };
                    };
                } else if (Go.typeEquals((__type__ : Ref<Slice_>))) {
                    var _x:Ref<stdgo.go.types.Types.Slice_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Slice_>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Slice_>)) : Ref<Slice_>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.types.Types.Slice_>), ok : false };
                        }, _y = __tmp__.value, _ok = __tmp__.ok;
                        if (_ok) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _u._nify(_x._elem, _y._elem, _p);
                            };
                        };
                    };
                } else if (Go.typeEquals((__type__ : Ref<Struct>))) {
                    var _x:Ref<stdgo.go.types.Types.Struct> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Struct>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Struct>)) : Ref<Struct>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.types.Types.Struct>), ok : false };
                        }, _y = __tmp__.value, _ok = __tmp__.ok;
                        if (_ok) {
                            if (_x.numFields() == (_y.numFields())) {
                                for (_i => _f in _x._fields) {
                                    var _g = _y._fields[(_i : GoInt)];
                                    if ((((_f._embedded != _g._embedded) || (_x.tag(_i) != _y.tag(_i))) || !_f._sameId(_g._object._pkg, _g._object._name)) || !_u._nify(_f._object._typ, _g._object._typ, _p)) {
                                        {
                                            for (defer in __deferstack__) {
                                                defer();
                                            };
                                            return false;
                                        };
                                    };
                                };
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return true;
                                };
                            };
                        };
                    };
                } else if (Go.typeEquals((__type__ : Ref<Pointer_>))) {
                    var _x:Ref<stdgo.go.types.Types.Pointer_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Pointer_>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Pointer_>)) : Ref<Pointer_>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.types.Types.Pointer_>), ok : false };
                        }, _y = __tmp__.value, _ok = __tmp__.ok;
                        if (_ok) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _u._nify(_x._base, _y._base, _p);
                            };
                        };
                    };
                } else if (Go.typeEquals((__type__ : Ref<Tuple>))) {
                    var _x:Ref<stdgo.go.types.Types.Tuple> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Tuple>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Tuple>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Tuple>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Tuple>)) : Ref<Tuple>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.types.Types.Tuple>), ok : false };
                        }, _y = __tmp__.value, _ok = __tmp__.ok;
                        if (_ok) {
                            if (_x.len() == (_y.len())) {
                                if (_x != null && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) {
                                    for (_i => _v in _x._vars) {
                                        var _w = _y._vars[(_i : GoInt)];
                                        if (!_u._nify(_v._object._typ, _w._object._typ, _p)) {
                                            {
                                                for (defer in __deferstack__) {
                                                    defer();
                                                };
                                                return false;
                                            };
                                        };
                                    };
                                };
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return true;
                                };
                            };
                        };
                    };
                } else if (Go.typeEquals((__type__ : Ref<Signature>))) {
                    var _x:Ref<stdgo.go.types.Types.Signature> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Signature>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Signature>)) : Ref<Signature>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.types.Types.Signature>), ok : false };
                        }, _y = __tmp__.value, _ok = __tmp__.ok;
                        if (_ok) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return ((_x._variadic == _y._variadic) && _u._nify(Go.asInterface(_x._params), Go.asInterface(_y._params), _p)) && _u._nify(Go.asInterface(_x._results), Go.asInterface(_y._results), _p);
                            };
                        };
                    };
                } else if (Go.typeEquals((__type__ : Ref<Interface>))) {
                    var _x:Ref<stdgo.go.types.Types.Interface> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Interface>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Interface>)) : Ref<Interface>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.types.Types.Interface>), ok : false };
                        }, _y = __tmp__.value, _ok = __tmp__.ok;
                        if (_ok) {
                            var _xset = _x._typeSet();
                            var _yset = _y._typeSet();
                            if (_xset._comparable != (_yset._comparable)) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return false;
                                };
                            };
                            if (!_xset._terms._equal(_yset._terms)) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return false;
                                };
                            };
                            var _a = _xset._methods;
                            var _b = _yset._methods;
                            if ((_a.length) == ((_b.length))) {
                                var _q = (Go.setRef((new T_ifacePair(_x, _y, _p) : T_ifacePair)) : Ref<stdgo.go.types.Types.T_ifacePair>);
                                while (_p != null && ((_p : Dynamic).__nil__ == null || !(_p : Dynamic).__nil__)) {
                                    if (_p._identical(_q)) {
                                        {
                                            for (defer in __deferstack__) {
                                                defer();
                                            };
                                            return true;
                                        };
                                    };
                                    _p = _p._prev;
                                };
                                if (false) {
                                    _assertSortedMethods(_a);
                                    _assertSortedMethods(_b);
                                };
                                for (_i => _f in _a) {
                                    var _g = _b[(_i : GoInt)];
                                    if ((_f.id() != _g.id()) || !_u._nify(_f._object._typ, _g._object._typ, _q)) {
                                        {
                                            for (defer in __deferstack__) {
                                                defer();
                                            };
                                            return false;
                                        };
                                    };
                                };
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return true;
                                };
                            };
                        };
                    };
                } else if (Go.typeEquals((__type__ : Ref<Map_>))) {
                    var _x:Ref<stdgo.go.types.Types.Map_> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Map_>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Map_>)) : Ref<Map_>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.types.Types.Map_>), ok : false };
                        }, _y = __tmp__.value, _ok = __tmp__.ok;
                        if (_ok) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return _u._nify(_x._key, _y._key, _p) && _u._nify(_x._elem, _y._elem, _p);
                            };
                        };
                    };
                } else if (Go.typeEquals((__type__ : Ref<Chan>))) {
                    var _x:Ref<stdgo.go.types.Types.Chan> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Chan>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Chan>)) : Ref<Chan>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.types.Types.Chan>), ok : false };
                        }, _y = __tmp__.value, _ok = __tmp__.ok;
                        if (_ok) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return (!_u._exact || (_x._dir == _y._dir)) && _u._nify(_x._elem, _y._elem, _p);
                            };
                        };
                    };
                } else if (Go.typeEquals((__type__ : Ref<Named>))) {
                    var _x:Ref<stdgo.go.types.Types.Named> = __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.Named>) : __type__.__underlying__().value;
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert((Go.toInterface(_y) : Ref<Named>)) : Ref<Named>), ok : true };
                        } catch(_) {
                            { value : (null : Ref<stdgo.go.types.Types.Named>), ok : false };
                        }, _y = __tmp__.value, _ok = __tmp__.ok;
                        if (_ok) {
                            var _xargs = _x.typeArgs()._list();
                            var _yargs = _y.typeArgs()._list();
                            if ((_xargs.length) != ((_yargs.length))) {
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return false;
                                };
                            };
                            if ((_x._obj._object._pkg == _y._obj._object._pkg) && (_x._obj._object._name == _y._obj._object._name)) {
                                for (_i => _x in _xargs) {
                                    if (!_u._nify(_x, _yargs[(_i : GoInt)], _p)) {
                                        {
                                            for (defer in __deferstack__) {
                                                defer();
                                            };
                                            return false;
                                        };
                                    };
                                };
                                {
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    return true;
                                };
                            };
                        };
                    };
                } else if (Go.typeEquals((__type__ : Ref<TypeParam>))) {
                    var _x:Ref<stdgo.go.types.Types.TypeParam> = __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__() == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__ == null ? (null : Ref<stdgo.go.types.Types.TypeParam>) : __type__.__underlying__().value;
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return Go.toInterface(Go.asInterface(_x)) == (Go.toInterface(_y));
                    };
                } else if (__type__ == null) {
                    var _x:AnyInterface = __type__ == null ? (null : AnyInterface) : cast __type__;
                } else {
                    var _x:stdgo.go.types.Types.Type = __type__ == null ? (null : stdgo.go.types.Types.Type) : cast __type__;
                    throw Go.toInterface(_sprintf(null, null, true, ("u.nify(%s, %s), u.x.tparams = %s" : GoString), Go.toInterface(_x), Go.toInterface(_y), Go.toInterface(_u._x._tparams)));
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return false;
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return _result;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return _result;
        };
    }
    @:keep
    static public function _nifyEq( _u:Ref<T_unifier>, _x:Type, _y:Type, _p:Ref<T_ifacePair>):Bool {
        return (Go.toInterface(_x) == Go.toInterface(_y)) || _u._nify(_x, _y, _p);
    }
    /**
        // join unifies the i'th type parameter of x with the j'th type parameter of y.
        // If both type parameters already have a type associated with them and they are
        // not joined, join fails and returns false.
    **/
    @:keep
    static public function _join( _u:Ref<T_unifier>, _i:GoInt, _j:GoInt):Bool {
        if (false) {
            _u._tracef(("%s ‚áÑ %s" : GoString), Go.toInterface(Go.asInterface(_u._x._tparams[(_i : GoInt)])), Go.toInterface(Go.asInterface(_u._y._tparams[(_j : GoInt)])));
        };
        var _ti:GoInt = _u._x._indices[(_i : GoInt)];
        var _tj:GoInt = _u._y._indices[(_j : GoInt)];
        {
            var __switchIndex__ = -1;
            var __run__ = true;
            while (__run__) {
                __run__ = false;
                if ((_ti == (0 : GoInt)) && (_tj == (0 : GoInt))) {
                    _u._types = (_u._types.__append__((null : stdgo.go.types.Types.Type)));
                    _u._x._indices[(_i : GoInt)] = -(_u._types.length);
                    _u._y._indices[(_j : GoInt)] = -(_u._types.length);
                    break;
                } else if (_ti == ((0 : GoInt))) {
                    _u._x._indices[(_i : GoInt)] = _tj;
                    break;
                } else if (_tj == ((0 : GoInt))) {
                    _u._y._indices[(_j : GoInt)] = _ti;
                    break;
                } else if (_ti == (_tj)) {
                    break;
                    break;
                } else if ((_ti > (0 : GoInt)) && (_tj > (0 : GoInt))) {
                    return false;
                    break;
                } else if (_ti > (0 : GoInt)) {
                    _u._y._setIndex(_j, _ti);
                    break;
                } else {
                    _u._x._setIndex(_i, _tj);
                };
                break;
            };
        };
        return true;
    }
    @:keep
    static public function _tracef( _u:Ref<T_unifier>, _format:GoString, _args:haxe.Rest<AnyInterface>):Void {
        var _args = new Slice<AnyInterface>(_args.length, 0, ..._args);
        stdgo.fmt.Fmt.println(Go.toInterface(stdgo.strings.Strings.repeat((".  " : GoString), _u._depth) + _sprintf(null, null, true, _format, ..._args.__toArray__())));
    }
    /**
        // unify attempts to unify x and y and reports whether it succeeded.
    **/
    @:keep
    static public function _unify( _u:Ref<T_unifier>, _x:Type, _y:Type):Bool {
        return _u._nify(_x, _y, null);
    }
}
class T_tparamsList_asInterface {
    /**
        // types returns the list of inferred types (via unification) for the type parameters
        // described by d, and an index. If all types were inferred, the returned index is < 0.
        // Otherwise, it is the index of the first type parameter which couldn't be inferred;
        // i.e., for which list[index] is nil.
    **/
    @:keep
    public dynamic function _types():{ var _0 : Slice<Type>; var _1 : GoInt; } return __self__.value._types();
    /**
        // unknowns returns the number of type parameters for which no type has been set yet.
    **/
    @:keep
    public dynamic function _unknowns():GoInt return __self__.value._unknowns();
    /**
        // set sets the type typ for the i'th type parameter;
        // typ must not be nil and it must not have been set before.
    **/
    @:keep
    public dynamic function _set(_i:GoInt, _typ:Type):Void __self__.value._set(_i, _typ);
    /**
        // at returns the type set for the i'th type parameter; or nil.
    **/
    @:keep
    public dynamic function _at(_i:GoInt):Type return __self__.value._at(_i);
    /**
        // setIndex sets the type slot index for the i'th type parameter
        // (and all its joined parameters) to tj. The type parameter
        // must have a (possibly nil) type slot associated with it.
    **/
    @:keep
    public dynamic function _setIndex(_i:GoInt, _tj:GoInt):Void __self__.value._setIndex(_i, _tj);
    /**
        // If typ is a type parameter of d, index returns the type parameter index.
        // Otherwise, the result is < 0.
    **/
    @:keep
    public dynamic function _index(_typ:Type):GoInt return __self__.value._index(_typ);
    /**
        // init initializes d with the given type parameters.
        // The type parameters must be in the order in which they appear in their declaration
        // (this ensures that the tparams indices match the respective type parameter index).
    **/
    @:keep
    public dynamic function _init(_tparams:Slice<Ref<TypeParam>>):Void __self__.value._init(_tparams);
    /**
        // String returns a string representation for a tparamsList. For debugging.
    **/
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_tparamsList>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_tparamsList_asInterface) class T_tparamsList_static_extension {
    /**
        // types returns the list of inferred types (via unification) for the type parameters
        // described by d, and an index. If all types were inferred, the returned index is < 0.
        // Otherwise, it is the index of the first type parameter which couldn't be inferred;
        // i.e., for which list[index] is nil.
    **/
    @:keep
    static public function _types( _d:Ref<T_tparamsList>):{ var _0 : Slice<Type>; var _1 : GoInt; } {
        var _list:Slice<Type> = (null : Slice<stdgo.go.types.Types.Type>), _index:GoInt = (0 : GoInt);
        _list = new Slice<stdgo.go.types.Types.Type>((_d._tparams.length : GoInt).toBasic(), 0);
        _index = (-1 : GoInt);
        for (_i in 0 ... _d._tparams.length.toBasic()) {
            var _t:stdgo.go.types.Types.Type = _d._at(_i);
            _list[(_i : GoInt)] = _t;
            if ((_index < (0 : GoInt)) && (_t == null)) {
                _index = _i;
            };
        };
        return { _0 : _list, _1 : _index };
    }
    /**
        // unknowns returns the number of type parameters for which no type has been set yet.
    **/
    @:keep
    static public function _unknowns( _d:Ref<T_tparamsList>):GoInt {
        var _n:GoInt = (0 : GoInt);
        for (__0 => _ti in _d._indices) {
            if (_ti <= (0 : GoInt)) {
                _n++;
            };
        };
        return _n;
    }
    /**
        // set sets the type typ for the i'th type parameter;
        // typ must not be nil and it must not have been set before.
    **/
    @:keep
    static public function _set( _d:Ref<T_tparamsList>, _i:GoInt, _typ:Type):Void {
        _assert(_typ != null);
        var _u = _d._unifier;
        if (false) {
            _u._tracef(("%s ‚ûû %s" : GoString), Go.toInterface(Go.asInterface(_d._tparams[(_i : GoInt)])), Go.toInterface(_typ));
        };
        {
            var _ti:GoInt = _d._indices[(_i : GoInt)];
            if (_ti < (0 : GoInt)) {
                _u._types[(-_ti - (1 : GoInt) : GoInt)] = _typ;
                _d._setIndex(_i, -_ti);
            } else if (_ti == ((0 : GoInt))) {
                _u._types = (_u._types.__append__(_typ));
                _d._indices[(_i : GoInt)] = (_u._types.length);
            } else {
                throw Go.toInterface(("type already set" : GoString));
            };
        };
    }
    /**
        // at returns the type set for the i'th type parameter; or nil.
    **/
    @:keep
    static public function _at( _d:Ref<T_tparamsList>, _i:GoInt):Type {
        {
            var _ti:GoInt = _d._indices[(_i : GoInt)];
            if (_ti > (0 : GoInt)) {
                return _d._unifier._types[(_ti - (1 : GoInt) : GoInt)];
            };
        };
        return (null : stdgo.go.types.Types.Type);
    }
    /**
        // setIndex sets the type slot index for the i'th type parameter
        // (and all its joined parameters) to tj. The type parameter
        // must have a (possibly nil) type slot associated with it.
    **/
    @:keep
    static public function _setIndex( _d:Ref<T_tparamsList>, _i:GoInt, _tj:GoInt):Void {
        var _ti:GoInt = _d._indices[(_i : GoInt)];
        _assert((_ti != (0 : GoInt)) && (_tj != (0 : GoInt)));
        for (_k => _tk in _d._indices) {
            if (_tk == (_ti)) {
                _d._indices[(_k : GoInt)] = _tj;
            };
        };
    }
    /**
        // If typ is a type parameter of d, index returns the type parameter index.
        // Otherwise, the result is < 0.
    **/
    @:keep
    static public function _index( _d:Ref<T_tparamsList>, _typ:Type):GoInt {
        {
            var __tmp__ = try {
                { value : (Go.typeAssert((Go.toInterface(_typ) : Ref<TypeParam>)) : Ref<TypeParam>), ok : true };
            } catch(_) {
                { value : (null : Ref<stdgo.go.types.Types.TypeParam>), ok : false };
            }, _tpar = __tmp__.value, _ok = __tmp__.ok;
            if (_ok) {
                return _tparamIndex(_d._tparams, _tpar);
            };
        };
        return (-1 : GoInt);
    }
    /**
        // init initializes d with the given type parameters.
        // The type parameters must be in the order in which they appear in their declaration
        // (this ensures that the tparams indices match the respective type parameter index).
    **/
    @:keep
    static public function _init( _d:Ref<T_tparamsList>, _tparams:Slice<Ref<TypeParam>>):Void {
        if ((_tparams.length) == ((0 : GoInt))) {
            return;
        };
        if (false) {
            for (_i => _tpar in _tparams) {
                _assert(_i == (_tpar._index));
            };
        };
        _d._tparams = _tparams;
        _d._indices = new Slice<GoInt>((_tparams.length : GoInt).toBasic(), 0).__setNumber32__();
    }
    /**
        // String returns a string representation for a tparamsList. For debugging.
    **/
    @:keep
    static public function string( _d:Ref<T_tparamsList>):GoString {
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        var _w = _newTypeWriter((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>), null);
        _w._byte((91 : GoUInt8));
        for (_i => _tpar in _d._tparams) {
            if (_i > (0 : GoInt)) {
                _w._string((", " : GoString));
            };
            _w._typ(Go.asInterface(_tpar));
            _w._string((": " : GoString));
            _w._typ(_d._at(_i));
        };
        _w._byte((93 : GoUInt8));
        return (_buf.string() : GoString);
    }
}
class Union_asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:keep
    public dynamic function underlying():Type return __self__.value.underlying();
    @:keep
    public dynamic function term(_i:GoInt):Ref<Term> return __self__.value.term(_i);
    @:keep
    public dynamic function len():GoInt return __self__.value.len();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Union>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Union_asInterface) class Union_static_extension {
    @:keep
    static public function string( _u:Ref<Union>):GoString {
        return typeString(Go.asInterface(_u), null);
    }
    @:keep
    static public function underlying( _u:Ref<Union>):Type {
        return Go.asInterface(_u);
    }
    @:keep
    static public function term( _u:Ref<Union>, _i:GoInt):Ref<Term> {
        return _u._terms[(_i : GoInt)];
    }
    @:keep
    static public function len( _u:Ref<Union>):GoInt {
        return (_u._terms.length);
    }
}
class T_atPos_asInterface {
    @:keep
    public dynamic function pos():stdgo.go.token.Token.Pos return __self__.value.pos();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_atPos>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_atPos_asInterface) class T_atPos_static_extension {
    @:keep
    static public function pos( _s:T_atPos):stdgo.go.token.Token.Pos {
        return (_s : stdgo.go.token.Token.Pos);
    }
}
class T_nodeSet_asInterface {
    @:keep
    public dynamic function _add(_p:Ref<T_graphNode>):Void __self__.value._add(_p);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_nodeSet>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_nodeSet_asInterface) class T_nodeSet_static_extension {
    @:keep
    static public function _add( _s:Ref<T_nodeSet>, _p:Ref<T_graphNode>):Void {
        if ((_s : stdgo.go.types.Types.T_nodeSet) == null) {
            _s.__setData__(({
                final x = new GoRefMap<Ref<stdgo.go.types.Types.T_graphNode>, Bool>();
                @:mergeBlock {};
                cast x;
            } : GoMap<Ref<stdgo.go.types.Types.T_graphNode>, Bool>));
        };
        ((_s : stdgo.go.types.Types.T_nodeSet))[_p] = true;
    }
}
class T_nodeQueue_asInterface {
    @:keep
    public dynamic function pop():AnyInterface return __self__.value.pop();
    @:keep
    public dynamic function push(_x:AnyInterface):Void __self__.value.push(_x);
    @:keep
    public dynamic function less(_i:GoInt, _j:GoInt):Bool return __self__.value.less(_i, _j);
    @:keep
    public dynamic function swap(_i:GoInt, _j:GoInt):Void __self__.value.swap(_i, _j);
    @:keep
    public dynamic function len():GoInt return __self__.value.len();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_nodeQueue>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_nodeQueue_asInterface) class T_nodeQueue_static_extension {
    @:keep
    static public function pop( _a:Ref<T_nodeQueue>):AnyInterface {
        var _n:GoInt = ((_a : stdgo.go.types.Types.T_nodeQueue).length);
        var _x = ((_a : stdgo.go.types.Types.T_nodeQueue))[(_n - (1 : GoInt) : GoInt)];
        _x._index = (-1 : GoInt);
        _a.__setData__((((_a : stdgo.go.types.Types.T_nodeQueue)).__slice__(0, _n - (1 : GoInt)) : stdgo.go.types.Types.T_nodeQueue));
        return Go.toInterface(Go.asInterface(_x));
    }
    @:keep
    static public function push( _a:Ref<T_nodeQueue>, _x:AnyInterface):Void {
        throw Go.toInterface(("unreachable" : GoString));
    }
    @:keep
    static public function less( _a:T_nodeQueue, _i:GoInt, _j:GoInt):Bool {
        var __0 = _a[(_i : GoInt)], __1 = _a[(_j : GoInt)], _y = __1, _x = __0;
        return (_x._ndeps < _y._ndeps) || ((_x._ndeps == _y._ndeps) && (_x._obj._order() < _y._obj._order()));
    }
    @:keep
    static public function swap( _a:T_nodeQueue, _i:GoInt, _j:GoInt):Void {
        var __0 = _a[(_i : GoInt)], __1 = _a[(_j : GoInt)], _y = __1, _x = __0;
        {
            final __tmp__0 = _y;
            final __tmp__1 = _x;
            _a[(_i : GoInt)] = __tmp__0;
            _a[(_j : GoInt)] = __tmp__1;
        };
        {
            final __tmp__0 = _j;
            final __tmp__1 = _i;
            _x._index = __tmp__0;
            _y._index = __tmp__1;
        };
    }
    @:keep
    static public function len( _a:T_nodeQueue):GoInt {
        return (_a.length);
    }
}
class T_methodSet_asInterface {
    @:keep
    public dynamic function _addOne(_f:Ref<Func>, _index:Slice<GoInt>, _indirect:Bool, _multiples:Bool):T_methodSet return __self__.value._addOne(_f, _index, _indirect, _multiples);
    /**
        // Add adds all functions in list to the method set s.
        // If multiples is set, every function in list appears multiple times
        // and is treated as a collision.
    **/
    @:keep
    public dynamic function _add(_list:Slice<Ref<Func>>, _index:Slice<GoInt>, _indirect:Bool, _multiples:Bool):T_methodSet return __self__.value._add(_list, _index, _indirect, _multiples);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_methodSet>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_methodSet_asInterface) class T_methodSet_static_extension {
    @:keep
    static public function _addOne( _s:T_methodSet, _f:Ref<Func>, _index:Slice<GoInt>, _indirect:Bool, _multiples:Bool):T_methodSet {
        if (_s == null) {
            _s = ({
                final x = new stdgo.GoMap.GoStringMap<Ref<stdgo.go.types.Types.Selection>>();
                x.__defaultValue__ = () -> (null : Ref<stdgo.go.types.Types.Selection>);
                @:mergeBlock {};
                x;
            } : GoMap<GoString, Ref<stdgo.go.types.Types.Selection>>);
        };
        var _key:GoString = _f.id();
        if (!_multiples) {
            {
                var __tmp__ = (_s != null && _s.exists(_key) ? { value : _s[_key], ok : true } : { value : (null : Ref<stdgo.go.types.Types.Selection>), ok : false }), __0:Ref<stdgo.go.types.Types.Selection> = __tmp__.value, _found:Bool = __tmp__.ok;
                if (!_found && (_indirect || !_f._hasPtrRecv())) {
                    _s[_key] = (Go.setRef((new Selection((1 : stdgo.go.types.Types.SelectionKind), (null : stdgo.go.types.Types.Type), Go.asInterface(_f), _index, _indirect) : Selection)) : Ref<stdgo.go.types.Types.Selection>);
                    return _s;
                };
            };
        };
        _s[_key] = null;
        return _s;
    }
    /**
        // Add adds all functions in list to the method set s.
        // If multiples is set, every function in list appears multiple times
        // and is treated as a collision.
    **/
    @:keep
    static public function _add( _s:T_methodSet, _list:Slice<Ref<Func>>, _index:Slice<GoInt>, _indirect:Bool, _multiples:Bool):T_methodSet {
        if ((_list.length) == ((0 : GoInt))) {
            return _s;
        };
        for (_i => _f in _list) {
            _s = _s._addOne(_f, _concat(_index, _i), _indirect, _multiples);
        };
        return _s;
    }
}
class T_color_asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_color>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_color_asInterface) class T_color_static_extension {
    @:keep
    static public function string( _c:T_color):GoString {
        {
            final __value__ = _c;
            if (__value__ == ((0u32 : stdgo.go.types.Types.T_color))) {
                return ("white" : GoString);
            } else if (__value__ == ((1u32 : stdgo.go.types.Types.T_color))) {
                return ("black" : GoString);
            } else {
                return ("grey" : GoString);
            };
        };
    }
}
class T_objset_asInterface {
    /**
        // insert attempts to insert an object obj into objset s.
        // If s already contains an alternative object alt with
        // the same name, insert leaves s unchanged and returns alt.
        // Otherwise it inserts obj and returns nil.
    **/
    @:keep
    public dynamic function _insert(_obj:Object):Object return __self__.value._insert(_obj);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_objset>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_objset_asInterface) class T_objset_static_extension {
    /**
        // insert attempts to insert an object obj into objset s.
        // If s already contains an alternative object alt with
        // the same name, insert leaves s unchanged and returns alt.
        // Otherwise it inserts obj and returns nil.
    **/
    @:keep
    static public function _insert( _s:Ref<T_objset>, _obj:Object):Object {
        var _id:GoString = _obj.id();
        {
            var _alt:stdgo.go.types.Types.Object = ((_s : stdgo.go.types.Types.T_objset))[_id];
            if (_alt != null) {
                return _alt;
            };
        };
        if ((_s : stdgo.go.types.Types.T_objset) == null) {
            _s.__setData__(({
                final x = new stdgo.GoMap.GoStringMap<stdgo.go.types.Types.Object>();
                x.__defaultValue__ = () -> (null : stdgo.go.types.Types.Object);
                @:mergeBlock {};
                x;
            } : GoMap<GoString, stdgo.go.types.Types.Object>));
        };
        ((_s : stdgo.go.types.Types.T_objset))[_id] = _obj;
        return (null : stdgo.go.types.Types.Object);
    }
}
class T_inSourceOrder_asInterface {
    @:keep
    public dynamic function swap(_i:GoInt, _j:GoInt):Void __self__.value.swap(_i, _j);
    @:keep
    public dynamic function less(_i:GoInt, _j:GoInt):Bool return __self__.value.less(_i, _j);
    @:keep
    public dynamic function len():GoInt return __self__.value.len();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_inSourceOrder>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_inSourceOrder_asInterface) class T_inSourceOrder_static_extension {
    @:keep
    static public function swap( _a:T_inSourceOrder, _i:GoInt, _j:GoInt):Void {
        {
            final __tmp__0 = _a[(_j : GoInt)];
            final __tmp__1 = _a[(_i : GoInt)];
            _a[(_i : GoInt)] = __tmp__0;
            _a[(_j : GoInt)] = __tmp__1;
        };
    }
    @:keep
    static public function less( _a:T_inSourceOrder, _i:GoInt, _j:GoInt):Bool {
        return _a[(_i : GoInt)]._order() < _a[(_j : GoInt)]._order();
    }
    @:keep
    static public function len( _a:T_inSourceOrder):GoInt {
        return (_a.length);
    }
}
class T_substMap_asInterface {
    @:keep
    public dynamic function _lookup(_tpar:Ref<TypeParam>):Type return __self__.value._lookup(_tpar);
    @:keep
    public dynamic function _empty():Bool return __self__.value._empty();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_substMap>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_substMap_asInterface) class T_substMap_static_extension {
    @:keep
    static public function _lookup( _m:T_substMap, _tpar:Ref<TypeParam>):Type {
        {
            var _t:stdgo.go.types.Types.Type = _m[_tpar];
            if (_t != null) {
                return _t;
            };
        };
        return Go.asInterface(_tpar);
    }
    @:keep
    static public function _empty( _m:T_substMap):Bool {
        return (_m.length) == ((0 : GoInt));
    }
}
class T_termlist_asInterface {
    /**
        // subsetOf reports whether xl ‚äÜ yl.
    **/
    @:keep
    public dynamic function _subsetOf(_yl:T_termlist):Bool return __self__.value._subsetOf(_yl);
    /**
        // supersetOf reports whether y ‚äÜ xl.
    **/
    @:keep
    public dynamic function _supersetOf(_y:Ref<T_term>):Bool return __self__.value._supersetOf(_y);
    /**
        // includes reports whether t ‚àà xl.
    **/
    @:keep
    public dynamic function _includes(_t:Type):Bool return __self__.value._includes(_t);
    /**
        // equal reports whether xl and yl represent the same type set.
    **/
    @:keep
    public dynamic function _equal(_yl:T_termlist):Bool return __self__.value._equal(_yl);
    /**
        // intersect returns the intersection xl ‚à© yl.
    **/
    @:keep
    public dynamic function _intersect(_yl:T_termlist):T_termlist return __self__.value._intersect(_yl);
    /**
        // union returns the union xl ‚à™ yl.
    **/
    @:keep
    public dynamic function _union(_yl:T_termlist):T_termlist return __self__.value._union(_yl);
    /**
        // norm returns the normal form of xl.
    **/
    @:keep
    public dynamic function _norm():T_termlist return __self__.value._norm();
    /**
        // isAll reports whether the termlist xl represents the set of all types.
    **/
    @:keep
    public dynamic function _isAll():Bool return __self__.value._isAll();
    /**
        // isEmpty reports whether the termlist xl represents the empty set of types.
    **/
    @:keep
    public dynamic function _isEmpty():Bool return __self__.value._isEmpty();
    /**
        // String prints the termlist exactly (without normalization).
    **/
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_termlist>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_termlist_asInterface) class T_termlist_static_extension {
    /**
        // subsetOf reports whether xl ‚äÜ yl.
    **/
    @:keep
    static public function _subsetOf( _xl:T_termlist, _yl:T_termlist):Bool {
        if (_yl._isEmpty()) {
            return _xl._isEmpty();
        };
        for (__0 => _x in _xl) {
            if (!_yl._supersetOf(_x)) {
                return false;
            };
        };
        return true;
    }
    /**
        // supersetOf reports whether y ‚äÜ xl.
    **/
    @:keep
    static public function _supersetOf( _xl:T_termlist, _y:Ref<T_term>):Bool {
        for (__0 => _x in _xl) {
            if (_y._subsetOf(_x)) {
                return true;
            };
        };
        return false;
    }
    /**
        // includes reports whether t ‚àà xl.
    **/
    @:keep
    static public function _includes( _xl:T_termlist, _t:Type):Bool {
        for (__0 => _x in _xl) {
            if (_x._includes(_t)) {
                return true;
            };
        };
        return false;
    }
    /**
        // equal reports whether xl and yl represent the same type set.
    **/
    @:keep
    static public function _equal( _xl:T_termlist, _yl:T_termlist):Bool {
        return _xl._subsetOf(_yl) && _yl._subsetOf(_xl);
    }
    /**
        // intersect returns the intersection xl ‚à© yl.
    **/
    @:keep
    static public function _intersect( _xl:T_termlist, _yl:T_termlist):T_termlist {
        if (_xl._isEmpty() || _yl._isEmpty()) {
            return null;
        };
        var _rl:T_termlist = new stdgo.go.types.Types.T_termlist(0, 0);
        for (__0 => _x in _xl) {
            for (__1 => _y in _yl) {
                {
                    var _r = _x._intersect(_y);
                    if (_r != null && ((_r : Dynamic).__nil__ == null || !(_r : Dynamic).__nil__)) {
                        _rl = (_rl.__append__(_r));
                    };
                };
            };
        };
        return _rl._norm();
    }
    /**
        // union returns the union xl ‚à™ yl.
    **/
    @:keep
    static public function _union( _xl:T_termlist, _yl:T_termlist):T_termlist {
        return (_xl.__append__(..._yl.__toArray__()))._norm();
    }
    /**
        // norm returns the normal form of xl.
    **/
    @:keep
    static public function _norm( _xl:T_termlist):T_termlist {
        var _used = new Slice<Bool>((_xl.length : GoInt).toBasic(), 0);
        var _rl:T_termlist = new stdgo.go.types.Types.T_termlist(0, 0);
        for (_i => _xi in _xl) {
            if (((_xi == null) || (_xi : Dynamic).__nil__) || _used[(_i : GoInt)]) {
                continue;
            };
            {
                var _j:GoInt = _i + (1 : GoInt);
                Go.cfor(_j < (_xl.length), _j++, {
                    var _xj = _xl[(_j : GoInt)];
                    if (((_xj == null) || (_xj : Dynamic).__nil__) || _used[(_j : GoInt)]) {
                        continue;
                    };
                    {
                        var __tmp__ = _xi._union(_xj), _u1:Ref<stdgo.go.types.Types.T_term> = __tmp__._0, _u2:Ref<stdgo.go.types.Types.T_term> = __tmp__._1;
                        if (_u2 == null || (_u2 : Dynamic).__nil__) {
                            if (_u1._typ == null) {
                                return _allTermlist;
                            };
                            _xi = _u1;
                            _used[(_j : GoInt)] = true;
                        };
                    };
                });
            };
            _rl = (_rl.__append__(_xi));
        };
        return _rl;
    }
    /**
        // isAll reports whether the termlist xl represents the set of all types.
    **/
    @:keep
    static public function _isAll( _xl:T_termlist):Bool {
        for (__0 => _x in _xl) {
            if (((_x != null) && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) && (_x._typ == null)) {
                return true;
            };
        };
        return false;
    }
    /**
        // isEmpty reports whether the termlist xl represents the empty set of types.
    **/
    @:keep
    static public function _isEmpty( _xl:T_termlist):Bool {
        for (__0 => _x in _xl) {
            if (_x != null && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) {
                return false;
            };
        };
        return true;
    }
    /**
        // String prints the termlist exactly (without normalization).
    **/
    @:keep
    static public function string( _xl:T_termlist):GoString {
        if ((_xl.length) == ((0 : GoInt))) {
            return ("‚àÖ" : GoString);
        };
        var _buf:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
        for (_i => _x in _xl) {
            if (_i > (0 : GoInt)) {
                _buf.writeString((" | " : GoString));
            };
            _buf.writeString((_x.string() : GoString));
        };
        return (_buf.string() : GoString);
    }
}
class T_byUniqueMethodName_asInterface {
    @:keep
    public dynamic function swap(_i:GoInt, _j:GoInt):Void __self__.value.swap(_i, _j);
    @:keep
    public dynamic function less(_i:GoInt, _j:GoInt):Bool return __self__.value.less(_i, _j);
    @:keep
    public dynamic function len():GoInt return __self__.value.len();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_byUniqueMethodName>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.T_byUniqueMethodName_asInterface) class T_byUniqueMethodName_static_extension {
    @:keep
    static public function swap( _a:T_byUniqueMethodName, _i:GoInt, _j:GoInt):Void {
        {
            final __tmp__0 = _a[(_j : GoInt)];
            final __tmp__1 = _a[(_i : GoInt)];
            _a[(_i : GoInt)] = __tmp__0;
            _a[(_j : GoInt)] = __tmp__1;
        };
    }
    @:keep
    static public function less( _a:T_byUniqueMethodName, _i:GoInt, _j:GoInt):Bool {
        return _a[(_i : GoInt)].id() < _a[(_j : GoInt)].id();
    }
    @:keep
    static public function len( _a:T_byUniqueMethodName):GoInt {
        return (_a.length);
    }
}
class Term_asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:keep
    public dynamic function type():Type return __self__.value.type();
    @:keep
    public dynamic function tilde():Bool return __self__.value.tilde();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Term>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.go.types.Types.Term_asInterface) class Term_static_extension {
    @:keep
    static public function string( _t:Ref<Term>):GoString {
        return ({
            final e = _t;
            ({ _tilde : e._tilde, _typ : e._typ } : stdgo.go.types.Types.T_term);
        }.string() : GoString);
    }
    @:keep
    static public function type( _t:Ref<Term>):Type {
        return _t._typ;
    }
    @:keep
    static public function tilde( _t:Ref<Term>):Bool {
        return _t._tilde;
    }
}
