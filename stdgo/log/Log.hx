package stdgo.log;
/**
    // Package log implements a simple logging package. It defines a type, Logger,
    // with methods for formatting output. It also has a predefined 'standard'
    // Logger accessible through helper functions Print[f|ln], Fatal[f|ln], and
    // Panic[f|ln], which are easier to use than creating a Logger manually.
    // That logger writes to standard error and prints the date and time
    // of each logged message.
    // Every log message is output on a separate line: if the message being
    // printed does not end in a newline, the logger will add one.
    // The Fatal functions call os.Exit(1) after writing the log message.
    // The Panic functions call panic after writing the log message.
**/
private var __go2hxdoc__package : Bool;
/**
    
    
    
**/
var _std : stdgo.StdGoTypes.Ref<stdgo.log.Log.Logger> = new_(stdgo.Go.asInterface(stdgo.os.Os.stderr), stdgo.Go.str()?.__copy__(), (3 : stdgo.StdGoTypes.GoInt));
/**
    
    
    
**/
var _bufferPool : stdgo.sync.Sync.Pool = ({ new_ : function():stdgo.StdGoTypes.AnyInterface {
        return stdgo.Go.toInterface((stdgo.Go.setRef((null : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>)) : stdgo.StdGoTypes.Ref<stdgo.Slice<stdgo.StdGoTypes.GoUInt8>>));
    } } : stdgo.sync.Sync.Pool);
/**
    
    
    
**/
var _tests : stdgo.Slice<stdgo.log.Log.T_tester> = (new stdgo.Slice<stdgo.log.Log.T_tester>(
14,
14,
(new stdgo.log.Log.T_tester((0 : stdgo.StdGoTypes.GoInt), stdgo.Go.str()?.__copy__(), stdgo.Go.str()?.__copy__()) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((0 : stdgo.StdGoTypes.GoInt), ("XXX" : stdgo.GoString), ("XXX" : stdgo.GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((1 : stdgo.StdGoTypes.GoInt), stdgo.Go.str()?.__copy__(), ("[0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9] " : stdgo.GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((2 : stdgo.StdGoTypes.GoInt), stdgo.Go.str()?.__copy__(), ("[0-9][0-9]:[0-9][0-9]:[0-9][0-9] " : stdgo.GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((66 : stdgo.StdGoTypes.GoInt), ("XXX" : stdgo.GoString), ("[0-9][0-9]:[0-9][0-9]:[0-9][0-9] XXX" : stdgo.GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((6 : stdgo.StdGoTypes.GoInt), stdgo.Go.str()?.__copy__(), ("[0-9][0-9]:[0-9][0-9]:[0-9][0-9]\\.[0-9][0-9][0-9][0-9][0-9][0-9] " : stdgo.GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((4 : stdgo.StdGoTypes.GoInt), stdgo.Go.str()?.__copy__(), ("[0-9][0-9]:[0-9][0-9]:[0-9][0-9]\\.[0-9][0-9][0-9][0-9][0-9][0-9] " : stdgo.GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((8 : stdgo.StdGoTypes.GoInt), stdgo.Go.str()?.__copy__(), (".*/[A-Za-z0-9_\\-]+\\.go:(63|65): " : stdgo.GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((16 : stdgo.StdGoTypes.GoInt), stdgo.Go.str()?.__copy__(), ("[A-Za-z0-9_\\-]+\\.go:(63|65): " : stdgo.GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((24 : stdgo.StdGoTypes.GoInt), stdgo.Go.str()?.__copy__(), ("[A-Za-z0-9_\\-]+\\.go:(63|65): " : stdgo.GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((15 : stdgo.StdGoTypes.GoInt), ("XXX" : stdgo.GoString), ("XXX[0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9]\\.[0-9][0-9][0-9][0-9][0-9][0-9] .*/[A-Za-z0-9_\\-]+\\.go:(63|65): " : stdgo.GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((23 : stdgo.StdGoTypes.GoInt), ("XXX" : stdgo.GoString), ("XXX[0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9]\\.[0-9][0-9][0-9][0-9][0-9][0-9] [A-Za-z0-9_\\-]+\\.go:(63|65): " : stdgo.GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((79 : stdgo.StdGoTypes.GoInt), ("XXX" : stdgo.GoString), ("[0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9]\\.[0-9][0-9][0-9][0-9][0-9][0-9] .*/[A-Za-z0-9_\\-]+\\.go:(63|65): XXX" : stdgo.GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((87 : stdgo.StdGoTypes.GoInt), ("XXX" : stdgo.GoString), ("[0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9]\\.[0-9][0-9][0-9][0-9][0-9][0-9] [A-Za-z0-9_\\-]+\\.go:(63|65): XXX" : stdgo.GoString)) : stdgo.log.Log.T_tester)) : stdgo.Slice<stdgo.log.Log.T_tester>);
/**
    // These flags define which text to prefix to each log entry generated by the Logger.
    // Bits are or'ed together to control what's printed.
    // With the exception of the Lmsgprefix flag, there is no
    // control over the order they appear (the order listed here)
    // or the format they present (as described in the comments).
    // The prefix is followed by a colon only when Llongfile or Lshortfile
    // is specified.
    // For example, flags Ldate | Ltime (or LstdFlags) produce,
    //
    //	2009/01/23 01:23:23 message
    //
    // while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
    //
    //	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
    
    // the date in the local time zone: 2009/01/23
**/
final ldate : stdgo.StdGoTypes.GoUInt64 = (64i64 : stdgo.StdGoTypes.GoUInt64);
/**
    // These flags define which text to prefix to each log entry generated by the Logger.
    // Bits are or'ed together to control what's printed.
    // With the exception of the Lmsgprefix flag, there is no
    // control over the order they appear (the order listed here)
    // or the format they present (as described in the comments).
    // The prefix is followed by a colon only when Llongfile or Lshortfile
    // is specified.
    // For example, flags Ldate | Ltime (or LstdFlags) produce,
    //
    //	2009/01/23 01:23:23 message
    //
    // while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
    //
    //	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
    
    // the time in the local time zone: 01:23:23
**/
final ltime = (64i64 : stdgo.StdGoTypes.GoUInt64);
/**
    // These flags define which text to prefix to each log entry generated by the Logger.
    // Bits are or'ed together to control what's printed.
    // With the exception of the Lmsgprefix flag, there is no
    // control over the order they appear (the order listed here)
    // or the format they present (as described in the comments).
    // The prefix is followed by a colon only when Llongfile or Lshortfile
    // is specified.
    // For example, flags Ldate | Ltime (or LstdFlags) produce,
    //
    //	2009/01/23 01:23:23 message
    //
    // while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
    //
    //	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
    
    // microsecond resolution: 01:23:23.123123.  assumes Ltime.
**/
final lmicroseconds = (64i64 : stdgo.StdGoTypes.GoUInt64);
/**
    // These flags define which text to prefix to each log entry generated by the Logger.
    // Bits are or'ed together to control what's printed.
    // With the exception of the Lmsgprefix flag, there is no
    // control over the order they appear (the order listed here)
    // or the format they present (as described in the comments).
    // The prefix is followed by a colon only when Llongfile or Lshortfile
    // is specified.
    // For example, flags Ldate | Ltime (or LstdFlags) produce,
    //
    //	2009/01/23 01:23:23 message
    //
    // while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
    //
    //	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
    
    // full file name and line number: /a/b/c/d.go:23
**/
final llongfile = (64i64 : stdgo.StdGoTypes.GoUInt64);
/**
    // These flags define which text to prefix to each log entry generated by the Logger.
    // Bits are or'ed together to control what's printed.
    // With the exception of the Lmsgprefix flag, there is no
    // control over the order they appear (the order listed here)
    // or the format they present (as described in the comments).
    // The prefix is followed by a colon only when Llongfile or Lshortfile
    // is specified.
    // For example, flags Ldate | Ltime (or LstdFlags) produce,
    //
    //	2009/01/23 01:23:23 message
    //
    // while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
    //
    //	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
    
    // final file name element and line number: d.go:23. overrides Llongfile
**/
final lshortfile = (64i64 : stdgo.StdGoTypes.GoUInt64);
/**
    // These flags define which text to prefix to each log entry generated by the Logger.
    // Bits are or'ed together to control what's printed.
    // With the exception of the Lmsgprefix flag, there is no
    // control over the order they appear (the order listed here)
    // or the format they present (as described in the comments).
    // The prefix is followed by a colon only when Llongfile or Lshortfile
    // is specified.
    // For example, flags Ldate | Ltime (or LstdFlags) produce,
    //
    //	2009/01/23 01:23:23 message
    //
    // while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
    //
    //	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
    
    // if Ldate or Ltime is set, use UTC rather than the local time zone
**/
final lutc = (64i64 : stdgo.StdGoTypes.GoUInt64);
/**
    // These flags define which text to prefix to each log entry generated by the Logger.
    // Bits are or'ed together to control what's printed.
    // With the exception of the Lmsgprefix flag, there is no
    // control over the order they appear (the order listed here)
    // or the format they present (as described in the comments).
    // The prefix is followed by a colon only when Llongfile or Lshortfile
    // is specified.
    // For example, flags Ldate | Ltime (or LstdFlags) produce,
    //
    //	2009/01/23 01:23:23 message
    //
    // while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
    //
    //	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
    
    // move the "prefix" from the beginning of the line to before the message
**/
final lmsgprefix = (64i64 : stdgo.StdGoTypes.GoUInt64);
/**
    // These flags define which text to prefix to each log entry generated by the Logger.
    // Bits are or'ed together to control what's printed.
    // With the exception of the Lmsgprefix flag, there is no
    // control over the order they appear (the order listed here)
    // or the format they present (as described in the comments).
    // The prefix is followed by a colon only when Llongfile or Lshortfile
    // is specified.
    // For example, flags Ldate | Ltime (or LstdFlags) produce,
    //
    //	2009/01/23 01:23:23 message
    //
    // while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
    //
    //	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
    
    // initial values for the standard logger
**/
final lstdFlags : stdgo.StdGoTypes.GoUInt64 = (3i64 : stdgo.StdGoTypes.GoUInt64);
/**
    
    
    
**/
final rdate : stdgo.GoString = ("[0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9]" : stdgo.GoString);
/**
    
    
    
**/
final rtime : stdgo.GoString = ("[0-9][0-9]:[0-9][0-9]:[0-9][0-9]" : stdgo.GoString);
/**
    
    
    
**/
final rmicroseconds : stdgo.GoString = ("\\.[0-9][0-9][0-9][0-9][0-9][0-9]" : stdgo.GoString);
/**
    
    
    // must update if the calls to l.Printf / l.Print below move
**/
final rline : stdgo.GoString = ("(63|65):" : stdgo.GoString);
/**
    
    
    
**/
final rlongfile : stdgo.GoString = (".*/[A-Za-z0-9_\\-]+\\.go:(63|65):" : stdgo.GoString);
/**
    
    
    
**/
final rshortfile : stdgo.GoString = ("[A-Za-z0-9_\\-]+\\.go:(63|65):" : stdgo.GoString);
/**
    // A Logger represents an active logging object that generates lines of
    // output to an io.Writer. Each logging operation makes a single call to
    // the Writer's Write method. A Logger can be used simultaneously from
    // multiple goroutines; it guarantees to serialize access to the Writer.
    
    
**/
@:structInit @:using(stdgo.log.Log.Logger_static_extension) class Logger {
    public var _outMu : stdgo.sync.Sync.Mutex = ({} : stdgo.sync.Sync.Mutex);
    public var _out : stdgo.io.Io.Writer = (null : stdgo.io.Io.Writer);
    public var _prefix : stdgo.sync.atomic_.Atomic_.Pointer_<stdgo.GoString> = ({} : stdgo.sync.atomic_.Atomic_.Pointer_<stdgo.GoString>);
    public var _flag : stdgo.sync.atomic_.Atomic_.Int32 = ({} : stdgo.sync.atomic_.Atomic_.Int32);
    public var _isDiscard : stdgo.sync.atomic_.Atomic_.Bool_ = ({} : stdgo.sync.atomic_.Atomic_.Bool_);
    public function new(?_outMu:stdgo.sync.Sync.Mutex, ?_out:stdgo.io.Io.Writer, ?_prefix:stdgo.sync.atomic_.Atomic_.Pointer_<stdgo.GoString>, ?_flag:stdgo.sync.atomic_.Atomic_.Int32, ?_isDiscard:stdgo.sync.atomic_.Atomic_.Bool_) {
        if (_outMu != null) this._outMu = _outMu;
        if (_out != null) this._out = _out;
        if (_prefix != null) this._prefix = _prefix;
        if (_flag != null) this._flag = _flag;
        if (_isDiscard != null) this._isDiscard = _isDiscard;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Logger(_outMu, _out, _prefix, _flag, _isDiscard);
    }
}
/**
    
    
    
**/
@:structInit @:private class T_tester {
    public var _flag : stdgo.StdGoTypes.GoInt = 0;
    public var _prefix : stdgo.GoString = "";
    public var _pattern : stdgo.GoString = "";
    public function new(?_flag:stdgo.StdGoTypes.GoInt, ?_prefix:stdgo.GoString, ?_pattern:stdgo.GoString) {
        if (_flag != null) this._flag = _flag;
        if (_prefix != null) this._prefix = _prefix;
        if (_pattern != null) this._pattern = _pattern;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_tester(_flag, _prefix, _pattern);
    }
}
/**
    // discard is identical to io.Discard,
    // but copied here to avoid the io.Discard optimization in Logger.
    
    
**/
@:structInit @:private @:using(stdgo.log.Log.T_discard_static_extension) class T_discard {
    public function new() {}
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_discard();
    }
}
/**
    // New creates a new Logger. The out variable sets the
    // destination to which log data will be written.
    // The prefix appears at the beginning of each generated log line, or
    // after the log header if the Lmsgprefix flag is provided.
    // The flag argument defines the logging properties.
**/
function new_(_out:stdgo.io.Io.Writer, _prefix:stdgo.GoString, _flag:stdgo.StdGoTypes.GoInt):stdgo.StdGoTypes.Ref<Logger> {
        var _l = (stdgo.Go.setRef(({} : stdgo.log.Log.Logger)) : stdgo.StdGoTypes.Ref<stdgo.log.Log.Logger>);
        _l.setOutput(_out);
        _l.setPrefix(_prefix?.__copy__());
        _l.setFlags(_flag);
        return _l;
    }
/**
    // Default returns the standard logger used by the package-level output functions.
**/
function default_():stdgo.StdGoTypes.Ref<Logger> {
        return _std;
    }
/**
    // Cheap integer to fixed-width decimal ASCII. Give a negative width to avoid zero-padding.
**/
function _itoa(_buf:stdgo.StdGoTypes.Ref<stdgo.Slice<stdgo.StdGoTypes.GoByte>>, _i:stdgo.StdGoTypes.GoInt, _wid:stdgo.StdGoTypes.GoInt):Void {
        var _b:stdgo.GoArray<stdgo.StdGoTypes.GoByte> = new stdgo.GoArray<stdgo.StdGoTypes.GoUInt8>(...[for (i in 0 ... 20) (0 : stdgo.StdGoTypes.GoUInt8)]);
        var _bp:stdgo.StdGoTypes.GoInt = (19 : stdgo.StdGoTypes.GoInt);
        while ((_i >= (10 : stdgo.StdGoTypes.GoInt)) || (_wid > (1 : stdgo.StdGoTypes.GoInt))) {
            _wid--;
            var _q:stdgo.StdGoTypes.GoInt = _i / (10 : stdgo.StdGoTypes.GoInt);
            _b[(_bp : stdgo.StdGoTypes.GoInt)] = (((48 : stdgo.StdGoTypes.GoInt) + _i) - (_q * (10 : stdgo.StdGoTypes.GoInt)) : stdgo.StdGoTypes.GoByte);
            _bp--;
            _i = _q;
        };
        _b[(_bp : stdgo.StdGoTypes.GoInt)] = ((48 : stdgo.StdGoTypes.GoInt) + _i : stdgo.StdGoTypes.GoByte);
        _buf.__setData__(((_buf : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>).__append__(...(_b.__slice__(_bp) : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>).__toArray__())));
    }
/**
    // formatHeader writes log header to buf in following order:
    //   - l.prefix (if it's not blank and Lmsgprefix is unset),
    //   - date and/or time (if corresponding flags are provided),
    //   - file and line number (if corresponding flags are provided),
    //   - l.prefix (if it's not blank and Lmsgprefix is set).
**/
function _formatHeader(_buf:stdgo.StdGoTypes.Ref<stdgo.Slice<stdgo.StdGoTypes.GoByte>>, _t:stdgo.time.Time.Time, _prefix:stdgo.GoString, _flag:stdgo.StdGoTypes.GoInt, _file:stdgo.GoString, _line:stdgo.StdGoTypes.GoInt):Void {
        if (_flag & (64 : stdgo.StdGoTypes.GoInt) == ((0 : stdgo.StdGoTypes.GoInt))) {
            _buf.__setData__(((_buf : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>).__append__(..._prefix.__toArray__())));
        };
        if (_flag & (7 : stdgo.StdGoTypes.GoInt) != ((0 : stdgo.StdGoTypes.GoInt))) {
            if (_flag & (32 : stdgo.StdGoTypes.GoInt) != ((0 : stdgo.StdGoTypes.GoInt))) {
                _t = _t.utc()?.__copy__();
            };
            if (_flag & (1 : stdgo.StdGoTypes.GoInt) != ((0 : stdgo.StdGoTypes.GoInt))) {
                var __tmp__ = _t.date(), _year:stdgo.StdGoTypes.GoInt = __tmp__._0, _month:stdgo.time.Time.Month = __tmp__._1, _day:stdgo.StdGoTypes.GoInt = __tmp__._2;
                _itoa(_buf, _year, (4 : stdgo.StdGoTypes.GoInt));
                _buf.__setData__(((_buf : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>).__append__((47 : stdgo.StdGoTypes.GoUInt8))));
                _itoa(_buf, (_month : stdgo.StdGoTypes.GoInt), (2 : stdgo.StdGoTypes.GoInt));
                _buf.__setData__(((_buf : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>).__append__((47 : stdgo.StdGoTypes.GoUInt8))));
                _itoa(_buf, _day, (2 : stdgo.StdGoTypes.GoInt));
                _buf.__setData__(((_buf : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>).__append__((32 : stdgo.StdGoTypes.GoUInt8))));
            };
            if (_flag & (6 : stdgo.StdGoTypes.GoInt) != ((0 : stdgo.StdGoTypes.GoInt))) {
                var __tmp__ = _t.clock(), _hour:stdgo.StdGoTypes.GoInt = __tmp__._0, _min:stdgo.StdGoTypes.GoInt = __tmp__._1, _sec:stdgo.StdGoTypes.GoInt = __tmp__._2;
                _itoa(_buf, _hour, (2 : stdgo.StdGoTypes.GoInt));
                _buf.__setData__(((_buf : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>).__append__((58 : stdgo.StdGoTypes.GoUInt8))));
                _itoa(_buf, _min, (2 : stdgo.StdGoTypes.GoInt));
                _buf.__setData__(((_buf : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>).__append__((58 : stdgo.StdGoTypes.GoUInt8))));
                _itoa(_buf, _sec, (2 : stdgo.StdGoTypes.GoInt));
                if (_flag & (4 : stdgo.StdGoTypes.GoInt) != ((0 : stdgo.StdGoTypes.GoInt))) {
                    _buf.__setData__(((_buf : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>).__append__((46 : stdgo.StdGoTypes.GoUInt8))));
                    _itoa(_buf, _t.nanosecond() / (1000 : stdgo.StdGoTypes.GoInt), (6 : stdgo.StdGoTypes.GoInt));
                };
                _buf.__setData__(((_buf : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>).__append__((32 : stdgo.StdGoTypes.GoUInt8))));
            };
        };
        if (_flag & (24 : stdgo.StdGoTypes.GoInt) != ((0 : stdgo.StdGoTypes.GoInt))) {
            if (_flag & (16 : stdgo.StdGoTypes.GoInt) != ((0 : stdgo.StdGoTypes.GoInt))) {
                var _short:stdgo.GoString = _file?.__copy__();
                {
                    var _i:stdgo.StdGoTypes.GoInt = (_file.length) - (1 : stdgo.StdGoTypes.GoInt);
                    stdgo.Go.cfor(_i > (0 : stdgo.StdGoTypes.GoInt), _i--, {
                        if (_file[(_i : stdgo.StdGoTypes.GoInt)] == ((47 : stdgo.StdGoTypes.GoUInt8))) {
                            _short = (_file.__slice__(_i + (1 : stdgo.StdGoTypes.GoInt)) : stdgo.GoString)?.__copy__();
                            break;
                        };
                    });
                };
                _file = _short?.__copy__();
            };
            _buf.__setData__(((_buf : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>).__append__(..._file.__toArray__())));
            _buf.__setData__(((_buf : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>).__append__((58 : stdgo.StdGoTypes.GoUInt8))));
            _itoa(_buf, _line, (-1 : stdgo.StdGoTypes.GoInt));
            _buf.__setData__(((_buf : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>).__append__(...(": " : stdgo.GoString).__toArray__())));
        };
        if (_flag & (64 : stdgo.StdGoTypes.GoInt) != ((0 : stdgo.StdGoTypes.GoInt))) {
            _buf.__setData__(((_buf : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>).__append__(..._prefix.__toArray__())));
        };
    }
function _getBuffer():stdgo.StdGoTypes.Ref<stdgo.Slice<stdgo.StdGoTypes.GoByte>> {
        var _p = (stdgo.Go.typeAssert((_bufferPool.get() : stdgo.StdGoTypes.Ref<stdgo.Slice<stdgo.StdGoTypes.GoByte>>)) : stdgo.StdGoTypes.Ref<stdgo.Slice<stdgo.StdGoTypes.GoByte>>);
        _p.__setData__((((_p : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>)).__slice__(0, (0 : stdgo.StdGoTypes.GoInt)) : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>));
        return _p;
    }
function _putBuffer(_p:stdgo.StdGoTypes.Ref<stdgo.Slice<stdgo.StdGoTypes.GoByte>>):Void {
        if ((_p : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>).capacity > (65536 : stdgo.StdGoTypes.GoInt)) {
            _p.__setData__((null : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>));
        };
        _bufferPool.put(stdgo.Go.toInterface(_p));
    }
/**
    // SetOutput sets the output destination for the standard logger.
**/
function setOutput(_w:stdgo.io.Io.Writer):Void {
        _std.setOutput(_w);
    }
/**
    // Flags returns the output flags for the standard logger.
    // The flag bits are Ldate, Ltime, and so on.
**/
function flags():stdgo.StdGoTypes.GoInt {
        return _std.flags();
    }
/**
    // SetFlags sets the output flags for the standard logger.
    // The flag bits are Ldate, Ltime, and so on.
**/
function setFlags(_flag:stdgo.StdGoTypes.GoInt):Void {
        _std.setFlags(_flag);
    }
/**
    // Prefix returns the output prefix for the standard logger.
**/
function prefix():stdgo.GoString {
        return _std.prefix()?.__copy__();
    }
/**
    // SetPrefix sets the output prefix for the standard logger.
**/
function setPrefix(_prefix:stdgo.GoString):Void {
        _std.setPrefix(_prefix?.__copy__());
    }
/**
    // Writer returns the output destination for the standard logger.
**/
function writer():stdgo.io.Io.Writer {
        return _std.writer();
    }
/**
    // Print calls Output to print to the standard logger.
    // Arguments are handled in the manner of fmt.Print.
**/
function print(_v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void {
        var _v = new stdgo.Slice<stdgo.StdGoTypes.AnyInterface>(_v.length, 0, ..._v);
        _std._output((0 : stdgo.StdGoTypes.GoUIntptr), (2 : stdgo.StdGoTypes.GoInt), function(_b:stdgo.Slice<stdgo.StdGoTypes.GoByte>):stdgo.Slice<stdgo.StdGoTypes.GoByte> {
            return stdgo.fmt.Fmt.append(_b, ..._v.__toArray__());
        });
    }
/**
    // Printf calls Output to print to the standard logger.
    // Arguments are handled in the manner of fmt.Printf.
**/
function printf(_format:stdgo.GoString, _v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void {
        var _v = new stdgo.Slice<stdgo.StdGoTypes.AnyInterface>(_v.length, 0, ..._v);
        _std._output((0 : stdgo.StdGoTypes.GoUIntptr), (2 : stdgo.StdGoTypes.GoInt), function(_b:stdgo.Slice<stdgo.StdGoTypes.GoByte>):stdgo.Slice<stdgo.StdGoTypes.GoByte> {
            return stdgo.fmt.Fmt.appendf(_b, _format?.__copy__(), ..._v.__toArray__());
        });
    }
/**
    // Println calls Output to print to the standard logger.
    // Arguments are handled in the manner of fmt.Println.
**/
function println(_v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void {
        var _v = new stdgo.Slice<stdgo.StdGoTypes.AnyInterface>(_v.length, 0, ..._v);
        _std._output((0 : stdgo.StdGoTypes.GoUIntptr), (2 : stdgo.StdGoTypes.GoInt), function(_b:stdgo.Slice<stdgo.StdGoTypes.GoByte>):stdgo.Slice<stdgo.StdGoTypes.GoByte> {
            return stdgo.fmt.Fmt.appendln(_b, ..._v.__toArray__());
        });
    }
/**
    // Fatal is equivalent to Print() followed by a call to os.Exit(1).
**/
function fatal(_v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void {
        var _v = new stdgo.Slice<stdgo.StdGoTypes.AnyInterface>(_v.length, 0, ..._v);
        _std.output((2 : stdgo.StdGoTypes.GoInt), stdgo.fmt.Fmt.sprint(..._v.__toArray__())?.__copy__());
        Sys.exit((1 : stdgo.StdGoTypes.GoInt));
    }
/**
    // Fatalf is equivalent to Printf() followed by a call to os.Exit(1).
**/
function fatalf(_format:stdgo.GoString, _v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void {
        var _v = new stdgo.Slice<stdgo.StdGoTypes.AnyInterface>(_v.length, 0, ..._v);
        _std.output((2 : stdgo.StdGoTypes.GoInt), stdgo.fmt.Fmt.sprintf(_format?.__copy__(), ..._v.__toArray__())?.__copy__());
        Sys.exit((1 : stdgo.StdGoTypes.GoInt));
    }
/**
    // Fatalln is equivalent to Println() followed by a call to os.Exit(1).
**/
function fatalln(_v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void {
        var _v = new stdgo.Slice<stdgo.StdGoTypes.AnyInterface>(_v.length, 0, ..._v);
        _std.output((2 : stdgo.StdGoTypes.GoInt), stdgo.fmt.Fmt.sprintln(..._v.__toArray__())?.__copy__());
        Sys.exit((1 : stdgo.StdGoTypes.GoInt));
    }
/**
    // Panic is equivalent to Print() followed by a call to panic().
**/
function panic(_v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void {
        var _v = new stdgo.Slice<stdgo.StdGoTypes.AnyInterface>(_v.length, 0, ..._v);
        var _s:stdgo.GoString = stdgo.fmt.Fmt.sprint(..._v.__toArray__())?.__copy__();
        _std.output((2 : stdgo.StdGoTypes.GoInt), _s?.__copy__());
        throw stdgo.Go.toInterface(_s);
    }
/**
    // Panicf is equivalent to Printf() followed by a call to panic().
**/
function panicf(_format:stdgo.GoString, _v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void {
        var _v = new stdgo.Slice<stdgo.StdGoTypes.AnyInterface>(_v.length, 0, ..._v);
        var _s:stdgo.GoString = stdgo.fmt.Fmt.sprintf(_format?.__copy__(), ..._v.__toArray__())?.__copy__();
        _std.output((2 : stdgo.StdGoTypes.GoInt), _s?.__copy__());
        throw stdgo.Go.toInterface(_s);
    }
/**
    // Panicln is equivalent to Println() followed by a call to panic().
**/
function panicln(_v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void {
        var _v = new stdgo.Slice<stdgo.StdGoTypes.AnyInterface>(_v.length, 0, ..._v);
        var _s:stdgo.GoString = stdgo.fmt.Fmt.sprintln(..._v.__toArray__())?.__copy__();
        _std.output((2 : stdgo.StdGoTypes.GoInt), _s?.__copy__());
        throw stdgo.Go.toInterface(_s);
    }
/**
    // Output writes the output for a logging event. The string s contains
    // the text to print after the prefix specified by the flags of the
    // Logger. A newline is appended if the last character of s is not
    // already a newline. Calldepth is the count of the number of
    // frames to skip when computing the file name and line number
    // if Llongfile or Lshortfile is set; a value of 1 will print the details
    // for the caller of Output.
**/
function output(_calldepth:stdgo.StdGoTypes.GoInt, _s:stdgo.GoString):stdgo.Error {
        return _std.output(_calldepth + (1 : stdgo.StdGoTypes.GoInt), _s?.__copy__());
    }
/**
    // Test using Println("hello", 23, "world") or using Printf("hello %d world", 23)
**/
function _testPrint(_t:stdgo.StdGoTypes.Ref<stdgo.testing.Testing.T>, _flag:stdgo.StdGoTypes.GoInt, _prefix:stdgo.GoString, _pattern:stdgo.GoString, _useFormat:Bool):Void {
        var _buf = (stdgo.Go.setRef(({} : stdgo.strings.Strings.Builder)) : stdgo.StdGoTypes.Ref<stdgo.strings.Strings.Builder>);
        setOutput(stdgo.Go.asInterface(_buf));
        setFlags(_flag);
        setPrefix(_prefix?.__copy__());
        if (_useFormat) {
            printf(("hello %d world" : stdgo.GoString), stdgo.Go.toInterface((23 : stdgo.StdGoTypes.GoInt)));
        } else {
            println(stdgo.Go.toInterface(("hello" : stdgo.GoString)), stdgo.Go.toInterface((23 : stdgo.StdGoTypes.GoInt)), stdgo.Go.toInterface(("world" : stdgo.GoString)));
        };
        var _line:stdgo.GoString = (_buf.string() : stdgo.GoString)?.__copy__();
        _line = (_line.__slice__((0 : stdgo.StdGoTypes.GoInt), (_line.length) - (1 : stdgo.StdGoTypes.GoInt)) : stdgo.GoString)?.__copy__();
        _pattern = ("^" : stdgo.GoString) + _pattern?.__copy__() + ("hello 23 world$" : stdgo.GoString)?.__copy__()?.__copy__();
        var __tmp__ = stdgo.regexp.Regexp.matchString(_pattern?.__copy__(), _line?.__copy__()), _matched:Bool = __tmp__._0, _err:stdgo.Error = __tmp__._1;
        if (_err != null) {
            _t.fatal(stdgo.Go.toInterface(("pattern did not compile:" : stdgo.GoString)), stdgo.Go.toInterface(_err));
        };
        if (!_matched) {
            _t.errorf(("log output should match %q is %q" : stdgo.GoString), stdgo.Go.toInterface(_pattern), stdgo.Go.toInterface(_line));
        };
        setOutput(stdgo.Go.asInterface(stdgo.os.Os.stderr));
    }
function testDefault(_t:stdgo.StdGoTypes.Ref<stdgo.testing.Testing.T>):Void {
        {
            var _got = default_();
            if (_got != (_std)) {
                _t.errorf(("Default [%p] should be std [%p]" : stdgo.GoString), stdgo.Go.toInterface(stdgo.Go.asInterface(_got)), stdgo.Go.toInterface(stdgo.Go.asInterface(_std)));
            };
        };
    }
function testAll(_t:stdgo.StdGoTypes.Ref<stdgo.testing.Testing.T>):Void {
        for (__8 => _testcase in _tests) {
            _testPrint(_t, _testcase._flag, _testcase._prefix?.__copy__(), _testcase._pattern?.__copy__(), false);
            _testPrint(_t, _testcase._flag, _testcase._prefix?.__copy__(), _testcase._pattern?.__copy__(), true);
        };
    }
function testOutput(_t:stdgo.StdGoTypes.Ref<stdgo.testing.Testing.T>):Void {
        {};
        var _b:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
        var _l = new_(stdgo.Go.asInterface((stdgo.Go.setRef(_b) : stdgo.StdGoTypes.Ref<stdgo.strings.Strings.Builder>)), stdgo.Go.str()?.__copy__(), (0 : stdgo.StdGoTypes.GoInt));
        _l.println(stdgo.Go.toInterface(("test" : stdgo.GoString)));
        {
            var _expect:stdgo.GoString = ("test\n" : stdgo.GoString);
            if ((_b.string() : stdgo.GoString) != (_expect)) {
                _t.errorf(("log output should match %q is %q" : stdgo.GoString), stdgo.Go.toInterface(_expect), stdgo.Go.toInterface((_b.string() : stdgo.GoString)));
            };
        };
    }
function testNonNewLogger(_t:stdgo.StdGoTypes.Ref<stdgo.testing.Testing.T>):Void {
        var _l:Logger = ({} : stdgo.log.Log.Logger);
        _l.setOutput(stdgo.Go.asInterface((stdgo.Go.setRef(({} : stdgo.bytes.Bytes.Buffer)) : stdgo.StdGoTypes.Ref<stdgo.bytes.Bytes.Buffer>)));
        _l.print(stdgo.Go.toInterface(("hello" : stdgo.GoString)));
    }
function testOutputRace(_t:stdgo.StdGoTypes.Ref<stdgo.testing.Testing.T>):Void {
        var _b:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        var _l = new_(stdgo.Go.asInterface((stdgo.Go.setRef(_b) : stdgo.StdGoTypes.Ref<stdgo.bytes.Bytes.Buffer>)), stdgo.Go.str()?.__copy__(), (0 : stdgo.StdGoTypes.GoInt));
        var _wg:stdgo.sync.Sync.WaitGroup = ({} : stdgo.sync.Sync.WaitGroup);
        _wg.add((100 : stdgo.StdGoTypes.GoInt));
        {
            var _i:stdgo.StdGoTypes.GoInt = (0 : stdgo.StdGoTypes.GoInt);
            stdgo.Go.cfor(_i < (100 : stdgo.StdGoTypes.GoInt), _i++, {
                stdgo.Go.routine(() -> {
                    var a = function():Void {
                        var __deferstack__:Array<Void -> Void> = [];
                        try {
                            __deferstack__.unshift(() -> _wg.done());
                            _l.setFlags((0 : stdgo.StdGoTypes.GoInt));
                            _l.output((0 : stdgo.StdGoTypes.GoInt), stdgo.Go.str()?.__copy__());
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                                return;
                            };
                        } catch(__exception__) {
                            var exe:Dynamic = __exception__.native;
                            if ((exe is haxe.ValueException)) exe = exe.value;
                            if (!(exe is stdgo.StdGoTypes.AnyInterfaceData)) {
                                exe = stdgo.Go.toInterface(__exception__.message);
                            };
                            stdgo.Go.recover_exception = exe;
                            for (defer in __deferstack__) {
                                defer();
                            };
                            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                            return;
                        };
                    };
                    a();
                });
            });
        };
        _wg.wait_();
    }
function testFlagAndPrefixSetting(_t:stdgo.StdGoTypes.Ref<stdgo.testing.Testing.T>):Void {
        var _b:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        var _l = new_(stdgo.Go.asInterface((stdgo.Go.setRef(_b) : stdgo.StdGoTypes.Ref<stdgo.bytes.Bytes.Buffer>)), ("Test:" : stdgo.GoString), (3 : stdgo.StdGoTypes.GoInt));
        var _f:stdgo.StdGoTypes.GoInt = _l.flags();
        if (_f != ((3 : stdgo.StdGoTypes.GoInt))) {
            _t.errorf(("Flags 1: expected %x got %x" : stdgo.GoString), stdgo.Go.toInterface((3 : stdgo.StdGoTypes.GoInt)), stdgo.Go.toInterface(_f));
        };
        _l.setFlags(_f | (4 : stdgo.StdGoTypes.GoInt));
        _f = _l.flags();
        if (_f != ((7 : stdgo.StdGoTypes.GoInt))) {
            _t.errorf(("Flags 2: expected %x got %x" : stdgo.GoString), stdgo.Go.toInterface((7 : stdgo.StdGoTypes.GoInt)), stdgo.Go.toInterface(_f));
        };
        var _p:stdgo.GoString = _l.prefix()?.__copy__();
        if (_p != (("Test:" : stdgo.GoString))) {
            _t.errorf(("Prefix: expected \"Test:\" got %q" : stdgo.GoString), stdgo.Go.toInterface(_p));
        };
        _l.setPrefix(("Reality:" : stdgo.GoString));
        _p = _l.prefix()?.__copy__();
        if (_p != (("Reality:" : stdgo.GoString))) {
            _t.errorf(("Prefix: expected \"Reality:\" got %q" : stdgo.GoString), stdgo.Go.toInterface(_p));
        };
        _l.print(stdgo.Go.toInterface(("hello" : stdgo.GoString)));
        var _pattern:stdgo.GoString = ("^Reality:[0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9]\\.[0-9][0-9][0-9][0-9][0-9][0-9] hello\n" : stdgo.GoString);
        var __tmp__ = stdgo.regexp.Regexp.match(_pattern?.__copy__(), _b.bytes()), _matched:Bool = __tmp__._0, _err:stdgo.Error = __tmp__._1;
        if (_err != null) {
            _t.fatalf(("pattern %q did not compile: %s" : stdgo.GoString), stdgo.Go.toInterface(_pattern), stdgo.Go.toInterface(_err));
        };
        if (!_matched) {
            _t.error(stdgo.Go.toInterface(("message did not match pattern" : stdgo.GoString)));
        };
        _b.reset();
        _l.setFlags((0 : stdgo.StdGoTypes.GoInt));
        _l.setPrefix(("\n" : stdgo.GoString));
        _l.output((0 : stdgo.StdGoTypes.GoInt), stdgo.Go.str()?.__copy__());
        {
            var _got:stdgo.GoString = (_b.string() : stdgo.GoString)?.__copy__();
            if (_got != (("\n" : stdgo.GoString))) {
                _t.errorf(("message mismatch:\ngot  %q\nwant %q" : stdgo.GoString), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(("\n" : stdgo.GoString)));
            };
        };
    }
function testUTCFlag(_t:stdgo.StdGoTypes.Ref<stdgo.testing.Testing.T>):Void {
        var _b:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
        var _l = new_(stdgo.Go.asInterface((stdgo.Go.setRef(_b) : stdgo.StdGoTypes.Ref<stdgo.strings.Strings.Builder>)), ("Test:" : stdgo.GoString), (3 : stdgo.StdGoTypes.GoInt));
        _l.setFlags((35 : stdgo.StdGoTypes.GoInt));
        var _now:stdgo.time.Time.Time = stdgo.time.Time.now().utc()?.__copy__();
        _l.print(stdgo.Go.toInterface(("hello" : stdgo.GoString)));
        var _want:stdgo.GoString = stdgo.fmt.Fmt.sprintf(("Test:%d/%.2d/%.2d %.2d:%.2d:%.2d hello\n" : stdgo.GoString), stdgo.Go.toInterface(_now.year()), stdgo.Go.toInterface(stdgo.Go.asInterface(_now.month())), stdgo.Go.toInterface(_now.day()), stdgo.Go.toInterface(_now.hour()), stdgo.Go.toInterface(_now.minute()), stdgo.Go.toInterface(_now.second()))?.__copy__();
        var _got:stdgo.GoString = (_b.string() : stdgo.GoString)?.__copy__();
        if (_got == (_want)) {
            return;
        };
        _now = _now.add((1000000000i64 : stdgo.time.Time.Duration))?.__copy__();
        _want = stdgo.fmt.Fmt.sprintf(("Test:%d/%.2d/%.2d %.2d:%.2d:%.2d hello\n" : stdgo.GoString), stdgo.Go.toInterface(_now.year()), stdgo.Go.toInterface(stdgo.Go.asInterface(_now.month())), stdgo.Go.toInterface(_now.day()), stdgo.Go.toInterface(_now.hour()), stdgo.Go.toInterface(_now.minute()), stdgo.Go.toInterface(_now.second()))?.__copy__();
        if (_got == (_want)) {
            return;
        };
        _t.errorf(("got %q; want %q" : stdgo.GoString), stdgo.Go.toInterface(_got), stdgo.Go.toInterface(_want));
    }
function testEmptyPrintCreatesLine(_t:stdgo.StdGoTypes.Ref<stdgo.testing.Testing.T>):Void {
        var _b:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
        var _l = new_(stdgo.Go.asInterface((stdgo.Go.setRef(_b) : stdgo.StdGoTypes.Ref<stdgo.strings.Strings.Builder>)), ("Header:" : stdgo.GoString), (3 : stdgo.StdGoTypes.GoInt));
        _l.print();
        _l.println(stdgo.Go.toInterface(("non-empty" : stdgo.GoString)));
        var _output:stdgo.GoString = (_b.string() : stdgo.GoString)?.__copy__();
        {
            var _n:stdgo.StdGoTypes.GoInt = stdgo.strings.Strings.count(_output?.__copy__(), ("Header" : stdgo.GoString));
            if (_n != ((2 : stdgo.StdGoTypes.GoInt))) {
                _t.errorf(("expected 2 headers, got %d" : stdgo.GoString), stdgo.Go.toInterface(_n));
            };
        };
        {
            var _n:stdgo.StdGoTypes.GoInt = stdgo.strings.Strings.count(_output?.__copy__(), ("\n" : stdgo.GoString));
            if (_n != ((2 : stdgo.StdGoTypes.GoInt))) {
                _t.errorf(("expected 2 lines, got %d" : stdgo.GoString), stdgo.Go.toInterface(_n));
            };
        };
    }
function testDiscard(_t:stdgo.StdGoTypes.Ref<stdgo.testing.Testing.T>):Void {
        var _l = new_(stdgo.io.Io.discard, stdgo.Go.str()?.__copy__(), (0 : stdgo.StdGoTypes.GoInt));
        var _s:stdgo.GoString = stdgo.strings.Strings.repeat(("a" : stdgo.GoString), (102400 : stdgo.StdGoTypes.GoInt))?.__copy__();
        var _c:stdgo.StdGoTypes.GoFloat64 = stdgo.testing.Testing.allocsPerRun((100 : stdgo.StdGoTypes.GoInt), function():Void {
            _l.printf(("%s" : stdgo.GoString), stdgo.Go.toInterface(_s));
        });
        if (_c > (1 : stdgo.StdGoTypes.GoFloat64)) {
            _t.errorf(("got %v allocs, want at most 1" : stdgo.GoString), stdgo.Go.toInterface(_c));
        };
    }
function benchmarkItoa(_b:stdgo.StdGoTypes.Ref<stdgo.testing.Testing.B>):Void {
        var _dst = new stdgo.Slice<stdgo.StdGoTypes.GoUInt8>((0 : stdgo.StdGoTypes.GoInt).toBasic(), (64 : stdgo.StdGoTypes.GoInt)).__setNumber32__();
        {
            var _i:stdgo.StdGoTypes.GoInt = (0 : stdgo.StdGoTypes.GoInt);
            stdgo.Go.cfor(_i < _b.n, _i++, {
                _dst = (_dst.__slice__((0 : stdgo.StdGoTypes.GoInt), (0 : stdgo.StdGoTypes.GoInt)) : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>);
                _itoa((stdgo.Go.setRef(_dst) : stdgo.StdGoTypes.Ref<stdgo.Slice<stdgo.StdGoTypes.GoUInt8>>), (2015 : stdgo.StdGoTypes.GoInt), (4 : stdgo.StdGoTypes.GoInt));
                _itoa((stdgo.Go.setRef(_dst) : stdgo.StdGoTypes.Ref<stdgo.Slice<stdgo.StdGoTypes.GoUInt8>>), (1 : stdgo.StdGoTypes.GoInt), (2 : stdgo.StdGoTypes.GoInt));
                _itoa((stdgo.Go.setRef(_dst) : stdgo.StdGoTypes.Ref<stdgo.Slice<stdgo.StdGoTypes.GoUInt8>>), (30 : stdgo.StdGoTypes.GoInt), (2 : stdgo.StdGoTypes.GoInt));
                _itoa((stdgo.Go.setRef(_dst) : stdgo.StdGoTypes.Ref<stdgo.Slice<stdgo.StdGoTypes.GoUInt8>>), (12 : stdgo.StdGoTypes.GoInt), (2 : stdgo.StdGoTypes.GoInt));
                _itoa((stdgo.Go.setRef(_dst) : stdgo.StdGoTypes.Ref<stdgo.Slice<stdgo.StdGoTypes.GoUInt8>>), (56 : stdgo.StdGoTypes.GoInt), (2 : stdgo.StdGoTypes.GoInt));
                _itoa((stdgo.Go.setRef(_dst) : stdgo.StdGoTypes.Ref<stdgo.Slice<stdgo.StdGoTypes.GoUInt8>>), (0 : stdgo.StdGoTypes.GoInt), (2 : stdgo.StdGoTypes.GoInt));
                _itoa((stdgo.Go.setRef(_dst) : stdgo.StdGoTypes.Ref<stdgo.Slice<stdgo.StdGoTypes.GoUInt8>>), (987654 : stdgo.StdGoTypes.GoInt), (6 : stdgo.StdGoTypes.GoInt));
            });
        };
    }
function benchmarkPrintln(_b:stdgo.StdGoTypes.Ref<stdgo.testing.Testing.B>):Void {
        {};
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        var _l = new_(stdgo.Go.asInterface((stdgo.Go.setRef(_buf) : stdgo.StdGoTypes.Ref<stdgo.bytes.Bytes.Buffer>)), stdgo.Go.str()?.__copy__(), (3 : stdgo.StdGoTypes.GoInt));
        _b.reportAllocs();
        {
            var _i:stdgo.StdGoTypes.GoInt = (0 : stdgo.StdGoTypes.GoInt);
            stdgo.Go.cfor(_i < _b.n, _i++, {
                _buf.reset();
                _l.println(stdgo.Go.toInterface(("test" : stdgo.GoString)));
            });
        };
    }
function benchmarkPrintlnNoFlags(_b:stdgo.StdGoTypes.Ref<stdgo.testing.Testing.B>):Void {
        {};
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        var _l = new_(stdgo.Go.asInterface((stdgo.Go.setRef(_buf) : stdgo.StdGoTypes.Ref<stdgo.bytes.Bytes.Buffer>)), stdgo.Go.str()?.__copy__(), (0 : stdgo.StdGoTypes.GoInt));
        _b.reportAllocs();
        {
            var _i:stdgo.StdGoTypes.GoInt = (0 : stdgo.StdGoTypes.GoInt);
            stdgo.Go.cfor(_i < _b.n, _i++, {
                _buf.reset();
                _l.println(stdgo.Go.toInterface(("test" : stdgo.GoString)));
            });
        };
    }
function benchmarkConcurrent(_b:stdgo.StdGoTypes.Ref<stdgo.testing.Testing.B>):Void {
        var _l = new_(stdgo.Go.asInterface((new stdgo.log.Log.T_discard() : stdgo.log.Log.T_discard)), ("prefix: " : stdgo.GoString), (79 : stdgo.StdGoTypes.GoInt));
        var _group:stdgo.sync.Sync.WaitGroup = ({} : stdgo.sync.Sync.WaitGroup);
        {
            var _i:stdgo.StdGoTypes.GoInt = stdgo.runtime.Runtime.numCPU();
            stdgo.Go.cfor(_i > (0 : stdgo.StdGoTypes.GoInt), _i--, {
                _group.add((1 : stdgo.StdGoTypes.GoInt));
                stdgo.Go.routine(() -> {
                    var a = function():Void {
                        var __deferstack__:Array<Void -> Void> = [];
                        try {
                            {
                                var _i:stdgo.StdGoTypes.GoInt = (0 : stdgo.StdGoTypes.GoInt);
                                stdgo.Go.cfor(_i < _b.n, _i++, {
                                    _l.output((0 : stdgo.StdGoTypes.GoInt), ("hello, world!" : stdgo.GoString));
                                });
                            };
                            __deferstack__.unshift(() -> _group.done());
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                                return;
                            };
                        } catch(__exception__) {
                            var exe:Dynamic = __exception__.native;
                            if ((exe is haxe.ValueException)) exe = exe.value;
                            if (!(exe is stdgo.StdGoTypes.AnyInterfaceData)) {
                                exe = stdgo.Go.toInterface(__exception__.message);
                            };
                            stdgo.Go.recover_exception = exe;
                            for (defer in __deferstack__) {
                                defer();
                            };
                            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                            return;
                        };
                    };
                    a();
                });
            });
        };
        _group.wait_();
    }
function benchmarkDiscard(_b:stdgo.StdGoTypes.Ref<stdgo.testing.Testing.B>):Void {
        var _l = new_(stdgo.io.Io.discard, stdgo.Go.str()?.__copy__(), (19 : stdgo.StdGoTypes.GoInt));
        _b.reportAllocs();
        {
            var _i:stdgo.StdGoTypes.GoInt = (0 : stdgo.StdGoTypes.GoInt);
            stdgo.Go.cfor(_i < _b.n, _i++, {
                _l.printf(("processing %d objects from bucket %q" : stdgo.GoString), stdgo.Go.toInterface((1234 : stdgo.StdGoTypes.GoInt)), stdgo.Go.toInterface(("fizzbuzz" : stdgo.GoString)));
            });
        };
    }
@:keep var _ = {
        try {
            stdgo.log.internal.Internal.defaultOutput = function(_pc:stdgo.StdGoTypes.GoUIntptr, _data:stdgo.Slice<stdgo.StdGoTypes.GoByte>):stdgo.Error {
                return _std._output(_pc, (0 : stdgo.StdGoTypes.GoInt), function(_buf:stdgo.Slice<stdgo.StdGoTypes.GoByte>):stdgo.Slice<stdgo.StdGoTypes.GoByte> {
                    return (_buf.__append__(..._data.__toArray__()));
                });
            };
        } catch(__exception__) if (__exception__.message != "__return__") throw __exception__;
        true;
    };
class Logger_asInterface {
    /**
        // Writer returns the output destination for the logger.
    **/
    @:keep
    public dynamic function writer():stdgo.io.Io.Writer return __self__.value.writer();
    /**
        // SetPrefix sets the output prefix for the logger.
    **/
    @:keep
    public dynamic function setPrefix(_prefix:stdgo.GoString):Void __self__.value.setPrefix(_prefix);
    /**
        // Prefix returns the output prefix for the logger.
    **/
    @:keep
    public dynamic function prefix():stdgo.GoString return __self__.value.prefix();
    /**
        // SetFlags sets the output flags for the logger.
        // The flag bits are Ldate, Ltime, and so on.
    **/
    @:keep
    public dynamic function setFlags(_flag:stdgo.StdGoTypes.GoInt):Void __self__.value.setFlags(_flag);
    /**
        // Flags returns the output flags for the logger.
        // The flag bits are Ldate, Ltime, and so on.
    **/
    @:keep
    public dynamic function flags():stdgo.StdGoTypes.GoInt return __self__.value.flags();
    /**
        // Panicln is equivalent to l.Println() followed by a call to panic().
    **/
    @:keep
    public dynamic function panicln(_v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void __self__.value.panicln(..._v);
    /**
        // Panicf is equivalent to l.Printf() followed by a call to panic().
    **/
    @:keep
    public dynamic function panicf(_format:stdgo.GoString, _v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void __self__.value.panicf(_format, ..._v);
    /**
        // Panic is equivalent to l.Print() followed by a call to panic().
    **/
    @:keep
    public dynamic function panic(_v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void __self__.value.panic(..._v);
    /**
        // Fatalln is equivalent to l.Println() followed by a call to os.Exit(1).
    **/
    @:keep
    public dynamic function fatalln(_v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void __self__.value.fatalln(..._v);
    /**
        // Fatalf is equivalent to l.Printf() followed by a call to os.Exit(1).
    **/
    @:keep
    public dynamic function fatalf(_format:stdgo.GoString, _v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void __self__.value.fatalf(_format, ..._v);
    /**
        // Fatal is equivalent to l.Print() followed by a call to os.Exit(1).
    **/
    @:keep
    public dynamic function fatal(_v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void __self__.value.fatal(..._v);
    /**
        // Println calls l.Output to print to the logger.
        // Arguments are handled in the manner of fmt.Println.
    **/
    @:keep
    public dynamic function println(_v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void __self__.value.println(..._v);
    /**
        // Printf calls l.Output to print to the logger.
        // Arguments are handled in the manner of fmt.Printf.
    **/
    @:keep
    public dynamic function printf(_format:stdgo.GoString, _v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void __self__.value.printf(_format, ..._v);
    /**
        // Print calls l.Output to print to the logger.
        // Arguments are handled in the manner of fmt.Print.
    **/
    @:keep
    public dynamic function print(_v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void __self__.value.print(..._v);
    /**
        // output can take either a calldepth or a pc to get source line information.
        // It uses the pc if it is non-zero.
    **/
    @:keep
    public dynamic function _output(_pc:stdgo.StdGoTypes.GoUIntptr, _calldepth:stdgo.StdGoTypes.GoInt, _appendOutput:stdgo.Slice<stdgo.StdGoTypes.GoByte> -> stdgo.Slice<stdgo.StdGoTypes.GoByte>):stdgo.Error return __self__.value._output(_pc, _calldepth, _appendOutput);
    /**
        // Output writes the output for a logging event. The string s contains
        // the text to print after the prefix specified by the flags of the
        // Logger. A newline is appended if the last character of s is not
        // already a newline. Calldepth is used to recover the PC and is
        // provided for generality, although at the moment on all pre-defined
        // paths it will be 2.
    **/
    @:keep
    public dynamic function output(_calldepth:stdgo.StdGoTypes.GoInt, _s:stdgo.GoString):stdgo.Error return __self__.value.output(_calldepth, _s);
    /**
        // SetOutput sets the output destination for the logger.
    **/
    @:keep
    public dynamic function setOutput(_w:stdgo.io.Io.Writer):Void __self__.value.setOutput(_w);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.StdGoTypes.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Logger>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.log.Log.Logger_asInterface) class Logger_static_extension {
    /**
        // Writer returns the output destination for the logger.
    **/
    @:keep
    static public function writer( _l:stdgo.StdGoTypes.Ref<Logger>):stdgo.io.Io.Writer {
        @:recv var _l:stdgo.StdGoTypes.Ref<Logger> = _l;
        var __deferstack__:Array<Void -> Void> = [];
        _l._outMu.lock();
        try {
            __deferstack__.unshift(() -> _l._outMu.unlock());
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _l._out;
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return (null : stdgo.io.Io.Writer);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.StdGoTypes.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return (null : stdgo.io.Io.Writer);
        };
    }
    /**
        // SetPrefix sets the output prefix for the logger.
    **/
    @:keep
    static public function setPrefix( _l:stdgo.StdGoTypes.Ref<Logger>, _prefix:stdgo.GoString):Void {
        @:recv var _l:stdgo.StdGoTypes.Ref<Logger> = _l;
        _l._prefix.store(("" : stdgo.GoString), stdgo.Go.pointer(_prefix));
    }
    /**
        // Prefix returns the output prefix for the logger.
    **/
    @:keep
    static public function prefix( _l:stdgo.StdGoTypes.Ref<Logger>):stdgo.GoString {
        @:recv var _l:stdgo.StdGoTypes.Ref<Logger> = _l;
        {
            var _p = _l._prefix.load(("" : stdgo.GoString));
            if (_p != null) {
                return _p.value?.__copy__();
            };
        };
        return stdgo.Go.str()?.__copy__();
    }
    /**
        // SetFlags sets the output flags for the logger.
        // The flag bits are Ldate, Ltime, and so on.
    **/
    @:keep
    static public function setFlags( _l:stdgo.StdGoTypes.Ref<Logger>, _flag:stdgo.StdGoTypes.GoInt):Void {
        @:recv var _l:stdgo.StdGoTypes.Ref<Logger> = _l;
        _l._flag.store((_flag : stdgo.StdGoTypes.GoInt32));
    }
    /**
        // Flags returns the output flags for the logger.
        // The flag bits are Ldate, Ltime, and so on.
    **/
    @:keep
    static public function flags( _l:stdgo.StdGoTypes.Ref<Logger>):stdgo.StdGoTypes.GoInt {
        @:recv var _l:stdgo.StdGoTypes.Ref<Logger> = _l;
        return (_l._flag.load() : stdgo.StdGoTypes.GoInt);
    }
    /**
        // Panicln is equivalent to l.Println() followed by a call to panic().
    **/
    @:keep
    static public function panicln( _l:stdgo.StdGoTypes.Ref<Logger>, _v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void {
        var _v = new stdgo.Slice<stdgo.StdGoTypes.AnyInterface>(_v.length, 0, ..._v);
        @:recv var _l:stdgo.StdGoTypes.Ref<Logger> = _l;
        var _s:stdgo.GoString = stdgo.fmt.Fmt.sprintln(..._v.__toArray__())?.__copy__();
        _l.output((2 : stdgo.StdGoTypes.GoInt), _s?.__copy__());
        throw stdgo.Go.toInterface(_s);
    }
    /**
        // Panicf is equivalent to l.Printf() followed by a call to panic().
    **/
    @:keep
    static public function panicf( _l:stdgo.StdGoTypes.Ref<Logger>, _format:stdgo.GoString, _v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void {
        var _v = new stdgo.Slice<stdgo.StdGoTypes.AnyInterface>(_v.length, 0, ..._v);
        @:recv var _l:stdgo.StdGoTypes.Ref<Logger> = _l;
        var _s:stdgo.GoString = stdgo.fmt.Fmt.sprintf(_format?.__copy__(), ..._v.__toArray__())?.__copy__();
        _l.output((2 : stdgo.StdGoTypes.GoInt), _s?.__copy__());
        throw stdgo.Go.toInterface(_s);
    }
    /**
        // Panic is equivalent to l.Print() followed by a call to panic().
    **/
    @:keep
    static public function panic( _l:stdgo.StdGoTypes.Ref<Logger>, _v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void {
        var _v = new stdgo.Slice<stdgo.StdGoTypes.AnyInterface>(_v.length, 0, ..._v);
        @:recv var _l:stdgo.StdGoTypes.Ref<Logger> = _l;
        var _s:stdgo.GoString = stdgo.fmt.Fmt.sprint(..._v.__toArray__())?.__copy__();
        _l.output((2 : stdgo.StdGoTypes.GoInt), _s?.__copy__());
        throw stdgo.Go.toInterface(_s);
    }
    /**
        // Fatalln is equivalent to l.Println() followed by a call to os.Exit(1).
    **/
    @:keep
    static public function fatalln( _l:stdgo.StdGoTypes.Ref<Logger>, _v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void {
        var _v = new stdgo.Slice<stdgo.StdGoTypes.AnyInterface>(_v.length, 0, ..._v);
        @:recv var _l:stdgo.StdGoTypes.Ref<Logger> = _l;
        _l.output((2 : stdgo.StdGoTypes.GoInt), stdgo.fmt.Fmt.sprintln(..._v.__toArray__())?.__copy__());
        Sys.exit((1 : stdgo.StdGoTypes.GoInt));
    }
    /**
        // Fatalf is equivalent to l.Printf() followed by a call to os.Exit(1).
    **/
    @:keep
    static public function fatalf( _l:stdgo.StdGoTypes.Ref<Logger>, _format:stdgo.GoString, _v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void {
        var _v = new stdgo.Slice<stdgo.StdGoTypes.AnyInterface>(_v.length, 0, ..._v);
        @:recv var _l:stdgo.StdGoTypes.Ref<Logger> = _l;
        _l.output((2 : stdgo.StdGoTypes.GoInt), stdgo.fmt.Fmt.sprintf(_format?.__copy__(), ..._v.__toArray__())?.__copy__());
        Sys.exit((1 : stdgo.StdGoTypes.GoInt));
    }
    /**
        // Fatal is equivalent to l.Print() followed by a call to os.Exit(1).
    **/
    @:keep
    static public function fatal( _l:stdgo.StdGoTypes.Ref<Logger>, _v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void {
        var _v = new stdgo.Slice<stdgo.StdGoTypes.AnyInterface>(_v.length, 0, ..._v);
        @:recv var _l:stdgo.StdGoTypes.Ref<Logger> = _l;
        _l.output((2 : stdgo.StdGoTypes.GoInt), stdgo.fmt.Fmt.sprint(..._v.__toArray__())?.__copy__());
        Sys.exit((1 : stdgo.StdGoTypes.GoInt));
    }
    /**
        // Println calls l.Output to print to the logger.
        // Arguments are handled in the manner of fmt.Println.
    **/
    @:keep
    static public function println( _l:stdgo.StdGoTypes.Ref<Logger>, _v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void {
        var _v = new stdgo.Slice<stdgo.StdGoTypes.AnyInterface>(_v.length, 0, ..._v);
        @:recv var _l:stdgo.StdGoTypes.Ref<Logger> = _l;
        _l._output((0 : stdgo.StdGoTypes.GoUIntptr), (2 : stdgo.StdGoTypes.GoInt), function(_b:stdgo.Slice<stdgo.StdGoTypes.GoByte>):stdgo.Slice<stdgo.StdGoTypes.GoByte> {
            return stdgo.fmt.Fmt.appendln(_b, ..._v.__toArray__());
        });
    }
    /**
        // Printf calls l.Output to print to the logger.
        // Arguments are handled in the manner of fmt.Printf.
    **/
    @:keep
    static public function printf( _l:stdgo.StdGoTypes.Ref<Logger>, _format:stdgo.GoString, _v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void {
        var _v = new stdgo.Slice<stdgo.StdGoTypes.AnyInterface>(_v.length, 0, ..._v);
        @:recv var _l:stdgo.StdGoTypes.Ref<Logger> = _l;
        _l._output((0 : stdgo.StdGoTypes.GoUIntptr), (2 : stdgo.StdGoTypes.GoInt), function(_b:stdgo.Slice<stdgo.StdGoTypes.GoByte>):stdgo.Slice<stdgo.StdGoTypes.GoByte> {
            return stdgo.fmt.Fmt.appendf(_b, _format?.__copy__(), ..._v.__toArray__());
        });
    }
    /**
        // Print calls l.Output to print to the logger.
        // Arguments are handled in the manner of fmt.Print.
    **/
    @:keep
    static public function print( _l:stdgo.StdGoTypes.Ref<Logger>, _v:haxe.Rest<stdgo.StdGoTypes.AnyInterface>):Void {
        var _v = new stdgo.Slice<stdgo.StdGoTypes.AnyInterface>(_v.length, 0, ..._v);
        @:recv var _l:stdgo.StdGoTypes.Ref<Logger> = _l;
        _l._output((0 : stdgo.StdGoTypes.GoUIntptr), (2 : stdgo.StdGoTypes.GoInt), function(_b:stdgo.Slice<stdgo.StdGoTypes.GoByte>):stdgo.Slice<stdgo.StdGoTypes.GoByte> {
            return stdgo.fmt.Fmt.append(_b, ..._v.__toArray__());
        });
    }
    /**
        // output can take either a calldepth or a pc to get source line information.
        // It uses the pc if it is non-zero.
    **/
    @:keep
    static public function _output( _l:stdgo.StdGoTypes.Ref<Logger>, _pc:stdgo.StdGoTypes.GoUIntptr, _calldepth:stdgo.StdGoTypes.GoInt, _appendOutput:stdgo.Slice<stdgo.StdGoTypes.GoByte> -> stdgo.Slice<stdgo.StdGoTypes.GoByte>):stdgo.Error {
        @:recv var _l:stdgo.StdGoTypes.Ref<Logger> = _l;
        var __deferstack__:Array<Void -> Void> = [];
        if (_l._isDiscard.load()) {
            return (null : stdgo.Error);
        };
        try {
            var _now:stdgo.time.Time.Time = stdgo.time.Time.now()?.__copy__();
            var _prefix:stdgo.GoString = _l.prefix()?.__copy__();
            var _flag:stdgo.StdGoTypes.GoInt = _l.flags();
            var _file:stdgo.GoString = ("" : stdgo.GoString);
            var _line:stdgo.StdGoTypes.GoInt = (0 : stdgo.StdGoTypes.GoInt);
            if (_flag & (24 : stdgo.StdGoTypes.GoInt) != ((0 : stdgo.StdGoTypes.GoInt))) {
                if (_pc == ((0 : stdgo.StdGoTypes.GoUIntptr))) {
                    var _ok:Bool = false;
                    {
                        var __tmp__ = stdgo.runtime.Runtime.caller(_calldepth);
                        _file = __tmp__._1?.__copy__();
                        _line = __tmp__._2;
                        _ok = __tmp__._3;
                    };
                    if (!_ok) {
                        _file = ("???" : stdgo.GoString);
                        _line = (0 : stdgo.StdGoTypes.GoInt);
                    };
                } else {
                    var _fs = stdgo.runtime.Runtime.callersFrames((new stdgo.Slice<stdgo.StdGoTypes.GoUIntptr>(1, 1, _pc) : stdgo.Slice<stdgo.StdGoTypes.GoUIntptr>));
                    var __tmp__ = _fs.next(), _f:stdgo.runtime.Runtime.Frame = __tmp__._0, __35:Bool = __tmp__._1;
                    _file = _f.file?.__copy__();
                    if (_file == (stdgo.Go.str())) {
                        _file = ("???" : stdgo.GoString);
                    };
                    _line = _f.line;
                };
            };
            var _buf = _getBuffer();
            {
                var _a0 = _buf;
                __deferstack__.unshift(() -> _putBuffer(_a0));
            };
            _formatHeader(_buf, _now?.__copy__(), _prefix?.__copy__(), _flag, _file?.__copy__(), _line);
            _buf.__setData__(_appendOutput((_buf : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>)));
            if (((_buf : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>).length == (0 : stdgo.StdGoTypes.GoInt)) || (((_buf : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>))[(((_buf : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>).length) - (1 : stdgo.StdGoTypes.GoInt) : stdgo.StdGoTypes.GoInt)] != (10 : stdgo.StdGoTypes.GoUInt8))) {
                _buf.__setData__(((_buf : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>).__append__((10 : stdgo.StdGoTypes.GoUInt8))));
            };
            _l._outMu.lock();
            __deferstack__.unshift(() -> _l._outMu.unlock());
            var __tmp__ = _l._out.write((_buf : stdgo.Slice<stdgo.StdGoTypes.GoUInt8>)), __72:stdgo.StdGoTypes.GoInt = __tmp__._0, _err:stdgo.Error = __tmp__._1;
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _err;
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return (null : stdgo.Error);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.StdGoTypes.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return (null : stdgo.Error);
        };
    }
    /**
        // Output writes the output for a logging event. The string s contains
        // the text to print after the prefix specified by the flags of the
        // Logger. A newline is appended if the last character of s is not
        // already a newline. Calldepth is used to recover the PC and is
        // provided for generality, although at the moment on all pre-defined
        // paths it will be 2.
    **/
    @:keep
    static public function output( _l:stdgo.StdGoTypes.Ref<Logger>, _calldepth:stdgo.StdGoTypes.GoInt, _s:stdgo.GoString):stdgo.Error {
        @:recv var _l:stdgo.StdGoTypes.Ref<Logger> = _l;
        _calldepth++;
        return _l._output((0 : stdgo.StdGoTypes.GoUIntptr), _calldepth, function(_b:stdgo.Slice<stdgo.StdGoTypes.GoByte>):stdgo.Slice<stdgo.StdGoTypes.GoByte> {
            return (_b.__append__(..._s.__toArray__()));
        });
    }
    /**
        // SetOutput sets the output destination for the logger.
    **/
    @:keep
    static public function setOutput( _l:stdgo.StdGoTypes.Ref<Logger>, _w:stdgo.io.Io.Writer):Void {
        @:recv var _l:stdgo.StdGoTypes.Ref<Logger> = _l;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            _l._outMu.lock();
            __deferstack__.unshift(() -> _l._outMu.unlock());
            _l._out = _w;
            _l._isDiscard.store(stdgo.Go.toInterface(_w) == (stdgo.Go.toInterface(stdgo.io.Io.discard)));
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.StdGoTypes.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return;
        };
    }
}
class T_discard_asInterface {
    @:keep
    public dynamic function write(_p:stdgo.Slice<stdgo.StdGoTypes.GoByte>):{ var _0 : stdgo.StdGoTypes.GoInt; var _1 : stdgo.Error; } return __self__.value.write(_p);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.StdGoTypes.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_discard>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.log.Log.T_discard_asInterface) class T_discard_static_extension {
    @:keep
    static public function write( _:T_discard, _p:stdgo.Slice<stdgo.StdGoTypes.GoByte>):{ var _0 : stdgo.StdGoTypes.GoInt; var _1 : stdgo.Error; } {
        @:recv var _:T_discard = _?.__copy__();
        return { _0 : (_p.length), _1 : (null : stdgo.Error) };
    }
}
