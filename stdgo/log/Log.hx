package stdgo.log;
import stdgo.StdGoTypes;
import stdgo.Error;
import stdgo.Go;
import stdgo.GoString;
import stdgo.Pointer;
import stdgo.Slice;
import stdgo.GoArray;
import stdgo.GoMap;
import stdgo.Chan;
/**
    // Package log implements a simple logging package. It defines a type, Logger,
    // with methods for formatting output. It also has a predefined 'standard'
    // Logger accessible through helper functions Print[f|ln], Fatal[f|ln], and
    // Panic[f|ln], which are easier to use than creating a Logger manually.
    // That logger writes to standard error and prints the date and time
    // of each logged message.
    // Every log message is output on a separate line: if the message being
    // printed does not end in a newline, the logger will add one.
    // The Fatal functions call os.Exit(1) after writing the log message.
    // The Panic functions call panic after writing the log message.
**/
private var __go2hxdoc__package : Bool;
/**
    
    
    
**/
private var _std = new_(Go.asInterface(stdgo.os.Os.stderr), Go.str(), (3 : GoInt));
/**
    
    
    
**/
private var _tests = (new Slice<stdgo.log.Log.T_tester>(
14,
14,
(new stdgo.log.Log.T_tester((0 : GoInt), Go.str(), Go.str()) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((0 : GoInt), ("XXX" : GoString), ("XXX" : GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((1 : GoInt), Go.str(), ("[0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9] " : GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((2 : GoInt), Go.str(), ("[0-9][0-9]:[0-9][0-9]:[0-9][0-9] " : GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((66 : GoInt), ("XXX" : GoString), ("[0-9][0-9]:[0-9][0-9]:[0-9][0-9] XXX" : GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((6 : GoInt), Go.str(), ("[0-9][0-9]:[0-9][0-9]:[0-9][0-9]\\.[0-9][0-9][0-9][0-9][0-9][0-9] " : GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((4 : GoInt), Go.str(), ("[0-9][0-9]:[0-9][0-9]:[0-9][0-9]\\.[0-9][0-9][0-9][0-9][0-9][0-9] " : GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((8 : GoInt), Go.str(), (".*/[A-Za-z0-9_\\-]+\\.go:(61|63): " : GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((16 : GoInt), Go.str(), ("[A-Za-z0-9_\\-]+\\.go:(61|63): " : GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((24 : GoInt), Go.str(), ("[A-Za-z0-9_\\-]+\\.go:(61|63): " : GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((15 : GoInt), ("XXX" : GoString), ("XXX[0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9]\\.[0-9][0-9][0-9][0-9][0-9][0-9] .*/[A-Za-z0-9_\\-]+\\.go:(61|63): " : GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((23 : GoInt), ("XXX" : GoString), ("XXX[0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9]\\.[0-9][0-9][0-9][0-9][0-9][0-9] [A-Za-z0-9_\\-]+\\.go:(61|63): " : GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((79 : GoInt), ("XXX" : GoString), ("[0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9]\\.[0-9][0-9][0-9][0-9][0-9][0-9] .*/[A-Za-z0-9_\\-]+\\.go:(61|63): XXX" : GoString)) : stdgo.log.Log.T_tester),
(new stdgo.log.Log.T_tester((87 : GoInt), ("XXX" : GoString), ("[0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9]\\.[0-9][0-9][0-9][0-9][0-9][0-9] [A-Za-z0-9_\\-]+\\.go:(61|63): XXX" : GoString)) : stdgo.log.Log.T_tester)) : Slice<stdgo.log.Log.T_tester>);
/**
    // These flags define which text to prefix to each log entry generated by the Logger.
    // Bits are or'ed together to control what's printed.
    // With the exception of the Lmsgprefix flag, there is no
    // control over the order they appear (the order listed here)
    // or the format they present (as described in the comments).
    // The prefix is followed by a colon only when Llongfile or Lshortfile
    // is specified.
    // For example, flags Ldate | Ltime (or LstdFlags) produce,
    //
    //	2009/01/23 01:23:23 message
    //
    // while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
    //
    //	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
    
    // the date in the local time zone: 2009/01/23
**/
final ldate = (64i64 : GoUInt64);
/**
    // These flags define which text to prefix to each log entry generated by the Logger.
    // Bits are or'ed together to control what's printed.
    // With the exception of the Lmsgprefix flag, there is no
    // control over the order they appear (the order listed here)
    // or the format they present (as described in the comments).
    // The prefix is followed by a colon only when Llongfile or Lshortfile
    // is specified.
    // For example, flags Ldate | Ltime (or LstdFlags) produce,
    //
    //	2009/01/23 01:23:23 message
    //
    // while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
    //
    //	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
    
    // the time in the local time zone: 01:23:23
**/
final ltime = (64i64 : GoUInt64);
/**
    // These flags define which text to prefix to each log entry generated by the Logger.
    // Bits are or'ed together to control what's printed.
    // With the exception of the Lmsgprefix flag, there is no
    // control over the order they appear (the order listed here)
    // or the format they present (as described in the comments).
    // The prefix is followed by a colon only when Llongfile or Lshortfile
    // is specified.
    // For example, flags Ldate | Ltime (or LstdFlags) produce,
    //
    //	2009/01/23 01:23:23 message
    //
    // while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
    //
    //	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
    
    // microsecond resolution: 01:23:23.123123.  assumes Ltime.
**/
final lmicroseconds = (64i64 : GoUInt64);
/**
    // These flags define which text to prefix to each log entry generated by the Logger.
    // Bits are or'ed together to control what's printed.
    // With the exception of the Lmsgprefix flag, there is no
    // control over the order they appear (the order listed here)
    // or the format they present (as described in the comments).
    // The prefix is followed by a colon only when Llongfile or Lshortfile
    // is specified.
    // For example, flags Ldate | Ltime (or LstdFlags) produce,
    //
    //	2009/01/23 01:23:23 message
    //
    // while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
    //
    //	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
    
    // full file name and line number: /a/b/c/d.go:23
**/
final llongfile = (64i64 : GoUInt64);
/**
    // These flags define which text to prefix to each log entry generated by the Logger.
    // Bits are or'ed together to control what's printed.
    // With the exception of the Lmsgprefix flag, there is no
    // control over the order they appear (the order listed here)
    // or the format they present (as described in the comments).
    // The prefix is followed by a colon only when Llongfile or Lshortfile
    // is specified.
    // For example, flags Ldate | Ltime (or LstdFlags) produce,
    //
    //	2009/01/23 01:23:23 message
    //
    // while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
    //
    //	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
    
    // final file name element and line number: d.go:23. overrides Llongfile
**/
final lshortfile = (64i64 : GoUInt64);
/**
    // These flags define which text to prefix to each log entry generated by the Logger.
    // Bits are or'ed together to control what's printed.
    // With the exception of the Lmsgprefix flag, there is no
    // control over the order they appear (the order listed here)
    // or the format they present (as described in the comments).
    // The prefix is followed by a colon only when Llongfile or Lshortfile
    // is specified.
    // For example, flags Ldate | Ltime (or LstdFlags) produce,
    //
    //	2009/01/23 01:23:23 message
    //
    // while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
    //
    //	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
    
    // if Ldate or Ltime is set, use UTC rather than the local time zone
**/
final lutc = (64i64 : GoUInt64);
/**
    // These flags define which text to prefix to each log entry generated by the Logger.
    // Bits are or'ed together to control what's printed.
    // With the exception of the Lmsgprefix flag, there is no
    // control over the order they appear (the order listed here)
    // or the format they present (as described in the comments).
    // The prefix is followed by a colon only when Llongfile or Lshortfile
    // is specified.
    // For example, flags Ldate | Ltime (or LstdFlags) produce,
    //
    //	2009/01/23 01:23:23 message
    //
    // while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
    //
    //	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
    
    // move the "prefix" from the beginning of the line to before the message
**/
final lmsgprefix = (64i64 : GoUInt64);
/**
    // These flags define which text to prefix to each log entry generated by the Logger.
    // Bits are or'ed together to control what's printed.
    // With the exception of the Lmsgprefix flag, there is no
    // control over the order they appear (the order listed here)
    // or the format they present (as described in the comments).
    // The prefix is followed by a colon only when Llongfile or Lshortfile
    // is specified.
    // For example, flags Ldate | Ltime (or LstdFlags) produce,
    //
    //	2009/01/23 01:23:23 message
    //
    // while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
    //
    //	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
    
    // initial values for the standard logger
**/
final lstdFlags = (3i64 : GoUInt64);
/**
    
    
    
**/
final rdate = ("[0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9]" : GoString);
/**
    
    
    
**/
final rtime = ("[0-9][0-9]:[0-9][0-9]:[0-9][0-9]" : GoString);
/**
    
    
    
**/
final rmicroseconds = ("\\.[0-9][0-9][0-9][0-9][0-9][0-9]" : GoString);
/**
    
    
    // must update if the calls to l.Printf / l.Print below move
**/
final rline = ("(61|63):" : GoString);
/**
    
    
    
**/
final rlongfile = (".*/[A-Za-z0-9_\\-]+\\.go:(61|63):" : GoString);
/**
    
    
    
**/
final rshortfile = ("[A-Za-z0-9_\\-]+\\.go:(61|63):" : GoString);
/**
    // A Logger represents an active logging object that generates lines of
    // output to an io.Writer. Each logging operation makes a single call to
    // the Writer's Write method. A Logger can be used simultaneously from
    // multiple goroutines; it guarantees to serialize access to the Writer.
    
    
**/
@:structInit @:using(stdgo.log.Log.Logger_static_extension) class Logger {
    public var _mu : stdgo.sync.Sync.Mutex = ({} : stdgo.sync.Sync.Mutex);
    public var _prefix : GoString = "";
    public var _flag : GoInt = 0;
    public var _out : stdgo.io.Io.Writer = (null : stdgo.io.Io.Writer);
    public var _buf : Slice<GoUInt8> = (null : Slice<GoUInt8>);
    public var _isDiscard : stdgo.sync.atomic.Atomic.Bool_ = ({} : stdgo.sync.atomic.Atomic.Bool_);
    public function new(?_mu:stdgo.sync.Sync.Mutex, ?_prefix:GoString, ?_flag:GoInt, ?_out:stdgo.io.Io.Writer, ?_buf:Slice<GoUInt8>, ?_isDiscard:stdgo.sync.atomic.Atomic.Bool_) {
        if (_mu != null) this._mu = _mu;
        if (_prefix != null) this._prefix = _prefix;
        if (_flag != null) this._flag = _flag;
        if (_out != null) this._out = _out;
        if (_buf != null) this._buf = _buf;
        if (_isDiscard != null) this._isDiscard = _isDiscard;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Logger(_mu, _prefix, _flag, _out, _buf, _isDiscard);
    }
}
/**
    
    
    
**/
@:structInit @:private class T_tester {
    public var _flag : GoInt = 0;
    public var _prefix : GoString = "";
    public var _pattern : GoString = "";
    public function new(?_flag:GoInt, ?_prefix:GoString, ?_pattern:GoString) {
        if (_flag != null) this._flag = _flag;
        if (_prefix != null) this._prefix = _prefix;
        if (_pattern != null) this._pattern = _pattern;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_tester(_flag, _prefix, _pattern);
    }
}
/**
    // New creates a new Logger. The out variable sets the
    // destination to which log data will be written.
    // The prefix appears at the beginning of each generated log line, or
    // after the log header if the Lmsgprefix flag is provided.
    // The flag argument defines the logging properties.
**/
function new_(_out:stdgo.io.Io.Writer, _prefix:GoString, _flag:GoInt):Ref<Logger> {
        var _l = (Go.setRef(({ _prefix : _prefix, _flag : _flag, _out : _out } : Logger)) : Ref<stdgo.log.Log.Logger>);
        if (Go.toInterface(_out) == (Go.toInterface(stdgo.io.Io.discard))) {
            _l._isDiscard.store(true);
        };
        return _l;
    }
/**
    // Default returns the standard logger used by the package-level output functions.
**/
function default_():Ref<Logger> {
        return _std;
    }
/**
    // Cheap integer to fixed-width decimal ASCII. Give a negative width to avoid zero-padding.
**/
private function _itoa(_buf:Ref<Slice<GoByte>>, _i:GoInt, _wid:GoInt):Void {
        var _b:GoArray<GoByte> = new GoArray<GoUInt8>(...[for (i in 0 ... 20) (0 : GoUInt8)]);
        var _bp:GoInt = (19 : GoInt);
        while ((_i >= (10 : GoInt)) || (_wid > (1 : GoInt))) {
            _wid--;
            var _q:GoInt = _i / (10 : GoInt);
            _b[(_bp : GoInt)] = (((48 : GoInt) + _i) - (_q * (10 : GoInt)) : GoByte);
            _bp--;
            _i = _q;
        };
        _b[(_bp : GoInt)] = ((48 : GoInt) + _i : GoByte);
        _buf.__setData__(((_buf : Slice<GoUInt8>).__append__(...(_b.__slice__(_bp) : Slice<GoUInt8>).__toArray__())));
    }
/**
    // SetOutput sets the output destination for the standard logger.
**/
function setOutput(_w:stdgo.io.Io.Writer):Void {
        _std.setOutput(_w);
    }
/**
    // Flags returns the output flags for the standard logger.
    // The flag bits are Ldate, Ltime, and so on.
**/
function flags():GoInt {
        return _std.flags();
    }
/**
    // SetFlags sets the output flags for the standard logger.
    // The flag bits are Ldate, Ltime, and so on.
**/
function setFlags(_flag:GoInt):Void {
        _std.setFlags(_flag);
    }
/**
    // Prefix returns the output prefix for the standard logger.
**/
function prefix():GoString {
        return _std.prefix();
    }
/**
    // SetPrefix sets the output prefix for the standard logger.
**/
function setPrefix(_prefix:GoString):Void {
        _std.setPrefix(_prefix);
    }
/**
    // Writer returns the output destination for the standard logger.
**/
function writer():stdgo.io.Io.Writer {
        return _std.writer();
    }
/**
    // Print calls Output to print to the standard logger.
    // Arguments are handled in the manner of fmt.Print.
**/
function print(_v:haxe.Rest<AnyInterface>):Void {
        var _v = new Slice<AnyInterface>(_v.length, 0, ..._v);
        if (_std._isDiscard.load()) {
            return;
        };
        _std.output((2 : GoInt), stdgo.fmt.Fmt.sprint(..._v.__toArray__()));
    }
/**
    // Printf calls Output to print to the standard logger.
    // Arguments are handled in the manner of fmt.Printf.
**/
function printf(_format:GoString, _v:haxe.Rest<AnyInterface>):Void {
        var _v = new Slice<AnyInterface>(_v.length, 0, ..._v);
        if (_std._isDiscard.load()) {
            return;
        };
        _std.output((2 : GoInt), stdgo.fmt.Fmt.sprintf(_format, ..._v.__toArray__()));
    }
/**
    // Println calls Output to print to the standard logger.
    // Arguments are handled in the manner of fmt.Println.
**/
function println(_v:haxe.Rest<AnyInterface>):Void {
        var _v = new Slice<AnyInterface>(_v.length, 0, ..._v);
        if (_std._isDiscard.load()) {
            return;
        };
        _std.output((2 : GoInt), stdgo.fmt.Fmt.sprintln(..._v.__toArray__()));
    }
/**
    // Fatal is equivalent to Print() followed by a call to os.Exit(1).
**/
function fatal(_v:haxe.Rest<AnyInterface>):Void {
        var _v = new Slice<AnyInterface>(_v.length, 0, ..._v);
        _std.output((2 : GoInt), stdgo.fmt.Fmt.sprint(..._v.__toArray__()));
        Sys.exit((1 : GoInt));
    }
/**
    // Fatalf is equivalent to Printf() followed by a call to os.Exit(1).
**/
function fatalf(_format:GoString, _v:haxe.Rest<AnyInterface>):Void {
        var _v = new Slice<AnyInterface>(_v.length, 0, ..._v);
        _std.output((2 : GoInt), stdgo.fmt.Fmt.sprintf(_format, ..._v.__toArray__()));
        Sys.exit((1 : GoInt));
    }
/**
    // Fatalln is equivalent to Println() followed by a call to os.Exit(1).
**/
function fatalln(_v:haxe.Rest<AnyInterface>):Void {
        var _v = new Slice<AnyInterface>(_v.length, 0, ..._v);
        _std.output((2 : GoInt), stdgo.fmt.Fmt.sprintln(..._v.__toArray__()));
        Sys.exit((1 : GoInt));
    }
/**
    // Panic is equivalent to Print() followed by a call to panic().
**/
function panic(_v:haxe.Rest<AnyInterface>):Void {
        var _v = new Slice<AnyInterface>(_v.length, 0, ..._v);
        var _s:GoString = stdgo.fmt.Fmt.sprint(..._v.__toArray__());
        _std.output((2 : GoInt), _s);
        throw Go.toInterface(_s);
    }
/**
    // Panicf is equivalent to Printf() followed by a call to panic().
**/
function panicf(_format:GoString, _v:haxe.Rest<AnyInterface>):Void {
        var _v = new Slice<AnyInterface>(_v.length, 0, ..._v);
        var _s:GoString = stdgo.fmt.Fmt.sprintf(_format, ..._v.__toArray__());
        _std.output((2 : GoInt), _s);
        throw Go.toInterface(_s);
    }
/**
    // Panicln is equivalent to Println() followed by a call to panic().
**/
function panicln(_v:haxe.Rest<AnyInterface>):Void {
        var _v = new Slice<AnyInterface>(_v.length, 0, ..._v);
        var _s:GoString = stdgo.fmt.Fmt.sprintln(..._v.__toArray__());
        _std.output((2 : GoInt), _s);
        throw Go.toInterface(_s);
    }
/**
    // Output writes the output for a logging event. The string s contains
    // the text to print after the prefix specified by the flags of the
    // Logger. A newline is appended if the last character of s is not
    // already a newline. Calldepth is the count of the number of
    // frames to skip when computing the file name and line number
    // if Llongfile or Lshortfile is set; a value of 1 will print the details
    // for the caller of Output.
**/
function output(_calldepth:GoInt, _s:GoString):Error {
        return _std.output(_calldepth + (1 : GoInt), _s);
    }
/**
    // Test using Println("hello", 23, "world") or using Printf("hello %d world", 23)
**/
private function _testPrint(_t:Ref<stdgo.testing.Testing.T>, _flag:GoInt, _prefix:GoString, _pattern:GoString, _useFormat:Bool):Void {
        var _buf = (Go.setRef(({} : stdgo.strings.Strings.Builder)) : Ref<stdgo.strings.Strings.Builder>);
        setOutput(Go.asInterface(_buf));
        setFlags(_flag);
        setPrefix(_prefix);
        if (_useFormat) {
            printf(("hello %d world" : GoString), Go.toInterface((23 : GoInt)));
        } else {
            println(Go.toInterface(("hello" : GoString)), Go.toInterface((23 : GoInt)), Go.toInterface(("world" : GoString)));
        };
        var _line:GoString = (_buf.string() : GoString);
        _line = (_line.__slice__((0 : GoInt), (_line.length) - (1 : GoInt)) : GoString);
        _pattern = (("^" : GoString) + _pattern) + ("hello 23 world$" : GoString);
        var __tmp__ = stdgo.regexp.Regexp.matchString(_pattern, _line), _matched:Bool = __tmp__._0, _err:Error = __tmp__._1;
        if (_err != null) {
            _t.fatal(Go.toInterface(("pattern did not compile:" : GoString)), Go.toInterface(_err));
        };
        if (!_matched) {
            _t.errorf(("log output should match %q is %q" : GoString), Go.toInterface(_pattern), Go.toInterface(_line));
        };
        setOutput(Go.asInterface(stdgo.os.Os.stderr));
    }
function testDefault(_t:Ref<stdgo.testing.Testing.T>):Void {
        {
            var _got = default_();
            if (_got != (_std)) {
                _t.errorf(("Default [%p] should be std [%p]" : GoString), Go.toInterface(Go.asInterface(_got)), Go.toInterface(Go.asInterface(_std)));
            };
        };
    }
function testAll(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _testcase in _tests) {
            _testPrint(_t, _testcase._flag, _testcase._prefix, _testcase._pattern, false);
            _testPrint(_t, _testcase._flag, _testcase._prefix, _testcase._pattern, true);
        };
    }
function testOutput(_t:Ref<stdgo.testing.Testing.T>):Void {
        {};
        var _b:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
        var _l = new_(Go.asInterface((Go.setRef(_b) : Ref<stdgo.strings.Strings.Builder>)), Go.str(), (0 : GoInt));
        _l.println(Go.toInterface(("test" : GoString)));
        {
            var _expect:GoString = ("test\n" : GoString);
            if ((_b.string() : GoString) != (_expect)) {
                _t.errorf(("log output should match %q is %q" : GoString), Go.toInterface(_expect), Go.toInterface((_b.string() : GoString)));
            };
        };
    }
function testOutputRace(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _b:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        var _l = new_(Go.asInterface((Go.setRef(_b) : Ref<stdgo.bytes.Bytes.Buffer>)), Go.str(), (0 : GoInt));
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < (100 : GoInt), _i++, {
                Go.routine(() -> {
                    var a = function():Void {
                        _l.setFlags((0 : GoInt));
                    };
                    a();
                });
                _l.output((0 : GoInt), Go.str());
            });
        };
    }
function testFlagAndPrefixSetting(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _b:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        var _l = new_(Go.asInterface((Go.setRef(_b) : Ref<stdgo.bytes.Bytes.Buffer>)), ("Test:" : GoString), (3 : GoInt));
        var _f:GoInt = _l.flags();
        if (_f != ((3 : GoInt))) {
            _t.errorf(("Flags 1: expected %x got %x" : GoString), Go.toInterface((3 : GoInt)), Go.toInterface(_f));
        };
        _l.setFlags(_f | (4 : GoInt));
        _f = _l.flags();
        if (_f != ((7 : GoInt))) {
            _t.errorf(("Flags 2: expected %x got %x" : GoString), Go.toInterface((7 : GoInt)), Go.toInterface(_f));
        };
        var _p:GoString = _l.prefix();
        if (_p != (("Test:" : GoString))) {
            _t.errorf(("Prefix: expected \"Test:\" got %q" : GoString), Go.toInterface(_p));
        };
        _l.setPrefix(("Reality:" : GoString));
        _p = _l.prefix();
        if (_p != (("Reality:" : GoString))) {
            _t.errorf(("Prefix: expected \"Reality:\" got %q" : GoString), Go.toInterface(_p));
        };
        _l.print(Go.toInterface(("hello" : GoString)));
        var _pattern:GoString = ("^Reality:[0-9][0-9][0-9][0-9]/[0-9][0-9]/[0-9][0-9] [0-9][0-9]:[0-9][0-9]:[0-9][0-9]\\.[0-9][0-9][0-9][0-9][0-9][0-9] hello\n" : GoString);
        var __tmp__ = stdgo.regexp.Regexp.match(_pattern, _b.bytes()), _matched:Bool = __tmp__._0, _err:Error = __tmp__._1;
        if (_err != null) {
            _t.fatalf(("pattern %q did not compile: %s" : GoString), Go.toInterface(_pattern), Go.toInterface(_err));
        };
        if (!_matched) {
            _t.error(Go.toInterface(("message did not match pattern" : GoString)));
        };
    }
function testUTCFlag(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _b:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
        var _l = new_(Go.asInterface((Go.setRef(_b) : Ref<stdgo.strings.Strings.Builder>)), ("Test:" : GoString), (3 : GoInt));
        _l.setFlags((35 : GoInt));
        var _now:stdgo.time.Time.Time = stdgo.time.Time.now().utc()?.__copy__();
        _l.print(Go.toInterface(("hello" : GoString)));
        var _want:GoString = stdgo.fmt.Fmt.sprintf(("Test:%d/%.2d/%.2d %.2d:%.2d:%.2d hello\n" : GoString), Go.toInterface(_now.year()), Go.toInterface(Go.asInterface(_now.month())), Go.toInterface(_now.day()), Go.toInterface(_now.hour()), Go.toInterface(_now.minute()), Go.toInterface(_now.second()));
        var _got:GoString = (_b.string() : GoString);
        if (_got == (_want)) {
            return;
        };
        _now = _now.add((1000000000i64 : stdgo.time.Time.Duration))?.__copy__();
        _want = stdgo.fmt.Fmt.sprintf(("Test:%d/%.2d/%.2d %.2d:%.2d:%.2d hello\n" : GoString), Go.toInterface(_now.year()), Go.toInterface(Go.asInterface(_now.month())), Go.toInterface(_now.day()), Go.toInterface(_now.hour()), Go.toInterface(_now.minute()), Go.toInterface(_now.second()));
        if (_got == (_want)) {
            return;
        };
        _t.errorf(("got %q; want %q" : GoString), Go.toInterface(_got), Go.toInterface(_want));
    }
function testEmptyPrintCreatesLine(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _b:stdgo.strings.Strings.Builder = ({} : stdgo.strings.Strings.Builder);
        var _l = new_(Go.asInterface((Go.setRef(_b) : Ref<stdgo.strings.Strings.Builder>)), ("Header:" : GoString), (3 : GoInt));
        _l.print();
        _l.println(Go.toInterface(("non-empty" : GoString)));
        var _output:GoString = (_b.string() : GoString);
        {
            var _n:GoInt = stdgo.strings.Strings.count(_output, ("Header" : GoString));
            if (_n != ((2 : GoInt))) {
                _t.errorf(("expected 2 headers, got %d" : GoString), Go.toInterface(_n));
            };
        };
        {
            var _n:GoInt = stdgo.strings.Strings.count(_output, ("\n" : GoString));
            if (_n != ((2 : GoInt))) {
                _t.errorf(("expected 2 lines, got %d" : GoString), Go.toInterface(_n));
            };
        };
    }
function testDiscard(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _l = new_(stdgo.io.Io.discard, Go.str(), (0 : GoInt));
        var _s:GoString = stdgo.strings.Strings.repeat(("a" : GoString), (102400 : GoInt));
        var _c:GoFloat64 = stdgo.testing.Testing.allocsPerRun((100 : GoInt), function():Void {
            _l.printf(("%s" : GoString), Go.toInterface(_s));
        });
        if (_c > (1 : GoFloat64)) {
            _t.errorf(("got %v allocs, want at most 1" : GoString), Go.toInterface(_c));
        };
    }
function benchmarkItoa(_b:Ref<stdgo.testing.Testing.B>):Void {
        var _dst = new Slice<GoUInt8>((0 : GoInt).toBasic(), (64 : GoInt)).__setNumber32__();
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                _dst = (_dst.__slice__((0 : GoInt), (0 : GoInt)) : Slice<GoUInt8>);
                _itoa((Go.setRef(_dst) : Ref<Slice<GoUInt8>>), (2015 : GoInt), (4 : GoInt));
                _itoa((Go.setRef(_dst) : Ref<Slice<GoUInt8>>), (1 : GoInt), (2 : GoInt));
                _itoa((Go.setRef(_dst) : Ref<Slice<GoUInt8>>), (30 : GoInt), (2 : GoInt));
                _itoa((Go.setRef(_dst) : Ref<Slice<GoUInt8>>), (12 : GoInt), (2 : GoInt));
                _itoa((Go.setRef(_dst) : Ref<Slice<GoUInt8>>), (56 : GoInt), (2 : GoInt));
                _itoa((Go.setRef(_dst) : Ref<Slice<GoUInt8>>), (0 : GoInt), (2 : GoInt));
                _itoa((Go.setRef(_dst) : Ref<Slice<GoUInt8>>), (987654 : GoInt), (6 : GoInt));
            });
        };
    }
function benchmarkPrintln(_b:Ref<stdgo.testing.Testing.B>):Void {
        {};
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        var _l = new_(Go.asInterface((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>)), Go.str(), (3 : GoInt));
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                _buf.reset();
                _l.println(Go.toInterface(("test" : GoString)));
            });
        };
    }
function benchmarkPrintlnNoFlags(_b:Ref<stdgo.testing.Testing.B>):Void {
        {};
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        var _l = new_(Go.asInterface((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>)), Go.str(), (0 : GoInt));
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                _buf.reset();
                _l.println(Go.toInterface(("test" : GoString)));
            });
        };
    }
class Logger_asInterface {
    /**
        // Writer returns the output destination for the logger.
    **/
    @:keep
    public dynamic function writer():stdgo.io.Io.Writer return __self__.value.writer();
    /**
        // SetPrefix sets the output prefix for the logger.
    **/
    @:keep
    public dynamic function setPrefix(_prefix:GoString):Void __self__.value.setPrefix(_prefix);
    /**
        // Prefix returns the output prefix for the logger.
    **/
    @:keep
    public dynamic function prefix():GoString return __self__.value.prefix();
    /**
        // SetFlags sets the output flags for the logger.
        // The flag bits are Ldate, Ltime, and so on.
    **/
    @:keep
    public dynamic function setFlags(_flag:GoInt):Void __self__.value.setFlags(_flag);
    /**
        // Flags returns the output flags for the logger.
        // The flag bits are Ldate, Ltime, and so on.
    **/
    @:keep
    public dynamic function flags():GoInt return __self__.value.flags();
    /**
        // Panicln is equivalent to l.Println() followed by a call to panic().
    **/
    @:keep
    public dynamic function panicln(_v:haxe.Rest<AnyInterface>):Void __self__.value.panicln(..._v);
    /**
        // Panicf is equivalent to l.Printf() followed by a call to panic().
    **/
    @:keep
    public dynamic function panicf(_format:GoString, _v:haxe.Rest<AnyInterface>):Void __self__.value.panicf(_format, ..._v);
    /**
        // Panic is equivalent to l.Print() followed by a call to panic().
    **/
    @:keep
    public dynamic function panic(_v:haxe.Rest<AnyInterface>):Void __self__.value.panic(..._v);
    /**
        // Fatalln is equivalent to l.Println() followed by a call to os.Exit(1).
    **/
    @:keep
    public dynamic function fatalln(_v:haxe.Rest<AnyInterface>):Void __self__.value.fatalln(..._v);
    /**
        // Fatalf is equivalent to l.Printf() followed by a call to os.Exit(1).
    **/
    @:keep
    public dynamic function fatalf(_format:GoString, _v:haxe.Rest<AnyInterface>):Void __self__.value.fatalf(_format, ..._v);
    /**
        // Fatal is equivalent to l.Print() followed by a call to os.Exit(1).
    **/
    @:keep
    public dynamic function fatal(_v:haxe.Rest<AnyInterface>):Void __self__.value.fatal(..._v);
    /**
        // Println calls l.Output to print to the logger.
        // Arguments are handled in the manner of fmt.Println.
    **/
    @:keep
    public dynamic function println(_v:haxe.Rest<AnyInterface>):Void __self__.value.println(..._v);
    /**
        // Print calls l.Output to print to the logger.
        // Arguments are handled in the manner of fmt.Print.
    **/
    @:keep
    public dynamic function print(_v:haxe.Rest<AnyInterface>):Void __self__.value.print(..._v);
    /**
        // Printf calls l.Output to print to the logger.
        // Arguments are handled in the manner of fmt.Printf.
    **/
    @:keep
    public dynamic function printf(_format:GoString, _v:haxe.Rest<AnyInterface>):Void __self__.value.printf(_format, ..._v);
    /**
        // Output writes the output for a logging event. The string s contains
        // the text to print after the prefix specified by the flags of the
        // Logger. A newline is appended if the last character of s is not
        // already a newline. Calldepth is used to recover the PC and is
        // provided for generality, although at the moment on all pre-defined
        // paths it will be 2.
    **/
    @:keep
    public dynamic function output(_calldepth:GoInt, _s:GoString):Error return __self__.value.output(_calldepth, _s);
    /**
        // formatHeader writes log header to buf in following order:
        //   - l.prefix (if it's not blank and Lmsgprefix is unset),
        //   - date and/or time (if corresponding flags are provided),
        //   - file and line number (if corresponding flags are provided),
        //   - l.prefix (if it's not blank and Lmsgprefix is set).
    **/
    @:keep
    public dynamic function _formatHeader(_buf:Ref<Slice<GoByte>>, _t:stdgo.time.Time.Time, _file:GoString, _line:GoInt):Void __self__.value._formatHeader(_buf, _t, _file, _line);
    /**
        // SetOutput sets the output destination for the logger.
    **/
    @:keep
    public dynamic function setOutput(_w:stdgo.io.Io.Writer):Void __self__.value.setOutput(_w);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Logger>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.log.Log.Logger_asInterface) class Logger_static_extension {
    /**
        // Writer returns the output destination for the logger.
    **/
    @:keep
    static public function writer( _l:Ref<Logger>):stdgo.io.Io.Writer {
        var __deferstack__:Array<Void -> Void> = [];
        _l._mu.lock();
        try {
            __deferstack__.unshift(() -> _l._mu.unlock());
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _l._out;
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return (null : stdgo.io.Io.Writer);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return (null : stdgo.io.Io.Writer);
        };
    }
    /**
        // SetPrefix sets the output prefix for the logger.
    **/
    @:keep
    static public function setPrefix( _l:Ref<Logger>, _prefix:GoString):Void {
        var __deferstack__:Array<Void -> Void> = [];
        try {
            _l._mu.lock();
            __deferstack__.unshift(() -> _l._mu.unlock());
            _l._prefix = _prefix;
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return;
        };
    }
    /**
        // Prefix returns the output prefix for the logger.
    **/
    @:keep
    static public function prefix( _l:Ref<Logger>):GoString {
        var __deferstack__:Array<Void -> Void> = [];
        _l._mu.lock();
        try {
            __deferstack__.unshift(() -> _l._mu.unlock());
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _l._prefix;
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return ("" : GoString);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return ("" : GoString);
        };
    }
    /**
        // SetFlags sets the output flags for the logger.
        // The flag bits are Ldate, Ltime, and so on.
    **/
    @:keep
    static public function setFlags( _l:Ref<Logger>, _flag:GoInt):Void {
        var __deferstack__:Array<Void -> Void> = [];
        try {
            _l._mu.lock();
            __deferstack__.unshift(() -> _l._mu.unlock());
            _l._flag = _flag;
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return;
        };
    }
    /**
        // Flags returns the output flags for the logger.
        // The flag bits are Ldate, Ltime, and so on.
    **/
    @:keep
    static public function flags( _l:Ref<Logger>):GoInt {
        var __deferstack__:Array<Void -> Void> = [];
        _l._mu.lock();
        try {
            __deferstack__.unshift(() -> _l._mu.unlock());
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _l._flag;
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return (0 : GoInt);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return (0 : GoInt);
        };
    }
    /**
        // Panicln is equivalent to l.Println() followed by a call to panic().
    **/
    @:keep
    static public function panicln( _l:Ref<Logger>, _v:haxe.Rest<AnyInterface>):Void {
        var _v = new Slice<AnyInterface>(_v.length, 0, ..._v);
        var _s:GoString = stdgo.fmt.Fmt.sprintln(..._v.__toArray__());
        _l.output((2 : GoInt), _s);
        throw Go.toInterface(_s);
    }
    /**
        // Panicf is equivalent to l.Printf() followed by a call to panic().
    **/
    @:keep
    static public function panicf( _l:Ref<Logger>, _format:GoString, _v:haxe.Rest<AnyInterface>):Void {
        var _v = new Slice<AnyInterface>(_v.length, 0, ..._v);
        var _s:GoString = stdgo.fmt.Fmt.sprintf(_format, ..._v.__toArray__());
        _l.output((2 : GoInt), _s);
        throw Go.toInterface(_s);
    }
    /**
        // Panic is equivalent to l.Print() followed by a call to panic().
    **/
    @:keep
    static public function panic( _l:Ref<Logger>, _v:haxe.Rest<AnyInterface>):Void {
        var _v = new Slice<AnyInterface>(_v.length, 0, ..._v);
        var _s:GoString = stdgo.fmt.Fmt.sprint(..._v.__toArray__());
        _l.output((2 : GoInt), _s);
        throw Go.toInterface(_s);
    }
    /**
        // Fatalln is equivalent to l.Println() followed by a call to os.Exit(1).
    **/
    @:keep
    static public function fatalln( _l:Ref<Logger>, _v:haxe.Rest<AnyInterface>):Void {
        var _v = new Slice<AnyInterface>(_v.length, 0, ..._v);
        _l.output((2 : GoInt), stdgo.fmt.Fmt.sprintln(..._v.__toArray__()));
        Sys.exit((1 : GoInt));
    }
    /**
        // Fatalf is equivalent to l.Printf() followed by a call to os.Exit(1).
    **/
    @:keep
    static public function fatalf( _l:Ref<Logger>, _format:GoString, _v:haxe.Rest<AnyInterface>):Void {
        var _v = new Slice<AnyInterface>(_v.length, 0, ..._v);
        _l.output((2 : GoInt), stdgo.fmt.Fmt.sprintf(_format, ..._v.__toArray__()));
        Sys.exit((1 : GoInt));
    }
    /**
        // Fatal is equivalent to l.Print() followed by a call to os.Exit(1).
    **/
    @:keep
    static public function fatal( _l:Ref<Logger>, _v:haxe.Rest<AnyInterface>):Void {
        var _v = new Slice<AnyInterface>(_v.length, 0, ..._v);
        _l.output((2 : GoInt), stdgo.fmt.Fmt.sprint(..._v.__toArray__()));
        Sys.exit((1 : GoInt));
    }
    /**
        // Println calls l.Output to print to the logger.
        // Arguments are handled in the manner of fmt.Println.
    **/
    @:keep
    static public function println( _l:Ref<Logger>, _v:haxe.Rest<AnyInterface>):Void {
        var _v = new Slice<AnyInterface>(_v.length, 0, ..._v);
        if (_l._isDiscard.load()) {
            return;
        };
        _l.output((2 : GoInt), stdgo.fmt.Fmt.sprintln(..._v.__toArray__()));
    }
    /**
        // Print calls l.Output to print to the logger.
        // Arguments are handled in the manner of fmt.Print.
    **/
    @:keep
    static public function print( _l:Ref<Logger>, _v:haxe.Rest<AnyInterface>):Void {
        var _v = new Slice<AnyInterface>(_v.length, 0, ..._v);
        if (_l._isDiscard.load()) {
            return;
        };
        _l.output((2 : GoInt), stdgo.fmt.Fmt.sprint(..._v.__toArray__()));
    }
    /**
        // Printf calls l.Output to print to the logger.
        // Arguments are handled in the manner of fmt.Printf.
    **/
    @:keep
    static public function printf( _l:Ref<Logger>, _format:GoString, _v:haxe.Rest<AnyInterface>):Void {
        var _v = new Slice<AnyInterface>(_v.length, 0, ..._v);
        if (_l._isDiscard.load()) {
            return;
        };
        _l.output((2 : GoInt), stdgo.fmt.Fmt.sprintf(_format, ..._v.__toArray__()));
    }
    /**
        // Output writes the output for a logging event. The string s contains
        // the text to print after the prefix specified by the flags of the
        // Logger. A newline is appended if the last character of s is not
        // already a newline. Calldepth is used to recover the PC and is
        // provided for generality, although at the moment on all pre-defined
        // paths it will be 2.
    **/
    @:keep
    static public function output( _l:Ref<Logger>, _calldepth:GoInt, _s:GoString):Error {
        var __deferstack__:Array<Void -> Void> = [];
        var _now:stdgo.time.Time.Time = stdgo.time.Time.now()?.__copy__();
        try {
            var _file:GoString = ("" : GoString);
            var _line:GoInt = (0 : GoInt);
            _l._mu.lock();
            __deferstack__.unshift(() -> _l._mu.unlock());
            if (_l._flag & (24 : GoInt) != ((0 : GoInt))) {
                _l._mu.unlock();
                var _ok:Bool = false;
                {
                    var __tmp__ = stdgo.runtime.Runtime.caller(_calldepth);
                    _file = __tmp__._1;
                    _line = __tmp__._2;
                    _ok = __tmp__._3;
                };
                if (!_ok) {
                    _file = ("???" : GoString);
                    _line = (0 : GoInt);
                };
                _l._mu.lock();
            };
            _l._buf = (_l._buf.__slice__(0, (0 : GoInt)) : Slice<GoUInt8>);
            _l._formatHeader((Go.setRef(_l._buf) : Ref<Slice<GoUInt8>>), _now?.__copy__(), _file, _line);
            _l._buf = (_l._buf.__append__(..._s.__toArray__()));
            if ((_s.length == (0 : GoInt)) || (_s[((_s.length) - (1 : GoInt) : GoInt)] != (10 : GoUInt8))) {
                _l._buf = (_l._buf.__append__((10 : GoUInt8)));
            };
            var __tmp__ = _l._out.write(_l._buf), __28:GoInt = __tmp__._0, _err:Error = __tmp__._1;
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return _err;
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return (null : Error);
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return (null : Error);
        };
    }
    /**
        // formatHeader writes log header to buf in following order:
        //   - l.prefix (if it's not blank and Lmsgprefix is unset),
        //   - date and/or time (if corresponding flags are provided),
        //   - file and line number (if corresponding flags are provided),
        //   - l.prefix (if it's not blank and Lmsgprefix is set).
    **/
    @:keep
    static public function _formatHeader( _l:Ref<Logger>, _buf:Ref<Slice<GoByte>>, _t:stdgo.time.Time.Time, _file:GoString, _line:GoInt):Void {
        if (_l._flag & (64 : GoInt) == ((0 : GoInt))) {
            _buf.__setData__(((_buf : Slice<GoUInt8>).__append__(..._l._prefix.__toArray__())));
        };
        if (_l._flag & (7 : GoInt) != ((0 : GoInt))) {
            if (_l._flag & (32 : GoInt) != ((0 : GoInt))) {
                _t = _t.utc()?.__copy__();
            };
            if (_l._flag & (1 : GoInt) != ((0 : GoInt))) {
                var __tmp__ = _t.date(), _year:GoInt = __tmp__._0, _month:stdgo.time.Time.Month = __tmp__._1, _day:GoInt = __tmp__._2;
                _itoa(_buf, _year, (4 : GoInt));
                _buf.__setData__(((_buf : Slice<GoUInt8>).__append__((47 : GoUInt8))));
                _itoa(_buf, (_month : GoInt), (2 : GoInt));
                _buf.__setData__(((_buf : Slice<GoUInt8>).__append__((47 : GoUInt8))));
                _itoa(_buf, _day, (2 : GoInt));
                _buf.__setData__(((_buf : Slice<GoUInt8>).__append__((32 : GoUInt8))));
            };
            if (_l._flag & (6 : GoInt) != ((0 : GoInt))) {
                var __tmp__ = _t.clock(), _hour:GoInt = __tmp__._0, _min:GoInt = __tmp__._1, _sec:GoInt = __tmp__._2;
                _itoa(_buf, _hour, (2 : GoInt));
                _buf.__setData__(((_buf : Slice<GoUInt8>).__append__((58 : GoUInt8))));
                _itoa(_buf, _min, (2 : GoInt));
                _buf.__setData__(((_buf : Slice<GoUInt8>).__append__((58 : GoUInt8))));
                _itoa(_buf, _sec, (2 : GoInt));
                if (_l._flag & (4 : GoInt) != ((0 : GoInt))) {
                    _buf.__setData__(((_buf : Slice<GoUInt8>).__append__((46 : GoUInt8))));
                    _itoa(_buf, _t.nanosecond() / (1000 : GoInt), (6 : GoInt));
                };
                _buf.__setData__(((_buf : Slice<GoUInt8>).__append__((32 : GoUInt8))));
            };
        };
        if (_l._flag & (24 : GoInt) != ((0 : GoInt))) {
            if (_l._flag & (16 : GoInt) != ((0 : GoInt))) {
                var _short:GoString = _file;
                {
                    var _i:GoInt = (_file.length) - (1 : GoInt);
                    Go.cfor(_i > (0 : GoInt), _i--, {
                        if (_file[(_i : GoInt)] == ((47 : GoUInt8))) {
                            _short = (_file.__slice__(_i + (1 : GoInt)) : GoString);
                            break;
                        };
                    });
                };
                _file = _short;
            };
            _buf.__setData__(((_buf : Slice<GoUInt8>).__append__(..._file.__toArray__())));
            _buf.__setData__(((_buf : Slice<GoUInt8>).__append__((58 : GoUInt8))));
            _itoa(_buf, _line, (-1 : GoInt));
            _buf.__setData__(((_buf : Slice<GoUInt8>).__append__(...(": " : GoString).__toArray__())));
        };
        if (_l._flag & (64 : GoInt) != ((0 : GoInt))) {
            _buf.__setData__(((_buf : Slice<GoUInt8>).__append__(..._l._prefix.__toArray__())));
        };
    }
    /**
        // SetOutput sets the output destination for the logger.
    **/
    @:keep
    static public function setOutput( _l:Ref<Logger>, _w:stdgo.io.Io.Writer):Void {
        var __deferstack__:Array<Void -> Void> = [];
        try {
            _l._mu.lock();
            __deferstack__.unshift(() -> _l._mu.unlock());
            _l._out = _w;
            _l._isDiscard.store(Go.toInterface(_w) == (Go.toInterface(stdgo.io.Io.discard)));
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return;
        };
    }
}
