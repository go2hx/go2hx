package stdgo.math;
/**
    Package rand implements pseudo-random number generators suitable for tasks
    such as simulation, but it should not be used for security-sensitive work.
    
    Random numbers are generated by a [Source], usually wrapped in a [Rand].
    Both types should be used by a single goroutine at a time: sharing among
    multiple goroutines requires some kind of synchronization.
    
    Top-level functions, such as [Float64] and [Int],
    are safe for concurrent use by multiple goroutines.
    
    This package's outputs might be easily predictable regardless of how it's
    seeded. For random numbers suitable for security-sensitive work, see the
    crypto/rand package.
**/
private var __go2hxdoc__package : Bool;
@:forward @:forward.new abstract Source_static_extension(stdgo._internal.math.rand.Rand.Source_static_extension) from stdgo._internal.math.rand.Rand.Source_static_extension to stdgo._internal.math.rand.Rand.Source_static_extension {

}
typedef Source = stdgo._internal.math.rand.Rand.Source;
@:forward @:forward.new abstract Source64_static_extension(stdgo._internal.math.rand.Rand.Source64_static_extension) from stdgo._internal.math.rand.Rand.Source64_static_extension to stdgo._internal.math.rand.Rand.Source64_static_extension {

}
typedef Source64 = stdgo._internal.math.rand.Rand.Source64;
@:forward @:forward.new abstract Rand(stdgo._internal.math.rand.Rand.Rand) from stdgo._internal.math.rand.Rand.Rand to stdgo._internal.math.rand.Rand.Rand {

}
@:forward @:forward.new abstract T_fastSource(stdgo._internal.math.rand.Rand.T_fastSource) from stdgo._internal.math.rand.Rand.T_fastSource to stdgo._internal.math.rand.Rand.T_fastSource {

}
@:forward @:forward.new abstract T_lockedSource(stdgo._internal.math.rand.Rand.T_lockedSource) from stdgo._internal.math.rand.Rand.T_lockedSource to stdgo._internal.math.rand.Rand.T_lockedSource {

}
@:forward @:forward.new abstract T_rngSource(stdgo._internal.math.rand.Rand.T_rngSource) from stdgo._internal.math.rand.Rand.T_rngSource to stdgo._internal.math.rand.Rand.T_rngSource {

}
@:forward @:forward.new abstract Zipf(stdgo._internal.math.rand.Rand.Zipf) from stdgo._internal.math.rand.Rand.Zipf to stdgo._internal.math.rand.Rand.Zipf {

}
function int31nForTest(r:Rand, n:StdTypes.Int):StdTypes.Int {
        return stdgo._internal.math.rand.Rand.int31nForTest(r, n);
    }
function getNormalDistributionParameters():stdgo.Tuple.Tuple4<StdTypes.Float, haxe.ds.Vector<std.UInt>, haxe.ds.Vector<StdTypes.Float>, haxe.ds.Vector<StdTypes.Float>> {
        return {
            final obj = stdgo._internal.math.rand.Rand.getNormalDistributionParameters();
            { _0 : obj._0, _1 : obj._1, _2 : obj._2, _3 : obj._3 };
        };
    }
function getExponentialDistributionParameters():stdgo.Tuple.Tuple4<StdTypes.Float, haxe.ds.Vector<std.UInt>, haxe.ds.Vector<StdTypes.Float>, haxe.ds.Vector<StdTypes.Float>> {
        return {
            final obj = stdgo._internal.math.rand.Rand.getExponentialDistributionParameters();
            { _0 : obj._0, _1 : obj._1, _2 : obj._2, _3 : obj._3 };
        };
    }
/**
    NewSource returns a new pseudo-random Source seeded with the given value.
    Unlike the default Source used by top-level functions, this source is not
    safe for concurrent use by multiple goroutines.
    The returned Source implements Source64.
**/
function newSource(seed:haxe.Int64):Source {
        return stdgo._internal.math.rand.Rand.newSource(seed);
    }
/**
    New returns a new Rand that uses random values from src
    to generate other random values.
**/
function new_(src:Source):Rand {
        return stdgo._internal.math.rand.Rand.new_(src);
    }
/**
    Seed uses the provided seed value to initialize the default Source to a
    deterministic state. Seed values that have the same remainder when
    divided by 2³¹-1 generate the same pseudo-random sequence.
    Seed, unlike the Rand.Seed method, is safe for concurrent use.
    
    If Seed is not called, the generator is seeded randomly at program startup.
    
    Prior to Go 1.20, the generator was seeded like Seed(1) at program startup.
    To force the old behavior, call Seed(1) at program startup.
    Alternately, set GODEBUG=randautoseed=0 in the environment
    before making any calls to functions in this package.
    
    Deprecated: As of Go 1.20 there is no reason to call Seed with
    a random value. Programs that call Seed with a known value to get
    a specific sequence of results should use New(NewSource(seed)) to
    obtain a local random generator.
**/
function seed(seed:haxe.Int64):Void {
        stdgo._internal.math.rand.Rand.seed(seed);
    }
/**
    Int63 returns a non-negative pseudo-random 63-bit integer as an int64
    from the default Source.
**/
function int63():haxe.Int64 {
        return stdgo._internal.math.rand.Rand.int63();
    }
/**
    Uint32 returns a pseudo-random 32-bit value as a uint32
    from the default Source.
**/
function uint32():std.UInt {
        return stdgo._internal.math.rand.Rand.uint32();
    }
/**
    Uint64 returns a pseudo-random 64-bit value as a uint64
    from the default Source.
**/
function uint64():haxe.UInt64 {
        return stdgo._internal.math.rand.Rand.uint64();
    }
/**
    Int31 returns a non-negative pseudo-random 31-bit integer as an int32
    from the default Source.
**/
function int31():StdTypes.Int {
        return stdgo._internal.math.rand.Rand.int31();
    }
/**
    Int returns a non-negative pseudo-random int from the default Source.
**/
function int_():StdTypes.Int {
        return stdgo._internal.math.rand.Rand.int_();
    }
/**
    Int63n returns, as an int64, a non-negative pseudo-random number in the half-open interval [0,n)
    from the default Source.
    It panics if n <= 0.
**/
function int63n(n:haxe.Int64):haxe.Int64 {
        return stdgo._internal.math.rand.Rand.int63n(n);
    }
/**
    Int31n returns, as an int32, a non-negative pseudo-random number in the half-open interval [0,n)
    from the default Source.
    It panics if n <= 0.
**/
function int31n(n:StdTypes.Int):StdTypes.Int {
        return stdgo._internal.math.rand.Rand.int31n(n);
    }
/**
    Intn returns, as an int, a non-negative pseudo-random number in the half-open interval [0,n)
    from the default Source.
    It panics if n <= 0.
**/
function intn(n:StdTypes.Int):StdTypes.Int {
        return stdgo._internal.math.rand.Rand.intn(n);
    }
/**
    Float64 returns, as a float64, a pseudo-random number in the half-open interval [0.0,1.0)
    from the default Source.
**/
function float64():StdTypes.Float {
        return stdgo._internal.math.rand.Rand.float64();
    }
/**
    Float32 returns, as a float32, a pseudo-random number in the half-open interval [0.0,1.0)
    from the default Source.
**/
function float32():StdTypes.Float {
        return stdgo._internal.math.rand.Rand.float32();
    }
/**
    Perm returns, as a slice of n ints, a pseudo-random permutation of the integers
    in the half-open interval [0,n) from the default Source.
**/
function perm(n:StdTypes.Int):Array<StdTypes.Int> {
        return [for (i in stdgo._internal.math.rand.Rand.perm(n)) i];
    }
/**
    Shuffle pseudo-randomizes the order of elements using the default Source.
    n is the number of elements. Shuffle panics if n < 0.
    swap swaps the elements with indexes i and j.
**/
function shuffle(n:StdTypes.Int, swap:(_i:stdgo.GoInt, _j:stdgo.GoInt) -> Void):Void {
        final swap = swap;
        stdgo._internal.math.rand.Rand.shuffle(n, swap);
    }
/**
    Read generates len(p) random bytes from the default Source and
    writes them into p. It always returns len(p) and a nil error.
    Read, unlike the Rand.Read method, is safe for concurrent use.
    
    Deprecated: For almost all use cases, crypto/rand.Read is more appropriate.
**/
function read(p:Array<StdTypes.Int>):stdgo.Tuple<StdTypes.Int, stdgo.Error> {
        final p = ([for (i in p) i] : stdgo.Slice<stdgo.GoByte>);
        return {
            final obj = stdgo._internal.math.rand.Rand.read(p);
            { _0 : obj._0, _1 : obj._1 };
        };
    }
/**
    NormFloat64 returns a normally distributed float64 in the range
    [-math.MaxFloat64, +math.MaxFloat64] with
    standard normal distribution (mean = 0, stddev = 1)
    from the default Source.
    To produce a different normal distribution, callers can
    adjust the output using:
    
    	sample = NormFloat64() * desiredStdDev + desiredMean
**/
function normFloat64():StdTypes.Float {
        return stdgo._internal.math.rand.Rand.normFloat64();
    }
/**
    ExpFloat64 returns an exponentially distributed float64 in the range
    (0, +math.MaxFloat64] with an exponential distribution whose rate parameter
    (lambda) is 1 and whose mean is 1/lambda (1) from the default Source.
    To produce a distribution with a different rate parameter,
    callers can adjust the output using:
    
    	sample = ExpFloat64() / desiredRateParameter
**/
function expFloat64():StdTypes.Float {
        return stdgo._internal.math.rand.Rand.expFloat64();
    }
/**
    NewZipf returns a Zipf variate generator.
    The generator generates values k ∈ [0, imax]
    such that P(k) is proportional to (v + k) ** (-s).
    Requirements: s > 1 and v >= 1.
**/
function newZipf(r:Rand, s:StdTypes.Float, v:StdTypes.Float, imax:haxe.UInt64):Zipf {
        return stdgo._internal.math.rand.Rand.newZipf(r, s, v, imax);
    }
@:forward @:forward.new abstract Rand_asInterface(stdgo._internal.math.rand.Rand.Rand_asInterface) from stdgo._internal.math.rand.Rand.Rand_asInterface to stdgo._internal.math.rand.Rand.Rand_asInterface {

}
@:forward @:forward.new abstract Rand_static_extension(stdgo._internal.math.rand.Rand.Rand_static_extension) from stdgo._internal.math.rand.Rand.Rand_static_extension to stdgo._internal.math.rand.Rand.Rand_static_extension {

}
@:forward @:forward.new abstract T_fastSource_asInterface(stdgo._internal.math.rand.Rand.T_fastSource_asInterface) from stdgo._internal.math.rand.Rand.T_fastSource_asInterface to stdgo._internal.math.rand.Rand.T_fastSource_asInterface {

}
@:forward @:forward.new abstract T_fastSource_static_extension(stdgo._internal.math.rand.Rand.T_fastSource_static_extension) from stdgo._internal.math.rand.Rand.T_fastSource_static_extension to stdgo._internal.math.rand.Rand.T_fastSource_static_extension {

}
@:forward @:forward.new abstract T_lockedSource_asInterface(stdgo._internal.math.rand.Rand.T_lockedSource_asInterface) from stdgo._internal.math.rand.Rand.T_lockedSource_asInterface to stdgo._internal.math.rand.Rand.T_lockedSource_asInterface {

}
@:forward @:forward.new abstract T_lockedSource_static_extension(stdgo._internal.math.rand.Rand.T_lockedSource_static_extension) from stdgo._internal.math.rand.Rand.T_lockedSource_static_extension to stdgo._internal.math.rand.Rand.T_lockedSource_static_extension {

}
@:forward @:forward.new abstract T_rngSource_asInterface(stdgo._internal.math.rand.Rand.T_rngSource_asInterface) from stdgo._internal.math.rand.Rand.T_rngSource_asInterface to stdgo._internal.math.rand.Rand.T_rngSource_asInterface {

}
@:forward @:forward.new abstract T_rngSource_static_extension(stdgo._internal.math.rand.Rand.T_rngSource_static_extension) from stdgo._internal.math.rand.Rand.T_rngSource_static_extension to stdgo._internal.math.rand.Rand.T_rngSource_static_extension {

}
@:forward @:forward.new abstract Zipf_asInterface(stdgo._internal.math.rand.Rand.Zipf_asInterface) from stdgo._internal.math.rand.Rand.Zipf_asInterface to stdgo._internal.math.rand.Rand.Zipf_asInterface {

}
@:forward @:forward.new abstract Zipf_static_extension(stdgo._internal.math.rand.Rand.Zipf_static_extension) from stdgo._internal.math.rand.Rand.Zipf_static_extension to stdgo._internal.math.rand.Rand.Zipf_static_extension {

}
