package stdgo.math.big;
import stdgo.StdGoTypes;
import stdgo.Error;
import stdgo.Go;
import stdgo.GoString;
import stdgo.Pointer;
import stdgo.Slice;
import stdgo.GoArray;
import stdgo.GoMap;
import stdgo.Chan;
/**
    /|*
    Package big implements arbitrary-precision arithmetic (big numbers).
    The following numeric types are supported:
    
    	Int    signed integers
    	Rat    rational numbers
    	Float  floating-point numbers
    
    The zero value for an Int, Rat, or Float correspond to 0. Thus, new
    values can be declared in the usual ways and denote 0 without further
    initialization:
    
    	var x Int        // &x is an *Int of value 0
    	var r = &Rat{}   // r is a *Rat of value 0
    	y := new(Float)  // y is a *Float of value 0
    
    Alternatively, new values can be allocated and initialized with factory
    functions of the form:
    
    	func NewT(v V) *T
    
    For instance, NewInt(x) returns an *Int set to the value of the int64
    argument x, NewRat(a, b) returns a *Rat set to the fraction a/b where
    a and b are int64 values, and NewFloat(f) returns a *Float initialized
    to the float64 argument f. More flexibility is provided with explicit
    setters, for instance:
    
    	var z1 Int
    	z1.SetUint64(123)                 // z1 := 123
    	z2 := new(Rat).SetFloat64(1.25)   // z2 := 5/4
    	z3 := new(Float).SetInt(z1)       // z3 := 123.0
    
    Setters, numeric operations and predicates are represented as methods of
    the form:
    
    	func (z *T) SetV(v V) *T          // z = v
    	func (z *T) Unary(x *T) *T        // z = unary x
    	func (z *T) Binary(x, y *T) *T    // z = x binary y
    	func (x *T) Pred() P              // p = pred(x)
    
    with T one of Int, Rat, or Float. For unary and binary operations, the
    result is the receiver (usually named z in that case; see below); if it
    is one of the operands x or y it may be safely overwritten (and its memory
    reused).
    
    Arithmetic expressions are typically written as a sequence of individual
    method calls, with each call corresponding to an operation. The receiver
    denotes the result and the method arguments are the operation's operands.
    For instance, given three *Int values a, b and c, the invocation
    
    	c.Add(a, b)
    
    computes the sum a + b and stores the result in c, overwriting whatever
    value was held in c before. Unless specified otherwise, operations permit
    aliasing of parameters, so it is perfectly ok to write
    
    	sum.Add(sum, x)
    
    to accumulate values x in a sum.
    
    (By always passing in a result value via the receiver, memory use can be
    much better controlled. Instead of having to allocate new memory for each
    result, an operation can reuse the space allocated for the result value,
    and overwrite that value with the new result in the process.)
    
    Notational convention: Incoming method parameters (including the receiver)
    are named consistently in the API to clarify their use. Incoming operands
    are usually named x, y, a, b, and so on, but never z. A parameter specifying
    the result is named z (typically the receiver).
    
    For instance, the arguments for (*Int).Add are named x and y, and because
    the receiver specifies the result destination, it is called z:
    
    	func (z *Int) Add(x, y *Int) *Int
    
    Methods of this form typically return the incoming receiver as well, to
    enable simple call chaining.
    
    Methods which don't require a result value to be passed in (for instance,
    Int.Sign), simply return the result. In this case, the receiver is typically
    the first operand, named x:
    
    	func (x *Int) Sign() int
    
    Various methods support conversions between strings and corresponding
    numeric values, and vice versa: *Int, *Rat, and *Float values implement
    the Stringer interface for a (default) string representation of the value,
    but also provide SetString methods to initialize a value from a string in
    a variety of supported formats (see the respective SetString documentation).
    
    Finally, *Int, *Rat, and *Float satisfy the fmt package's Scanner interface
    for scanning and (except for *Rat) the Formatter interface for formatted
    printing.
    *|/
**/
private var __go2hxdoc__package : Bool;
/**
    
    
    
**/
private var __Accuracy_index = (new GoArray<GoUInt8>((0 : GoUInt8), (5 : GoUInt8), (10 : GoUInt8), (15 : GoUInt8)) : GoArray<GoUInt8>);
/**
    // These powers of 5 fit into a uint64.
    //
    //	for p, q := uint64(0), uint64(1); p < q; p, q = q, q*5 {
    //		fmt.Println(q)
    //	}
    
    
**/
private var _pow5tab = (new GoArray<GoUInt64>(
(1i64 : GoUInt64),
(5i64 : GoUInt64),
(25i64 : GoUInt64),
(125i64 : GoUInt64),
(625i64 : GoUInt64),
(3125i64 : GoUInt64),
(15625i64 : GoUInt64),
(78125i64 : GoUInt64),
(390625i64 : GoUInt64),
(1953125i64 : GoUInt64),
(9765625i64 : GoUInt64),
(48828125i64 : GoUInt64),
(244140625i64 : GoUInt64),
(1220703125i64 : GoUInt64),
(6103515625i64 : GoUInt64),
(30517578125i64 : GoUInt64),
(152587890625i64 : GoUInt64),
(762939453125i64 : GoUInt64),
(3814697265625i64 : GoUInt64),
(19073486328125i64 : GoUInt64),
(95367431640625i64 : GoUInt64),
(476837158203125i64 : GoUInt64),
(2384185791015625i64 : GoUInt64),
(11920928955078125i64 : GoUInt64),
(59604644775390625i64 : GoUInt64),
(298023223876953125i64 : GoUInt64),
(1490116119384765625i64 : GoUInt64),
(7450580596923828125i64 : GoUInt64)) : GoArray<GoUInt64>);
/**
    
    
    
**/
private var _natOne = (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat);
/**
    
    
    
**/
private var _intOne = (Go.setRef((new Int_(false, _natOne) : Int_)) : Ref<stdgo.math.big.Big.Int_>);
/**
    
    
    
**/
private var _natTwo = (new Slice<stdgo.math.big.Big.Word>(0, 0, (2u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat);
/**
    
    
    
**/
private var _natFive = (new Slice<stdgo.math.big.Big.Word>(0, 0, (5u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat);
/**
    
    
    
**/
private var _natTen = (new Slice<stdgo.math.big.Big.Word>(0, 0, (10u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat);
/**
    // Operands that are shorter than karatsubaThreshold are multiplied using
    // "grade school" multiplication; for longer operands the Karatsuba algorithm
    // is used.
    
    // computed by calibrate_test.go
**/
private var _karatsubaThreshold = (40 : GoInt);
/**
    // Operands that are shorter than basicSqrThreshold are squared using
    // "grade school" multiplication; for operands longer than karatsubaSqrThreshold
    // we use the Karatsuba algorithm optimized for x == y.
    
    // computed by calibrate_test.go
**/
private var _basicSqrThreshold = (20 : GoInt);
/**
    
    
    // computed by calibrate_test.go
**/
private var _karatsubaSqrThreshold = (260 : GoInt);
/**
    // scan errors
    
    
**/
private var _errNoDigits = stdgo.errors.Errors.new_(("number has no digits" : GoString));
/**
    // scan errors
    
    
**/
private var _errInvalSep = stdgo.errors.Errors.new_(("\'_\' must separate successive digits" : GoString));
/**
    // Split blocks greater than leafSize Words (or set to 0 to disable recursive conversion)
    // Benchmark and configure leafSize using: go test -bench="Leaf"
    //
    //	8 and 16 effective on 3.0 GHz Xeon "Clovertown" CPU (128 byte cache lines)
    //	8 and 16 effective on 2.66 GHz Core 2 Duo "Penryn" CPU
    
    // number of Word-size binary values treat as a monolithic block
**/
private var _leafSize : GoInt = (8 : GoInt);
/**
    
    
    
**/
private var __RoundingMode_index = (new GoArray<GoUInt8>((0 : GoUInt8), (13 : GoUInt8), (26 : GoUInt8), (32 : GoUInt8), (44 : GoUInt8), (57 : GoUInt8), (70 : GoUInt8)) : GoArray<GoUInt8>);
/**
    
    
    
**/
private var _isRaceBuilder = stdgo.strings.Strings.hasSuffix(stdgo.internal.testenv.Testenv.builder(), ("-race" : GoString));
/**
    
    
    
**/
private var _sumVV = (new Slice<stdgo.math.big.Big.T_argVV>(
0,
0,
(new stdgo.math.big.Big.T_argVV() : stdgo.math.big.Big.T_argVV),
(new stdgo.math.big.Big.T_argVV((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVV),
(new stdgo.math.big.Big.T_argVV((new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVV),
(new stdgo.math.big.Big.T_argVV((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVV),
(new stdgo.math.big.Big.T_argVV((new Slice<stdgo.math.big.Big.Word>(0, 0, (80235u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (12345u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (67890u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVV),
(new stdgo.math.big.Big.T_argVV((new Slice<stdgo.math.big.Big.Word>(0, 0, (-2u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVV),
(new stdgo.math.big.Big.T_argVV((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVV),
(new stdgo.math.big.Big.T_argVV((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-2u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVV),
(new stdgo.math.big.Big.T_argVV((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVV)) : Slice<stdgo.math.big.Big.T_argVV>);
/**
    // Always the same seed for reproducible results.
    
    
**/
private var _rnd = stdgo.math.rand.Rand.new_(stdgo.math.rand.Rand.newSource((0i64 : GoInt64)));
/**
    
    
    
**/
private var _benchSizes = (new Slice<GoInt>(
0,
0,
(1 : GoInt),
(2 : GoInt),
(3 : GoInt),
(4 : GoInt),
(5 : GoInt),
(10 : GoInt),
(100 : GoInt),
(1000 : GoInt),
(10000 : GoInt),
(100000 : GoInt)) : Slice<GoInt>);
/**
    
    
    
**/
private var _sumVW = (new Slice<stdgo.math.big.Big.T_argVW>(0, 0, (new stdgo.math.big.Big.T_argVW() : stdgo.math.big.Big.T_argVW), (new stdgo.math.big.Big.T_argVW(null, null, (2u32 : stdgo.math.big.Big.Word), (2u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW), (new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW), (new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (1u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW), (new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW), (new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (1u32 : stdgo.math.big.Big.Word), (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW), (new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (1u32 : stdgo.math.big.Big.Word), (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW), (new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (585u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (314u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (271u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW)) : Slice<stdgo.math.big.Big.T_argVW>);
/**
    
    
    
**/
private var _lshVW = (new Slice<stdgo.math.big.Big.T_argVW>(
0,
0,
(new stdgo.math.big.Big.T_argVW() : stdgo.math.big.Big.T_argVW),
(new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW),
(new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (1u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW),
(new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (20u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW),
(new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW),
(new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (-2u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (1u32 : stdgo.math.big.Big.Word), (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW),
(new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (-1048576u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (20u32 : stdgo.math.big.Big.Word), (1048575u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW),
(new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW),
(new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (-2u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (1u32 : stdgo.math.big.Big.Word), (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW),
(new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (-1048576u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (20u32 : stdgo.math.big.Big.Word), (1048575u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW)) : Slice<stdgo.math.big.Big.T_argVW>);
/**
    
    
    
**/
private var _rshVW = (new Slice<stdgo.math.big.Big.T_argVW>(
0,
0,
(new stdgo.math.big.Big.T_argVW() : stdgo.math.big.Big.T_argVW),
(new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW),
(new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (1u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW),
(new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (20u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW),
(new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW),
(new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (2147483647u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (1u32 : stdgo.math.big.Big.Word), (-2147483648u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW),
(new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (4095u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (20u32 : stdgo.math.big.Big.Word), (-4096u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW),
(new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW),
(new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (2147483647u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (1u32 : stdgo.math.big.Big.Word), (-2147483648u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW),
(new stdgo.math.big.Big.T_argVW((new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (4095u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (20u32 : stdgo.math.big.Big.Word), (-4096u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVW)) : Slice<stdgo.math.big.Big.T_argVW>);
/**
    
    
    
**/
private var _argshlVUIn = (new Slice<stdgo.math.big.Big.Word>(
0,
0,
(1u32 : stdgo.math.big.Big.Word),
(2u32 : stdgo.math.big.Big.Word),
(4u32 : stdgo.math.big.Big.Word),
(8u32 : stdgo.math.big.Big.Word),
(16u32 : stdgo.math.big.Big.Word),
(32u32 : stdgo.math.big.Big.Word),
(64u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>);
/**
    
    
    
**/
private var _argshlVUr0 = (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word), (2u32 : stdgo.math.big.Big.Word), (4u32 : stdgo.math.big.Big.Word), (8u32 : stdgo.math.big.Big.Word), (16u32 : stdgo.math.big.Big.Word), (32u32 : stdgo.math.big.Big.Word), (64u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>);
/**
    
    
    
**/
private var _argshlVUr1 = (new Slice<stdgo.math.big.Big.Word>(0, 0, (2u32 : stdgo.math.big.Big.Word), (4u32 : stdgo.math.big.Big.Word), (8u32 : stdgo.math.big.Big.Word), (16u32 : stdgo.math.big.Big.Word), (32u32 : stdgo.math.big.Big.Word), (64u32 : stdgo.math.big.Big.Word), (128u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>);
/**
    
    
    
**/
private var _argshlVUrWm1 = (new Slice<stdgo.math.big.Big.Word>(0, 0, (-2147483648u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (1u32 : stdgo.math.big.Big.Word), (2u32 : stdgo.math.big.Big.Word), (4u32 : stdgo.math.big.Big.Word), (8u32 : stdgo.math.big.Big.Word), (16u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>);
/**
    
    
    
**/
private var _argshlVU = (new Slice<stdgo.math.big.Big.T_argVU>(
0,
0,
(new stdgo.math.big.Big.T_argVU((new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1073741824u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>), (7u32 : GoUInt), (0u32 : GoUInt), (0u32 : GoUInt), (1u32 : GoUInt), (new Slice<stdgo.math.big.Big.Word>(0, 0, (2u32 : stdgo.math.big.Big.Word), (-2u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-2147483647u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>), (1u32 : stdgo.math.big.Big.Word), ("complete overlap of shlVU" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU((new Slice<stdgo.math.big.Big.Word>(
0,
0,
(1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1073741824u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>), (7u32 : GoUInt), (0u32 : GoUInt), (3u32 : GoUInt), (1u32 : GoUInt), (new Slice<stdgo.math.big.Big.Word>(0, 0, (2u32 : stdgo.math.big.Big.Word), (-2u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-2147483647u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>), (1u32 : stdgo.math.big.Big.Word), ("partial overlap by half of shlVU" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU((new Slice<stdgo.math.big.Big.Word>(
0,
0,
(1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1073741824u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>), (7u32 : GoUInt), (0u32 : GoUInt), (6u32 : GoUInt), (1u32 : GoUInt), (new Slice<stdgo.math.big.Big.Word>(0, 0, (2u32 : stdgo.math.big.Big.Word), (-2u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-2147483647u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>), (1u32 : stdgo.math.big.Big.Word), ("partial overlap by 1 Word of shlVU" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU((new Slice<stdgo.math.big.Big.Word>(
0,
0,
(1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1073741824u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>), (7u32 : GoUInt), (0u32 : GoUInt), (7u32 : GoUInt), (1u32 : GoUInt), (new Slice<stdgo.math.big.Big.Word>(0, 0, (2u32 : stdgo.math.big.Big.Word), (-2u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-2147483647u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>), (1u32 : stdgo.math.big.Big.Word), ("no overlap of shlVU" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshlVUIn, (7u32 : GoUInt), (0u32 : GoUInt), (0u32 : GoUInt), (0u32 : GoUInt), _argshlVUr0, (0u32 : stdgo.math.big.Big.Word), ("complete overlap of shlVU and shift of 0" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshlVUIn, (7u32 : GoUInt), (0u32 : GoUInt), (0u32 : GoUInt), (1u32 : GoUInt), _argshlVUr1, (0u32 : stdgo.math.big.Big.Word), ("complete overlap of shlVU and shift of 1" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshlVUIn, (7u32 : GoUInt), (0u32 : GoUInt), (0u32 : GoUInt), (31u32 : GoUInt), _argshlVUrWm1, (32u32 : stdgo.math.big.Big.Word), ("complete overlap of shlVU and shift of _W - 1" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshlVUIn, (7u32 : GoUInt), (0u32 : GoUInt), (1u32 : GoUInt), (0u32 : GoUInt), _argshlVUr0, (0u32 : stdgo.math.big.Big.Word), ("partial overlap by 6 Words of shlVU and shift of 0" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshlVUIn, (7u32 : GoUInt), (0u32 : GoUInt), (1u32 : GoUInt), (1u32 : GoUInt), _argshlVUr1, (0u32 : stdgo.math.big.Big.Word), ("partial overlap by 6 Words of shlVU and shift of 1" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshlVUIn, (7u32 : GoUInt), (0u32 : GoUInt), (1u32 : GoUInt), (31u32 : GoUInt), _argshlVUrWm1, (32u32 : stdgo.math.big.Big.Word), ("partial overlap by 6 Words of shlVU and shift of _W - 1" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshlVUIn, (7u32 : GoUInt), (0u32 : GoUInt), (2u32 : GoUInt), (0u32 : GoUInt), _argshlVUr0, (0u32 : stdgo.math.big.Big.Word), ("partial overlap by 5 Words of shlVU and shift of 0" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshlVUIn, (7u32 : GoUInt), (0u32 : GoUInt), (2u32 : GoUInt), (1u32 : GoUInt), _argshlVUr1, (0u32 : stdgo.math.big.Big.Word), ("partial overlap by 5 Words of shlVU and shift of 1" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshlVUIn, (7u32 : GoUInt), (0u32 : GoUInt), (2u32 : GoUInt), (31u32 : GoUInt), _argshlVUrWm1, (32u32 : stdgo.math.big.Big.Word), ("partial overlap by 5 Words of shlVU abd shift of _W - 1" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshlVUIn, (7u32 : GoUInt), (0u32 : GoUInt), (3u32 : GoUInt), (0u32 : GoUInt), _argshlVUr0, (0u32 : stdgo.math.big.Big.Word), ("partial overlap by 4 Words of shlVU and shift of 0" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshlVUIn, (7u32 : GoUInt), (0u32 : GoUInt), (3u32 : GoUInt), (1u32 : GoUInt), _argshlVUr1, (0u32 : stdgo.math.big.Big.Word), ("partial overlap by 4 Words of shlVU and shift of 1" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshlVUIn, (7u32 : GoUInt), (0u32 : GoUInt), (3u32 : GoUInt), (31u32 : GoUInt), _argshlVUrWm1, (32u32 : stdgo.math.big.Big.Word), ("partial overlap by 4 Words of shlVU and shift of _W - 1" : GoString)) : stdgo.math.big.Big.T_argVU)) : Slice<stdgo.math.big.Big.T_argVU>);
/**
    
    
    
**/
private var _argshrVUIn = (new Slice<stdgo.math.big.Big.Word>(
0,
0,
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(1u32 : stdgo.math.big.Big.Word),
(2u32 : stdgo.math.big.Big.Word),
(4u32 : stdgo.math.big.Big.Word),
(8u32 : stdgo.math.big.Big.Word),
(16u32 : stdgo.math.big.Big.Word),
(32u32 : stdgo.math.big.Big.Word),
(64u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>);
/**
    
    
    
**/
private var _argshrVUr0 = (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word), (2u32 : stdgo.math.big.Big.Word), (4u32 : stdgo.math.big.Big.Word), (8u32 : stdgo.math.big.Big.Word), (16u32 : stdgo.math.big.Big.Word), (32u32 : stdgo.math.big.Big.Word), (64u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>);
/**
    
    
    
**/
private var _argshrVUr1 = (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (1u32 : stdgo.math.big.Big.Word), (2u32 : stdgo.math.big.Big.Word), (4u32 : stdgo.math.big.Big.Word), (8u32 : stdgo.math.big.Big.Word), (16u32 : stdgo.math.big.Big.Word), (32u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>);
/**
    
    
    
**/
private var _argshrVUrWm1 = (new Slice<stdgo.math.big.Big.Word>(0, 0, (4u32 : stdgo.math.big.Big.Word), (8u32 : stdgo.math.big.Big.Word), (16u32 : stdgo.math.big.Big.Word), (32u32 : stdgo.math.big.Big.Word), (64u32 : stdgo.math.big.Big.Word), (128u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>);
/**
    
    
    
**/
private var _argshrVU = (new Slice<stdgo.math.big.Big.T_argVU>(
0,
0,
(new stdgo.math.big.Big.T_argVU((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (3u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-2147483648u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>), (7u32 : GoUInt), (1u32 : GoUInt), (1u32 : GoUInt), (1u32 : GoUInt), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-2147483647u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (2147483647u32 : stdgo.math.big.Big.Word), (1073741824u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>), (-2147483648u32 : stdgo.math.big.Big.Word), ("complete overlap of shrVU" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU((new Slice<stdgo.math.big.Big.Word>(
0,
0,
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(3u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-2147483648u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>), (7u32 : GoUInt), (4u32 : GoUInt), (1u32 : GoUInt), (1u32 : GoUInt), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-2147483647u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (2147483647u32 : stdgo.math.big.Big.Word), (1073741824u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>), (-2147483648u32 : stdgo.math.big.Big.Word), ("partial overlap by half of shrVU" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU((new Slice<stdgo.math.big.Big.Word>(
0,
0,
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(3u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-2147483648u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>), (7u32 : GoUInt), (7u32 : GoUInt), (1u32 : GoUInt), (1u32 : GoUInt), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-2147483647u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (2147483647u32 : stdgo.math.big.Big.Word), (1073741824u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>), (-2147483648u32 : stdgo.math.big.Big.Word), ("partial overlap by 1 Word of shrVU" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU((new Slice<stdgo.math.big.Big.Word>(
0,
0,
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(0u32 : stdgo.math.big.Big.Word),
(3u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-1u32 : stdgo.math.big.Big.Word),
(-2147483648u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>), (7u32 : GoUInt), (8u32 : GoUInt), (1u32 : GoUInt), (1u32 : GoUInt), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-2147483647u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (2147483647u32 : stdgo.math.big.Big.Word), (1073741824u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>), (-2147483648u32 : stdgo.math.big.Big.Word), ("no overlap of shrVU" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshrVUIn, (7u32 : GoUInt), (3u32 : GoUInt), (3u32 : GoUInt), (0u32 : GoUInt), _argshrVUr0, (0u32 : stdgo.math.big.Big.Word), ("complete overlap of shrVU and shift of 0" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshrVUIn, (7u32 : GoUInt), (3u32 : GoUInt), (3u32 : GoUInt), (1u32 : GoUInt), _argshrVUr1, (-2147483648u32 : stdgo.math.big.Big.Word), ("complete overlap of shrVU and shift of 1" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshrVUIn, (7u32 : GoUInt), (3u32 : GoUInt), (3u32 : GoUInt), (31u32 : GoUInt), _argshrVUrWm1, (2u32 : stdgo.math.big.Big.Word), ("complete overlap of shrVU and shift of _W - 1" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshrVUIn, (7u32 : GoUInt), (3u32 : GoUInt), (2u32 : GoUInt), (0u32 : GoUInt), _argshrVUr0, (0u32 : stdgo.math.big.Big.Word), ("partial overlap by 6 Words of shrVU and shift of 0" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshrVUIn, (7u32 : GoUInt), (3u32 : GoUInt), (2u32 : GoUInt), (1u32 : GoUInt), _argshrVUr1, (-2147483648u32 : stdgo.math.big.Big.Word), ("partial overlap by 6 Words of shrVU and shift of 1" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshrVUIn, (7u32 : GoUInt), (3u32 : GoUInt), (2u32 : GoUInt), (31u32 : GoUInt), _argshrVUrWm1, (2u32 : stdgo.math.big.Big.Word), ("partial overlap by 6 Words of shrVU and shift of _W - 1" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshrVUIn, (7u32 : GoUInt), (3u32 : GoUInt), (1u32 : GoUInt), (0u32 : GoUInt), _argshrVUr0, (0u32 : stdgo.math.big.Big.Word), ("partial overlap by 5 Words of shrVU and shift of 0" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshrVUIn, (7u32 : GoUInt), (3u32 : GoUInt), (1u32 : GoUInt), (1u32 : GoUInt), _argshrVUr1, (-2147483648u32 : stdgo.math.big.Big.Word), ("partial overlap by 5 Words of shrVU and shift of 1" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshrVUIn, (7u32 : GoUInt), (3u32 : GoUInt), (1u32 : GoUInt), (31u32 : GoUInt), _argshrVUrWm1, (2u32 : stdgo.math.big.Big.Word), ("partial overlap by 5 Words of shrVU and shift of _W - 1" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshrVUIn, (7u32 : GoUInt), (3u32 : GoUInt), (0u32 : GoUInt), (0u32 : GoUInt), _argshrVUr0, (0u32 : stdgo.math.big.Big.Word), ("partial overlap by 4 Words of shrVU and shift of 0" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshrVUIn, (7u32 : GoUInt), (3u32 : GoUInt), (0u32 : GoUInt), (1u32 : GoUInt), _argshrVUr1, (-2147483648u32 : stdgo.math.big.Big.Word), ("partial overlap by 4 Words of shrVU and shift of 1" : GoString)) : stdgo.math.big.Big.T_argVU),
(new stdgo.math.big.Big.T_argVU(_argshrVUIn, (7u32 : GoUInt), (3u32 : GoUInt), (0u32 : GoUInt), (31u32 : GoUInt), _argshrVUrWm1, (2u32 : stdgo.math.big.Big.Word), ("partial overlap by 4 Words of shrVU and shift of _W - 1" : GoString)) : stdgo.math.big.Big.T_argVU)) : Slice<stdgo.math.big.Big.T_argVU>);
/**
    
    
    
**/
private var _prodVWW = (new Slice<stdgo.math.big.Big.T_argVWW>(
0,
0,
(new stdgo.math.big.Big.T_argVWW() : stdgo.math.big.Big.T_argVWW),
(new stdgo.math.big.Big.T_argVWW((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVWW),
(new stdgo.math.big.Big.T_argVWW((new Slice<stdgo.math.big.Big.Word>(0, 0, (991u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (0u32 : stdgo.math.big.Big.Word), (991u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVWW),
(new stdgo.math.big.Big.T_argVWW((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVWW),
(new stdgo.math.big.Big.T_argVWW((new Slice<stdgo.math.big.Big.Word>(0, 0, (991u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (0u32 : stdgo.math.big.Big.Word), (991u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVWW),
(new stdgo.math.big.Big.T_argVWW((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (-1u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVWW),
(new stdgo.math.big.Big.T_argVWW((new Slice<stdgo.math.big.Big.Word>(0, 0, (991u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (-1u32 : stdgo.math.big.Big.Word), (991u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVWW),
(new stdgo.math.big.Big.T_argVWW((new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (1u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVWW),
(new stdgo.math.big.Big.T_argVWW((new Slice<stdgo.math.big.Big.Word>(0, 0, (992u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (1u32 : stdgo.math.big.Big.Word), (991u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVWW),
(new stdgo.math.big.Big.T_argVWW((new Slice<stdgo.math.big.Big.Word>(0, 0, (22793u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (991u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (23u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVWW),
(new stdgo.math.big.Big.T_argVWW((new Slice<stdgo.math.big.Big.Word>(0, 0, (22800u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (991u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (23u32 : stdgo.math.big.Big.Word), (7u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVWW),
(new stdgo.math.big.Big.T_argVWW((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (22793u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (991u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (23u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVWW),
(new stdgo.math.big.Big.T_argVWW((new Slice<stdgo.math.big.Big.Word>(0, 0, (7u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (22793u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (991u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (23u32 : stdgo.math.big.Big.Word), (7u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVWW),
(new stdgo.math.big.Big.T_argVWW((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (7893475u32 : stdgo.math.big.Big.Word), (7395495u32 : stdgo.math.big.Big.Word), (798547395u32 : stdgo.math.big.Big.Word), (68943u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVWW),
(new stdgo.math.big.Big.T_argVWW((new Slice<stdgo.math.big.Big.Word>(0, 0, (991u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (7893475u32 : stdgo.math.big.Big.Word), (7395495u32 : stdgo.math.big.Big.Word), (798547395u32 : stdgo.math.big.Big.Word), (68943u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (0u32 : stdgo.math.big.Big.Word), (991u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVWW),
(new stdgo.math.big.Big.T_argVWW((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (894375984u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVWW),
(new stdgo.math.big.Big.T_argVWW((new Slice<stdgo.math.big.Big.Word>(0, 0, (991u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (894375984u32 : stdgo.math.big.Big.Word), (991u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVWW),
(new stdgo.math.big.Big.T_argVWW((new Slice<stdgo.math.big.Big.Word>(0, 0, (-2u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (2u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVWW),
(new stdgo.math.big.Big.T_argVWW((new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (2u32 : stdgo.math.big.Big.Word), (1u32 : stdgo.math.big.Big.Word), (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVWW),
(new stdgo.math.big.Big.T_argVWW((new Slice<stdgo.math.big.Big.Word>(0, 0, (-128u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (128u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (127u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVWW),
(new stdgo.math.big.Big.T_argVWW((new Slice<stdgo.math.big.Big.Word>(0, 0, (-64u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (128u32 : stdgo.math.big.Big.Word), (64u32 : stdgo.math.big.Big.Word), (127u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVWW),
(new stdgo.math.big.Big.T_argVWW((new Slice<stdgo.math.big.Big.Word>(0, 0, (-128u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (128u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (127u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVWW),
(new stdgo.math.big.Big.T_argVWW((new Slice<stdgo.math.big.Big.Word>(0, 0, (-64u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (128u32 : stdgo.math.big.Big.Word), (64u32 : stdgo.math.big.Big.Word), (127u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_argVWW)) : Slice<stdgo.math.big.Big.T_argVWW>);
/**
    
    
    
**/
private var _mulWWTests = (new Slice<T__struct_0>(0, 0, ({ _x : (-1u32 : stdgo.math.big.Big.Word), _y : (-1u32 : stdgo.math.big.Big.Word), _q : (-2u32 : stdgo.math.big.Big.Word), _r : (1u32 : stdgo.math.big.Big.Word) } : T__struct_0)) : Slice<T__struct_0>);
/**
    
    
    
**/
private var _mulAddWWWTests = (new Slice<T__struct_1>(0, 0, ({ _x : (-1u32 : stdgo.math.big.Big.Word), _y : (-1u32 : stdgo.math.big.Big.Word), _c : (0u32 : stdgo.math.big.Big.Word), _q : (-2u32 : stdgo.math.big.Big.Word), _r : (1u32 : stdgo.math.big.Big.Word) } : T__struct_1), ({ _x : (-1u32 : stdgo.math.big.Big.Word), _y : (-1u32 : stdgo.math.big.Big.Word), _c : (-1u32 : stdgo.math.big.Big.Word), _q : (-1u32 : stdgo.math.big.Big.Word), _r : (0u32 : stdgo.math.big.Big.Word) } : T__struct_1)) : Slice<T__struct_1>);
/**
    
    
    
**/
private var _divWWTests = (new Slice<T__struct_2>(0, 0, ({ _x1 : (2147483647u32 : stdgo.math.big.Big.Word), _x0 : (0u32 : stdgo.math.big.Big.Word), _y : (-1u32 : stdgo.math.big.Big.Word), _q : (2147483647u32 : stdgo.math.big.Big.Word), _r : (2147483647u32 : stdgo.math.big.Big.Word) } : T__struct_2), ({ _x1 : (-1073741825u32 : stdgo.math.big.Big.Word), _x0 : (-1u32 : stdgo.math.big.Big.Word), _y : (-1073741824u32 : stdgo.math.big.Big.Word), _q : (-1u32 : stdgo.math.big.Big.Word), _r : (-1073741825u32 : stdgo.math.big.Big.Word) } : T__struct_2)) : Slice<T__struct_2>);
/**
    
    
    
**/
private var _calibrate = stdgo.flag.Flag.bool_(("calibrate" : GoString), false, ("run calibration test" : GoString));
/**
    // Selected precisions with which to run various tests.
    
    
**/
private var _precList = (new GoArray<GoUInt>(
(1u32 : GoUInt),
(2u32 : GoUInt),
(5u32 : GoUInt),
(8u32 : GoUInt),
(10u32 : GoUInt),
(16u32 : GoUInt),
(23u32 : GoUInt),
(24u32 : GoUInt),
(32u32 : GoUInt),
(50u32 : GoUInt),
(53u32 : GoUInt),
(64u32 : GoUInt),
(100u32 : GoUInt),
(128u32 : GoUInt),
(500u32 : GoUInt),
(511u32 : GoUInt),
(512u32 : GoUInt),
(513u32 : GoUInt),
(1000u32 : GoUInt),
(10000u32 : GoUInt)) : GoArray<GoUInt>);
/**
    // Selected bits with which to run various tests.
    // Each entry is a list of bits representing a floating-point number (see fromBits).
    
    
**/
private var _bitsList = (new GoArray<stdgo.math.big.Big.Bits>((new Slice<GoInt>(0, 0) : stdgo.math.big.Big.Bits), (new Slice<GoInt>(0, 0, (0 : GoInt)) : stdgo.math.big.Big.Bits), (new Slice<GoInt>(0, 0, (1 : GoInt)) : stdgo.math.big.Big.Bits), (new Slice<GoInt>(0, 0, (-1 : GoInt)) : stdgo.math.big.Big.Bits), (new Slice<GoInt>(0, 0, (10 : GoInt)) : stdgo.math.big.Big.Bits), (new Slice<GoInt>(0, 0, (-10 : GoInt)) : stdgo.math.big.Big.Bits), (new Slice<GoInt>(0, 0, (100 : GoInt), (10 : GoInt), (1 : GoInt)) : stdgo.math.big.Big.Bits), (new Slice<GoInt>(0, 0, (0 : GoInt), (-1 : GoInt), (-2 : GoInt), (-10 : GoInt)) : stdgo.math.big.Big.Bits)) : GoArray<stdgo.math.big.Big.Bits>);
/**
    
    
    
**/
private var _long = stdgo.flag.Flag.bool_(("long" : GoString), false, ("run very long tests" : GoString));
/**
    
    
    
**/
private var _floatVals = (new Slice<GoString>(
0,
0,
("0" : GoString),
("1" : GoString),
("0.1" : GoString),
("2.71828" : GoString),
("1234567890" : GoString),
("3.14e1234" : GoString),
("3.14e-1234" : GoString),
("0.738957395793475734757349579759957975985497e100" : GoString),
("0.73895739579347546656564656573475734957975995797598589749859834759476745986795497e100" : GoString),
("inf" : GoString),
("Inf" : GoString)) : Slice<GoString>);
/**
    
    
    
**/
private var _sumZZ = (new Slice<stdgo.math.big.Big.T_argZZ>(0, 0, (new stdgo.math.big.Big.T_argZZ(newInt((0i64 : GoInt64)), newInt((0i64 : GoInt64)), newInt((0i64 : GoInt64))) : stdgo.math.big.Big.T_argZZ), (new stdgo.math.big.Big.T_argZZ(newInt((1i64 : GoInt64)), newInt((1i64 : GoInt64)), newInt((0i64 : GoInt64))) : stdgo.math.big.Big.T_argZZ), (new stdgo.math.big.Big.T_argZZ(newInt((1111111110i64 : GoInt64)), newInt((123456789i64 : GoInt64)), newInt((987654321i64 : GoInt64))) : stdgo.math.big.Big.T_argZZ), (new stdgo.math.big.Big.T_argZZ(newInt((-1i64 : GoInt64)), newInt((-1i64 : GoInt64)), newInt((0i64 : GoInt64))) : stdgo.math.big.Big.T_argZZ), (new stdgo.math.big.Big.T_argZZ(newInt((864197532i64 : GoInt64)), newInt((-123456789i64 : GoInt64)), newInt((987654321i64 : GoInt64))) : stdgo.math.big.Big.T_argZZ), (new stdgo.math.big.Big.T_argZZ(newInt((-1111111110i64 : GoInt64)), newInt((-123456789i64 : GoInt64)), newInt((-987654321i64 : GoInt64))) : stdgo.math.big.Big.T_argZZ)) : Slice<stdgo.math.big.Big.T_argZZ>);
/**
    
    
    
**/
private var _prodZZ = (new Slice<stdgo.math.big.Big.T_argZZ>(0, 0, (new stdgo.math.big.Big.T_argZZ(newInt((0i64 : GoInt64)), newInt((0i64 : GoInt64)), newInt((0i64 : GoInt64))) : stdgo.math.big.Big.T_argZZ), (new stdgo.math.big.Big.T_argZZ(newInt((0i64 : GoInt64)), newInt((1i64 : GoInt64)), newInt((0i64 : GoInt64))) : stdgo.math.big.Big.T_argZZ), (new stdgo.math.big.Big.T_argZZ(newInt((1i64 : GoInt64)), newInt((1i64 : GoInt64)), newInt((1i64 : GoInt64))) : stdgo.math.big.Big.T_argZZ), (new stdgo.math.big.Big.T_argZZ(newInt((-982081i64 : GoInt64)), newInt((991i64 : GoInt64)), newInt((-991i64 : GoInt64))) : stdgo.math.big.Big.T_argZZ)) : Slice<stdgo.math.big.Big.T_argZZ>);
/**
    
    
    
**/
private var _mulRangesZ = (new Slice<T__struct_32>(
0,
0,
({ _a : (-1i64 : GoInt64), _b : (1i64 : GoInt64), _prod : ("0" : GoString) } : T__struct_32),
({ _a : (-2i64 : GoInt64), _b : (-1i64 : GoInt64), _prod : ("2" : GoString) } : T__struct_32),
({ _a : (-3i64 : GoInt64), _b : (-2i64 : GoInt64), _prod : ("6" : GoString) } : T__struct_32),
({ _a : (-3i64 : GoInt64), _b : (-1i64 : GoInt64), _prod : ("-6" : GoString) } : T__struct_32),
({ _a : (1i64 : GoInt64), _b : (3i64 : GoInt64), _prod : ("6" : GoString) } : T__struct_32),
({ _a : (-10i64 : GoInt64), _b : (-10i64 : GoInt64), _prod : ("-10" : GoString) } : T__struct_32),
({ _a : (0i64 : GoInt64), _b : (-1i64 : GoInt64), _prod : ("1" : GoString) } : T__struct_32),
({ _a : (-1i64 : GoInt64), _b : (-100i64 : GoInt64), _prod : ("1" : GoString) } : T__struct_32),
({ _a : (-1i64 : GoInt64), _b : (1i64 : GoInt64), _prod : ("0" : GoString) } : T__struct_32),
({ _a : (-1000000000i64 : GoInt64), _b : (0i64 : GoInt64), _prod : ("0" : GoString) } : T__struct_32),
({ _a : (-1000000000i64 : GoInt64), _b : (1000000000i64 : GoInt64), _prod : ("0" : GoString) } : T__struct_32),
({ _a : (-10i64 : GoInt64), _b : (-1i64 : GoInt64), _prod : ("3628800" : GoString) } : T__struct_32),
({ _a : (-20i64 : GoInt64), _b : (-2i64 : GoInt64), _prod : ("-2432902008176640000" : GoString) } : T__struct_32),
({ _a : (-99i64 : GoInt64), _b : (-1i64 : GoInt64), _prod : ("-933262154439441526816992388562667004907159682643816214685929638952175999932299156089414639761565182862536979208272237582511852109168640000000000000000000000" : GoString) } : T__struct_32)) : Slice<T__struct_32>);
/**
    // Examples from the Go Language Spec, section "Arithmetic operators"
    
    
**/
private var _divisionSignsTests = (new Slice<T__struct_34>(0, 0, ({ _x : (5i64 : GoInt64), _y : (3i64 : GoInt64), _q : (1i64 : GoInt64), _r : (2i64 : GoInt64), _d : (1i64 : GoInt64), _m : (2i64 : GoInt64) } : T__struct_34), ({ _x : (-5i64 : GoInt64), _y : (3i64 : GoInt64), _q : (-1i64 : GoInt64), _r : (-2i64 : GoInt64), _d : (-2i64 : GoInt64), _m : (1i64 : GoInt64) } : T__struct_34), ({ _x : (5i64 : GoInt64), _y : (-3i64 : GoInt64), _q : (-1i64 : GoInt64), _r : (2i64 : GoInt64), _d : (-1i64 : GoInt64), _m : (2i64 : GoInt64) } : T__struct_34), ({ _x : (-5i64 : GoInt64), _y : (-3i64 : GoInt64), _q : (1i64 : GoInt64), _r : (-2i64 : GoInt64), _d : (2i64 : GoInt64), _m : (1i64 : GoInt64) } : T__struct_34), ({ _x : (1i64 : GoInt64), _y : (2i64 : GoInt64), _q : (0i64 : GoInt64), _r : (1i64 : GoInt64), _d : (0i64 : GoInt64), _m : (1i64 : GoInt64) } : T__struct_34), ({ _x : (8i64 : GoInt64), _y : (4i64 : GoInt64), _q : (2i64 : GoInt64), _r : (0i64 : GoInt64), _d : (2i64 : GoInt64), _m : (0i64 : GoInt64) } : T__struct_34)) : Slice<T__struct_34>);
/**
    
    
    
**/
private var _quoTests = (new Slice<T__struct_35>(0, 0, ({ _x : ("476217953993950760840509444250624797097991362735329973741718102894495832294430498335824897858659711275234906400899559094370964723884706254265559534144986498357" : GoString), _y : ("9353930466774385905609975137998169297361893554149986716853295022578535724979483772383667534691121982974895531435241089241440253066816724367338287092081996" : GoString), _q : ("50911" : GoString), _r : ("1" : GoString) } : T__struct_35), ({ _x : ("11510768301994997771168" : GoString), _y : ("1328165573307167369775" : GoString), _q : ("8" : GoString), _r : ("885443715537658812968" : GoString) } : T__struct_35)) : Slice<T__struct_35>);
/**
    
    
    
**/
private var _bitLenTests = (new Slice<T__struct_36>(
0,
0,
({ _in : ("-1" : GoString), _out : (1 : GoInt) } : T__struct_36),
({ _in : ("0" : GoString), _out : (0 : GoInt) } : T__struct_36),
({ _in : ("1" : GoString), _out : (1 : GoInt) } : T__struct_36),
({ _in : ("2" : GoString), _out : (2 : GoInt) } : T__struct_36),
({ _in : ("4" : GoString), _out : (3 : GoInt) } : T__struct_36),
({ _in : ("0xabc" : GoString), _out : (12 : GoInt) } : T__struct_36),
({ _in : ("0x8000" : GoString), _out : (16 : GoInt) } : T__struct_36),
({ _in : ("0x80000000" : GoString), _out : (32 : GoInt) } : T__struct_36),
({ _in : ("0x800000000000" : GoString), _out : (48 : GoInt) } : T__struct_36),
({ _in : ("0x8000000000000000" : GoString), _out : (64 : GoInt) } : T__struct_36),
({ _in : ("0x80000000000000000000" : GoString), _out : (80 : GoInt) } : T__struct_36),
({ _in : ("-0x4000000000000000000000" : GoString), _out : (87 : GoInt) } : T__struct_36)) : Slice<T__struct_36>);
/**
    
    
    
**/
private var _expTests = (new Slice<T__struct_37>(
0,
0,
({ _x : ("0" : GoString), _y : ("0" : GoString), _m : Go.str(), _out : ("1" : GoString) } : T__struct_37),
({ _x : ("1" : GoString), _y : ("0" : GoString), _m : Go.str(), _out : ("1" : GoString) } : T__struct_37),
({ _x : ("-10" : GoString), _y : ("0" : GoString), _m : Go.str(), _out : ("1" : GoString) } : T__struct_37),
({ _x : ("1234" : GoString), _y : ("-1" : GoString), _m : Go.str(), _out : ("1" : GoString) } : T__struct_37),
({ _x : ("1234" : GoString), _y : ("-1" : GoString), _m : ("0" : GoString), _out : ("1" : GoString) } : T__struct_37),
({ _x : ("17" : GoString), _y : ("-100" : GoString), _m : ("1234" : GoString), _out : ("865" : GoString) } : T__struct_37),
({ _x : ("2" : GoString), _y : ("-100" : GoString), _m : ("1234" : GoString), _out : Go.str() } : T__struct_37),
({ _x : ("0" : GoString), _y : ("0" : GoString), _m : ("1" : GoString), _out : ("0" : GoString) } : T__struct_37),
({ _x : ("1" : GoString), _y : ("0" : GoString), _m : ("1" : GoString), _out : ("0" : GoString) } : T__struct_37),
({ _x : ("-10" : GoString), _y : ("0" : GoString), _m : ("1" : GoString), _out : ("0" : GoString) } : T__struct_37),
({ _x : ("1234" : GoString), _y : ("-1" : GoString), _m : ("1" : GoString), _out : ("0" : GoString) } : T__struct_37),
({ _x : ("5" : GoString), _y : ("1" : GoString), _m : ("3" : GoString), _out : ("2" : GoString) } : T__struct_37),
({ _x : ("5" : GoString), _y : ("-7" : GoString), _m : Go.str(), _out : ("1" : GoString) } : T__struct_37),
({ _x : ("-5" : GoString), _y : ("-7" : GoString), _m : Go.str(), _out : ("1" : GoString) } : T__struct_37),
({ _x : ("5" : GoString), _y : ("0" : GoString), _m : Go.str(), _out : ("1" : GoString) } : T__struct_37),
({ _x : ("-5" : GoString), _y : ("0" : GoString), _m : Go.str(), _out : ("1" : GoString) } : T__struct_37),
({ _x : ("5" : GoString), _y : ("1" : GoString), _m : Go.str(), _out : ("5" : GoString) } : T__struct_37),
({ _x : ("-5" : GoString), _y : ("1" : GoString), _m : Go.str(), _out : ("-5" : GoString) } : T__struct_37),
({ _x : ("-5" : GoString), _y : ("1" : GoString), _m : ("7" : GoString), _out : ("2" : GoString) } : T__struct_37),
({ _x : ("-2" : GoString), _y : ("3" : GoString), _m : ("2" : GoString), _out : ("0" : GoString) } : T__struct_37),
({ _x : ("5" : GoString), _y : ("2" : GoString), _m : Go.str(), _out : ("25" : GoString) } : T__struct_37),
({ _x : ("1" : GoString), _y : ("65537" : GoString), _m : ("2" : GoString), _out : ("1" : GoString) } : T__struct_37),
({ _x : ("0x8000000000000000" : GoString), _y : ("2" : GoString), _m : Go.str(), _out : ("0x40000000000000000000000000000000" : GoString) } : T__struct_37),
({ _x : ("0x8000000000000000" : GoString), _y : ("2" : GoString), _m : ("6719" : GoString), _out : ("4944" : GoString) } : T__struct_37),
({ _x : ("0x8000000000000000" : GoString), _y : ("3" : GoString), _m : ("6719" : GoString), _out : ("5447" : GoString) } : T__struct_37),
({ _x : ("0x8000000000000000" : GoString), _y : ("1000" : GoString), _m : ("6719" : GoString), _out : ("1603" : GoString) } : T__struct_37),
({ _x : ("0x8000000000000000" : GoString), _y : ("1000000" : GoString), _m : ("6719" : GoString), _out : ("3199" : GoString) } : T__struct_37),
({ _x : ("0x8000000000000000" : GoString), _y : ("-1000000" : GoString), _m : ("6719" : GoString), _out : ("3663" : GoString) } : T__struct_37),
({ _x : ("0xffffffffffffffffffffffffffffffff" : GoString), _y : ("0x12345678123456781234567812345678123456789" : GoString), _m : ("0x01112222333344445555666677778889" : GoString), _out : ("0x36168FA1DB3AAE6C8CE647E137F97A" : GoString) } : T__struct_37),
({ _x : ("2938462938472983472983659726349017249287491026512746239764525612965293865296239471239874193284792387498274256129746192347" : GoString), _y : ("298472983472983471903246121093472394872319615612417471234712061" : GoString), _m : ("29834729834729834729347290846729561262544958723956495615629569234729836259263598127342374289365912465901365498236492183464" : GoString), _out : ("23537740700184054162508175125554701713153216681790245129157191391322321508055833908509185839069455749219131480588829346291" : GoString) } : T__struct_37),
({ _x : ("11001289118363089646017359372117963499250546375269047542777928006103246876688756735760905680604646624353196869572752623285140408755420374049317646428185270079555372763503115646054602867593662923894140940837479507194934267532831694565516466765025434902348314525627418515646588160955862839022051353653052947073136084780742729727874803457643848197499548297570026926927502505634297079527299004267769780768565695459945235586892627059178884998772989397505061206395455591503771677500931269477503508150175717121828518985901959919560700853226255420793148986854391552859459511723547532575574664944815966793196961286234040892865" : GoString), _y : ("0xB08FFB20760FFED58FADA86DFEF71AD72AA0FA763219618FE022C197E54708BB1191C66470250FCE8879487507CEE41381CA4D932F81C2B3F1AB20B539D50DCD" : GoString), _m : ("0xAC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4A099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF6095179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B9078717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF73" : GoString), _out : ("21484252197776302499639938883777710321993113097987201050501182909581359357618579566746556372589385361683610524730509041328855066514963385522570894839035884713051640171474186548713546686476761306436434146475140156284389181808675016576845833340494848283681088886584219750554408060556769486628029028720727393293111678826356480455433909233520504112074401376133077150471237549474149190242010469539006449596611576612573955754349042329130631128234637924786466585703488460540228477440853493392086251021228087076124706778899179648655221663765993962724699135217212118535057766739392069738618682722216712319320435674779146070442" : GoString) } : T__struct_37),
({ _x : ("-0x1BCE04427D8032319A89E5C4136456671AC620883F2C4139E57F91307C485AD2D6204F4F87A58262652DB5DBBAC72B0613E51B835E7153BEC6068F5C8D696B74DBD18FEC316AEF73985CF0475663208EB46B4F17DD9DA55367B03323E5491A70997B90C059FB34809E6EE55BCFBD5F2F52233BFE62E6AA9E4E26A1D4C2439883D14F2633D55D8AA66A1ACD5595E778AC3A280517F1157989E70C1A437B849F1877B779CC3CDDEDE2DAA6594A6C66D181A00A5F777EE60596D8773998F6E988DEAE4CCA60E4DDCF9590543C89F74F603259FCAD71660D30294FBBE6490300F78A9D63FA660DC9417B8B9DDA28BEB3977B621B988E23D4D954F322C3540541BC649ABD504C50FADFD9F0987D58A2BF689313A285E773FF02899A6EF887D1D4A0D2" : GoString), _y : ("0xB08FFB20760FFED58FADA86DFEF71AD72AA0FA763219618FE022C197E54708BB1191C66470250FCE8879487507CEE41381CA4D932F81C2B3F1AB20B539D50DCD" : GoString), _m : ("0xAC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4A099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF6095179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B9078717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF73" : GoString), _out : ("21484252197776302499639938883777710321993113097987201050501182909581359357618579566746556372589385361683610524730509041328855066514963385522570894839035884713051640171474186548713546686476761306436434146475140156284389181808675016576845833340494848283681088886584219750554408060556769486628029028720727393293111678826356480455433909233520504112074401376133077150471237549474149190242010469539006449596611576612573955754349042329130631128234637924786466585703488460540228477440853493392086251021228087076124706778899179648655221663765993962724699135217212118535057766739392069738618682722216712319320435674779146070442" : GoString) } : T__struct_37),
({ _x : ("0xffffffff00000001" : GoString), _y : ("0xffffffff00000001" : GoString), _m : ("0xffffffff00000001" : GoString), _out : ("0" : GoString) } : T__struct_37),
({ _x : ("0xffffffffffffffff00000001" : GoString), _y : ("0xffffffffffffffff00000001" : GoString), _m : ("0xffffffffffffffff00000001" : GoString), _out : ("0" : GoString) } : T__struct_37),
({ _x : ("0xffffffffffffffffffffffff00000001" : GoString), _y : ("0xffffffffffffffffffffffff00000001" : GoString), _m : ("0xffffffffffffffffffffffff00000001" : GoString), _out : ("0" : GoString) } : T__struct_37),
({ _x : ("0xffffffffffffffffffffffffffffffff00000001" : GoString), _y : ("0xffffffffffffffffffffffffffffffff00000001" : GoString), _m : ("0xffffffffffffffffffffffffffffffff00000001" : GoString), _out : ("0" : GoString) } : T__struct_37),
({ _x : ("2" : GoString), _y : ("0xB08FFB20760FFED58FADA86DFEF71AD72AA0FA763219618FE022C197E54708BB1191C66470250FCE8879487507CEE41381CA4D932F81C2B3F1AB20B539D50DCD" : GoString), _m : ("0xAC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4A099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF6095179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B9078717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF73" : GoString), _out : ("0x6AADD3E3E424D5B713FCAA8D8945B1E055166132038C57BBD2D51C833F0C5EA2007A2324CE514F8E8C2F008A2F36F44005A4039CB55830986F734C93DAF0EB4BAB54A6A8C7081864F44346E9BC6F0A3EB9F2C0146A00C6A05187D0C101E1F2D038CDB70CB5E9E05A2D188AB6CBB46286624D4415E7D4DBFAD3BCC6009D915C406EED38F468B940F41E6BEDC0430DD78E6F19A7DA3A27498A4181E24D738B0072D8F6ADB8C9809A5B033A09785814FD9919F6EF9F83EEA519BEC593855C4C10CBEEC582D4AE0792158823B0275E6AEC35242740468FAF3D5C60FD1E376362B6322F78B7ED0CA1C5BBCD2B49734A56C0967A1D01A100932C837B91D592CE08ABFF" : GoString) } : T__struct_37),
({ _x : ("2" : GoString), _y : ("0xB08FFB20760FFED58FADA86DFEF71AD72AA0FA763219618FE022C197E54708BB1191C66470250FCE8879487507CEE41381CA4D932F81C2B3F1AB20B539D50DCD" : GoString), _m : ("0xAC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4A099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF6095179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B9078717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF72" : GoString), _out : ("0x7858794B5897C29F4ED0B40913416AB6C48588484E6A45F2ED3E26C941D878E923575AAC434EE2750E6439A6976F9BB4D64CEDB2A53CE8D04DD48CADCDF8E46F22747C6B81C6CEA86C0D873FBF7CEF262BAAC43A522BD7F32F3CDAC52B9337C77B3DCFB3DB3EDD80476331E82F4B1DF8EFDC1220C92656DFC9197BDC1877804E28D928A2A284B8DED506CBA304435C9D0133C246C98A7D890D1DE60CBC53A024361DA83A9B8775019083D22AC6820ED7C3C68F8E801DD4EC779EE0A05C6EB682EF9840D285B838369BA7E148FA27691D524FAEAF7C6ECE2A4B99A294B9F2C241857B5B90CC8BFFCFCF18DFA7D676131D5CD3855A5A3E8EBFA0CDFADB4D198B4A" : GoString) } : T__struct_37)) : Slice<T__struct_37>);
/**
    
    
    
**/
private var _gcdTests = (new Slice<T__struct_39>(
0,
0,
({ _d : ("0" : GoString), _x : ("0" : GoString), _y : ("0" : GoString), _a : ("0" : GoString), _b : ("0" : GoString) } : T__struct_39),
({ _d : ("7" : GoString), _x : ("0" : GoString), _y : ("1" : GoString), _a : ("0" : GoString), _b : ("7" : GoString) } : T__struct_39),
({ _d : ("7" : GoString), _x : ("0" : GoString), _y : ("-1" : GoString), _a : ("0" : GoString), _b : ("-7" : GoString) } : T__struct_39),
({ _d : ("11" : GoString), _x : ("1" : GoString), _y : ("0" : GoString), _a : ("11" : GoString), _b : ("0" : GoString) } : T__struct_39),
({ _d : ("7" : GoString), _x : ("-1" : GoString), _y : ("-2" : GoString), _a : ("-77" : GoString), _b : ("35" : GoString) } : T__struct_39),
({ _d : ("935" : GoString), _x : ("-3" : GoString), _y : ("8" : GoString), _a : ("64515" : GoString), _b : ("24310" : GoString) } : T__struct_39),
({ _d : ("935" : GoString), _x : ("-3" : GoString), _y : ("-8" : GoString), _a : ("64515" : GoString), _b : ("-24310" : GoString) } : T__struct_39),
({ _d : ("935" : GoString), _x : ("3" : GoString), _y : ("-8" : GoString), _a : ("-64515" : GoString), _b : ("-24310" : GoString) } : T__struct_39),
({ _d : ("1" : GoString), _x : ("-9" : GoString), _y : ("47" : GoString), _a : ("120" : GoString), _b : ("23" : GoString) } : T__struct_39),
({ _d : ("7" : GoString), _x : ("1" : GoString), _y : ("-2" : GoString), _a : ("77" : GoString), _b : ("35" : GoString) } : T__struct_39),
({ _d : ("935" : GoString), _x : ("-3" : GoString), _y : ("8" : GoString), _a : ("64515" : GoString), _b : ("24310" : GoString) } : T__struct_39),
({ _d : ("935000000000000000" : GoString), _x : ("-3" : GoString), _y : ("8" : GoString), _a : ("64515000000000000000" : GoString), _b : ("24310000000000000000" : GoString) } : T__struct_39),
({ _d : ("1" : GoString), _x : ("-221" : GoString), _y : ("22059940471369027483332068679400581064239780177629666810348940098015901108344" : GoString), _a : ("98920366548084643601728869055592650835572950932266967461790948584315647051443" : GoString), _b : ("991" : GoString) } : T__struct_39)) : Slice<T__struct_39>);
/**
    
    
    
**/
private var _rshTests = (new Slice<stdgo.math.big.Big.T_intShiftTest>(
0,
0,
(new stdgo.math.big.Big.T_intShiftTest(("0" : GoString), (0u32 : GoUInt), ("0" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("-0" : GoString), (0u32 : GoUInt), ("0" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("0" : GoString), (1u32 : GoUInt), ("0" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("0" : GoString), (2u32 : GoUInt), ("0" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("1" : GoString), (0u32 : GoUInt), ("1" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("1" : GoString), (1u32 : GoUInt), ("0" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("1" : GoString), (2u32 : GoUInt), ("0" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("2" : GoString), (0u32 : GoUInt), ("2" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("2" : GoString), (1u32 : GoUInt), ("1" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("-1" : GoString), (0u32 : GoUInt), ("-1" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("-1" : GoString), (1u32 : GoUInt), ("-1" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("-1" : GoString), (10u32 : GoUInt), ("-1" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("-100" : GoString), (2u32 : GoUInt), ("-25" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("-100" : GoString), (3u32 : GoUInt), ("-13" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("-100" : GoString), (100u32 : GoUInt), ("-1" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("4294967296" : GoString), (0u32 : GoUInt), ("4294967296" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("4294967296" : GoString), (1u32 : GoUInt), ("2147483648" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("4294967296" : GoString), (2u32 : GoUInt), ("1073741824" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("18446744073709551616" : GoString), (0u32 : GoUInt), ("18446744073709551616" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("18446744073709551616" : GoString), (1u32 : GoUInt), ("9223372036854775808" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("18446744073709551616" : GoString), (2u32 : GoUInt), ("4611686018427387904" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("18446744073709551616" : GoString), (64u32 : GoUInt), ("1" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("340282366920938463463374607431768211456" : GoString), (64u32 : GoUInt), ("18446744073709551616" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("340282366920938463463374607431768211456" : GoString), (128u32 : GoUInt), ("1" : GoString)) : stdgo.math.big.Big.T_intShiftTest)) : Slice<stdgo.math.big.Big.T_intShiftTest>);
/**
    
    
    
**/
private var _lshTests = (new Slice<stdgo.math.big.Big.T_intShiftTest>(
0,
0,
(new stdgo.math.big.Big.T_intShiftTest(("0" : GoString), (0u32 : GoUInt), ("0" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("0" : GoString), (1u32 : GoUInt), ("0" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("0" : GoString), (2u32 : GoUInt), ("0" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("1" : GoString), (0u32 : GoUInt), ("1" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("1" : GoString), (1u32 : GoUInt), ("2" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("1" : GoString), (2u32 : GoUInt), ("4" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("2" : GoString), (0u32 : GoUInt), ("2" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("2" : GoString), (1u32 : GoUInt), ("4" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("2" : GoString), (2u32 : GoUInt), ("8" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("-87" : GoString), (1u32 : GoUInt), ("-174" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("4294967296" : GoString), (0u32 : GoUInt), ("4294967296" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("4294967296" : GoString), (1u32 : GoUInt), ("8589934592" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("4294967296" : GoString), (2u32 : GoUInt), ("17179869184" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("18446744073709551616" : GoString), (0u32 : GoUInt), ("18446744073709551616" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("9223372036854775808" : GoString), (1u32 : GoUInt), ("18446744073709551616" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("4611686018427387904" : GoString), (2u32 : GoUInt), ("18446744073709551616" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("1" : GoString), (64u32 : GoUInt), ("18446744073709551616" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("18446744073709551616" : GoString), (64u32 : GoUInt), ("340282366920938463463374607431768211456" : GoString)) : stdgo.math.big.Big.T_intShiftTest),
(new stdgo.math.big.Big.T_intShiftTest(("1" : GoString), (128u32 : GoUInt), ("340282366920938463463374607431768211456" : GoString)) : stdgo.math.big.Big.T_intShiftTest)) : Slice<stdgo.math.big.Big.T_intShiftTest>);
/**
    // Entries must be sorted by value in ascending order.
    
    
**/
private var _cmpAbsTests = (new Slice<GoString>(0, 0, ("0" : GoString), ("1" : GoString), ("2" : GoString), ("10" : GoString), ("10000000" : GoString), ("2783678367462374683678456387645876387564783686583485" : GoString), ("2783678367462374683678456387645876387564783686583486" : GoString), ("32957394867987420967976567076075976570670947609750670956097509670576075067076027578341538" : GoString)) : Slice<GoString>);
/**
    
    
    
**/
private var _int64Tests = (new Slice<GoString>(
0,
0,
("0" : GoString),
("1" : GoString),
("-1" : GoString),
("4294967295" : GoString),
("-4294967295" : GoString),
("4294967296" : GoString),
("-4294967296" : GoString),
("9223372036854775807" : GoString),
("-9223372036854775807" : GoString),
("-9223372036854775808" : GoString),
("0x8000000000000000" : GoString),
("-0x8000000000000001" : GoString),
("38579843757496759476987459679745" : GoString),
("-38579843757496759476987459679745" : GoString)) : Slice<GoString>);
/**
    
    
    
**/
private var _uint64Tests = (new Slice<GoString>(
0,
0,
("0" : GoString),
("1" : GoString),
("4294967295" : GoString),
("4294967296" : GoString),
("8589934591" : GoString),
("8589934592" : GoString),
("9223372036854775807" : GoString),
("9223372036854775808" : GoString),
("0x08000000000000000" : GoString),
("0x10000000000000000" : GoString),
("-0x08000000000000000" : GoString),
("-1" : GoString)) : Slice<GoString>);
/**
    
    
    
**/
private var _bitwiseTests = (new Slice<T__struct_40>(
0,
0,
({ _x : ("0x00" : GoString), _y : ("0x00" : GoString), _and : ("0x00" : GoString), _or : ("0x00" : GoString), _xor : ("0x00" : GoString), _andNot : ("0x00" : GoString) } : T__struct_40),
({ _x : ("0x00" : GoString), _y : ("0x01" : GoString), _and : ("0x00" : GoString), _or : ("0x01" : GoString), _xor : ("0x01" : GoString), _andNot : ("0x00" : GoString) } : T__struct_40),
({ _x : ("0x01" : GoString), _y : ("0x00" : GoString), _and : ("0x00" : GoString), _or : ("0x01" : GoString), _xor : ("0x01" : GoString), _andNot : ("0x01" : GoString) } : T__struct_40),
({ _x : ("-0x01" : GoString), _y : ("0x00" : GoString), _and : ("0x00" : GoString), _or : ("-0x01" : GoString), _xor : ("-0x01" : GoString), _andNot : ("-0x01" : GoString) } : T__struct_40),
({ _x : ("-0xaf" : GoString), _y : ("-0x50" : GoString), _and : ("-0xf0" : GoString), _or : ("-0x0f" : GoString), _xor : ("0xe1" : GoString), _andNot : ("0x41" : GoString) } : T__struct_40),
({ _x : ("0x00" : GoString), _y : ("-0x01" : GoString), _and : ("0x00" : GoString), _or : ("-0x01" : GoString), _xor : ("-0x01" : GoString), _andNot : ("0x00" : GoString) } : T__struct_40),
({ _x : ("0x01" : GoString), _y : ("0x01" : GoString), _and : ("0x01" : GoString), _or : ("0x01" : GoString), _xor : ("0x00" : GoString), _andNot : ("0x00" : GoString) } : T__struct_40),
({ _x : ("-0x01" : GoString), _y : ("-0x01" : GoString), _and : ("-0x01" : GoString), _or : ("-0x01" : GoString), _xor : ("0x00" : GoString), _andNot : ("0x00" : GoString) } : T__struct_40),
({ _x : ("0x07" : GoString), _y : ("0x08" : GoString), _and : ("0x00" : GoString), _or : ("0x0f" : GoString), _xor : ("0x0f" : GoString), _andNot : ("0x07" : GoString) } : T__struct_40),
({ _x : ("0x05" : GoString), _y : ("0x0f" : GoString), _and : ("0x05" : GoString), _or : ("0x0f" : GoString), _xor : ("0x0a" : GoString), _andNot : ("0x00" : GoString) } : T__struct_40),
({ _x : ("0xff" : GoString), _y : ("-0x0a" : GoString), _and : ("0xf6" : GoString), _or : ("-0x01" : GoString), _xor : ("-0xf7" : GoString), _andNot : ("0x09" : GoString) } : T__struct_40),
({ _x : ("0x013ff6" : GoString), _y : ("0x9a4e" : GoString), _and : ("0x1a46" : GoString), _or : ("0x01bffe" : GoString), _xor : ("0x01a5b8" : GoString), _andNot : ("0x0125b0" : GoString) } : T__struct_40),
({ _x : ("-0x013ff6" : GoString), _y : ("0x9a4e" : GoString), _and : ("0x800a" : GoString), _or : ("-0x0125b2" : GoString), _xor : ("-0x01a5bc" : GoString), _andNot : ("-0x01c000" : GoString) } : T__struct_40),
({ _x : ("-0x013ff6" : GoString), _y : ("-0x9a4e" : GoString), _and : ("-0x01bffe" : GoString), _or : ("-0x1a46" : GoString), _xor : ("0x01a5b8" : GoString), _andNot : ("0x8008" : GoString) } : T__struct_40),
({ _x : ("0x1000009dc6e3d9822cba04129bcbe3401" : GoString), _y : ("0xb9bd7d543685789d57cb918e833af352559021483cdb05cc21fd" : GoString), _and : ("0x1000001186210100001000009048c2001" : GoString), _or : ("0xb9bd7d543685789d57cb918e8bfeff7fddb2ebe87dfbbdfe35fd" : GoString), _xor : ("0xb9bd7d543685789d57ca918e8ae69d6fcdb2eae87df2b97215fc" : GoString), _andNot : ("0x8c40c2d8822caa04120b8321400" : GoString) } : T__struct_40),
({ _x : ("0x1000009dc6e3d9822cba04129bcbe3401" : GoString), _y : ("-0xb9bd7d543685789d57cb918e833af352559021483cdb05cc21fd" : GoString), _and : ("0x8c40c2d8822caa04120b8321401" : GoString), _or : ("-0xb9bd7d543685789d57ca918e82229142459020483cd2014001fd" : GoString), _xor : ("-0xb9bd7d543685789d57ca918e8ae69d6fcdb2eae87df2b97215fe" : GoString), _andNot : ("0x1000001186210100001000009048c2000" : GoString) } : T__struct_40),
({ _x : ("-0x1000009dc6e3d9822cba04129bcbe3401" : GoString), _y : ("-0xb9bd7d543685789d57cb918e833af352559021483cdb05cc21fd" : GoString), _and : ("-0xb9bd7d543685789d57cb918e8bfeff7fddb2ebe87dfbbdfe35fd" : GoString), _or : ("-0x1000001186210100001000009048c2001" : GoString), _xor : ("0xb9bd7d543685789d57ca918e8ae69d6fcdb2eae87df2b97215fc" : GoString), _andNot : ("0xb9bd7d543685789d57ca918e82229142459020483cd2014001fc" : GoString) } : T__struct_40)) : Slice<T__struct_40>);
/**
    
    
    
**/
private var _bitsetTests = (new Slice<T__struct_41>(
0,
0,
({ _x : ("0" : GoString), _i : (0 : GoInt), _b : (0u32 : GoUInt) } : T__struct_41),
({ _x : ("0" : GoString), _i : (200 : GoInt), _b : (0u32 : GoUInt) } : T__struct_41),
({ _x : ("1" : GoString), _i : (0 : GoInt), _b : (1u32 : GoUInt) } : T__struct_41),
({ _x : ("1" : GoString), _i : (1 : GoInt), _b : (0u32 : GoUInt) } : T__struct_41),
({ _x : ("-1" : GoString), _i : (0 : GoInt), _b : (1u32 : GoUInt) } : T__struct_41),
({ _x : ("-1" : GoString), _i : (200 : GoInt), _b : (1u32 : GoUInt) } : T__struct_41),
({ _x : ("0x2000000000000000000000000000" : GoString), _i : (108 : GoInt), _b : (0u32 : GoUInt) } : T__struct_41),
({ _x : ("0x2000000000000000000000000000" : GoString), _i : (109 : GoInt), _b : (1u32 : GoUInt) } : T__struct_41),
({ _x : ("0x2000000000000000000000000000" : GoString), _i : (110 : GoInt), _b : (0u32 : GoUInt) } : T__struct_41),
({ _x : ("-0x2000000000000000000000000001" : GoString), _i : (108 : GoInt), _b : (1u32 : GoUInt) } : T__struct_41),
({ _x : ("-0x2000000000000000000000000001" : GoString), _i : (109 : GoInt), _b : (0u32 : GoUInt) } : T__struct_41),
({ _x : ("-0x2000000000000000000000000001" : GoString), _i : (110 : GoInt), _b : (1u32 : GoUInt) } : T__struct_41)) : Slice<T__struct_41>);
/**
    
    
    
**/
private var _tzbTests = (new Slice<T__struct_42>(0, 0, ({ _in : ("0" : GoString), _out : (0u32 : GoUInt) } : T__struct_42), ({ _in : ("1" : GoString), _out : (0u32 : GoUInt) } : T__struct_42), ({ _in : ("-1" : GoString), _out : (0u32 : GoUInt) } : T__struct_42), ({ _in : ("4" : GoString), _out : (2u32 : GoUInt) } : T__struct_42), ({ _in : ("-8" : GoString), _out : (3u32 : GoUInt) } : T__struct_42), ({ _in : ("0x4000000000000000000" : GoString), _out : (74u32 : GoUInt) } : T__struct_42), ({ _in : ("-0x8000000000000000000" : GoString), _out : (75u32 : GoUInt) } : T__struct_42)) : Slice<T__struct_42>);
/**
    
    
    
**/
private var _notTests = (new Slice<T__struct_43>(0, 0, ({ _in : ("0" : GoString), _out : ("-1" : GoString) } : T__struct_43), ({ _in : ("1" : GoString), _out : ("-2" : GoString) } : T__struct_43), ({ _in : ("7" : GoString), _out : ("-8" : GoString) } : T__struct_43), ({ _in : ("0" : GoString), _out : ("-1" : GoString) } : T__struct_43), ({ _in : ("-81910" : GoString), _out : ("81909" : GoString) } : T__struct_43), ({ _in : ("298472983472983471903246121093472394872319615612417471234712061" : GoString), _out : ("-298472983472983471903246121093472394872319615612417471234712062" : GoString) } : T__struct_43)) : Slice<T__struct_43>);
/**
    
    
    
**/
private var _modInverseTests = (new Slice<T__struct_44>(0, 0, ({ _element : ("1234567" : GoString), _modulus : ("458948883992" : GoString) } : T__struct_44), ({ _element : ("239487239847" : GoString), _modulus : ("2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919" : GoString) } : T__struct_44), ({ _element : ("-10" : GoString), _modulus : ("13" : GoString) } : T__struct_44), ({ _element : ("10" : GoString), _modulus : ("-13" : GoString) } : T__struct_44), ({ _element : ("-17" : GoString), _modulus : ("-13" : GoString) } : T__struct_44)) : Slice<T__struct_44>);
/**
    
    
    
**/
private var _stringTests = (new Slice<T__struct_46>(
0,
0,
({ _in : Go.str(), _out : ("" : GoString), _base : (0 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("a" : GoString), _out : ("" : GoString), _base : (0 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("z" : GoString), _out : ("" : GoString), _base : (0 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("+" : GoString), _out : ("" : GoString), _base : (0 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("-" : GoString), _out : ("" : GoString), _base : (0 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("0b" : GoString), _out : ("" : GoString), _base : (0 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("0o" : GoString), _out : ("" : GoString), _base : (0 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("0x" : GoString), _out : ("" : GoString), _base : (0 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("0y" : GoString), _out : ("" : GoString), _base : (0 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("2" : GoString), _out : ("" : GoString), _base : (2 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("0b2" : GoString), _out : ("" : GoString), _base : (0 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("08" : GoString), _out : ("" : GoString), _base : (0 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("8" : GoString), _out : ("" : GoString), _base : (8 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("0xg" : GoString), _out : ("" : GoString), _base : (0 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("g" : GoString), _out : ("" : GoString), _base : (16 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("_" : GoString), _out : ("" : GoString), _base : (0 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("0_" : GoString), _out : ("" : GoString), _base : (0 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("_0" : GoString), _out : ("" : GoString), _base : (0 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("-1__0" : GoString), _out : ("" : GoString), _base : (0 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("0x10_" : GoString), _out : ("" : GoString), _base : (0 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("1_000" : GoString), _out : ("" : GoString), _base : (10 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("d_e_a_d" : GoString), _out : ("" : GoString), _base : (16 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("0" : GoString), _out : ("0" : GoString), _base : (0 : GoInt), _val : (0i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("0" : GoString), _out : ("0" : GoString), _base : (10 : GoInt), _val : (0i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("0" : GoString), _out : ("0" : GoString), _base : (16 : GoInt), _val : (0i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("+0" : GoString), _out : ("0" : GoString), _base : (0 : GoInt), _val : (0i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("-0" : GoString), _out : ("0" : GoString), _base : (0 : GoInt), _val : (0i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("10" : GoString), _out : ("10" : GoString), _base : (0 : GoInt), _val : (10i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("10" : GoString), _out : ("10" : GoString), _base : (10 : GoInt), _val : (10i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("10" : GoString), _out : ("10" : GoString), _base : (16 : GoInt), _val : (16i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("-10" : GoString), _out : ("-10" : GoString), _base : (16 : GoInt), _val : (-16i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("+10" : GoString), _out : ("10" : GoString), _base : (16 : GoInt), _val : (16i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("0b10" : GoString), _out : ("2" : GoString), _base : (0 : GoInt), _val : (2i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("0o10" : GoString), _out : ("8" : GoString), _base : (0 : GoInt), _val : (8i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("0x10" : GoString), _out : ("16" : GoString), _base : (0 : GoInt), _val : (16i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("0x10" : GoString), _out : ("" : GoString), _base : (16 : GoInt), _val : (0 : GoInt64), _ok : false } : T__struct_46),
({ _in : ("-0x10" : GoString), _out : ("-16" : GoString), _base : (0 : GoInt), _val : (-16i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("+0x10" : GoString), _out : ("16" : GoString), _base : (0 : GoInt), _val : (16i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("00" : GoString), _out : ("0" : GoString), _base : (0 : GoInt), _val : (0i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("0" : GoString), _out : ("0" : GoString), _base : (8 : GoInt), _val : (0i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("07" : GoString), _out : ("7" : GoString), _base : (0 : GoInt), _val : (7i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("7" : GoString), _out : ("7" : GoString), _base : (8 : GoInt), _val : (7i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("023" : GoString), _out : ("19" : GoString), _base : (0 : GoInt), _val : (19i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("23" : GoString), _out : ("23" : GoString), _base : (8 : GoInt), _val : (19i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("cafebabe" : GoString), _out : ("cafebabe" : GoString), _base : (16 : GoInt), _val : (3405691582i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("0b0" : GoString), _out : ("0" : GoString), _base : (0 : GoInt), _val : (0i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("-111" : GoString), _out : ("-111" : GoString), _base : (2 : GoInt), _val : (-7i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("-0b111" : GoString), _out : ("-7" : GoString), _base : (0 : GoInt), _val : (-7i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("0b1001010111" : GoString), _out : ("599" : GoString), _base : (0 : GoInt), _val : (599i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("1001010111" : GoString), _out : ("1001010111" : GoString), _base : (2 : GoInt), _val : (599i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("A" : GoString), _out : ("a" : GoString), _base : (36 : GoInt), _val : (10i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("A" : GoString), _out : ("A" : GoString), _base : (37 : GoInt), _val : (36i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("ABCXYZ" : GoString), _out : ("abcxyz" : GoString), _base : (36 : GoInt), _val : (623741435i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("ABCXYZ" : GoString), _out : ("ABCXYZ" : GoString), _base : (62 : GoInt), _val : (33536793425i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("1_000" : GoString), _out : ("1000" : GoString), _base : (0 : GoInt), _val : (1000i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("0b_1010" : GoString), _out : ("10" : GoString), _base : (0 : GoInt), _val : (10i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("+0o_660" : GoString), _out : ("432" : GoString), _base : (0 : GoInt), _val : (432i64 : GoInt64), _ok : true } : T__struct_46),
({ _in : ("-0xF00D_1E" : GoString), _out : ("-15731998" : GoString), _base : (0 : GoInt), _val : (-15731998i64 : GoInt64), _ok : true } : T__struct_46)) : Slice<T__struct_46>);
/**
    
    
    
**/
private var _formatTests = (new Slice<T__struct_47>(
0,
0,
({ _input : ("<nil>" : GoString), _format : ("%x" : GoString), _output : ("<nil>" : GoString) } : T__struct_47),
({ _input : ("<nil>" : GoString), _format : ("%#x" : GoString), _output : ("<nil>" : GoString) } : T__struct_47),
({ _input : ("<nil>" : GoString), _format : ("%#y" : GoString), _output : ("%!y(big.Int=<nil>)" : GoString) } : T__struct_47),
({ _input : ("10" : GoString), _format : ("%b" : GoString), _output : ("1010" : GoString) } : T__struct_47),
({ _input : ("10" : GoString), _format : ("%o" : GoString), _output : ("12" : GoString) } : T__struct_47),
({ _input : ("10" : GoString), _format : ("%d" : GoString), _output : ("10" : GoString) } : T__struct_47),
({ _input : ("10" : GoString), _format : ("%v" : GoString), _output : ("10" : GoString) } : T__struct_47),
({ _input : ("10" : GoString), _format : ("%x" : GoString), _output : ("a" : GoString) } : T__struct_47),
({ _input : ("10" : GoString), _format : ("%X" : GoString), _output : ("A" : GoString) } : T__struct_47),
({ _input : ("-10" : GoString), _format : ("%X" : GoString), _output : ("-A" : GoString) } : T__struct_47),
({ _input : ("10" : GoString), _format : ("%y" : GoString), _output : ("%!y(big.Int=10)" : GoString) } : T__struct_47),
({ _input : ("-10" : GoString), _format : ("%y" : GoString), _output : ("%!y(big.Int=-10)" : GoString) } : T__struct_47),
({ _input : ("10" : GoString), _format : ("%#b" : GoString), _output : ("0b1010" : GoString) } : T__struct_47),
({ _input : ("10" : GoString), _format : ("%#o" : GoString), _output : ("012" : GoString) } : T__struct_47),
({ _input : ("10" : GoString), _format : ("%O" : GoString), _output : ("0o12" : GoString) } : T__struct_47),
({ _input : ("-10" : GoString), _format : ("%#b" : GoString), _output : ("-0b1010" : GoString) } : T__struct_47),
({ _input : ("-10" : GoString), _format : ("%#o" : GoString), _output : ("-012" : GoString) } : T__struct_47),
({ _input : ("-10" : GoString), _format : ("%O" : GoString), _output : ("-0o12" : GoString) } : T__struct_47),
({ _input : ("10" : GoString), _format : ("%#d" : GoString), _output : ("10" : GoString) } : T__struct_47),
({ _input : ("10" : GoString), _format : ("%#v" : GoString), _output : ("10" : GoString) } : T__struct_47),
({ _input : ("10" : GoString), _format : ("%#x" : GoString), _output : ("0xa" : GoString) } : T__struct_47),
({ _input : ("10" : GoString), _format : ("%#X" : GoString), _output : ("0XA" : GoString) } : T__struct_47),
({ _input : ("-10" : GoString), _format : ("%#X" : GoString), _output : ("-0XA" : GoString) } : T__struct_47),
({ _input : ("10" : GoString), _format : ("%#y" : GoString), _output : ("%!y(big.Int=10)" : GoString) } : T__struct_47),
({ _input : ("-10" : GoString), _format : ("%#y" : GoString), _output : ("%!y(big.Int=-10)" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%d" : GoString), _output : ("1234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%3d" : GoString), _output : ("1234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%4d" : GoString), _output : ("1234" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%d" : GoString), _output : ("-1234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("% 5d" : GoString), _output : (" 1234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%+5d" : GoString), _output : ("+1234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%-5d" : GoString), _output : ("1234 " : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%x" : GoString), _output : ("4d2" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%X" : GoString), _output : ("4D2" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%3x" : GoString), _output : ("-4d2" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%4x" : GoString), _output : ("-4d2" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%5x" : GoString), _output : (" -4d2" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%-5x" : GoString), _output : ("-4d2 " : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%03d" : GoString), _output : ("1234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%04d" : GoString), _output : ("1234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%05d" : GoString), _output : ("01234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%06d" : GoString), _output : ("001234" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%06d" : GoString), _output : ("-01234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%+06d" : GoString), _output : ("+01234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("% 06d" : GoString), _output : (" 01234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%-6d" : GoString), _output : ("1234  " : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%-06d" : GoString), _output : ("1234  " : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%-06d" : GoString), _output : ("-1234 " : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%.3d" : GoString), _output : ("1234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%.4d" : GoString), _output : ("1234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%.5d" : GoString), _output : ("01234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%.6d" : GoString), _output : ("001234" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%.3d" : GoString), _output : ("-1234" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%.4d" : GoString), _output : ("-1234" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%.5d" : GoString), _output : ("-01234" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%.6d" : GoString), _output : ("-001234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%8.3d" : GoString), _output : ("    1234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%8.4d" : GoString), _output : ("    1234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%8.5d" : GoString), _output : ("   01234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%8.6d" : GoString), _output : ("  001234" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%8.3d" : GoString), _output : ("   -1234" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%8.4d" : GoString), _output : ("   -1234" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%8.5d" : GoString), _output : ("  -01234" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%8.6d" : GoString), _output : (" -001234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%+8.3d" : GoString), _output : ("   +1234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%+8.4d" : GoString), _output : ("   +1234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%+8.5d" : GoString), _output : ("  +01234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%+8.6d" : GoString), _output : (" +001234" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%+8.3d" : GoString), _output : ("   -1234" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%+8.4d" : GoString), _output : ("   -1234" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%+8.5d" : GoString), _output : ("  -01234" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%+8.6d" : GoString), _output : (" -001234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("% 8.3d" : GoString), _output : ("    1234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("% 8.4d" : GoString), _output : ("    1234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("% 8.5d" : GoString), _output : ("   01234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("% 8.6d" : GoString), _output : ("  001234" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("% 8.3d" : GoString), _output : ("   -1234" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("% 8.4d" : GoString), _output : ("   -1234" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("% 8.5d" : GoString), _output : ("  -01234" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("% 8.6d" : GoString), _output : (" -001234" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%.3x" : GoString), _output : ("4d2" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%.4x" : GoString), _output : ("04d2" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%.5x" : GoString), _output : ("004d2" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%.6x" : GoString), _output : ("0004d2" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%.3x" : GoString), _output : ("-4d2" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%.4x" : GoString), _output : ("-04d2" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%.5x" : GoString), _output : ("-004d2" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%.6x" : GoString), _output : ("-0004d2" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%8.3x" : GoString), _output : ("     4d2" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%8.4x" : GoString), _output : ("    04d2" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%8.5x" : GoString), _output : ("   004d2" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%8.6x" : GoString), _output : ("  0004d2" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%8.3x" : GoString), _output : ("    -4d2" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%8.4x" : GoString), _output : ("   -04d2" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%8.5x" : GoString), _output : ("  -004d2" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%8.6x" : GoString), _output : (" -0004d2" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%+8.3x" : GoString), _output : ("    +4d2" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%+8.4x" : GoString), _output : ("   +04d2" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%+8.5x" : GoString), _output : ("  +004d2" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%+8.6x" : GoString), _output : (" +0004d2" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%+8.3x" : GoString), _output : ("    -4d2" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%+8.4x" : GoString), _output : ("   -04d2" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%+8.5x" : GoString), _output : ("  -004d2" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%+8.6x" : GoString), _output : (" -0004d2" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("% 8.3x" : GoString), _output : ("     4d2" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("% 8.4x" : GoString), _output : ("    04d2" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("% 8.5x" : GoString), _output : ("   004d2" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("% 8.6x" : GoString), _output : ("  0004d2" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("% 8.7x" : GoString), _output : (" 00004d2" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("% 8.8x" : GoString), _output : (" 000004d2" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("% 8.3x" : GoString), _output : ("    -4d2" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("% 8.4x" : GoString), _output : ("   -04d2" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("% 8.5x" : GoString), _output : ("  -004d2" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("% 8.6x" : GoString), _output : (" -0004d2" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("% 8.7x" : GoString), _output : ("-00004d2" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("% 8.8x" : GoString), _output : ("-000004d2" : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%-8.3d" : GoString), _output : ("1234    " : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%-8.4d" : GoString), _output : ("1234    " : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%-8.5d" : GoString), _output : ("01234   " : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%-8.6d" : GoString), _output : ("001234  " : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%-8.7d" : GoString), _output : ("0001234 " : GoString) } : T__struct_47),
({ _input : ("1234" : GoString), _format : ("%-8.8d" : GoString), _output : ("00001234" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%-8.3d" : GoString), _output : ("-1234   " : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%-8.4d" : GoString), _output : ("-1234   " : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%-8.5d" : GoString), _output : ("-01234  " : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%-8.6d" : GoString), _output : ("-001234 " : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%-8.7d" : GoString), _output : ("-0001234" : GoString) } : T__struct_47),
({ _input : ("-1234" : GoString), _format : ("%-8.8d" : GoString), _output : ("-00001234" : GoString) } : T__struct_47),
({ _input : ("16777215" : GoString), _format : ("%b" : GoString), _output : ("111111111111111111111111" : GoString) } : T__struct_47),
({ _input : ("0" : GoString), _format : ("%.d" : GoString), _output : Go.str() } : T__struct_47),
({ _input : ("0" : GoString), _format : ("%.0d" : GoString), _output : Go.str() } : T__struct_47),
({ _input : ("0" : GoString), _format : ("%3.d" : GoString), _output : Go.str() } : T__struct_47)) : Slice<T__struct_47>);
/**
    
    
    
**/
private var _scanTests = (new Slice<T__struct_48>(
0,
0,
({ _input : ("1010" : GoString), _format : ("%b" : GoString), _output : ("10" : GoString), _remaining : (0 : GoInt) } : T__struct_48),
({ _input : ("0b1010" : GoString), _format : ("%v" : GoString), _output : ("10" : GoString), _remaining : (0 : GoInt) } : T__struct_48),
({ _input : ("12" : GoString), _format : ("%o" : GoString), _output : ("10" : GoString), _remaining : (0 : GoInt) } : T__struct_48),
({ _input : ("012" : GoString), _format : ("%v" : GoString), _output : ("10" : GoString), _remaining : (0 : GoInt) } : T__struct_48),
({ _input : ("10" : GoString), _format : ("%d" : GoString), _output : ("10" : GoString), _remaining : (0 : GoInt) } : T__struct_48),
({ _input : ("10" : GoString), _format : ("%v" : GoString), _output : ("10" : GoString), _remaining : (0 : GoInt) } : T__struct_48),
({ _input : ("a" : GoString), _format : ("%x" : GoString), _output : ("10" : GoString), _remaining : (0 : GoInt) } : T__struct_48),
({ _input : ("0xa" : GoString), _format : ("%v" : GoString), _output : ("10" : GoString), _remaining : (0 : GoInt) } : T__struct_48),
({ _input : ("A" : GoString), _format : ("%X" : GoString), _output : ("10" : GoString), _remaining : (0 : GoInt) } : T__struct_48),
({ _input : ("-A" : GoString), _format : ("%X" : GoString), _output : ("-10" : GoString), _remaining : (0 : GoInt) } : T__struct_48),
({ _input : ("+0b1011001" : GoString), _format : ("%v" : GoString), _output : ("89" : GoString), _remaining : (0 : GoInt) } : T__struct_48),
({ _input : ("0xA" : GoString), _format : ("%v" : GoString), _output : ("10" : GoString), _remaining : (0 : GoInt) } : T__struct_48),
({ _input : ("0 " : GoString), _format : ("%v" : GoString), _output : ("0" : GoString), _remaining : (1 : GoInt) } : T__struct_48),
({ _input : ("2+3" : GoString), _format : ("%v" : GoString), _output : ("2" : GoString), _remaining : (2 : GoInt) } : T__struct_48),
({ _input : ("0XABC 12" : GoString), _format : ("%v" : GoString), _output : ("2748" : GoString), _remaining : (3 : GoInt) } : T__struct_48)) : Slice<T__struct_48>);
/**
    
    
    
**/
private var _encodingTests = (new Slice<GoString>(0, 0, ("0" : GoString), ("1" : GoString), ("2" : GoString), ("10" : GoString), ("1000" : GoString), ("1234567890" : GoString), ("298472983472983471903246121093472394872319615612417471234712061" : GoString)) : Slice<GoString>);
/**
    
    
    
**/
private var _cmpTests = (new Slice<T__struct_49>(
0,
0,
({ _x : null, _y : null, _r : (0 : GoInt) } : T__struct_49),
({ _x : null, _y : (new stdgo.math.big.Big.T_nat(0, 0) : T_nat), _r : (0 : GoInt) } : T__struct_49),
({ _x : (new stdgo.math.big.Big.T_nat(0, 0) : T_nat), _y : null, _r : (0 : GoInt) } : T__struct_49),
({ _x : (new stdgo.math.big.Big.T_nat(0, 0) : T_nat), _y : (new stdgo.math.big.Big.T_nat(0, 0) : T_nat), _r : (0 : GoInt) } : T__struct_49),
({ _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _y : (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _r : (0 : GoInt) } : T__struct_49),
({ _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _y : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _r : (-1 : GoInt) } : T__struct_49),
({ _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _y : (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _r : (1 : GoInt) } : T__struct_49),
({ _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _y : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _r : (0 : GoInt) } : T__struct_49),
({ _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _y : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _r : (1 : GoInt) } : T__struct_49),
({ _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _y : (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _r : (-1 : GoInt) } : T__struct_49),
({ _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _y : (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _r : (1 : GoInt) } : T__struct_49),
({ _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _y : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _r : (-1 : GoInt) } : T__struct_49),
({ _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (16u32 : stdgo.math.big.Big.Word), (571956u32 : stdgo.math.big.Big.Word), (8794u32 : stdgo.math.big.Big.Word), (68u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _y : (new Slice<stdgo.math.big.Big.Word>(0, 0, (837u32 : stdgo.math.big.Big.Word), (9146u32 : stdgo.math.big.Big.Word), (1u32 : stdgo.math.big.Big.Word), (754489u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _r : (-1 : GoInt) } : T__struct_49),
({ _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (34986u32 : stdgo.math.big.Big.Word), (41u32 : stdgo.math.big.Big.Word), (105u32 : stdgo.math.big.Big.Word), (1957u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _y : (new Slice<stdgo.math.big.Big.Word>(0, 0, (56u32 : stdgo.math.big.Big.Word), (7458u32 : stdgo.math.big.Big.Word), (104u32 : stdgo.math.big.Big.Word), (1957u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _r : (1 : GoInt) } : T__struct_49)) : Slice<T__struct_49>);
/**
    
    
    
**/
private var _sumNN = (new Slice<stdgo.math.big.Big.T_argNN>(0, 0, (new stdgo.math.big.Big.T_argNN() : stdgo.math.big.Big.T_argNN), (new stdgo.math.big.Big.T_argNN((new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), null, (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat)) : stdgo.math.big.Big.T_argNN), (new stdgo.math.big.Big.T_argNN((new Slice<stdgo.math.big.Big.Word>(0, 0, (1111111110u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (123456789u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (987654321u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat)) : stdgo.math.big.Big.T_argNN), (new stdgo.math.big.Big.T_argNN((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), null, (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat)) : stdgo.math.big.Big.T_argNN), (new stdgo.math.big.Big.T_argNN((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (1111111110u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (123456789u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (987654321u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat)) : stdgo.math.big.Big.T_argNN), (new stdgo.math.big.Big.T_argNN((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (-1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat)) : stdgo.math.big.Big.T_argNN)) : Slice<stdgo.math.big.Big.T_argNN>);
/**
    
    
    
**/
private var _prodNN = (new Slice<stdgo.math.big.Big.T_argNN>(
0,
0,
(new stdgo.math.big.Big.T_argNN() : stdgo.math.big.Big.T_argNN),
(new stdgo.math.big.Big.T_argNN(null, null, null) : stdgo.math.big.Big.T_argNN),
(new stdgo.math.big.Big.T_argNN(null, (new Slice<stdgo.math.big.Big.Word>(0, 0, (991u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), null) : stdgo.math.big.Big.T_argNN),
(new stdgo.math.big.Big.T_argNN((new Slice<stdgo.math.big.Big.Word>(0, 0, (991u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (991u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat)) : stdgo.math.big.Big.T_argNN),
(new stdgo.math.big.Big.T_argNN((new Slice<stdgo.math.big.Big.Word>(0, 0, (982081u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (991u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (991u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat)) : stdgo.math.big.Big.T_argNN),
(new stdgo.math.big.Big.T_argNN((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (982081u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (991u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (991u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat)) : stdgo.math.big.Big.T_argNN),
(new stdgo.math.big.Big.T_argNN((new Slice<stdgo.math.big.Big.Word>(0, 0, (991u32 : stdgo.math.big.Big.Word), (1982u32 : stdgo.math.big.Big.Word), (2973u32 : stdgo.math.big.Big.Word), (3964u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word), (2u32 : stdgo.math.big.Big.Word), (3u32 : stdgo.math.big.Big.Word), (4u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (991u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat)) : stdgo.math.big.Big.T_argNN),
(new stdgo.math.big.Big.T_argNN((new Slice<stdgo.math.big.Big.Word>(0, 0, (4u32 : stdgo.math.big.Big.Word), (11u32 : stdgo.math.big.Big.Word), (20u32 : stdgo.math.big.Big.Word), (30u32 : stdgo.math.big.Big.Word), (20u32 : stdgo.math.big.Big.Word), (11u32 : stdgo.math.big.Big.Word), (4u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word), (2u32 : stdgo.math.big.Big.Word), (3u32 : stdgo.math.big.Big.Word), (4u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (4u32 : stdgo.math.big.Big.Word), (3u32 : stdgo.math.big.Big.Word), (2u32 : stdgo.math.big.Big.Word), (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat)) : stdgo.math.big.Big.T_argNN),
(new stdgo.math.big.Big.T_argNN(_natFromString(("11790184577738583171520872861412518665678211592275841109096961" : GoString)), _natFromString(("515377520732011331036461129765621272702107522001" : GoString)), _natFromString(("22876792454961" : GoString))) : stdgo.math.big.Big.T_argNN),
(new stdgo.math.big.Big.T_argNN(_natFromString(stdgo.strings.Strings.repeat(("1" : GoString), (70000 : GoInt))), _natFromString(("1" : GoString) + stdgo.strings.Strings.repeat(stdgo.strings.Strings.repeat(("0" : GoString), (699 : GoInt)) + ("1" : GoString), (99 : GoInt))), _natFromString(stdgo.strings.Strings.repeat(("1" : GoString), (700 : GoInt)))) : stdgo.math.big.Big.T_argNN),
(new stdgo.math.big.Big.T_argNN(_natFromString(stdgo.strings.Strings.repeat(("1" : GoString), (20000 : GoInt))), _natFromString((("1" : GoString) + stdgo.strings.Strings.repeat(("0" : GoString), (9999 : GoInt))) + ("1" : GoString)), _natFromString(stdgo.strings.Strings.repeat(("1" : GoString), (10000 : GoInt)))) : stdgo.math.big.Big.T_argNN)) : Slice<stdgo.math.big.Big.T_argNN>);
/**
    
    
    
**/
private var _mulRangesN = (new Slice<T__struct_50>(
0,
0,
({ _a : (0i64 : GoUInt64), _b : (0i64 : GoUInt64), _prod : ("0" : GoString) } : T__struct_50),
({ _a : (1i64 : GoUInt64), _b : (1i64 : GoUInt64), _prod : ("1" : GoString) } : T__struct_50),
({ _a : (1i64 : GoUInt64), _b : (2i64 : GoUInt64), _prod : ("2" : GoString) } : T__struct_50),
({ _a : (1i64 : GoUInt64), _b : (3i64 : GoUInt64), _prod : ("6" : GoString) } : T__struct_50),
({ _a : (10i64 : GoUInt64), _b : (10i64 : GoUInt64), _prod : ("10" : GoString) } : T__struct_50),
({ _a : (0i64 : GoUInt64), _b : (100i64 : GoUInt64), _prod : ("0" : GoString) } : T__struct_50),
({ _a : (0i64 : GoUInt64), _b : (1000000000i64 : GoUInt64), _prod : ("0" : GoString) } : T__struct_50),
({ _a : (1i64 : GoUInt64), _b : (0i64 : GoUInt64), _prod : ("1" : GoString) } : T__struct_50),
({ _a : (100i64 : GoUInt64), _b : (1i64 : GoUInt64), _prod : ("1" : GoString) } : T__struct_50),
({ _a : (1i64 : GoUInt64), _b : (10i64 : GoUInt64), _prod : ("3628800" : GoString) } : T__struct_50),
({ _a : (1i64 : GoUInt64), _b : (20i64 : GoUInt64), _prod : ("2432902008176640000" : GoString) } : T__struct_50),
({ _a : (1i64 : GoUInt64), _b : (100i64 : GoUInt64), _prod : ("93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000" : GoString) } : T__struct_50)) : Slice<T__struct_50>);
/**
    
    
    
**/
private var _mulBenchSizes = (new Slice<GoInt>(0, 0, (10 : GoInt), (100 : GoInt), (1000 : GoInt), (10000 : GoInt), (100000 : GoInt)) : Slice<GoInt>);
/**
    
    
    
**/
private var _leftShiftTests = (new Slice<stdgo.math.big.Big.T_shiftTest>(0, 0, (new stdgo.math.big.Big.T_shiftTest(null, (0u32 : GoUInt), null) : stdgo.math.big.Big.T_shiftTest), (new stdgo.math.big.Big.T_shiftTest(null, (1u32 : GoUInt), null) : stdgo.math.big.Big.T_shiftTest), (new stdgo.math.big.Big.T_shiftTest(_natOne, (0u32 : GoUInt), _natOne) : stdgo.math.big.Big.T_shiftTest), (new stdgo.math.big.Big.T_shiftTest(_natOne, (1u32 : GoUInt), _natTwo) : stdgo.math.big.Big.T_shiftTest), (new stdgo.math.big.Big.T_shiftTest((new Slice<stdgo.math.big.Big.Word>(0, 0, (-2147483648u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (1u32 : GoUInt), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat)) : stdgo.math.big.Big.T_shiftTest), (new stdgo.math.big.Big.T_shiftTest((new Slice<stdgo.math.big.Big.Word>(0, 0, (-2147483648u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (1u32 : GoUInt), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat)) : stdgo.math.big.Big.T_shiftTest)) : Slice<stdgo.math.big.Big.T_shiftTest>);
/**
    
    
    
**/
private var _rightShiftTests = (new Slice<stdgo.math.big.Big.T_shiftTest>(0, 0, (new stdgo.math.big.Big.T_shiftTest(null, (0u32 : GoUInt), null) : stdgo.math.big.Big.T_shiftTest), (new stdgo.math.big.Big.T_shiftTest(null, (1u32 : GoUInt), null) : stdgo.math.big.Big.T_shiftTest), (new stdgo.math.big.Big.T_shiftTest(_natOne, (0u32 : GoUInt), _natOne) : stdgo.math.big.Big.T_shiftTest), (new stdgo.math.big.Big.T_shiftTest(_natOne, (1u32 : GoUInt), null) : stdgo.math.big.Big.T_shiftTest), (new stdgo.math.big.Big.T_shiftTest(_natTwo, (1u32 : GoUInt), _natOne) : stdgo.math.big.Big.T_shiftTest), (new stdgo.math.big.Big.T_shiftTest((new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (1u32 : GoUInt), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-2147483648u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat)) : stdgo.math.big.Big.T_shiftTest), (new stdgo.math.big.Big.T_shiftTest((new Slice<stdgo.math.big.Big.Word>(0, 0, (2u32 : stdgo.math.big.Big.Word), (1u32 : stdgo.math.big.Big.Word), (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (1u32 : GoUInt), (new Slice<stdgo.math.big.Big.Word>(0, 0, (-2147483647u32 : stdgo.math.big.Big.Word), (-2147483648u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat)) : stdgo.math.big.Big.T_shiftTest)) : Slice<stdgo.math.big.Big.T_shiftTest>);
/**
    
    
    
**/
private var _modWTests32 = (new Slice<stdgo.math.big.Big.T_modWTest>(0, 0, (new stdgo.math.big.Big.T_modWTest(("23492635982634928349238759823742" : GoString), ("252341" : GoString), ("220170" : GoString)) : stdgo.math.big.Big.T_modWTest)) : Slice<stdgo.math.big.Big.T_modWTest>);
/**
    
    
    
**/
private var _modWTests64 = (new Slice<stdgo.math.big.Big.T_modWTest>(0, 0, (new stdgo.math.big.Big.T_modWTest(("6527895462947293856291561095690465243862946" : GoString), ("524326975699234" : GoString), ("375066989628668" : GoString)) : stdgo.math.big.Big.T_modWTest)) : Slice<stdgo.math.big.Big.T_modWTest>);
/**
    
    
    
**/
private var _montgomeryTests = (new Slice<T__struct_51>(0, 0, ({ _x : ("0xffffffffffffffffffffffffffffffffffffffffffffffffe" : GoString), _y : ("0xffffffffffffffffffffffffffffffffffffffffffffffffe" : GoString), _m : ("0xfffffffffffffffffffffffffffffffffffffffffffffffff" : GoString), _k0 : (1i64 : GoUInt64), _out32 : ("0x1000000000000000000000000000000000000000000" : GoString), _out64 : ("0x10000000000000000000000000000000000" : GoString) } : T__struct_51), ({ _x : ("0x000000000ffffff5" : GoString), _y : ("0x000000000ffffff0" : GoString), _m : ("0x0000000010000001" : GoString), _k0 : (-72057593769492481i64 : GoUInt64), _out32 : ("0x000000000bfffff4" : GoString), _out64 : ("0x0000000003400001" : GoString) } : T__struct_51), ({ _x : ("0x0000000080000000" : GoString), _y : ("0x00000000ffffffff" : GoString), _m : ("0x1000000000000001" : GoString), _k0 : (1152921504606846975i64 : GoUInt64), _out32 : ("0x0800000008000001" : GoString), _out64 : ("0x0800000008000001" : GoString) } : T__struct_51), ({ _x : ("0x0000000080000000" : GoString), _y : ("0x0000000080000000" : GoString), _m : ("0xffffffff00000001" : GoString), _k0 : (-4294967297i64 : GoUInt64), _out32 : ("0xbfffffff40000001" : GoString), _out64 : ("0xbfffffff40000001" : GoString) } : T__struct_51), ({ _x : ("0x0000000080000000" : GoString), _y : ("0x0000000080000000" : GoString), _m : ("0x00ffffff00000001" : GoString), _k0 : (72057589742960639i64 : GoUInt64), _out32 : ("0xbfffff40000001" : GoString), _out64 : ("0xbfffff40000001" : GoString) } : T__struct_51), ({ _x : ("0x0000000080000000" : GoString), _y : ("0x0000000080000000" : GoString), _m : ("0x0000ffff00000001" : GoString), _k0 : (281470681743359i64 : GoUInt64), _out32 : ("0xbfff40000001" : GoString), _out64 : ("0xbfff40000001" : GoString) } : T__struct_51), ({ _x : ("0x3321ffffffffffffffffffffffffffff00000000000022222623333333332bbbb888c0" : GoString), _y : ("0x3321ffffffffffffffffffffffffffff00000000000022222623333333332bbbb888c0" : GoString), _m : ("0x33377fffffffffffffffffffffffffffffffffffffffffffff0000000000022222eee1" : GoString), _k0 : (-2392379993335190817i64 : GoUInt64), _out32 : ("0x04eb0e11d72329dc0915f86784820fc403275bf2f6620a20e0dd344c5cd0875e50deb5" : GoString), _out64 : ("0x0d7144739a7d8e11d72329dc0915f86784820fc403275bf2f61ed96f35dd34dbb3d6a0" : GoString) } : T__struct_51), ({ _x : ("0x10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffff00000000000022222223333333333444444444" : GoString), _y : ("0x10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffff999999999999999aaabbbbbbbbcccccccccccc" : GoString), _m : ("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff33377fffffffffffffffffffffffffffffffffffffffffffff0000000000022222eee1" : GoString), _k0 : (-2392379993335190817i64 : GoUInt64), _out32 : ("0x5c0d52f451aec609b15da8e5e5626c4eaa88723bdeac9d25ca9b961269400410ca208a16af9c2fb07d7a11c7772cba02c22f9711078d51a3797eb18e691295293284d988e349fa6deba46b25a4ecd9f715" : GoString), _out64 : ("0x92fcad4b5c0d52f451aec609b15da8e5e5626c4eaa88723bdeac9d25ca9b961269400410ca208a16af9c2fb07d799c32fe2f3cc5422f9711078d51a3797eb18e691295293284d8f5e69caf6decddfe1df6" : GoString) } : T__struct_51)) : Slice<T__struct_51>);
/**
    
    
    
**/
private var _expNNTests = (new Slice<T__struct_37>(
0,
0,
({ _x : ("0" : GoString), _y : ("0" : GoString), _m : ("0" : GoString), _out : ("1" : GoString) } : T__struct_37),
({ _x : ("0" : GoString), _y : ("0" : GoString), _m : ("1" : GoString), _out : ("0" : GoString) } : T__struct_37),
({ _x : ("1" : GoString), _y : ("1" : GoString), _m : ("1" : GoString), _out : ("0" : GoString) } : T__struct_37),
({ _x : ("2" : GoString), _y : ("1" : GoString), _m : ("1" : GoString), _out : ("0" : GoString) } : T__struct_37),
({ _x : ("2" : GoString), _y : ("2" : GoString), _m : ("1" : GoString), _out : ("0" : GoString) } : T__struct_37),
({ _x : ("10" : GoString), _y : ("100000000000" : GoString), _m : ("1" : GoString), _out : ("0" : GoString) } : T__struct_37),
({ _x : ("0x8000000000000000" : GoString), _y : ("2" : GoString), _m : Go.str(), _out : ("0x40000000000000000000000000000000" : GoString) } : T__struct_37),
({ _x : ("0x8000000000000000" : GoString), _y : ("2" : GoString), _m : ("6719" : GoString), _out : ("4944" : GoString) } : T__struct_37),
({ _x : ("0x8000000000000000" : GoString), _y : ("3" : GoString), _m : ("6719" : GoString), _out : ("5447" : GoString) } : T__struct_37),
({ _x : ("0x8000000000000000" : GoString), _y : ("1000" : GoString), _m : ("6719" : GoString), _out : ("1603" : GoString) } : T__struct_37),
({ _x : ("0x8000000000000000" : GoString), _y : ("1000000" : GoString), _m : ("6719" : GoString), _out : ("3199" : GoString) } : T__struct_37),
({ _x : ("2938462938472983472983659726349017249287491026512746239764525612965293865296239471239874193284792387498274256129746192347" : GoString), _y : ("298472983472983471903246121093472394872319615612417471234712061" : GoString), _m : ("29834729834729834729347290846729561262544958723956495615629569234729836259263598127342374289365912465901365498236492183464" : GoString), _out : ("23537740700184054162508175125554701713153216681790245129157191391322321508055833908509185839069455749219131480588829346291" : GoString) } : T__struct_37),
({ _x : ("11521922904531591643048817447554701904414021819823889996244743037378330903763518501116638828335352811871131385129455853417360623007349090150042001944696604737499160174391019030572483602867266711107136838523916077674888297896995042968746762200926853379" : GoString), _y : ("426343618817810911523" : GoString), _m : ("444747819283133684179" : GoString), _out : ("42" : GoString) } : T__struct_37),
({ _x : ("375" : GoString), _y : ("249" : GoString), _m : ("388" : GoString), _out : ("175" : GoString) } : T__struct_37),
({ _x : ("375" : GoString), _y : ("18446744073709551801" : GoString), _m : ("388" : GoString), _out : ("175" : GoString) } : T__struct_37),
({ _x : ("0" : GoString), _y : ("0x40000000000000" : GoString), _m : ("0x200" : GoString), _out : ("0" : GoString) } : T__struct_37),
({ _x : ("0xeffffff900002f00" : GoString), _y : ("0x40000000000000" : GoString), _m : ("0x200" : GoString), _out : ("0" : GoString) } : T__struct_37),
({ _x : ("5" : GoString), _y : ("1435700818" : GoString), _m : ("72" : GoString), _out : ("49" : GoString) } : T__struct_37),
({ _x : ("0xffff" : GoString), _y : ("0x300030003000300030003000300030003000302a3000300030003000300030003000300030003000300030003000300030003030623066307f3030783062303430383064303630343036" : GoString), _m : ("0x300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" : GoString), _out : ("0xa3f94c08b0b90e87af637cacc9383f7ea032352b8961fc036a52b659b6c9b33491b335ffd74c927f64ddd62cfca0001" : GoString) } : T__struct_37)) : Slice<T__struct_37>);
/**
    
    
    
**/
private var _fiboNums = (new Slice<GoString>(
0,
0,
("0" : GoString),
("55" : GoString),
("6765" : GoString),
("832040" : GoString),
("102334155" : GoString),
("12586269025" : GoString),
("1548008755920" : GoString),
("190392490709135" : GoString),
("23416728348467685" : GoString),
("2880067194370816120" : GoString),
("354224848179261915075" : GoString)) : Slice<GoString>);
/**
    
    
    
**/
private var _bitTests = (new Slice<T__struct_52>(
0,
0,
({ _x : ("0" : GoString), _i : (0u32 : GoUInt), _want : (0u32 : GoUInt) } : T__struct_52),
({ _x : ("0" : GoString), _i : (1u32 : GoUInt), _want : (0u32 : GoUInt) } : T__struct_52),
({ _x : ("0" : GoString), _i : (1000u32 : GoUInt), _want : (0u32 : GoUInt) } : T__struct_52),
({ _x : ("0x1" : GoString), _i : (0u32 : GoUInt), _want : (1u32 : GoUInt) } : T__struct_52),
({ _x : ("0x10" : GoString), _i : (0u32 : GoUInt), _want : (0u32 : GoUInt) } : T__struct_52),
({ _x : ("0x10" : GoString), _i : (3u32 : GoUInt), _want : (0u32 : GoUInt) } : T__struct_52),
({ _x : ("0x10" : GoString), _i : (4u32 : GoUInt), _want : (1u32 : GoUInt) } : T__struct_52),
({ _x : ("0x10" : GoString), _i : (5u32 : GoUInt), _want : (0u32 : GoUInt) } : T__struct_52),
({ _x : ("0x8000000000000000" : GoString), _i : (62u32 : GoUInt), _want : (0u32 : GoUInt) } : T__struct_52),
({ _x : ("0x8000000000000000" : GoString), _i : (63u32 : GoUInt), _want : (1u32 : GoUInt) } : T__struct_52),
({ _x : ("0x8000000000000000" : GoString), _i : (64u32 : GoUInt), _want : (0u32 : GoUInt) } : T__struct_52),
({ _x : ("0x3" : GoString) + stdgo.strings.Strings.repeat(("0" : GoString), (32 : GoInt)), _i : (127u32 : GoUInt), _want : (0u32 : GoUInt) } : T__struct_52),
({ _x : ("0x3" : GoString) + stdgo.strings.Strings.repeat(("0" : GoString), (32 : GoInt)), _i : (128u32 : GoUInt), _want : (1u32 : GoUInt) } : T__struct_52),
({ _x : ("0x3" : GoString) + stdgo.strings.Strings.repeat(("0" : GoString), (32 : GoInt)), _i : (129u32 : GoUInt), _want : (1u32 : GoUInt) } : T__struct_52),
({ _x : ("0x3" : GoString) + stdgo.strings.Strings.repeat(("0" : GoString), (32 : GoInt)), _i : (130u32 : GoUInt), _want : (0u32 : GoUInt) } : T__struct_52)) : Slice<T__struct_52>);
/**
    
    
    
**/
private var _stickyTests = (new Slice<T__struct_52>(
0,
0,
({ _x : ("0" : GoString), _i : (0u32 : GoUInt), _want : (0u32 : GoUInt) } : T__struct_52),
({ _x : ("0" : GoString), _i : (1u32 : GoUInt), _want : (0u32 : GoUInt) } : T__struct_52),
({ _x : ("0" : GoString), _i : (1000u32 : GoUInt), _want : (0u32 : GoUInt) } : T__struct_52),
({ _x : ("0x1" : GoString), _i : (0u32 : GoUInt), _want : (0u32 : GoUInt) } : T__struct_52),
({ _x : ("0x1" : GoString), _i : (1u32 : GoUInt), _want : (1u32 : GoUInt) } : T__struct_52),
({ _x : ("0x1350" : GoString), _i : (0u32 : GoUInt), _want : (0u32 : GoUInt) } : T__struct_52),
({ _x : ("0x1350" : GoString), _i : (4u32 : GoUInt), _want : (0u32 : GoUInt) } : T__struct_52),
({ _x : ("0x1350" : GoString), _i : (5u32 : GoUInt), _want : (1u32 : GoUInt) } : T__struct_52),
({ _x : ("0x8000000000000000" : GoString), _i : (63u32 : GoUInt), _want : (0u32 : GoUInt) } : T__struct_52),
({ _x : ("0x8000000000000000" : GoString), _i : (64u32 : GoUInt), _want : (1u32 : GoUInt) } : T__struct_52),
({ _x : ("0x1" : GoString) + stdgo.strings.Strings.repeat(("0" : GoString), (100 : GoInt)), _i : (400u32 : GoUInt), _want : (0u32 : GoUInt) } : T__struct_52),
({ _x : ("0x1" : GoString) + stdgo.strings.Strings.repeat(("0" : GoString), (100 : GoInt)), _i : (401u32 : GoUInt), _want : (1u32 : GoUInt) } : T__struct_52)) : Slice<T__struct_52>);
/**
    
    
    
**/
private var _sqrBenchSizes = (new Slice<GoInt>(
0,
0,
(1 : GoInt),
(2 : GoInt),
(3 : GoInt),
(5 : GoInt),
(8 : GoInt),
(10 : GoInt),
(20 : GoInt),
(30 : GoInt),
(50 : GoInt),
(80 : GoInt),
(100 : GoInt),
(200 : GoInt),
(300 : GoInt),
(500 : GoInt),
(800 : GoInt),
(1000 : GoInt),
(10000 : GoInt),
(100000 : GoInt)) : Slice<GoInt>);
/**
    
    
    
**/
private var _subMod2NTests = (new Slice<T__struct_53>(0, 0, ({ _x : ("1" : GoString), _y : ("2" : GoString), _n : (0u32 : GoUInt), _z : ("0" : GoString) } : T__struct_53), ({ _x : ("1" : GoString), _y : ("0" : GoString), _n : (1u32 : GoUInt), _z : ("1" : GoString) } : T__struct_53), ({ _x : ("0" : GoString), _y : ("1" : GoString), _n : (1u32 : GoUInt), _z : ("1" : GoString) } : T__struct_53), ({ _x : ("3" : GoString), _y : ("5" : GoString), _n : (3u32 : GoUInt), _z : ("6" : GoString) } : T__struct_53), ({ _x : ("5" : GoString), _y : ("3" : GoString), _n : (3u32 : GoUInt), _z : ("2" : GoString) } : T__struct_53), ({ _x : ("36893488147419103232" : GoString), _y : ("73786976294838206463" : GoString), _n : (67u32 : GoUInt), _z : ("110680464442257309697" : GoString) } : T__struct_53), ({ _x : ("73786976294838206463" : GoString), _y : ("36893488147419103232" : GoString), _n : (67u32 : GoUInt), _z : ("36893488147419103231" : GoString) } : T__struct_53)) : Slice<T__struct_53>);
/**
    
    
    
**/
private var _strTests = (new Slice<T__struct_55>(
0,
0,
({ _x : null, _b : (2 : GoInt), _s : ("0" : GoString) } : T__struct_55),
({ _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (2 : GoInt), _s : ("1" : GoString) } : T__struct_55),
({ _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (197u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (2 : GoInt), _s : ("11000101" : GoString) } : T__struct_55),
({ _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1721u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (8 : GoInt), _s : ("3271" : GoString) } : T__struct_55),
({ _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (10u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (10 : GoInt), _s : ("10" : GoString) } : T__struct_55),
({ _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1234567890u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (10 : GoInt), _s : ("1234567890" : GoString) } : T__struct_55),
({ _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (-559038737u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (16 : GoInt), _s : ("deadbeef" : GoString) } : T__struct_55),
({ _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (2268135u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (17 : GoInt), _s : ("1a2b3c" : GoString) } : T__struct_55),
({ _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (815162342u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (32 : GoInt), _s : ("o9cov6" : GoString) } : T__struct_55),
({ _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (815162342u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (62 : GoInt), _s : ("TakXI" : GoString) } : T__struct_55)) : Slice<T__struct_55>);
/**
    
    
    
**/
private var _natScanTests = (new Slice<T__struct_56>(
0,
0,
({ _s : Go.str(), _base : (0 : GoInt), _frac : false, _x : null, _b : (10 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("_" : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (10 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("?" : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (10 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (63 : GoInt32) } : T__struct_56),
({ _s : ("?" : GoString), _base : (10 : GoInt), _frac : false, _x : null, _b : (10 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (63 : GoInt32) } : T__struct_56),
({ _s : Go.str(), _base : (10 : GoInt), _frac : false, _x : null, _b : (10 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (0 : GoInt32) } : T__struct_56),
({ _s : Go.str(), _base : (36 : GoInt), _frac : false, _x : null, _b : (36 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (0 : GoInt32) } : T__struct_56),
({ _s : Go.str(), _base : (62 : GoInt), _frac : false, _x : null, _b : (62 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0b" : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (2 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0o" : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (8 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0x" : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (16 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0x_" : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (16 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0b2" : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (2 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (50 : GoInt32) } : T__struct_56),
({ _s : ("0B2" : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (2 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (50 : GoInt32) } : T__struct_56),
({ _s : ("0o8" : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (8 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (56 : GoInt32) } : T__struct_56),
({ _s : ("0O8" : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (8 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (56 : GoInt32) } : T__struct_56),
({ _s : ("0xg" : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (16 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (103 : GoInt32) } : T__struct_56),
({ _s : ("0Xg" : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (16 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (103 : GoInt32) } : T__struct_56),
({ _s : ("345" : GoString), _base : (2 : GoInt), _frac : false, _x : null, _b : (2 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (51 : GoInt32) } : T__struct_56),
({ _s : ("._" : GoString), _base : (0 : GoInt), _frac : true, _x : null, _b : (10 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (0 : GoInt32) } : T__struct_56),
({ _s : (".0" : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (10 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (46 : GoInt32) } : T__struct_56),
({ _s : (".0" : GoString), _base : (10 : GoInt), _frac : false, _x : null, _b : (10 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (46 : GoInt32) } : T__struct_56),
({ _s : ("." : GoString), _base : (0 : GoInt), _frac : true, _x : null, _b : (10 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0x." : GoString), _base : (0 : GoInt), _frac : true, _x : null, _b : (16 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0x.g" : GoString), _base : (0 : GoInt), _frac : true, _x : null, _b : (16 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (103 : GoInt32) } : T__struct_56),
({ _s : ("0x.0" : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (16 : GoInt), _count : (0 : GoInt), _err : _errNoDigits, _next : (46 : GoInt32) } : T__struct_56),
({ _s : ("_0" : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (10 : GoInt), _count : (1 : GoInt), _err : _errInvalSep, _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0_" : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (10 : GoInt), _count : (1 : GoInt), _err : _errInvalSep, _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0__0" : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (8 : GoInt), _count : (1 : GoInt), _err : _errInvalSep, _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0x___0" : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (16 : GoInt), _count : (1 : GoInt), _err : _errInvalSep, _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0_x" : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (10 : GoInt), _count : (1 : GoInt), _err : _errInvalSep, _next : (120 : GoInt32) } : T__struct_56),
({ _s : ("0_8" : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (10 : GoInt), _count : (1 : GoInt), _err : _errInvalSep, _next : (56 : GoInt32) } : T__struct_56),
({ _s : ("123_." : GoString), _base : (0 : GoInt), _frac : true, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (123u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (10 : GoInt), _count : (0 : GoInt), _err : _errInvalSep, _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("._123" : GoString), _base : (0 : GoInt), _frac : true, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (123u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (10 : GoInt), _count : (-3 : GoInt), _err : _errInvalSep, _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0b__1000" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (8u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (2 : GoInt), _count : (4 : GoInt), _err : _errInvalSep, _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0o60___0" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (384u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (8 : GoInt), _count : (3 : GoInt), _err : _errInvalSep, _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0466_" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (310u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (8 : GoInt), _count : (3 : GoInt), _err : _errInvalSep, _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("01234567_8" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (342391u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (8 : GoInt), _count : (7 : GoInt), _err : _errInvalSep, _next : (56 : GoInt32) } : T__struct_56),
({ _s : ("1_." : GoString), _base : (0 : GoInt), _frac : true, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (10 : GoInt), _count : (0 : GoInt), _err : _errInvalSep, _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0._1" : GoString), _base : (0 : GoInt), _frac : true, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (10 : GoInt), _count : (-1 : GoInt), _err : _errInvalSep, _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("2.7_" : GoString), _base : (0 : GoInt), _frac : true, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (27u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (10 : GoInt), _count : (-1 : GoInt), _err : _errInvalSep, _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0x1.0_" : GoString), _base : (0 : GoInt), _frac : true, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (16u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (16 : GoInt), _count : (-1 : GoInt), _err : _errInvalSep, _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0_" : GoString), _base : (10 : GoInt), _frac : false, _x : null, _b : (10 : GoInt), _count : (1 : GoInt), _err : (null : Error), _next : (95 : GoInt32) } : T__struct_56),
({ _s : ("1__0" : GoString), _base : (10 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (10 : GoInt), _count : (1 : GoInt), _err : (null : Error), _next : (95 : GoInt32) } : T__struct_56),
({ _s : ("0__8" : GoString), _base : (10 : GoInt), _frac : false, _x : null, _b : (10 : GoInt), _count : (1 : GoInt), _err : (null : Error), _next : (95 : GoInt32) } : T__struct_56),
({ _s : ("xy_z_" : GoString), _base : (36 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1222u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (36 : GoInt), _count : (2 : GoInt), _err : (null : Error), _next : (95 : GoInt32) } : T__struct_56),
({ _s : ("0" : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (10 : GoInt), _count : (1 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0" : GoString), _base : (36 : GoInt), _frac : false, _x : null, _b : (36 : GoInt), _count : (1 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0" : GoString), _base : (62 : GoInt), _frac : false, _x : null, _b : (62 : GoInt), _count : (1 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("1" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (10 : GoInt), _count : (1 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("1" : GoString), _base : (10 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (10 : GoInt), _count : (1 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0 " : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (10 : GoInt), _count : (1 : GoInt), _err : (null : Error), _next : (32 : GoInt32) } : T__struct_56),
({ _s : ("00 " : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (8 : GoInt), _count : (1 : GoInt), _err : (null : Error), _next : (32 : GoInt32) } : T__struct_56),
({ _s : ("0b1" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (2 : GoInt), _count : (1 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0B11000101" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (197u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (2 : GoInt), _count : (8 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0B110001012" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (197u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (2 : GoInt), _count : (8 : GoInt), _err : (null : Error), _next : (50 : GoInt32) } : T__struct_56),
({ _s : ("07" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (7u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (8 : GoInt), _count : (1 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("08" : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (10 : GoInt), _count : (1 : GoInt), _err : (null : Error), _next : (56 : GoInt32) } : T__struct_56),
({ _s : ("08" : GoString), _base : (10 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (8u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (10 : GoInt), _count : (2 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("018" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (8 : GoInt), _count : (1 : GoInt), _err : (null : Error), _next : (56 : GoInt32) } : T__struct_56),
({ _s : ("0o7" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (7u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (8 : GoInt), _count : (1 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0o18" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (8 : GoInt), _count : (1 : GoInt), _err : (null : Error), _next : (56 : GoInt32) } : T__struct_56),
({ _s : ("0O17" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (15u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (8 : GoInt), _count : (2 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("03271" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1721u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (8 : GoInt), _count : (4 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("10ab" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (10u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (10 : GoInt), _count : (2 : GoInt), _err : (null : Error), _next : (97 : GoInt32) } : T__struct_56),
({ _s : ("1234567890" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1234567890u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (10 : GoInt), _count : (10 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("A" : GoString), _base : (36 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (10u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (36 : GoInt), _count : (1 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("A" : GoString), _base : (37 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (36u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (37 : GoInt), _count : (1 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("xyz" : GoString), _base : (36 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (44027u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (36 : GoInt), _count : (3 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("XYZ?" : GoString), _base : (36 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (44027u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (36 : GoInt), _count : (3 : GoInt), _err : (null : Error), _next : (63 : GoInt32) } : T__struct_56),
({ _s : ("XYZ?" : GoString), _base : (62 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (230577u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (62 : GoInt), _count : (3 : GoInt), _err : (null : Error), _next : (63 : GoInt32) } : T__struct_56),
({ _s : ("0x" : GoString), _base : (16 : GoInt), _frac : false, _x : null, _b : (16 : GoInt), _count : (1 : GoInt), _err : (null : Error), _next : (120 : GoInt32) } : T__struct_56),
({ _s : ("0xdeadbeef" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (-559038737u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (16 : GoInt), _count : (8 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0XDEADBEEF" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (-559038737u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (16 : GoInt), _count : (8 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0." : GoString), _base : (0 : GoInt), _frac : false, _x : null, _b : (10 : GoInt), _count : (1 : GoInt), _err : (null : Error), _next : (46 : GoInt32) } : T__struct_56),
({ _s : ("0." : GoString), _base : (10 : GoInt), _frac : true, _x : null, _b : (10 : GoInt), _count : (0 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0.1.2" : GoString), _base : (10 : GoInt), _frac : true, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (10 : GoInt), _count : (-1 : GoInt), _err : (null : Error), _next : (46 : GoInt32) } : T__struct_56),
({ _s : (".000" : GoString), _base : (10 : GoInt), _frac : true, _x : null, _b : (10 : GoInt), _count : (-3 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("12.3" : GoString), _base : (10 : GoInt), _frac : true, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (123u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (10 : GoInt), _count : (-1 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("012.345" : GoString), _base : (10 : GoInt), _frac : true, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (12345u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (10 : GoInt), _count : (-3 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0.1" : GoString), _base : (0 : GoInt), _frac : true, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (10 : GoInt), _count : (-1 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0.1" : GoString), _base : (2 : GoInt), _frac : true, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (2 : GoInt), _count : (-1 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0.12" : GoString), _base : (2 : GoInt), _frac : true, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (2 : GoInt), _count : (-1 : GoInt), _err : (null : Error), _next : (50 : GoInt32) } : T__struct_56),
({ _s : ("0b0.1" : GoString), _base : (0 : GoInt), _frac : true, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (2 : GoInt), _count : (-1 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0B0.12" : GoString), _base : (0 : GoInt), _frac : true, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (2 : GoInt), _count : (-1 : GoInt), _err : (null : Error), _next : (50 : GoInt32) } : T__struct_56),
({ _s : ("0o0.7" : GoString), _base : (0 : GoInt), _frac : true, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (7u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (8 : GoInt), _count : (-1 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0O0.78" : GoString), _base : (0 : GoInt), _frac : true, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (7u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (8 : GoInt), _count : (-1 : GoInt), _err : (null : Error), _next : (56 : GoInt32) } : T__struct_56),
({ _s : ("0xdead.beef" : GoString), _base : (0 : GoInt), _frac : true, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (-559038737u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (16 : GoInt), _count : (-4 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("1_000" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1000u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (10 : GoInt), _count : (4 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0_466" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (310u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (8 : GoInt), _count : (3 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0o_600" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (384u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (8 : GoInt), _count : (3 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0x_f0_0d" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (61453u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (16 : GoInt), _count : (4 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0b1000_0001" : GoString), _base : (0 : GoInt), _frac : false, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (129u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (2 : GoInt), _count : (8 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("1_000.000_1" : GoString), _base : (0 : GoInt), _frac : true, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (10000001u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (10 : GoInt), _count : (-4 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0x_f00d.1e" : GoString), _base : (0 : GoInt), _frac : true, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (15731998u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (16 : GoInt), _count : (-2 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0x_f00d.1E2" : GoString), _base : (0 : GoInt), _frac : true, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (251711970u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (16 : GoInt), _count : (-3 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_56),
({ _s : ("0x_f00d.1eg" : GoString), _base : (0 : GoInt), _frac : true, _x : (new Slice<stdgo.math.big.Big.Word>(0, 0, (15731998u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), _b : (16 : GoInt), _count : (-2 : GoInt), _err : (null : Error), _next : (103 : GoInt32) } : T__struct_56)) : Slice<T__struct_56>);
/**
    
    
    
**/
private var _pi = ("3141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481117450284102701938521105559644622948954930381964428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273724587006606315588174881520920962829254091715364367892590360011330530548820466521384146951941511609433057270365759591953092186117381932611793105118548074462379962749567351885752724891227938183011949129833673362440656643086021394946395224737190702179860943702770539217176293176752384674818467669405132000568127145263560827785771342757789609173637178721468440901224953430146549585371050792279689258923542019956112129021960864034418159813629774771309960518707211349999998372978049951059731732816096318595024459455346908302642522308253344685035261931188171010003137838752886587533208381420617177669147303598253490428755468731159562863882353787593751957781857780532171226806613001927876611195909216420198938095257201065485863278865936153381827968230301952035301852968995773622599413891249721775283479131515574857242454150695950829533116861727855889075098381754637464939319255060400927701671139009848824012858361603563707660104710181942955596198946767837449448255379774726847104047534646208046684259069491293313677028989152104752162056966024058038150193511253382430035587640247496473263914199272604269922796782354781636009341721641219924586315030286182974555706749838505494588586926995690927210797509302955321165344987202755960236480665499119881834797753566369807426542527862551818417574672890977772793800081647060016145249192173217214772350141441973568548161361157352552133475741849468438523323907394143334547762416862518983569485562099219222184272550254256887671790494601653466804988627232791786085784383827967976681454100953883786360950680064225125205117392984896084128488626945604241965285022210661186306744278622039194945047123713786960956364371917287467764657573962413890865832645995813390478027590099465764078951269468398352595709825822620522489407726719478268482601476990902640136394437455305068203496252451749399651431429809190659250937221696461515709858387410597885959772975498930161753928468138268683868942774155991855925245953959431049972524680845987273644695848653836736222626099124608051243884390451244136549762780797715691435997700129616089441694868555848406353422072225828488648158456028506016842739452267467678895252138522549954666727823986456596116354886230577456498035593634568174324112515076069479451096596094025228879710893145669136867228748940560101503308617928680920874760917824938589009714909675985261365549781893129784821682998948722658804857564014270477555132379641451523746234364542858444795265867821051141354735739523113427166102135969536231442952484937187110145765403590279934403742007310578539062198387447808478489683321445713868751943506430218453191048481005370614680674919278191197939952061419663428754440643745123718192179998391015919561814675142691239748940907186494231961567945208095146550225231603881930142093762137855956638937787083039069792077346722182562599661501421503068038447734549202605414665925201497442850732518666002132434088190710486331734649651453905796268561005508106658796998163574736384052571459102897064140110971206280439039759515677157700420337869936007230558763176359421873125147120532928191826186125867321579198414848829164470609575270695722091756711672291098169091528017350671274858322287183520935396572512108357915136988209144421006751033467110314126711136990865851639831501970165151168517143765761835155650884909989859982387345528331635507647918535893226185489632132933089857064204675259070915481416549859461637180270981994309924488957571282890592323326097299712084433573265489382391193259746366730583604142813883032038249037589852437441702913276561809377344403070746921120191302033038019762110110044929321516084244485963766983895228684783123552658213144957685726243344189303968642624341077322697802807318915441101044682325271620105265227211166039666557309254711055785376346682065310989652691862056476931257058635662018558100729360659876486117910453348850346113657686753249441668039626579787718556084552965412665408530614344431858676975145661406800700237877659134401712749470420562230538994561314071127000407854733269939081454664645880797270826683063432858785698305235808933065757406795457163775254202114955761581400250126228594130216471550979259230990796547376125517656751357517829666454779174501129961489030463994713296210734043751895735961458901938971311179042978285647503203198691514028708085990480109412147221317947647772622414254854540332157185306142288137585043063321751829798662237172159160771669254748738986654949450114654062843366393790039769265672146385306736096571209180763832716641627488880078692560290228472104031721186082041900042296617119637792133757511495950156604963186294726547364252308177036751590673502350728354056704038674351362222477158915049530984448933309634087807693259939780541934144737744184263129860809988868741326047215695162396586457302163159819319516735381297416772947867242292465436680098067692823828068996400482435403701416314965897940924323789690706977942236250822168895738379862300159377647165122893578601588161755782973523344604281512627203734314653197777416031990665541876397929334419521541341899485444734567383162499341913181480927777103863877343177207545654532207770921201905166096280490926360197598828161332316663652861932668633606273567630354477628035045077723554710585954870279081435624014517180624643626794561275318134078330336254232783944975382437205835311477119926063813346776879695970309833913077109870408591337" : GoString);
/**
    
    
    
**/
private var _primes = (new Slice<GoString>(
0,
0,
("2" : GoString),
("3" : GoString),
("5" : GoString),
("7" : GoString),
("11" : GoString),
("13756265695458089029" : GoString),
("13496181268022124907" : GoString),
("10953742525620032441" : GoString),
("17908251027575790097" : GoString),
("18699199384836356663" : GoString),
("98920366548084643601728869055592650835572950932266967461790948584315647051443" : GoString),
("94560208308847015747498523884063394671606671904944666360068158221458669711639" : GoString),
("449417999055441493994709297093108513015373787049558499205492347871729927573118262811508386655998299074566974373711472560655026288668094291699357843464363003144674940345912431129144354948751003607115263071543163" : GoString),
("230975859993204150666423538988557839555560243929065415434980904258310530753006723857139742334640122533598517597674807096648905501653461687601339782814316124971547968912893214002992086353183070342498989426570593" : GoString),
("5521712099665906221540423207019333379125265462121169655563495403888449493493629943498064604536961775110765377745550377067893607246020694972959780839151452457728855382113555867743022746090187341871655890805971735385789993" : GoString),
("203956878356401977405765866929034577280193993314348263094772646453283062722701277632936616063144088173312372882677123879538709400158306567338328279154499698366071906766440037074217117805690872792848149112022286332144876183376326512083574821647933992961249917319836219304274280243803104015000563790123" : GoString),
("3618502788666131106986593281521497120414687020801267626233049500247285301239" : GoString),
("57896044618658097711785492504343953926634992332820282019728792003956564819949" : GoString),
("9850501549098619803069760025035903451269934817616361666987073351061430442874302652853566563721228910201656997576599" : GoString),
("42307582002575910332922579714097346549017899709713998034217522897561970639123926132812109468141778230245837569601494931472367" : GoString),
("6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151" : GoString)) : Slice<GoString>);
/**
    
    
    
**/
private var _composites = (new Slice<GoString>(
0,
0,
("0" : GoString),
("1" : GoString),
("21284175091214687912771199898307297748211672914763848041968395774954376176754" : GoString),
("6084766654921918907427900243509372380954290099172559290432744450051395395951" : GoString),
("84594350493221918389213352992032324280367711247940675652888030554255915464401" : GoString),
("82793403787388584738507275144194252681" : GoString),
("1195068768795265792518361315725116351898245581" : GoString),
("\n     80383745745363949125707961434194210813883768828755814583748891752229\n      74273765333652186502336163960045457915042023603208766569966760987284\n       0439654082329287387918508691668573282677617710293896977394701670823\n        0428687109997439976544144845341155872450633409279022275296229414984\n         2306881685404326457534018329786111298960644845216191652872597534901" : GoString),
("989" : GoString),
("3239" : GoString),
("5777" : GoString),
("10877" : GoString),
("27971" : GoString),
("29681" : GoString),
("30739" : GoString),
("31631" : GoString),
("39059" : GoString),
("72389" : GoString),
("73919" : GoString),
("75077" : GoString),
("100127" : GoString),
("113573" : GoString),
("125249" : GoString),
("137549" : GoString),
("137801" : GoString),
("153931" : GoString),
("155819" : GoString),
("161027" : GoString),
("162133" : GoString),
("189419" : GoString),
("218321" : GoString),
("231703" : GoString),
("249331" : GoString),
("370229" : GoString),
("429479" : GoString),
("430127" : GoString),
("459191" : GoString),
("473891" : GoString),
("480689" : GoString),
("600059" : GoString),
("621781" : GoString),
("632249" : GoString),
("635627" : GoString),
("3673744903" : GoString),
("3281593591" : GoString),
("2385076987" : GoString),
("2738053141" : GoString),
("2009621503" : GoString),
("1502682721" : GoString),
("255866131" : GoString),
("117987841" : GoString),
("587861" : GoString),
("6368689" : GoString),
("8725753" : GoString),
("80579735209" : GoString),
("105919633" : GoString)) : Slice<GoString>);
/**
    
    
    
**/
private var _ratCmpTests = (new Slice<T__struct_57>(
0,
0,
({ _rat1 : ("0" : GoString), _rat2 : ("0/1" : GoString), _out : (0 : GoInt) } : T__struct_57),
({ _rat1 : ("1/1" : GoString), _rat2 : ("1" : GoString), _out : (0 : GoInt) } : T__struct_57),
({ _rat1 : ("-1" : GoString), _rat2 : ("-2/2" : GoString), _out : (0 : GoInt) } : T__struct_57),
({ _rat1 : ("1" : GoString), _rat2 : ("0" : GoString), _out : (1 : GoInt) } : T__struct_57),
({ _rat1 : ("0/1" : GoString), _rat2 : ("1/1" : GoString), _out : (-1 : GoInt) } : T__struct_57),
({ _rat1 : ("-5/1434770811533343057144" : GoString), _rat2 : ("-5/1434770811533343057145" : GoString), _out : (-1 : GoInt) } : T__struct_57),
({ _rat1 : ("49832350382626108453/8964749413" : GoString), _rat2 : ("49832350382626108454/8964749413" : GoString), _out : (-1 : GoInt) } : T__struct_57),
({ _rat1 : ("-37414950961700930/7204075375675961" : GoString), _rat2 : ("37414950961700930/7204075375675961" : GoString), _out : (-1 : GoInt) } : T__struct_57),
({ _rat1 : ("37414950961700930/7204075375675961" : GoString), _rat2 : ("74829901923401860/14408150751351922" : GoString), _out : (0 : GoInt) } : T__struct_57)) : Slice<T__struct_57>);
/**
    
    
    
**/
private var _ratBinTests = (new Slice<T__struct_58>(
0,
0,
({ _x : ("0" : GoString), _y : ("0" : GoString), _sum : ("0" : GoString), _prod : ("0" : GoString) } : T__struct_58),
({ _x : ("0" : GoString), _y : ("1" : GoString), _sum : ("1" : GoString), _prod : ("0" : GoString) } : T__struct_58),
({ _x : ("-1" : GoString), _y : ("0" : GoString), _sum : ("-1" : GoString), _prod : ("0" : GoString) } : T__struct_58),
({ _x : ("-1" : GoString), _y : ("1" : GoString), _sum : ("0" : GoString), _prod : ("-1" : GoString) } : T__struct_58),
({ _x : ("1" : GoString), _y : ("1" : GoString), _sum : ("2" : GoString), _prod : ("1" : GoString) } : T__struct_58),
({ _x : ("1/2" : GoString), _y : ("1/2" : GoString), _sum : ("1" : GoString), _prod : ("1/4" : GoString) } : T__struct_58),
({ _x : ("1/4" : GoString), _y : ("1/3" : GoString), _sum : ("7/12" : GoString), _prod : ("1/12" : GoString) } : T__struct_58),
({ _x : ("2/5" : GoString), _y : ("-14/3" : GoString), _sum : ("-64/15" : GoString), _prod : ("-28/15" : GoString) } : T__struct_58),
({ _x : ("4707/49292519774798173060" : GoString), _y : ("-3367/70976135186689855734" : GoString), _sum : ("84058377121001851123459/1749296273614329067191168098769082663020" : GoString), _prod : ("-1760941/388732505247628681598037355282018369560" : GoString) } : T__struct_58),
({ _x : ("-61204110018146728334/3" : GoString), _y : ("-31052192278051565633/2" : GoString), _sum : ("-215564796870448153567/6" : GoString), _prod : ("950260896245257153059642991192710872711/3" : GoString) } : T__struct_58),
({ _x : ("-854857841473707320655/4237645934602118692642972629634714039" : GoString), _y : ("-18/31750379913563777419" : GoString), _sum : ("-27/133467566250814981" : GoString), _prod : ("15387441146526731771790/134546868362786310073779084329032722548987800600710485341" : GoString) } : T__struct_58),
({ _x : ("618575745270541348005638912139/19198433543745179392300736" : GoString), _y : ("-19948846211000086/637313996471" : GoString), _sum : ("27674141753240653/30123979153216" : GoString), _prod : ("-6169936206128396568797607742807090270137721977/6117715203873571641674006593837351328" : GoString) } : T__struct_58),
({ _x : ("-3/26206484091896184128" : GoString), _y : ("5/2848423294177090248" : GoString), _sum : ("15310893822118706237/9330894968229805033368778458685147968" : GoString), _prod : ("-5/24882386581946146755650075889827061248" : GoString) } : T__struct_58),
({ _x : ("26946729/330400702820" : GoString), _y : ("41563965/225583428284" : GoString), _sum : ("1238218672302860271/4658307703098666660055" : GoString), _prod : ("224002580204097/14906584649915733312176" : GoString) } : T__struct_58),
({ _x : ("-8259900599013409474/7" : GoString), _y : ("-84829337473700364773/56707961321161574960" : GoString), _sum : ("-468402123685491748914621885145127724451/396955729248131024720" : GoString), _prod : ("350340947706464153265156004876107029701/198477864624065512360" : GoString) } : T__struct_58),
({ _x : ("575775209696864/1320203974639986246357" : GoString), _y : ("29/712593081308" : GoString), _sum : ("410331716733912717985762465/940768218243776489278275419794956" : GoString), _prod : ("808/45524274987585732633" : GoString) } : T__struct_58),
({ _x : ("1786597389946320496771/2066653520653241" : GoString), _y : ("6269770/1992362624741777" : GoString), _sum : ("3559549865190272133656109052308126637/4117523232840525481453983149257" : GoString), _prod : ("8967230/3296219033" : GoString) } : T__struct_58),
({ _x : ("-36459180403360509753/32150500941194292113930" : GoString), _y : ("9381566963714/9633539" : GoString), _sum : ("301622077145533298008420642898530153/309723104686531919656937098270" : GoString), _prod : ("-3784609207827/3426986245" : GoString) } : T__struct_58)) : Slice<T__struct_58>);
/**
    
    
    
**/
private var _setFrac64Tests = (new Slice<T__struct_59>(0, 0, ({ _a : (0i64 : GoInt64), _b : (1i64 : GoInt64), _out : ("0" : GoString) } : T__struct_59), ({ _a : (0i64 : GoInt64), _b : (-1i64 : GoInt64), _out : ("0" : GoString) } : T__struct_59), ({ _a : (1i64 : GoInt64), _b : (1i64 : GoInt64), _out : ("1" : GoString) } : T__struct_59), ({ _a : (-1i64 : GoInt64), _b : (1i64 : GoInt64), _out : ("-1" : GoString) } : T__struct_59), ({ _a : (1i64 : GoInt64), _b : (-1i64 : GoInt64), _out : ("-1" : GoString) } : T__struct_59), ({ _a : (-1i64 : GoInt64), _b : (-1i64 : GoInt64), _out : ("1" : GoString) } : T__struct_59), ({ _a : (-9223372036854775808i64 : GoInt64), _b : (-9223372036854775808i64 : GoInt64), _out : ("1" : GoString) } : T__struct_59)) : Slice<T__struct_59>);
/**
    
    
    
**/
private var _exponentTests = (new Slice<T__struct_61>(
0,
0,
({ _s : Go.str(), _base2ok : false, _sepOk : false, _x : (0i64 : GoInt64), _b : (10 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_61),
({ _s : ("1" : GoString), _base2ok : false, _sepOk : false, _x : (0i64 : GoInt64), _b : (10 : GoInt), _err : (null : Error), _next : (49 : GoInt32) } : T__struct_61),
({ _s : ("e0" : GoString), _base2ok : false, _sepOk : false, _x : (0i64 : GoInt64), _b : (10 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_61),
({ _s : ("E1" : GoString), _base2ok : false, _sepOk : false, _x : (1i64 : GoInt64), _b : (10 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_61),
({ _s : ("e+10" : GoString), _base2ok : false, _sepOk : false, _x : (10i64 : GoInt64), _b : (10 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_61),
({ _s : ("e-10" : GoString), _base2ok : false, _sepOk : false, _x : (-10i64 : GoInt64), _b : (10 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_61),
({ _s : ("e123456789a" : GoString), _base2ok : false, _sepOk : false, _x : (123456789i64 : GoInt64), _b : (10 : GoInt), _err : (null : Error), _next : (97 : GoInt32) } : T__struct_61),
({ _s : ("p" : GoString), _base2ok : false, _sepOk : false, _x : (0i64 : GoInt64), _b : (10 : GoInt), _err : (null : Error), _next : (112 : GoInt32) } : T__struct_61),
({ _s : ("P+100" : GoString), _base2ok : false, _sepOk : false, _x : (0i64 : GoInt64), _b : (10 : GoInt), _err : (null : Error), _next : (80 : GoInt32) } : T__struct_61),
({ _s : ("p0" : GoString), _base2ok : true, _sepOk : false, _x : (0i64 : GoInt64), _b : (2 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_61),
({ _s : ("P-123" : GoString), _base2ok : true, _sepOk : false, _x : (-123i64 : GoInt64), _b : (2 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_61),
({ _s : ("p+0a" : GoString), _base2ok : true, _sepOk : false, _x : (0i64 : GoInt64), _b : (2 : GoInt), _err : (null : Error), _next : (97 : GoInt32) } : T__struct_61),
({ _s : ("p+123__" : GoString), _base2ok : true, _sepOk : false, _x : (123i64 : GoInt64), _b : (2 : GoInt), _err : (null : Error), _next : (95 : GoInt32) } : T__struct_61),
({ _s : ("e+1_0" : GoString), _base2ok : false, _sepOk : true, _x : (10i64 : GoInt64), _b : (10 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_61),
({ _s : ("e-1_0" : GoString), _base2ok : false, _sepOk : true, _x : (-10i64 : GoInt64), _b : (10 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_61),
({ _s : ("e123_456_789a" : GoString), _base2ok : false, _sepOk : true, _x : (123456789i64 : GoInt64), _b : (10 : GoInt), _err : (null : Error), _next : (97 : GoInt32) } : T__struct_61),
({ _s : ("P+1_00" : GoString), _base2ok : false, _sepOk : true, _x : (0i64 : GoInt64), _b : (10 : GoInt), _err : (null : Error), _next : (80 : GoInt32) } : T__struct_61),
({ _s : ("p-1_2_3" : GoString), _base2ok : true, _sepOk : true, _x : (-123i64 : GoInt64), _b : (2 : GoInt), _err : (null : Error), _next : (0 : GoInt32) } : T__struct_61),
({ _s : ("e" : GoString), _base2ok : false, _sepOk : false, _x : (0i64 : GoInt64), _b : (10 : GoInt), _err : _errNoDigits, _next : (0 : GoInt32) } : T__struct_61),
({ _s : ("ef" : GoString), _base2ok : false, _sepOk : false, _x : (0i64 : GoInt64), _b : (10 : GoInt), _err : _errNoDigits, _next : (102 : GoInt32) } : T__struct_61),
({ _s : ("e+" : GoString), _base2ok : false, _sepOk : false, _x : (0i64 : GoInt64), _b : (10 : GoInt), _err : _errNoDigits, _next : (0 : GoInt32) } : T__struct_61),
({ _s : ("E-x" : GoString), _base2ok : false, _sepOk : false, _x : (0i64 : GoInt64), _b : (10 : GoInt), _err : _errNoDigits, _next : (120 : GoInt32) } : T__struct_61),
({ _s : ("p" : GoString), _base2ok : true, _sepOk : false, _x : (0i64 : GoInt64), _b : (2 : GoInt), _err : _errNoDigits, _next : (0 : GoInt32) } : T__struct_61),
({ _s : ("P-" : GoString), _base2ok : true, _sepOk : false, _x : (0i64 : GoInt64), _b : (2 : GoInt), _err : _errNoDigits, _next : (0 : GoInt32) } : T__struct_61),
({ _s : ("p+e" : GoString), _base2ok : true, _sepOk : false, _x : (0i64 : GoInt64), _b : (2 : GoInt), _err : _errNoDigits, _next : (101 : GoInt32) } : T__struct_61),
({ _s : ("e+_x" : GoString), _base2ok : false, _sepOk : true, _x : (0i64 : GoInt64), _b : (10 : GoInt), _err : _errNoDigits, _next : (120 : GoInt32) } : T__struct_61),
({ _s : ("e0_" : GoString), _base2ok : false, _sepOk : true, _x : (0i64 : GoInt64), _b : (10 : GoInt), _err : _errInvalSep, _next : (0 : GoInt32) } : T__struct_61),
({ _s : ("e_0" : GoString), _base2ok : false, _sepOk : true, _x : (0i64 : GoInt64), _b : (10 : GoInt), _err : _errInvalSep, _next : (0 : GoInt32) } : T__struct_61),
({ _s : ("e-1_2__3" : GoString), _base2ok : false, _sepOk : true, _x : (-123i64 : GoInt64), _b : (10 : GoInt), _err : _errInvalSep, _next : (0 : GoInt32) } : T__struct_61)) : Slice<T__struct_61>);
/**
    
    
    
**/
private var _setStringTests = (new Slice<stdgo.math.big.Big.StringTest>(
0,
0,
({ _in : ("1e" : GoString) } : stdgo.math.big.Big.StringTest),
({ _in : ("1.e" : GoString) } : stdgo.math.big.Big.StringTest),
({ _in : ("1e+14e-5" : GoString) } : stdgo.math.big.Big.StringTest),
({ _in : ("1e4.5" : GoString) } : stdgo.math.big.Big.StringTest),
({ _in : ("r" : GoString) } : stdgo.math.big.Big.StringTest),
({ _in : ("a/b" : GoString) } : stdgo.math.big.Big.StringTest),
({ _in : ("a.b" : GoString) } : stdgo.math.big.Big.StringTest),
({ _in : ("1/0" : GoString) } : stdgo.math.big.Big.StringTest),
({ _in : ("4/3/2" : GoString) } : stdgo.math.big.Big.StringTest),
({ _in : ("4/3/" : GoString) } : stdgo.math.big.Big.StringTest),
({ _in : ("4/3." : GoString) } : stdgo.math.big.Big.StringTest),
({ _in : ("4/" : GoString) } : stdgo.math.big.Big.StringTest),
({ _in : ("13e-9223372036854775808" : GoString) } : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0" : GoString), ("0" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("-0" : GoString), ("0" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("1" : GoString), ("1" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("-1" : GoString), ("-1" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("1." : GoString), ("1" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("1e0" : GoString), ("1" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("1.e1" : GoString), ("10" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("-0.1" : GoString), ("-1/10" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("-.1" : GoString), ("-1/10" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("2/4" : GoString), ("1/2" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest((".25" : GoString), ("1/4" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("-1/5" : GoString), ("-1/5" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("8129567.7690E14" : GoString), ("812956776900000000000" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("78189e+4" : GoString), ("781890000" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("553019.8935e+8" : GoString), ("55301989350000" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("98765432109876543210987654321e-10" : GoString), ("98765432109876543210987654321/10000000000" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("9877861857500000E-7" : GoString), ("3951144743/4" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("2169378.417e-3" : GoString), ("2169378417/1000000" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("884243222337379604041632732738665534" : GoString), ("884243222337379604041632732738665534" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("53/70893980658822810696" : GoString), ("53/70893980658822810696" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("106/141787961317645621392" : GoString), ("53/70893980658822810696" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("204211327800791583.81095" : GoString), ("4084226556015831676219/20000" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0e9999999999" : GoString), ("0" : GoString), true) : stdgo.math.big.Big.StringTest)) : Slice<stdgo.math.big.Big.StringTest>);
/**
    // These are not supported by fmt.Fscanf.
    
    
**/
private var _setStringTests2 = (new Slice<stdgo.math.big.Big.StringTest>(
0,
0,
({ _in : ("4/3x" : GoString) } : stdgo.math.big.Big.StringTest),
({ _in : ("0/-1" : GoString) } : stdgo.math.big.Big.StringTest),
({ _in : ("-1/-1" : GoString) } : stdgo.math.big.Big.StringTest),
({ _in : ("10_/1" : GoString) } : stdgo.math.big.Big.StringTest),
({ _in : ("_10/1" : GoString) } : stdgo.math.big.Big.StringTest),
({ _in : ("1/1__0" : GoString) } : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0b1000/3" : GoString), ("8/3" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0B1000/0x8" : GoString), ("1" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("-010/1" : GoString), ("-8" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("-010.0" : GoString), ("-10" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("-0o10/1" : GoString), ("-8" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0x10/1" : GoString), ("16" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0x10/0x20" : GoString), ("1/2" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0010" : GoString), ("10" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0x10.0" : GoString), ("16" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0x1.8" : GoString), ("3/2" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0X1.8p4" : GoString), ("24" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0x1.1E2" : GoString), ("2289/2048" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0b1.1E2" : GoString), ("150" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0B1.1P3" : GoString), ("12" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0o10e-2" : GoString), ("2/25" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0O10p-3" : GoString), ("1" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0b_1000/3" : GoString), ("8/3" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0B_10_00/0x8" : GoString), ("1" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0xdead/0B1101_1110_1010_1101" : GoString), ("1" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0B1101_1110_1010_1101/0XD_E_A_D" : GoString), ("1" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("1_000.0" : GoString), ("1000" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0x_10.0" : GoString), ("16" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0x1_0.0" : GoString), ("16" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0x1.8_0" : GoString), ("3/2" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0X1.8p0_4" : GoString), ("24" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0b1.1_0E2" : GoString), ("150" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0o1_0e-2" : GoString), ("2/25" : GoString), true) : stdgo.math.big.Big.StringTest),
(new stdgo.math.big.Big.StringTest(("0O_10p-3" : GoString), ("1" : GoString), true) : stdgo.math.big.Big.StringTest)) : Slice<stdgo.math.big.Big.StringTest>);
/**
    
    
    
**/
private var _floatStringTests = (new Slice<T__struct_62>(
0,
0,
({ _in : ("0" : GoString), _prec : (0 : GoInt), _out : ("0" : GoString) } : T__struct_62),
({ _in : ("0" : GoString), _prec : (4 : GoInt), _out : ("0.0000" : GoString) } : T__struct_62),
({ _in : ("1" : GoString), _prec : (0 : GoInt), _out : ("1" : GoString) } : T__struct_62),
({ _in : ("1" : GoString), _prec : (2 : GoInt), _out : ("1.00" : GoString) } : T__struct_62),
({ _in : ("-1" : GoString), _prec : (0 : GoInt), _out : ("-1" : GoString) } : T__struct_62),
({ _in : ("0.05" : GoString), _prec : (1 : GoInt), _out : ("0.1" : GoString) } : T__struct_62),
({ _in : ("-0.05" : GoString), _prec : (1 : GoInt), _out : ("-0.1" : GoString) } : T__struct_62),
({ _in : (".25" : GoString), _prec : (2 : GoInt), _out : ("0.25" : GoString) } : T__struct_62),
({ _in : (".25" : GoString), _prec : (1 : GoInt), _out : ("0.3" : GoString) } : T__struct_62),
({ _in : (".25" : GoString), _prec : (3 : GoInt), _out : ("0.250" : GoString) } : T__struct_62),
({ _in : ("-1/3" : GoString), _prec : (3 : GoInt), _out : ("-0.333" : GoString) } : T__struct_62),
({ _in : ("-2/3" : GoString), _prec : (4 : GoInt), _out : ("-0.6667" : GoString) } : T__struct_62),
({ _in : ("0.96" : GoString), _prec : (1 : GoInt), _out : ("1.0" : GoString) } : T__struct_62),
({ _in : ("0.999" : GoString), _prec : (2 : GoInt), _out : ("1.00" : GoString) } : T__struct_62),
({ _in : ("0.9" : GoString), _prec : (0 : GoInt), _out : ("1" : GoString) } : T__struct_62),
({ _in : (".25" : GoString), _prec : (-1 : GoInt), _out : ("0" : GoString) } : T__struct_62),
({ _in : (".55" : GoString), _prec : (-1 : GoInt), _out : ("1" : GoString) } : T__struct_62)) : Slice<T__struct_62>);
/**
    // Test inputs to Rat.SetString. The prefix "long:" causes the test
    // to be skipped except in -long mode.  (The threshold is about 500us.)
    
    
**/
private var _float64inputs = (new Slice<GoString>(
0,
0,
("5e+125" : GoString),
("69e+267" : GoString),
("999e-026" : GoString),
("7861e-034" : GoString),
("75569e-254" : GoString),
("928609e-261" : GoString),
("9210917e+080" : GoString),
("84863171e+114" : GoString),
("653777767e+273" : GoString),
("5232604057e-298" : GoString),
("27235667517e-109" : GoString),
("653532977297e-123" : GoString),
("3142213164987e-294" : GoString),
("46202199371337e-072" : GoString),
("231010996856685e-073" : GoString),
("9324754620109615e+212" : GoString),
("78459735791271921e+049" : GoString),
("272104041512242479e+200" : GoString),
("6802601037806061975e+198" : GoString),
("20505426358836677347e-221" : GoString),
("836168422905420598437e-234" : GoString),
("4891559871276714924261e+222" : GoString),
("9e-265" : GoString),
("85e-037" : GoString),
("623e+100" : GoString),
("3571e+263" : GoString),
("81661e+153" : GoString),
("920657e-023" : GoString),
("4603285e-024" : GoString),
("87575437e-309" : GoString),
("245540327e+122" : GoString),
("6138508175e+120" : GoString),
("83356057653e+193" : GoString),
("619534293513e+124" : GoString),
("2335141086879e+218" : GoString),
("36167929443327e-159" : GoString),
("609610927149051e-255" : GoString),
("3743626360493413e-165" : GoString),
("94080055902682397e-242" : GoString),
("899810892172646163e+283" : GoString),
("7120190517612959703e+120" : GoString),
("25188282901709339043e-252" : GoString),
("308984926168550152811e-052" : GoString),
("6372891218502368041059e+064" : GoString),
("5e-20" : GoString),
("67e+14" : GoString),
("985e+15" : GoString),
("7693e-42" : GoString),
("55895e-16" : GoString),
("996622e-44" : GoString),
("7038531e-32" : GoString),
("60419369e-46" : GoString),
("702990899e-20" : GoString),
("6930161142e-48" : GoString),
("25933168707e+13" : GoString),
("596428896559e+20" : GoString),
("3e-23" : GoString),
("57e+18" : GoString),
("789e-35" : GoString),
("2539e-18" : GoString),
("76173e+28" : GoString),
("887745e-11" : GoString),
("5382571e-37" : GoString),
("82381273e-35" : GoString),
("750486563e-38" : GoString),
("3752432815e-39" : GoString),
("75224575729e-45" : GoString),
("459926601011e+15" : GoString),
("0" : GoString),
("1" : GoString),
("+1" : GoString),
("1e23" : GoString),
("1E23" : GoString),
("100000000000000000000000" : GoString),
("1e-100" : GoString),
("123456700" : GoString),
("99999999999999974834176" : GoString),
("100000000000000000000001" : GoString),
("100000000000000008388608" : GoString),
("100000000000000016777215" : GoString),
("100000000000000016777216" : GoString),
("-1" : GoString),
("-0.1" : GoString),
("-0" : GoString),
("1e-20" : GoString),
("625e-3" : GoString),
("1.7976931348623157e308" : GoString),
("-1.7976931348623157e308" : GoString),
("1.7976931348623159e308" : GoString),
("-1.7976931348623159e308" : GoString),
("1.7976931348623158e308" : GoString),
("-1.7976931348623158e308" : GoString),
("1.797693134862315808e308" : GoString),
("-1.797693134862315808e308" : GoString),
("1e308" : GoString),
("2e308" : GoString),
("1e309" : GoString),
("1e310" : GoString),
("-1e310" : GoString),
("1e400" : GoString),
("-1e400" : GoString),
("long:1e400000" : GoString),
("long:-1e400000" : GoString),
("1e-305" : GoString),
("1e-306" : GoString),
("1e-307" : GoString),
("1e-308" : GoString),
("1e-309" : GoString),
("1e-310" : GoString),
("1e-322" : GoString),
("5e-324" : GoString),
("4e-324" : GoString),
("3e-324" : GoString),
("2e-324" : GoString),
("1e-350" : GoString),
("long:1e-400000" : GoString),
("-1e-350" : GoString),
("long:-1e-400000" : GoString),
("2.2250738585072012e-308" : GoString),
("2.2250738585072011e-308" : GoString),
("4.630813248087435e+307" : GoString),
("22.222222222222222" : GoString),
(("long:2." : GoString) + stdgo.strings.Strings.repeat(("2" : GoString), (4000 : GoInt))) + ("e+1" : GoString),
("1.00000000000000011102230246251565404236316680908203125" : GoString),
("1.00000000000000011102230246251565404236316680908203124" : GoString),
("1.00000000000000011102230246251565404236316680908203126" : GoString),
(("long:1.00000000000000011102230246251565404236316680908203125" : GoString) + stdgo.strings.Strings.repeat(("0" : GoString), (10000 : GoInt))) + ("1" : GoString),
("4.940656458412465441765687928682213723651e-324" : GoString),
("2.470328229206232720882843964341106861825e-324" : GoString),
("2.470328302827751011111470718709768633275e-324" : GoString),
("2.225073858507201136057409796709131975935e-308" : GoString),
("1152921504606846975" : GoString),
("-1152921504606846975" : GoString),
("1152921504606846977" : GoString),
("-1152921504606846977" : GoString),
("1/3" : GoString)) : Slice<GoString>);
/**
    
    
    
**/
private var _ratNums = (new Slice<GoString>(
0,
0,
("-141592653589793238462643383279502884197169399375105820974944592307816406286" : GoString),
("-1415926535897932384626433832795028841971" : GoString),
("-141592653589793" : GoString),
("-1" : GoString),
("0" : GoString),
("1" : GoString),
("141592653589793" : GoString),
("1415926535897932384626433832795028841971" : GoString),
("141592653589793238462643383279502884197169399375105820974944592307816406286" : GoString)) : Slice<GoString>);
/**
    
    
    
**/
private var _ratDenoms = (new Slice<GoString>(0, 0, ("1" : GoString), ("718281828459045" : GoString), ("7182818284590452353602874713526624977572" : GoString), ("718281828459045235360287471352662497757247093699959574966967627724076630353" : GoString)) : Slice<GoString>);
/**
    
    
    
**/
private final __Accuracy_name = ("BelowExactAbove" : GoString);
/**
    
    
    // word size in bytes
**/
private final __S = (4i64 : GoUInt64);
/**
    
    
    // word size in bits
**/
private final __W = (32i64 : GoUInt64);
/**
    
    
    // digit base
**/
private final __B = (4294967296i64 : GoUInt64);
/**
    
    
    // digit mask
**/
private final __M = (4294967295i64 : GoUInt64);
/**
    
    
    
**/
private final _issue42838Value = ("159309191113245227702888039776771180559110455519261878607388585338616290151305816094308987472018268594098344692611135542392730712890625" : GoString);
/**
    
    
    
**/
private final _testsNumber = (65536i64 : GoUInt64);
/**
    
    
    
**/
private final _sqrModeMul = ("mul(x, x)" : GoString);
/**
    
    
    
**/
private final _sqrModeBasic = ("basicSqr(x)" : GoString);
/**
    
    
    
**/
private final _sqrModeKaratsuba = ("karatsubaSqr(x)" : GoString);
/**
    // Maximum shift amount that can be done in one pass without overflow.
    // A Word has _W bits and (1<<maxShift - 1)*10 + 9 must fit into Word.
    
    
**/
private final _maxShift = (28i64 : GoUInt64);
/**
    
    
    
**/
private var _sink : GoString = ("" : GoString);
/**
    
    
    // enable for debugging
**/
private final _debugFloat = false;
/**
    // Exponent and precision limits.
    
    // largest supported exponent
**/
final maxExp = (2147483647i64 : GoUInt64);
/**
    // Exponent and precision limits.
    
    // smallest supported exponent
**/
final minExp = (0i64 : GoUInt64);
/**
    // Exponent and precision limits.
    
    // largest (theoretically) supported precision; likely memory-limited
**/
final maxPrec = (4294967295i64 : GoUInt64);
/**
    // The form value order is relevant - do not change!
    
    
**/
private final _zero : T_form = (2 : stdgo.math.big.Big.T_form);
/**
    // The form value order is relevant - do not change!
    
    
**/
private final _finite = (2 : stdgo.math.big.Big.T_form);
/**
    // The form value order is relevant - do not change!
    
    
**/
private final _inf = (2 : stdgo.math.big.Big.T_form);
/**
    // These constants define supported rounding modes.
    
    // == IEEE 754-2008 roundTiesToEven
**/
final toNearestEven : RoundingMode = (5 : stdgo.math.big.Big.RoundingMode);
/**
    // These constants define supported rounding modes.
    
    // == IEEE 754-2008 roundTiesToAway
**/
final toNearestAway = (5 : stdgo.math.big.Big.RoundingMode);
/**
    // These constants define supported rounding modes.
    
    // == IEEE 754-2008 roundTowardZero
**/
final toZero = (5 : stdgo.math.big.Big.RoundingMode);
/**
    // These constants define supported rounding modes.
    
    // no IEEE 754-2008 equivalent
**/
final awayFromZero = (5 : stdgo.math.big.Big.RoundingMode);
/**
    // These constants define supported rounding modes.
    
    // == IEEE 754-2008 roundTowardNegative
**/
final toNegativeInf = (5 : stdgo.math.big.Big.RoundingMode);
/**
    // These constants define supported rounding modes.
    
    // == IEEE 754-2008 roundTowardPositive
**/
final toPositiveInf = (5 : stdgo.math.big.Big.RoundingMode);
/**
    // Constants describing the Accuracy of a Float.
    
    
**/
final below : Accuracy = (-1 : stdgo.math.big.Big.Accuracy);
/**
    // Constants describing the Accuracy of a Float.
    
    
**/
final exact : Accuracy = (0 : stdgo.math.big.Big.Accuracy);
/**
    // Constants describing the Accuracy of a Float.
    
    
**/
final above : Accuracy = (1 : stdgo.math.big.Big.Accuracy);
/**
    // Verify that ErrNaN implements the error interface.
    
    
**/
private var __6 : Error = Go.asInterface((new ErrNaN() : ErrNaN));
/**
    
    
    
**/
private var _floatZero : Float_ = ({} : stdgo.math.big.Big.Float_);
/**
    
    
    // *Float must implement fmt.Scanner
**/
private var __7 : stdgo.fmt.Fmt.Scanner = Go.asInterface(((null : Ref<stdgo.math.big.Big.Float_>) : Ref<Float_>));
/**
    
    
    
**/
private var _zero_ : GoFloat64 = (0 : GoFloat64);
/**
    
    
    
**/
private final _below1e23 = (0i64 : GoUInt64);
/**
    
    
    
**/
private final _above1e23 = (0i64 : GoUInt64);
/**
    // Gob codec version. Permits backward-compatible changes to the encoding.
    
    
**/
private final _floatGobVersion : GoByte = (1 : GoUInt8);
/**
    
    
    // *Float must implement fmt.Formatter
**/
private var __8 : stdgo.fmt.Fmt.Formatter = Go.asInterface((Go.setRef(_floatZero) : Ref<stdgo.math.big.Big.Float_>));
/**
    
    
    // *Int must implement fmt.Formatter
**/
private var __9 : stdgo.fmt.Fmt.Formatter = Go.asInterface(_intOne);
/**
    
    
    // *Int must implement fmt.Scanner
**/
private var __10 : stdgo.fmt.Fmt.Scanner = Go.asInterface(_intOne);
/**
    // Gob codec version. Permits backward-compatible changes to the encoding.
    
    
**/
private final _intGobVersion : GoByte = (1 : GoUInt8);
/**
    
    
    
**/
private var _natPool : stdgo.sync.Sync.Pool = ({} : stdgo.sync.Sync.Pool);
/**
    
    
    
**/
private final _digits = ("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString);
/**
    // MaxBase is the largest number base accepted for string conversions.
    
    
**/
final maxBase = (62 : GoInt32);
/**
    
    
    
**/
private final _maxBaseSmall = (36 : GoInt32);
/**
    
    
    
**/
private var _cacheBase10 : T__struct_54 = ({ mutex : ({} : stdgo.sync.Sync.Mutex), _table : new GoArray<stdgo.math.big.Big.T_divisor>(...[for (i in 0 ... 64) ({} : stdgo.math.big.Big.T_divisor)]) } : T__struct_54);
/**
    // divRecursiveThreshold is the number of divisor digits
    // at which point divRecursive is faster than divBasic.
    
    
**/
private final _divRecursiveThreshold = (100i64 : GoUInt64);
/**
    
    
    
**/
private var _ratZero : Rat = ({} : stdgo.math.big.Big.Rat);
/**
    
    
    // *Rat must implement fmt.Scanner
**/
private var __11 : stdgo.fmt.Fmt.Scanner = Go.asInterface((Go.setRef(_ratZero) : Ref<stdgo.math.big.Big.Rat>));
/**
    // Gob codec version. Permits backward-compatible changes to the encoding.
    
    
**/
private final _ratGobVersion : GoByte = (1 : GoUInt8);
/**
    
    
    
**/
private final __RoundingMode_name = ("ToNearestEvenToNearestAwayToZeroAwayFromZeroToNegativeInfToPositiveInf" : GoString);
/**
    
    
    
**/
private var _threeOnce : T__struct_64 = ({ once : ({} : stdgo.sync.Sync.Once), _v : (null : Ref<stdgo.math.big.Big.Float_>) } : T__struct_64);
/**
    
    
    
**/
@:structInit @:private class T_argVV {
    public var _z : stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat(0, 0);
    public var _x : stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat(0, 0);
    public var _y : stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat(0, 0);
    public var _c : stdgo.math.big.Big.Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
    public function new(?_z:stdgo.math.big.Big.T_nat, ?_x:stdgo.math.big.Big.T_nat, ?_y:stdgo.math.big.Big.T_nat, ?_c:stdgo.math.big.Big.Word) {
        if (_z != null) this._z = _z;
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_c != null) this._c = _c;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_argVV(_z, _x, _y, _c);
    }
}
/**
    
    
    
**/
@:structInit @:private class T_argVW {
    public var _z : stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat(0, 0);
    public var _x : stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat(0, 0);
    public var _y : stdgo.math.big.Big.Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
    public var _c : stdgo.math.big.Big.Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
    public function new(?_z:stdgo.math.big.Big.T_nat, ?_x:stdgo.math.big.Big.T_nat, ?_y:stdgo.math.big.Big.Word, ?_c:stdgo.math.big.Big.Word) {
        if (_z != null) this._z = _z;
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_c != null) this._c = _c;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_argVW(_z, _x, _y, _c);
    }
}
/**
    
    
    
**/
@:structInit @:private class T_argVU {
    public var _d : Slice<stdgo.math.big.Big.Word> = (null : Slice<stdgo.math.big.Big.Word>);
    public var _l : GoUInt = 0;
    public var _xp : GoUInt = 0;
    public var _zp : GoUInt = 0;
    public var _s : GoUInt = 0;
    public var _r : Slice<stdgo.math.big.Big.Word> = (null : Slice<stdgo.math.big.Big.Word>);
    public var _c : stdgo.math.big.Big.Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
    public var _m : GoString = "";
    public function new(?_d:Slice<stdgo.math.big.Big.Word>, ?_l:GoUInt, ?_xp:GoUInt, ?_zp:GoUInt, ?_s:GoUInt, ?_r:Slice<stdgo.math.big.Big.Word>, ?_c:stdgo.math.big.Big.Word, ?_m:GoString) {
        if (_d != null) this._d = _d;
        if (_l != null) this._l = _l;
        if (_xp != null) this._xp = _xp;
        if (_zp != null) this._zp = _zp;
        if (_s != null) this._s = _s;
        if (_r != null) this._r = _r;
        if (_c != null) this._c = _c;
        if (_m != null) this._m = _m;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_argVU(_d, _l, _xp, _zp, _s, _r, _c, _m);
    }
}
/**
    
    
    
**/
@:structInit @:private class T_argVWW {
    public var _z : stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat(0, 0);
    public var _x : stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat(0, 0);
    public var _y : stdgo.math.big.Big.Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
    public var _r : stdgo.math.big.Big.Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
    public var _c : stdgo.math.big.Big.Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
    public function new(?_z:stdgo.math.big.Big.T_nat, ?_x:stdgo.math.big.Big.T_nat, ?_y:stdgo.math.big.Big.Word, ?_r:stdgo.math.big.Big.Word, ?_c:stdgo.math.big.Big.Word) {
        if (_z != null) this._z = _z;
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_r != null) this._r = _r;
        if (_c != null) this._c = _c;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_argVWW(_z, _x, _y, _r, _c);
    }
}
/**
    
    
    
**/
@:structInit @:private class T_argWVW {
    public var _z : stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat(0, 0);
    public var _xn : stdgo.math.big.Big.Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
    public var _x : stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat(0, 0);
    public var _y : stdgo.math.big.Big.Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
    public var _r : stdgo.math.big.Big.Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
    public function new(?_z:stdgo.math.big.Big.T_nat, ?_xn:stdgo.math.big.Big.Word, ?_x:stdgo.math.big.Big.T_nat, ?_y:stdgo.math.big.Big.Word, ?_r:stdgo.math.big.Big.Word) {
        if (_z != null) this._z = _z;
        if (_xn != null) this._xn = _xn;
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_r != null) this._r = _r;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_argWVW(_z, _xn, _x, _y, _r);
    }
}
/**
    // A decimal represents an unsigned floating-point number in decimal representation.
    // The value of a non-zero decimal d is d.mant * 10**d.exp with 0.1 <= d.mant < 1,
    // with the most-significant mantissa digit at index 0. For the zero decimal, the
    // mantissa length and exponent are 0.
    // The zero value for decimal represents a ready-to-use 0.0.
    
    
**/
@:structInit @:private @:using(stdgo.math.big.Big.T_decimal_static_extension) class T_decimal {
    public var _mant : Slice<GoUInt8> = (null : Slice<GoUInt8>);
    public var _exp : GoInt = 0;
    public function new(?_mant:Slice<GoUInt8>, ?_exp:GoInt) {
        if (_mant != null) this._mant = _mant;
        if (_exp != null) this._exp = _exp;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_decimal(_mant, _exp);
    }
}
/**
    // A nonzero finite Float represents a multi-precision floating point number
    //
    //	sign  mantissa  2**exponent
    //
    // with 0.5 <= mantissa < 1.0, and MinExp <= exponent <= MaxExp.
    // A Float may also be zero (+0, -0) or infinite (+Inf, -Inf).
    // All Floats are ordered, and the ordering of two Floats x and y
    // is defined by x.Cmp(y).
    //
    // Each Float value also has a precision, rounding mode, and accuracy.
    // The precision is the maximum number of mantissa bits available to
    // represent the value. The rounding mode specifies how a result should
    // be rounded to fit into the mantissa bits, and accuracy describes the
    // rounding error with respect to the exact result.
    //
    // Unless specified otherwise, all operations (including setters) that
    // specify a *Float variable for the result (usually via the receiver
    // with the exception of MantExp), round the numeric result according
    // to the precision and rounding mode of the result variable.
    //
    // If the provided result precision is 0 (see below), it is set to the
    // precision of the argument with the largest precision value before any
    // rounding takes place, and the rounding mode remains unchanged. Thus,
    // uninitialized Floats provided as result arguments will have their
    // precision set to a reasonable value determined by the operands, and
    // their mode is the zero value for RoundingMode (ToNearestEven).
    //
    // By setting the desired precision to 24 or 53 and using matching rounding
    // mode (typically ToNearestEven), Float operations produce the same results
    // as the corresponding float32 or float64 IEEE-754 arithmetic for operands
    // that correspond to normal (i.e., not denormal) float32 or float64 numbers.
    // Exponent underflow and overflow lead to a 0 or an Infinity for different
    // values than IEEE-754 because Float exponents have a much larger range.
    //
    // The zero (uninitialized) value for a Float is ready to use and represents
    // the number +0.0 exactly, with precision 0 and rounding mode ToNearestEven.
    //
    // Operations always take pointer arguments (*Float) rather
    // than Float values, and each unique Float value requires
    // its own unique *Float pointer. To "copy" a Float value,
    // an existing (or newly allocated) Float must be set to
    // a new value using the Float.Set method; shallow copies
    // of Floats are not supported and may lead to errors.
    
    
**/
@:structInit @:using(stdgo.math.big.Big.Float__static_extension) class Float_ {
    public var _prec : GoUInt32 = 0;
    public var _mode : stdgo.math.big.Big.RoundingMode = ((0 : GoUInt8) : stdgo.math.big.Big.RoundingMode);
    public var _acc : stdgo.math.big.Big.Accuracy = ((0 : GoInt8) : stdgo.math.big.Big.Accuracy);
    public var _form : stdgo.math.big.Big.T_form = ((0 : GoUInt8) : stdgo.math.big.Big.T_form);
    public var _neg : Bool = false;
    public var _mant : stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat(0, 0);
    public var _exp : GoInt32 = 0;
    public function new(?_prec:GoUInt32, ?_mode:stdgo.math.big.Big.RoundingMode, ?_acc:stdgo.math.big.Big.Accuracy, ?_form:stdgo.math.big.Big.T_form, ?_neg:Bool, ?_mant:stdgo.math.big.Big.T_nat, ?_exp:GoInt32) {
        if (_prec != null) this._prec = _prec;
        if (_mode != null) this._mode = _mode;
        if (_acc != null) this._acc = _acc;
        if (_form != null) this._form = _form;
        if (_neg != null) this._neg = _neg;
        if (_mant != null) this._mant = _mant;
        if (_exp != null) this._exp = _exp;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Float_(_prec, _mode, _acc, _form, _neg, _mant, _exp);
    }
}
/**
    // An ErrNaN panic is raised by a Float operation that would lead to
    // a NaN under IEEE-754 rules. An ErrNaN implements the error interface.
    
    
**/
@:structInit @:using(stdgo.math.big.Big.ErrNaN_static_extension) class ErrNaN {
    public var _msg : GoString = "";
    public function new(?_msg:GoString) {
        if (_msg != null) this._msg = _msg;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new ErrNaN(_msg);
    }
}
/**
    
    
    
**/
@:structInit @:private @:using(stdgo.math.big.Big.T_matrix_static_extension) class T_matrix {
    public var _n : GoInt = 0;
    public var _m : GoInt = 0;
    public var _a : Slice<Ref<stdgo.math.big.Big.Rat>> = (null : Slice<Ref<stdgo.math.big.Big.Rat>>);
    public function new(?_n:GoInt, ?_m:GoInt, ?_a:Slice<Ref<stdgo.math.big.Big.Rat>>) {
        if (_n != null) this._n = _n;
        if (_m != null) this._m = _m;
        if (_a != null) this._a = _a;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_matrix(_n, _m, _a);
    }
}
/**
    // An Int represents a signed multi-precision integer.
    // The zero value for an Int represents the value 0.
    //
    // Operations always take pointer arguments (*Int) rather
    // than Int values, and each unique Int value requires
    // its own unique *Int pointer. To "copy" an Int value,
    // an existing (or newly allocated) Int must be set to
    // a new value using the Int.Set method; shallow copies
    // of Ints are not supported and may lead to errors.
    
    
**/
@:structInit @:using(stdgo.math.big.Big.Int__static_extension) class Int_ {
    public var _neg : Bool = false;
    public var _abs : stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat(0, 0);
    public function new(?_neg:Bool, ?_abs:stdgo.math.big.Big.T_nat) {
        if (_neg != null) this._neg = _neg;
        if (_abs != null) this._abs = _abs;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Int_(_neg, _abs);
    }
}
/**
    
    
    
**/
@:structInit @:private class T_argZZ {
    public var _z : Ref<stdgo.math.big.Big.Int_> = (null : Ref<stdgo.math.big.Big.Int_>);
    public var _x : Ref<stdgo.math.big.Big.Int_> = (null : Ref<stdgo.math.big.Big.Int_>);
    public var _y : Ref<stdgo.math.big.Big.Int_> = (null : Ref<stdgo.math.big.Big.Int_>);
    public function new(?_z:Ref<stdgo.math.big.Big.Int_>, ?_x:Ref<stdgo.math.big.Big.Int_>, ?_y:Ref<stdgo.math.big.Big.Int_>) {
        if (_z != null) this._z = _z;
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_argZZ(_z, _x, _y);
    }
}
/**
    
    
    
**/
@:structInit @:private class T_intShiftTest {
    public var _in : GoString = "";
    public var _shift : GoUInt = 0;
    public var _out : GoString = "";
    public function new(?_in:GoString, ?_shift:GoUInt, ?_out:GoString) {
        if (_in != null) this._in = _in;
        if (_shift != null) this._shift = _shift;
        if (_out != null) this._out = _out;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_intShiftTest(_in, _shift, _out);
    }
}
/**
    // byteReader is a local wrapper around fmt.ScanState;
    // it implements the ByteReader interface.
    
    
**/
@:structInit @:private @:using(stdgo.math.big.Big.T_byteReader_static_extension) class T_byteReader {
    @:embedded
    public var scanState : stdgo.fmt.Fmt.ScanState = (null : stdgo.fmt.Fmt.ScanState);
    public function new(?scanState:stdgo.fmt.Fmt.ScanState) {
        if (scanState != null) this.scanState = scanState;
    }
    public function __underlying__() return Go.toInterface(this);
    @:embedded
    public function read(_buf:Slice<GoUInt8>):{ var _0 : GoInt; var _1 : Error; } return scanState.read(_buf);
    @:embedded
    public function readRune():{ var _0 : GoInt32; var _1 : GoInt; var _2 : Error; } return scanState.readRune();
    @:embedded
    public function skipSpace() scanState.skipSpace();
    @:embedded
    public function token(_skipSpace:Bool, _f:GoInt32 -> Bool):{ var _0 : Slice<GoUInt8>; var _1 : Error; } return scanState.token(_skipSpace, _f);
    @:embedded
    public function unreadRune():Error return scanState.unreadRune();
    @:embedded
    public function width():{ var _0 : GoInt; var _1 : Bool; } return scanState.width();
    public function __copy__() {
        return new T_byteReader(scanState);
    }
}
/**
    
    
    
**/
@:structInit @:private class T_argNN {
    public var _z : stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat(0, 0);
    public var _x : stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat(0, 0);
    public var _y : stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat(0, 0);
    public function new(?_z:stdgo.math.big.Big.T_nat, ?_x:stdgo.math.big.Big.T_nat, ?_y:stdgo.math.big.Big.T_nat) {
        if (_z != null) this._z = _z;
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_argNN(_z, _x, _y);
    }
}
/**
    
    
    
**/
@:structInit @:private class T_shiftTest {
    public var _in : stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat(0, 0);
    public var _shift : GoUInt = 0;
    public var _out : stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat(0, 0);
    public function new(?_in:stdgo.math.big.Big.T_nat, ?_shift:GoUInt, ?_out:stdgo.math.big.Big.T_nat) {
        if (_in != null) this._in = _in;
        if (_shift != null) this._shift = _shift;
        if (_out != null) this._out = _out;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_shiftTest(_in, _shift, _out);
    }
}
/**
    
    
    
**/
@:structInit @:private class T_modWTest {
    public var _in : GoString = "";
    public var _dividend : GoString = "";
    public var _out : GoString = "";
    public function new(?_in:GoString, ?_dividend:GoString, ?_out:GoString) {
        if (_in != null) this._in = _in;
        if (_dividend != null) this._dividend = _dividend;
        if (_out != null) this._out = _out;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_modWTest(_in, _dividend, _out);
    }
}
/**
    
    
    
**/
@:structInit @:private class T_divisor {
    public var _bbb : stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat(0, 0);
    public var _nbits : GoInt = 0;
    public var _ndigits : GoInt = 0;
    public function new(?_bbb:stdgo.math.big.Big.T_nat, ?_nbits:GoInt, ?_ndigits:GoInt) {
        if (_bbb != null) this._bbb = _bbb;
        if (_nbits != null) this._nbits = _nbits;
        if (_ndigits != null) this._ndigits = _ndigits;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_divisor(_bbb, _nbits, _ndigits);
    }
}
/**
    // A Rat represents a quotient a/b of arbitrary precision.
    // The zero value for a Rat represents the value 0.
    //
    // Operations always take pointer arguments (*Rat) rather
    // than Rat values, and each unique Rat value requires
    // its own unique *Rat pointer. To "copy" a Rat value,
    // an existing (or newly allocated) Rat must be set to
    // a new value using the Rat.Set method; shallow copies
    // of Rats are not supported and may lead to errors.
    
    
**/
@:structInit @:using(stdgo.math.big.Big.Rat_static_extension) class Rat {
    /**
        // To make zero values for Rat work w/o initialization,
        // a zero value of b (len(b) == 0) acts like b == 1. At
        // the earliest opportunity (when an assignment to the Rat
        // is made), such uninitialized denominators are set to 1.
        // a.neg determines the sign of the Rat, b.neg is ignored.
    **/
    public var _a : stdgo.math.big.Big.Int_ = ({} : stdgo.math.big.Big.Int_);
    public var _b : stdgo.math.big.Big.Int_ = ({} : stdgo.math.big.Big.Int_);
    public function new(?_a:stdgo.math.big.Big.Int_, ?_b:stdgo.math.big.Big.Int_) {
        if (_a != null) this._a = _a;
        if (_b != null) this._b = _b;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new Rat(_a, _b);
    }
}
/**
    
    
    
**/
@:structInit @:private class T_ratBinArg {
    public var _x : GoString = "";
    public var _y : GoString = "";
    public var _z : GoString = "";
    public function new(?_x:GoString, ?_y:GoString, ?_z:GoString) {
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_z != null) this._z = _z;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new T_ratBinArg(_x, _y, _z);
    }
}
/**
    
    
    
**/
@:structInit class StringTest {
    public var _in : GoString = "";
    public var _out : GoString = "";
    public var _ok : Bool = false;
    public function new(?_in:GoString, ?_out:GoString, ?_ok:Bool) {
        if (_in != null) this._in = _in;
        if (_out != null) this._out = _out;
        if (_ok != null) this._ok = _ok;
    }
    public function __underlying__() return Go.toInterface(this);
    public function __copy__() {
        return new StringTest(_in, _out, _ok);
    }
}
class T__struct_0_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_0>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_0_asInterface) class T__struct_0_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_0_static_extension) private typedef T__struct_0 = {
    public var _x : stdgo.math.big.Big.Word;
    public var _y : stdgo.math.big.Big.Word;
    public var _q : stdgo.math.big.Big.Word;
    public var _r : stdgo.math.big.Big.Word;
};
class T__struct_1_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_1>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_1_asInterface) class T__struct_1_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_1_static_extension) private typedef T__struct_1 = {
    public var _x : stdgo.math.big.Big.Word;
    public var _y : stdgo.math.big.Big.Word;
    public var _c : stdgo.math.big.Big.Word;
    public var _q : stdgo.math.big.Big.Word;
    public var _r : stdgo.math.big.Big.Word;
};
class T__struct_2_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_2>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_2_asInterface) class T__struct_2_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_2_static_extension) private typedef T__struct_2 = {
    public var _x1 : stdgo.math.big.Big.Word;
    public var _x0 : stdgo.math.big.Big.Word;
    public var _y : stdgo.math.big.Big.Word;
    public var _q : stdgo.math.big.Big.Word;
    public var _r : stdgo.math.big.Big.Word;
};
class T__struct_3_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_3>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_3_asInterface) class T__struct_3_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_3_static_extension) private typedef T__struct_3 = {
    public var _x : stdgo.math.big.Big.Bits;
    public var _y : stdgo.math.big.Big.Bits;
    public var _want : stdgo.math.big.Big.Bits;
};
class T__struct_4_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_4>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_4_asInterface) class T__struct_4_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_4_static_extension) private typedef T__struct_4 = {
    public var _x : stdgo.math.big.Big.Bits;
    public var _want : stdgo.math.big.Big.Bits;
};
class T__struct_5_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_5>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_5_asInterface) class T__struct_5_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_5_static_extension) private typedef T__struct_5 = {
    public var _bits : stdgo.math.big.Big.Bits;
    public var _want : GoString;
};
class T__struct_6_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_6>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_6_asInterface) class T__struct_6_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_6_static_extension) private typedef T__struct_6 = {
    public var _x : stdgo.math.big.Big.T_decimal;
    public var _want : GoString;
};
class T__struct_7_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_7>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_7_asInterface) class T__struct_7_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_7_static_extension) private typedef T__struct_7 = {
    public var _x : stdgo.math.big.Big.Word;
    public var _shift : GoInt;
    public var _want : GoString;
};
class T__struct_8_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_8>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_8_asInterface) class T__struct_8_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_8_static_extension) private typedef T__struct_8 = {
    public var _x : GoUInt64;
    public var _n : GoInt;
    public var _down : GoString;
    public var _even : GoString;
    public var _up : GoString;
};
class T__struct_9_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_9>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_9_asInterface) class T__struct_9_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_9_static_extension) private typedef T__struct_9 = {
    public var _z : GoInt;
    public var _x : GoInt;
    public var _y : GoInt;
    public var _want : GoInt;
    public var _opname : GoInt32;
    public var _op : (Ref<stdgo.math.big.Big.Float_>, Ref<stdgo.math.big.Big.Float_>, Ref<stdgo.math.big.Big.Float_>) -> Ref<stdgo.math.big.Big.Float_>;
};
class T__struct_10_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_10>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_10_asInterface) class T__struct_10_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_10_static_extension) private typedef T__struct_10 = {
    public var _x : GoString;
    public var _prec : GoUInt;
    public var _want : GoString;
    public var _acc : stdgo.math.big.Big.Accuracy;
};
class T__struct_11_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_11>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_11_asInterface) class T__struct_11_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_11_static_extension) private typedef T__struct_11 = {
    public var _x : GoString;
    public var _want : GoUInt;
};
class T__struct_12_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_12>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_12_asInterface) class T__struct_12_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_12_static_extension) private typedef T__struct_12 = {
    public var _x : GoString;
    public var _s : GoInt;
};
class T__struct_13_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_13>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_13_asInterface) class T__struct_13_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_13_static_extension) private typedef T__struct_13 = {
    public var _x : GoString;
    public var _mant : GoString;
    public var _exp : GoInt;
};
class T__struct_14_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_14>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_14_asInterface) class T__struct_14_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_14_static_extension) private typedef T__struct_14 = {
    public var _frac : GoString;
    public var _exp : GoInt;
    public var _z : GoString;
};
class T__struct_15_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_15>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_15_asInterface) class T__struct_15_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_15_static_extension) private typedef T__struct_15 = {
    public var _x : GoString;
    public var _sign : GoInt;
    public var _signbit : Bool;
    public var _inf : Bool;
};
class T__struct_16_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_16>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_16_asInterface) class T__struct_16_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_16_static_extension) private typedef T__struct_16 = {
    public var _prec : GoUInt;
    public var _x : GoString;
    public var _zero : GoString;
    public var _neven : GoString;
    public var _naway : GoString;
    public var _away : GoString;
};
class T__struct_17_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_17>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_17_asInterface) class T__struct_17_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_17_static_extension) private typedef T__struct_17 = {
    public var _signbit : Bool;
    public var _prec : GoUInt;
    public var _want : GoString;
};
class T__struct_18_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_18>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_18_asInterface) class T__struct_18_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_18_static_extension) private typedef T__struct_18 = {
    public var _x : GoString;
    public var _out : GoUInt64;
    public var _acc : stdgo.math.big.Big.Accuracy;
};
class T__struct_19_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_19>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_19_asInterface) class T__struct_19_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_19_static_extension) private typedef T__struct_19 = {
    public var _x : GoString;
    public var _out : GoInt64;
    public var _acc : stdgo.math.big.Big.Accuracy;
};
class T__struct_20_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_20>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_20_asInterface) class T__struct_20_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_20_static_extension) private typedef T__struct_20 = {
    public var _x : GoString;
    public var _out : GoFloat32;
    public var _acc : stdgo.math.big.Big.Accuracy;
};
class T__struct_21_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_21>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_21_asInterface) class T__struct_21_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_21_static_extension) private typedef T__struct_21 = {
    public var _x : GoString;
    public var _out : GoFloat64;
    public var _acc : stdgo.math.big.Big.Accuracy;
};
class T__struct_22_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_22>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_22_asInterface) class T__struct_22_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_22_static_extension) private typedef T__struct_22 = {
    public var _x : GoString;
    public var _want : GoString;
    public var _acc : stdgo.math.big.Big.Accuracy;
};
class T__struct_23_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_23>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_23_asInterface) class T__struct_23_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_23_static_extension) private typedef T__struct_23 = {
    public var _a : GoFloat64;
    public var _b : GoFloat64;
};
class T__struct_24_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_24>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_24_asInterface) class T__struct_24_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_24_static_extension) private typedef T__struct_24 = {
    public var _x : GoFloat64;
    public var _y : GoFloat64;
};
class T__struct_25_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_25>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_25_asInterface) class T__struct_25_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_25_static_extension) private typedef T__struct_25 = {
    public var _prec : GoUInt;
    public var _mode : stdgo.math.big.Big.RoundingMode;
    public var _op : GoUInt8;
    public var _x : GoString;
    public var _y : GoString;
    public var _want : GoString;
    public var _acc : stdgo.math.big.Big.Accuracy;
};
class T__struct_26_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_26>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_26_asInterface) class T__struct_26_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_26_static_extension) private typedef T__struct_26 = {
    public var _mode : stdgo.math.big.Big.RoundingMode;
    public var _prec : GoUInt;
    public var _x : GoInt64;
    public var _y : GoInt64;
    public var _want : GoInt64;
    public var _op : GoUInt8;
};
class T__struct_27_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_27>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_27_asInterface) class T__struct_27_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_27_static_extension) private typedef T__struct_27 = {
    public var _s : GoString;
    public var _x : GoFloat64;
};
class T__struct_28_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_28>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_28_asInterface) class T__struct_28_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_28_static_extension) private typedef T__struct_28 = {
    public var _x : GoFloat64;
    public var _format : GoUInt8;
    public var _prec : GoInt;
    public var _want : GoString;
};
class T__struct_29_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_29>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_29_asInterface) class T__struct_29_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_29_static_extension) private typedef T__struct_29 = {
    public var _x : GoString;
    public var _round : stdgo.math.big.Big.RoundingMode;
    public var _prec : GoUInt;
    public var _format : GoUInt8;
    public var _digits : GoInt;
    public var _want : GoString;
};
class T__struct_30_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_30>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_30_asInterface) class T__struct_30_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_30_static_extension) private typedef T__struct_30 = {
    public var _format : GoString;
    public var _value : AnyInterface;
    public var _want : GoString;
};
class T__struct_31_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_31>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_31_asInterface) class T__struct_31_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_31_static_extension) private typedef T__struct_31 = {
    public var _input : GoString;
    public var _format : GoString;
    public var _output : GoString;
    public var _remaining : GoInt;
    public var _wantErr : Bool;
};
class T__struct_32_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_32>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_32_asInterface) class T__struct_32_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_32_static_extension) private typedef T__struct_32 = {
    public var _a : GoInt64;
    public var _b : GoInt64;
    public var _prod : GoString;
};
class T__struct_33_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_33>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_33_asInterface) class T__struct_33_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_33_static_extension) private typedef T__struct_33 = {
    public var _n : GoInt64;
    public var _k : GoInt64;
    public var _want : GoString;
};
class T__struct_34_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_34>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_34_asInterface) class T__struct_34_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_34_static_extension) private typedef T__struct_34 = {
    public var _x : GoInt64;
    public var _y : GoInt64;
    public var _q : GoInt64;
    public var _r : GoInt64;
    public var _d : GoInt64;
    public var _m : GoInt64;
};
class T__struct_35_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_35>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_35_asInterface) class T__struct_35_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_35_static_extension) private typedef T__struct_35 = {
    public var _x : GoString;
    public var _y : GoString;
    public var _q : GoString;
    public var _r : GoString;
};
class T__struct_36_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_36>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_36_asInterface) class T__struct_36_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_36_static_extension) private typedef T__struct_36 = {
    public var _in : GoString;
    public var _out : GoInt;
};
class T__struct_37_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_37>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_37_asInterface) class T__struct_37_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_37_static_extension) private typedef T__struct_37 = {
    public var _x : GoString;
    public var _y : GoString;
    public var _m : GoString;
    public var _out : GoString;
};
class T__struct_38_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_38>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_38_asInterface) class T__struct_38_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_38_static_extension) private typedef T__struct_38 = {
    public var _name : GoString;
    public var _val : GoString;
};
class T__struct_39_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_39>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_39_asInterface) class T__struct_39_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_39_static_extension) private typedef T__struct_39 = {
    public var _d : GoString;
    public var _x : GoString;
    public var _y : GoString;
    public var _a : GoString;
    public var _b : GoString;
};
class T__struct_40_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_40>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_40_asInterface) class T__struct_40_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_40_static_extension) private typedef T__struct_40 = {
    public var _x : GoString;
    public var _y : GoString;
    public var _and : GoString;
    public var _or : GoString;
    public var _xor : GoString;
    public var _andNot : GoString;
};
class T__struct_41_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_41>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_41_asInterface) class T__struct_41_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_41_static_extension) private typedef T__struct_41 = {
    public var _x : GoString;
    public var _i : GoInt;
    public var _b : GoUInt;
};
class T__struct_42_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_42>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_42_asInterface) class T__struct_42_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_42_static_extension) private typedef T__struct_42 = {
    public var _in : GoString;
    public var _out : GoUInt;
};
class T__struct_43_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_43>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_43_asInterface) class T__struct_43_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_43_static_extension) private typedef T__struct_43 = {
    public var _in : GoString;
    public var _out : GoString;
};
class T__struct_44_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_44>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_44_asInterface) class T__struct_44_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_44_static_extension) private typedef T__struct_44 = {
    public var _element : GoString;
    public var _modulus : GoString;
};
class T__struct_45_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_45>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_45_asInterface) class T__struct_45_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_45_static_extension) private typedef T__struct_45 = {
    public var _x : GoInt64;
    public var _y : GoInt64;
    public var _result : GoInt;
};
class T__struct_46_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_46>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_46_asInterface) class T__struct_46_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_46_static_extension) private typedef T__struct_46 = {
    public var _in : GoString;
    public var _out : GoString;
    public var _base : GoInt;
    public var _val : GoInt64;
    public var _ok : Bool;
};
class T__struct_47_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_47>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_47_asInterface) class T__struct_47_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_47_static_extension) private typedef T__struct_47 = {
    public var _input : GoString;
    public var _format : GoString;
    public var _output : GoString;
};
class T__struct_48_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_48>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_48_asInterface) class T__struct_48_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_48_static_extension) private typedef T__struct_48 = {
    public var _input : GoString;
    public var _format : GoString;
    public var _output : GoString;
    public var _remaining : GoInt;
};
class T__struct_49_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_49>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_49_asInterface) class T__struct_49_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_49_static_extension) private typedef T__struct_49 = {
    public var _x : stdgo.math.big.Big.T_nat;
    public var _y : stdgo.math.big.Big.T_nat;
    public var _r : GoInt;
};
class T__struct_50_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_50>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_50_asInterface) class T__struct_50_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_50_static_extension) private typedef T__struct_50 = {
    public var _a : GoUInt64;
    public var _b : GoUInt64;
    public var _prod : GoString;
};
class T__struct_51_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_51>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_51_asInterface) class T__struct_51_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_51_static_extension) private typedef T__struct_51 = {
    public var _x : GoString;
    public var _y : GoString;
    public var _m : GoString;
    public var _k0 : GoUInt64;
    public var _out32 : GoString;
    public var _out64 : GoString;
};
class T__struct_52_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_52>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_52_asInterface) class T__struct_52_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_52_static_extension) private typedef T__struct_52 = {
    public var _x : GoString;
    public var _i : GoUInt;
    public var _want : GoUInt;
};
class T__struct_53_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_53>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_53_asInterface) class T__struct_53_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_53_static_extension) private typedef T__struct_53 = {
    public var _x : GoString;
    public var _y : GoString;
    public var _n : GoUInt;
    public var _z : GoString;
};
class T__struct_54_asInterface {
    @:embedded
    public dynamic function _unlockSlow(__0:GoInt32):Void __self__.value._unlockSlow(__0);
    @:embedded
    public dynamic function _lockSlow():Void __self__.value._lockSlow();
    @:embedded
    public dynamic function unlock():Void __self__.value.unlock();
    @:embedded
    public dynamic function tryLock():Bool return __self__.value.tryLock();
    @:embedded
    public dynamic function lock():Void __self__.value.lock();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_54>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_54_asInterface) class T__struct_54_static_extension {
    @:embedded
    public static function _unlockSlow( __self__:T__struct_54, __0:GoInt32) __self__.mutex._unlockSlow(__0);
    @:embedded
    public static function _lockSlow( __self__:T__struct_54) __self__.mutex._lockSlow();
    @:embedded
    public static function unlock( __self__:T__struct_54) __self__.mutex.unlock();
    @:embedded
    public static function tryLock( __self__:T__struct_54):Bool return return __self__.mutex.tryLock();
    @:embedded
    public static function lock( __self__:T__struct_54) __self__.mutex.lock();
}
@:local @:using(stdgo.math.big.Big.T__struct_54_static_extension) private typedef T__struct_54 = {
    @:embedded
    public var mutex : stdgo.sync.Sync.Mutex;
    public var _table : GoArray<stdgo.math.big.Big.T_divisor>;
};
class T__struct_55_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_55>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_55_asInterface) class T__struct_55_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_55_static_extension) private typedef T__struct_55 = {
    public var _x : stdgo.math.big.Big.T_nat;
    public var _b : GoInt;
    public var _s : GoString;
};
class T__struct_56_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_56>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_56_asInterface) class T__struct_56_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_56_static_extension) private typedef T__struct_56 = {
    public var _s : GoString;
    public var _base : GoInt;
    public var _frac : Bool;
    public var _x : stdgo.math.big.Big.T_nat;
    public var _b : GoInt;
    public var _count : GoInt;
    public var _err : Error;
    public var _next : GoInt32;
};
class T__struct_57_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_57>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_57_asInterface) class T__struct_57_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_57_static_extension) private typedef T__struct_57 = {
    public var _rat1 : GoString;
    public var _rat2 : GoString;
    public var _out : GoInt;
};
class T__struct_58_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_58>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_58_asInterface) class T__struct_58_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_58_static_extension) private typedef T__struct_58 = {
    public var _x : GoString;
    public var _y : GoString;
    public var _sum : GoString;
    public var _prod : GoString;
};
class T__struct_59_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_59>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_59_asInterface) class T__struct_59_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_59_static_extension) private typedef T__struct_59 = {
    public var _a : GoInt64;
    public var _b : GoInt64;
    public var _out : GoString;
};
class T__struct_60_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_60>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_60_asInterface) class T__struct_60_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_60_static_extension) private typedef T__struct_60 = {
    public var _name : GoString;
    public var _f : Ref<stdgo.math.big.Big.Rat> -> Void;
};
class T__struct_61_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_61>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_61_asInterface) class T__struct_61_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_61_static_extension) private typedef T__struct_61 = {
    public var _s : GoString;
    public var _base2ok : Bool;
    public var _sepOk : Bool;
    public var _x : GoInt64;
    public var _b : GoInt;
    public var _err : Error;
    public var _next : GoInt32;
};
class T__struct_62_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_62>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_62_asInterface) class T__struct_62_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_62_static_extension) private typedef T__struct_62 = {
    public var _in : GoString;
    public var _prec : GoInt;
    public var _out : GoString;
};
class T__struct_63_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_63>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_63_asInterface) class T__struct_63_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_63_static_extension) private typedef T__struct_63 = {
    public var _input : GoString;
    public var _want : Bool;
};
class T__struct_64_asInterface {
    @:embedded
    public dynamic function _doSlow(_f:() -> Void):Void __self__.value._doSlow(_f);
    @:embedded
    public dynamic function do_(_f:() -> Void):Void __self__.value.do_(_f);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_64>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_64_asInterface) class T__struct_64_static_extension {
    @:embedded
    public static function _doSlow( __self__:T__struct_64, _f:() -> Void) __self__.once._doSlow(_f);
    @:embedded
    public static function do_( __self__:T__struct_64, _f:() -> Void) __self__.once.do_(_f);
}
@:local @:using(stdgo.math.big.Big.T__struct_64_static_extension) private typedef T__struct_64 = {
    @:embedded
    public var once : stdgo.sync.Sync.Once;
    public var _v : Ref<stdgo.math.big.Big.Float_>;
};
class T__struct_65_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_65>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_65_asInterface) class T__struct_65_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_65_static_extension) private typedef T__struct_65 = {
    public var _x : GoString;
    public var _want : GoString;
};
class T__struct_66_asInterface {
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T__struct_66>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T__struct_66_asInterface) class T__struct_66_static_extension {

}
@:local @:using(stdgo.math.big.Big.T__struct_66_static_extension) private typedef T__struct_66 = {
    public var _x : Ref<stdgo.math.big.Big.Float_>;
    public var _want : Ref<stdgo.math.big.Big.Float_>;
};
/**
    // A Word represents a single digit of a multi-precision unsigned integer.
**/
@:named typedef Word = GoUInt;
@:named private typedef T_funVV = (Slice<stdgo.math.big.Big.Word>, Slice<stdgo.math.big.Big.Word>, Slice<stdgo.math.big.Big.Word>) -> stdgo.math.big.Big.Word;
@:named private typedef T_funVW = (Slice<stdgo.math.big.Big.Word>, Slice<stdgo.math.big.Big.Word>, stdgo.math.big.Big.Word) -> stdgo.math.big.Big.Word;
@:named private typedef T_funVWW = (Slice<stdgo.math.big.Big.Word>, Slice<stdgo.math.big.Big.Word>, stdgo.math.big.Big.Word, stdgo.math.big.Big.Word) -> stdgo.math.big.Big.Word;
@:named private typedef T_funWVW = (Slice<stdgo.math.big.Big.Word>, stdgo.math.big.Big.Word, Slice<stdgo.math.big.Big.Word>, stdgo.math.big.Big.Word) -> stdgo.math.big.Big.Word;
/**
    // A Bits value b represents a finite floating-point number x of the form
    //
    //	x = 2**b[0] + 2**b[1] + ... 2**b[len(b)-1]
    //
    // The order of slice elements is not significant. Negative elements may be
    // used to form fractions. A Bits value is normalized if each b[i] occurs at
    // most once. For instance Bits{0, 0, 1} is not normalized but represents the
    // same floating-point number as Bits{2}, which is normalized. The zero (nil)
    // value of Bits is a ready to use Bits value and represents the value 0.
**/
@:named @:using(stdgo.math.big.Big.Bits_static_extension) typedef Bits = Slice<GoInt>;
/**
    // A form value describes the internal representation.
**/
@:named private typedef T_form = GoUInt8;
/**
    // RoundingMode determines how a Float value is rounded to the
    // desired precision. Rounding may change the Float value; the
    // rounding error is described by the Float's Accuracy.
**/
@:named @:using(stdgo.math.big.Big.RoundingMode_static_extension) typedef RoundingMode = GoUInt8;
/**
    // Accuracy describes the rounding error produced by the most recent
    // operation that generated a Float value, relative to the exact value.
**/
@:named @:using(stdgo.math.big.Big.Accuracy_static_extension) typedef Accuracy = GoInt8;
@:named private typedef T_funZZ = (Ref<stdgo.math.big.Big.Int_>, Ref<stdgo.math.big.Big.Int_>, Ref<stdgo.math.big.Big.Int_>) -> Ref<stdgo.math.big.Big.Int_>;
@:named private typedef T_bitFun = (Ref<stdgo.math.big.Big.Int_>, Ref<stdgo.math.big.Big.Int_>, Ref<stdgo.math.big.Big.Int_>) -> Ref<stdgo.math.big.Big.Int_>;
/**
    // An unsigned integer x of the form
    //
    //	x = x[n-1]*_B^(n-1) + x[n-2]*_B^(n-2) + ... + x[1]*_B + x[0]
    //
    // with 0 <= x[i] < _B and 0 <= i < n is stored in a slice of length n,
    // with the digits x[i] as the slice elements.
    //
    // A number is normalized if the slice contains no leading 0 digits.
    // During arithmetic operations, denormalized values may occur but are
    // always normalized before returning the final result. The normalized
    // representation of 0 is the empty or nil slice (length = 0).
**/
@:named @:using(stdgo.math.big.Big.T_nat_static_extension) private typedef T_nat = Slice<stdgo.math.big.Big.Word>;
@:named private typedef T_funNN = (stdgo.math.big.Big.T_nat, stdgo.math.big.Big.T_nat, stdgo.math.big.Big.T_nat) -> stdgo.math.big.Big.T_nat;
@:named private typedef T_ratBinFun = (Ref<stdgo.math.big.Big.Rat>, Ref<stdgo.math.big.Big.Rat>, Ref<stdgo.math.big.Big.Rat>) -> Ref<stdgo.math.big.Big.Rat>;
/**
    // z1<<_W + z0 = x*y
**/
private function _mulWW(_x:Word, _y:Word):{ var _0 : Word; var _1 : Word; } {
        var _z1:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word), _z0:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        var __tmp__ = stdgo.math.bits.Bits.mul((_x : GoUInt), (_y : GoUInt)), _hi:GoUInt = __tmp__._0, _lo:GoUInt = __tmp__._1;
        return { _0 : (_hi : Word), _1 : (_lo : Word) };
    }
/**
    // z1<<_W + z0 = x*y + c
**/
private function _mulAddWWW_g(_x:Word, _y:Word, _c:Word):{ var _0 : Word; var _1 : Word; } {
        var _z1:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word), _z0:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        var __tmp__ = stdgo.math.bits.Bits.mul((_x : GoUInt), (_y : GoUInt)), _hi:GoUInt = __tmp__._0, _lo:GoUInt = __tmp__._1;
        var _cc:GoUInt = (0 : GoUInt);
        {
            var __tmp__ = stdgo.math.bits.Bits.add(_lo, (_c : GoUInt), (0u32 : GoUInt));
            _lo = __tmp__._0;
            _cc = __tmp__._1;
        };
        return { _0 : (_hi + _cc : Word), _1 : (_lo : Word) };
    }
/**
    // nlz returns the number of leading zeros in x.
    // Wraps bits.LeadingZeros call for convenience.
**/
private function _nlz(_x:Word):GoUInt {
        return (stdgo.math.bits.Bits.leadingZeros((_x : GoUInt)) : GoUInt);
    }
/**
    // The resulting carry c is either 0 or 1.
**/
private function _addVV_g(_z:Slice<Word>, _x:Slice<Word>, _y:Slice<Word>):Word {
        var _c:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(((_i < _z.length) && (_i < _x.length)) && (_i < _y.length), _i++, {
                var __tmp__ = stdgo.math.bits.Bits.add((_x[(_i : GoInt)] : GoUInt), (_y[(_i : GoInt)] : GoUInt), (_c : GoUInt)), _zi:GoUInt = __tmp__._0, _cc:GoUInt = __tmp__._1;
                _z[(_i : GoInt)] = (_zi : Word);
                _c = (_cc : Word);
            });
        };
        return _c;
    }
/**
    // The resulting carry c is either 0 or 1.
**/
private function _subVV_g(_z:Slice<Word>, _x:Slice<Word>, _y:Slice<Word>):Word {
        var _c:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(((_i < _z.length) && (_i < _x.length)) && (_i < _y.length), _i++, {
                var __tmp__ = stdgo.math.bits.Bits.sub((_x[(_i : GoInt)] : GoUInt), (_y[(_i : GoInt)] : GoUInt), (_c : GoUInt)), _zi:GoUInt = __tmp__._0, _cc:GoUInt = __tmp__._1;
                _z[(_i : GoInt)] = (_zi : Word);
                _c = (_cc : Word);
            });
        };
        return _c;
    }
/**
    // The resulting carry c is either 0 or 1.
**/
private function _addVW_g(_z:Slice<Word>, _x:Slice<Word>, _y:Word):Word {
        var _c:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        _c = _y;
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor((_i < _z.length) && (_i < _x.length), _i++, {
                var __tmp__ = stdgo.math.bits.Bits.add((_x[(_i : GoInt)] : GoUInt), (_c : GoUInt), (0u32 : GoUInt)), _zi:GoUInt = __tmp__._0, _cc:GoUInt = __tmp__._1;
                _z[(_i : GoInt)] = (_zi : Word);
                _c = (_cc : Word);
            });
        };
        return _c;
    }
/**
    // addVWlarge is addVW, but intended for large z.
    // The only difference is that we check on every iteration
    // whether we are done with carries,
    // and if so, switch to a much faster copy instead.
    // This is only a good idea for large z,
    // because the overhead of the check and the function call
    // outweigh the benefits when z is small.
**/
private function _addVWlarge(_z:Slice<Word>, _x:Slice<Word>, _y:Word):Word {
        var _c:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        _c = _y;
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor((_i < _z.length) && (_i < _x.length), _i++, {
                if (_c == ((0u32 : stdgo.math.big.Big.Word))) {
                    Go.copySlice((_z.__slice__(_i) : Slice<stdgo.math.big.Big.Word>), (_x.__slice__(_i) : Slice<stdgo.math.big.Big.Word>));
                    return _c;
                };
                var __tmp__ = stdgo.math.bits.Bits.add((_x[(_i : GoInt)] : GoUInt), (_c : GoUInt), (0u32 : GoUInt)), _zi:GoUInt = __tmp__._0, _cc:GoUInt = __tmp__._1;
                _z[(_i : GoInt)] = (_zi : Word);
                _c = (_cc : Word);
            });
        };
        return _c;
    }
private function _subVW_g(_z:Slice<Word>, _x:Slice<Word>, _y:Word):Word {
        var _c:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        _c = _y;
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor((_i < _z.length) && (_i < _x.length), _i++, {
                var __tmp__ = stdgo.math.bits.Bits.sub((_x[(_i : GoInt)] : GoUInt), (_c : GoUInt), (0u32 : GoUInt)), _zi:GoUInt = __tmp__._0, _cc:GoUInt = __tmp__._1;
                _z[(_i : GoInt)] = (_zi : Word);
                _c = (_cc : Word);
            });
        };
        return _c;
    }
/**
    // subVWlarge is to subVW as addVWlarge is to addVW.
**/
private function _subVWlarge(_z:Slice<Word>, _x:Slice<Word>, _y:Word):Word {
        var _c:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        _c = _y;
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor((_i < _z.length) && (_i < _x.length), _i++, {
                if (_c == ((0u32 : stdgo.math.big.Big.Word))) {
                    Go.copySlice((_z.__slice__(_i) : Slice<stdgo.math.big.Big.Word>), (_x.__slice__(_i) : Slice<stdgo.math.big.Big.Word>));
                    return _c;
                };
                var __tmp__ = stdgo.math.bits.Bits.sub((_x[(_i : GoInt)] : GoUInt), (_c : GoUInt), (0u32 : GoUInt)), _zi:GoUInt = __tmp__._0, _cc:GoUInt = __tmp__._1;
                _z[(_i : GoInt)] = (_zi : Word);
                _c = (_cc : Word);
            });
        };
        return _c;
    }
private function _shlVU_g(_z:Slice<Word>, _x:Slice<Word>, _s:GoUInt):Word {
        var _c:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        if (_s == ((0u32 : GoUInt))) {
            Go.copySlice(_z, _x);
            return _c;
        };
        if ((_z.length) == ((0 : GoInt))) {
            return _c;
        };
        _s = _s & ((31u32 : GoUInt));
        var __349:GoUInt = (32u32 : GoUInt) - _s;
        __349 = __349 & ((31u32 : GoUInt));
        _c = _x[((_z.length) - (1 : GoInt) : GoInt)] >> __349;
        {
            var _i:GoInt = (_z.length) - (1 : GoInt);
            Go.cfor(_i > (0 : GoInt), _i--, {
                _z[(_i : GoInt)] = (_x[(_i : GoInt)] << _s) | (_x[(_i - (1 : GoInt) : GoInt)] >> __349);
            });
        };
        _z[(0 : GoInt)] = _x[(0 : GoInt)] << _s;
        return _c;
    }
private function _shrVU_g(_z:Slice<Word>, _x:Slice<Word>, _s:GoUInt):Word {
        var _c:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        if (_s == ((0u32 : GoUInt))) {
            Go.copySlice(_z, _x);
            return _c;
        };
        if ((_z.length) == ((0 : GoInt))) {
            return _c;
        };
        if ((_x.length) != ((_z.length))) {
            throw Go.toInterface(("len(x) != len(z)" : GoString));
        };
        _s = _s & ((31u32 : GoUInt));
        var __349:GoUInt = (32u32 : GoUInt) - _s;
        __349 = __349 & ((31u32 : GoUInt));
        _c = _x[(0 : GoInt)] << __349;
        {
            var _i:GoInt = (1 : GoInt);
            Go.cfor(_i < (_z.length), _i++, {
                _z[(_i - (1 : GoInt) : GoInt)] = (_x[(_i - (1 : GoInt) : GoInt)] >> _s) | (_x[(_i : GoInt)] << __349);
            });
        };
        _z[((_z.length) - (1 : GoInt) : GoInt)] = _x[((_z.length) - (1 : GoInt) : GoInt)] >> _s;
        return _c;
    }
private function _mulAddVWW_g(_z:Slice<Word>, _x:Slice<Word>, _y:Word, _r:Word):Word {
        var _c:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        _c = _r;
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor((_i < _z.length) && (_i < _x.length), _i++, {
                {
                    var __tmp__ = _mulAddWWW_g(_x[(_i : GoInt)], _y, _c);
                    _c = __tmp__._0;
                    _z[(_i : GoInt)] = __tmp__._1;
                };
            });
        };
        return _c;
    }
private function _addMulVVW_g(_z:Slice<Word>, _x:Slice<Word>, _y:Word):Word {
        var _c:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor((_i < _z.length) && (_i < _x.length), _i++, {
                var __tmp__ = _mulAddWWW_g(_x[(_i : GoInt)], _y, _z[(_i : GoInt)]), _z1:stdgo.math.big.Big.Word = __tmp__._0, _z0:stdgo.math.big.Big.Word = __tmp__._1;
                var __tmp__ = stdgo.math.bits.Bits.add((_z0 : GoUInt), (_c : GoUInt), (0u32 : GoUInt)), _lo:GoUInt = __tmp__._0, _cc:GoUInt = __tmp__._1;
                {
                    final __tmp__0 = (_cc : Word);
                    final __tmp__1 = (_lo : Word);
                    _c = __tmp__0;
                    _z[(_i : GoInt)] = __tmp__1;
                };
                _c = _c + (_z1);
            });
        };
        return _c;
    }
/**
    // q = ( x1 << _W + x0 - r)/y. m = floor(( _B^2 - 1 ) / d - _B). Requiring x1<y.
    // An approximate reciprocal with a reference to "Improved Division by Invariant Integers
    // (IEEE Transactions on Computers, 11 Jun. 2010)"
**/
private function _divWW(_x1:Word, _x0:Word, _y:Word, _m:Word):{ var _0 : Word; var _1 : Word; } {
        var _q:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word), _r:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        var _s:GoUInt = _nlz(_y);
        if (_s != ((0u32 : GoUInt))) {
            _x1 = (_x1 << _s) | (_x0 >> ((32u32 : GoUInt) - _s));
            _x0 = _x0 << (_s);
            _y = _y << (_s);
        };
        var _d:GoUInt = (_y : GoUInt);
        var __tmp__ = stdgo.math.bits.Bits.mul((_m : GoUInt), (_x1 : GoUInt)), _t1:GoUInt = __tmp__._0, _t0:GoUInt = __tmp__._1;
        var __tmp__ = stdgo.math.bits.Bits.add(_t0, (_x0 : GoUInt), (0u32 : GoUInt)), __0:GoUInt = __tmp__._0, _c:GoUInt = __tmp__._1;
        {
            var __tmp__ = stdgo.math.bits.Bits.add(_t1, (_x1 : GoUInt), _c);
            _t1 = __tmp__._0;
        };
        var _qq:GoUInt = _t1;
        var __tmp__ = stdgo.math.bits.Bits.mul(_d, _qq), _dq1:GoUInt = __tmp__._0, _dq0:GoUInt = __tmp__._1;
        var __tmp__ = stdgo.math.bits.Bits.sub((_x0 : GoUInt), _dq0, (0u32 : GoUInt)), _r0:GoUInt = __tmp__._0, _b:GoUInt = __tmp__._1;
        var __tmp__ = stdgo.math.bits.Bits.sub((_x1 : GoUInt), _dq1, _b), _r1:GoUInt = __tmp__._0, __1:GoUInt = __tmp__._1;
        if (_r1 != ((0u32 : GoUInt))) {
            _qq++;
            _r0 = _r0 - (_d);
        };
        if (_r0 >= _d) {
            _qq++;
            _r0 = _r0 - (_d);
        };
        return { _0 : (_qq : Word), _1 : (_r0 >> _s : Word) };
    }
/**
    // reciprocalWord return the reciprocal of the divisor. rec = floor(( _B^2 - 1 ) / u - _B). u = d1 << nlz(d1).
**/
private function _reciprocalWord(_d1:Word):Word {
        var _u:GoUInt = (_d1 << _nlz(_d1) : GoUInt);
        var _x1:GoUInt = (-1 ^ _u);
        var _x0:GoUInt = (-1u32 : GoUInt);
        var __tmp__ = stdgo.math.bits.Bits.div(_x1, _x0, _u), _rec:GoUInt = __tmp__._0, __0:GoUInt = __tmp__._1;
        return (_rec : Word);
    }
private function _addVV(_z:Slice<Word>, _x:Slice<Word>, _y:Slice<Word>):Word {
        var _c:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        return _addVV_g(_z, _x, _y);
    }
private function _subVV(_z:Slice<Word>, _x:Slice<Word>, _y:Slice<Word>):Word {
        var _c:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        return _subVV_g(_z, _x, _y);
    }
private function _addVW(_z:Slice<Word>, _x:Slice<Word>, _y:Word):Word {
        var _c:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        var _fn = _addVW_g;
        if ((_z.length) > (32 : GoInt)) {
            _fn = _addVWlarge;
        };
        return _fn(_z, _x, _y);
    }
private function _subVW(_z:Slice<Word>, _x:Slice<Word>, _y:Word):Word {
        var _c:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        var _fn = _subVW_g;
        if ((_z.length) > (32 : GoInt)) {
            _fn = _subVWlarge;
        };
        return _fn(_z, _x, _y);
    }
private function _shlVU(_z:Slice<Word>, _x:Slice<Word>, _s:GoUInt):Word {
        var _c:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        return _shlVU_g(_z, _x, _s);
    }
private function _shrVU(_z:Slice<Word>, _x:Slice<Word>, _s:GoUInt):Word {
        var _c:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        return _shrVU_g(_z, _x, _s);
    }
private function _mulAddVWW(_z:Slice<Word>, _x:Slice<Word>, _y:Word, _r:Word):Word {
        var _c:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        return _mulAddVWW_g(_z, _x, _y, _r);
    }
private function _addMulVVW(_z:Slice<Word>, _x:Slice<Word>, _y:Word):Word {
        var _c:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        return _addMulVVW_g(_z, _x, _y);
    }
private function _testFunVV(_t:Ref<stdgo.testing.Testing.T>, _msg:GoString, _f:T_funVV, _a:T_argVV):Void {
        var _z:stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat((_a._z.length : GoInt).toBasic(), 0, ...[for (i in 0 ... (_a._z.length : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
        var _c:stdgo.math.big.Big.Word = _f(_z, _a._x, _a._y);
        for (_i => _zi in _z) {
            if (_zi != (_a._z[(_i : GoInt)])) {
                _t.errorf(("%s%+v\n\tgot z[%d] = %#x; want %#x" : GoString), Go.toInterface(_msg), Go.toInterface(_a), Go.toInterface(_i), Go.toInterface(_zi), Go.toInterface(_a._z[(_i : GoInt)]));
                break;
            };
        };
        if (_c != (_a._c)) {
            _t.errorf(("%s%+v\n\tgot c = %#x; want %#x" : GoString), Go.toInterface(_msg), Go.toInterface(_a), Go.toInterface(_c), Go.toInterface(_a._c));
        };
    }
function testFunVV(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _a in _sumVV) {
            var _arg:stdgo.math.big.Big.T_argVV = _a?.__copy__();
            _testFunVV(_t, ("addVV_g" : GoString), _addVV_g, _arg?.__copy__());
            _testFunVV(_t, ("addVV" : GoString), _addVV, _arg?.__copy__());
            _arg = (new T_argVV(_a._z, _a._y, _a._x, _a._c) : T_argVV);
            _testFunVV(_t, ("addVV_g symmetric" : GoString), _addVV_g, _arg?.__copy__());
            _testFunVV(_t, ("addVV symmetric" : GoString), _addVV, _arg?.__copy__());
            _arg = (new T_argVV(_a._x, _a._z, _a._y, _a._c) : T_argVV);
            _testFunVV(_t, ("subVV_g" : GoString), _subVV_g, _arg?.__copy__());
            _testFunVV(_t, ("subVV" : GoString), _subVV, _arg?.__copy__());
            _arg = (new T_argVV(_a._y, _a._z, _a._x, _a._c) : T_argVV);
            _testFunVV(_t, ("subVV_g symmetric" : GoString), _subVV_g, _arg?.__copy__());
            _testFunVV(_t, ("subVV symmetric" : GoString), _subVV, _arg?.__copy__());
        };
    }
private function _rndW():Word {
        return ((_rnd.int63() << (1i64 : GoUInt64)) | _rnd.int63n((2i64 : GoInt64)) : Word);
    }
private function _rndV(_n:GoInt):Slice<Word> {
        var _v = new Slice<stdgo.math.big.Big.Word>((_n : GoInt).toBasic(), 0, ...[for (i in 0 ... (_n : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
        for (_i in 0 ... _v.length.toBasic()) {
            _v[(_i : GoInt)] = _rndW();
        };
        return _v;
    }
function benchmarkAddVV(_b:Ref<stdgo.testing.Testing.B>):Void {
        for (__0 => _n in _benchSizes) {
            if (_isRaceBuilder && (_n > (1000 : GoInt))) {
                continue;
            };
            var _x = _rndV(_n);
            var _y = _rndV(_n);
            var _z = new Slice<stdgo.math.big.Big.Word>((_n : GoInt).toBasic(), 0, ...[for (i in 0 ... (_n : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
            _b.run(stdgo.fmt.Fmt.sprint(Go.toInterface(_n)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                _b.setBytes((_n * (32 : GoInt) : GoInt64));
                {
                    var _i:GoInt = (0 : GoInt);
                    Go.cfor(_i < _b.n, _i++, {
                        _addVV(_z, _x, _y);
                    });
                };
            });
        };
    }
function benchmarkSubVV(_b:Ref<stdgo.testing.Testing.B>):Void {
        for (__0 => _n in _benchSizes) {
            if (_isRaceBuilder && (_n > (1000 : GoInt))) {
                continue;
            };
            var _x = _rndV(_n);
            var _y = _rndV(_n);
            var _z = new Slice<stdgo.math.big.Big.Word>((_n : GoInt).toBasic(), 0, ...[for (i in 0 ... (_n : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
            _b.run(stdgo.fmt.Fmt.sprint(Go.toInterface(_n)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                _b.setBytes((_n * (32 : GoInt) : GoInt64));
                {
                    var _i:GoInt = (0 : GoInt);
                    Go.cfor(_i < _b.n, _i++, {
                        _subVV(_z, _x, _y);
                    });
                };
            });
        };
    }
private function _testFunVW(_t:Ref<stdgo.testing.Testing.T>, _msg:GoString, _f:T_funVW, _a:T_argVW):Void {
        var _z:stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat((_a._z.length : GoInt).toBasic(), 0, ...[for (i in 0 ... (_a._z.length : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
        var _c:stdgo.math.big.Big.Word = _f(_z, _a._x, _a._y);
        for (_i => _zi in _z) {
            if (_zi != (_a._z[(_i : GoInt)])) {
                _t.errorf(("%s%+v\n\tgot z[%d] = %#x; want %#x" : GoString), Go.toInterface(_msg), Go.toInterface(_a), Go.toInterface(_i), Go.toInterface(_zi), Go.toInterface(_a._z[(_i : GoInt)]));
                break;
            };
        };
        if (_c != (_a._c)) {
            _t.errorf(("%s%+v\n\tgot c = %#x; want %#x" : GoString), Go.toInterface(_msg), Go.toInterface(_a), Go.toInterface(_c), Go.toInterface(_a._c));
        };
    }
private function _testFunVWext(_t:Ref<stdgo.testing.Testing.T>, _msg:GoString, _f:T_funVW, _f_g:T_funVW, _a:T_argVW):Void {
        var _z_g:stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat((_a._z.length : GoInt).toBasic(), 0, ...[for (i in 0 ... (_a._z.length : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
        var _c_g:stdgo.math.big.Big.Word = _f_g(_z_g, _a._x, _a._y);
        var _c:stdgo.math.big.Big.Word = _f(_a._z, _a._x, _a._y);
        for (_i => _zi in _a._z) {
            if (_zi != (_z_g[(_i : GoInt)])) {
                _t.errorf(("%s\n\tgot z[%d] = %#x; want %#x" : GoString), Go.toInterface(_msg), Go.toInterface(_i), Go.toInterface(_zi), Go.toInterface(_z_g[(_i : GoInt)]));
                break;
            };
        };
        if (_c != (_c_g)) {
            _t.errorf(("%s\n\tgot c = %#x; want %#x" : GoString), Go.toInterface(_msg), Go.toInterface(_c), Go.toInterface(_c_g));
        };
    }
private function _makeFunVW(_f:(_z:Slice<Word>, _x:Slice<Word>, _s:GoUInt) -> Word):T_funVW {
        return function(_z:Slice<Word>, _x:Slice<Word>, _s:Word):Word {
            var _c:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
            return _f(_z, _x, (_s : GoUInt));
        };
    }
function testFunVW(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _a in _sumVW) {
            var _arg:stdgo.math.big.Big.T_argVW = _a?.__copy__();
            _testFunVW(_t, ("addVW_g" : GoString), _addVW_g, _arg?.__copy__());
            _testFunVW(_t, ("addVW" : GoString), _addVW, _arg?.__copy__());
            _arg = (new T_argVW(_a._x, _a._z, _a._y, _a._c) : T_argVW);
            _testFunVW(_t, ("subVW_g" : GoString), _subVW_g, _arg?.__copy__());
            _testFunVW(_t, ("subVW" : GoString), _subVW, _arg?.__copy__());
        };
        var _shlVW_g:stdgo.math.big.Big.T_funVW = _makeFunVW(_shlVU_g);
        var _shlVW:stdgo.math.big.Big.T_funVW = _makeFunVW(_shlVU);
        for (__1 => _a in _lshVW) {
            var _arg:stdgo.math.big.Big.T_argVW = _a?.__copy__();
            _testFunVW(_t, ("shlVU_g" : GoString), _shlVW_g, _arg?.__copy__());
            _testFunVW(_t, ("shlVU" : GoString), _shlVW, _arg?.__copy__());
        };
        var _shrVW_g:stdgo.math.big.Big.T_funVW = _makeFunVW(_shrVU_g);
        var _shrVW:stdgo.math.big.Big.T_funVW = _makeFunVW(_shrVU);
        for (__2 => _a in _rshVW) {
            var _arg:stdgo.math.big.Big.T_argVW = _a?.__copy__();
            _testFunVW(_t, ("shrVU_g" : GoString), _shrVW_g, _arg?.__copy__());
            _testFunVW(_t, ("shrVU" : GoString), _shrVW, _arg?.__copy__());
        };
    }
/**
    // Construct a vector comprising the same word, usually '0' or 'maximum uint'
**/
private function _makeWordVec(_e:Word, _n:GoInt):Slice<Word> {
        var _v = new Slice<stdgo.math.big.Big.Word>((_n : GoInt).toBasic(), 0, ...[for (i in 0 ... (_n : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
        for (_i in 0 ... _v.length.toBasic()) {
            _v[(_i : GoInt)] = _e;
        };
        return _v;
    }
/**
    // Extended testing to addVW and subVW using various kinds of input data.
    // We utilize the results of addVW_g and subVW_g as golden reference to check
    // correctness.
**/
function testFunVWExt(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _vwSizes:Slice<GoInt> = (new Slice<GoInt>(
0,
0,
(0 : GoInt),
(1 : GoInt),
(3 : GoInt),
(4 : GoInt),
(5 : GoInt),
(8 : GoInt),
(9 : GoInt),
(23 : GoInt),
(31 : GoInt),
(32 : GoInt),
(33 : GoInt),
(34 : GoInt),
(35 : GoInt),
(36 : GoInt),
(50 : GoInt),
(120 : GoInt)) : Slice<GoInt>);
        for (__0 => _n in _vwSizes) {
            var _x = _rndV(_n);
            var _y:stdgo.math.big.Big.Word = _rndW();
            var _z:stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat((_n : GoInt).toBasic(), 0, ...[for (i in 0 ... (_n : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
            var _arg:stdgo.math.big.Big.T_argVW = (new T_argVW(_z, _x, _y, (0u32 : stdgo.math.big.Big.Word)) : T_argVW);
            _testFunVWext(_t, ("addVW, random inputs" : GoString), _addVW, _addVW_g, _arg?.__copy__());
            _testFunVWext(_t, ("subVW, random inputs" : GoString), _subVW, _subVW_g, _arg?.__copy__());
            _arg = (new T_argVW(_x, _x, _y, (0u32 : stdgo.math.big.Big.Word)) : T_argVW);
            _testFunVWext(_t, ("addVW, random inputs, sharing storage" : GoString), _addVW, _addVW_g, _arg?.__copy__());
            _testFunVWext(_t, ("subVW, random inputs, sharing storage" : GoString), _subVW, _subVW_g, _arg?.__copy__());
            _y = (-1u32 : stdgo.math.big.Big.Word);
            _x = _makeWordVec(_y, _n);
            _arg = (new T_argVW(_z, _x, _y, (0u32 : stdgo.math.big.Big.Word)) : T_argVW);
            _testFunVWext(_t, ("addVW, vector of max uint" : GoString), _addVW, _addVW_g, _arg?.__copy__());
            _x = _makeWordVec((0u32 : stdgo.math.big.Big.Word), _n);
            _arg = (new T_argVW(_z, _x, (1u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : T_argVW);
            _testFunVWext(_t, ("subVW, vector of zero" : GoString), _subVW, _subVW_g, _arg?.__copy__());
        };
    }
private function _testShiftFunc(_t:Ref<stdgo.testing.Testing.T>, _f:(_z:Slice<Word>, _x:Slice<Word>, _s:GoUInt) -> Word, _a:T_argVU):Void {
        var _b = new Slice<stdgo.math.big.Big.Word>((_a._d.length : GoInt).toBasic(), 0, ...[for (i in 0 ... (_a._d.length : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
        Go.copySlice(_b, _a._d);
        var _z = (_b.__slice__(_a._zp, _a._zp + _a._l) : Slice<stdgo.math.big.Big.Word>);
        var _x = (_b.__slice__(_a._xp, _a._xp + _a._l) : Slice<stdgo.math.big.Big.Word>);
        var _c:stdgo.math.big.Big.Word = _f(_z, _x, _a._s);
        for (_i => _zi in _z) {
            if (_zi != (_a._r[(_i : GoInt)])) {
                _t.errorf(("d := %v, %s(d[%d:%d], d[%d:%d], %d)\n\tgot z[%d] = %#x; want %#x" : GoString),
Go.toInterface(_a._d),
Go.toInterface(_a._m),
Go.toInterface(_a._zp),
Go.toInterface(_a._zp + _a._l),
Go.toInterface(_a._xp),
Go.toInterface(_a._xp + _a._l),
Go.toInterface(_a._s),
Go.toInterface(_i),
Go.toInterface(_zi),
Go.toInterface(_a._r[(_i : GoInt)]));
                break;
            };
        };
        if (_c != (_a._c)) {
            _t.errorf(("d := %v, %s(d[%d:%d], d[%d:%d], %d)\n\tgot c = %#x; want %#x" : GoString), Go.toInterface(_a._d), Go.toInterface(_a._m), Go.toInterface(_a._zp), Go.toInterface(_a._zp + _a._l), Go.toInterface(_a._xp), Go.toInterface(_a._xp + _a._l), Go.toInterface(_a._s), Go.toInterface(_c), Go.toInterface(_a._c));
        };
    }
function testShiftOverlap(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _a in _argshlVU) {
            var _arg:stdgo.math.big.Big.T_argVU = _a?.__copy__();
            _testShiftFunc(_t, _shlVU, _arg?.__copy__());
        };
        for (__1 => _a in _argshrVU) {
            var _arg:stdgo.math.big.Big.T_argVU = _a?.__copy__();
            _testShiftFunc(_t, _shrVU, _arg?.__copy__());
        };
    }
function testIssue31084(_t:Ref<stdgo.testing.Testing.T>):Void {
        {};
        var _p:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._expNN((new Slice<stdgo.math.big.Big.Word>(0, 0, (5u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (165u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), null, false);
        _p = _p._shl(_p, (165u32 : GoUInt));
        var _got:GoString = (_p._utoa((10 : GoInt)) : GoString);
        var _want:GoString = ("1" : GoString) + stdgo.strings.Strings.repeat(("0" : GoString), (165 : GoInt));
        if (_got != (_want)) {
            _t.errorf(("shl(%v, %v)\n\tgot  %s\n\twant %s" : GoString), Go.toInterface(Go.asInterface(_p)), Go.toInterface((165 : GoInt)), Go.toInterface(_got), Go.toInterface(_want));
        };
    }
function testIssue42838(_t:Ref<stdgo.testing.Testing.T>):Void {
        {};
        var __tmp__ = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._scan(Go.asInterface(stdgo.strings.Strings.newReader(("159309191113245227702888039776771180559110455519261878607388585338616290151305816094308987472018268594098344692611135542392730712890625" : GoString))), (0 : GoInt), false), _z:stdgo.math.big.Big.T_nat = __tmp__._0, __0:GoInt = __tmp__._1, __1:GoInt = __tmp__._2, __2:Error = __tmp__._3;
        _z = _z._shl(_z, (192u32 : GoUInt));
        var _got:GoString = (_z._utoa((10 : GoInt)) : GoString);
        var _want:GoString = ("1" : GoString) + stdgo.strings.Strings.repeat(("0" : GoString), (192 : GoInt));
        if (_got != (_want)) {
            _t.errorf(("shl(%v, %v)\n\tgot  %s\n\twant %s" : GoString), Go.toInterface(Go.asInterface(_z)), Go.toInterface((192 : GoInt)), Go.toInterface(_got), Go.toInterface(_want));
        };
    }
function benchmarkAddVW(_b:Ref<stdgo.testing.Testing.B>):Void {
        for (__0 => _n in _benchSizes) {
            if (_isRaceBuilder && (_n > (1000 : GoInt))) {
                continue;
            };
            var _x = _rndV(_n);
            var _y:stdgo.math.big.Big.Word = _rndW();
            var _z = new Slice<stdgo.math.big.Big.Word>((_n : GoInt).toBasic(), 0, ...[for (i in 0 ... (_n : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
            _b.run(stdgo.fmt.Fmt.sprint(Go.toInterface(_n)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                _b.setBytes((_n * (4 : GoInt) : GoInt64));
                {
                    var _i:GoInt = (0 : GoInt);
                    Go.cfor(_i < _b.n, _i++, {
                        _addVW(_z, _x, _y);
                    });
                };
            });
        };
    }
/**
    // Benchmarking addVW using vector of maximum uint to force carry flag set
**/
function benchmarkAddVWext(_b:Ref<stdgo.testing.Testing.B>):Void {
        for (__0 => _n in _benchSizes) {
            if (_isRaceBuilder && (_n > (1000 : GoInt))) {
                continue;
            };
            var _y:stdgo.math.big.Big.Word = (-1u32 : stdgo.math.big.Big.Word);
            var _x = _makeWordVec(_y, _n);
            var _z = new Slice<stdgo.math.big.Big.Word>((_n : GoInt).toBasic(), 0, ...[for (i in 0 ... (_n : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
            _b.run(stdgo.fmt.Fmt.sprint(Go.toInterface(_n)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                _b.setBytes((_n * (4 : GoInt) : GoInt64));
                {
                    var _i:GoInt = (0 : GoInt);
                    Go.cfor(_i < _b.n, _i++, {
                        _addVW(_z, _x, _y);
                    });
                };
            });
        };
    }
function benchmarkSubVW(_b:Ref<stdgo.testing.Testing.B>):Void {
        for (__0 => _n in _benchSizes) {
            if (_isRaceBuilder && (_n > (1000 : GoInt))) {
                continue;
            };
            var _x = _rndV(_n);
            var _y:stdgo.math.big.Big.Word = _rndW();
            var _z = new Slice<stdgo.math.big.Big.Word>((_n : GoInt).toBasic(), 0, ...[for (i in 0 ... (_n : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
            _b.run(stdgo.fmt.Fmt.sprint(Go.toInterface(_n)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                _b.setBytes((_n * (4 : GoInt) : GoInt64));
                {
                    var _i:GoInt = (0 : GoInt);
                    Go.cfor(_i < _b.n, _i++, {
                        _subVW(_z, _x, _y);
                    });
                };
            });
        };
    }
/**
    // Benchmarking subVW using vector of zero to force carry flag set
**/
function benchmarkSubVWext(_b:Ref<stdgo.testing.Testing.B>):Void {
        for (__0 => _n in _benchSizes) {
            if (_isRaceBuilder && (_n > (1000 : GoInt))) {
                continue;
            };
            var _x = _makeWordVec((0u32 : stdgo.math.big.Big.Word), _n);
            var _y:stdgo.math.big.Big.Word = ((1u32 : stdgo.math.big.Big.Word) : Word);
            var _z = new Slice<stdgo.math.big.Big.Word>((_n : GoInt).toBasic(), 0, ...[for (i in 0 ... (_n : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
            _b.run(stdgo.fmt.Fmt.sprint(Go.toInterface(_n)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                _b.setBytes((_n * (4 : GoInt) : GoInt64));
                {
                    var _i:GoInt = (0 : GoInt);
                    Go.cfor(_i < _b.n, _i++, {
                        _subVW(_z, _x, _y);
                    });
                };
            });
        };
    }
private function _testFunVWW(_t:Ref<stdgo.testing.Testing.T>, _msg:GoString, _f:T_funVWW, _a:T_argVWW):Void {
        var _z:stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat((_a._z.length : GoInt).toBasic(), 0, ...[for (i in 0 ... (_a._z.length : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
        var _c:stdgo.math.big.Big.Word = _f(_z, _a._x, _a._y, _a._r);
        for (_i => _zi in _z) {
            if (_zi != (_a._z[(_i : GoInt)])) {
                _t.errorf(("%s%+v\n\tgot z[%d] = %#x; want %#x" : GoString), Go.toInterface(_msg), Go.toInterface(_a), Go.toInterface(_i), Go.toInterface(_zi), Go.toInterface(_a._z[(_i : GoInt)]));
                break;
            };
        };
        if (_c != (_a._c)) {
            _t.errorf(("%s%+v\n\tgot c = %#x; want %#x" : GoString), Go.toInterface(_msg), Go.toInterface(_a), Go.toInterface(_c), Go.toInterface(_a._c));
        };
    }
private function _testFunWVW(_t:Ref<stdgo.testing.Testing.T>, _msg:GoString, _f:T_funWVW, _a:T_argWVW):Void {
        var _z:stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat((_a._z.length : GoInt).toBasic(), 0, ...[for (i in 0 ... (_a._z.length : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
        var _r:stdgo.math.big.Big.Word = _f(_z, _a._xn, _a._x, _a._y);
        for (_i => _zi in _z) {
            if (_zi != (_a._z[(_i : GoInt)])) {
                _t.errorf(("%s%+v\n\tgot z[%d] = %#x; want %#x" : GoString), Go.toInterface(_msg), Go.toInterface(_a), Go.toInterface(_i), Go.toInterface(_zi), Go.toInterface(_a._z[(_i : GoInt)]));
                break;
            };
        };
        if (_r != (_a._r)) {
            _t.errorf(("%s%+v\n\tgot r = %#x; want %#x" : GoString), Go.toInterface(_msg), Go.toInterface(_a), Go.toInterface(_r), Go.toInterface(_a._r));
        };
    }
function testFunVWW(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _a in _prodVWW) {
            var _arg:stdgo.math.big.Big.T_argVWW = _a?.__copy__();
            _testFunVWW(_t, ("mulAddVWW_g" : GoString), _mulAddVWW_g, _arg?.__copy__());
            _testFunVWW(_t, ("mulAddVWW" : GoString), _mulAddVWW, _arg?.__copy__());
            if ((_a._y != (0u32 : stdgo.math.big.Big.Word)) && (_a._r < _a._y)) {
                var _arg:stdgo.math.big.Big.T_argWVW = (new T_argWVW(_a._x, _a._c, _a._z, _a._y, _a._r) : T_argWVW);
                _testFunWVW(_t, ("divWVW" : GoString), _divWVW, _arg?.__copy__());
            };
        };
    }
function testMulWW(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _test in _mulWWTests) {
            var __tmp__ = _mulWW(_test._x, _test._y), _q:stdgo.math.big.Big.Word = __tmp__._0, _r:stdgo.math.big.Big.Word = __tmp__._1;
            if ((_q != _test._q) || (_r != _test._r)) {
                _t.errorf(("#%d got (%x, %x) want (%x, %x)" : GoString), Go.toInterface(_i), Go.toInterface(_q), Go.toInterface(_r), Go.toInterface(_test._q), Go.toInterface(_test._r));
            };
        };
    }
function testMulAddWWW(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _test in _mulAddWWWTests) {
            var __tmp__ = _mulAddWWW_g(_test._x, _test._y, _test._c), _q:stdgo.math.big.Big.Word = __tmp__._0, _r:stdgo.math.big.Big.Word = __tmp__._1;
            if ((_q != _test._q) || (_r != _test._r)) {
                _t.errorf(("#%d got (%x, %x) want (%x, %x)" : GoString), Go.toInterface(_i), Go.toInterface(_q), Go.toInterface(_r), Go.toInterface(_test._q), Go.toInterface(_test._r));
            };
        };
    }
function testDivWW(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _i:GoInt = (0 : GoInt);
        for (_i => _test in _divWWTests) {
            var _rec:stdgo.math.big.Big.Word = _reciprocalWord(_test._y);
            var __tmp__ = _divWW(_test._x1, _test._x0, _test._y, _rec), _q:stdgo.math.big.Big.Word = __tmp__._0, _r:stdgo.math.big.Big.Word = __tmp__._1;
            if ((_q != _test._q) || (_r != _test._r)) {
                _t.errorf(("#%d got (%x, %x) want (%x, %x)" : GoString), Go.toInterface(_i), Go.toInterface(_q), Go.toInterface(_r), Go.toInterface(_test._q), Go.toInterface(_test._r));
            };
        };
        Go.cfor(_i < (65536 : GoInt), _i++, {
            var _x1:stdgo.math.big.Big.Word = _rndW();
            var _x0:stdgo.math.big.Big.Word = _rndW();
            var _y:stdgo.math.big.Big.Word = _rndW();
            if (_x1 >= _y) {
                continue;
            };
            var _rec:stdgo.math.big.Big.Word = _reciprocalWord(_y);
            var __tmp__ = _divWW(_x1, _x0, _y, _rec), _qGot:stdgo.math.big.Big.Word = __tmp__._0, _rGot:stdgo.math.big.Big.Word = __tmp__._1;
            var __tmp__ = stdgo.math.bits.Bits.div((_x1 : GoUInt), (_x0 : GoUInt), (_y : GoUInt)), _qWant:GoUInt = __tmp__._0, _rWant:GoUInt = __tmp__._1;
            if (((_qGot : GoUInt) != _qWant) || ((_rGot : GoUInt) != _rWant)) {
                _t.errorf(("#%d got (%x, %x) want (%x, %x)" : GoString), Go.toInterface(_i), Go.toInterface(_qGot), Go.toInterface(_rGot), Go.toInterface(_qWant), Go.toInterface(_rWant));
            };
        });
    }
function benchmarkMulAddVWW(_b:Ref<stdgo.testing.Testing.B>):Void {
        for (__0 => _n in _benchSizes) {
            if (_isRaceBuilder && (_n > (1000 : GoInt))) {
                continue;
            };
            var _z = new Slice<stdgo.math.big.Big.Word>((_n + (1 : GoInt) : GoInt).toBasic(), 0, ...[for (i in 0 ... (_n + (1 : GoInt) : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
            var _x = _rndV(_n);
            var _y:stdgo.math.big.Big.Word = _rndW();
            var _r:stdgo.math.big.Big.Word = _rndW();
            _b.run(stdgo.fmt.Fmt.sprint(Go.toInterface(_n)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                _b.setBytes((_n * (32 : GoInt) : GoInt64));
                {
                    var _i:GoInt = (0 : GoInt);
                    Go.cfor(_i < _b.n, _i++, {
                        _mulAddVWW(_z, _x, _y, _r);
                    });
                };
            });
        };
    }
function benchmarkAddMulVVW(_b:Ref<stdgo.testing.Testing.B>):Void {
        for (__0 => _n in _benchSizes) {
            if (_isRaceBuilder && (_n > (1000 : GoInt))) {
                continue;
            };
            var _x = _rndV(_n);
            var _y:stdgo.math.big.Big.Word = _rndW();
            var _z = new Slice<stdgo.math.big.Big.Word>((_n : GoInt).toBasic(), 0, ...[for (i in 0 ... (_n : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
            _b.run(stdgo.fmt.Fmt.sprint(Go.toInterface(_n)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                _b.setBytes((_n * (32 : GoInt) : GoInt64));
                {
                    var _i:GoInt = (0 : GoInt);
                    Go.cfor(_i < _b.n, _i++, {
                        _addMulVVW(_z, _x, _y);
                    });
                };
            });
        };
    }
function benchmarkDivWVW(_b:Ref<stdgo.testing.Testing.B>):Void {
        for (__0 => _n in _benchSizes) {
            if (_isRaceBuilder && (_n > (1000 : GoInt))) {
                continue;
            };
            var _x = _rndV(_n);
            var _y:stdgo.math.big.Big.Word = _rndW();
            var _z = new Slice<stdgo.math.big.Big.Word>((_n : GoInt).toBasic(), 0, ...[for (i in 0 ... (_n : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
            _b.run(stdgo.fmt.Fmt.sprint(Go.toInterface(_n)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                _b.setBytes((_n * (32 : GoInt) : GoInt64));
                {
                    var _i:GoInt = (0 : GoInt);
                    Go.cfor(_i < _b.n, _i++, {
                        _divWVW(_z, (0u32 : stdgo.math.big.Big.Word), _x, _y);
                    });
                };
            });
        };
    }
function benchmarkNonZeroShifts(_b:Ref<stdgo.testing.Testing.B>):Void {
        for (__0 => _n in _benchSizes) {
            if (_isRaceBuilder && (_n > (1000 : GoInt))) {
                continue;
            };
            var _x = _rndV(_n);
            var _s:GoUInt = (stdgo.math.rand.Rand.int63n((30i64 : GoInt64)) : GoUInt) + (1u32 : GoUInt);
            var _z = new Slice<stdgo.math.big.Big.Word>((_n : GoInt).toBasic(), 0, ...[for (i in 0 ... (_n : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
            _b.run(stdgo.fmt.Fmt.sprint(Go.toInterface(_n)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                _b.setBytes((_n * (32 : GoInt) : GoInt64));
                _b.run(("shrVU" : GoString), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                    {
                        var _i:GoInt = (0 : GoInt);
                        Go.cfor(_i < _b.n, _i++, {
                            _shrVU(_z, _x, _s);
                        });
                    };
                });
                _b.run(("shlVU" : GoString), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                    {
                        var _i:GoInt = (0 : GoInt);
                        Go.cfor(_i < _b.n, _i++, {
                            _shlVU(_z, _x, _s);
                        });
                    };
                });
            });
        };
    }
function testMulBits(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_3>(0, 0, ({ _x : null, _y : null, _want : null } : T__struct_3), ({ _x : (new Slice<GoInt>(0, 0) : stdgo.math.big.Big.Bits), _y : (new Slice<GoInt>(0, 0) : stdgo.math.big.Big.Bits), _want : null } : T__struct_3), ({ _x : (new Slice<GoInt>(0, 0, (0 : GoInt)) : stdgo.math.big.Big.Bits), _y : (new Slice<GoInt>(0, 0, (0 : GoInt)) : stdgo.math.big.Big.Bits), _want : (new Slice<GoInt>(0, 0, (0 : GoInt)) : stdgo.math.big.Big.Bits) } : T__struct_3), ({ _x : (new Slice<GoInt>(0, 0, (0 : GoInt)) : stdgo.math.big.Big.Bits), _y : (new Slice<GoInt>(0, 0, (1 : GoInt)) : stdgo.math.big.Big.Bits), _want : (new Slice<GoInt>(0, 0, (1 : GoInt)) : stdgo.math.big.Big.Bits) } : T__struct_3), ({ _x : (new Slice<GoInt>(0, 0, (1 : GoInt)) : stdgo.math.big.Big.Bits), _y : (new Slice<GoInt>(0, 0, (1 : GoInt), (2 : GoInt), (3 : GoInt)) : stdgo.math.big.Big.Bits), _want : (new Slice<GoInt>(0, 0, (2 : GoInt), (3 : GoInt), (4 : GoInt)) : stdgo.math.big.Big.Bits) } : T__struct_3), ({ _x : (new Slice<GoInt>(0, 0, (-1 : GoInt)) : stdgo.math.big.Big.Bits), _y : (new Slice<GoInt>(0, 0, (1 : GoInt)) : stdgo.math.big.Big.Bits), _want : (new Slice<GoInt>(0, 0, (0 : GoInt)) : stdgo.math.big.Big.Bits) } : T__struct_3), ({ _x : (new Slice<GoInt>(0, 0, (-10 : GoInt), (-1 : GoInt), (0 : GoInt), (1 : GoInt), (10 : GoInt)) : stdgo.math.big.Big.Bits), _y : (new Slice<GoInt>(0, 0, (1 : GoInt), (2 : GoInt), (3 : GoInt)) : stdgo.math.big.Big.Bits), _want : (new Slice<GoInt>(
0,
0,
(-9 : GoInt),
(-8 : GoInt),
(-7 : GoInt),
(0 : GoInt),
(1 : GoInt),
(2 : GoInt),
(1 : GoInt),
(2 : GoInt),
(3 : GoInt),
(2 : GoInt),
(3 : GoInt),
(4 : GoInt),
(11 : GoInt),
(12 : GoInt),
(13 : GoInt)) : stdgo.math.big.Big.Bits) } : T__struct_3)) : Slice<T__struct_3>)) {
            var _got:GoString = stdgo.fmt.Fmt.sprintf(("%v" : GoString), Go.toInterface(Go.asInterface(_test._x._mul(_test._y))));
            var _want:GoString = stdgo.fmt.Fmt.sprintf(("%v" : GoString), Go.toInterface(Go.asInterface(_test._want)));
            if (_got != (_want)) {
                _t.errorf(("%v * %v = %s; want %s" : GoString), Go.toInterface(Go.asInterface(_test._x)), Go.toInterface(Go.asInterface(_test._y)), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function testNormBits(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_4>(0, 0, ({ _x : null, _want : null } : T__struct_4), ({ _x : (new Slice<GoInt>(0, 0) : stdgo.math.big.Big.Bits), _want : (new Slice<GoInt>(0, 0) : stdgo.math.big.Big.Bits) } : T__struct_4), ({ _x : (new Slice<GoInt>(0, 0, (0 : GoInt)) : stdgo.math.big.Big.Bits), _want : (new Slice<GoInt>(0, 0, (0 : GoInt)) : stdgo.math.big.Big.Bits) } : T__struct_4), ({ _x : (new Slice<GoInt>(0, 0, (0 : GoInt), (0 : GoInt)) : stdgo.math.big.Big.Bits), _want : (new Slice<GoInt>(0, 0, (1 : GoInt)) : stdgo.math.big.Big.Bits) } : T__struct_4), ({ _x : (new Slice<GoInt>(0, 0, (3 : GoInt), (1 : GoInt), (1 : GoInt)) : stdgo.math.big.Big.Bits), _want : (new Slice<GoInt>(0, 0, (2 : GoInt), (3 : GoInt)) : stdgo.math.big.Big.Bits) } : T__struct_4), ({ _x : (new Slice<GoInt>(0, 0, (10 : GoInt), (9 : GoInt), (8 : GoInt), (7 : GoInt), (6 : GoInt), (6 : GoInt)) : stdgo.math.big.Big.Bits), _want : (new Slice<GoInt>(0, 0, (11 : GoInt)) : stdgo.math.big.Big.Bits) } : T__struct_4)) : Slice<T__struct_4>)) {
            var _got:GoString = stdgo.fmt.Fmt.sprintf(("%v" : GoString), Go.toInterface(Go.asInterface(_test._x._norm())));
            var _want:GoString = stdgo.fmt.Fmt.sprintf(("%v" : GoString), Go.toInterface(Go.asInterface(_test._want)));
            if (_got != (_want)) {
                _t.errorf(("normBits(%v) = %s; want %s" : GoString), Go.toInterface(Go.asInterface(_test._x)), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function testFromBits(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_5>(
0,
0,
({ _bits : null, _want : ("0" : GoString) } : T__struct_5),
({ _bits : (new Slice<GoInt>(0, 0, (0 : GoInt)) : stdgo.math.big.Big.Bits), _want : ("0x.8p+1" : GoString) } : T__struct_5),
({ _bits : (new Slice<GoInt>(0, 0, (1 : GoInt)) : stdgo.math.big.Big.Bits), _want : ("0x.8p+2" : GoString) } : T__struct_5),
({ _bits : (new Slice<GoInt>(0, 0, (-1 : GoInt)) : stdgo.math.big.Big.Bits), _want : ("0x.8p+0" : GoString) } : T__struct_5),
({ _bits : (new Slice<GoInt>(0, 0, (63 : GoInt)) : stdgo.math.big.Big.Bits), _want : ("0x.8p+64" : GoString) } : T__struct_5),
({ _bits : (new Slice<GoInt>(0, 0, (33 : GoInt), (-30 : GoInt)) : stdgo.math.big.Big.Bits), _want : ("0x.8000000000000001p+34" : GoString) } : T__struct_5),
({ _bits : (new Slice<GoInt>(0, 0, (255 : GoInt), (0 : GoInt)) : stdgo.math.big.Big.Bits), _want : ("0x.8000000000000000000000000000000000000000000000000000000000000001p+256" : GoString) } : T__struct_5),
({ _bits : (new Slice<GoInt>(0, 0, (0 : GoInt), (0 : GoInt)) : stdgo.math.big.Big.Bits), _want : ("0x.8p+2" : GoString) } : T__struct_5),
({ _bits : (new Slice<GoInt>(0, 0, (0 : GoInt), (0 : GoInt), (0 : GoInt), (0 : GoInt)) : stdgo.math.big.Big.Bits), _want : ("0x.8p+3" : GoString) } : T__struct_5),
({ _bits : (new Slice<GoInt>(0, 0, (0 : GoInt), (1 : GoInt), (0 : GoInt)) : stdgo.math.big.Big.Bits), _want : ("0x.8p+3" : GoString) } : T__struct_5),
({ _bits : ((new Slice<GoInt>(0, 0, (2 : GoInt), (1 : GoInt), (0 : GoInt)) : stdgo.math.big.Big.Bits).__append__(...(new Slice<GoInt>(0, 0, (3 : GoInt), (1 : GoInt)) : stdgo.math.big.Big.Bits).__toArray__())), _want : ("0x.88p+5" : GoString) } : T__struct_5)) : Slice<T__struct_5>)) {
            var _f = _test._bits.float_();
            {
                var _got:GoString = _f.text((112 : GoUInt8), (0 : GoInt));
                if (_got != (_test._want)) {
                    _t.errorf(("setBits(%v) = %s; want %s" : GoString), Go.toInterface(Go.asInterface(_test._bits)), Go.toInterface(_got), Go.toInterface(_test._want));
                };
            };
        };
    }
function testCalibrate(_t:Ref<stdgo.testing.Testing.T>):Void {
        if (!_calibrate.value) {
            return;
        };
        _computeKaratsubaThresholds();
        var _minSqr:GoInt = _computeSqrThreshold((10 : GoInt), (30 : GoInt), (1 : GoInt), (3 : GoInt), ("mul(x, x)" : GoString), ("basicSqr(x)" : GoString));
        var _maxSqr:GoInt = _computeSqrThreshold((200 : GoInt), (500 : GoInt), (10 : GoInt), (3 : GoInt), ("basicSqr(x)" : GoString), ("karatsubaSqr(x)" : GoString));
        if (_minSqr != ((0 : GoInt))) {
            stdgo.fmt.Fmt.printf(("found basicSqrThreshold = %d\n" : GoString), Go.toInterface(_minSqr));
        } else {
            stdgo.fmt.Fmt.println(Go.toInterface(("no basicSqrThreshold found" : GoString)));
        };
        if (_maxSqr != ((0 : GoInt))) {
            stdgo.fmt.Fmt.printf(("found karatsubaSqrThreshold = %d\n" : GoString), Go.toInterface(_maxSqr));
        } else {
            stdgo.fmt.Fmt.println(Go.toInterface(("no karatsubaSqrThreshold found" : GoString)));
        };
    }
private function _karatsubaLoad(_b:Ref<stdgo.testing.Testing.B>):Void {
        benchmarkMul(_b);
    }
/**
    // measureKaratsuba returns the time to run a Karatsuba-relevant benchmark
    // given Karatsuba threshold th.
**/
private function _measureKaratsuba(_th:GoInt):stdgo.time.Time.Duration {
        {
            final __tmp__0 = _karatsubaThreshold;
            final __tmp__1 = _th;
            _th = __tmp__0;
            _karatsubaThreshold = __tmp__1;
        };
        var _res:stdgo.testing.Testing.BenchmarkResult = stdgo.testing.Testing.benchmark(_karatsubaLoad)?.__copy__();
        _karatsubaThreshold = _th;
        return (_res.nsPerOp() : stdgo.time.Time.Duration);
    }
private function _computeKaratsubaThresholds():Void {
        stdgo.fmt.Fmt.printf(("Multiplication times for varying Karatsuba thresholds\n" : GoString));
        stdgo.fmt.Fmt.printf(("(run repeatedly for good results)\n" : GoString));
        var tb:stdgo.time.Time.Duration = _measureKaratsuba((1000000000 : GoInt));
        stdgo.fmt.Fmt.printf(("Tb = %10s\n" : GoString), Go.toInterface(Go.asInterface(tb)));
        var _th:GoInt = (4 : GoInt);
        var _th1:GoInt = (-1 : GoInt);
        var _th2:GoInt = (-1 : GoInt);
        var _deltaOld:stdgo.time.Time.Duration = ((0 : GoInt64) : stdgo.time.Time.Duration);
        {
            var _count:GoInt = (-1 : GoInt);
            Go.cfor((_count != (0 : GoInt)) && (_th < (128 : GoInt)), _count--, {
                var tk:stdgo.time.Time.Duration = _measureKaratsuba(_th);
                var _delta:stdgo.time.Time.Duration = ((tb - tk) * (100i64 : stdgo.time.Time.Duration)) / tb;
                stdgo.fmt.Fmt.printf(("th = %3d  Tk = %10s  %4d%%" : GoString), Go.toInterface(_th), Go.toInterface(Go.asInterface(tk)), Go.toInterface(Go.asInterface(_delta)));
                if ((tk < tb) && (_th1 < (0 : GoInt))) {
                    _th1 = _th;
                    stdgo.fmt.Fmt.print(Go.toInterface(("  break-even point" : GoString)));
                };
                if ((((0i64 : stdgo.time.Time.Duration) < _delta) && (_delta < _deltaOld)) && (_th2 < (0 : GoInt))) {
                    _th2 = _th;
                    stdgo.fmt.Fmt.print(Go.toInterface(("  diminishing return" : GoString)));
                };
                _deltaOld = _delta;
                stdgo.fmt.Fmt.println();
                if (((_th1 >= (0 : GoInt)) && (_th2 >= (0 : GoInt))) && (_count < (0 : GoInt))) {
                    _count = (10 : GoInt);
                };
                _th++;
            });
        };
    }
private function _measureSqr(_words:GoInt, _nruns:GoInt, _mode:GoString):stdgo.time.Time.Duration {
        var __0:GoInt = _basicSqrThreshold, __1:GoInt = _karatsubaSqrThreshold, _initKaratsubaSqr:GoInt = __1, _initBasicSqr:GoInt = __0;
        {
            final __value__ = _mode;
            if (__value__ == (("mul(x, x)" : GoString))) {
                _basicSqrThreshold = _words + (1 : GoInt);
            } else if (__value__ == (("basicSqr(x)" : GoString))) {
                {
                    final __tmp__0 = _words - (1 : GoInt);
                    final __tmp__1 = _words + (1 : GoInt);
                    _basicSqrThreshold = __tmp__0;
                    _karatsubaSqrThreshold = __tmp__1;
                };
            } else if (__value__ == (("karatsubaSqr(x)" : GoString))) {
                _karatsubaSqrThreshold = _words - (1 : GoInt);
            };
        };
        var _testval:GoInt64 = (0 : GoInt64);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _nruns, _i++, {
                var _res:stdgo.testing.Testing.BenchmarkResult = stdgo.testing.Testing.benchmark(function(_b:Ref<stdgo.testing.Testing.B>):Void {
                    _benchmarkNatSqr(_b, _words);
                })?.__copy__();
                _testval = _testval + (_res.nsPerOp());
            });
        };
        _testval = _testval / ((_nruns : GoInt64));
        {
            final __tmp__0 = _initBasicSqr;
            final __tmp__1 = _initKaratsubaSqr;
            _basicSqrThreshold = __tmp__0;
            _karatsubaSqrThreshold = __tmp__1;
        };
        return (_testval : stdgo.time.Time.Duration);
    }
private function _computeSqrThreshold(_from:GoInt, _to:GoInt, _step:GoInt, _nruns:GoInt, _lower:GoString, _upper:GoString):GoInt {
        stdgo.fmt.Fmt.printf(("Calibrating threshold between %s and %s\n" : GoString), Go.toInterface(_lower), Go.toInterface(_upper));
        stdgo.fmt.Fmt.printf(("Looking for a timing difference for x between %d - %d words by %d step\n" : GoString), Go.toInterface(_from), Go.toInterface(_to), Go.toInterface(_step));
        var _initPos:Bool = false;
        var _threshold:GoInt = (0 : GoInt);
        {
            var _i:GoInt = _from;
            Go.cfor(_i <= _to, _i = _i + (_step), {
                var _baseline:stdgo.time.Time.Duration = _measureSqr(_i, _nruns, _lower);
                var _testval:stdgo.time.Time.Duration = _measureSqr(_i, _nruns, _upper);
                var _pos:Bool = _baseline > _testval;
                var _delta:stdgo.time.Time.Duration = _baseline - _testval;
                var _percent:stdgo.time.Time.Duration = (_delta * (100i64 : stdgo.time.Time.Duration)) / _baseline;
                stdgo.fmt.Fmt.printf(("words = %3d deltaT = %10s (%4d%%) is %s better: %v" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface(_delta)), Go.toInterface(Go.asInterface(_percent)), Go.toInterface(_upper), Go.toInterface(_pos));
                if (_i == (_from)) {
                    _initPos = _pos;
                };
                if ((_threshold == (0 : GoInt)) && (_pos != _initPos)) {
                    _threshold = _i;
                    stdgo.fmt.Fmt.printf(("  threshold  found" : GoString));
                };
                stdgo.fmt.Fmt.println();
            });
        };
        if (_threshold != ((0 : GoInt))) {
            stdgo.fmt.Fmt.printf(("Found threshold = %d between %d - %d\n" : GoString), Go.toInterface(_threshold), Go.toInterface(_from), Go.toInterface(_to));
        } else {
            stdgo.fmt.Fmt.printf(("Found NO threshold between %d - %d\n" : GoString), Go.toInterface(_from), Go.toInterface(_to));
        };
        return _threshold;
    }
/**
    // shr implements x >> s, for s <= maxShift.
**/
private function _shr(_x:Ref<T_decimal>, _s:GoUInt):Void {
        var _r:GoInt = (0 : GoInt);
        var _n:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        while (((_n >> _s) == (0u32 : stdgo.math.big.Big.Word)) && (_r < _x._mant.length)) {
            var _ch:stdgo.math.big.Big.Word = (_x._mant[(_r : GoInt)] : Word);
            _r++;
            _n = ((_n * (10u32 : stdgo.math.big.Big.Word)) + _ch) - (48u32 : stdgo.math.big.Big.Word);
        };
        if (_n == ((0u32 : stdgo.math.big.Big.Word))) {
            _x._mant = (_x._mant.__slice__(0, (0 : GoInt)) : Slice<GoUInt8>);
            return;
        };
        while (_n >> _s == ((0u32 : stdgo.math.big.Big.Word))) {
            _r++;
            _n = _n * ((10u32 : stdgo.math.big.Big.Word));
        };
        _x._exp = _x._exp + ((1 : GoInt) - _r);
        var _w:GoInt = (0 : GoInt);
        var _mask:stdgo.math.big.Big.Word = (((1u32 : stdgo.math.big.Big.Word) : Word) << _s) - (1u32 : stdgo.math.big.Big.Word);
        while (_r < (_x._mant.length)) {
            var _ch:stdgo.math.big.Big.Word = (_x._mant[(_r : GoInt)] : Word);
            _r++;
            var _d:stdgo.math.big.Big.Word = _n >> _s;
            _n = _n & (_mask);
            _x._mant[(_w : GoInt)] = (_d + (48u32 : stdgo.math.big.Big.Word) : GoByte);
            _w++;
            _n = ((_n * (10u32 : stdgo.math.big.Big.Word)) + _ch) - (48u32 : stdgo.math.big.Big.Word);
        };
        while ((_n > (0u32 : stdgo.math.big.Big.Word)) && (_w < _x._mant.length)) {
            var _d:stdgo.math.big.Big.Word = _n >> _s;
            _n = _n & (_mask);
            _x._mant[(_w : GoInt)] = (_d + (48u32 : stdgo.math.big.Big.Word) : GoByte);
            _w++;
            _n = _n * (10u32 : stdgo.math.big.Big.Word);
        };
        _x._mant = (_x._mant.__slice__(0, _w) : Slice<GoUInt8>);
        while (_n > (0u32 : stdgo.math.big.Big.Word)) {
            var _d:stdgo.math.big.Big.Word = _n >> _s;
            _n = _n & (_mask);
            _x._mant = _x._mant.__appendref__((_d + (48u32 : stdgo.math.big.Big.Word) : GoByte));
            _n = _n * (10u32 : stdgo.math.big.Big.Word);
        };
        _trim(_x);
    }
/**
    // appendZeros appends n 0 digits to buf and returns buf.
**/
private function _appendZeros(_buf:Slice<GoByte>, _n:GoInt):Slice<GoByte> {
        Go.cfor(_n > (0 : GoInt), _n--, {
            _buf = _buf.__appendref__((48 : GoUInt8));
        });
        return _buf;
    }
/**
    // shouldRoundUp reports if x should be rounded up
    // if shortened to n digits. n must be a valid index
    // for x.mant.
**/
private function _shouldRoundUp(_x:Ref<T_decimal>, _n:GoInt):Bool {
        if ((_x._mant[(_n : GoInt)] == (53 : GoUInt8)) && ((_n + (1 : GoInt)) == (_x._mant.length))) {
            return (_n > (0 : GoInt)) && (((_x._mant[(_n - (1 : GoInt) : GoInt)] - (48 : GoUInt8)) & (1 : GoUInt8)) != (0 : GoUInt8));
        };
        return _x._mant[(_n : GoInt)] >= (53 : GoUInt8);
    }
/**
    // trim cuts off any trailing zeros from x's mantissa;
    // they are meaningless for the value of x.
**/
private function _trim(_x:Ref<T_decimal>):Void {
        var _i:GoInt = (_x._mant.length);
        while ((_i > (0 : GoInt)) && (_x._mant[(_i - (1 : GoInt) : GoInt)] == (48 : GoUInt8))) {
            _i--;
        };
        _x._mant = (_x._mant.__slice__(0, _i) : Slice<GoUInt8>);
        if (_i == ((0 : GoInt))) {
            _x._exp = (0 : GoInt);
        };
    }
function testDecimalString(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_6>(0, 0, ({ _x : ({} : stdgo.math.big.Big.T_decimal), _want : ("0" : GoString) } : T__struct_6), ({ _x : (new T_decimal((null : Slice<GoUInt8>), (1000 : GoInt)) : T_decimal), _want : ("0" : GoString) } : T__struct_6), ({ _x : (new T_decimal((("12345" : GoString) : Slice<GoByte>), (0 : GoInt)) : T_decimal), _want : ("0.12345" : GoString) } : T__struct_6), ({ _x : (new T_decimal((("12345" : GoString) : Slice<GoByte>), (-3 : GoInt)) : T_decimal), _want : ("0.00012345" : GoString) } : T__struct_6), ({ _x : (new T_decimal((("12345" : GoString) : Slice<GoByte>), (3 : GoInt)) : T_decimal), _want : ("123.45" : GoString) } : T__struct_6), ({ _x : (new T_decimal((("12345" : GoString) : Slice<GoByte>), (10 : GoInt)) : T_decimal), _want : ("1234500000" : GoString) } : T__struct_6)) : Slice<T__struct_6>)) {
            {
                var _got:GoString = (_test._x.string() : GoString);
                if (_got != (_test._want)) {
                    _t.errorf(("%v == %s; want %s" : GoString), Go.toInterface(Go.asInterface(_test._x)), Go.toInterface(_got), Go.toInterface(_test._want));
                };
            };
        };
    }
function testDecimalInit(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_7>(
0,
0,
({ _x : (0u32 : stdgo.math.big.Big.Word), _shift : (0 : GoInt), _want : ("0" : GoString) } : T__struct_7),
({ _x : (0u32 : stdgo.math.big.Big.Word), _shift : (-100 : GoInt), _want : ("0" : GoString) } : T__struct_7),
({ _x : (0u32 : stdgo.math.big.Big.Word), _shift : (100 : GoInt), _want : ("0" : GoString) } : T__struct_7),
({ _x : (1u32 : stdgo.math.big.Big.Word), _shift : (0 : GoInt), _want : ("1" : GoString) } : T__struct_7),
({ _x : (1u32 : stdgo.math.big.Big.Word), _shift : (10 : GoInt), _want : ("1024" : GoString) } : T__struct_7),
({ _x : (1u32 : stdgo.math.big.Big.Word), _shift : (100 : GoInt), _want : ("1267650600228229401496703205376" : GoString) } : T__struct_7),
({ _x : (1u32 : stdgo.math.big.Big.Word), _shift : (-100 : GoInt), _want : ("0.0000000000000000000000000000007888609052210118054117285652827862296732064351090230047702789306640625" : GoString) } : T__struct_7),
({ _x : (12345678u32 : stdgo.math.big.Big.Word), _shift : (8 : GoInt), _want : ("3160493568" : GoString) } : T__struct_7),
({ _x : (12345678u32 : stdgo.math.big.Big.Word), _shift : (-8 : GoInt), _want : ("48225.3046875" : GoString) } : T__struct_7),
({ _x : (195312u32 : stdgo.math.big.Big.Word), _shift : (9 : GoInt), _want : ("99999744" : GoString) } : T__struct_7),
({ _x : (1953125u32 : stdgo.math.big.Big.Word), _shift : (9 : GoInt), _want : ("1000000000" : GoString) } : T__struct_7)) : Slice<T__struct_7>)) {
            var _d:T_decimal = ({} : stdgo.math.big.Big.T_decimal);
            _d._init((new Slice<stdgo.math.big.Big.Word>(0, 0, _test._x) : stdgo.math.big.Big.T_nat)._norm(), _test._shift);
            {
                var _got:GoString = (_d.string() : GoString);
                if (_got != (_test._want)) {
                    _t.errorf(("%d << %d == %s; want %s" : GoString), Go.toInterface(_test._x), Go.toInterface(_test._shift), Go.toInterface(_got), Go.toInterface(_test._want));
                };
            };
        };
    }
function testDecimalRounding(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_8>(
0,
0,
({ _x : (0i64 : GoUInt64), _n : (0 : GoInt), _down : ("0" : GoString), _even : ("0" : GoString), _up : ("0" : GoString) } : T__struct_8),
({ _x : (0i64 : GoUInt64), _n : (1 : GoInt), _down : ("0" : GoString), _even : ("0" : GoString), _up : ("0" : GoString) } : T__struct_8),
({ _x : (1i64 : GoUInt64), _n : (0 : GoInt), _down : ("0" : GoString), _even : ("0" : GoString), _up : ("10" : GoString) } : T__struct_8),
({ _x : (5i64 : GoUInt64), _n : (0 : GoInt), _down : ("0" : GoString), _even : ("0" : GoString), _up : ("10" : GoString) } : T__struct_8),
({ _x : (9i64 : GoUInt64), _n : (0 : GoInt), _down : ("0" : GoString), _even : ("10" : GoString), _up : ("10" : GoString) } : T__struct_8),
({ _x : (15i64 : GoUInt64), _n : (1 : GoInt), _down : ("10" : GoString), _even : ("20" : GoString), _up : ("20" : GoString) } : T__struct_8),
({ _x : (45i64 : GoUInt64), _n : (1 : GoInt), _down : ("40" : GoString), _even : ("40" : GoString), _up : ("50" : GoString) } : T__struct_8),
({ _x : (95i64 : GoUInt64), _n : (1 : GoInt), _down : ("90" : GoString), _even : ("100" : GoString), _up : ("100" : GoString) } : T__struct_8),
({ _x : (12344999i64 : GoUInt64), _n : (4 : GoInt), _down : ("12340000" : GoString), _even : ("12340000" : GoString), _up : ("12350000" : GoString) } : T__struct_8),
({ _x : (12345000i64 : GoUInt64), _n : (4 : GoInt), _down : ("12340000" : GoString), _even : ("12340000" : GoString), _up : ("12350000" : GoString) } : T__struct_8),
({ _x : (12345001i64 : GoUInt64), _n : (4 : GoInt), _down : ("12340000" : GoString), _even : ("12350000" : GoString), _up : ("12350000" : GoString) } : T__struct_8),
({ _x : (23454999i64 : GoUInt64), _n : (4 : GoInt), _down : ("23450000" : GoString), _even : ("23450000" : GoString), _up : ("23460000" : GoString) } : T__struct_8),
({ _x : (23455000i64 : GoUInt64), _n : (4 : GoInt), _down : ("23450000" : GoString), _even : ("23460000" : GoString), _up : ("23460000" : GoString) } : T__struct_8),
({ _x : (23455001i64 : GoUInt64), _n : (4 : GoInt), _down : ("23450000" : GoString), _even : ("23460000" : GoString), _up : ("23460000" : GoString) } : T__struct_8),
({ _x : (99994999i64 : GoUInt64), _n : (4 : GoInt), _down : ("99990000" : GoString), _even : ("99990000" : GoString), _up : ("100000000" : GoString) } : T__struct_8),
({ _x : (99995000i64 : GoUInt64), _n : (4 : GoInt), _down : ("99990000" : GoString), _even : ("100000000" : GoString), _up : ("100000000" : GoString) } : T__struct_8),
({ _x : (99999999i64 : GoUInt64), _n : (4 : GoInt), _down : ("99990000" : GoString), _even : ("100000000" : GoString), _up : ("100000000" : GoString) } : T__struct_8),
({ _x : (12994999i64 : GoUInt64), _n : (4 : GoInt), _down : ("12990000" : GoString), _even : ("12990000" : GoString), _up : ("13000000" : GoString) } : T__struct_8),
({ _x : (12995000i64 : GoUInt64), _n : (4 : GoInt), _down : ("12990000" : GoString), _even : ("13000000" : GoString), _up : ("13000000" : GoString) } : T__struct_8),
({ _x : (12999999i64 : GoUInt64), _n : (4 : GoInt), _down : ("12990000" : GoString), _even : ("13000000" : GoString), _up : ("13000000" : GoString) } : T__struct_8)) : Slice<T__struct_8>)) {
            var _x:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._setUint64(_test._x);
            var _d:T_decimal = ({} : stdgo.math.big.Big.T_decimal);
            _d._init(_x, (0 : GoInt));
            _d._roundDown(_test._n);
            {
                var _got:GoString = (_d.string() : GoString);
                if (_got != (_test._down)) {
                    _t.errorf(("roundDown(%d, %d) = %s; want %s" : GoString), Go.toInterface(_test._x), Go.toInterface(_test._n), Go.toInterface(_got), Go.toInterface(_test._down));
                };
            };
            _d._init(_x, (0 : GoInt));
            _d._round(_test._n);
            {
                var _got:GoString = (_d.string() : GoString);
                if (_got != (_test._even)) {
                    _t.errorf(("round(%d, %d) = %s; want %s" : GoString), Go.toInterface(_test._x), Go.toInterface(_test._n), Go.toInterface(_got), Go.toInterface(_test._even));
                };
            };
            _d._init(_x, (0 : GoInt));
            _d._roundUp(_test._n);
            {
                var _got:GoString = (_d.string() : GoString);
                if (_got != (_test._up)) {
                    _t.errorf(("roundUp(%d, %d) = %s; want %s" : GoString), Go.toInterface(_test._x), Go.toInterface(_test._n), Go.toInterface(_got), Go.toInterface(_test._up));
                };
            };
        };
    }
function benchmarkDecimalConversion(_b:Ref<stdgo.testing.Testing.B>):Void {
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                {
                    var _shift:GoInt = (-100 : GoInt);
                    Go.cfor(_shift <= (100 : GoInt), _shift++, {
                        var _d:T_decimal = ({} : stdgo.math.big.Big.T_decimal);
                        _d._init(_natOne, _shift);
                        _sink = (_d.string() : GoString);
                    });
                };
            });
        };
    }
function benchmarkFloatString(_b:Ref<stdgo.testing.Testing.B>):Void {
        var _x = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>);
        for (__0 => _prec in (new Slice<GoUInt>(0, 0, (100u32 : GoUInt), (1000u32 : GoUInt), (10000u32 : GoUInt), (100000u32 : GoUInt)) : Slice<GoUInt>)) {
            _x.setPrec(_prec).setRat(newRat((1i64 : GoInt64), (3i64 : GoInt64)));
            _b.run(stdgo.fmt.Fmt.sprintf(("%v" : GoString), Go.toInterface(_prec)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                _b.reportAllocs();
                {
                    var _i:GoInt = (0 : GoInt);
                    Go.cfor(_i < _b.n, _i++, {
                        _sink = (_x.string() : GoString);
                    });
                };
            });
        };
    }
/**
    // NewFloat allocates and returns a new Float set to x,
    // with precision 53 and rounding mode ToNearestEven.
    // NewFloat panics with ErrNaN if x is a NaN.
**/
function newFloat(_x:GoFloat64):Ref<Float_> {
        if (stdgo.math.Math.isNaN(_x)) {
            throw Go.toInterface(Go.asInterface((new ErrNaN(("NewFloat(NaN)" : GoString)) : ErrNaN)));
        };
        return (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setFloat64(_x);
    }
private function _makeAcc(_above:Bool):Accuracy {
        if (_above) {
            return (1 : stdgo.math.big.Big.Accuracy);
        };
        return (-1 : stdgo.math.big.Big.Accuracy);
    }
/**
    // fnorm normalizes mantissa m by shifting it to the left
    // such that the msb of the most-significant word (msw) is 1.
    // It returns the shift amount. It assumes that len(m) != 0.
**/
private function _fnorm(_m:T_nat):GoInt64 {
        if (false && ((_m.length == (0 : GoInt)) || (_m[((_m.length) - (1 : GoInt) : GoInt)] == (0u32 : stdgo.math.big.Big.Word)))) {
            throw Go.toInterface(("msw of mantissa is 0" : GoString));
        };
        var _s:GoUInt = _nlz(_m[((_m.length) - (1 : GoInt) : GoInt)]);
        if (_s > (0u32 : GoUInt)) {
            var _c:stdgo.math.big.Big.Word = _shlVU(_m, _m, _s);
            if (false && (_c != (0u32 : stdgo.math.big.Big.Word))) {
                throw Go.toInterface(("nlz or shlVU incorrect" : GoString));
            };
        };
        return (_s : GoInt64);
    }
/**
    // msb32 returns the 32 most significant bits of x.
**/
private function _msb32(_x:T_nat):GoUInt32 {
        var _i:GoInt = (_x.length) - (1 : GoInt);
        if (_i < (0 : GoInt)) {
            return (0u32 : GoUInt32);
        };
        if (false && ((_x[(_i : GoInt)] & (-2147483648u32 : stdgo.math.big.Big.Word)) == (0u32 : stdgo.math.big.Big.Word))) {
            throw Go.toInterface(("x not normalized" : GoString));
        };
        {
            final __value__ = (32 : GoInt);
            if (__value__ == ((32 : GoInt))) {
                return (_x[(_i : GoInt)] : GoUInt32);
            } else if (__value__ == ((64 : GoInt))) {
                return (_x[(_i : GoInt)] >> (32i64 : GoUInt64) : GoUInt32);
            };
        };
        throw Go.toInterface(("unreachable" : GoString));
    }
/**
    // msb64 returns the 64 most significant bits of x.
**/
private function _msb64(_x:T_nat):GoUInt64 {
        var _i:GoInt = (_x.length) - (1 : GoInt);
        if (_i < (0 : GoInt)) {
            return (0i64 : GoUInt64);
        };
        if (false && ((_x[(_i : GoInt)] & (-2147483648u32 : stdgo.math.big.Big.Word)) == (0u32 : stdgo.math.big.Big.Word))) {
            throw Go.toInterface(("x not normalized" : GoString));
        };
        {
            final __value__ = (32 : GoInt);
            if (__value__ == ((32 : GoInt))) {
                var _v:GoUInt64 = (_x[(_i : GoInt)] : GoUInt64) << (32i64 : GoUInt64);
                if (_i > (0 : GoInt)) {
                    _v = _v | ((_x[(_i - (1 : GoInt) : GoInt)] : GoUInt64));
                };
                return _v;
            } else if (__value__ == ((64 : GoInt))) {
                return (_x[(_i : GoInt)] : GoUInt64);
            };
        };
        throw Go.toInterface(("unreachable" : GoString));
    }
private function _validateBinaryOperands(_x:Ref<Float_>, _y:Ref<Float_>):Void {
        if (true) {
            throw Go.toInterface(("validateBinaryOperands called but debugFloat is not set" : GoString));
        };
        if ((_x._mant.length) == ((0 : GoInt))) {
            throw Go.toInterface(("empty mantissa for x" : GoString));
        };
        if ((_y._mant.length) == ((0 : GoInt))) {
            throw Go.toInterface(("empty mantissa for y" : GoString));
        };
    }
private function _umax32(_x:GoUInt32, _y:GoUInt32):GoUInt32 {
        if (_x > _y) {
            return _x;
        };
        return _y;
    }
function testFloatZeroValue(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _x:Float_ = ({} : stdgo.math.big.Big.Float_);
        {
            var _s:GoString = _x.text((102 : GoUInt8), (1 : GoInt));
            if (_s != (("0.0" : GoString))) {
                _t.errorf(("zero value = %s; want 0.0" : GoString), Go.toInterface(_s));
            };
        };
        {
            var _prec:GoUInt = _x.prec();
            if (_prec != ((0u32 : GoUInt))) {
                _t.errorf(("prec = %d; want 0" : GoString), Go.toInterface(_prec));
            };
        };
        var _make = function(_x:GoInt):Ref<Float_> {
            var _f:Float_ = ({} : stdgo.math.big.Big.Float_);
            if (_x != ((0 : GoInt))) {
                _f.setInt64((_x : GoInt64));
            };
            return (Go.setRef(_f) : Ref<stdgo.math.big.Big.Float_>);
        };
        for (__0 => _test in (new Slice<T__struct_9>(
0,
0,
({ _z : (0 : GoInt), _x : (0 : GoInt), _y : (0 : GoInt), _want : (0 : GoInt), _opname : (43 : GoInt32), _op : Float__static_extension.add } : T__struct_9),
({ _z : (0 : GoInt), _x : (1 : GoInt), _y : (2 : GoInt), _want : (3 : GoInt), _opname : (43 : GoInt32), _op : Float__static_extension.add } : T__struct_9),
({ _z : (1 : GoInt), _x : (2 : GoInt), _y : (0 : GoInt), _want : (2 : GoInt), _opname : (43 : GoInt32), _op : Float__static_extension.add } : T__struct_9),
({ _z : (2 : GoInt), _x : (0 : GoInt), _y : (1 : GoInt), _want : (1 : GoInt), _opname : (43 : GoInt32), _op : Float__static_extension.add } : T__struct_9),
({ _z : (0 : GoInt), _x : (0 : GoInt), _y : (0 : GoInt), _want : (0 : GoInt), _opname : (45 : GoInt32), _op : Float__static_extension.sub } : T__struct_9),
({ _z : (0 : GoInt), _x : (1 : GoInt), _y : (2 : GoInt), _want : (-1 : GoInt), _opname : (45 : GoInt32), _op : Float__static_extension.sub } : T__struct_9),
({ _z : (1 : GoInt), _x : (2 : GoInt), _y : (0 : GoInt), _want : (2 : GoInt), _opname : (45 : GoInt32), _op : Float__static_extension.sub } : T__struct_9),
({ _z : (2 : GoInt), _x : (0 : GoInt), _y : (1 : GoInt), _want : (-1 : GoInt), _opname : (45 : GoInt32), _op : Float__static_extension.sub } : T__struct_9),
({ _z : (0 : GoInt), _x : (0 : GoInt), _y : (0 : GoInt), _want : (0 : GoInt), _opname : (42 : GoInt32), _op : Float__static_extension.mul } : T__struct_9),
({ _z : (0 : GoInt), _x : (1 : GoInt), _y : (2 : GoInt), _want : (2 : GoInt), _opname : (42 : GoInt32), _op : Float__static_extension.mul } : T__struct_9),
({ _z : (1 : GoInt), _x : (2 : GoInt), _y : (0 : GoInt), _want : (0 : GoInt), _opname : (42 : GoInt32), _op : Float__static_extension.mul } : T__struct_9),
({ _z : (2 : GoInt), _x : (0 : GoInt), _y : (1 : GoInt), _want : (0 : GoInt), _opname : (42 : GoInt32), _op : Float__static_extension.mul } : T__struct_9),
({ _z : (0 : GoInt), _x : (2 : GoInt), _y : (1 : GoInt), _want : (2 : GoInt), _opname : (47 : GoInt32), _op : Float__static_extension.quo } : T__struct_9),
({ _z : (1 : GoInt), _x : (2 : GoInt), _y : (0 : GoInt), _want : (0 : GoInt), _opname : (47 : GoInt32), _op : Float__static_extension.quo } : T__struct_9),
({ _z : (2 : GoInt), _x : (0 : GoInt), _y : (1 : GoInt), _want : (0 : GoInt), _opname : (47 : GoInt32), _op : Float__static_extension.quo } : T__struct_9)) : Slice<T__struct_9>)) {
            var _z = _make(_test._z);
            _test._op(_z, _make(_test._x), _make(_test._y));
            var _got:GoInt = (0 : GoInt);
            if (!_z.isInf()) {
                _got = (_z._int64() : GoInt);
            };
            if (_got != (_test._want)) {
                _t.errorf(("%d %c %d = %d; want %d" : GoString), Go.toInterface(_test._x), Go.toInterface(_test._opname), Go.toInterface(_test._y), Go.toInterface(_got), Go.toInterface(_test._want));
            };
        };
    }
private function _makeFloat(_s:GoString):Ref<Float_> {
        var __tmp__ = parseFloat(_s, (0 : GoInt), (1000u32 : GoUInt), (0 : stdgo.math.big.Big.RoundingMode)), _x:Ref<stdgo.math.big.Big.Float_> = __tmp__._0, __0:GoInt = __tmp__._1, _err:Error = __tmp__._2;
        if (_err != null) {
            throw Go.toInterface(_err);
        };
        return _x;
    }
function testFloatSetPrec(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_10>(
0,
0,
({ _x : ("0" : GoString), _prec : (0u32 : GoUInt), _want : ("0" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_10),
({ _x : ("-0" : GoString), _prec : (0u32 : GoUInt), _want : ("-0" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_10),
({ _x : ("-Inf" : GoString), _prec : (0u32 : GoUInt), _want : ("-Inf" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_10),
({ _x : ("+Inf" : GoString), _prec : (0u32 : GoUInt), _want : ("+Inf" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_10),
({ _x : ("123" : GoString), _prec : (0u32 : GoUInt), _want : ("0" : GoString), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_10),
({ _x : ("-123" : GoString), _prec : (0u32 : GoUInt), _want : ("-0" : GoString), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_10),
({ _x : ("0" : GoString), _prec : (-1u32 : GoUInt), _want : ("0" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_10),
({ _x : ("-0" : GoString), _prec : (-1u32 : GoUInt), _want : ("-0" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_10),
({ _x : ("-Inf" : GoString), _prec : (-1u32 : GoUInt), _want : ("-Inf" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_10),
({ _x : ("+Inf" : GoString), _prec : (-1u32 : GoUInt), _want : ("+Inf" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_10),
({ _x : ("1.5" : GoString), _prec : (1u32 : GoUInt), _want : ("2" : GoString), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_10),
({ _x : ("-1.5" : GoString), _prec : (1u32 : GoUInt), _want : ("-2" : GoString), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_10),
({ _x : ("123" : GoString), _prec : (1000000u32 : GoUInt), _want : ("123" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_10),
({ _x : ("-123" : GoString), _prec : (1000000u32 : GoUInt), _want : ("-123" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_10)) : Slice<T__struct_10>)) {
            var _x = _makeFloat(_test._x).setPrec(_test._prec);
            var _prec:GoUInt = _test._prec;
            if (_prec > (-1u32 : GoUInt)) {
                _prec = (-1u32 : GoUInt);
            };
            {
                var _got:GoUInt = _x.prec();
                if (_got != (_prec)) {
                    _t.errorf(("%s.SetPrec(%d).Prec() == %d; want %d" : GoString), Go.toInterface(_test._x), Go.toInterface(_test._prec), Go.toInterface(_got), Go.toInterface(_prec));
                };
            };
            {
                var __0:GoString = (_x.string() : GoString), __1:stdgo.math.big.Big.Accuracy = _x.acc(), _acc:stdgo.math.big.Big.Accuracy = __1, _got:GoString = __0;
                if ((_got != _test._want) || (_acc != _test._acc)) {
                    _t.errorf(("%s.SetPrec(%d) = %s (%s); want %s (%s)" : GoString), Go.toInterface(_test._x), Go.toInterface(_test._prec), Go.toInterface(_got), Go.toInterface(Go.asInterface(_acc)), Go.toInterface(_test._want), Go.toInterface(Go.asInterface(_test._acc)));
                };
            };
        };
    }
function testFloatMinPrec(_t:Ref<stdgo.testing.Testing.T>):Void {
        {};
        for (__0 => _test in (new Slice<T__struct_11>(
0,
0,
({ _x : ("0" : GoString), _want : (0u32 : GoUInt) } : T__struct_11),
({ _x : ("-0" : GoString), _want : (0u32 : GoUInt) } : T__struct_11),
({ _x : ("+Inf" : GoString), _want : (0u32 : GoUInt) } : T__struct_11),
({ _x : ("-Inf" : GoString), _want : (0u32 : GoUInt) } : T__struct_11),
({ _x : ("1" : GoString), _want : (1u32 : GoUInt) } : T__struct_11),
({ _x : ("2" : GoString), _want : (1u32 : GoUInt) } : T__struct_11),
({ _x : ("3" : GoString), _want : (2u32 : GoUInt) } : T__struct_11),
({ _x : ("0x8001" : GoString), _want : (16u32 : GoUInt) } : T__struct_11),
({ _x : ("0x8001p-1000" : GoString), _want : (16u32 : GoUInt) } : T__struct_11),
({ _x : ("0x8001p+1000" : GoString), _want : (16u32 : GoUInt) } : T__struct_11),
({ _x : ("0.1" : GoString), _want : (100u32 : GoUInt) } : T__struct_11)) : Slice<T__struct_11>)) {
            var _x = _makeFloat(_test._x).setPrec((100u32 : GoUInt));
            {
                var _got:GoUInt = _x.minPrec();
                if (_got != (_test._want)) {
                    _t.errorf(("%s.MinPrec() = %d; want %d" : GoString), Go.toInterface(_test._x), Go.toInterface(_got), Go.toInterface(_test._want));
                };
            };
        };
    }
function testFloatSign(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_12>(0, 0, ({ _x : ("-Inf" : GoString), _s : (-1 : GoInt) } : T__struct_12), ({ _x : ("-1" : GoString), _s : (-1 : GoInt) } : T__struct_12), ({ _x : ("-0" : GoString), _s : (0 : GoInt) } : T__struct_12), ({ _x : ("+0" : GoString), _s : (0 : GoInt) } : T__struct_12), ({ _x : ("+1" : GoString), _s : (1 : GoInt) } : T__struct_12), ({ _x : ("+Inf" : GoString), _s : (1 : GoInt) } : T__struct_12)) : Slice<T__struct_12>)) {
            var _x = _makeFloat(_test._x);
            var _s:GoInt = _x.sign();
            if (_s != (_test._s)) {
                _t.errorf(("%s.Sign() = %d; want %d" : GoString), Go.toInterface(_test._x), Go.toInterface(_s), Go.toInterface(_test._s));
            };
        };
    }
/**
    // alike(x, y) is like x.Cmp(y) == 0 but also considers the sign of 0 (0 != -0).
**/
private function _alike(_x:Ref<Float_>, _y:Ref<Float_>):Bool {
        return (_x.cmp(_y) == (0 : GoInt)) && (_x.signbit() == _y.signbit());
    }
private function _alike32(_x:GoFloat32, _y:GoFloat32):Bool {
        return (_x == _y) && (stdgo.math.Math.signbit((_x : GoFloat64)) == stdgo.math.Math.signbit((_y : GoFloat64)));
    }
private function _alike64(_x:GoFloat64, _y:GoFloat64):Bool {
        return (_x == _y) && (stdgo.math.Math.signbit(_x) == stdgo.math.Math.signbit(_y));
    }
function testFloatMantExp(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_13>(
0,
0,
({ _x : ("0" : GoString), _mant : ("0" : GoString), _exp : (0 : GoInt) } : T__struct_13),
({ _x : ("+0" : GoString), _mant : ("0" : GoString), _exp : (0 : GoInt) } : T__struct_13),
({ _x : ("-0" : GoString), _mant : ("-0" : GoString), _exp : (0 : GoInt) } : T__struct_13),
({ _x : ("Inf" : GoString), _mant : ("+Inf" : GoString), _exp : (0 : GoInt) } : T__struct_13),
({ _x : ("+Inf" : GoString), _mant : ("+Inf" : GoString), _exp : (0 : GoInt) } : T__struct_13),
({ _x : ("-Inf" : GoString), _mant : ("-Inf" : GoString), _exp : (0 : GoInt) } : T__struct_13),
({ _x : ("1.5" : GoString), _mant : ("0.75" : GoString), _exp : (1 : GoInt) } : T__struct_13),
({ _x : ("1.024e3" : GoString), _mant : ("0.5" : GoString), _exp : (11 : GoInt) } : T__struct_13),
({ _x : ("-0.125" : GoString), _mant : ("-0.5" : GoString), _exp : (-2 : GoInt) } : T__struct_13)) : Slice<T__struct_13>)) {
            var _x = _makeFloat(_test._x);
            var _mant = _makeFloat(_test._mant);
            var _m = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>);
            var _e:GoInt = _x.mantExp(_m);
            if (!_alike(_m, _mant) || (_e != _test._exp)) {
                _t.errorf(("%s.MantExp() = %s, %d; want %s, %d" : GoString), Go.toInterface(_test._x), Go.toInterface(_m.text((103 : GoUInt8), (10 : GoInt))), Go.toInterface(_e), Go.toInterface(_test._mant), Go.toInterface(_test._exp));
            };
        };
    }
function testFloatMantExpAliasing(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _x = _makeFloat(("0.5p10" : GoString));
        {
            var _e:GoInt = _x.mantExp(_x);
            if (_e != ((10 : GoInt))) {
                _t.fatalf(("Float.MantExp aliasing error: got %d; want 10" : GoString), Go.toInterface(_e));
            };
        };
        {
            var _want = _makeFloat(("0.5" : GoString));
            if (!_alike(_x, _want)) {
                _t.fatalf(("Float.MantExp aliasing error: got %s; want %s" : GoString), Go.toInterface(_x.text((103 : GoUInt8), (10 : GoInt))), Go.toInterface(_want.text((103 : GoUInt8), (10 : GoInt))));
            };
        };
    }
function testFloatSetMantExp(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_14>(
0,
0,
({ _frac : ("0" : GoString), _exp : (0 : GoInt), _z : ("0" : GoString) } : T__struct_14),
({ _frac : ("+0" : GoString), _exp : (0 : GoInt), _z : ("0" : GoString) } : T__struct_14),
({ _frac : ("-0" : GoString), _exp : (0 : GoInt), _z : ("-0" : GoString) } : T__struct_14),
({ _frac : ("Inf" : GoString), _exp : (1234 : GoInt), _z : ("+Inf" : GoString) } : T__struct_14),
({ _frac : ("+Inf" : GoString), _exp : (-1234 : GoInt), _z : ("+Inf" : GoString) } : T__struct_14),
({ _frac : ("-Inf" : GoString), _exp : (-1234 : GoInt), _z : ("-Inf" : GoString) } : T__struct_14),
({ _frac : ("0" : GoString), _exp : (-2147483648 : GoInt), _z : ("0" : GoString) } : T__struct_14),
({ _frac : ("0.25" : GoString), _exp : (-2147483648 : GoInt), _z : ("+0" : GoString) } : T__struct_14),
({ _frac : ("-0.25" : GoString), _exp : (-2147483648 : GoInt), _z : ("-0" : GoString) } : T__struct_14),
({ _frac : ("1" : GoString), _exp : (2147483647 : GoInt), _z : ("+Inf" : GoString) } : T__struct_14),
({ _frac : ("2" : GoString), _exp : (2147483646 : GoInt), _z : ("+Inf" : GoString) } : T__struct_14),
({ _frac : ("0.75" : GoString), _exp : (1 : GoInt), _z : ("1.5" : GoString) } : T__struct_14),
({ _frac : ("0.5" : GoString), _exp : (11 : GoInt), _z : ("1024" : GoString) } : T__struct_14),
({ _frac : ("-0.5" : GoString), _exp : (-2 : GoInt), _z : ("-0.125" : GoString) } : T__struct_14),
({ _frac : ("32" : GoString), _exp : (5 : GoInt), _z : ("1024" : GoString) } : T__struct_14),
({ _frac : ("1024" : GoString), _exp : (-10 : GoInt), _z : ("1" : GoString) } : T__struct_14)) : Slice<T__struct_14>)) {
            var _frac = _makeFloat(_test._frac);
            var _want = _makeFloat(_test._z);
            var _z:Float_ = ({} : stdgo.math.big.Big.Float_);
            _z.setMantExp(_frac, _test._exp);
            if (!_alike((Go.setRef(_z) : Ref<stdgo.math.big.Big.Float_>), _want)) {
                _t.errorf(("SetMantExp(%s, %d) = %s; want %s" : GoString), Go.toInterface(_test._frac), Go.toInterface(_test._exp), Go.toInterface(_z.text((103 : GoUInt8), (10 : GoInt))), Go.toInterface(_test._z));
            };
            var _mant = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>);
            if (_z.setMantExp(_mant, _want.mantExp(_mant)).cmp(_want) != ((0 : GoInt))) {
                _t.errorf(("Inverse property not satisfied: got %s; want %s" : GoString), Go.toInterface(_z.text((103 : GoUInt8), (10 : GoInt))), Go.toInterface(_test._z));
            };
        };
    }
function testFloatPredicates(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_15>(0, 0, ({ _x : ("-Inf" : GoString), _sign : (-1 : GoInt), _signbit : true, _inf : true } : T__struct_15), ({ _x : ("-1" : GoString), _sign : (-1 : GoInt), _signbit : true, _inf : false } : T__struct_15), ({ _x : ("-0" : GoString), _sign : (0 : GoInt), _signbit : true, _inf : false } : T__struct_15), ({ _x : ("0" : GoString), _sign : (0 : GoInt), _signbit : false, _inf : false } : T__struct_15), ({ _x : ("1" : GoString), _sign : (1 : GoInt), _signbit : false, _inf : false } : T__struct_15), ({ _x : ("+Inf" : GoString), _sign : (1 : GoInt), _signbit : false, _inf : true } : T__struct_15)) : Slice<T__struct_15>)) {
            var _x = _makeFloat(_test._x);
            {
                var _got:Bool = _x.signbit();
                if (_got != (_test._signbit)) {
                    _t.errorf(("(%s).Signbit() = %v; want %v" : GoString), Go.toInterface(_test._x), Go.toInterface(_got), Go.toInterface(_test._signbit));
                };
            };
            {
                var _got:GoInt = _x.sign();
                if (_got != (_test._sign)) {
                    _t.errorf(("(%s).Sign() = %d; want %d" : GoString), Go.toInterface(_test._x), Go.toInterface(_got), Go.toInterface(_test._sign));
                };
            };
            {
                var _got:Bool = _x.isInf();
                if (_got != (_test._inf)) {
                    _t.errorf(("(%s).IsInf() = %v; want %v" : GoString), Go.toInterface(_test._x), Go.toInterface(_got), Go.toInterface(_test._inf));
                };
            };
        };
    }
function testFloatIsInt(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<GoString>(
0,
0,
("0 int" : GoString),
("-0 int" : GoString),
("1 int" : GoString),
("-1 int" : GoString),
("0.5" : GoString),
("1.23" : GoString),
("1.23e1" : GoString),
("1.23e2 int" : GoString),
("0.000000001e+8" : GoString),
("0.000000001e+9 int" : GoString),
("1.2345e200 int" : GoString),
("Inf" : GoString),
("+Inf" : GoString),
("-Inf" : GoString)) : Slice<GoString>)) {
            var _s:GoString = stdgo.strings.Strings.trimSuffix(_test, (" int" : GoString));
            var _want:Bool = _s != (_test);
            {
                var _got:Bool = _makeFloat(_s).isInt();
                if (_got != (_want)) {
                    _t.errorf(("%s.IsInt() == %t" : GoString), Go.toInterface(_s), Go.toInterface(_got));
                };
            };
        };
    }
private function _fromBinary(_s:GoString):GoInt64 {
        var __tmp__ = stdgo.strconv.Strconv.parseInt(_s, (2 : GoInt), (64 : GoInt)), _x:GoInt64 = __tmp__._0, _err:Error = __tmp__._1;
        if (_err != null) {
            throw Go.toInterface(_err);
        };
        return _x;
    }
private function _toBinary(_x:GoInt64):GoString {
        return stdgo.strconv.Strconv.formatInt(_x, (2 : GoInt));
    }
private function _testFloatRound(_t:Ref<stdgo.testing.Testing.T>, _x:GoInt64, _r:GoInt64, _prec:GoUInt, _mode:RoundingMode):Void {
        var _ok:Bool = false;
        {
            final __value__ = _mode;
            if (__value__ == ((0 : stdgo.math.big.Big.RoundingMode)) || __value__ == ((1 : stdgo.math.big.Big.RoundingMode))) {
                _ok = true;
            } else if (__value__ == ((2 : stdgo.math.big.Big.RoundingMode))) {
                if (_x < (0i64 : GoInt64)) {
                    _ok = _r >= _x;
                } else {
                    _ok = _r <= _x;
                };
            } else if (__value__ == ((3 : stdgo.math.big.Big.RoundingMode))) {
                if (_x < (0i64 : GoInt64)) {
                    _ok = _r <= _x;
                } else {
                    _ok = _r >= _x;
                };
            } else if (__value__ == ((4 : stdgo.math.big.Big.RoundingMode))) {
                _ok = _r <= _x;
            } else if (__value__ == ((5 : stdgo.math.big.Big.RoundingMode))) {
                _ok = _r >= _x;
            } else {
                throw Go.toInterface(("unreachable" : GoString));
            };
        };
        if (!_ok) {
            _t.fatalf(("incorrect test data for prec = %d, %s: x = %s, r = %s" : GoString), Go.toInterface(_prec), Go.toInterface(Go.asInterface(_mode)), Go.toInterface(_toBinary(_x)), Go.toInterface(_toBinary(_r)));
        };
        var _a:stdgo.math.big.Big.Accuracy = (0 : stdgo.math.big.Big.Accuracy);
        if (_r < _x) {
            _a = (-1 : stdgo.math.big.Big.Accuracy);
        } else if (_r > _x) {
            _a = (1 : stdgo.math.big.Big.Accuracy);
        };
        var _f = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setMode(_mode).setInt64(_x).setPrec(_prec);
        var _r1:GoInt64 = _f._int64();
        var _p1:GoUInt = _f.prec();
        var _a1:stdgo.math.big.Big.Accuracy = _f.acc();
        if (((_r1 != _r) || (_p1 != _prec)) || (_a1 != _a)) {
            _t.errorf(("round %s (%d bits, %s) incorrect: got %s (%d bits, %s); want %s (%d bits, %s)" : GoString), Go.toInterface(_toBinary(_x)), Go.toInterface(_prec), Go.toInterface(Go.asInterface(_mode)), Go.toInterface(_toBinary(_r1)), Go.toInterface(_p1), Go.toInterface(Go.asInterface(_a1)), Go.toInterface(_toBinary(_r)), Go.toInterface(_prec), Go.toInterface(Go.asInterface(_a)));
            return;
        };
        var _g = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setMode(_mode).setPrec(_prec).setInt64(_x);
        if (!_alike(_g, _f)) {
            _t.errorf(("round %s (%d bits, %s) not symmetric: got %s and %s; want %s" : GoString), Go.toInterface(_toBinary(_x)), Go.toInterface(_prec), Go.toInterface(Go.asInterface(_mode)), Go.toInterface(_toBinary(_g._int64())), Go.toInterface(_toBinary(_r1)), Go.toInterface(_toBinary(_r)));
            return;
        };
        var _h = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setMode(_mode).setPrec(_prec).set(_f);
        if (!_alike(_h, _f)) {
            _t.errorf(("round %s (%d bits, %s) not idempotent: got %s and %s; want %s" : GoString), Go.toInterface(_toBinary(_x)), Go.toInterface(_prec), Go.toInterface(Go.asInterface(_mode)), Go.toInterface(_toBinary(_h._int64())), Go.toInterface(_toBinary(_r1)), Go.toInterface(_toBinary(_r)));
            return;
        };
    }
/**
    // TestFloatRound tests basic rounding.
**/
function testFloatRound(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_16>(
0,
0,
({ _prec : (5u32 : GoUInt), _x : ("1000" : GoString), _zero : ("1000" : GoString), _neven : ("1000" : GoString), _naway : ("1000" : GoString), _away : ("1000" : GoString) } : T__struct_16),
({ _prec : (5u32 : GoUInt), _x : ("1001" : GoString), _zero : ("1001" : GoString), _neven : ("1001" : GoString), _naway : ("1001" : GoString), _away : ("1001" : GoString) } : T__struct_16),
({ _prec : (5u32 : GoUInt), _x : ("1010" : GoString), _zero : ("1010" : GoString), _neven : ("1010" : GoString), _naway : ("1010" : GoString), _away : ("1010" : GoString) } : T__struct_16),
({ _prec : (5u32 : GoUInt), _x : ("1011" : GoString), _zero : ("1011" : GoString), _neven : ("1011" : GoString), _naway : ("1011" : GoString), _away : ("1011" : GoString) } : T__struct_16),
({ _prec : (5u32 : GoUInt), _x : ("1100" : GoString), _zero : ("1100" : GoString), _neven : ("1100" : GoString), _naway : ("1100" : GoString), _away : ("1100" : GoString) } : T__struct_16),
({ _prec : (5u32 : GoUInt), _x : ("1101" : GoString), _zero : ("1101" : GoString), _neven : ("1101" : GoString), _naway : ("1101" : GoString), _away : ("1101" : GoString) } : T__struct_16),
({ _prec : (5u32 : GoUInt), _x : ("1110" : GoString), _zero : ("1110" : GoString), _neven : ("1110" : GoString), _naway : ("1110" : GoString), _away : ("1110" : GoString) } : T__struct_16),
({ _prec : (5u32 : GoUInt), _x : ("1111" : GoString), _zero : ("1111" : GoString), _neven : ("1111" : GoString), _naway : ("1111" : GoString), _away : ("1111" : GoString) } : T__struct_16),
({ _prec : (4u32 : GoUInt), _x : ("1000" : GoString), _zero : ("1000" : GoString), _neven : ("1000" : GoString), _naway : ("1000" : GoString), _away : ("1000" : GoString) } : T__struct_16),
({ _prec : (4u32 : GoUInt), _x : ("1001" : GoString), _zero : ("1001" : GoString), _neven : ("1001" : GoString), _naway : ("1001" : GoString), _away : ("1001" : GoString) } : T__struct_16),
({ _prec : (4u32 : GoUInt), _x : ("1010" : GoString), _zero : ("1010" : GoString), _neven : ("1010" : GoString), _naway : ("1010" : GoString), _away : ("1010" : GoString) } : T__struct_16),
({ _prec : (4u32 : GoUInt), _x : ("1011" : GoString), _zero : ("1011" : GoString), _neven : ("1011" : GoString), _naway : ("1011" : GoString), _away : ("1011" : GoString) } : T__struct_16),
({ _prec : (4u32 : GoUInt), _x : ("1100" : GoString), _zero : ("1100" : GoString), _neven : ("1100" : GoString), _naway : ("1100" : GoString), _away : ("1100" : GoString) } : T__struct_16),
({ _prec : (4u32 : GoUInt), _x : ("1101" : GoString), _zero : ("1101" : GoString), _neven : ("1101" : GoString), _naway : ("1101" : GoString), _away : ("1101" : GoString) } : T__struct_16),
({ _prec : (4u32 : GoUInt), _x : ("1110" : GoString), _zero : ("1110" : GoString), _neven : ("1110" : GoString), _naway : ("1110" : GoString), _away : ("1110" : GoString) } : T__struct_16),
({ _prec : (4u32 : GoUInt), _x : ("1111" : GoString), _zero : ("1111" : GoString), _neven : ("1111" : GoString), _naway : ("1111" : GoString), _away : ("1111" : GoString) } : T__struct_16),
({ _prec : (3u32 : GoUInt), _x : ("1000" : GoString), _zero : ("1000" : GoString), _neven : ("1000" : GoString), _naway : ("1000" : GoString), _away : ("1000" : GoString) } : T__struct_16),
({ _prec : (3u32 : GoUInt), _x : ("1001" : GoString), _zero : ("1000" : GoString), _neven : ("1000" : GoString), _naway : ("1010" : GoString), _away : ("1010" : GoString) } : T__struct_16),
({ _prec : (3u32 : GoUInt), _x : ("1010" : GoString), _zero : ("1010" : GoString), _neven : ("1010" : GoString), _naway : ("1010" : GoString), _away : ("1010" : GoString) } : T__struct_16),
({ _prec : (3u32 : GoUInt), _x : ("1011" : GoString), _zero : ("1010" : GoString), _neven : ("1100" : GoString), _naway : ("1100" : GoString), _away : ("1100" : GoString) } : T__struct_16),
({ _prec : (3u32 : GoUInt), _x : ("1100" : GoString), _zero : ("1100" : GoString), _neven : ("1100" : GoString), _naway : ("1100" : GoString), _away : ("1100" : GoString) } : T__struct_16),
({ _prec : (3u32 : GoUInt), _x : ("1101" : GoString), _zero : ("1100" : GoString), _neven : ("1100" : GoString), _naway : ("1110" : GoString), _away : ("1110" : GoString) } : T__struct_16),
({ _prec : (3u32 : GoUInt), _x : ("1110" : GoString), _zero : ("1110" : GoString), _neven : ("1110" : GoString), _naway : ("1110" : GoString), _away : ("1110" : GoString) } : T__struct_16),
({ _prec : (3u32 : GoUInt), _x : ("1111" : GoString), _zero : ("1110" : GoString), _neven : ("10000" : GoString), _naway : ("10000" : GoString), _away : ("10000" : GoString) } : T__struct_16),
({ _prec : (3u32 : GoUInt), _x : ("1000001" : GoString), _zero : ("1000000" : GoString), _neven : ("1000000" : GoString), _naway : ("1000000" : GoString), _away : ("1010000" : GoString) } : T__struct_16),
({ _prec : (3u32 : GoUInt), _x : ("1001001" : GoString), _zero : ("1000000" : GoString), _neven : ("1010000" : GoString), _naway : ("1010000" : GoString), _away : ("1010000" : GoString) } : T__struct_16),
({ _prec : (3u32 : GoUInt), _x : ("1010001" : GoString), _zero : ("1010000" : GoString), _neven : ("1010000" : GoString), _naway : ("1010000" : GoString), _away : ("1100000" : GoString) } : T__struct_16),
({ _prec : (3u32 : GoUInt), _x : ("1011001" : GoString), _zero : ("1010000" : GoString), _neven : ("1100000" : GoString), _naway : ("1100000" : GoString), _away : ("1100000" : GoString) } : T__struct_16),
({ _prec : (3u32 : GoUInt), _x : ("1100001" : GoString), _zero : ("1100000" : GoString), _neven : ("1100000" : GoString), _naway : ("1100000" : GoString), _away : ("1110000" : GoString) } : T__struct_16),
({ _prec : (3u32 : GoUInt), _x : ("1101001" : GoString), _zero : ("1100000" : GoString), _neven : ("1110000" : GoString), _naway : ("1110000" : GoString), _away : ("1110000" : GoString) } : T__struct_16),
({ _prec : (3u32 : GoUInt), _x : ("1110001" : GoString), _zero : ("1110000" : GoString), _neven : ("1110000" : GoString), _naway : ("1110000" : GoString), _away : ("10000000" : GoString) } : T__struct_16),
({ _prec : (3u32 : GoUInt), _x : ("1111001" : GoString), _zero : ("1110000" : GoString), _neven : ("10000000" : GoString), _naway : ("10000000" : GoString), _away : ("10000000" : GoString) } : T__struct_16),
({ _prec : (2u32 : GoUInt), _x : ("1000" : GoString), _zero : ("1000" : GoString), _neven : ("1000" : GoString), _naway : ("1000" : GoString), _away : ("1000" : GoString) } : T__struct_16),
({ _prec : (2u32 : GoUInt), _x : ("1001" : GoString), _zero : ("1000" : GoString), _neven : ("1000" : GoString), _naway : ("1000" : GoString), _away : ("1100" : GoString) } : T__struct_16),
({ _prec : (2u32 : GoUInt), _x : ("1010" : GoString), _zero : ("1000" : GoString), _neven : ("1000" : GoString), _naway : ("1100" : GoString), _away : ("1100" : GoString) } : T__struct_16),
({ _prec : (2u32 : GoUInt), _x : ("1011" : GoString), _zero : ("1000" : GoString), _neven : ("1100" : GoString), _naway : ("1100" : GoString), _away : ("1100" : GoString) } : T__struct_16),
({ _prec : (2u32 : GoUInt), _x : ("1100" : GoString), _zero : ("1100" : GoString), _neven : ("1100" : GoString), _naway : ("1100" : GoString), _away : ("1100" : GoString) } : T__struct_16),
({ _prec : (2u32 : GoUInt), _x : ("1101" : GoString), _zero : ("1100" : GoString), _neven : ("1100" : GoString), _naway : ("1100" : GoString), _away : ("10000" : GoString) } : T__struct_16),
({ _prec : (2u32 : GoUInt), _x : ("1110" : GoString), _zero : ("1100" : GoString), _neven : ("10000" : GoString), _naway : ("10000" : GoString), _away : ("10000" : GoString) } : T__struct_16),
({ _prec : (2u32 : GoUInt), _x : ("1111" : GoString), _zero : ("1100" : GoString), _neven : ("10000" : GoString), _naway : ("10000" : GoString), _away : ("10000" : GoString) } : T__struct_16),
({ _prec : (2u32 : GoUInt), _x : ("1000001" : GoString), _zero : ("1000000" : GoString), _neven : ("1000000" : GoString), _naway : ("1000000" : GoString), _away : ("1100000" : GoString) } : T__struct_16),
({ _prec : (2u32 : GoUInt), _x : ("1001001" : GoString), _zero : ("1000000" : GoString), _neven : ("1000000" : GoString), _naway : ("1000000" : GoString), _away : ("1100000" : GoString) } : T__struct_16),
({ _prec : (2u32 : GoUInt), _x : ("1010001" : GoString), _zero : ("1000000" : GoString), _neven : ("1100000" : GoString), _naway : ("1100000" : GoString), _away : ("1100000" : GoString) } : T__struct_16),
({ _prec : (2u32 : GoUInt), _x : ("1011001" : GoString), _zero : ("1000000" : GoString), _neven : ("1100000" : GoString), _naway : ("1100000" : GoString), _away : ("1100000" : GoString) } : T__struct_16),
({ _prec : (2u32 : GoUInt), _x : ("1100001" : GoString), _zero : ("1100000" : GoString), _neven : ("1100000" : GoString), _naway : ("1100000" : GoString), _away : ("10000000" : GoString) } : T__struct_16),
({ _prec : (2u32 : GoUInt), _x : ("1101001" : GoString), _zero : ("1100000" : GoString), _neven : ("1100000" : GoString), _naway : ("1100000" : GoString), _away : ("10000000" : GoString) } : T__struct_16),
({ _prec : (2u32 : GoUInt), _x : ("1110001" : GoString), _zero : ("1100000" : GoString), _neven : ("10000000" : GoString), _naway : ("10000000" : GoString), _away : ("10000000" : GoString) } : T__struct_16),
({ _prec : (2u32 : GoUInt), _x : ("1111001" : GoString), _zero : ("1100000" : GoString), _neven : ("10000000" : GoString), _naway : ("10000000" : GoString), _away : ("10000000" : GoString) } : T__struct_16),
({ _prec : (1u32 : GoUInt), _x : ("1000" : GoString), _zero : ("1000" : GoString), _neven : ("1000" : GoString), _naway : ("1000" : GoString), _away : ("1000" : GoString) } : T__struct_16),
({ _prec : (1u32 : GoUInt), _x : ("1001" : GoString), _zero : ("1000" : GoString), _neven : ("1000" : GoString), _naway : ("1000" : GoString), _away : ("10000" : GoString) } : T__struct_16),
({ _prec : (1u32 : GoUInt), _x : ("1010" : GoString), _zero : ("1000" : GoString), _neven : ("1000" : GoString), _naway : ("1000" : GoString), _away : ("10000" : GoString) } : T__struct_16),
({ _prec : (1u32 : GoUInt), _x : ("1011" : GoString), _zero : ("1000" : GoString), _neven : ("1000" : GoString), _naway : ("1000" : GoString), _away : ("10000" : GoString) } : T__struct_16),
({ _prec : (1u32 : GoUInt), _x : ("1100" : GoString), _zero : ("1000" : GoString), _neven : ("10000" : GoString), _naway : ("10000" : GoString), _away : ("10000" : GoString) } : T__struct_16),
({ _prec : (1u32 : GoUInt), _x : ("1101" : GoString), _zero : ("1000" : GoString), _neven : ("10000" : GoString), _naway : ("10000" : GoString), _away : ("10000" : GoString) } : T__struct_16),
({ _prec : (1u32 : GoUInt), _x : ("1110" : GoString), _zero : ("1000" : GoString), _neven : ("10000" : GoString), _naway : ("10000" : GoString), _away : ("10000" : GoString) } : T__struct_16),
({ _prec : (1u32 : GoUInt), _x : ("1111" : GoString), _zero : ("1000" : GoString), _neven : ("10000" : GoString), _naway : ("10000" : GoString), _away : ("10000" : GoString) } : T__struct_16),
({ _prec : (1u32 : GoUInt), _x : ("1000001" : GoString), _zero : ("1000000" : GoString), _neven : ("1000000" : GoString), _naway : ("1000000" : GoString), _away : ("10000000" : GoString) } : T__struct_16),
({ _prec : (1u32 : GoUInt), _x : ("1001001" : GoString), _zero : ("1000000" : GoString), _neven : ("1000000" : GoString), _naway : ("1000000" : GoString), _away : ("10000000" : GoString) } : T__struct_16),
({ _prec : (1u32 : GoUInt), _x : ("1010001" : GoString), _zero : ("1000000" : GoString), _neven : ("1000000" : GoString), _naway : ("1000000" : GoString), _away : ("10000000" : GoString) } : T__struct_16),
({ _prec : (1u32 : GoUInt), _x : ("1011001" : GoString), _zero : ("1000000" : GoString), _neven : ("1000000" : GoString), _naway : ("1000000" : GoString), _away : ("10000000" : GoString) } : T__struct_16),
({ _prec : (1u32 : GoUInt), _x : ("1100001" : GoString), _zero : ("1000000" : GoString), _neven : ("10000000" : GoString), _naway : ("10000000" : GoString), _away : ("10000000" : GoString) } : T__struct_16),
({ _prec : (1u32 : GoUInt), _x : ("1101001" : GoString), _zero : ("1000000" : GoString), _neven : ("10000000" : GoString), _naway : ("10000000" : GoString), _away : ("10000000" : GoString) } : T__struct_16),
({ _prec : (1u32 : GoUInt), _x : ("1110001" : GoString), _zero : ("1000000" : GoString), _neven : ("10000000" : GoString), _naway : ("10000000" : GoString), _away : ("10000000" : GoString) } : T__struct_16),
({ _prec : (1u32 : GoUInt), _x : ("1111001" : GoString), _zero : ("1000000" : GoString), _neven : ("10000000" : GoString), _naway : ("10000000" : GoString), _away : ("10000000" : GoString) } : T__struct_16)) : Slice<T__struct_16>)) {
            var _x:GoInt64 = _fromBinary(_test._x);
            var _z:GoInt64 = _fromBinary(_test._zero);
            var _e:GoInt64 = _fromBinary(_test._neven);
            var _n:GoInt64 = _fromBinary(_test._naway);
            var _a:GoInt64 = _fromBinary(_test._away);
            var _prec:GoUInt = _test._prec;
            _testFloatRound(_t, _x, _z, _prec, (2 : stdgo.math.big.Big.RoundingMode));
            _testFloatRound(_t, _x, _e, _prec, (0 : stdgo.math.big.Big.RoundingMode));
            _testFloatRound(_t, _x, _n, _prec, (1 : stdgo.math.big.Big.RoundingMode));
            _testFloatRound(_t, _x, _a, _prec, (3 : stdgo.math.big.Big.RoundingMode));
            _testFloatRound(_t, _x, _z, _prec, (4 : stdgo.math.big.Big.RoundingMode));
            _testFloatRound(_t, _x, _a, _prec, (5 : stdgo.math.big.Big.RoundingMode));
            _testFloatRound(_t, -_x, -_a, _prec, (4 : stdgo.math.big.Big.RoundingMode));
            _testFloatRound(_t, -_x, -_z, _prec, (5 : stdgo.math.big.Big.RoundingMode));
        };
    }
/**
    // TestFloatRound24 tests that rounding a float64 to 24 bits
    // matches IEEE-754 rounding to nearest when converting a
    // float64 to a float32 (excluding denormal numbers).
**/
function testFloatRound24(_t:Ref<stdgo.testing.Testing.T>):Void {
        {};
        {
            var _d:GoInt = (0 : GoInt);
            Go.cfor(_d <= (16 : GoInt), _d++, {
                var _x:GoFloat64 = ((67108848 : GoInt) + _d : GoFloat64);
                var _f = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec((24u32 : GoUInt)).setFloat64(_x);
                var __tmp__ = _f.float32(), _got:GoFloat32 = __tmp__._0, __0:stdgo.math.big.Big.Accuracy = __tmp__._1;
                var _want:GoFloat32 = (_x : GoFloat32);
                if (_got != (_want)) {
                    _t.errorf(("Round(%g, 24) = %g; want %g" : GoString), Go.toInterface(_x), Go.toInterface(_got), Go.toInterface(_want));
                };
            });
        };
    }
function testFloatSetUint64(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _want in (new Slice<GoUInt64>(0, 0, (0i64 : GoUInt64), (1i64 : GoUInt64), (2i64 : GoUInt64), (10i64 : GoUInt64), (100i64 : GoUInt64), (4294967295i64 : GoUInt64), (4294967296i64 : GoUInt64), (-1i64 : GoUInt64)) : Slice<GoUInt64>)) {
            var _f:Float_ = ({} : stdgo.math.big.Big.Float_);
            _f.setUint64(_want);
            {
                var _got:GoUInt64 = _f._uint64();
                if (_got != (_want)) {
                    _t.errorf(("got %#x (%s); want %#x" : GoString), Go.toInterface(_got), Go.toInterface(_f.text((112 : GoUInt8), (0 : GoInt))), Go.toInterface(_want));
                };
            };
        };
        {};
        {
            var _prec:GoUInt = (1u32 : GoUInt);
            Go.cfor(_prec <= (64u32 : GoUInt), _prec++, {
                var _f = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_prec).setMode((2 : stdgo.math.big.Big.RoundingMode)).setUint64((-8690466094656961759i64 : GoUInt64));
                var _got:GoUInt64 = _f._uint64();
                var _want:GoUInt64 = (-8690466094656961759i64 : GoUInt64) & ((((1i64 : GoUInt64) << ((64u32 : GoUInt) - _prec)) - (1i64 : GoUInt64)) ^ (-1i32 : GoInt));
                if (_got != (_want)) {
                    _t.errorf(("got %#x (%s); want %#x" : GoString), Go.toInterface(_got), Go.toInterface(_f.text((112 : GoUInt8), (0 : GoInt))), Go.toInterface(_want));
                };
            });
        };
    }
function testFloatSetInt64(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _want in (new Slice<GoInt64>(0, 0, (0i64 : GoInt64), (1i64 : GoInt64), (2i64 : GoInt64), (10i64 : GoInt64), (100i64 : GoInt64), (4294967295i64 : GoInt64), (4294967296i64 : GoInt64), (9223372036854775807i64 : GoInt64)) : Slice<GoInt64>)) {
            for (_i in 0 ... (new GoArray<GoInt>(...([].concat([for (i in 0 ... 2) (0 : GoInt)]))) : GoArray<GoInt>).length.toBasic()) {
                if (_i & (1 : GoInt) != ((0 : GoInt))) {
                    _want = -_want;
                };
                var _f:Float_ = ({} : stdgo.math.big.Big.Float_);
                _f.setInt64(_want);
                {
                    var _got:GoInt64 = _f._int64();
                    if (_got != (_want)) {
                        _t.errorf(("got %#x (%s); want %#x" : GoString), Go.toInterface(_got), Go.toInterface(_f.text((112 : GoUInt8), (0 : GoInt))), Go.toInterface(_want));
                    };
                };
            };
        };
        {};
        {
            var _prec:GoUInt = (1u32 : GoUInt);
            Go.cfor(_prec <= (63u32 : GoUInt), _prec++, {
                var _f = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_prec).setMode((2 : stdgo.math.big.Big.RoundingMode)).setInt64((8526495040805286416i64 : GoInt64));
                var _got:GoInt64 = _f._int64();
                var _want:GoInt64 = (8526495040805286416i64 : GoInt64) & ((((1i64 : GoInt64) << ((63u32 : GoUInt) - _prec)) - (1i64 : GoInt64)) ^ (-1i32 : GoInt));
                if (_got != (_want)) {
                    _t.errorf(("got %#x (%s); want %#x" : GoString), Go.toInterface(_got), Go.toInterface(_f.text((112 : GoUInt8), (0 : GoInt))), Go.toInterface(_want));
                };
            });
        };
    }
function testFloatSetFloat64(_t:Ref<stdgo.testing.Testing.T>):Void {
        var __deferstack__:Array<Void -> Void> = [];
        try {
            for (__0 => _want in (new Slice<GoFloat64>(
0,
0,
(0 : GoFloat64),
(1 : GoFloat64),
(2 : GoFloat64),
(12345 : GoFloat64),
(1e+10 : GoFloat64),
(1e+100 : GoFloat64),
(3.14159265e+10 : GoFloat64),
(2.718281828e-123 : GoFloat64),
(0.3333333333333333 : GoFloat64),
(3.4028234663852886e+38 : GoFloat64),
(1.7976931348623157e+308 : GoFloat64),
(1.401298464324817e-45 : GoFloat64),
(5e-324 : GoFloat64),
stdgo.math.Math.inf((-1 : GoInt)),
stdgo.math.Math.inf((0 : GoInt)),
-stdgo.math.Math.inf((1 : GoInt))) : Slice<GoFloat64>)) {
                for (_i in 0 ... (new GoArray<GoInt>(...([].concat([for (i in 0 ... 2) (0 : GoInt)]))) : GoArray<GoInt>).length.toBasic()) {
                    if (_i & (1 : GoInt) != ((0 : GoInt))) {
                        _want = -_want;
                    };
                    var _f:Float_ = ({} : stdgo.math.big.Big.Float_);
                    _f.setFloat64(_want);
                    {
                        var __tmp__ = _f.float64(), _got:GoFloat64 = __tmp__._0, _acc:stdgo.math.big.Big.Accuracy = __tmp__._1;
                        if ((_got != _want) || (_acc != (0 : stdgo.math.big.Big.Accuracy))) {
                            _t.errorf(("got %g (%s, %s); want %g (Exact)" : GoString), Go.toInterface(_got), Go.toInterface(_f.text((112 : GoUInt8), (0 : GoInt))), Go.toInterface(Go.asInterface(_acc)), Go.toInterface(_want));
                        };
                    };
                };
            };
            {};
            {
                var _prec:GoUInt = (1u32 : GoUInt);
                Go.cfor(_prec <= (52u32 : GoUInt), _prec++, {
                    var _f = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_prec).setMode((2 : stdgo.math.big.Big.RoundingMode)).setFloat64(((2381903803200024i64 : GoUInt64) : GoFloat64));
                    var __tmp__ = _f.float64(), _got:GoFloat64 = __tmp__._0, __1:stdgo.math.big.Big.Accuracy = __tmp__._1;
                    var _want:GoFloat64 = ((2381903803200024i64 : GoUInt64) & ((((1i64 : GoUInt64) << ((52u32 : GoUInt) - _prec)) - (1i64 : GoUInt64)) ^ (-1i32 : GoInt)) : GoFloat64);
                    if (_got != (_want)) {
                        _t.errorf(("got %g (%s); want %g" : GoString), Go.toInterface(_got), Go.toInterface(_f.text((112 : GoUInt8), (0 : GoInt))), Go.toInterface(_want));
                    };
                });
            };
            __deferstack__.unshift(() -> {
                var a = function():Void {
                    {
                        var __tmp__ = try {
                            { value : (Go.typeAssert(({
                                final r = Go.recover_exception;
                                Go.recover_exception = null;
                                r;
                            } : ErrNaN)) : ErrNaN), ok : true };
                        } catch(_) {
                            { value : ({} : stdgo.math.big.Big.ErrNaN), ok : false };
                        }, _p = __tmp__.value, _ok = __tmp__.ok;
                        if (!_ok) {
                            _t.errorf(("got %v; want ErrNaN panic" : GoString), Go.toInterface(Go.asInterface(_p)));
                        };
                    };
                };
                a();
            });
            var _f:Float_ = ({} : stdgo.math.big.Big.Float_);
            _f.setFloat64(stdgo.math.Math.naN());
            _t.errorf(("got %s; want ErrNaN panic" : GoString), Go.toInterface(_f.text((112 : GoUInt8), (0 : GoInt))));
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return;
        };
    }
function testFloatSetInt(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _want in (new Slice<GoString>(0, 0, ("0" : GoString), ("1" : GoString), ("-1" : GoString), ("1234567890" : GoString), ("123456789012345678901234567890" : GoString), ("123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890" : GoString)) : Slice<GoString>)) {
            var _x:Int_ = ({} : stdgo.math.big.Big.Int_);
            var __tmp__ = _x.setString(_want, (0 : GoInt)), __1:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _t.errorf(("invalid integer %s" : GoString), Go.toInterface(_want));
                continue;
            };
            var _n:GoInt = _x.bitLen();
            var _f:Float_ = ({} : stdgo.math.big.Big.Float_);
            _f.setInt((Go.setRef(_x) : Ref<stdgo.math.big.Big.Int_>));
            if (_n < (64 : GoInt)) {
                _n = (64 : GoInt);
            };
            {
                var _prec:GoUInt = _f.prec();
                if (_prec != ((_n : GoUInt))) {
                    _t.errorf(("got prec = %d; want %d" : GoString), Go.toInterface(_prec), Go.toInterface(_n));
                };
            };
            var _got:GoString = _f.text((103 : GoUInt8), (100 : GoInt));
            if (_got != (_want)) {
                _t.errorf(("got %s (%s); want %s" : GoString), Go.toInterface(_got), Go.toInterface(_f.text((112 : GoUInt8), (0 : GoInt))), Go.toInterface(_want));
            };
        };
    }
function testFloatSetRat(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _want in (new Slice<GoString>(0, 0, ("0" : GoString), ("1" : GoString), ("-1" : GoString), ("1234567890" : GoString), ("123456789012345678901234567890" : GoString), ("123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890" : GoString), ("1.2" : GoString), ("3.14159265" : GoString)) : Slice<GoString>)) {
            var _x:Rat = ({} : stdgo.math.big.Big.Rat);
            var __tmp__ = _x.setString(_want), __1:Ref<stdgo.math.big.Big.Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _t.errorf(("invalid fraction %s" : GoString), Go.toInterface(_want));
                continue;
            };
            var _n:GoInt = _max(_x.num().bitLen(), _x.denom().bitLen());
            var __0:Float_ = ({} : stdgo.math.big.Big.Float_), __1:Float_ = ({} : stdgo.math.big.Big.Float_), _f2:Float_ = __1, _f1:Float_ = __0;
            _f2.setPrec((1000u32 : GoUInt));
            _f1.setRat((Go.setRef(_x) : Ref<stdgo.math.big.Big.Rat>));
            _f2.setRat((Go.setRef(_x) : Ref<stdgo.math.big.Big.Rat>));
            if (_n < (64 : GoInt)) {
                _n = (64 : GoInt);
            };
            {
                var _prec:GoUInt = _f1.prec();
                if (_prec != ((_n : GoUInt))) {
                    _t.errorf(("got prec = %d; want %d" : GoString), Go.toInterface(_prec), Go.toInterface(_n));
                };
            };
            var _got:GoString = _f2.text((103 : GoUInt8), (100 : GoInt));
            if (_got != (_want)) {
                _t.errorf(("got %s (%s); want %s" : GoString), Go.toInterface(_got), Go.toInterface(_f2.text((112 : GoUInt8), (0 : GoInt))), Go.toInterface(_want));
            };
        };
    }
function testFloatSetInf(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _f:Float_ = ({} : stdgo.math.big.Big.Float_);
        for (__0 => _test in (new Slice<T__struct_17>(0, 0, ({ _signbit : false, _prec : (0u32 : GoUInt), _want : ("+Inf" : GoString) } : T__struct_17), ({ _signbit : true, _prec : (0u32 : GoUInt), _want : ("-Inf" : GoString) } : T__struct_17), ({ _signbit : false, _prec : (10u32 : GoUInt), _want : ("+Inf" : GoString) } : T__struct_17), ({ _signbit : true, _prec : (30u32 : GoUInt), _want : ("-Inf" : GoString) } : T__struct_17)) : Slice<T__struct_17>)) {
            var _x = _f.setPrec(_test._prec).setInf(_test._signbit);
            {
                var _got:GoString = (_x.string() : GoString);
                if ((_got != _test._want) || (_x.prec() != _test._prec)) {
                    _t.errorf(("SetInf(%v) = %s (prec = %d); want %s (prec = %d)" : GoString), Go.toInterface(_test._signbit), Go.toInterface(_got), Go.toInterface(_x.prec()), Go.toInterface(_test._want), Go.toInterface(_test._prec));
                };
            };
        };
    }
function testFloatUint64(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_18>(
0,
0,
({ _x : ("-Inf" : GoString), _out : (0i64 : GoUInt64), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_18),
({ _x : ("-1" : GoString), _out : (0i64 : GoUInt64), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_18),
({ _x : ("-1e-1000" : GoString), _out : (0i64 : GoUInt64), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_18),
({ _x : ("-0" : GoString), _out : (0i64 : GoUInt64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_18),
({ _x : ("0" : GoString), _out : (0i64 : GoUInt64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_18),
({ _x : ("1e-1000" : GoString), _out : (0i64 : GoUInt64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_18),
({ _x : ("1" : GoString), _out : (1i64 : GoUInt64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_18),
({ _x : ("1.000000000000000000001" : GoString), _out : (1i64 : GoUInt64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_18),
({ _x : ("12345.0" : GoString), _out : (12345i64 : GoUInt64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_18),
({ _x : ("12345.000000000000000000001" : GoString), _out : (12345i64 : GoUInt64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_18),
({ _x : ("18446744073709551615" : GoString), _out : (-1i64 : GoUInt64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_18),
({ _x : ("18446744073709551615.000000000000000000001" : GoString), _out : (-1i64 : GoUInt64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_18),
({ _x : ("18446744073709551616" : GoString), _out : (-1i64 : GoUInt64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_18),
({ _x : ("1e10000" : GoString), _out : (-1i64 : GoUInt64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_18),
({ _x : ("+Inf" : GoString), _out : (-1i64 : GoUInt64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_18)) : Slice<T__struct_18>)) {
            var _x = _makeFloat(_test._x);
            var __tmp__ = _x.uint64(), _out:GoUInt64 = __tmp__._0, _acc:stdgo.math.big.Big.Accuracy = __tmp__._1;
            if ((_out != _test._out) || (_acc != _test._acc)) {
                _t.errorf(("%s: got %d (%s); want %d (%s)" : GoString), Go.toInterface(_test._x), Go.toInterface(_out), Go.toInterface(Go.asInterface(_acc)), Go.toInterface(_test._out), Go.toInterface(Go.asInterface(_test._acc)));
            };
        };
    }
function testFloatInt64(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_19>(
0,
0,
({ _x : ("-Inf" : GoString), _out : (-9223372036854775808i64 : GoInt64), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("-1e10000" : GoString), _out : (-9223372036854775808i64 : GoInt64), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("-9223372036854775809" : GoString), _out : (-9223372036854775808i64 : GoInt64), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("-9223372036854775808.000000000000000000001" : GoString), _out : (-9223372036854775808i64 : GoInt64), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("-9223372036854775808" : GoString), _out : (-9223372036854775808i64 : GoInt64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("-9223372036854775807.000000000000000000001" : GoString), _out : (-9223372036854775807i64 : GoInt64), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("-9223372036854775807" : GoString), _out : (-9223372036854775807i64 : GoInt64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("-12345.000000000000000000001" : GoString), _out : (-12345i64 : GoInt64), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("-12345.0" : GoString), _out : (-12345i64 : GoInt64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("-1.000000000000000000001" : GoString), _out : (-1i64 : GoInt64), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("-1.5" : GoString), _out : (-1i64 : GoInt64), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("-1" : GoString), _out : (-1i64 : GoInt64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("-1e-1000" : GoString), _out : (0i64 : GoInt64), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("0" : GoString), _out : (0i64 : GoInt64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("1e-1000" : GoString), _out : (0i64 : GoInt64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("1" : GoString), _out : (1i64 : GoInt64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("1.000000000000000000001" : GoString), _out : (1i64 : GoInt64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("1.5" : GoString), _out : (1i64 : GoInt64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("12345.0" : GoString), _out : (12345i64 : GoInt64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("12345.000000000000000000001" : GoString), _out : (12345i64 : GoInt64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("9223372036854775807" : GoString), _out : (9223372036854775807i64 : GoInt64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("9223372036854775807.000000000000000000001" : GoString), _out : (9223372036854775807i64 : GoInt64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("9223372036854775808" : GoString), _out : (9223372036854775807i64 : GoInt64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("1e10000" : GoString), _out : (9223372036854775807i64 : GoInt64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_19),
({ _x : ("+Inf" : GoString), _out : (9223372036854775807i64 : GoInt64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_19)) : Slice<T__struct_19>)) {
            var _x = _makeFloat(_test._x);
            var __tmp__ = _x.int64(), _out:GoInt64 = __tmp__._0, _acc:stdgo.math.big.Big.Accuracy = __tmp__._1;
            if ((_out != _test._out) || (_acc != _test._acc)) {
                _t.errorf(("%s: got %d (%s); want %d (%s)" : GoString), Go.toInterface(_test._x), Go.toInterface(_out), Go.toInterface(Go.asInterface(_acc)), Go.toInterface(_test._out), Go.toInterface(Go.asInterface(_test._acc)));
            };
        };
    }
function testFloatFloat32(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_20>(
0,
0,
({ _x : ("0" : GoString), _out : (0 : GoFloat64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("1e-1000" : GoString), _out : (0 : GoFloat64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x0.000002p-127" : GoString), _out : (0 : GoFloat64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x.0000010p-126" : GoString), _out : (0 : GoFloat64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("1.401298464e-45" : GoString), _out : (1.401298464324817e-45 : GoFloat64), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x.ffffff8p-149" : GoString), _out : (1.401298464324817e-45 : GoFloat64), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x.0000018p-126" : GoString), _out : (1.401298464324817e-45 : GoFloat64), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x.0000020p-126" : GoString), _out : (1.401298464324817e-45 : GoFloat64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x.8p-148" : GoString), _out : (1.401298464324817e-45 : GoFloat64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("1p-149" : GoString), _out : (1.401298464324817e-45 : GoFloat64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x.fffffep-126" : GoString), _out : stdgo.math.Math.float32frombits((8388607u32 : GoUInt32)), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x0.0000001p-126" : GoString), _out : stdgo.math.Math.float32frombits((0u32 : GoUInt32)), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x0.0000008p-126" : GoString), _out : stdgo.math.Math.float32frombits((0u32 : GoUInt32)), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x0.0000010p-126" : GoString), _out : stdgo.math.Math.float32frombits((0u32 : GoUInt32)), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x0.0000011p-126" : GoString), _out : stdgo.math.Math.float32frombits((1u32 : GoUInt32)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x0.0000018p-126" : GoString), _out : stdgo.math.Math.float32frombits((1u32 : GoUInt32)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x1.0000000p-149" : GoString), _out : stdgo.math.Math.float32frombits((1u32 : GoUInt32)), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x0.0000020p-126" : GoString), _out : stdgo.math.Math.float32frombits((1u32 : GoUInt32)), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x0.fffffe0p-126" : GoString), _out : stdgo.math.Math.float32frombits((8388607u32 : GoUInt32)), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x1.0000000p-126" : GoString), _out : stdgo.math.Math.float32frombits((8388608u32 : GoUInt32)), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x0.8p-149" : GoString), _out : stdgo.math.Math.float32frombits((0u32 : GoUInt32)), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x0.9p-149" : GoString), _out : stdgo.math.Math.float32frombits((1u32 : GoUInt32)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x0.ap-149" : GoString), _out : stdgo.math.Math.float32frombits((1u32 : GoUInt32)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x0.bp-149" : GoString), _out : stdgo.math.Math.float32frombits((1u32 : GoUInt32)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x0.cp-149" : GoString), _out : stdgo.math.Math.float32frombits((1u32 : GoUInt32)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x1.0p-149" : GoString), _out : stdgo.math.Math.float32frombits((1u32 : GoUInt32)), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x1.7p-149" : GoString), _out : stdgo.math.Math.float32frombits((1u32 : GoUInt32)), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x1.8p-149" : GoString), _out : stdgo.math.Math.float32frombits((2u32 : GoUInt32)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x1.9p-149" : GoString), _out : stdgo.math.Math.float32frombits((2u32 : GoUInt32)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x2.0p-149" : GoString), _out : stdgo.math.Math.float32frombits((2u32 : GoUInt32)), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x2.8p-149" : GoString), _out : stdgo.math.Math.float32frombits((2u32 : GoUInt32)), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x2.9p-149" : GoString), _out : stdgo.math.Math.float32frombits((3u32 : GoUInt32)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x3.0p-149" : GoString), _out : stdgo.math.Math.float32frombits((3u32 : GoUInt32)), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x3.7p-149" : GoString), _out : stdgo.math.Math.float32frombits((3u32 : GoUInt32)), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x3.8p-149" : GoString), _out : stdgo.math.Math.float32frombits((4u32 : GoUInt32)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x4.0p-149" : GoString), _out : stdgo.math.Math.float32frombits((4u32 : GoUInt32)), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x4.8p-149" : GoString), _out : stdgo.math.Math.float32frombits((4u32 : GoUInt32)), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x4.9p-149" : GoString), _out : stdgo.math.Math.float32frombits((5u32 : GoUInt32)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x7.7p-149" : GoString), _out : stdgo.math.Math.float32frombits((7u32 : GoUInt32)), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x7.8p-149" : GoString), _out : stdgo.math.Math.float32frombits((8u32 : GoUInt32)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x7.9p-149" : GoString), _out : stdgo.math.Math.float32frombits((8u32 : GoUInt32)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x.ffffffp-126" : GoString), _out : stdgo.math.Math.float32frombits((8388608u32 : GoUInt32)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("1p-126" : GoString), _out : stdgo.math.Math.float32frombits((8388608u32 : GoUInt32)), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x1.fffffep-126" : GoString), _out : stdgo.math.Math.float32frombits((16777215u32 : GoUInt32)), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x1.ffffffp-126" : GoString), _out : stdgo.math.Math.float32frombits((16777216u32 : GoUInt32)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("1" : GoString), _out : (1 : GoFloat64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("1.000000000000000000001" : GoString), _out : (1 : GoFloat64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("12345.0" : GoString), _out : (12345 : GoFloat64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("12345.000000000000000000001" : GoString), _out : (12345 : GoFloat64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x1.fffffe0p127" : GoString), _out : (3.4028234663852886e+38 : GoFloat64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x1.fffffe8p127" : GoString), _out : (3.4028234663852886e+38 : GoFloat64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x1.ffffff0p127" : GoString), _out : (stdgo.math.Math.inf((1 : GoInt)) : GoFloat32), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x1p128" : GoString), _out : (stdgo.math.Math.inf((1 : GoInt)) : GoFloat32), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("1e10000" : GoString), _out : (stdgo.math.Math.inf((1 : GoInt)) : GoFloat32), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("0x1.ffffff0p2147483646" : GoString), _out : (stdgo.math.Math.inf((1 : GoInt)) : GoFloat32), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_20),
({ _x : ("Inf" : GoString), _out : (stdgo.math.Math.inf((1 : GoInt)) : GoFloat32), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_20)) : Slice<T__struct_20>)) {
            {
                var _i:GoInt = (0 : GoInt);
                Go.cfor(_i < (2 : GoInt), _i++, {
                    var __0:GoString = _test._x, __1:GoFloat32 = _test._out, __2:stdgo.math.big.Big.Accuracy = _test._acc, _tacc:stdgo.math.big.Big.Accuracy = __2, _tout:GoFloat32 = __1, _tx:GoString = __0;
                    if (_i != ((0 : GoInt))) {
                        _tx = ("-" : GoString) + _tx;
                        _tout = -_tout;
                        _tacc = -_tacc;
                    };
                    {
                        var __tmp__ = stdgo.strconv.Strconv.parseFloat(_tx, (32 : GoInt)), _f:GoFloat64 = __tmp__._0, _err:Error = __tmp__._1;
                        if ((_err == null) && !_alike32((_f : GoFloat32), _tout)) {
                            _t.errorf(("%s: got %g; want %g (incorrect test data)" : GoString), Go.toInterface(_tx), Go.toInterface(_f), Go.toInterface(_tout));
                        };
                    };
                    var _x = _makeFloat(_tx);
                    var __tmp__ = _x.float32(), _out:GoFloat32 = __tmp__._0, _acc:stdgo.math.big.Big.Accuracy = __tmp__._1;
                    if (!_alike32(_out, _tout) || (_acc != _tacc)) {
                        _t.errorf(("%s: got %g (%#08x, %s); want %g (%#08x, %s)" : GoString), Go.toInterface(_tx), Go.toInterface(_out), Go.toInterface(stdgo.math.Math.float32bits(_out)), Go.toInterface(Go.asInterface(_acc)), Go.toInterface(_test._out), Go.toInterface(stdgo.math.Math.float32bits(_test._out)), Go.toInterface(Go.asInterface(_tacc)));
                    };
                    var _x2:Float_ = ({} : stdgo.math.big.Big.Float_);
                    var __tmp__ = _x2.setFloat64((_out : GoFloat64)).float32(), _out2:GoFloat32 = __tmp__._0, _acc2:stdgo.math.big.Big.Accuracy = __tmp__._1;
                    if (!_alike32(_out2, _out) || (_acc2 != (0 : stdgo.math.big.Big.Accuracy))) {
                        _t.errorf(("idempotency test: got %g (%s); want %g (Exact)" : GoString), Go.toInterface(_out2), Go.toInterface(Go.asInterface(_acc2)), Go.toInterface(_out));
                    };
                });
            };
        };
    }
function testFloatFloat64(_t:Ref<stdgo.testing.Testing.T>):Void {
        {};
        for (__0 => _test in (new Slice<T__struct_21>(
0,
0,
({ _x : ("0" : GoString), _out : (0 : GoFloat64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("1e-1000" : GoString), _out : (0 : GoFloat64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x0.0000000000001p-1023" : GoString), _out : (0 : GoFloat64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x0.00000000000008p-1022" : GoString), _out : (0 : GoFloat64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x0.0000000000000cp-1022" : GoString), _out : (5e-324 : GoFloat64), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x0.00000000000010p-1022" : GoString), _out : (5e-324 : GoFloat64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x.8p-1073" : GoString), _out : (5e-324 : GoFloat64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("1p-1074" : GoString), _out : (5e-324 : GoFloat64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x.fffffffffffffp-1022" : GoString), _out : stdgo.math.Math.float64frombits((4503599627370495i64 : GoUInt64)), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x0.00000000000001p-1022" : GoString), _out : stdgo.math.Math.float64frombits((0i64 : GoUInt64)), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x0.00000000000004p-1022" : GoString), _out : stdgo.math.Math.float64frombits((0i64 : GoUInt64)), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x0.00000000000008p-1022" : GoString), _out : stdgo.math.Math.float64frombits((0i64 : GoUInt64)), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x0.00000000000009p-1022" : GoString), _out : stdgo.math.Math.float64frombits((1i64 : GoUInt64)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x0.0000000000000ap-1022" : GoString), _out : stdgo.math.Math.float64frombits((1i64 : GoUInt64)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x0.8p-1074" : GoString), _out : stdgo.math.Math.float64frombits((0i64 : GoUInt64)), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x0.9p-1074" : GoString), _out : stdgo.math.Math.float64frombits((1i64 : GoUInt64)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x0.ap-1074" : GoString), _out : stdgo.math.Math.float64frombits((1i64 : GoUInt64)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x0.bp-1074" : GoString), _out : stdgo.math.Math.float64frombits((1i64 : GoUInt64)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x0.cp-1074" : GoString), _out : stdgo.math.Math.float64frombits((1i64 : GoUInt64)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x1.0p-1074" : GoString), _out : stdgo.math.Math.float64frombits((1i64 : GoUInt64)), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x1.7p-1074" : GoString), _out : stdgo.math.Math.float64frombits((1i64 : GoUInt64)), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x1.8p-1074" : GoString), _out : stdgo.math.Math.float64frombits((2i64 : GoUInt64)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x1.9p-1074" : GoString), _out : stdgo.math.Math.float64frombits((2i64 : GoUInt64)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x2.0p-1074" : GoString), _out : stdgo.math.Math.float64frombits((2i64 : GoUInt64)), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x2.8p-1074" : GoString), _out : stdgo.math.Math.float64frombits((2i64 : GoUInt64)), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x2.9p-1074" : GoString), _out : stdgo.math.Math.float64frombits((3i64 : GoUInt64)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x3.0p-1074" : GoString), _out : stdgo.math.Math.float64frombits((3i64 : GoUInt64)), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x3.7p-1074" : GoString), _out : stdgo.math.Math.float64frombits((3i64 : GoUInt64)), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x3.8p-1074" : GoString), _out : stdgo.math.Math.float64frombits((4i64 : GoUInt64)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x4.0p-1074" : GoString), _out : stdgo.math.Math.float64frombits((4i64 : GoUInt64)), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x4.8p-1074" : GoString), _out : stdgo.math.Math.float64frombits((4i64 : GoUInt64)), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x4.9p-1074" : GoString), _out : stdgo.math.Math.float64frombits((5i64 : GoUInt64)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x.fffffffffffff8p-1022" : GoString), _out : stdgo.math.Math.float64frombits((4503599627370496i64 : GoUInt64)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("1p-1022" : GoString), _out : stdgo.math.Math.float64frombits((4503599627370496i64 : GoUInt64)), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("1" : GoString), _out : (1 : GoFloat64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("1.000000000000000000001" : GoString), _out : (1 : GoFloat64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("12345.0" : GoString), _out : (12345 : GoFloat64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("12345.000000000000000000001" : GoString), _out : (12345 : GoFloat64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x1.fffffffffffff0p1023" : GoString), _out : (1.7976931348623157e+308 : GoFloat64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x1.fffffffffffff4p1023" : GoString), _out : (1.7976931348623157e+308 : GoFloat64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x1.fffffffffffff8p1023" : GoString), _out : stdgo.math.Math.inf((1 : GoInt)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x1p1024" : GoString), _out : stdgo.math.Math.inf((1 : GoInt)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("1e10000" : GoString), _out : stdgo.math.Math.inf((1 : GoInt)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x1.fffffffffffff8p2147483646" : GoString), _out : stdgo.math.Math.inf((1 : GoInt)), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("Inf" : GoString), _out : stdgo.math.Math.inf((1 : GoInt)), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("0x.fffffffffffffp-1022" : GoString), _out : (2.225073858507201e-308 : GoFloat64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("4503599627370495p-1074" : GoString), _out : (2.225073858507201e-308 : GoFloat64), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("2.2250738585072011e-308" : GoString), _out : (2.225073858507201e-308 : GoFloat64), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_21),
({ _x : ("2.2250738585072012e-308" : GoString), _out : (2.2250738585072014e-308 : GoFloat64), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_21)) : Slice<T__struct_21>)) {
            {
                var _i:GoInt = (0 : GoInt);
                Go.cfor(_i < (2 : GoInt), _i++, {
                    var __0:GoString = _test._x, __1:GoFloat64 = _test._out, __2:stdgo.math.big.Big.Accuracy = _test._acc, _tacc:stdgo.math.big.Big.Accuracy = __2, _tout:GoFloat64 = __1, _tx:GoString = __0;
                    if (_i != ((0 : GoInt))) {
                        _tx = ("-" : GoString) + _tx;
                        _tout = -_tout;
                        _tacc = -_tacc;
                    };
                    {
                        var __tmp__ = stdgo.strconv.Strconv.parseFloat(_tx, (64 : GoInt)), _f:GoFloat64 = __tmp__._0, _err:Error = __tmp__._1;
                        if ((_err == null) && !_alike64(_f, _tout)) {
                            _t.errorf(("%s: got %g; want %g (incorrect test data)" : GoString), Go.toInterface(_tx), Go.toInterface(_f), Go.toInterface(_tout));
                        };
                    };
                    var _x = _makeFloat(_tx);
                    var __tmp__ = _x.float64(), _out:GoFloat64 = __tmp__._0, _acc:stdgo.math.big.Big.Accuracy = __tmp__._1;
                    if (!_alike64(_out, _tout) || (_acc != _tacc)) {
                        _t.errorf(("%s: got %g (%#016x, %s); want %g (%#016x, %s)" : GoString), Go.toInterface(_tx), Go.toInterface(_out), Go.toInterface(stdgo.math.Math.float64bits(_out)), Go.toInterface(Go.asInterface(_acc)), Go.toInterface(_test._out), Go.toInterface(stdgo.math.Math.float64bits(_test._out)), Go.toInterface(Go.asInterface(_tacc)));
                    };
                    var _x2:Float_ = ({} : stdgo.math.big.Big.Float_);
                    var __tmp__ = _x2.setFloat64(_out).float64(), _out2:GoFloat64 = __tmp__._0, _acc2:stdgo.math.big.Big.Accuracy = __tmp__._1;
                    if (!_alike64(_out2, _out) || (_acc2 != (0 : stdgo.math.big.Big.Accuracy))) {
                        _t.errorf(("idempotency test: got %g (%s); want %g (Exact)" : GoString), Go.toInterface(_out2), Go.toInterface(Go.asInterface(_acc2)), Go.toInterface(_out));
                    };
                });
            };
        };
    }
function testFloatInt(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_22>(
0,
0,
({ _x : ("0" : GoString), _want : ("0" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("+0" : GoString), _want : ("0" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("-0" : GoString), _want : ("0" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("Inf" : GoString), _want : ("nil" : GoString), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("+Inf" : GoString), _want : ("nil" : GoString), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("-Inf" : GoString), _want : ("nil" : GoString), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("1" : GoString), _want : ("1" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("-1" : GoString), _want : ("-1" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("1.23" : GoString), _want : ("1" : GoString), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("-1.23" : GoString), _want : ("-1" : GoString), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("123e-2" : GoString), _want : ("1" : GoString), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("123e-3" : GoString), _want : ("0" : GoString), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("123e-4" : GoString), _want : ("0" : GoString), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("1e-1000" : GoString), _want : ("0" : GoString), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("-1e-1000" : GoString), _want : ("0" : GoString), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("1e+10" : GoString), _want : ("10000000000" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("1e+100" : GoString), _want : ("10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_22)) : Slice<T__struct_22>)) {
            var _x = _makeFloat(_test._x);
            var __tmp__ = _x.int_(null), _res:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, _acc:stdgo.math.big.Big.Accuracy = __tmp__._1;
            var _got:GoString = ("nil" : GoString);
            if (_res != null && ((_res : Dynamic).__nil__ == null || !(_res : Dynamic).__nil__)) {
                _got = (_res.string() : GoString);
            };
            if ((_got != _test._want) || (_acc != _test._acc)) {
                _t.errorf(("%s: got %s (%s); want %s (%s)" : GoString), Go.toInterface(_test._x), Go.toInterface(_got), Go.toInterface(Go.asInterface(_acc)), Go.toInterface(_test._want), Go.toInterface(Go.asInterface(_test._acc)));
            };
        };
        for (__1 => _f in (new Slice<GoString>(0, 0, ("0" : GoString), ("1" : GoString), ("-1" : GoString), ("1234" : GoString)) : Slice<GoString>)) {
            var _x = _makeFloat(_f);
            var _i = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
            {
                var __tmp__ = _x.int_(_i), _res:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __2:stdgo.math.big.Big.Accuracy = __tmp__._1;
                if (_res != (_i)) {
                    _t.errorf(("(%s).Int is not using supplied *Int" : GoString), Go.toInterface(_f));
                };
            };
        };
    }
function testFloatRat(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_22>(
0,
0,
({ _x : ("0" : GoString), _want : ("0/1" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("+0" : GoString), _want : ("0/1" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("-0" : GoString), _want : ("0/1" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("Inf" : GoString), _want : ("nil" : GoString), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("+Inf" : GoString), _want : ("nil" : GoString), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("-Inf" : GoString), _want : ("nil" : GoString), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("1" : GoString), _want : ("1/1" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("-1" : GoString), _want : ("-1/1" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("1.25" : GoString), _want : ("5/4" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("-1.25" : GoString), _want : ("-5/4" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("1e10" : GoString), _want : ("10000000000/1" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("1p10" : GoString), _want : ("1024/1" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("-1p-10" : GoString), _want : ("-1/1024" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_22),
({ _x : ("3.14159265" : GoString), _want : ("7244019449799623199/2305843009213693952" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_22)) : Slice<T__struct_22>)) {
            var _x = _makeFloat(_test._x).setPrec((64u32 : GoUInt));
            var __tmp__ = _x.rat(null), _res:Ref<stdgo.math.big.Big.Rat> = __tmp__._0, _acc:stdgo.math.big.Big.Accuracy = __tmp__._1;
            var _got:GoString = ("nil" : GoString);
            if (_res != null && ((_res : Dynamic).__nil__ == null || !(_res : Dynamic).__nil__)) {
                _got = (_res.string() : GoString);
            };
            if (_got != (_test._want)) {
                _t.errorf(("%s: got %s; want %s" : GoString), Go.toInterface(_test._x), Go.toInterface(_got), Go.toInterface(_test._want));
                continue;
            };
            if (_acc != (_test._acc)) {
                _t.errorf(("%s: got %s; want %s" : GoString), Go.toInterface(_test._x), Go.toInterface(Go.asInterface(_acc)), Go.toInterface(Go.asInterface(_test._acc)));
                continue;
            };
            if (_res != null && ((_res : Dynamic).__nil__ == null || !(_res : Dynamic).__nil__)) {
                var _got = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec((64u32 : GoUInt)).setRat(_res);
                if (_got.cmp(_x) != ((0 : GoInt))) {
                    _t.errorf(("%s: got %s; want %s" : GoString), Go.toInterface(_test._x), Go.toInterface(Go.asInterface(_got)), Go.toInterface(Go.asInterface(_x)));
                };
            };
        };
        for (__1 => _f in (new Slice<GoString>(0, 0, ("0" : GoString), ("1" : GoString), ("-1" : GoString), ("1234" : GoString)) : Slice<GoString>)) {
            var _x = _makeFloat(_f);
            var _r = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>);
            {
                var __tmp__ = _x.rat(_r), _res:Ref<stdgo.math.big.Big.Rat> = __tmp__._0, __2:stdgo.math.big.Big.Accuracy = __tmp__._1;
                if (_res != (_r)) {
                    _t.errorf(("(%s).Rat is not using supplied *Rat" : GoString), Go.toInterface(_f));
                };
            };
        };
    }
function testFloatAbs(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<GoString>(0, 0, ("0" : GoString), ("1" : GoString), ("1234" : GoString), ("1.23e-2" : GoString), ("1e-1000" : GoString), ("1e1000" : GoString), ("Inf" : GoString)) : Slice<GoString>)) {
            var _p = _makeFloat(_test);
            var _a = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).abs(_p);
            if (!_alike(_a, _p)) {
                _t.errorf(("%s: got %s; want %s" : GoString), Go.toInterface(_test), Go.toInterface(_a.text((103 : GoUInt8), (10 : GoInt))), Go.toInterface(_test));
            };
            var _n = _makeFloat(("-" : GoString) + _test);
            _a.abs(_n);
            if (!_alike(_a, _p)) {
                _t.errorf(("-%s: got %s; want %s" : GoString), Go.toInterface(_test), Go.toInterface(_a.text((103 : GoUInt8), (10 : GoInt))), Go.toInterface(_test));
            };
        };
    }
function testFloatNeg(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<GoString>(0, 0, ("0" : GoString), ("1" : GoString), ("1234" : GoString), ("1.23e-2" : GoString), ("1e-1000" : GoString), ("1e1000" : GoString), ("Inf" : GoString)) : Slice<GoString>)) {
            var _p1 = _makeFloat(_test);
            var _n1 = _makeFloat(("-" : GoString) + _test);
            var _n2 = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).neg(_p1);
            var _p2 = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).neg(_n2);
            if (!_alike(_n2, _n1)) {
                _t.errorf(("%s: got %s; want %s" : GoString), Go.toInterface(_test), Go.toInterface(_n2.text((103 : GoUInt8), (10 : GoInt))), Go.toInterface(_n1.text((103 : GoUInt8), (10 : GoInt))));
            };
            if (!_alike(_p2, _p1)) {
                _t.errorf(("%s: got %s; want %s" : GoString), Go.toInterface(_test), Go.toInterface(_p2.text((103 : GoUInt8), (10 : GoInt))), Go.toInterface(_p1.text((103 : GoUInt8), (10 : GoInt))));
            };
        };
    }
function testFloatInc(_t:Ref<stdgo.testing.Testing.T>):Void {
        {};
        for (__0 => _prec in _precList) {
            if (((1 : GoInt) << _prec) < (10 : GoInt)) {
                continue;
            };
            var __0:Float_ = ({} : stdgo.math.big.Big.Float_), __1:Float_ = ({} : stdgo.math.big.Big.Float_), _one:Float_ = __1, _x:Float_ = __0;
            _x.setPrec(_prec);
            _one.setInt64((1i64 : GoInt64));
            {
                var _i:GoInt = (0 : GoInt);
                Go.cfor(_i < (10 : GoInt), _i++, {
                    _x.add((Go.setRef(_x) : Ref<stdgo.math.big.Big.Float_>), (Go.setRef(_one) : Ref<stdgo.math.big.Big.Float_>));
                });
            };
            if (_x.cmp((Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setInt64((10i64 : GoInt64))) != ((0 : GoInt))) {
                _t.errorf(("prec = %d: got %s; want %d" : GoString), Go.toInterface(_prec), Go.toInterface(Go.asInterface((Go.setRef(_x) : Ref<stdgo.math.big.Big.Float_>))), Go.toInterface((10 : GoInt)));
            };
        };
    }
/**
    // TestFloatAdd tests Float.Add/Sub by comparing the result of a "manual"
    // addition/subtraction of arguments represented by Bits values with the
    // respective Float addition/subtraction for a variety of precisions
    // and rounding modes.
**/
function testFloatAdd(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _xbits in _bitsList) {
            for (__1 => _ybits in _bitsList) {
                var _x = _xbits.float_();
                var _y = _ybits.float_();
                var _zbits:stdgo.math.big.Big.Bits = _xbits._add(_ybits);
                var _z = _zbits.float_();
                for (_i => _mode in (new GoArray<stdgo.math.big.Big.RoundingMode>((2 : stdgo.math.big.Big.RoundingMode), (0 : stdgo.math.big.Big.RoundingMode), (3 : stdgo.math.big.Big.RoundingMode)) : GoArray<stdgo.math.big.Big.RoundingMode>)) {
                    for (__2 => _prec in _precList) {
                        var _got = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_prec).setMode(_mode);
                        _got.add(_x, _y);
                        var _want = _zbits._round(_prec, _mode);
                        if (_got.cmp(_want) != ((0 : GoInt))) {
                            _t.errorf(("i = %d, prec = %d, %s:\n\t     %s %v\n\t+    %s %v\n\t=    %s\n\twant %s" : GoString), Go.toInterface(_i), Go.toInterface(_prec), Go.toInterface(Go.asInterface(_mode)), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_xbits)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_ybits)), Go.toInterface(Go.asInterface(_got)), Go.toInterface(Go.asInterface(_want)));
                        };
                        _got.sub(_z, _x);
                        _want = _ybits._round(_prec, _mode);
                        if (_got.cmp(_want) != ((0 : GoInt))) {
                            _t.errorf(("i = %d, prec = %d, %s:\n\t     %s %v\n\t-    %s %v\n\t=    %s\n\twant %s" : GoString), Go.toInterface(_i), Go.toInterface(_prec), Go.toInterface(Go.asInterface(_mode)), Go.toInterface(Go.asInterface(_z)), Go.toInterface(Go.asInterface(_zbits)), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_xbits)), Go.toInterface(Go.asInterface(_got)), Go.toInterface(Go.asInterface(_want)));
                        };
                    };
                };
            };
        };
    }
/**
    // TestFloatAddRoundZero tests Float.Add/Sub rounding when the result is exactly zero.
    // x + (-x) or x - x for non-zero x should be +0 in all cases except when
    // the rounding mode is ToNegativeInf in which case it should be -0.
**/
function testFloatAddRoundZero(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _mode in (new GoArray<stdgo.math.big.Big.RoundingMode>((0 : stdgo.math.big.Big.RoundingMode), (1 : stdgo.math.big.Big.RoundingMode), (2 : stdgo.math.big.Big.RoundingMode), (3 : stdgo.math.big.Big.RoundingMode), (5 : stdgo.math.big.Big.RoundingMode), (4 : stdgo.math.big.Big.RoundingMode)) : GoArray<stdgo.math.big.Big.RoundingMode>)) {
            var _x = newFloat((5 : GoFloat64));
            var _y = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).neg(_x);
            var _want = newFloat((0 : GoFloat64));
            if (_mode == ((4 : stdgo.math.big.Big.RoundingMode))) {
                _want.neg(_want);
            };
            var _got = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setMode(_mode);
            _got.add(_x, _y);
            if ((_got.cmp(_want) != (0 : GoInt)) || (_got._neg != (_mode == (4 : stdgo.math.big.Big.RoundingMode)))) {
                _t.errorf(("%s:\n\t     %v\n\t+    %v\n\t=    %v\n\twant %v" : GoString), Go.toInterface(Go.asInterface(_mode)), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_got)), Go.toInterface(Go.asInterface(_want)));
            };
            _got.sub(_x, _x);
            if ((_got.cmp(_want) != (0 : GoInt)) || (_got._neg != (_mode == (4 : stdgo.math.big.Big.RoundingMode)))) {
                _t.errorf(("%v:\n\t     %v\n\t-    %v\n\t=    %v\n\twant %v" : GoString), Go.toInterface(Go.asInterface(_mode)), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_got)), Go.toInterface(Go.asInterface(_want)));
            };
        };
    }
/**
    // TestFloatAdd32 tests that Float.Add/Sub of numbers with
    // 24bit mantissa behaves like float32 addition/subtraction
    // (excluding denormal numbers).
**/
function testFloatAdd32(_t:Ref<stdgo.testing.Testing.T>):Void {
        {};
        {
            var _d:GoInt = (0 : GoInt);
            Go.cfor(_d <= (16 : GoInt), _d++, {
                for (_i in 0 ... (new GoArray<GoInt>(...([].concat([for (i in 0 ... 2) (0 : GoInt)]))) : GoArray<GoInt>).length.toBasic()) {
                    var __0:GoFloat64 = (6.7108848e+07 : GoFloat64), __1:GoFloat64 = (_d : GoFloat64), _y0:GoFloat64 = __1, _x0:GoFloat64 = __0;
                    if (_i & (1 : GoInt) != ((0 : GoInt))) {
                        {
                            final __tmp__0 = _y0;
                            final __tmp__1 = _x0;
                            _x0 = __tmp__0;
                            _y0 = __tmp__1;
                        };
                    };
                    var _x = newFloat(_x0);
                    var _y = newFloat(_y0);
                    var _z = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec((24u32 : GoUInt));
                    _z.add(_x, _y);
                    var __tmp__ = _z.float32(), _got:GoFloat32 = __tmp__._0, _acc:stdgo.math.big.Big.Accuracy = __tmp__._1;
                    var _want:GoFloat32 = (_y0 : GoFloat32) + (_x0 : GoFloat32);
                    if ((_got != _want) || (_acc != (0 : stdgo.math.big.Big.Accuracy))) {
                        _t.errorf(("d = %d: %g + %g = %g (%s); want %g (Exact)" : GoString), Go.toInterface(_d), Go.toInterface(_x0), Go.toInterface(_y0), Go.toInterface(_got), Go.toInterface(Go.asInterface(_acc)), Go.toInterface(_want));
                    };
                    _z.sub(_z, _y);
                    {
                        var __tmp__ = _z.float32();
                        _got = __tmp__._0;
                        _acc = __tmp__._1;
                    };
                    _want = (_want : GoFloat32) - (_y0 : GoFloat32);
                    if ((_got != _want) || (_acc != (0 : stdgo.math.big.Big.Accuracy))) {
                        _t.errorf(("d = %d: %g - %g = %g (%s); want %g (Exact)" : GoString), Go.toInterface(_d), Go.toInterface(_x0 + _y0), Go.toInterface(_y0), Go.toInterface(_got), Go.toInterface(Go.asInterface(_acc)), Go.toInterface(_want));
                    };
                };
            });
        };
    }
/**
    // TestFloatAdd64 tests that Float.Add/Sub of numbers with
    // 53bit mantissa behaves like float64 addition/subtraction.
**/
function testFloatAdd64(_t:Ref<stdgo.testing.Testing.T>):Void {
        {};
        {
            var _d:GoInt = (0 : GoInt);
            Go.cfor(_d <= (16 : GoInt), _d++, {
                for (_i in 0 ... (new GoArray<GoInt>(...([].concat([for (i in 0 ... 2) (0 : GoInt)]))) : GoArray<GoInt>).length.toBasic()) {
                    var __0:GoFloat64 = (3.602879701896395e+16 : GoFloat64), __1:GoFloat64 = (_d : GoFloat64), _y0:GoFloat64 = __1, _x0:GoFloat64 = __0;
                    if (_i & (1 : GoInt) != ((0 : GoInt))) {
                        {
                            final __tmp__0 = _y0;
                            final __tmp__1 = _x0;
                            _x0 = __tmp__0;
                            _y0 = __tmp__1;
                        };
                    };
                    var _x = newFloat(_x0);
                    var _y = newFloat(_y0);
                    var _z = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec((53u32 : GoUInt));
                    _z.add(_x, _y);
                    var __tmp__ = _z.float64(), _got:GoFloat64 = __tmp__._0, _acc:stdgo.math.big.Big.Accuracy = __tmp__._1;
                    var _want:GoFloat64 = _x0 + _y0;
                    if ((_got != _want) || (_acc != (0 : stdgo.math.big.Big.Accuracy))) {
                        _t.errorf(("d = %d: %g + %g = %g (%s); want %g (Exact)" : GoString), Go.toInterface(_d), Go.toInterface(_x0), Go.toInterface(_y0), Go.toInterface(_got), Go.toInterface(Go.asInterface(_acc)), Go.toInterface(_want));
                    };
                    _z.sub(_z, _y);
                    {
                        var __tmp__ = _z.float64();
                        _got = __tmp__._0;
                        _acc = __tmp__._1;
                    };
                    _want = _want - (_y0);
                    if ((_got != _want) || (_acc != (0 : stdgo.math.big.Big.Accuracy))) {
                        _t.errorf(("d = %d: %g - %g = %g (%s); want %g (Exact)" : GoString), Go.toInterface(_d), Go.toInterface(_x0 + _y0), Go.toInterface(_y0), Go.toInterface(_got), Go.toInterface(Go.asInterface(_acc)), Go.toInterface(_want));
                    };
                };
            });
        };
    }
function testIssue20490(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _tests:Slice<T__struct_23> = (new Slice<T__struct_23>(0, 0, ({ _a : (4 : GoFloat64), _b : (1 : GoFloat64) } : T__struct_23), ({ _a : (-4 : GoFloat64), _b : (1 : GoFloat64) } : T__struct_23), ({ _a : (4 : GoFloat64), _b : (-1 : GoFloat64) } : T__struct_23), ({ _a : (-4 : GoFloat64), _b : (-1 : GoFloat64) } : T__struct_23)) : Slice<T__struct_23>);
        for (__0 => _test in _tests) {
            var __0 = newFloat(_test._a), __1 = newFloat(_test._b), _b = __1, _a = __0;
            var _diff = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).sub(_a, _b);
            _b.sub(_a, _b);
            if (_b.cmp(_diff) != ((0 : GoInt))) {
                _t.errorf(("got %g - %g = %g; want %g\n" : GoString), Go.toInterface(Go.asInterface(_a)), Go.toInterface(Go.asInterface(newFloat(_test._b))), Go.toInterface(Go.asInterface(_b)), Go.toInterface(Go.asInterface(_diff)));
            };
            _b = newFloat(_test._b);
            var _sum = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).add(_a, _b);
            _b.add(_a, _b);
            if (_b.cmp(_sum) != ((0 : GoInt))) {
                _t.errorf(("got %g + %g = %g; want %g\n" : GoString), Go.toInterface(Go.asInterface(_a)), Go.toInterface(Go.asInterface(newFloat(_test._b))), Go.toInterface(Go.asInterface(_b)), Go.toInterface(Go.asInterface(_sum)));
            };
        };
    }
/**
    // TestFloatMul tests Float.Mul/Quo by comparing the result of a "manual"
    // multiplication/division of arguments represented by Bits values with the
    // respective Float multiplication/division for a variety of precisions
    // and rounding modes.
**/
function testFloatMul(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _xbits in _bitsList) {
            for (__1 => _ybits in _bitsList) {
                var _x = _xbits.float_();
                var _y = _ybits.float_();
                var _zbits:stdgo.math.big.Big.Bits = _xbits._mul(_ybits);
                var _z = _zbits.float_();
                for (_i => _mode in (new GoArray<stdgo.math.big.Big.RoundingMode>((2 : stdgo.math.big.Big.RoundingMode), (0 : stdgo.math.big.Big.RoundingMode), (3 : stdgo.math.big.Big.RoundingMode)) : GoArray<stdgo.math.big.Big.RoundingMode>)) {
                    for (__2 => _prec in _precList) {
                        var _got = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_prec).setMode(_mode);
                        _got.mul(_x, _y);
                        var _want = _zbits._round(_prec, _mode);
                        if (_got.cmp(_want) != ((0 : GoInt))) {
                            _t.errorf(("i = %d, prec = %d, %s:\n\t     %v %v\n\t*    %v %v\n\t=    %v\n\twant %v" : GoString), Go.toInterface(_i), Go.toInterface(_prec), Go.toInterface(Go.asInterface(_mode)), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_xbits)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_ybits)), Go.toInterface(Go.asInterface(_got)), Go.toInterface(Go.asInterface(_want)));
                        };
                        if (_x.sign() == ((0 : GoInt))) {
                            continue;
                        };
                        _got.quo(_z, _x);
                        _want = _ybits._round(_prec, _mode);
                        if (_got.cmp(_want) != ((0 : GoInt))) {
                            _t.errorf(("i = %d, prec = %d, %s:\n\t     %v %v\n\t/    %v %v\n\t=    %v\n\twant %v" : GoString), Go.toInterface(_i), Go.toInterface(_prec), Go.toInterface(Go.asInterface(_mode)), Go.toInterface(Go.asInterface(_z)), Go.toInterface(Go.asInterface(_zbits)), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_xbits)), Go.toInterface(Go.asInterface(_got)), Go.toInterface(Go.asInterface(_want)));
                        };
                    };
                };
            };
        };
    }
/**
    // TestFloatMul64 tests that Float.Mul/Quo of numbers with
    // 53bit mantissa behaves like float64 multiplication/division.
**/
function testFloatMul64(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_24>(0, 0, ({ _x : (0 : GoFloat64), _y : (0 : GoFloat64) } : T__struct_24), ({ _x : (0 : GoFloat64), _y : (1 : GoFloat64) } : T__struct_24), ({ _x : (1 : GoFloat64), _y : (1 : GoFloat64) } : T__struct_24), ({ _x : (1 : GoFloat64), _y : (1.5 : GoFloat64) } : T__struct_24), ({ _x : (1.234 : GoFloat64), _y : (0.5678 : GoFloat64) } : T__struct_24), ({ _x : (2.718281828 : GoFloat64), _y : (3.14159265358979 : GoFloat64) } : T__struct_24), ({ _x : (2.718281828e+10 : GoFloat64), _y : (3.14159265358979e-32 : GoFloat64) } : T__struct_24), ({ _x : (0.3333333333333333 : GoFloat64), _y : (1e+200 : GoFloat64) } : T__struct_24)) : Slice<T__struct_24>)) {
            for (_i in 0 ... (new GoArray<GoInt>(...([].concat([for (i in 0 ... 8) (0 : GoInt)]))) : GoArray<GoInt>).length.toBasic()) {
                var __0:GoFloat64 = _test._x, __1:GoFloat64 = _test._y, _y0:GoFloat64 = __1, _x0:GoFloat64 = __0;
                if (_i & (1 : GoInt) != ((0 : GoInt))) {
                    _x0 = -_x0;
                };
                if (_i & (2 : GoInt) != ((0 : GoInt))) {
                    _y0 = -_y0;
                };
                if (_i & (4 : GoInt) != ((0 : GoInt))) {
                    {
                        final __tmp__0 = _y0;
                        final __tmp__1 = _x0;
                        _x0 = __tmp__0;
                        _y0 = __tmp__1;
                    };
                };
                var _x = newFloat(_x0);
                var _y = newFloat(_y0);
                var _z = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec((53u32 : GoUInt));
                _z.mul(_x, _y);
                var __tmp__ = _z.float64(), _got:GoFloat64 = __tmp__._0, __1:stdgo.math.big.Big.Accuracy = __tmp__._1;
                var _want:GoFloat64 = _x0 * _y0;
                if (_got != (_want)) {
                    _t.errorf(("%g * %g = %g; want %g" : GoString), Go.toInterface(_x0), Go.toInterface(_y0), Go.toInterface(_got), Go.toInterface(_want));
                };
                if (_y0 == (0 : GoFloat64)) {
                    continue;
                };
                _z.quo(_z, _y);
                {
                    var __tmp__ = _z.float64();
                    _got = __tmp__._0;
                };
                _want = _want / (_y0);
                if (_got != (_want)) {
                    _t.errorf(("%g / %g = %g; want %g" : GoString), Go.toInterface(_x0 * _y0), Go.toInterface(_y0), Go.toInterface(_got), Go.toInterface(_want));
                };
            };
        };
    }
function testIssue6866(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _prec in _precList) {
            var _two = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_prec).setInt64((2i64 : GoInt64));
            var _one = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_prec).setInt64((1i64 : GoInt64));
            var _three = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_prec).setInt64((3i64 : GoInt64));
            var _msix = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_prec).setInt64((-6i64 : GoInt64));
            var _psix = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_prec).setInt64((6i64 : GoInt64));
            var _p = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_prec);
            var _z1 = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_prec);
            var _z2 = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_prec);
            _p.quo(_one, _three);
            _p.mul(_p, _msix);
            _z1.add(_two, _p);
            _p.quo(_one, _three);
            _p.mul(_p, _psix);
            _z2.sub(_two, _p);
            if (_z1.cmp(_z2) != ((0 : GoInt))) {
                _t.fatalf(("prec %d: got z1 = %v != z2 = %v; want z1 == z2\n" : GoString), Go.toInterface(_prec), Go.toInterface(Go.asInterface(_z1)), Go.toInterface(Go.asInterface(_z2)));
            };
            if (_z1.sign() != ((0 : GoInt))) {
                _t.errorf(("prec %d: got z1 = %v; want 0" : GoString), Go.toInterface(_prec), Go.toInterface(Go.asInterface(_z1)));
            };
            if (_z2.sign() != ((0 : GoInt))) {
                _t.errorf(("prec %d: got z2 = %v; want 0" : GoString), Go.toInterface(_prec), Go.toInterface(Go.asInterface(_z2)));
            };
        };
    }
function testFloatQuo(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _preci:GoInt = (200 : GoInt);
        var _precf:GoInt = (20 : GoInt);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < (8 : GoInt), _i++, {
                var _bits:stdgo.math.big.Big.Bits = (new Slice<GoInt>(0, 0, _preci - (1 : GoInt)) : stdgo.math.big.Big.Bits);
                if (_i & (3 : GoInt) != ((0 : GoInt))) {
                    _bits = _bits.__appendref__((0 : GoInt));
                };
                if (_i & (2 : GoInt) != ((0 : GoInt))) {
                    _bits = _bits.__appendref__((-1 : GoInt));
                };
                if (_i & (1 : GoInt) != ((0 : GoInt))) {
                    _bits = _bits.__appendref__(-_precf);
                };
                var _z = _bits.float_();
                var _y = newFloat((3.141592653589793e+123 : GoFloat64));
                var _x = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_z.prec() + _y.prec()).setMode((2 : stdgo.math.big.Big.RoundingMode));
                _x.mul(_z, _y);
                {
                    var _got:stdgo.math.big.Big.Accuracy = _x.acc();
                    if (_got != ((0 : stdgo.math.big.Big.Accuracy))) {
                        _t.errorf(("got acc = %s; want exact" : GoString), Go.toInterface(Go.asInterface(_got)));
                    };
                };
                for (__0 => _mode in (new GoArray<stdgo.math.big.Big.RoundingMode>((2 : stdgo.math.big.Big.RoundingMode), (0 : stdgo.math.big.Big.RoundingMode), (3 : stdgo.math.big.Big.RoundingMode)) : GoArray<stdgo.math.big.Big.RoundingMode>)) {
                    {
                        var _d:GoInt = (-5 : GoInt);
                        Go.cfor(_d < (5 : GoInt), _d++, {
                            var _prec:GoUInt = (_preci + _d : GoUInt);
                            var _got = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_prec).setMode(_mode).quo(_x, _y);
                            var _want = _bits._round(_prec, _mode);
                            if (_got.cmp(_want) != ((0 : GoInt))) {
                                _t.errorf(("i = %d, prec = %d, %s:\n\t     %s\n\t/    %s\n\t=    %s\n\twant %s" : GoString), Go.toInterface(_i), Go.toInterface(_prec), Go.toInterface(Go.asInterface(_mode)), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_got)), Go.toInterface(Go.asInterface(_want)));
                            };
                        });
                    };
                };
            });
        };
    }
/**
    // TestFloatQuoSmoke tests all divisions x/y for values x, y in the range [-n, +n];
    // it serves as a smoke test for basic correctness of division.
**/
function testFloatQuoSmoke(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _n:GoInt = (10 : GoInt);
        if (_long.value) {
            _n = (1000 : GoInt);
        };
        {};
        {};
        {
            var _x:GoInt = -_n;
            Go.cfor(_x <= _n, _x++, {
                {
                    var _y:GoInt = -_n;
                    Go.cfor(_y < _n, _y++, {
                        if (_y == ((0 : GoInt))) {
                            continue;
                        };
                        var _a:GoFloat64 = (_x : GoFloat64);
                        var _b:GoFloat64 = (_y : GoFloat64);
                        var _c:GoFloat64 = _a / _b;
                        {
                            var _ad:GoInt = (-3 : GoInt);
                            Go.cfor(_ad <= (3 : GoInt), _ad++, {
                                {
                                    var _bd:GoInt = (-3 : GoInt);
                                    Go.cfor(_bd <= (3 : GoInt), _bd++, {
                                        var a = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(((13 : GoInt) + _ad : GoUInt)).setFloat64(_a);
                                        var b = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(((13 : GoInt) + _bd : GoUInt)).setFloat64(_b);
                                        var c = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec((53u32 : GoUInt)).quo(a, b);
                                        var __tmp__ = c.float64(), _cc:GoFloat64 = __tmp__._0, _acc:stdgo.math.big.Big.Accuracy = __tmp__._1;
                                        if (_cc != (_c)) {
                                            _t.errorf(("%g/%g = %s; want %.5g\n" : GoString), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(c.text((103 : GoUInt8), (5 : GoInt))), Go.toInterface(_c));
                                            continue;
                                        };
                                        if (_acc != ((0 : stdgo.math.big.Big.Accuracy))) {
                                            _t.errorf(("%g/%g got %s result; want exact result" : GoString), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(Go.asInterface(_acc)));
                                        };
                                    });
                                };
                            });
                        };
                    });
                };
            });
        };
    }
/**
    // TestFloatArithmeticSpecialValues tests that Float operations produce the
    // correct results for combinations of zero (0), finite (1 and 2.71828),
    // and infinite (Inf) operands.
**/
function testFloatArithmeticSpecialValues(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _zero:GoFloat64 = (0 : GoFloat64);
        var _args = (new Slice<GoFloat64>(0, 0, stdgo.math.Math.inf((-1 : GoInt)), (-2.71828 : GoFloat64), (-1 : GoFloat64), -_zero, _zero, (1 : GoFloat64), (2.71828 : GoFloat64), stdgo.math.Math.inf((1 : GoInt))) : Slice<GoFloat64>);
        var _xx = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>);
        var _yy = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>);
        var _got = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>);
        var _want = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < (4 : GoInt), _i++, {
                for (__0 => _x in _args) {
                    _xx.setFloat64(_x);
                    {
                        var __tmp__ = _xx.float64(), _got:GoFloat64 = __tmp__._0, _acc:stdgo.math.big.Big.Accuracy = __tmp__._1;
                        if ((_got != _x) || (_acc != (0 : stdgo.math.big.Big.Accuracy))) {
                            _t.errorf(("Float(%g) == %g (%s)" : GoString), Go.toInterface(_x), Go.toInterface(_got), Go.toInterface(Go.asInterface(_acc)));
                        };
                    };
                    for (__1 => _y in _args) {
                        _yy.setFloat64(_y);
                        var __0:GoString = ("" : GoString), __1:GoFloat64 = (0 : GoFloat64), __2:(_z:Ref<Float_>, _x:Ref<Float_>, _y:Ref<Float_>) -> Ref<Float_> = null, _f:(_z:Ref<Float_>, _x:Ref<Float_>, _y:Ref<Float_>) -> Ref<Float_> = __2, _z:GoFloat64 = __1, _op:GoString = __0;
                        {
                            final __value__ = _i;
                            if (__value__ == ((0 : GoInt))) {
                                _op = ("+" : GoString);
                                _z = _x + _y;
                                _f = Float__static_extension.add;
                            } else if (__value__ == ((1 : GoInt))) {
                                _op = ("-" : GoString);
                                _z = _x - _y;
                                _f = Float__static_extension.sub;
                            } else if (__value__ == ((2 : GoInt))) {
                                _op = ("*" : GoString);
                                _z = _x * _y;
                                _f = Float__static_extension.mul;
                            } else if (__value__ == ((3 : GoInt))) {
                                _op = ("/" : GoString);
                                _z = _x / _y;
                                _f = Float__static_extension.quo;
                            } else {
                                throw Go.toInterface(("unreachable" : GoString));
                            };
                        };
                        var _errnan:Bool = false;
                        {
                            var a = function():Void {
                                var __deferstack__:Array<Void -> Void> = [];
                                try {
                                    __deferstack__.unshift(() -> {
                                        var a = function():Void {
                                            {
                                                var _p:AnyInterface = ({
                                                    final r = Go.recover_exception;
                                                    Go.recover_exception = null;
                                                    r;
                                                });
                                                if (_p != null) {
                                                    (Go.typeAssert((_p : ErrNaN)) : ErrNaN);
                                                    _errnan = true;
                                                };
                                            };
                                        };
                                        a();
                                    });
                                    _f(_got, _xx, _yy);
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    {
                                        for (defer in __deferstack__) {
                                            defer();
                                        };
                                        if (Go.recover_exception != null) throw Go.recover_exception;
                                        return;
                                    };
                                } catch(__exception__) {
                                    var exe:Dynamic = __exception__.native;
                                    if ((exe is haxe.ValueException)) exe = exe.value;
                                    if (!(exe is AnyInterfaceData)) {
                                        exe = Go.toInterface(__exception__.message);
                                    };
                                    Go.recover_exception = exe;
                                    for (defer in __deferstack__) {
                                        defer();
                                    };
                                    if (Go.recover_exception != null) throw Go.recover_exception;
                                    return;
                                };
                            };
                            a();
                        };
                        if (stdgo.math.Math.isNaN(_z)) {
                            if (!_errnan) {
                                _t.errorf(("%5g %s %5g = %5s; want ErrNaN panic" : GoString), Go.toInterface(_x), Go.toInterface(_op), Go.toInterface(_y), Go.toInterface(Go.asInterface(_got)));
                            };
                            continue;
                        };
                        if (_errnan) {
                            _t.errorf(("%5g %s %5g panicked with ErrNan; want %5s" : GoString), Go.toInterface(_x), Go.toInterface(_op), Go.toInterface(_y), Go.toInterface(Go.asInterface(_want)));
                            continue;
                        };
                        _want.setFloat64(_z);
                        if (!_alike(_got, _want)) {
                            _t.errorf(("%5g %s %5g = %5s; want %5s" : GoString), Go.toInterface(_x), Go.toInterface(_op), Go.toInterface(_y), Go.toInterface(Go.asInterface(_got)), Go.toInterface(Go.asInterface(_want)));
                        };
                    };
                };
            });
        };
    }
function testFloatArithmeticOverflow(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_25>(
0,
0,
({ _prec : (4u32 : GoUInt), _mode : (0 : stdgo.math.big.Big.RoundingMode), _op : (43 : GoUInt8), _x : ("0" : GoString), _y : ("0" : GoString), _want : ("0" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_25),
({ _prec : (4u32 : GoUInt), _mode : (0 : stdgo.math.big.Big.RoundingMode), _op : (43 : GoUInt8), _x : ("0x.8p+0" : GoString), _y : ("0x.8p+0" : GoString), _want : ("0x.8p+1" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_25),
({ _prec : (4u32 : GoUInt), _mode : (0 : stdgo.math.big.Big.RoundingMode), _op : (43 : GoUInt8), _x : ("0" : GoString), _y : ("0x.8p2147483647" : GoString), _want : ("0x.8p+2147483647" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_25),
({ _prec : (4u32 : GoUInt), _mode : (0 : stdgo.math.big.Big.RoundingMode), _op : (43 : GoUInt8), _x : ("0x.8p2147483500" : GoString), _y : ("0x.8p2147483647" : GoString), _want : ("0x.8p+2147483647" : GoString), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_25),
({ _prec : (4u32 : GoUInt), _mode : (0 : stdgo.math.big.Big.RoundingMode), _op : (43 : GoUInt8), _x : ("0x.8p2147483647" : GoString), _y : ("0x.8p2147483647" : GoString), _want : ("+Inf" : GoString), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_25),
({ _prec : (4u32 : GoUInt), _mode : (0 : stdgo.math.big.Big.RoundingMode), _op : (43 : GoUInt8), _x : ("-0x.8p2147483647" : GoString), _y : ("-0x.8p2147483647" : GoString), _want : ("-Inf" : GoString), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_25),
({ _prec : (4u32 : GoUInt), _mode : (0 : stdgo.math.big.Big.RoundingMode), _op : (45 : GoUInt8), _x : ("-0x.8p2147483647" : GoString), _y : ("0x.8p2147483647" : GoString), _want : ("-Inf" : GoString), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_25),
({ _prec : (4u32 : GoUInt), _mode : (2 : stdgo.math.big.Big.RoundingMode), _op : (43 : GoUInt8), _x : ("0x.fp2147483647" : GoString), _y : ("0x.8p2147483643" : GoString), _want : ("0x.fp+2147483647" : GoString), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_25),
({ _prec : (4u32 : GoUInt), _mode : (0 : stdgo.math.big.Big.RoundingMode), _op : (43 : GoUInt8), _x : ("0x.fp2147483647" : GoString), _y : ("0x.8p2147483643" : GoString), _want : ("+Inf" : GoString), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_25),
({ _prec : (4u32 : GoUInt), _mode : (3 : stdgo.math.big.Big.RoundingMode), _op : (43 : GoUInt8), _x : ("0x.fp2147483647" : GoString), _y : ("0x.8p2147483643" : GoString), _want : ("+Inf" : GoString), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_25),
({ _prec : (4u32 : GoUInt), _mode : (3 : stdgo.math.big.Big.RoundingMode), _op : (45 : GoUInt8), _x : ("-0x.fp2147483647" : GoString), _y : ("0x.8p2147483644" : GoString), _want : ("-Inf" : GoString), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_25),
({ _prec : (4u32 : GoUInt), _mode : (0 : stdgo.math.big.Big.RoundingMode), _op : (45 : GoUInt8), _x : ("-0x.fp2147483647" : GoString), _y : ("0x.8p2147483643" : GoString), _want : ("-Inf" : GoString), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_25),
({ _prec : (4u32 : GoUInt), _mode : (2 : stdgo.math.big.Big.RoundingMode), _op : (45 : GoUInt8), _x : ("-0x.fp2147483647" : GoString), _y : ("0x.8p2147483643" : GoString), _want : ("-0x.fp+2147483647" : GoString), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_25),
({ _prec : (4u32 : GoUInt), _mode : (0 : stdgo.math.big.Big.RoundingMode), _op : (43 : GoUInt8), _x : ("0" : GoString), _y : ("0x.8p-2147483648" : GoString), _want : ("0x.8p-2147483648" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_25),
({ _prec : (4u32 : GoUInt), _mode : (0 : stdgo.math.big.Big.RoundingMode), _op : (43 : GoUInt8), _x : ("0x.8p-2147483648" : GoString), _y : ("0x.8p-2147483648" : GoString), _want : ("0x.8p-2147483647" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_25),
({ _prec : (4u32 : GoUInt), _mode : (0 : stdgo.math.big.Big.RoundingMode), _op : (42 : GoUInt8), _x : ("1" : GoString), _y : ("0x.8p2147483647" : GoString), _want : ("0x.8p+2147483647" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_25),
({ _prec : (4u32 : GoUInt), _mode : (0 : stdgo.math.big.Big.RoundingMode), _op : (42 : GoUInt8), _x : ("2" : GoString), _y : ("0x.8p2147483647" : GoString), _want : ("+Inf" : GoString), _acc : (1 : stdgo.math.big.Big.Accuracy) } : T__struct_25),
({ _prec : (4u32 : GoUInt), _mode : (0 : stdgo.math.big.Big.RoundingMode), _op : (42 : GoUInt8), _x : ("-2" : GoString), _y : ("0x.8p2147483647" : GoString), _want : ("-Inf" : GoString), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_25),
({ _prec : (4u32 : GoUInt), _mode : (0 : stdgo.math.big.Big.RoundingMode), _op : (47 : GoUInt8), _x : ("0.5" : GoString), _y : ("0x.8p2147483647" : GoString), _want : ("0x.8p-2147483646" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_25),
({ _prec : (4u32 : GoUInt), _mode : (0 : stdgo.math.big.Big.RoundingMode), _op : (47 : GoUInt8), _x : ("0x.8p+0" : GoString), _y : ("0x.8p2147483647" : GoString), _want : ("0x.8p-2147483646" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_25),
({ _prec : (4u32 : GoUInt), _mode : (0 : stdgo.math.big.Big.RoundingMode), _op : (47 : GoUInt8), _x : ("0x.8p-1" : GoString), _y : ("0x.8p2147483647" : GoString), _want : ("0x.8p-2147483647" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_25),
({ _prec : (4u32 : GoUInt), _mode : (0 : stdgo.math.big.Big.RoundingMode), _op : (47 : GoUInt8), _x : ("0x.8p-2" : GoString), _y : ("0x.8p2147483647" : GoString), _want : ("0x.8p-2147483648" : GoString), _acc : (0 : stdgo.math.big.Big.Accuracy) } : T__struct_25),
({ _prec : (4u32 : GoUInt), _mode : (0 : stdgo.math.big.Big.RoundingMode), _op : (47 : GoUInt8), _x : ("0x.8p-3" : GoString), _y : ("0x.8p2147483647" : GoString), _want : ("0" : GoString), _acc : (-1 : stdgo.math.big.Big.Accuracy) } : T__struct_25)) : Slice<T__struct_25>)) {
            var _x = _makeFloat(_test._x);
            var _y = _makeFloat(_test._y);
            var _z = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_test._prec).setMode(_test._mode);
            {
                final __value__ = _test._op;
                if (__value__ == ((43 : GoUInt8))) {
                    _z.add(_x, _y);
                } else if (__value__ == ((45 : GoUInt8))) {
                    _z.sub(_x, _y);
                } else if (__value__ == ((42 : GoUInt8))) {
                    _z.mul(_x, _y);
                } else if (__value__ == ((47 : GoUInt8))) {
                    _z.quo(_x, _y);
                } else {
                    throw Go.toInterface(("unreachable" : GoString));
                };
            };
            {
                var _got:GoString = _z.text((112 : GoUInt8), (0 : GoInt));
                if ((_got != _test._want) || (_z.acc() != _test._acc)) {
                    _t.errorf(("prec = %d (%s): %s %c %s = %s (%s); want %s (%s)" : GoString), Go.toInterface(_test._prec), Go.toInterface(Go.asInterface(_test._mode)), Go.toInterface(_x.text((112 : GoUInt8), (0 : GoInt))), Go.toInterface(_test._op), Go.toInterface(_y.text((112 : GoUInt8), (0 : GoInt))), Go.toInterface(_got), Go.toInterface(Go.asInterface(_z.acc())), Go.toInterface(_test._want), Go.toInterface(Go.asInterface(_test._acc)));
                };
            };
        };
    }
/**
    // For rounding modes ToNegativeInf and ToPositiveInf, rounding is affected
    // by the sign of the value to be rounded. Test that rounding happens after
    // the sign of a result has been set.
    // This test uses specific values that are known to fail if rounding is
    // "factored" out before setting the result sign.
**/
function testFloatArithmeticRounding(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_26>(
0,
0,
({ _mode : (2 : stdgo.math.big.Big.RoundingMode), _prec : (3u32 : GoUInt), _x : (-8i64 : GoInt64), _y : (-1i64 : GoInt64), _want : (-8i64 : GoInt64), _op : (43 : GoUInt8) } : T__struct_26),
({ _mode : (3 : stdgo.math.big.Big.RoundingMode), _prec : (3u32 : GoUInt), _x : (-8i64 : GoInt64), _y : (-1i64 : GoInt64), _want : (-10i64 : GoInt64), _op : (43 : GoUInt8) } : T__struct_26),
({ _mode : (4 : stdgo.math.big.Big.RoundingMode), _prec : (3u32 : GoUInt), _x : (-8i64 : GoInt64), _y : (-1i64 : GoInt64), _want : (-10i64 : GoInt64), _op : (43 : GoUInt8) } : T__struct_26),
({ _mode : (2 : stdgo.math.big.Big.RoundingMode), _prec : (3u32 : GoUInt), _x : (-8i64 : GoInt64), _y : (1i64 : GoInt64), _want : (-8i64 : GoInt64), _op : (45 : GoUInt8) } : T__struct_26),
({ _mode : (3 : stdgo.math.big.Big.RoundingMode), _prec : (3u32 : GoUInt), _x : (-8i64 : GoInt64), _y : (1i64 : GoInt64), _want : (-10i64 : GoInt64), _op : (45 : GoUInt8) } : T__struct_26),
({ _mode : (4 : stdgo.math.big.Big.RoundingMode), _prec : (3u32 : GoUInt), _x : (-8i64 : GoInt64), _y : (1i64 : GoInt64), _want : (-10i64 : GoInt64), _op : (45 : GoUInt8) } : T__struct_26),
({ _mode : (2 : stdgo.math.big.Big.RoundingMode), _prec : (3u32 : GoUInt), _x : (-9i64 : GoInt64), _y : (1i64 : GoInt64), _want : (-8i64 : GoInt64), _op : (42 : GoUInt8) } : T__struct_26),
({ _mode : (3 : stdgo.math.big.Big.RoundingMode), _prec : (3u32 : GoUInt), _x : (-9i64 : GoInt64), _y : (1i64 : GoInt64), _want : (-10i64 : GoInt64), _op : (42 : GoUInt8) } : T__struct_26),
({ _mode : (4 : stdgo.math.big.Big.RoundingMode), _prec : (3u32 : GoUInt), _x : (-9i64 : GoInt64), _y : (1i64 : GoInt64), _want : (-10i64 : GoInt64), _op : (42 : GoUInt8) } : T__struct_26),
({ _mode : (2 : stdgo.math.big.Big.RoundingMode), _prec : (3u32 : GoUInt), _x : (-9i64 : GoInt64), _y : (1i64 : GoInt64), _want : (-8i64 : GoInt64), _op : (47 : GoUInt8) } : T__struct_26),
({ _mode : (3 : stdgo.math.big.Big.RoundingMode), _prec : (3u32 : GoUInt), _x : (-9i64 : GoInt64), _y : (1i64 : GoInt64), _want : (-10i64 : GoInt64), _op : (47 : GoUInt8) } : T__struct_26),
({ _mode : (4 : stdgo.math.big.Big.RoundingMode), _prec : (3u32 : GoUInt), _x : (-9i64 : GoInt64), _y : (1i64 : GoInt64), _want : (-10i64 : GoInt64), _op : (47 : GoUInt8) } : T__struct_26)) : Slice<T__struct_26>)) {
            var __0:Float_ = ({} : stdgo.math.big.Big.Float_), __1:Float_ = ({} : stdgo.math.big.Big.Float_), __2:Float_ = ({} : stdgo.math.big.Big.Float_), _z:Float_ = __2, _y:Float_ = __1, _x:Float_ = __0;
            _x.setInt64(_test._x);
            _y.setInt64(_test._y);
            _z.setPrec(_test._prec).setMode(_test._mode);
            {
                final __value__ = _test._op;
                if (__value__ == ((43 : GoUInt8))) {
                    _z.add((Go.setRef(_x) : Ref<stdgo.math.big.Big.Float_>), (Go.setRef(_y) : Ref<stdgo.math.big.Big.Float_>));
                } else if (__value__ == ((45 : GoUInt8))) {
                    _z.sub((Go.setRef(_x) : Ref<stdgo.math.big.Big.Float_>), (Go.setRef(_y) : Ref<stdgo.math.big.Big.Float_>));
                } else if (__value__ == ((42 : GoUInt8))) {
                    _z.mul((Go.setRef(_x) : Ref<stdgo.math.big.Big.Float_>), (Go.setRef(_y) : Ref<stdgo.math.big.Big.Float_>));
                } else if (__value__ == ((47 : GoUInt8))) {
                    _z.quo((Go.setRef(_x) : Ref<stdgo.math.big.Big.Float_>), (Go.setRef(_y) : Ref<stdgo.math.big.Big.Float_>));
                } else {
                    throw Go.toInterface(("unreachable" : GoString));
                };
            };
            {
                var __tmp__ = _z.int64(), _got:GoInt64 = __tmp__._0, _acc:stdgo.math.big.Big.Accuracy = __tmp__._1;
                if ((_got != _test._want) || (_acc != (0 : stdgo.math.big.Big.Accuracy))) {
                    _t.errorf(("%s, %d bits: %d %c %d = %d (%s); want %d (Exact)" : GoString), Go.toInterface(Go.asInterface(_test._mode)), Go.toInterface(_test._prec), Go.toInterface(_test._x), Go.toInterface(_test._op), Go.toInterface(_test._y), Go.toInterface(_got), Go.toInterface(Go.asInterface(_acc)), Go.toInterface(_test._want));
                };
            };
        };
    }
/**
    // TestFloatCmpSpecialValues tests that Cmp produces the correct results for
    // combinations of zero (0), finite (1 and 2.71828), and infinite (Inf)
    // operands.
**/
function testFloatCmpSpecialValues(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _zero:GoFloat64 = (0 : GoFloat64);
        var _args = (new Slice<GoFloat64>(0, 0, stdgo.math.Math.inf((-1 : GoInt)), (-2.71828 : GoFloat64), (-1 : GoFloat64), -_zero, _zero, (1 : GoFloat64), (2.71828 : GoFloat64), stdgo.math.Math.inf((1 : GoInt))) : Slice<GoFloat64>);
        var _xx = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>);
        var _yy = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < (4 : GoInt), _i++, {
                for (__0 => _x in _args) {
                    _xx.setFloat64(_x);
                    {
                        var __tmp__ = _xx.float64(), _got:GoFloat64 = __tmp__._0, _acc:stdgo.math.big.Big.Accuracy = __tmp__._1;
                        if ((_got != _x) || (_acc != (0 : stdgo.math.big.Big.Accuracy))) {
                            _t.errorf(("Float(%g) == %g (%s)" : GoString), Go.toInterface(_x), Go.toInterface(_got), Go.toInterface(Go.asInterface(_acc)));
                        };
                    };
                    for (__1 => _y in _args) {
                        _yy.setFloat64(_y);
                        var _got:GoInt = _xx.cmp(_yy);
                        var _want:GoInt = (0 : GoInt);
                        if (_x < _y) {
                            _want = (-1 : GoInt);
                        } else if (_x > _y) {
                            _want = (1 : GoInt);
                        };
                        if (_got != (_want)) {
                            _t.errorf(("(%g).Cmp(%g) = %v; want %v" : GoString), Go.toInterface(_x), Go.toInterface(_y), Go.toInterface(_got), Go.toInterface(_want));
                        };
                    };
                };
            });
        };
    }
function benchmarkFloatAdd(_b:Ref<stdgo.testing.Testing.B>):Void {
        var _x = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>);
        var _y = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>);
        var _z = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>);
        for (__0 => _prec in (new Slice<GoUInt>(0, 0, (10u32 : GoUInt), (100u32 : GoUInt), (1000u32 : GoUInt), (10000u32 : GoUInt), (100000u32 : GoUInt)) : Slice<GoUInt>)) {
            _x.setPrec(_prec).setRat(newRat((1i64 : GoInt64), (3i64 : GoInt64)));
            _y.setPrec(_prec).setRat(newRat((1i64 : GoInt64), (6i64 : GoInt64)));
            _z.setPrec(_prec);
            _b.run(stdgo.fmt.Fmt.sprintf(("%v" : GoString), Go.toInterface(_prec)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                _b.reportAllocs();
                {
                    var _i:GoInt = (0 : GoInt);
                    Go.cfor(_i < _b.n, _i++, {
                        _z.add(_x, _y);
                    });
                };
            });
        };
    }
function benchmarkFloatSub(_b:Ref<stdgo.testing.Testing.B>):Void {
        var _x = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>);
        var _y = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>);
        var _z = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>);
        for (__0 => _prec in (new Slice<GoUInt>(0, 0, (10u32 : GoUInt), (100u32 : GoUInt), (1000u32 : GoUInt), (10000u32 : GoUInt), (100000u32 : GoUInt)) : Slice<GoUInt>)) {
            _x.setPrec(_prec).setRat(newRat((1i64 : GoInt64), (3i64 : GoInt64)));
            _y.setPrec(_prec).setRat(newRat((1i64 : GoInt64), (6i64 : GoInt64)));
            _z.setPrec(_prec);
            _b.run(stdgo.fmt.Fmt.sprintf(("%v" : GoString), Go.toInterface(_prec)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                _b.reportAllocs();
                {
                    var _i:GoInt = (0 : GoInt);
                    Go.cfor(_i < _b.n, _i++, {
                        _z.sub(_x, _y);
                    });
                };
            });
        };
    }
/**
    // ParseFloat is like f.Parse(s, base) with f set to the given precision
    // and rounding mode.
**/
function parseFloat(_s:GoString, _base:GoInt, _prec:GoUInt, _mode:RoundingMode):{ var _0 : Ref<Float_>; var _1 : GoInt; var _2 : Error; } {
        var _f:Ref<Float_> = (null : Ref<stdgo.math.big.Big.Float_>), _b:GoInt = (0 : GoInt), _err:Error = (null : Error);
        return (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_prec).setMode(_mode).parse(_s, _base);
    }
function testFloatSetFloat64String(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _inf:GoFloat64 = stdgo.math.Math.inf((0 : GoInt));
        var _nan:GoFloat64 = stdgo.math.Math.naN();
        for (__0 => _test in (new Slice<T__struct_27>(
0,
0,
({ _s : ("0" : GoString), _x : (0 : GoFloat64) } : T__struct_27),
({ _s : ("-0" : GoString), _x : -_zero_ } : T__struct_27),
({ _s : ("+0" : GoString), _x : (0 : GoFloat64) } : T__struct_27),
({ _s : ("1" : GoString), _x : (1 : GoFloat64) } : T__struct_27),
({ _s : ("-1" : GoString), _x : (-1 : GoFloat64) } : T__struct_27),
({ _s : ("+1" : GoString), _x : (1 : GoFloat64) } : T__struct_27),
({ _s : ("1.234" : GoString), _x : (1.234 : GoFloat64) } : T__struct_27),
({ _s : ("-1.234" : GoString), _x : (-1.234 : GoFloat64) } : T__struct_27),
({ _s : ("+1.234" : GoString), _x : (1.234 : GoFloat64) } : T__struct_27),
({ _s : (".1" : GoString), _x : (0.1 : GoFloat64) } : T__struct_27),
({ _s : ("1." : GoString), _x : (1 : GoFloat64) } : T__struct_27),
({ _s : ("+1." : GoString), _x : (1 : GoFloat64) } : T__struct_27),
({ _s : ("0e100" : GoString), _x : (0 : GoFloat64) } : T__struct_27),
({ _s : ("-0e+100" : GoString), _x : -_zero_ } : T__struct_27),
({ _s : ("+0e-100" : GoString), _x : (0 : GoFloat64) } : T__struct_27),
({ _s : ("0E100" : GoString), _x : (0 : GoFloat64) } : T__struct_27),
({ _s : ("-0E+100" : GoString), _x : -_zero_ } : T__struct_27),
({ _s : ("+0E-100" : GoString), _x : (0 : GoFloat64) } : T__struct_27),
({ _s : ("1.e10" : GoString), _x : (1e+10 : GoFloat64) } : T__struct_27),
({ _s : ("1e+10" : GoString), _x : (1e+10 : GoFloat64) } : T__struct_27),
({ _s : ("+1e-10" : GoString), _x : (1e-10 : GoFloat64) } : T__struct_27),
({ _s : ("1E10" : GoString), _x : (1e+10 : GoFloat64) } : T__struct_27),
({ _s : ("1.E+10" : GoString), _x : (1e+10 : GoFloat64) } : T__struct_27),
({ _s : ("+1E-10" : GoString), _x : (1e-10 : GoFloat64) } : T__struct_27),
({ _s : ("Inf" : GoString), _x : _inf } : T__struct_27),
({ _s : ("+Inf" : GoString), _x : _inf } : T__struct_27),
({ _s : ("-Inf" : GoString), _x : -_inf } : T__struct_27),
({ _s : ("inf" : GoString), _x : _inf } : T__struct_27),
({ _s : ("+inf" : GoString), _x : _inf } : T__struct_27),
({ _s : ("-inf" : GoString), _x : -_inf } : T__struct_27),
({ _s : Go.str(), _x : _nan } : T__struct_27),
({ _s : ("-" : GoString), _x : _nan } : T__struct_27),
({ _s : ("0x" : GoString), _x : _nan } : T__struct_27),
({ _s : ("0e" : GoString), _x : _nan } : T__struct_27),
({ _s : ("1.2ef" : GoString), _x : _nan } : T__struct_27),
({ _s : ("2..3" : GoString), _x : _nan } : T__struct_27),
({ _s : ("123.." : GoString), _x : _nan } : T__struct_27),
({ _s : ("infinity" : GoString), _x : _nan } : T__struct_27),
({ _s : ("foobar" : GoString), _x : _nan } : T__struct_27),
({ _s : ("_" : GoString), _x : _nan } : T__struct_27),
({ _s : ("0_" : GoString), _x : _nan } : T__struct_27),
({ _s : ("1__0" : GoString), _x : _nan } : T__struct_27),
({ _s : ("123_." : GoString), _x : _nan } : T__struct_27),
({ _s : ("123._" : GoString), _x : _nan } : T__struct_27),
({ _s : ("123._4" : GoString), _x : _nan } : T__struct_27),
({ _s : ("1_2.3_4_" : GoString), _x : _nan } : T__struct_27),
({ _s : ("_.123" : GoString), _x : _nan } : T__struct_27),
({ _s : ("_123.456" : GoString), _x : _nan } : T__struct_27),
({ _s : ("10._0" : GoString), _x : _nan } : T__struct_27),
({ _s : ("10.0e_0" : GoString), _x : _nan } : T__struct_27),
({ _s : ("10.0e0_" : GoString), _x : _nan } : T__struct_27),
({ _s : ("0P-0__0" : GoString), _x : _nan } : T__struct_27),
({ _s : ("3.14159265" : GoString), _x : (3.14159265 : GoFloat64) } : T__struct_27),
({ _s : ("-687436.79457e-245" : GoString), _x : (-6.8743679457e-240 : GoFloat64) } : T__struct_27),
({ _s : ("-687436.79457E245" : GoString), _x : (-6.8743679457e+250 : GoFloat64) } : T__struct_27),
({ _s : (".0000000000000000000000000000000000000001" : GoString), _x : (1e-40 : GoFloat64) } : T__struct_27),
({ _s : ("+10000000000000000000000000000000000000000e-0" : GoString), _x : (1e+40 : GoFloat64) } : T__struct_27),
({ _s : ("0p0" : GoString), _x : (0 : GoFloat64) } : T__struct_27),
({ _s : ("-0p0" : GoString), _x : -_zero_ } : T__struct_27),
({ _s : ("1p10" : GoString), _x : (1024 : GoFloat64) } : T__struct_27),
({ _s : ("1p+10" : GoString), _x : (1024 : GoFloat64) } : T__struct_27),
({ _s : ("+1p-10" : GoString), _x : (0.0009765625 : GoFloat64) } : T__struct_27),
({ _s : ("1024p-12" : GoString), _x : (0.25 : GoFloat64) } : T__struct_27),
({ _s : ("-1p10" : GoString), _x : (-1024 : GoFloat64) } : T__struct_27),
({ _s : ("1.5p1" : GoString), _x : (3 : GoFloat64) } : T__struct_27),
({ _s : ("0b0" : GoString), _x : (0 : GoFloat64) } : T__struct_27),
({ _s : ("-0b0" : GoString), _x : -_zero_ } : T__struct_27),
({ _s : ("0b0e+10" : GoString), _x : (0 : GoFloat64) } : T__struct_27),
({ _s : ("-0b0e-10" : GoString), _x : -_zero_ } : T__struct_27),
({ _s : ("0b1010" : GoString), _x : (10 : GoFloat64) } : T__struct_27),
({ _s : ("0B1010E2" : GoString), _x : (1000 : GoFloat64) } : T__struct_27),
({ _s : ("0b.1" : GoString), _x : (0.5 : GoFloat64) } : T__struct_27),
({ _s : ("0b.001" : GoString), _x : (0.125 : GoFloat64) } : T__struct_27),
({ _s : ("0b.001e3" : GoString), _x : (125 : GoFloat64) } : T__struct_27),
({ _s : ("0b0p+10" : GoString), _x : (0 : GoFloat64) } : T__struct_27),
({ _s : ("-0b0p-10" : GoString), _x : -_zero_ } : T__struct_27),
({ _s : ("0b.1010p4" : GoString), _x : (10 : GoFloat64) } : T__struct_27),
({ _s : ("0b1p-1" : GoString), _x : (0.5 : GoFloat64) } : T__struct_27),
({ _s : ("0b001p-3" : GoString), _x : (0.125 : GoFloat64) } : T__struct_27),
({ _s : ("0b.001p3" : GoString), _x : (1 : GoFloat64) } : T__struct_27),
({ _s : ("0b0.01p2" : GoString), _x : (1 : GoFloat64) } : T__struct_27),
({ _s : ("0b0.01P+2" : GoString), _x : (1 : GoFloat64) } : T__struct_27),
({ _s : ("0o0" : GoString), _x : (0 : GoFloat64) } : T__struct_27),
({ _s : ("-0o0" : GoString), _x : -_zero_ } : T__struct_27),
({ _s : ("0o0e+10" : GoString), _x : (0 : GoFloat64) } : T__struct_27),
({ _s : ("-0o0e-10" : GoString), _x : -_zero_ } : T__struct_27),
({ _s : ("0o12" : GoString), _x : (10 : GoFloat64) } : T__struct_27),
({ _s : ("0O12E2" : GoString), _x : (1000 : GoFloat64) } : T__struct_27),
({ _s : ("0o.4" : GoString), _x : (0.5 : GoFloat64) } : T__struct_27),
({ _s : ("0o.01" : GoString), _x : (0.015625 : GoFloat64) } : T__struct_27),
({ _s : ("0o.01e3" : GoString), _x : (15.625 : GoFloat64) } : T__struct_27),
({ _s : ("0o0p+10" : GoString), _x : (0 : GoFloat64) } : T__struct_27),
({ _s : ("-0o0p-10" : GoString), _x : -_zero_ } : T__struct_27),
({ _s : ("0o.12p6" : GoString), _x : (10 : GoFloat64) } : T__struct_27),
({ _s : ("0o4p-3" : GoString), _x : (0.5 : GoFloat64) } : T__struct_27),
({ _s : ("0o0014p-6" : GoString), _x : (0.1875 : GoFloat64) } : T__struct_27),
({ _s : ("0o.001p9" : GoString), _x : (1 : GoFloat64) } : T__struct_27),
({ _s : ("0o0.01p7" : GoString), _x : (2 : GoFloat64) } : T__struct_27),
({ _s : ("0O0.01P+2" : GoString), _x : (0.0625 : GoFloat64) } : T__struct_27),
({ _s : ("0x0" : GoString), _x : (0 : GoFloat64) } : T__struct_27),
({ _s : ("-0x0" : GoString), _x : -_zero_ } : T__struct_27),
({ _s : ("0x0p+10" : GoString), _x : (0 : GoFloat64) } : T__struct_27),
({ _s : ("-0x0p-10" : GoString), _x : -_zero_ } : T__struct_27),
({ _s : ("0xff" : GoString), _x : (255 : GoFloat64) } : T__struct_27),
({ _s : ("0X.8p1" : GoString), _x : (1 : GoFloat64) } : T__struct_27),
({ _s : ("-0X0.00008p16" : GoString), _x : (-0.5 : GoFloat64) } : T__struct_27),
({ _s : ("-0X0.00008P+16" : GoString), _x : (-0.5 : GoFloat64) } : T__struct_27),
({ _s : ("0x0.0000000000001p-1022" : GoString), _x : (5e-324 : GoFloat64) } : T__struct_27),
({ _s : ("0x1.fffffffffffffp1023" : GoString), _x : (1.7976931348623157e+308 : GoFloat64) } : T__struct_27),
({ _s : ("0_0" : GoString), _x : (0 : GoFloat64) } : T__struct_27),
({ _s : ("1_000." : GoString), _x : (1000 : GoFloat64) } : T__struct_27),
({ _s : ("1_2_3.4_5_6" : GoString), _x : (123.456 : GoFloat64) } : T__struct_27),
({ _s : ("1.0e0_0" : GoString), _x : (1 : GoFloat64) } : T__struct_27),
({ _s : ("1p+1_0" : GoString), _x : (1024 : GoFloat64) } : T__struct_27),
({ _s : ("0b_1000" : GoString), _x : (8 : GoFloat64) } : T__struct_27),
({ _s : ("0b_1011_1101" : GoString), _x : (189 : GoFloat64) } : T__struct_27),
({ _s : ("0x_f0_0d_1eP+0_8" : GoString), _x : (4.027391488e+09 : GoFloat64) } : T__struct_27)) : Slice<T__struct_27>)) {
            var _x:Float_ = ({} : stdgo.math.big.Big.Float_);
            _x.setPrec((53u32 : GoUInt));
            var __tmp__ = _x.setString(_test._s), __1:Ref<stdgo.math.big.Big.Float_> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (stdgo.math.Math.isNaN(_test._x)) {
                if (_ok) {
                    _t.errorf(("%s: want parse error" : GoString), Go.toInterface(_test._s));
                };
                continue;
            };
            if (!_ok) {
                _t.errorf(("%s: got parse error" : GoString), Go.toInterface(_test._s));
                continue;
            };
            var __tmp__ = _x.float64(), _f:GoFloat64 = __tmp__._0, __2:stdgo.math.big.Big.Accuracy = __tmp__._1;
            var _want = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setFloat64(_test._x);
            if ((_x.cmp(_want) != (0 : GoInt)) || (_x.signbit() != _want.signbit())) {
                _t.errorf(("%s: got %v (%v); want %v" : GoString), Go.toInterface(_test._s), Go.toInterface(Go.asInterface((Go.setRef(_x) : Ref<stdgo.math.big.Big.Float_>))), Go.toInterface(_f), Go.toInterface(_test._x));
            };
        };
    }
private function _fdiv(_a:GoFloat64, _b:GoFloat64):GoFloat64 {
        return _a / _b;
    }
function testFloat64Text(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_28>(
0,
0,
({ _x : (0 : GoFloat64), _format : (102 : GoUInt8), _prec : (0 : GoInt), _want : ("0" : GoString) } : T__struct_28),
({ _x : stdgo.math.Math.copysign((0 : GoFloat64), (-1 : GoFloat64)), _format : (102 : GoUInt8), _prec : (0 : GoInt), _want : ("-0" : GoString) } : T__struct_28),
({ _x : (1 : GoFloat64), _format : (102 : GoUInt8), _prec : (0 : GoInt), _want : ("1" : GoString) } : T__struct_28),
({ _x : (-1 : GoFloat64), _format : (102 : GoUInt8), _prec : (0 : GoInt), _want : ("-1" : GoString) } : T__struct_28),
({ _x : (0.001 : GoFloat64), _format : (101 : GoUInt8), _prec : (0 : GoInt), _want : ("1e-03" : GoString) } : T__struct_28),
({ _x : (0.459 : GoFloat64), _format : (101 : GoUInt8), _prec : (0 : GoInt), _want : ("5e-01" : GoString) } : T__struct_28),
({ _x : (1.459 : GoFloat64), _format : (101 : GoUInt8), _prec : (0 : GoInt), _want : ("1e+00" : GoString) } : T__struct_28),
({ _x : (2.459 : GoFloat64), _format : (101 : GoUInt8), _prec : (1 : GoInt), _want : ("2.5e+00" : GoString) } : T__struct_28),
({ _x : (3.459 : GoFloat64), _format : (101 : GoUInt8), _prec : (2 : GoInt), _want : ("3.46e+00" : GoString) } : T__struct_28),
({ _x : (4.459 : GoFloat64), _format : (101 : GoUInt8), _prec : (3 : GoInt), _want : ("4.459e+00" : GoString) } : T__struct_28),
({ _x : (5.459 : GoFloat64), _format : (101 : GoUInt8), _prec : (4 : GoInt), _want : ("5.4590e+00" : GoString) } : T__struct_28),
({ _x : (0.001 : GoFloat64), _format : (102 : GoUInt8), _prec : (0 : GoInt), _want : ("0" : GoString) } : T__struct_28),
({ _x : (0.459 : GoFloat64), _format : (102 : GoUInt8), _prec : (0 : GoInt), _want : ("0" : GoString) } : T__struct_28),
({ _x : (1.459 : GoFloat64), _format : (102 : GoUInt8), _prec : (0 : GoInt), _want : ("1" : GoString) } : T__struct_28),
({ _x : (2.459 : GoFloat64), _format : (102 : GoUInt8), _prec : (1 : GoInt), _want : ("2.5" : GoString) } : T__struct_28),
({ _x : (3.459 : GoFloat64), _format : (102 : GoUInt8), _prec : (2 : GoInt), _want : ("3.46" : GoString) } : T__struct_28),
({ _x : (4.459 : GoFloat64), _format : (102 : GoUInt8), _prec : (3 : GoInt), _want : ("4.459" : GoString) } : T__struct_28),
({ _x : (5.459 : GoFloat64), _format : (102 : GoUInt8), _prec : (4 : GoInt), _want : ("5.4590" : GoString) } : T__struct_28),
({ _x : (0 : GoFloat64), _format : (98 : GoUInt8), _prec : (0 : GoInt), _want : ("0" : GoString) } : T__struct_28),
({ _x : stdgo.math.Math.copysign((0 : GoFloat64), (-1 : GoFloat64)), _format : (98 : GoUInt8), _prec : (0 : GoInt), _want : ("-0" : GoString) } : T__struct_28),
({ _x : (1 : GoFloat64), _format : (98 : GoUInt8), _prec : (0 : GoInt), _want : ("4503599627370496p-52" : GoString) } : T__struct_28),
({ _x : (-1 : GoFloat64), _format : (98 : GoUInt8), _prec : (0 : GoInt), _want : ("-4503599627370496p-52" : GoString) } : T__struct_28),
({ _x : (4.503599627370496e+15 : GoFloat64), _format : (98 : GoUInt8), _prec : (0 : GoInt), _want : ("4503599627370496p+0" : GoString) } : T__struct_28),
({ _x : (0 : GoFloat64), _format : (112 : GoUInt8), _prec : (0 : GoInt), _want : ("0" : GoString) } : T__struct_28),
({ _x : stdgo.math.Math.copysign((0 : GoFloat64), (-1 : GoFloat64)), _format : (112 : GoUInt8), _prec : (0 : GoInt), _want : ("-0" : GoString) } : T__struct_28),
({ _x : (1024 : GoFloat64), _format : (112 : GoUInt8), _prec : (0 : GoInt), _want : ("0x.8p+11" : GoString) } : T__struct_28),
({ _x : (-1024 : GoFloat64), _format : (112 : GoUInt8), _prec : (0 : GoInt), _want : ("-0x.8p+11" : GoString) } : T__struct_28),
({ _x : (1 : GoFloat64), _format : (101 : GoUInt8), _prec : (5 : GoInt), _want : ("1.00000e+00" : GoString) } : T__struct_28),
({ _x : (1 : GoFloat64), _format : (102 : GoUInt8), _prec : (5 : GoInt), _want : ("1.00000" : GoString) } : T__struct_28),
({ _x : (1 : GoFloat64), _format : (103 : GoUInt8), _prec : (5 : GoInt), _want : ("1" : GoString) } : T__struct_28),
({ _x : (1 : GoFloat64), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("1" : GoString) } : T__struct_28),
({ _x : (20 : GoFloat64), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("20" : GoString) } : T__struct_28),
({ _x : (1.2345678e+06 : GoFloat64), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("1.2345678e+06" : GoString) } : T__struct_28),
({ _x : (200000 : GoFloat64), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("200000" : GoString) } : T__struct_28),
({ _x : (2e+06 : GoFloat64), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("2e+06" : GoString) } : T__struct_28),
({ _x : (400 : GoFloat64), _format : (103 : GoUInt8), _prec : (2 : GoInt), _want : ("4e+02" : GoString) } : T__struct_28),
({ _x : (40 : GoFloat64), _format : (103 : GoUInt8), _prec : (2 : GoInt), _want : ("40" : GoString) } : T__struct_28),
({ _x : (4 : GoFloat64), _format : (103 : GoUInt8), _prec : (2 : GoInt), _want : ("4" : GoString) } : T__struct_28),
({ _x : (0.4 : GoFloat64), _format : (103 : GoUInt8), _prec : (2 : GoInt), _want : ("0.4" : GoString) } : T__struct_28),
({ _x : (0.04 : GoFloat64), _format : (103 : GoUInt8), _prec : (2 : GoInt), _want : ("0.04" : GoString) } : T__struct_28),
({ _x : (0.004 : GoFloat64), _format : (103 : GoUInt8), _prec : (2 : GoInt), _want : ("0.004" : GoString) } : T__struct_28),
({ _x : (0.0004 : GoFloat64), _format : (103 : GoUInt8), _prec : (2 : GoInt), _want : ("0.0004" : GoString) } : T__struct_28),
({ _x : (4e-05 : GoFloat64), _format : (103 : GoUInt8), _prec : (2 : GoInt), _want : ("4e-05" : GoString) } : T__struct_28),
({ _x : (4e-06 : GoFloat64), _format : (103 : GoUInt8), _prec : (2 : GoInt), _want : ("4e-06" : GoString) } : T__struct_28),
({ _x : (0 : GoFloat64), _format : (101 : GoUInt8), _prec : (5 : GoInt), _want : ("0.00000e+00" : GoString) } : T__struct_28),
({ _x : (0 : GoFloat64), _format : (102 : GoUInt8), _prec : (5 : GoInt), _want : ("0.00000" : GoString) } : T__struct_28),
({ _x : (0 : GoFloat64), _format : (103 : GoUInt8), _prec : (5 : GoInt), _want : ("0" : GoString) } : T__struct_28),
({ _x : (0 : GoFloat64), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("0" : GoString) } : T__struct_28),
({ _x : (-1 : GoFloat64), _format : (101 : GoUInt8), _prec : (5 : GoInt), _want : ("-1.00000e+00" : GoString) } : T__struct_28),
({ _x : (-1 : GoFloat64), _format : (102 : GoUInt8), _prec : (5 : GoInt), _want : ("-1.00000" : GoString) } : T__struct_28),
({ _x : (-1 : GoFloat64), _format : (103 : GoUInt8), _prec : (5 : GoInt), _want : ("-1" : GoString) } : T__struct_28),
({ _x : (-1 : GoFloat64), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("-1" : GoString) } : T__struct_28),
({ _x : (12 : GoFloat64), _format : (101 : GoUInt8), _prec : (5 : GoInt), _want : ("1.20000e+01" : GoString) } : T__struct_28),
({ _x : (12 : GoFloat64), _format : (102 : GoUInt8), _prec : (5 : GoInt), _want : ("12.00000" : GoString) } : T__struct_28),
({ _x : (12 : GoFloat64), _format : (103 : GoUInt8), _prec : (5 : GoInt), _want : ("12" : GoString) } : T__struct_28),
({ _x : (12 : GoFloat64), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("12" : GoString) } : T__struct_28),
({ _x : (1.234567e+08 : GoFloat64), _format : (101 : GoUInt8), _prec : (5 : GoInt), _want : ("1.23457e+08" : GoString) } : T__struct_28),
({ _x : (1.234567e+08 : GoFloat64), _format : (102 : GoUInt8), _prec : (5 : GoInt), _want : ("123456700.00000" : GoString) } : T__struct_28),
({ _x : (1.234567e+08 : GoFloat64), _format : (103 : GoUInt8), _prec : (5 : GoInt), _want : ("1.2346e+08" : GoString) } : T__struct_28),
({ _x : (1.234567e+08 : GoFloat64), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("1.234567e+08" : GoString) } : T__struct_28),
({ _x : (1.2345e+06 : GoFloat64), _format : (101 : GoUInt8), _prec : (5 : GoInt), _want : ("1.23450e+06" : GoString) } : T__struct_28),
({ _x : (1.2345e+06 : GoFloat64), _format : (102 : GoUInt8), _prec : (5 : GoInt), _want : ("1234500.00000" : GoString) } : T__struct_28),
({ _x : (1.2345e+06 : GoFloat64), _format : (103 : GoUInt8), _prec : (5 : GoInt), _want : ("1.2345e+06" : GoString) } : T__struct_28),
({ _x : (1e+23 : GoFloat64), _format : (101 : GoUInt8), _prec : (17 : GoInt), _want : ("9.99999999999999916e+22" : GoString) } : T__struct_28),
({ _x : (1e+23 : GoFloat64), _format : (102 : GoUInt8), _prec : (17 : GoInt), _want : ("99999999999999991611392.00000000000000000" : GoString) } : T__struct_28),
({ _x : (1e+23 : GoFloat64), _format : (103 : GoUInt8), _prec : (17 : GoInt), _want : ("9.9999999999999992e+22" : GoString) } : T__struct_28),
({ _x : (1e+23 : GoFloat64), _format : (101 : GoUInt8), _prec : (-1 : GoInt), _want : ("1e+23" : GoString) } : T__struct_28),
({ _x : (1e+23 : GoFloat64), _format : (102 : GoUInt8), _prec : (-1 : GoInt), _want : ("100000000000000000000000" : GoString) } : T__struct_28),
({ _x : (1e+23 : GoFloat64), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("1e+23" : GoString) } : T__struct_28),
({ _x : (9.999999999999997e+22 : GoFloat64), _format : (101 : GoUInt8), _prec : (17 : GoInt), _want : ("9.99999999999999748e+22" : GoString) } : T__struct_28),
({ _x : (9.999999999999997e+22 : GoFloat64), _format : (102 : GoUInt8), _prec : (17 : GoInt), _want : ("99999999999999974834176.00000000000000000" : GoString) } : T__struct_28),
({ _x : (9.999999999999997e+22 : GoFloat64), _format : (103 : GoUInt8), _prec : (17 : GoInt), _want : ("9.9999999999999975e+22" : GoString) } : T__struct_28),
({ _x : (9.999999999999997e+22 : GoFloat64), _format : (101 : GoUInt8), _prec : (-1 : GoInt), _want : ("9.999999999999997e+22" : GoString) } : T__struct_28),
({ _x : (9.999999999999997e+22 : GoFloat64), _format : (102 : GoUInt8), _prec : (-1 : GoInt), _want : ("99999999999999970000000" : GoString) } : T__struct_28),
({ _x : (9.999999999999997e+22 : GoFloat64), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("9.999999999999997e+22" : GoString) } : T__struct_28),
({ _x : (1.0000000000000001e+23 : GoFloat64), _format : (101 : GoUInt8), _prec : (17 : GoInt), _want : ("1.00000000000000008e+23" : GoString) } : T__struct_28),
({ _x : (1.0000000000000001e+23 : GoFloat64), _format : (102 : GoUInt8), _prec : (17 : GoInt), _want : ("100000000000000008388608.00000000000000000" : GoString) } : T__struct_28),
({ _x : (1.0000000000000001e+23 : GoFloat64), _format : (103 : GoUInt8), _prec : (17 : GoInt), _want : ("1.0000000000000001e+23" : GoString) } : T__struct_28),
({ _x : (1.0000000000000001e+23 : GoFloat64), _format : (101 : GoUInt8), _prec : (-1 : GoInt), _want : ("1.0000000000000001e+23" : GoString) } : T__struct_28),
({ _x : (1.0000000000000001e+23 : GoFloat64), _format : (102 : GoUInt8), _prec : (-1 : GoInt), _want : ("100000000000000010000000" : GoString) } : T__struct_28),
({ _x : (1.0000000000000001e+23 : GoFloat64), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("1.0000000000000001e+23" : GoString) } : T__struct_28),
({ _x : (5e-324 : GoFloat64), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("5e-324" : GoString) } : T__struct_28),
({ _x : (-5e-324 : GoFloat64), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("-5e-324" : GoString) } : T__struct_28),
({ _x : _fdiv((5e-304 : GoFloat64), (1e+20 : GoFloat64)), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("5e-324" : GoString) } : T__struct_28),
({ _x : _fdiv((-5e-304 : GoFloat64), (1e+20 : GoFloat64)), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("-5e-324" : GoString) } : T__struct_28),
({ _x : (32 : GoFloat64), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("32" : GoString) } : T__struct_28),
({ _x : (32 : GoFloat64), _format : (103 : GoUInt8), _prec : (0 : GoInt), _want : ("3e+01" : GoString) } : T__struct_28),
({ _x : (100 : GoFloat64), _format : (120 : GoUInt8), _prec : (-1 : GoInt), _want : ("0x1.9p+06" : GoString) } : T__struct_28),
({ _x : stdgo.math.Math.inf((0 : GoInt)), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("+Inf" : GoString) } : T__struct_28),
({ _x : stdgo.math.Math.inf((-1 : GoInt)), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("-Inf" : GoString) } : T__struct_28),
({ _x : -stdgo.math.Math.inf((0 : GoInt)), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("-Inf" : GoString) } : T__struct_28),
({ _x : (-1 : GoFloat64), _format : (98 : GoUInt8), _prec : (-1 : GoInt), _want : ("-4503599627370496p-52" : GoString) } : T__struct_28),
({ _x : (0.9 : GoFloat64), _format : (102 : GoUInt8), _prec : (1 : GoInt), _want : ("0.9" : GoString) } : T__struct_28),
({ _x : (0.09 : GoFloat64), _format : (102 : GoUInt8), _prec : (1 : GoInt), _want : ("0.1" : GoString) } : T__struct_28),
({ _x : (0.0999 : GoFloat64), _format : (102 : GoUInt8), _prec : (1 : GoInt), _want : ("0.1" : GoString) } : T__struct_28),
({ _x : (0.05 : GoFloat64), _format : (102 : GoUInt8), _prec : (1 : GoInt), _want : ("0.1" : GoString) } : T__struct_28),
({ _x : (0.05 : GoFloat64), _format : (102 : GoUInt8), _prec : (0 : GoInt), _want : ("0" : GoString) } : T__struct_28),
({ _x : (0.5 : GoFloat64), _format : (102 : GoUInt8), _prec : (1 : GoInt), _want : ("0.5" : GoString) } : T__struct_28),
({ _x : (0.5 : GoFloat64), _format : (102 : GoUInt8), _prec : (0 : GoInt), _want : ("0" : GoString) } : T__struct_28),
({ _x : (1.5 : GoFloat64), _format : (102 : GoUInt8), _prec : (0 : GoInt), _want : ("2" : GoString) } : T__struct_28),
({ _x : (2.2250738585072014e-308 : GoFloat64), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("2.2250738585072014e-308" : GoString) } : T__struct_28),
({ _x : (2.225073858507201e-308 : GoFloat64), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("2.225073858507201e-308" : GoString) } : T__struct_28),
({ _x : (3.8326057576481645e+17 : GoFloat64), _format : (102 : GoUInt8), _prec : (0 : GoInt), _want : ("383260575764816448" : GoString) } : T__struct_28),
({ _x : (3.8326057576481645e+17 : GoFloat64), _format : (103 : GoUInt8), _prec : (-1 : GoInt), _want : ("3.8326057576481645e+17" : GoString) } : T__struct_28),
({ _x : (1 : GoFloat64), _format : (102 : GoUInt8), _prec : (-10 : GoInt), _want : ("1" : GoString) } : T__struct_28),
({ _x : (1 : GoFloat64), _format : (102 : GoUInt8), _prec : (-11 : GoInt), _want : ("1" : GoString) } : T__struct_28),
({ _x : (1 : GoFloat64), _format : (102 : GoUInt8), _prec : (-12 : GoInt), _want : ("1" : GoString) } : T__struct_28)) : Slice<T__struct_28>)) {
            var _f = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_actualPrec(_test._x)).setFloat64(_test._x);
            var _got:GoString = _f.text(_test._format, _test._prec);
            if (_got != (_test._want)) {
                _t.errorf(("%v: got %s; want %s" : GoString), Go.toInterface(Go.asInterface(_test)), Go.toInterface(_got), Go.toInterface(_test._want));
                continue;
            };
            if ((_test._format == (98 : GoUInt8)) && (_test._x == (0 : GoFloat64))) {
                continue;
            };
            if (_test._format == ((112 : GoUInt8))) {
                continue;
            };
            var _want:GoString = stdgo.strconv.Strconv.formatFloat(_test._x, _test._format, _test._prec, (64 : GoInt));
            if (_got != (_want)) {
                _t.errorf(("%v: got %s; want %s (strconv)" : GoString), Go.toInterface(Go.asInterface(_test)), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
/**
    // actualPrec returns the number of actually used mantissa bits.
**/
private function _actualPrec(_x:GoFloat64):GoUInt {
        {
            var _mant:GoUInt64 = stdgo.math.Math.float64bits(_x);
            if ((_x != (0 : GoFloat64)) && ((_mant & (9218868437227405312i64 : GoUInt64)) == (0i64 : GoUInt64))) {
                return (64u32 : GoUInt) - (stdgo.math.bits.Bits.leadingZeros64(_mant & (4503599627370495i64 : GoUInt64)) : GoUInt);
            };
        };
        return (53u32 : GoUInt);
    }
function testFloatText(_t:Ref<stdgo.testing.Testing.T>):Void {
        {};
        for (__0 => _test in (new Slice<T__struct_29>(
0,
0,
({ _x : ("0" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (10u32 : GoUInt), _format : (102 : GoUInt8), _digits : (0 : GoInt), _want : ("0" : GoString) } : T__struct_29),
({ _x : ("-0" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (10u32 : GoUInt), _format : (102 : GoUInt8), _digits : (0 : GoInt), _want : ("-0" : GoString) } : T__struct_29),
({ _x : ("1" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (10u32 : GoUInt), _format : (102 : GoUInt8), _digits : (0 : GoInt), _want : ("1" : GoString) } : T__struct_29),
({ _x : ("-1" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (10u32 : GoUInt), _format : (102 : GoUInt8), _digits : (0 : GoInt), _want : ("-1" : GoString) } : T__struct_29),
({ _x : ("1.459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (101 : GoUInt8), _digits : (0 : GoInt), _want : ("1e+00" : GoString) } : T__struct_29),
({ _x : ("2.459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (101 : GoUInt8), _digits : (1 : GoInt), _want : ("2.5e+00" : GoString) } : T__struct_29),
({ _x : ("3.459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (101 : GoUInt8), _digits : (2 : GoInt), _want : ("3.46e+00" : GoString) } : T__struct_29),
({ _x : ("4.459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (101 : GoUInt8), _digits : (3 : GoInt), _want : ("4.459e+00" : GoString) } : T__struct_29),
({ _x : ("5.459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (101 : GoUInt8), _digits : (4 : GoInt), _want : ("5.4590e+00" : GoString) } : T__struct_29),
({ _x : ("1.459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (69 : GoUInt8), _digits : (0 : GoInt), _want : ("1E+00" : GoString) } : T__struct_29),
({ _x : ("2.459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (69 : GoUInt8), _digits : (1 : GoInt), _want : ("2.5E+00" : GoString) } : T__struct_29),
({ _x : ("3.459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (69 : GoUInt8), _digits : (2 : GoInt), _want : ("3.46E+00" : GoString) } : T__struct_29),
({ _x : ("4.459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (69 : GoUInt8), _digits : (3 : GoInt), _want : ("4.459E+00" : GoString) } : T__struct_29),
({ _x : ("5.459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (69 : GoUInt8), _digits : (4 : GoInt), _want : ("5.4590E+00" : GoString) } : T__struct_29),
({ _x : ("1.459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (102 : GoUInt8), _digits : (0 : GoInt), _want : ("1" : GoString) } : T__struct_29),
({ _x : ("2.459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (102 : GoUInt8), _digits : (1 : GoInt), _want : ("2.5" : GoString) } : T__struct_29),
({ _x : ("3.459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (102 : GoUInt8), _digits : (2 : GoInt), _want : ("3.46" : GoString) } : T__struct_29),
({ _x : ("4.459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (102 : GoUInt8), _digits : (3 : GoInt), _want : ("4.459" : GoString) } : T__struct_29),
({ _x : ("5.459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (102 : GoUInt8), _digits : (4 : GoInt), _want : ("5.4590" : GoString) } : T__struct_29),
({ _x : ("1.459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (103 : GoUInt8), _digits : (0 : GoInt), _want : ("1" : GoString) } : T__struct_29),
({ _x : ("2.459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (103 : GoUInt8), _digits : (1 : GoInt), _want : ("2" : GoString) } : T__struct_29),
({ _x : ("3.459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (103 : GoUInt8), _digits : (2 : GoInt), _want : ("3.5" : GoString) } : T__struct_29),
({ _x : ("4.459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (103 : GoUInt8), _digits : (3 : GoInt), _want : ("4.46" : GoString) } : T__struct_29),
({ _x : ("5.459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (103 : GoUInt8), _digits : (4 : GoInt), _want : ("5.459" : GoString) } : T__struct_29),
({ _x : ("1459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (103 : GoUInt8), _digits : (0 : GoInt), _want : ("1e+03" : GoString) } : T__struct_29),
({ _x : ("2459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (103 : GoUInt8), _digits : (1 : GoInt), _want : ("2e+03" : GoString) } : T__struct_29),
({ _x : ("3459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (103 : GoUInt8), _digits : (2 : GoInt), _want : ("3.5e+03" : GoString) } : T__struct_29),
({ _x : ("4459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (103 : GoUInt8), _digits : (3 : GoInt), _want : ("4.46e+03" : GoString) } : T__struct_29),
({ _x : ("5459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (103 : GoUInt8), _digits : (4 : GoInt), _want : ("5459" : GoString) } : T__struct_29),
({ _x : ("1459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (71 : GoUInt8), _digits : (0 : GoInt), _want : ("1E+03" : GoString) } : T__struct_29),
({ _x : ("2459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (71 : GoUInt8), _digits : (1 : GoInt), _want : ("2E+03" : GoString) } : T__struct_29),
({ _x : ("3459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (71 : GoUInt8), _digits : (2 : GoInt), _want : ("3.5E+03" : GoString) } : T__struct_29),
({ _x : ("4459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (71 : GoUInt8), _digits : (3 : GoInt), _want : ("4.46E+03" : GoString) } : T__struct_29),
({ _x : ("5459" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (71 : GoUInt8), _digits : (4 : GoInt), _want : ("5459" : GoString) } : T__struct_29),
({ _x : ("3" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (10u32 : GoUInt), _format : (101 : GoUInt8), _digits : (40 : GoInt), _want : ("3.0000000000000000000000000000000000000000e+00" : GoString) } : T__struct_29),
({ _x : ("3" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (10u32 : GoUInt), _format : (102 : GoUInt8), _digits : (40 : GoInt), _want : ("3.0000000000000000000000000000000000000000" : GoString) } : T__struct_29),
({ _x : ("3" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (10u32 : GoUInt), _format : (103 : GoUInt8), _digits : (40 : GoInt), _want : ("3" : GoString) } : T__struct_29),
({ _x : ("3e40" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (101 : GoUInt8), _digits : (40 : GoInt), _want : ("3.0000000000000000000000000000000000000000e+40" : GoString) } : T__struct_29),
({ _x : ("3e40" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (102 : GoUInt8), _digits : (4 : GoInt), _want : ("30000000000000000000000000000000000000000.0000" : GoString) } : T__struct_29),
({ _x : ("3e40" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (100u32 : GoUInt), _format : (103 : GoUInt8), _digits : (40 : GoInt), _want : ("3e+40" : GoString) } : T__struct_29),
({ _x : ("1e1000000" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (112 : GoUInt8), _digits : (0 : GoInt), _want : ("0x.88b3a28a05eade3ap+3321929" : GoString) } : T__struct_29),
({ _x : ("1e646456992" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (112 : GoUInt8), _digits : (0 : GoInt), _want : ("0x.e883a0c5c8c7c42ap+2147483644" : GoString) } : T__struct_29),
({ _x : ("1e646456993" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (112 : GoUInt8), _digits : (0 : GoInt), _want : ("+Inf" : GoString) } : T__struct_29),
({ _x : ("1e1000000000" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (112 : GoUInt8), _digits : (0 : GoInt), _want : ("+Inf" : GoString) } : T__struct_29),
({ _x : ("1e-1000000" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (112 : GoUInt8), _digits : (0 : GoInt), _want : ("0x.efb4542cc8ca418ap-3321928" : GoString) } : T__struct_29),
({ _x : ("1e-646456993" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (112 : GoUInt8), _digits : (0 : GoInt), _want : ("0x.e17c8956983d9d59p-2147483647" : GoString) } : T__struct_29),
({ _x : ("1e-646456994" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (112 : GoUInt8), _digits : (0 : GoInt), _want : ("0" : GoString) } : T__struct_29),
({ _x : ("1e-1000000000" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (112 : GoUInt8), _digits : (0 : GoInt), _want : ("0" : GoString) } : T__struct_29),
({ _x : ("1p2147483646" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (112 : GoUInt8), _digits : (0 : GoInt), _want : ("0x.8p+2147483647" : GoString) } : T__struct_29),
({ _x : ("0x.8p2147483647" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (112 : GoUInt8), _digits : (0 : GoInt), _want : ("0x.8p+2147483647" : GoString) } : T__struct_29),
({ _x : ("0x.8p-2147483647" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (112 : GoUInt8), _digits : (0 : GoInt), _want : ("0x.8p-2147483647" : GoString) } : T__struct_29),
({ _x : ("1p-2147483649" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (112 : GoUInt8), _digits : (0 : GoInt), _want : ("0x.8p-2147483648" : GoString) } : T__struct_29),
({ _x : ("0" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (98 : GoUInt8), _digits : (0 : GoInt), _want : ("0" : GoString) } : T__struct_29),
({ _x : ("-0" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (98 : GoUInt8), _digits : (0 : GoInt), _want : ("-0" : GoString) } : T__struct_29),
({ _x : ("1.0" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (98 : GoUInt8), _digits : (0 : GoInt), _want : ("4503599627370496p-52" : GoString) } : T__struct_29),
({ _x : ("-1.0" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (98 : GoUInt8), _digits : (0 : GoInt), _want : ("-4503599627370496p-52" : GoString) } : T__struct_29),
({ _x : ("4503599627370496" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (98 : GoUInt8), _digits : (0 : GoInt), _want : ("4503599627370496p+0" : GoString) } : T__struct_29),
({ _x : ("3" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (350u32 : GoUInt), _format : (98 : GoUInt8), _digits : (0 : GoInt), _want : ("1720123961992553633708115671476565205597423741876210842803191629540192157066363606052513914832594264915968p-348" : GoString) } : T__struct_29),
({ _x : ("03" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (350u32 : GoUInt), _format : (98 : GoUInt8), _digits : (0 : GoInt), _want : ("1720123961992553633708115671476565205597423741876210842803191629540192157066363606052513914832594264915968p-348" : GoString) } : T__struct_29),
({ _x : ("3." : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (350u32 : GoUInt), _format : (98 : GoUInt8), _digits : (0 : GoInt), _want : ("1720123961992553633708115671476565205597423741876210842803191629540192157066363606052513914832594264915968p-348" : GoString) } : T__struct_29),
({ _x : ("3.0" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (350u32 : GoUInt), _format : (98 : GoUInt8), _digits : (0 : GoInt), _want : ("1720123961992553633708115671476565205597423741876210842803191629540192157066363606052513914832594264915968p-348" : GoString) } : T__struct_29),
({ _x : ("3.00" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (350u32 : GoUInt), _format : (98 : GoUInt8), _digits : (0 : GoInt), _want : ("1720123961992553633708115671476565205597423741876210842803191629540192157066363606052513914832594264915968p-348" : GoString) } : T__struct_29),
({ _x : ("3.000" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (350u32 : GoUInt), _format : (98 : GoUInt8), _digits : (0 : GoInt), _want : ("1720123961992553633708115671476565205597423741876210842803191629540192157066363606052513914832594264915968p-348" : GoString) } : T__struct_29),
({ _x : ("3" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (350u32 : GoUInt), _format : (112 : GoUInt8), _digits : (0 : GoInt), _want : ("0x.cp+2" : GoString) } : T__struct_29),
({ _x : ("03" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (350u32 : GoUInt), _format : (112 : GoUInt8), _digits : (0 : GoInt), _want : ("0x.cp+2" : GoString) } : T__struct_29),
({ _x : ("3." : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (350u32 : GoUInt), _format : (112 : GoUInt8), _digits : (0 : GoInt), _want : ("0x.cp+2" : GoString) } : T__struct_29),
({ _x : ("3.0" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (350u32 : GoUInt), _format : (112 : GoUInt8), _digits : (0 : GoInt), _want : ("0x.cp+2" : GoString) } : T__struct_29),
({ _x : ("3.00" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (350u32 : GoUInt), _format : (112 : GoUInt8), _digits : (0 : GoInt), _want : ("0x.cp+2" : GoString) } : T__struct_29),
({ _x : ("3.000" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (350u32 : GoUInt), _format : (112 : GoUInt8), _digits : (0 : GoInt), _want : ("0x.cp+2" : GoString) } : T__struct_29),
({ _x : ("0" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (112 : GoUInt8), _digits : (0 : GoInt), _want : ("0" : GoString) } : T__struct_29),
({ _x : ("-0" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (112 : GoUInt8), _digits : (0 : GoInt), _want : ("-0" : GoString) } : T__struct_29),
({ _x : ("1024.0" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (112 : GoUInt8), _digits : (0 : GoInt), _want : ("0x.8p+11" : GoString) } : T__struct_29),
({ _x : ("-1024.0" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (112 : GoUInt8), _digits : (0 : GoInt), _want : ("-0x.8p+11" : GoString) } : T__struct_29),
({ _x : ("0" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (120 : GoUInt8), _digits : (-1 : GoInt), _want : ("0x0p+00" : GoString) } : T__struct_29),
({ _x : ("0" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (120 : GoUInt8), _digits : (0 : GoInt), _want : ("0x0p+00" : GoString) } : T__struct_29),
({ _x : ("0" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (120 : GoUInt8), _digits : (1 : GoInt), _want : ("0x0.0p+00" : GoString) } : T__struct_29),
({ _x : ("0" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (120 : GoUInt8), _digits : (5 : GoInt), _want : ("0x0.00000p+00" : GoString) } : T__struct_29),
({ _x : ("3.25" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (120 : GoUInt8), _digits : (0 : GoInt), _want : ("0x1p+02" : GoString) } : T__struct_29),
({ _x : ("-3.25" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (120 : GoUInt8), _digits : (0 : GoInt), _want : ("-0x1p+02" : GoString) } : T__struct_29),
({ _x : ("3.25" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (120 : GoUInt8), _digits : (1 : GoInt), _want : ("0x1.ap+01" : GoString) } : T__struct_29),
({ _x : ("-3.25" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (120 : GoUInt8), _digits : (1 : GoInt), _want : ("-0x1.ap+01" : GoString) } : T__struct_29),
({ _x : ("3.25" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (120 : GoUInt8), _digits : (-1 : GoInt), _want : ("0x1.ap+01" : GoString) } : T__struct_29),
({ _x : ("-3.25" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (120 : GoUInt8), _digits : (-1 : GoInt), _want : ("-0x1.ap+01" : GoString) } : T__struct_29),
({ _x : ("1024.0" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (120 : GoUInt8), _digits : (0 : GoInt), _want : ("0x1p+10" : GoString) } : T__struct_29),
({ _x : ("-1024.0" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (120 : GoUInt8), _digits : (0 : GoInt), _want : ("-0x1p+10" : GoString) } : T__struct_29),
({ _x : ("1024.0" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (64u32 : GoUInt), _format : (120 : GoUInt8), _digits : (5 : GoInt), _want : ("0x1.00000p+10" : GoString) } : T__struct_29),
({ _x : ("8191.0" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (-1 : GoInt), _want : ("0x1.fffp+12" : GoString) } : T__struct_29),
({ _x : ("8191.5" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (-1 : GoInt), _want : ("0x1.fff8p+12" : GoString) } : T__struct_29),
({ _x : ("8191.53125" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (-1 : GoInt), _want : ("0x1.fff88p+12" : GoString) } : T__struct_29),
({ _x : ("8191.53125" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (4 : GoInt), _want : ("0x1.fff8p+12" : GoString) } : T__struct_29),
({ _x : ("8191.53125" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (3 : GoInt), _want : ("0x1.000p+13" : GoString) } : T__struct_29),
({ _x : ("8191.53125" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (0 : GoInt), _want : ("0x1p+13" : GoString) } : T__struct_29),
({ _x : ("8191.533203125" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (-1 : GoInt), _want : ("0x1.fff888p+12" : GoString) } : T__struct_29),
({ _x : ("8191.533203125" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (5 : GoInt), _want : ("0x1.fff88p+12" : GoString) } : T__struct_29),
({ _x : ("8191.533203125" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (4 : GoInt), _want : ("0x1.fff9p+12" : GoString) } : T__struct_29),
({ _x : ("8191.53125" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (-1 : GoInt), _want : ("0x1.fff88p+12" : GoString) } : T__struct_29),
({ _x : ("8191.53125" : GoString), _round : (0 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (5 : GoInt), _want : ("0x1.fff88p+12" : GoString) } : T__struct_29),
({ _x : ("8191.53125" : GoString), _round : (1 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (5 : GoInt), _want : ("0x1.fff88p+12" : GoString) } : T__struct_29),
({ _x : ("8191.53125" : GoString), _round : (2 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (5 : GoInt), _want : ("0x1.fff88p+12" : GoString) } : T__struct_29),
({ _x : ("8191.53125" : GoString), _round : (3 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (5 : GoInt), _want : ("0x1.fff88p+12" : GoString) } : T__struct_29),
({ _x : ("8191.53125" : GoString), _round : (4 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (5 : GoInt), _want : ("0x1.fff88p+12" : GoString) } : T__struct_29),
({ _x : ("8191.53125" : GoString), _round : (5 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (5 : GoInt), _want : ("0x1.fff88p+12" : GoString) } : T__struct_29),
({ _x : ("8191.53125" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (4 : GoInt), _want : ("0x1.fff8p+12" : GoString) } : T__struct_29),
({ _x : ("8191.53125" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (3 : GoInt), _want : ("0x1.000p+13" : GoString) } : T__struct_29),
({ _x : ("8191.53125" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (0 : GoInt), _want : ("0x1p+13" : GoString) } : T__struct_29),
({ _x : ("8191.533203125" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (-1 : GoInt), _want : ("0x1.fff888p+12" : GoString) } : T__struct_29),
({ _x : ("8191.533203125" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (6 : GoInt), _want : ("0x1.fff888p+12" : GoString) } : T__struct_29),
({ _x : ("8191.533203125" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (5 : GoInt), _want : ("0x1.fff88p+12" : GoString) } : T__struct_29),
({ _x : ("8191.533203125" : GoString), _round : (255 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (4 : GoInt), _want : ("0x1.fff9p+12" : GoString) } : T__struct_29),
({ _x : ("8191.53125" : GoString), _round : (0 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (4 : GoInt), _want : ("0x1.fff8p+12" : GoString) } : T__struct_29),
({ _x : ("8191.53125" : GoString), _round : (1 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (4 : GoInt), _want : ("0x1.fff9p+12" : GoString) } : T__struct_29),
({ _x : ("8191.53125" : GoString), _round : (2 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (4 : GoInt), _want : ("0x1.fff8p+12" : GoString) } : T__struct_29),
({ _x : ("8191.53125" : GoString), _round : (2 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (2 : GoInt), _want : ("0x1.ffp+12" : GoString) } : T__struct_29),
({ _x : ("8191.53125" : GoString), _round : (3 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (4 : GoInt), _want : ("0x1.fff9p+12" : GoString) } : T__struct_29),
({ _x : ("8191.53125" : GoString), _round : (4 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (4 : GoInt), _want : ("0x1.fff8p+12" : GoString) } : T__struct_29),
({ _x : ("-8191.53125" : GoString), _round : (4 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (4 : GoInt), _want : ("-0x1.fff9p+12" : GoString) } : T__struct_29),
({ _x : ("8191.53125" : GoString), _round : (5 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (4 : GoInt), _want : ("0x1.fff9p+12" : GoString) } : T__struct_29),
({ _x : ("-8191.53125" : GoString), _round : (5 : stdgo.math.big.Big.RoundingMode), _prec : (53u32 : GoUInt), _format : (120 : GoUInt8), _digits : (4 : GoInt), _want : ("-0x1.fff8p+12" : GoString) } : T__struct_29),
({ _x : ("0x.8p-2147483648" : GoString), _round : (0 : stdgo.math.big.Big.RoundingMode), _prec : (4u32 : GoUInt), _format : (112 : GoUInt8), _digits : (-1 : GoInt), _want : ("0x.8p-2147483648" : GoString) } : T__struct_29),
({ _x : ("0x.8p-2147483648" : GoString), _round : (0 : stdgo.math.big.Big.RoundingMode), _prec : (4u32 : GoUInt), _format : (120 : GoUInt8), _digits : (-1 : GoInt), _want : ("0x1p-2147483649" : GoString) } : T__struct_29)) : Slice<T__struct_29>)) {
            var __tmp__ = parseFloat(_test._x, (0 : GoInt), _test._prec, (0 : stdgo.math.big.Big.RoundingMode)), _f:Ref<stdgo.math.big.Big.Float_> = __tmp__._0, __1:GoInt = __tmp__._1, _err:Error = __tmp__._2;
            if (_err != null) {
                _t.errorf(("%v: %s" : GoString), Go.toInterface(Go.asInterface(_test)), Go.toInterface(_err));
                continue;
            };
            if (_test._round != ((255 : stdgo.math.big.Big.RoundingMode))) {
                _f.setMode(_test._round);
            };
            var _got:GoString = _f.text(_test._format, _test._digits);
            if (_got != (_test._want)) {
                _t.errorf(("%v: got %s; want %s" : GoString), Go.toInterface(Go.asInterface(_test)), Go.toInterface(_got), Go.toInterface(_test._want));
            };
            if ((((_test._prec == (53u32 : GoUInt)) && (_test._format != (112 : GoUInt8))) && (_f.sign() != (0 : GoInt))) && ((_test._round == (0 : stdgo.math.big.Big.RoundingMode)) || (_test._round == (255 : stdgo.math.big.Big.RoundingMode)))) {
                var __tmp__ = _f.float64(), _f64:GoFloat64 = __tmp__._0, _acc:stdgo.math.big.Big.Accuracy = __tmp__._1;
                if (_acc != ((0 : stdgo.math.big.Big.Accuracy))) {
                    _t.errorf(("%v: expected exact conversion to float64" : GoString), Go.toInterface(Go.asInterface(_test)));
                    continue;
                };
                var _got:GoString = stdgo.strconv.Strconv.formatFloat(_f64, _test._format, _test._digits, (64 : GoInt));
                if (_got != (_test._want)) {
                    _t.errorf(("%v: got %s; want %s" : GoString), Go.toInterface(Go.asInterface(_test)), Go.toInterface(_got), Go.toInterface(_test._want));
                };
            };
        };
    }
function testFloatFormat(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_30>(
0,
0,
({ _format : ("%+.3e" : GoString), _value : Go.toInterface((0 : GoFloat64)), _want : ("+0.000e+00" : GoString) } : T__struct_30),
({ _format : ("%+.3e" : GoString), _value : Go.toInterface((1 : GoFloat64)), _want : ("+1.000e+00" : GoString) } : T__struct_30),
({ _format : ("%+.3f" : GoString), _value : Go.toInterface((-1 : GoFloat64)), _want : ("-1.000" : GoString) } : T__struct_30),
({ _format : ("%+.3F" : GoString), _value : Go.toInterface((-1 : GoFloat64)), _want : ("-1.000" : GoString) } : T__struct_30),
({ _format : ("%+.3F" : GoString), _value : Go.toInterface(((-1 : GoFloat64) : GoFloat32)), _want : ("-1.000" : GoString) } : T__struct_30),
({ _format : ("%+07.2f" : GoString), _value : Go.toInterface((1 : GoFloat64)), _want : ("+001.00" : GoString) } : T__struct_30),
({ _format : ("%+07.2f" : GoString), _value : Go.toInterface((-1 : GoFloat64)), _want : ("-001.00" : GoString) } : T__struct_30),
({ _format : ("%+10.2f" : GoString), _value : Go.toInterface((1 : GoFloat64)), _want : ("     +1.00" : GoString) } : T__struct_30),
({ _format : ("%+10.2f" : GoString), _value : Go.toInterface((-1 : GoFloat64)), _want : ("     -1.00" : GoString) } : T__struct_30),
({ _format : ("% .3E" : GoString), _value : Go.toInterface((-1 : GoFloat64)), _want : ("-1.000E+00" : GoString) } : T__struct_30),
({ _format : ("% .3e" : GoString), _value : Go.toInterface((1 : GoFloat64)), _want : (" 1.000e+00" : GoString) } : T__struct_30),
({ _format : ("%+.3g" : GoString), _value : Go.toInterface((0 : GoFloat64)), _want : ("+0" : GoString) } : T__struct_30),
({ _format : ("%+.3g" : GoString), _value : Go.toInterface((1 : GoFloat64)), _want : ("+1" : GoString) } : T__struct_30),
({ _format : ("%+.3g" : GoString), _value : Go.toInterface((-1 : GoFloat64)), _want : ("-1" : GoString) } : T__struct_30),
({ _format : ("% .3g" : GoString), _value : Go.toInterface((-1 : GoFloat64)), _want : ("-1" : GoString) } : T__struct_30),
({ _format : ("% .3g" : GoString), _value : Go.toInterface((1 : GoFloat64)), _want : (" 1" : GoString) } : T__struct_30),
({ _format : ("%b" : GoString), _value : Go.toInterface(((1 : GoFloat64) : GoFloat32)), _want : ("8388608p-23" : GoString) } : T__struct_30),
({ _format : ("%b" : GoString), _value : Go.toInterface((1 : GoFloat64)), _want : ("4503599627370496p-52" : GoString) } : T__struct_30),
({ _format : ("%e" : GoString), _value : Go.toInterface((1 : GoFloat64)), _want : ("1.000000e+00" : GoString) } : T__struct_30),
({ _format : ("%e" : GoString), _value : Go.toInterface((1.2345678e+06 : GoFloat64)), _want : ("1.234568e+06" : GoString) } : T__struct_30),
({ _format : ("%e" : GoString), _value : Go.toInterface((1.2345678e-05 : GoFloat64)), _want : ("1.234568e-05" : GoString) } : T__struct_30),
({ _format : ("%e" : GoString), _value : Go.toInterface((-7 : GoFloat64)), _want : ("-7.000000e+00" : GoString) } : T__struct_30),
({ _format : ("%e" : GoString), _value : Go.toInterface((-1e-09 : GoFloat64)), _want : ("-1.000000e-09" : GoString) } : T__struct_30),
({ _format : ("%f" : GoString), _value : Go.toInterface((1.2345678e+06 : GoFloat64)), _want : ("1234567.800000" : GoString) } : T__struct_30),
({ _format : ("%f" : GoString), _value : Go.toInterface((1.2345678e-05 : GoFloat64)), _want : ("0.000012" : GoString) } : T__struct_30),
({ _format : ("%f" : GoString), _value : Go.toInterface((-7 : GoFloat64)), _want : ("-7.000000" : GoString) } : T__struct_30),
({ _format : ("%f" : GoString), _value : Go.toInterface((-1e-09 : GoFloat64)), _want : ("-0.000000" : GoString) } : T__struct_30),
({ _format : ("%g" : GoString), _value : Go.toInterface((1.2345678e+06 : GoFloat64)), _want : ("1.2345678e+06" : GoString) } : T__struct_30),
({ _format : ("%g" : GoString), _value : Go.toInterface(((1.2345678e+06 : GoFloat64) : GoFloat32)), _want : ("1.2345678e+06" : GoString) } : T__struct_30),
({ _format : ("%g" : GoString), _value : Go.toInterface((1.2345678e-05 : GoFloat64)), _want : ("1.2345678e-05" : GoString) } : T__struct_30),
({ _format : ("%g" : GoString), _value : Go.toInterface((-7 : GoFloat64)), _want : ("-7" : GoString) } : T__struct_30),
({ _format : ("%g" : GoString), _value : Go.toInterface((-1e-09 : GoFloat64)), _want : ("-1e-09" : GoString) } : T__struct_30),
({ _format : ("%g" : GoString), _value : Go.toInterface(((-1e-09 : GoFloat64) : GoFloat32)), _want : ("-1e-09" : GoString) } : T__struct_30),
({ _format : ("%E" : GoString), _value : Go.toInterface((1 : GoFloat64)), _want : ("1.000000E+00" : GoString) } : T__struct_30),
({ _format : ("%E" : GoString), _value : Go.toInterface((1.2345678e+06 : GoFloat64)), _want : ("1.234568E+06" : GoString) } : T__struct_30),
({ _format : ("%E" : GoString), _value : Go.toInterface((1.2345678e-05 : GoFloat64)), _want : ("1.234568E-05" : GoString) } : T__struct_30),
({ _format : ("%E" : GoString), _value : Go.toInterface((-7 : GoFloat64)), _want : ("-7.000000E+00" : GoString) } : T__struct_30),
({ _format : ("%E" : GoString), _value : Go.toInterface((-1e-09 : GoFloat64)), _want : ("-1.000000E-09" : GoString) } : T__struct_30),
({ _format : ("%G" : GoString), _value : Go.toInterface((1.2345678e+06 : GoFloat64)), _want : ("1.2345678E+06" : GoString) } : T__struct_30),
({ _format : ("%G" : GoString), _value : Go.toInterface(((1.2345678e+06 : GoFloat64) : GoFloat32)), _want : ("1.2345678E+06" : GoString) } : T__struct_30),
({ _format : ("%G" : GoString), _value : Go.toInterface((1.2345678e-05 : GoFloat64)), _want : ("1.2345678E-05" : GoString) } : T__struct_30),
({ _format : ("%G" : GoString), _value : Go.toInterface((-7 : GoFloat64)), _want : ("-7" : GoString) } : T__struct_30),
({ _format : ("%G" : GoString), _value : Go.toInterface((-1e-09 : GoFloat64)), _want : ("-1E-09" : GoString) } : T__struct_30),
({ _format : ("%G" : GoString), _value : Go.toInterface(((-1e-09 : GoFloat64) : GoFloat32)), _want : ("-1E-09" : GoString) } : T__struct_30),
({ _format : ("%20.6e" : GoString), _value : Go.toInterface((1234.5 : GoFloat64)), _want : ("        1.234500e+03" : GoString) } : T__struct_30),
({ _format : ("%20.6e" : GoString), _value : Go.toInterface((0.0012345 : GoFloat64)), _want : ("        1.234500e-03" : GoString) } : T__struct_30),
({ _format : ("%20e" : GoString), _value : Go.toInterface((1234.5 : GoFloat64)), _want : ("        1.234500e+03" : GoString) } : T__struct_30),
({ _format : ("%20e" : GoString), _value : Go.toInterface((0.0012345 : GoFloat64)), _want : ("        1.234500e-03" : GoString) } : T__struct_30),
({ _format : ("%20.8e" : GoString), _value : Go.toInterface((1234.5 : GoFloat64)), _want : ("      1.23450000e+03" : GoString) } : T__struct_30),
({ _format : ("%20f" : GoString), _value : Go.toInterface((1234.56789 : GoFloat64)), _want : ("         1234.567890" : GoString) } : T__struct_30),
({ _format : ("%20f" : GoString), _value : Go.toInterface((0.00123456789 : GoFloat64)), _want : ("            0.001235" : GoString) } : T__struct_30),
({ _format : ("%20f" : GoString), _value : Go.toInterface((1.2345678901234568e+10 : GoFloat64)), _want : ("  12345678901.234568" : GoString) } : T__struct_30),
({ _format : ("%-20f" : GoString), _value : Go.toInterface((1234.56789 : GoFloat64)), _want : ("1234.567890         " : GoString) } : T__struct_30),
({ _format : ("%20.8f" : GoString), _value : Go.toInterface((1234.56789 : GoFloat64)), _want : ("       1234.56789000" : GoString) } : T__struct_30),
({ _format : ("%20.8f" : GoString), _value : Go.toInterface((0.00123456789 : GoFloat64)), _want : ("          0.00123457" : GoString) } : T__struct_30),
({ _format : ("%g" : GoString), _value : Go.toInterface((1234.56789 : GoFloat64)), _want : ("1234.56789" : GoString) } : T__struct_30),
({ _format : ("%g" : GoString), _value : Go.toInterface((0.00123456789 : GoFloat64)), _want : ("0.00123456789" : GoString) } : T__struct_30),
({ _format : ("%g" : GoString), _value : Go.toInterface((1.23456789e+20 : GoFloat64)), _want : ("1.23456789e+20" : GoString) } : T__struct_30),
({ _format : ("%20e" : GoString), _value : Go.toInterface(stdgo.math.Math.inf((1 : GoInt))), _want : ("                +Inf" : GoString) } : T__struct_30),
({ _format : ("%-20f" : GoString), _value : Go.toInterface(stdgo.math.Math.inf((-1 : GoInt))), _want : ("-Inf                " : GoString) } : T__struct_30),
({ _format : ("%.2f" : GoString), _value : Go.toInterface((1 : GoFloat64)), _want : ("1.00" : GoString) } : T__struct_30),
({ _format : ("%.2f" : GoString), _value : Go.toInterface((-1 : GoFloat64)), _want : ("-1.00" : GoString) } : T__struct_30),
({ _format : ("% .2f" : GoString), _value : Go.toInterface((1 : GoFloat64)), _want : (" 1.00" : GoString) } : T__struct_30),
({ _format : ("% .2f" : GoString), _value : Go.toInterface((-1 : GoFloat64)), _want : ("-1.00" : GoString) } : T__struct_30),
({ _format : ("%+.2f" : GoString), _value : Go.toInterface((1 : GoFloat64)), _want : ("+1.00" : GoString) } : T__struct_30),
({ _format : ("%+.2f" : GoString), _value : Go.toInterface((-1 : GoFloat64)), _want : ("-1.00" : GoString) } : T__struct_30),
({ _format : ("%7.2f" : GoString), _value : Go.toInterface((1 : GoFloat64)), _want : ("   1.00" : GoString) } : T__struct_30),
({ _format : ("%7.2f" : GoString), _value : Go.toInterface((-1 : GoFloat64)), _want : ("  -1.00" : GoString) } : T__struct_30),
({ _format : ("% 7.2f" : GoString), _value : Go.toInterface((1 : GoFloat64)), _want : ("   1.00" : GoString) } : T__struct_30),
({ _format : ("% 7.2f" : GoString), _value : Go.toInterface((-1 : GoFloat64)), _want : ("  -1.00" : GoString) } : T__struct_30),
({ _format : ("%+7.2f" : GoString), _value : Go.toInterface((1 : GoFloat64)), _want : ("  +1.00" : GoString) } : T__struct_30),
({ _format : ("%+7.2f" : GoString), _value : Go.toInterface((-1 : GoFloat64)), _want : ("  -1.00" : GoString) } : T__struct_30),
({ _format : ("%07.2f" : GoString), _value : Go.toInterface((1 : GoFloat64)), _want : ("0001.00" : GoString) } : T__struct_30),
({ _format : ("%07.2f" : GoString), _value : Go.toInterface((-1 : GoFloat64)), _want : ("-001.00" : GoString) } : T__struct_30),
({ _format : ("% 07.2f" : GoString), _value : Go.toInterface((1 : GoFloat64)), _want : (" 001.00" : GoString) } : T__struct_30),
({ _format : ("% 07.2f" : GoString), _value : Go.toInterface((-1 : GoFloat64)), _want : ("-001.00" : GoString) } : T__struct_30),
({ _format : ("%+07.2f" : GoString), _value : Go.toInterface((1 : GoFloat64)), _want : ("+001.00" : GoString) } : T__struct_30),
({ _format : ("%+07.2f" : GoString), _value : Go.toInterface((-1 : GoFloat64)), _want : ("-001.00" : GoString) } : T__struct_30),
({ _format : ("%020f" : GoString), _value : Go.toInterface(stdgo.math.Math.inf((-1 : GoInt))), _want : ("                -Inf" : GoString) } : T__struct_30),
({ _format : ("%020f" : GoString), _value : Go.toInterface(stdgo.math.Math.inf((1 : GoInt))), _want : ("                +Inf" : GoString) } : T__struct_30),
({ _format : ("% 020f" : GoString), _value : Go.toInterface(stdgo.math.Math.inf((-1 : GoInt))), _want : ("                -Inf" : GoString) } : T__struct_30),
({ _format : ("% 020f" : GoString), _value : Go.toInterface(stdgo.math.Math.inf((1 : GoInt))), _want : ("                 Inf" : GoString) } : T__struct_30),
({ _format : ("%+020f" : GoString), _value : Go.toInterface(stdgo.math.Math.inf((-1 : GoInt))), _want : ("                -Inf" : GoString) } : T__struct_30),
({ _format : ("%+020f" : GoString), _value : Go.toInterface(stdgo.math.Math.inf((1 : GoInt))), _want : ("                +Inf" : GoString) } : T__struct_30),
({ _format : ("%20f" : GoString), _value : Go.toInterface((-1 : GoFloat64)), _want : ("           -1.000000" : GoString) } : T__struct_30),
({ _format : ("%v" : GoString), _value : Go.toInterface((0 : GoFloat64)), _want : ("0" : GoString) } : T__struct_30),
({ _format : ("%v" : GoString), _value : Go.toInterface((-7 : GoFloat64)), _want : ("-7" : GoString) } : T__struct_30),
({ _format : ("%v" : GoString), _value : Go.toInterface((-1e-09 : GoFloat64)), _want : ("-1e-09" : GoString) } : T__struct_30),
({ _format : ("%v" : GoString), _value : Go.toInterface(((-1e-09 : GoFloat64) : GoFloat32)), _want : ("-1e-09" : GoString) } : T__struct_30),
({ _format : ("%010v" : GoString), _value : Go.toInterface((0 : GoFloat64)), _want : ("0000000000" : GoString) } : T__struct_30),
({ _format : ("%.20f" : GoString), _value : Go.toInterface(("1e-20" : GoString)), _want : ("0.00000000000000000001" : GoString) } : T__struct_30),
({ _format : ("%.20f" : GoString), _value : Go.toInterface(("-1e-20" : GoString)), _want : ("-0.00000000000000000001" : GoString) } : T__struct_30),
({ _format : ("%30.20f" : GoString), _value : Go.toInterface(("-1e-20" : GoString)), _want : ("       -0.00000000000000000001" : GoString) } : T__struct_30),
({ _format : ("%030.20f" : GoString), _value : Go.toInterface(("-1e-20" : GoString)), _want : ("-00000000.00000000000000000001" : GoString) } : T__struct_30),
({ _format : ("%030.20f" : GoString), _value : Go.toInterface(("+1e-20" : GoString)), _want : ("000000000.00000000000000000001" : GoString) } : T__struct_30),
({ _format : ("% 030.20f" : GoString), _value : Go.toInterface(("+1e-20" : GoString)), _want : (" 00000000.00000000000000000001" : GoString) } : T__struct_30),
({ _format : ("%s" : GoString), _value : Go.toInterface((1 : GoFloat64)), _want : ("%!s(*big.Float=1)" : GoString) } : T__struct_30)) : Slice<T__struct_30>)) {
            var _value = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>);
            {
                final __type__ = _test._value;
                if (Go.typeEquals((__type__ : GoFloat32))) {
                    var _v:GoFloat32 = __type__ == null ? 0 : __type__.__underlying__() == null ? 0 : __type__ == null ? 0 : __type__.__underlying__().value;
                    _value.setPrec((24u32 : GoUInt)).setFloat64((_v : GoFloat64));
                } else if (Go.typeEquals((__type__ : GoFloat64))) {
                    var _v:GoFloat64 = __type__ == null ? 0 : __type__.__underlying__() == null ? 0 : __type__ == null ? 0 : __type__.__underlying__().value;
                    _value.setPrec((53u32 : GoUInt)).setFloat64(_v);
                } else if (Go.typeEquals((__type__ : GoString))) {
                    var _v:GoString = __type__ == null ? "" : __type__.__underlying__() == null ? "" : __type__ == null ? "" : __type__.__underlying__().value;
                    _value.setPrec((512u32 : GoUInt)).parse(_v, (0 : GoInt));
                } else {
                    var _v:AnyInterface = __type__?.__underlying__();
                    _t.fatalf(("unsupported test value: %v (%T)" : GoString), _v, _v);
                };
            };
            {
                var _got:GoString = stdgo.fmt.Fmt.sprintf(_test._format, Go.toInterface(Go.asInterface(_value)));
                if (_got != (_test._want)) {
                    _t.errorf(("%v: got %q; want %q" : GoString), Go.toInterface(Go.asInterface(_test)), Go.toInterface(_got), Go.toInterface(_test._want));
                };
            };
        };
    }
function benchmarkParseFloatSmallExp(_b:Ref<stdgo.testing.Testing.B>):Void {
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                for (__8 => _s in (new Slice<GoString>(
0,
0,
("1e0" : GoString),
("1e-1" : GoString),
("1e-2" : GoString),
("1e-3" : GoString),
("1e-4" : GoString),
("1e-5" : GoString),
("1e-10" : GoString),
("1e-20" : GoString),
("1e-50" : GoString),
("1e1" : GoString),
("1e2" : GoString),
("1e3" : GoString),
("1e4" : GoString),
("1e5" : GoString),
("1e10" : GoString),
("1e20" : GoString),
("1e50" : GoString)) : Slice<GoString>)) {
                    var _x:Float_ = ({} : stdgo.math.big.Big.Float_);
                    var __tmp__ = _x.parse(_s, (0 : GoInt)), __9:Ref<stdgo.math.big.Big.Float_> = __tmp__._0, __10:GoInt = __tmp__._1, _err:Error = __tmp__._2;
                    if (_err != null) {
                        _b.fatalf(("%s: %v" : GoString), Go.toInterface(_s), Go.toInterface(_err));
                    };
                };
            });
        };
    }
function benchmarkParseFloatLargeExp(_b:Ref<stdgo.testing.Testing.B>):Void {
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                for (__8 => _s in (new Slice<GoString>(
0,
0,
("1e0" : GoString),
("1e-10" : GoString),
("1e-20" : GoString),
("1e-30" : GoString),
("1e-40" : GoString),
("1e-50" : GoString),
("1e-100" : GoString),
("1e-500" : GoString),
("1e-1000" : GoString),
("1e-5000" : GoString),
("1e-10000" : GoString),
("1e10" : GoString),
("1e20" : GoString),
("1e30" : GoString),
("1e40" : GoString),
("1e50" : GoString),
("1e100" : GoString),
("1e500" : GoString),
("1e1000" : GoString),
("1e5000" : GoString),
("1e10000" : GoString)) : Slice<GoString>)) {
                    var _x:Float_ = ({} : stdgo.math.big.Big.Float_);
                    var __tmp__ = _x.parse(_s, (0 : GoInt)), __9:Ref<stdgo.math.big.Big.Float_> = __tmp__._0, __10:GoInt = __tmp__._1, _err:Error = __tmp__._2;
                    if (_err != null) {
                        _b.fatalf(("%s: %v" : GoString), Go.toInterface(_s), Go.toInterface(_err));
                    };
                };
            });
        };
    }
function testFloatScan(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _floatScanTests:Slice<T__struct_31> = {
            var s:Slice<T__struct_31> = new Slice<T__struct_31>(0, 0, ...([for (i in 0 ... 13) ({ _input : ("" : GoString), _format : ("" : GoString), _output : ("" : GoString), _remaining : (0 : GoInt), _wantErr : false } : T__struct_31)]));
            s[0] = ({ _input : ("10.0" : GoString), _format : ("%f" : GoString), _output : ("10" : GoString), _remaining : (0 : GoInt), _wantErr : false } : T__struct_31);
            s[1] = ({ _input : ("23.98+2.0" : GoString), _format : ("%v" : GoString), _output : ("23.98" : GoString), _remaining : (4 : GoInt), _wantErr : false } : T__struct_31);
            s[2] = ({ _input : ("-1+1" : GoString), _format : ("%v" : GoString), _output : ("-1" : GoString), _remaining : (2 : GoInt), _wantErr : false } : T__struct_31);
            s[3] = ({ _input : (" 00000" : GoString), _format : ("%v" : GoString), _output : ("0" : GoString), _remaining : (0 : GoInt), _wantErr : false } : T__struct_31);
            s[4] = ({ _input : ("-123456p-78" : GoString), _format : ("%b" : GoString), _output : ("-4.084816388e-19" : GoString), _remaining : (0 : GoInt), _wantErr : false } : T__struct_31);
            s[5] = ({ _input : ("+123" : GoString), _format : ("%b" : GoString), _output : ("123" : GoString), _remaining : (0 : GoInt), _wantErr : false } : T__struct_31);
            s[6] = ({ _input : ("-1.234e+56" : GoString), _format : ("%e" : GoString), _output : ("-1.234e+56" : GoString), _remaining : (0 : GoInt), _wantErr : false } : T__struct_31);
            s[7] = ({ _input : ("-1.234E-56" : GoString), _format : ("%E" : GoString), _output : ("-1.234e-56" : GoString), _remaining : (0 : GoInt), _wantErr : false } : T__struct_31);
            s[8] = ({ _input : ("-1.234e+567" : GoString), _format : ("%g" : GoString), _output : ("-1.234e+567" : GoString), _remaining : (0 : GoInt), _wantErr : false } : T__struct_31);
            s[9] = ({ _input : ("+1234567891011.234" : GoString), _format : ("%G" : GoString), _output : ("1.234567891e+12" : GoString), _remaining : (0 : GoInt), _wantErr : false } : T__struct_31);
            s[10] = ({ _input : ("Inf" : GoString), _format : ("%v" : GoString), _output : Go.str(), _remaining : (3 : GoInt), _wantErr : true } : T__struct_31);
            s[11] = ({ _input : ("-Inf" : GoString), _format : ("%v" : GoString), _output : Go.str(), _remaining : (3 : GoInt), _wantErr : true } : T__struct_31);
            s[12] = ({ _input : ("-Inf" : GoString), _format : ("%v" : GoString), _output : Go.str(), _remaining : (3 : GoInt), _wantErr : true } : T__struct_31);
            s;
        };
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        for (_i => _test in _floatScanTests) {
            var _x = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>);
            _buf.reset();
            _buf.writeString(_test._input);
            var __tmp__ = stdgo.fmt.Fmt.fscanf(Go.asInterface((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>)), _test._format, Go.toInterface(Go.asInterface(_x))), __0:GoInt = __tmp__._0, _err:Error = __tmp__._1;
            if (_test._wantErr) {
                if (_err == null) {
                    _t.errorf(("#%d want non-nil err" : GoString), Go.toInterface(_i));
                };
                continue;
            };
            if (_err != null) {
                _t.errorf(("#%d error: %s" : GoString), Go.toInterface(_i), Go.toInterface(_err));
            };
            if ((_x.string() : GoString) != (_test._output)) {
                _t.errorf(("#%d got %s; want %s" : GoString), Go.toInterface(_i), Go.toInterface((_x.string() : GoString)), Go.toInterface(_test._output));
            };
            if (_buf.len() != (_test._remaining)) {
                _t.errorf(("#%d got %d bytes remaining; want %d" : GoString), Go.toInterface(_i), Go.toInterface(_buf.len()), Go.toInterface(_test._remaining));
            };
        };
    }
function testFloatGobEncoding(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _medium:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        var _enc = stdgo.encoding.gob.Gob.newEncoder(Go.asInterface((Go.setRef(_medium) : Ref<stdgo.bytes.Bytes.Buffer>)));
        var _dec = stdgo.encoding.gob.Gob.newDecoder(Go.asInterface((Go.setRef(_medium) : Ref<stdgo.bytes.Bytes.Buffer>)));
        for (__0 => _test in _floatVals) {
            for (__1 => _sign in (new Slice<GoString>(0, 0, Go.str(), ("+" : GoString), ("-" : GoString)) : Slice<GoString>)) {
                for (__2 => _prec in (new Slice<GoUInt>(0, 0, (0u32 : GoUInt), (1u32 : GoUInt), (2u32 : GoUInt), (10u32 : GoUInt), (53u32 : GoUInt), (64u32 : GoUInt), (100u32 : GoUInt), (1000u32 : GoUInt)) : Slice<GoUInt>)) {
                    for (__3 => _mode in (new Slice<stdgo.math.big.Big.RoundingMode>(0, 0, (0 : stdgo.math.big.Big.RoundingMode), (1 : stdgo.math.big.Big.RoundingMode), (2 : stdgo.math.big.Big.RoundingMode), (3 : stdgo.math.big.Big.RoundingMode), (4 : stdgo.math.big.Big.RoundingMode), (5 : stdgo.math.big.Big.RoundingMode)) : Slice<stdgo.math.big.Big.RoundingMode>)) {
                        _medium.reset();
                        var _x:GoString = _sign + _test;
                        var _tx:Float_ = ({} : stdgo.math.big.Big.Float_);
                        var __tmp__ = _tx.setPrec(_prec).setMode(_mode).parse(_x, (0 : GoInt)), __4:Ref<stdgo.math.big.Big.Float_> = __tmp__._0, __5:GoInt = __tmp__._1, _err:Error = __tmp__._2;
                        if (_err != null) {
                            _t.errorf(("parsing of %s (%dbits, %v) failed (invalid test case): %v" : GoString), Go.toInterface(_x), Go.toInterface(_prec), Go.toInterface(Go.asInterface(_mode)), Go.toInterface(_err));
                            continue;
                        };
                        if (_prec == ((0u32 : GoUInt))) {
                            _tx.setPrec((0u32 : GoUInt));
                        };
                        {
                            var _err:Error = _enc.encode(Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Float_>))));
                            if (_err != null) {
                                _t.errorf(("encoding of %v (%dbits, %v) failed: %v" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Float_>))), Go.toInterface(_prec), Go.toInterface(Go.asInterface(_mode)), Go.toInterface(_err));
                                continue;
                            };
                        };
                        var _rx:Float_ = ({} : stdgo.math.big.Big.Float_);
                        {
                            var _err:Error = _dec.decode(Go.toInterface(Go.asInterface((Go.setRef(_rx) : Ref<stdgo.math.big.Big.Float_>))));
                            if (_err != null) {
                                _t.errorf(("decoding of %v (%dbits, %v) failed: %v" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Float_>))), Go.toInterface(_prec), Go.toInterface(Go.asInterface(_mode)), Go.toInterface(_err));
                                continue;
                            };
                        };
                        if (_rx.cmp((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Float_>)) != ((0 : GoInt))) {
                            _t.errorf(("transmission of %s failed: got %s want %s" : GoString), Go.toInterface(_x), Go.toInterface((_rx.string() : GoString)), Go.toInterface((_tx.string() : GoString)));
                            continue;
                        };
                        if (_rx.prec() != (_prec)) {
                            _t.errorf(("transmission of %s\'s prec failed: got %d want %d" : GoString), Go.toInterface(_x), Go.toInterface(_rx.prec()), Go.toInterface(_prec));
                        };
                        if (_rx.mode() != (_mode)) {
                            _t.errorf(("transmission of %s\'s mode failed: got %s want %s" : GoString), Go.toInterface(_x), Go.toInterface(Go.asInterface(_rx.mode())), Go.toInterface(Go.asInterface(_mode)));
                        };
                        if (_rx.acc() != (_tx.acc())) {
                            _t.errorf(("transmission of %s\'s accuracy failed: got %s want %s" : GoString), Go.toInterface(_x), Go.toInterface(Go.asInterface(_rx.acc())), Go.toInterface(Go.asInterface(_tx.acc())));
                        };
                    };
                };
            };
        };
    }
function testFloatCorruptGob(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        var _tx = newFloat((1 : GoFloat64)).setPrec((1000u32 : GoUInt)).setMode((5 : stdgo.math.big.Big.RoundingMode));
        {
            var _err:Error = stdgo.encoding.gob.Gob.newEncoder(Go.asInterface((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>))).encode(Go.toInterface(Go.asInterface(_tx)));
            if (_err != null) {
                _t.fatal(Go.toInterface(_err));
            };
        };
        var _b = _buf.bytes();
        var _rx:Float_ = ({} : stdgo.math.big.Big.Float_);
        {
            var _err:Error = stdgo.encoding.gob.Gob.newDecoder(Go.asInterface(stdgo.bytes.Bytes.newReader(_b))).decode(Go.toInterface(Go.asInterface((Go.setRef(_rx) : Ref<stdgo.math.big.Big.Float_>))));
            if (_err != null) {
                _t.fatal(Go.toInterface(_err));
            };
        };
        {
            var _err:Error = stdgo.encoding.gob.Gob.newDecoder(Go.asInterface(stdgo.bytes.Bytes.newReader((_b.__slice__(0, (10 : GoInt)) : Slice<GoUInt8>)))).decode(Go.toInterface(Go.asInterface((Go.setRef(_rx) : Ref<stdgo.math.big.Big.Float_>))));
            if (Go.toInterface(_err) != (Go.toInterface(stdgo.io.Io.errUnexpectedEOF))) {
                _t.errorf(("got %v want EOF" : GoString), Go.toInterface(_err));
            };
        };
        _b[(1 : GoInt)] = (0 : GoUInt8);
        {
            var _err:Error = stdgo.encoding.gob.Gob.newDecoder(Go.asInterface(stdgo.bytes.Bytes.newReader(_b))).decode(Go.toInterface(Go.asInterface((Go.setRef(_rx) : Ref<stdgo.math.big.Big.Float_>))));
            if (_err == null) {
                _t.fatal(Go.toInterface(("got nil want version error" : GoString)));
            };
        };
    }
function testFloatJSONEncoding(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in _floatVals) {
            for (__1 => _sign in (new Slice<GoString>(0, 0, Go.str(), ("+" : GoString), ("-" : GoString)) : Slice<GoString>)) {
                for (__2 => _prec in (new Slice<GoUInt>(0, 0, (0u32 : GoUInt), (1u32 : GoUInt), (2u32 : GoUInt), (10u32 : GoUInt), (53u32 : GoUInt), (64u32 : GoUInt), (100u32 : GoUInt), (1000u32 : GoUInt)) : Slice<GoUInt>)) {
                    if ((_prec > (53u32 : GoUInt)) && stdgo.testing.Testing.short()) {
                        continue;
                    };
                    var _x:GoString = _sign + _test;
                    var _tx:Float_ = ({} : stdgo.math.big.Big.Float_);
                    var __tmp__ = _tx.setPrec(_prec).parse(_x, (0 : GoInt)), __3:Ref<stdgo.math.big.Big.Float_> = __tmp__._0, __4:GoInt = __tmp__._1, _err:Error = __tmp__._2;
                    if (_err != null) {
                        _t.errorf(("parsing of %s (prec = %d) failed (invalid test case): %v" : GoString), Go.toInterface(_x), Go.toInterface(_prec), Go.toInterface(_err));
                        continue;
                    };
                    var __tmp__ = stdgo.encoding.json.Json.marshal(Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Float_>)))), _b:Slice<GoUInt8> = __tmp__._0, _err:Error = __tmp__._1;
                    if (_err != null) {
                        _t.errorf(("marshaling of %v (prec = %d) failed: %v" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Float_>))), Go.toInterface(_prec), Go.toInterface(_err));
                        continue;
                    };
                    var _rx:Float_ = ({} : stdgo.math.big.Big.Float_);
                    _rx.setPrec(_prec);
                    {
                        var _err:Error = stdgo.encoding.json.Json.unmarshal(_b, Go.toInterface(Go.asInterface((Go.setRef(_rx) : Ref<stdgo.math.big.Big.Float_>))));
                        if (_err != null) {
                            _t.errorf(("unmarshaling of %v (prec = %d) failed: %v" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Float_>))), Go.toInterface(_prec), Go.toInterface(_err));
                            continue;
                        };
                    };
                    if (_rx.cmp((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Float_>)) != ((0 : GoInt))) {
                        _t.errorf(("JSON encoding of %v (prec = %d) failed: got %v want %v" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Float_>))), Go.toInterface(_prec), Go.toInterface(Go.asInterface((Go.setRef(_rx) : Ref<stdgo.math.big.Big.Float_>))), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Float_>))));
                    };
                };
            };
        };
    }
function testFloatGobDecodeShortBuffer(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _tc in (new Slice<Slice<GoUInt8>>(0, 0, (new Slice<GoUInt8>(0, 0, (1 : GoUInt8), (0 : GoUInt8), (0 : GoUInt8), (0 : GoUInt8)) : Slice<GoUInt8>), (new Slice<GoUInt8>(0, 0, (1 : GoUInt8), (250 : GoUInt8), (0 : GoUInt8), (0 : GoUInt8), (0 : GoUInt8), (0 : GoUInt8)) : Slice<GoUInt8>)) : Slice<Slice<GoUInt8>>)) {
            var _err:Error = newFloat((0 : GoFloat64)).gobDecode(_tc);
            if (_err == null) {
                _t.error(Go.toInterface(("expected GobDecode to return error for malformed input" : GoString)));
            };
        };
    }
private function _roundShortest(_d:Ref<T_decimal>, _x:Ref<Float_>):Void {
        if ((_d._mant.length) == ((0 : GoInt))) {
            return;
        };
        var _mant:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._set(_x._mant);
        var _exp:GoInt = (_x._exp : GoInt) - _mant._bitLen();
        var _s:GoInt = _mant._bitLen() - (_x._prec + (1u32 : GoUInt32) : GoInt);
        if (_s < (0 : GoInt)) {
            _mant = _mant._shl(_mant, (-_s : GoUInt));
        } else if (_s > (0 : GoInt)) {
            _mant = _mant._shr(_mant, (_s : GoUInt));
        };
        _exp = _exp + (_s);
        var _lower:T_decimal = ({} : stdgo.math.big.Big.T_decimal);
        var _tmp:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
        _lower._init(_tmp._sub(_mant, _natOne), _exp);
        var _upper:T_decimal = ({} : stdgo.math.big.Big.T_decimal);
        _upper._init(_tmp._add(_mant, _natOne), _exp);
        var _inclusive:Bool = _mant[(0 : GoInt)] & (2u32 : stdgo.math.big.Big.Word) == ((0u32 : stdgo.math.big.Big.Word));
        for (_i => _m in _d._mant) {
            var _l:GoUInt8 = _lower._at(_i);
            var _u:GoUInt8 = _upper._at(_i);
            var _okdown:Bool = (_l != _m) || (_inclusive && ((_i + (1 : GoInt)) == (_lower._mant.length)));
            var _okup:Bool = (_m != _u) && ((_inclusive || ((_m + (1 : GoUInt8)) < _u)) || ((_i + (1 : GoInt)) < _upper._mant.length));
            if (_okdown && _okup) {
                _d._round(_i + (1 : GoInt));
                return;
            } else if (_okdown) {
                _d._roundDown(_i + (1 : GoInt));
                return;
            } else if (_okup) {
                _d._roundUp(_i + (1 : GoInt));
                return;
            };
        };
    }
/**
    // %e: d.dddddedd
**/
private function _fmtE(_buf:Slice<GoByte>, _fmt:GoByte, _prec:GoInt, _d:T_decimal):Slice<GoByte> {
        var _ch:GoUInt8 = ((48 : GoUInt8) : GoByte);
        if ((_d._mant.length) > (0 : GoInt)) {
            _ch = _d._mant[(0 : GoInt)];
        };
        _buf = _buf.__appendref__(_ch);
        if (_prec > (0 : GoInt)) {
            _buf = _buf.__appendref__((46 : GoUInt8));
            var _i:GoInt = (1 : GoInt);
            var _m:GoInt = _min((_d._mant.length), _prec + (1 : GoInt));
            if (_i < _m) {
                _buf = _buf.__appendref__(...(_d._mant.__slice__(_i, _m) : Slice<GoUInt8>).__toArray__());
                _i = _m;
            };
            Go.cfor(_i <= _prec, _i++, {
                _buf = _buf.__appendref__((48 : GoUInt8));
            });
        };
        _buf = _buf.__appendref__(_fmt);
        var _exp:GoInt64 = (0 : GoInt64);
        if ((_d._mant.length) > (0 : GoInt)) {
            _exp = (_d._exp : GoInt64) - (1i64 : GoInt64);
        };
        if (_exp < (0i64 : GoInt64)) {
            _ch = (45 : GoUInt8);
            _exp = -_exp;
        } else {
            _ch = (43 : GoUInt8);
        };
        _buf = _buf.__appendref__(_ch);
        if (_exp < (10i64 : GoInt64)) {
            _buf = _buf.__appendref__((48 : GoUInt8));
        };
        return stdgo.strconv.Strconv.appendInt(_buf, _exp, (10 : GoInt));
    }
/**
    // %f: ddddddd.ddddd
**/
private function _fmtF(_buf:Slice<GoByte>, _prec:GoInt, _d:T_decimal):Slice<GoByte> {
        if (_d._exp > (0 : GoInt)) {
            var _m:GoInt = _min((_d._mant.length), _d._exp);
            _buf = _buf.__appendref__(...(_d._mant.__slice__(0, _m) : Slice<GoUInt8>).__toArray__());
            Go.cfor(_m < _d._exp, _m++, {
                _buf = _buf.__appendref__((48 : GoUInt8));
            });
        } else {
            _buf = _buf.__appendref__((48 : GoUInt8));
        };
        if (_prec > (0 : GoInt)) {
            _buf = _buf.__appendref__((46 : GoUInt8));
            {
                var _i:GoInt = (0 : GoInt);
                Go.cfor(_i < _prec, _i++, {
                    _buf = _buf.__appendref__(_d._at(_d._exp + _i));
                });
            };
        };
        return _buf;
    }
private function _min(_x:GoInt, _y:GoInt):GoInt {
        if (_x < _y) {
            return _x;
        };
        return _y;
    }
/**
    // randInt returns a pseudo-random Int in the range [1<<(size-1), (1<<size) - 1]
**/
private function _randInt(_r:Ref<stdgo.math.rand.Rand.Rand>, _size:GoUInt):Ref<Int_> {
        var _n = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).lsh(_intOne, _size - (1u32 : GoUInt));
        var _x = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).rand(_r, _n);
        return _x.add(_x, _n);
    }
private function _runGCD(_b:Ref<stdgo.testing.Testing.B>, _aSize:GoUInt, _bSize:GoUInt):Void {
        if (_isRaceBuilder && ((_aSize > (1000u32 : GoUInt)) || (_bSize > (1000u32 : GoUInt)))) {
            _b.skip(Go.toInterface(("skipping on race builder" : GoString)));
        };
        _b.run(("WithoutXY" : GoString), function(_b:Ref<stdgo.testing.Testing.B>):Void {
            _runGCDExt(_b, _aSize, _bSize, false);
        });
        _b.run(("WithXY" : GoString), function(_b:Ref<stdgo.testing.Testing.B>):Void {
            _runGCDExt(_b, _aSize, _bSize, true);
        });
    }
private function _runGCDExt(_b:Ref<stdgo.testing.Testing.B>, _aSize:GoUInt, _bSize:GoUInt, _calcXY:Bool):Void {
        _b.stopTimer();
        var _r:Ref<stdgo.math.rand.Rand.Rand> = stdgo.math.rand.Rand.new_(stdgo.math.rand.Rand.newSource((1234i64 : GoInt64)));
        var _aa = _randInt(_r, _aSize);
        var _bb = _randInt(_r, _bSize);
        var __0:Ref<Int_> = (null : Ref<stdgo.math.big.Big.Int_>), __1:Ref<Int_> = (null : Ref<stdgo.math.big.Big.Int_>), _y:Ref<Int_> = __1, _x:Ref<Int_> = __0;
        if (_calcXY) {
            _x = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
            _y = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        };
        _b.startTimer();
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).gcd(_x, _y, _aa, _bb);
            });
        };
    }
function benchmarkGCD10x10(_b:Ref<stdgo.testing.Testing.B>):Void {
        _runGCD(_b, (10u32 : GoUInt), (10u32 : GoUInt));
    }
function benchmarkGCD10x100(_b:Ref<stdgo.testing.Testing.B>):Void {
        _runGCD(_b, (10u32 : GoUInt), (100u32 : GoUInt));
    }
function benchmarkGCD10x1000(_b:Ref<stdgo.testing.Testing.B>):Void {
        _runGCD(_b, (10u32 : GoUInt), (1000u32 : GoUInt));
    }
function benchmarkGCD10x10000(_b:Ref<stdgo.testing.Testing.B>):Void {
        _runGCD(_b, (10u32 : GoUInt), (10000u32 : GoUInt));
    }
function benchmarkGCD10x100000(_b:Ref<stdgo.testing.Testing.B>):Void {
        _runGCD(_b, (10u32 : GoUInt), (100000u32 : GoUInt));
    }
function benchmarkGCD100x100(_b:Ref<stdgo.testing.Testing.B>):Void {
        _runGCD(_b, (100u32 : GoUInt), (100u32 : GoUInt));
    }
function benchmarkGCD100x1000(_b:Ref<stdgo.testing.Testing.B>):Void {
        _runGCD(_b, (100u32 : GoUInt), (1000u32 : GoUInt));
    }
function benchmarkGCD100x10000(_b:Ref<stdgo.testing.Testing.B>):Void {
        _runGCD(_b, (100u32 : GoUInt), (10000u32 : GoUInt));
    }
function benchmarkGCD100x100000(_b:Ref<stdgo.testing.Testing.B>):Void {
        _runGCD(_b, (100u32 : GoUInt), (100000u32 : GoUInt));
    }
function benchmarkGCD1000x1000(_b:Ref<stdgo.testing.Testing.B>):Void {
        _runGCD(_b, (1000u32 : GoUInt), (1000u32 : GoUInt));
    }
function benchmarkGCD1000x10000(_b:Ref<stdgo.testing.Testing.B>):Void {
        _runGCD(_b, (1000u32 : GoUInt), (10000u32 : GoUInt));
    }
function benchmarkGCD1000x100000(_b:Ref<stdgo.testing.Testing.B>):Void {
        _runGCD(_b, (1000u32 : GoUInt), (100000u32 : GoUInt));
    }
function benchmarkGCD10000x10000(_b:Ref<stdgo.testing.Testing.B>):Void {
        _runGCD(_b, (10000u32 : GoUInt), (10000u32 : GoUInt));
    }
function benchmarkGCD10000x100000(_b:Ref<stdgo.testing.Testing.B>):Void {
        _runGCD(_b, (10000u32 : GoUInt), (100000u32 : GoUInt));
    }
function benchmarkGCD100000x100000(_b:Ref<stdgo.testing.Testing.B>):Void {
        _runGCD(_b, (100000u32 : GoUInt), (100000u32 : GoUInt));
    }
private function _newMatrix(_n:GoInt, _m:GoInt):Ref<T_matrix> {
        if (!(((0 : GoInt) <= _n) && ((0 : GoInt) <= _m))) {
            throw Go.toInterface(("illegal matrix" : GoString));
        };
        var _a = (Go.setRef(({} : stdgo.math.big.Big.T_matrix)) : Ref<stdgo.math.big.Big.T_matrix>);
        _a._n = _n;
        _a._m = _m;
        _a._a = new Slice<Ref<stdgo.math.big.Big.Rat>>((_n * _m : GoInt).toBasic(), 0, ...[for (i in 0 ... (_n * _m : GoInt).toBasic()) (null : Ref<stdgo.math.big.Big.Rat>)]);
        return _a;
    }
private function _newUnit(_n:GoInt):Ref<T_matrix> {
        var _a = _newMatrix(_n, _n);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _n, _i++, {
                {
                    var _j:GoInt = (0 : GoInt);
                    Go.cfor(_j < _n, _j++, {
                        var _x = newRat((0i64 : GoInt64), (1i64 : GoInt64));
                        if (_i == (_j)) {
                            _x.setInt64((1i64 : GoInt64));
                        };
                        _a._set(_i, _j, _x);
                    });
                };
            });
        };
        return _a;
    }
private function _newHilbert(_n:GoInt):Ref<T_matrix> {
        var _a = _newMatrix(_n, _n);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _n, _i++, {
                {
                    var _j:GoInt = (0 : GoInt);
                    Go.cfor(_j < _n, _j++, {
                        _a._set(_i, _j, newRat((1i64 : GoInt64), ((_i + _j) + (1 : GoInt) : GoInt64)));
                    });
                };
            });
        };
        return _a;
    }
private function _newInverseHilbert(_n:GoInt):Ref<T_matrix> {
        var _a = _newMatrix(_n, _n);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _n, _i++, {
                {
                    var _j:GoInt = (0 : GoInt);
                    Go.cfor(_j < _n, _j++, {
                        var _x1 = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setInt64(((_i + _j) + (1 : GoInt) : GoInt64));
                        var _x2 = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setInt((Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).binomial((_n + _i : GoInt64), ((_n - _j) - (1 : GoInt) : GoInt64)));
                        var _x3 = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setInt((Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).binomial((_n + _j : GoInt64), ((_n - _i) - (1 : GoInt) : GoInt64)));
                        var _x4 = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setInt((Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).binomial((_i + _j : GoInt64), (_i : GoInt64)));
                        _x1.mul(_x1, _x2);
                        _x1.mul(_x1, _x3);
                        _x1.mul(_x1, _x4);
                        _x1.mul(_x1, _x4);
                        if ((_i + _j) & (1 : GoInt) != ((0 : GoInt))) {
                            _x1.neg(_x1);
                        };
                        _a._set(_i, _j, _x1);
                    });
                };
            });
        };
        return _a;
    }
private function _doHilbert(_t:Ref<stdgo.testing.Testing.T>, _n:GoInt):Void {
        var _a = _newHilbert(_n);
        var _b = _newInverseHilbert(_n);
        var i = _newUnit(_n);
        var _ab = _a._mul(_b);
        if (!_ab._eql(i)) {
            if (_t == null || (_t : Dynamic).__nil__) {
                throw Go.toInterface(("Hilbert failed" : GoString));
            };
            _t.errorf(("a   = %s\n" : GoString), Go.toInterface(Go.asInterface(_a)));
            _t.errorf(("b   = %s\n" : GoString), Go.toInterface(Go.asInterface(_b)));
            _t.errorf(("a*b = %s\n" : GoString), Go.toInterface(Go.asInterface(_ab)));
            _t.errorf(("I   = %s\n" : GoString), Go.toInterface(Go.asInterface(i)));
        };
    }
function testHilbert(_t:Ref<stdgo.testing.Testing.T>):Void {
        _doHilbert(_t, (10 : GoInt));
    }
function benchmarkHilbert(_b:Ref<stdgo.testing.Testing.B>):Void {
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                _doHilbert(null, (10 : GoInt));
            });
        };
    }
/**
    // NewInt allocates and returns a new Int set to x.
**/
function newInt(_x:GoInt64):Ref<Int_> {
        var _u:GoUInt64 = (_x : GoUInt64);
        if (_x < (0i64 : GoInt64)) {
            _u = -_u;
        };
        var _abs:Slice<Word> = (null : Slice<stdgo.math.big.Big.Word>);
        if (_x == ((0i64 : GoInt64))) {} else if (true && ((_u >> (32i64 : GoUInt64)) != (0i64 : GoUInt64))) {
            _abs = (new Slice<stdgo.math.big.Big.Word>(0, 0, (_u : Word), (_u >> (32i64 : GoUInt64) : Word)) : Slice<stdgo.math.big.Big.Word>);
        } else {
            _abs = (new Slice<stdgo.math.big.Big.Word>(0, 0, (_u : Word)) : Slice<stdgo.math.big.Big.Word>);
        };
        return (Go.setRef(({ _neg : _x < (0i64 : GoInt64), _abs : _abs } : Int_)) : Ref<stdgo.math.big.Big.Int_>);
    }
/**
    // low32 returns the least significant 32 bits of x.
**/
private function _low32(_x:T_nat):GoUInt32 {
        if ((_x.length) == ((0 : GoInt))) {
            return (0u32 : GoUInt32);
        };
        return (_x[(0 : GoInt)] : GoUInt32);
    }
/**
    // low64 returns the least significant 64 bits of x.
**/
private function _low64(_x:T_nat):GoUInt64 {
        if ((_x.length) == ((0 : GoInt))) {
            return (0i64 : GoUInt64);
        };
        var _v:GoUInt64 = (_x[(0 : GoInt)] : GoUInt64);
        if (true && (_x.length > (1 : GoInt))) {
            return ((_x[(1 : GoInt)] : GoUInt64) << (32i64 : GoUInt64)) | _v;
        };
        return _v;
    }
/**
    // lehmerSimulate attempts to simulate several Euclidean update steps
    // using the leading digits of A and B.  It returns u0, u1, v0, v1
    // such that A and B can be updated as:
    //
    //	A = u0*A + v0*B
    //	B = u1*A + v1*B
    //
    // Requirements: A >= B and len(B.abs) >= 2
    // Since we are calculating with full words to avoid overflow,
    // we use 'even' to track the sign of the cosequences.
    // For even iterations: u0, v1 >= 0 && u1, v0 <= 0
    // For odd  iterations: u0, v1 <= 0 && u1, v0 >= 0
**/
private function _lehmerSimulate(a:Ref<Int_>, b:Ref<Int_>):{ var _0 : Word; var _1 : Word; var _2 : Word; var _3 : Word; var _4 : Bool; } {
        var _u0:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word), _u1:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word), _v0:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word), _v1:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word), _even:Bool = false;
        var __0:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word), __1:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word), __2:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word), __3:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word), _v2:Word = __3, _u2:Word = __2, _a2:Word = __1, _a1:Word = __0;
        var _m:GoInt = (b._abs.length);
        var _n:GoInt = (a._abs.length);
        var _h:GoUInt = _nlz(a._abs[(_n - (1 : GoInt) : GoInt)]);
        _a1 = (a._abs[(_n - (1 : GoInt) : GoInt)] << _h) | (a._abs[(_n - (2 : GoInt) : GoInt)] >> ((32u32 : GoUInt) - _h));
        if (_n == (_m)) {
            _a2 = (b._abs[(_n - (1 : GoInt) : GoInt)] << _h) | (b._abs[(_n - (2 : GoInt) : GoInt)] >> ((32u32 : GoUInt) - _h));
        } else if (_n == (_m + (1 : GoInt))) {
            _a2 = b._abs[(_n - (2 : GoInt) : GoInt)] >> ((32u32 : GoUInt) - _h);
        } else {
            _a2 = (0u32 : stdgo.math.big.Big.Word);
        };
        _even = false;
        {
            final __tmp__0 = (0u32 : stdgo.math.big.Big.Word);
            final __tmp__1 = (1u32 : stdgo.math.big.Big.Word);
            final __tmp__2 = (0u32 : stdgo.math.big.Big.Word);
            _u0 = __tmp__0;
            _u1 = __tmp__1;
            _u2 = __tmp__2;
        };
        {
            final __tmp__0 = (0u32 : stdgo.math.big.Big.Word);
            final __tmp__1 = (0u32 : stdgo.math.big.Big.Word);
            final __tmp__2 = (1u32 : stdgo.math.big.Big.Word);
            _v0 = __tmp__0;
            _v1 = __tmp__1;
            _v2 = __tmp__2;
        };
        while ((_a2 >= _v2) && ((_a1 - _a2) >= (_v1 + _v2))) {
            var __0:stdgo.math.big.Big.Word = _a1 / _a2, __1:stdgo.math.big.Big.Word = _a1 % _a2, _r:stdgo.math.big.Big.Word = __1, _q:stdgo.math.big.Big.Word = __0;
            {
                final __tmp__0 = _a2;
                final __tmp__1 = _r;
                _a1 = __tmp__0;
                _a2 = __tmp__1;
            };
            {
                final __tmp__0 = _u1;
                final __tmp__1 = _u2;
                final __tmp__2 = _u1 + (_q * _u2);
                _u0 = __tmp__0;
                _u1 = __tmp__1;
                _u2 = __tmp__2;
            };
            {
                final __tmp__0 = _v1;
                final __tmp__1 = _v2;
                final __tmp__2 = _v1 + (_q * _v2);
                _v0 = __tmp__0;
                _v1 = __tmp__1;
                _v2 = __tmp__2;
            };
            _even = !_even;
        };
        return { _0 : _u0, _1 : _u1, _2 : _v0, _3 : _v1, _4 : _even };
    }
/**
    // lehmerUpdate updates the inputs A and B such that:
    //
    //	A = u0*A + v0*B
    //	B = u1*A + v1*B
    //
    // where the signs of u0, u1, v0, v1 are given by even
    // For even == true: u0, v1 >= 0 && u1, v0 <= 0
    // For even == false: u0, v1 <= 0 && u1, v0 >= 0
    // q, r, s, t are temporary variables to avoid allocations in the multiplication.
**/
private function _lehmerUpdate(a:Ref<Int_>, b:Ref<Int_>, _q:Ref<Int_>, _r:Ref<Int_>, _s:Ref<Int_>, _t:Ref<Int_>, _u0:Word, _u1:Word, _v0:Word, _v1:Word, _even:Bool):Void {
        _t._abs = _t._abs._setWord(_u0);
        _s._abs = _s._abs._setWord(_v0);
        _t._neg = !_even;
        _s._neg = _even;
        _t.mul(a, _t);
        _s.mul(b, _s);
        _r._abs = _r._abs._setWord(_u1);
        _q._abs = _q._abs._setWord(_v1);
        _r._neg = _even;
        _q._neg = !_even;
        _r.mul(a, _r);
        _q.mul(b, _q);
        a.add(_t, _s);
        b.add(_r, _q);
    }
/**
    // euclidUpdate performs a single step of the Euclidean GCD algorithm
    // if extended is true, it also updates the cosequence Ua, Ub.
**/
private function _euclidUpdate(a:Ref<Int_>, b:Ref<Int_>, ua:Ref<Int_>, ub:Ref<Int_>, _q:Ref<Int_>, _r:Ref<Int_>, _s:Ref<Int_>, _t:Ref<Int_>, _extended:Bool):Void {
        {
            var __tmp__ = _q.quoRem(a, b, _r);
            _q = __tmp__._0;
            _r = __tmp__._1;
        };
        {
            var __tmp__ = (b : stdgo.math.big.Big.Int_)?.__copy__();
            a._neg = __tmp__._neg;
            a._abs = __tmp__._abs;
        };
        if (_extended) {
            _t.set(ub);
            _s.mul(ub, _q);
            ub.sub(ua, _s);
            ua.set(_t);
        };
    }
/**
    // Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0.
    // The y argument must be an odd integer.
**/
function jacobi(_x:Ref<Int_>, _y:Ref<Int_>):GoInt {
        if ((_y._abs.length == (0 : GoInt)) || ((_y._abs[(0 : GoInt)] & (1u32 : stdgo.math.big.Big.Word)) == (0u32 : stdgo.math.big.Big.Word))) {
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("big: invalid 2nd argument to Int.Jacobi: need odd integer but got %s" : GoString), Go.toInterface((_y.string() : GoString))));
        };
        var __0:Int_ = ({} : stdgo.math.big.Big.Int_), __1:Int_ = ({} : stdgo.math.big.Big.Int_), __2:Int_ = ({} : stdgo.math.big.Big.Int_), _c:Int_ = __2, _b:Int_ = __1, _a:Int_ = __0;
        _a.set(_x);
        _b.set(_y);
        var _j:GoInt = (1 : GoInt);
        if (_b._neg) {
            if (_a._neg) {
                _j = (-1 : GoInt);
            };
            _b._neg = false;
        };
        while (true) {
            if (_b.cmp(_intOne) == ((0 : GoInt))) {
                return _j;
            };
            if ((_a._abs.length) == ((0 : GoInt))) {
                return (0 : GoInt);
            };
            _a.mod((Go.setRef(_a) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_b) : Ref<stdgo.math.big.Big.Int_>));
            if ((_a._abs.length) == ((0 : GoInt))) {
                return (0 : GoInt);
            };
            var _s:GoUInt = _a._abs._trailingZeroBits();
            if (_s & (1u32 : GoUInt) != ((0u32 : GoUInt))) {
                var _bmod8:stdgo.math.big.Big.Word = _b._abs[(0 : GoInt)] & (7u32 : stdgo.math.big.Big.Word);
                if ((_bmod8 == (3u32 : stdgo.math.big.Big.Word)) || (_bmod8 == (5u32 : stdgo.math.big.Big.Word))) {
                    _j = -_j;
                };
            };
            _c.rsh((Go.setRef(_a) : Ref<stdgo.math.big.Big.Int_>), _s);
            if (((_b._abs[(0 : GoInt)] & (3u32 : stdgo.math.big.Big.Word)) == (3u32 : stdgo.math.big.Big.Word)) && ((_c._abs[(0 : GoInt)] & (3u32 : stdgo.math.big.Big.Word)) == (3u32 : stdgo.math.big.Big.Word))) {
                _j = -_j;
            };
            _a.set((Go.setRef(_b) : Ref<stdgo.math.big.Big.Int_>));
            _b.set((Go.setRef(_c) : Ref<stdgo.math.big.Big.Int_>));
        };
    }
private function _isNormalized(_x:Ref<Int_>):Bool {
        if ((_x._abs.length) == ((0 : GoInt))) {
            return !_x._neg;
        };
        return _x._abs[((_x._abs.length) - (1 : GoInt) : GoInt)] != ((0u32 : stdgo.math.big.Big.Word));
    }
function testSignZ(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _zero:Int_ = ({} : stdgo.math.big.Big.Int_);
        for (__0 => _a in _sumZZ) {
            var _s:GoInt = _a._z.sign();
            var _e:GoInt = _a._z.cmp((Go.setRef(_zero) : Ref<stdgo.math.big.Big.Int_>));
            if (_s != (_e)) {
                _t.errorf(("got %d; want %d for z = %v" : GoString), Go.toInterface(_s), Go.toInterface(_e), Go.toInterface(Go.asInterface(_a._z)));
            };
        };
    }
function testSetZ(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _a in _sumZZ) {
            var _z:Int_ = ({} : stdgo.math.big.Big.Int_);
            _z.set(_a._z);
            if (!_isNormalized((Go.setRef(_z) : Ref<stdgo.math.big.Big.Int_>))) {
                _t.errorf(("%v is not normalized" : GoString), Go.toInterface(Go.asInterface(_z)));
            };
            if ((Go.setRef(_z) : Ref<stdgo.math.big.Big.Int_>).cmp(_a._z) != ((0 : GoInt))) {
                _t.errorf(("got z = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_z)), Go.toInterface(Go.asInterface(_a._z)));
            };
        };
    }
function testAbsZ(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _zero:Int_ = ({} : stdgo.math.big.Big.Int_);
        for (__0 => _a in _sumZZ) {
            var _z:Int_ = ({} : stdgo.math.big.Big.Int_);
            _z.abs(_a._z);
            var _e:Int_ = ({} : stdgo.math.big.Big.Int_);
            _e.set(_a._z);
            if (_e.cmp((Go.setRef(_zero) : Ref<stdgo.math.big.Big.Int_>)) < (0 : GoInt)) {
                _e.sub((Go.setRef(_zero) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_e) : Ref<stdgo.math.big.Big.Int_>));
            };
            if (_z.cmp((Go.setRef(_e) : Ref<stdgo.math.big.Big.Int_>)) != ((0 : GoInt))) {
                _t.errorf(("got z = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_z)), Go.toInterface(Go.asInterface(_e)));
            };
        };
    }
private function _testFunZZ(_t:Ref<stdgo.testing.Testing.T>, _msg:GoString, _f:T_funZZ, _a:T_argZZ):Void {
        var _z:Int_ = ({} : stdgo.math.big.Big.Int_);
        _f((Go.setRef(_z) : Ref<stdgo.math.big.Big.Int_>), _a._x, _a._y);
        if (!_isNormalized((Go.setRef(_z) : Ref<stdgo.math.big.Big.Int_>))) {
            _t.errorf(("%s%v is not normalized" : GoString), Go.toInterface(_msg), Go.toInterface(Go.asInterface(_z)));
        };
        if ((Go.setRef(_z) : Ref<stdgo.math.big.Big.Int_>).cmp(_a._z) != ((0 : GoInt))) {
            _t.errorf(("%v %s %v\n\tgot z = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_a._x)), Go.toInterface(_msg), Go.toInterface(Go.asInterface(_a._y)), Go.toInterface(Go.asInterface((Go.setRef(_z) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(Go.asInterface(_a._z)));
        };
    }
function testSumZZ(_t:Ref<stdgo.testing.Testing.T>):Void {
        var addZZ = function(_z:Ref<Int_>, _x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> {
            return _z.add(_x, _y);
        };
        var subZZ = function(_z:Ref<Int_>, _x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> {
            return _z.sub(_x, _y);
        };
        for (__0 => _a in _sumZZ) {
            var _arg:stdgo.math.big.Big.T_argZZ = _a?.__copy__();
            _testFunZZ(_t, ("AddZZ" : GoString), addZZ, _arg?.__copy__());
            _arg = (new T_argZZ(_a._z, _a._y, _a._x) : T_argZZ);
            _testFunZZ(_t, ("AddZZ symmetric" : GoString), addZZ, _arg?.__copy__());
            _arg = (new T_argZZ(_a._x, _a._z, _a._y) : T_argZZ);
            _testFunZZ(_t, ("SubZZ" : GoString), subZZ, _arg?.__copy__());
            _arg = (new T_argZZ(_a._y, _a._z, _a._x) : T_argZZ);
            _testFunZZ(_t, ("SubZZ symmetric" : GoString), subZZ, _arg?.__copy__());
        };
    }
function testProdZZ(_t:Ref<stdgo.testing.Testing.T>):Void {
        var mulZZ = function(_z:Ref<Int_>, _x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> {
            return _z.mul(_x, _y);
        };
        for (__0 => _a in _prodZZ) {
            var _arg:stdgo.math.big.Big.T_argZZ = _a?.__copy__();
            _testFunZZ(_t, ("MulZZ" : GoString), mulZZ, _arg?.__copy__());
            _arg = (new T_argZZ(_a._z, _a._y, _a._x) : T_argZZ);
            _testFunZZ(_t, ("MulZZ symmetric" : GoString), mulZZ, _arg?.__copy__());
        };
    }
/**
    // mulBytes returns x*y via grade school multiplication. Both inputs
    // and the result are assumed to be in big-endian representation (to
    // match the semantics of Int.Bytes and Int.SetBytes).
**/
private function _mulBytes(_x:Slice<GoByte>, _y:Slice<GoByte>):Slice<GoByte> {
        var _z = new Slice<GoUInt8>(((_x.length) + (_y.length) : GoInt).toBasic(), 0, ...[for (i in 0 ... ((_x.length) + (_y.length) : GoInt).toBasic()) (0 : GoUInt8)]);
        var _k0:GoInt = (_z.length) - (1 : GoInt);
        {
            var _j:GoInt = (_y.length) - (1 : GoInt);
            Go.cfor(_j >= (0 : GoInt), _j--, {
                var _d:GoInt = (_y[(_j : GoInt)] : GoInt);
                if (_d != ((0 : GoInt))) {
                    var _k:GoInt = _k0;
                    var _carry:GoInt = (0 : GoInt);
                    {
                        var _i:GoInt = (_x.length) - (1 : GoInt);
                        Go.cfor(_i >= (0 : GoInt), _i--, {
                            var _t:GoInt = ((_z[(_k : GoInt)] : GoInt) + ((_x[(_i : GoInt)] : GoInt) * _d)) + _carry;
                            {
                                final __tmp__0 = (_t : GoByte);
                                final __tmp__1 = _t >> (8i64 : GoUInt64);
                                _z[(_k : GoInt)] = __tmp__0;
                                _carry = __tmp__1;
                            };
                            _k--;
                        });
                    };
                    _z[(_k : GoInt)] = (_carry : GoByte);
                };
                _k0--;
            });
        };
        var _i:GoInt = (0 : GoInt);
        while ((_i < _z.length) && (_z[(_i : GoInt)] == (0 : GoUInt8))) {
            _i++;
        };
        return (_z.__slice__(_i) : Slice<GoUInt8>);
    }
private function _checkMul(_a:Slice<GoByte>, _b:Slice<GoByte>):Bool {
        var __0:Int_ = ({} : stdgo.math.big.Big.Int_), __1:Int_ = ({} : stdgo.math.big.Big.Int_), __2:Int_ = ({} : stdgo.math.big.Big.Int_), _z1:Int_ = __2, _y:Int_ = __1, _x:Int_ = __0;
        _x.setBytes(_a);
        _y.setBytes(_b);
        _z1.mul((Go.setRef(_x) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_y) : Ref<stdgo.math.big.Big.Int_>));
        var _z2:Int_ = ({} : stdgo.math.big.Big.Int_);
        _z2.setBytes(_mulBytes(_a, _b));
        return _z1.cmp((Go.setRef(_z2) : Ref<stdgo.math.big.Big.Int_>)) == ((0 : GoInt));
    }
function testMul(_t:Ref<stdgo.testing.Testing.T>):Void {
        {
            var _err:Error = stdgo.testing.quick.Quick.check(Go.toInterface(_checkMul), null);
            if (_err != null) {
                _t.error(Go.toInterface(_err));
            };
        };
    }
function testMulRangeZ(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _tmp:Int_ = ({} : stdgo.math.big.Big.Int_);
        for (_i => _r in _mulRangesN) {
            var _prod:GoString = (_tmp.mulRange((_r._a : GoInt64), (_r._b : GoInt64)).string() : GoString);
            if (_prod != (_r._prod)) {
                _t.errorf(("#%da: got %s; want %s" : GoString), Go.toInterface(_i), Go.toInterface(_prod), Go.toInterface(_r._prod));
            };
        };
        for (_i => _r in _mulRangesZ) {
            var _prod:GoString = (_tmp.mulRange(_r._a, _r._b).string() : GoString);
            if (_prod != (_r._prod)) {
                _t.errorf(("#%db: got %s; want %s" : GoString), Go.toInterface(_i), Go.toInterface(_prod), Go.toInterface(_r._prod));
            };
        };
    }
function testBinomial(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _z:Int_ = ({} : stdgo.math.big.Big.Int_);
        for (__0 => _test in (new Slice<T__struct_33>(
0,
0,
({ _n : (0i64 : GoInt64), _k : (0i64 : GoInt64), _want : ("1" : GoString) } : T__struct_33),
({ _n : (0i64 : GoInt64), _k : (1i64 : GoInt64), _want : ("0" : GoString) } : T__struct_33),
({ _n : (1i64 : GoInt64), _k : (0i64 : GoInt64), _want : ("1" : GoString) } : T__struct_33),
({ _n : (1i64 : GoInt64), _k : (1i64 : GoInt64), _want : ("1" : GoString) } : T__struct_33),
({ _n : (1i64 : GoInt64), _k : (10i64 : GoInt64), _want : ("0" : GoString) } : T__struct_33),
({ _n : (4i64 : GoInt64), _k : (0i64 : GoInt64), _want : ("1" : GoString) } : T__struct_33),
({ _n : (4i64 : GoInt64), _k : (1i64 : GoInt64), _want : ("4" : GoString) } : T__struct_33),
({ _n : (4i64 : GoInt64), _k : (2i64 : GoInt64), _want : ("6" : GoString) } : T__struct_33),
({ _n : (4i64 : GoInt64), _k : (3i64 : GoInt64), _want : ("4" : GoString) } : T__struct_33),
({ _n : (4i64 : GoInt64), _k : (4i64 : GoInt64), _want : ("1" : GoString) } : T__struct_33),
({ _n : (10i64 : GoInt64), _k : (1i64 : GoInt64), _want : ("10" : GoString) } : T__struct_33),
({ _n : (10i64 : GoInt64), _k : (9i64 : GoInt64), _want : ("10" : GoString) } : T__struct_33),
({ _n : (10i64 : GoInt64), _k : (5i64 : GoInt64), _want : ("252" : GoString) } : T__struct_33),
({ _n : (11i64 : GoInt64), _k : (5i64 : GoInt64), _want : ("462" : GoString) } : T__struct_33),
({ _n : (11i64 : GoInt64), _k : (6i64 : GoInt64), _want : ("462" : GoString) } : T__struct_33),
({ _n : (100i64 : GoInt64), _k : (10i64 : GoInt64), _want : ("17310309456440" : GoString) } : T__struct_33),
({ _n : (100i64 : GoInt64), _k : (90i64 : GoInt64), _want : ("17310309456440" : GoString) } : T__struct_33),
({ _n : (1000i64 : GoInt64), _k : (10i64 : GoInt64), _want : ("263409560461970212832400" : GoString) } : T__struct_33),
({ _n : (1000i64 : GoInt64), _k : (990i64 : GoInt64), _want : ("263409560461970212832400" : GoString) } : T__struct_33)) : Slice<T__struct_33>)) {
            {
                var _got:GoString = (_z.binomial(_test._n, _test._k).string() : GoString);
                if (_got != (_test._want)) {
                    _t.errorf(("Binomial(%d, %d) = %s; want %s" : GoString), Go.toInterface(_test._n), Go.toInterface(_test._k), Go.toInterface(_got), Go.toInterface(_test._want));
                };
            };
        };
    }
function benchmarkBinomial(_b:Ref<stdgo.testing.Testing.B>):Void {
        var _z:Int_ = ({} : stdgo.math.big.Big.Int_);
        {
            var _i:GoInt = _b.n - (1 : GoInt);
            Go.cfor(_i >= (0 : GoInt), _i--, {
                _z.binomial((1000i64 : GoInt64), (990i64 : GoInt64));
            });
        };
    }
function testDivisionSigns(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _test in _divisionSignsTests) {
            var _x = newInt(_test._x);
            var _y = newInt(_test._y);
            var _q = newInt(_test._q);
            var _r = newInt(_test._r);
            var _d = newInt(_test._d);
            var _m = newInt(_test._m);
            var _q1 = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).quo(_x, _y);
            var _r1 = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).rem(_x, _y);
            if (!_isNormalized(_q1)) {
                _t.errorf(("#%d Quo: %v is not normalized" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface((_q1 : stdgo.math.big.Big.Int_))));
            };
            if (!_isNormalized(_r1)) {
                _t.errorf(("#%d Rem: %v is not normalized" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface((_r1 : stdgo.math.big.Big.Int_))));
            };
            if ((_q1.cmp(_q) != (0 : GoInt)) || (_r1.cmp(_r) != (0 : GoInt))) {
                _t.errorf(("#%d QuoRem: got (%s, %s), want (%s, %s)" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface(_q1)), Go.toInterface(Go.asInterface(_r1)), Go.toInterface(Go.asInterface(_q)), Go.toInterface(Go.asInterface(_r)));
            };
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).quoRem(_x, _y, (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>)), _q2:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, _r2:Ref<stdgo.math.big.Big.Int_> = __tmp__._1;
            if (!_isNormalized(_q2)) {
                _t.errorf(("#%d Quo: %v is not normalized" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface((_q2 : stdgo.math.big.Big.Int_))));
            };
            if (!_isNormalized(_r2)) {
                _t.errorf(("#%d Rem: %v is not normalized" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface((_r2 : stdgo.math.big.Big.Int_))));
            };
            if ((_q2.cmp(_q) != (0 : GoInt)) || (_r2.cmp(_r) != (0 : GoInt))) {
                _t.errorf(("#%d QuoRem: got (%s, %s), want (%s, %s)" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface(_q2)), Go.toInterface(Go.asInterface(_r2)), Go.toInterface(Go.asInterface(_q)), Go.toInterface(Go.asInterface(_r)));
            };
            var _d1 = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).div(_x, _y);
            var _m1 = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).mod(_x, _y);
            if (!_isNormalized(_d1)) {
                _t.errorf(("#%d Div: %v is not normalized" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface((_d1 : stdgo.math.big.Big.Int_))));
            };
            if (!_isNormalized(_m1)) {
                _t.errorf(("#%d Mod: %v is not normalized" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface((_m1 : stdgo.math.big.Big.Int_))));
            };
            if ((_d1.cmp(_d) != (0 : GoInt)) || (_m1.cmp(_m) != (0 : GoInt))) {
                _t.errorf(("#%d DivMod: got (%s, %s), want (%s, %s)" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface(_d1)), Go.toInterface(Go.asInterface(_m1)), Go.toInterface(Go.asInterface(_d)), Go.toInterface(Go.asInterface(_m)));
            };
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).divMod(_x, _y, (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>)), _d2:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, _m2:Ref<stdgo.math.big.Big.Int_> = __tmp__._1;
            if (!_isNormalized(_d2)) {
                _t.errorf(("#%d Div: %v is not normalized" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface((_d2 : stdgo.math.big.Big.Int_))));
            };
            if (!_isNormalized(_m2)) {
                _t.errorf(("#%d Mod: %v is not normalized" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface((_m2 : stdgo.math.big.Big.Int_))));
            };
            if ((_d2.cmp(_d) != (0 : GoInt)) || (_m2.cmp(_m) != (0 : GoInt))) {
                _t.errorf(("#%d DivMod: got (%s, %s), want (%s, %s)" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface(_d2)), Go.toInterface(Go.asInterface(_m2)), Go.toInterface(Go.asInterface(_d)), Go.toInterface(Go.asInterface(_m)));
            };
        };
    }
private function _norm(_x:T_nat):T_nat {
        var _i:GoInt = (_x.length);
        while ((_i > (0 : GoInt)) && (_x[(_i - (1 : GoInt) : GoInt)] == (0u32 : stdgo.math.big.Big.Word))) {
            _i--;
        };
        return (_x.__slice__(0, _i) : stdgo.math.big.Big.T_nat);
    }
function testBits(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<stdgo.math.big.Big.T_nat>(0, 0, null, (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (1u32 : stdgo.math.big.Big.Word), (2u32 : stdgo.math.big.Big.Word), (3u32 : stdgo.math.big.Big.Word), (4u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (4u32 : stdgo.math.big.Big.Word), (3u32 : stdgo.math.big.Big.Word), (2u32 : stdgo.math.big.Big.Word), (1u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat), (new Slice<stdgo.math.big.Big.Word>(0, 0, (4u32 : stdgo.math.big.Big.Word), (3u32 : stdgo.math.big.Big.Word), (2u32 : stdgo.math.big.Big.Word), (1u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat)) : Slice<stdgo.math.big.Big.T_nat>)) {
            var _z:Int_ = ({} : stdgo.math.big.Big.Int_);
            _z._neg = true;
            var _got = _z.setBits(_test);
            var _want:stdgo.math.big.Big.T_nat = _norm(_test);
            if (_got._abs._cmp(_want) != ((0 : GoInt))) {
                _t.errorf(("SetBits(%v) = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_test)), Go.toInterface(Go.asInterface(_got._abs)), Go.toInterface(Go.asInterface(_want)));
            };
            if (_got._neg) {
                _t.errorf(("SetBits(%v): got negative result" : GoString), Go.toInterface(Go.asInterface(_test)));
            };
            var _bits:stdgo.math.big.Big.T_nat = (_z.bits() : T_nat);
            if (_bits._cmp(_want) != ((0 : GoInt))) {
                _t.errorf(("%v.Bits() = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_z._abs)), Go.toInterface(Go.asInterface(_bits)), Go.toInterface(Go.asInterface(_want)));
            };
        };
    }
private function _checkSetBytes(_b:Slice<GoByte>):Bool {
        var _hex1:GoString = stdgo.encoding.hex.Hex.encodeToString((Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setBytes(_b).bytes());
        var _hex2:GoString = stdgo.encoding.hex.Hex.encodeToString(_b);
        while ((_hex1.length) < (_hex2.length)) {
            _hex1 = ("0" : GoString) + _hex1;
        };
        while ((_hex1.length) > (_hex2.length)) {
            _hex2 = ("0" : GoString) + _hex2;
        };
        return _hex1 == (_hex2);
    }
function testSetBytes(_t:Ref<stdgo.testing.Testing.T>):Void {
        {
            var _err:Error = stdgo.testing.quick.Quick.check(Go.toInterface(_checkSetBytes), null);
            if (_err != null) {
                _t.error(Go.toInterface(_err));
            };
        };
    }
private function _checkBytes(_b:Slice<GoByte>):Bool {
        while ((_b.length > (0 : GoInt)) && (_b[(0 : GoInt)] == (0 : GoUInt8))) {
            _b = (_b.__slice__((1 : GoInt)) : Slice<GoUInt8>);
        };
        var _b2 = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setBytes(_b).bytes();
        return stdgo.bytes.Bytes.equal(_b, _b2);
    }
function testBytes(_t:Ref<stdgo.testing.Testing.T>):Void {
        {
            var _err:Error = stdgo.testing.quick.Quick.check(Go.toInterface(_checkBytes), null);
            if (_err != null) {
                _t.error(Go.toInterface(_err));
            };
        };
    }
private function _checkQuo(_x:Slice<GoByte>, _y:Slice<GoByte>):Bool {
        var _u = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setBytes(_x);
        var _v = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setBytes(_y);
        if ((_v._abs.length) == ((0 : GoInt))) {
            return true;
        };
        var _r = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).quoRem(_u, _v, _r), _q:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, _r:Ref<stdgo.math.big.Big.Int_> = __tmp__._1;
        if (_r.cmp(_v) >= (0 : GoInt)) {
            return false;
        };
        var _uprime = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).set(_q);
        _uprime.mul(_uprime, _v);
        _uprime.add(_uprime, _r);
        return _uprime.cmp(_u) == ((0 : GoInt));
    }
function testQuo(_t:Ref<stdgo.testing.Testing.T>):Void {
        {
            var _err:Error = stdgo.testing.quick.Quick.check(Go.toInterface(_checkQuo), null);
            if (_err != null) {
                _t.error(Go.toInterface(_err));
            };
        };
        for (_i => _test in _quoTests) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._x, (10 : GoInt)), _x:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __0:Bool = __tmp__._1;
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._y, (10 : GoInt)), _y:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __1:Bool = __tmp__._1;
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._q, (10 : GoInt)), _expectedQ:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __2:Bool = __tmp__._1;
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._r, (10 : GoInt)), _expectedR:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __3:Bool = __tmp__._1;
            var _r = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).quoRem(_x, _y, _r), _q:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, _r:Ref<stdgo.math.big.Big.Int_> = __tmp__._1;
            if ((_q.cmp(_expectedQ) != (0 : GoInt)) || (_r.cmp(_expectedR) != (0 : GoInt))) {
                _t.errorf(("#%d got (%s, %s) want (%s, %s)" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface(_q)), Go.toInterface(Go.asInterface(_r)), Go.toInterface(Go.asInterface(_expectedQ)), Go.toInterface(Go.asInterface(_expectedR)));
            };
        };
    }
function testQuoStepD6(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _u = (Go.setRef((new Int_(false, (new Slice<stdgo.math.big.Big.Word>(0, 0, (0u32 : stdgo.math.big.Big.Word), (0u32 : stdgo.math.big.Big.Word), (-2147483647u32 : stdgo.math.big.Big.Word), (2147483647u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat)) : Int_)) : Ref<stdgo.math.big.Big.Int_>);
        var _v = (Go.setRef((new Int_(false, (new Slice<stdgo.math.big.Big.Word>(0, 0, (5u32 : stdgo.math.big.Big.Word), (-2147483646u32 : stdgo.math.big.Big.Word), (-2147483648u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat)) : Int_)) : Ref<stdgo.math.big.Big.Int_>);
        var _r = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).quoRem(_u, _v, _r), _q:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, _r:Ref<stdgo.math.big.Big.Int_> = __tmp__._1;
        {};
        {};
        {};
        {};
        if ((((_q.string() : GoString) != ("18446744073709551613" : GoString)) && ((_q.string() : GoString) != ("4294967293" : GoString))) || (((_r.string() : GoString) != ("3138550867693340382088035895064302439801311770021610913807" : GoString)) && ((_r.string() : GoString) != ("39614081266355540837921718287" : GoString)))) {
            _t.errorf(("got (%s, %s) want (%s, %s) or (%s, %s)" : GoString), Go.toInterface(Go.asInterface(_q)), Go.toInterface(Go.asInterface(_r)), Go.toInterface(("18446744073709551613" : GoString)), Go.toInterface(("3138550867693340382088035895064302439801311770021610913807" : GoString)), Go.toInterface(("4294967293" : GoString)), Go.toInterface(("39614081266355540837921718287" : GoString)));
        };
    }
function benchmarkQuoRem(_b:Ref<stdgo.testing.Testing.B>):Void {
        var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(("153980389784927331788354528594524332344709972855165340650588877572729725338415474372475094155672066328274535240275856844648695200875763869073572078279316458648124537905600131008790701752441155668003033945258023841165089852359980273279085783159654751552359397986180318708491098942831252291841441726305535546071" : GoString), (0 : GoInt)), _x:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __0:Bool = __tmp__._1;
        var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(("7746362281539803897849273317883545285945243323447099728551653406505888775727297253384154743724750941556720663282745352402758568446486952008757638690735720782793164586481245379056001310087907017524411556680030339452580238411650898523599802732790857831596547515523593979861803187084910989428312522918414417263055355460715745539358014631136245887418412633787074173796862711588221766398229333338511838891484974940633857861775630560092874987828057333663969469797013996401149696897591265769095952887917296740109742927689053276850469671231961384715398038978492733178835452859452433234470997285516534065058887757272972533841547437247509415567206632827453524027585684464869520087576386907357207827931645864812453790560013100879070175244115566800303394525802384116508985235998027327908578315965475155235939798618031870849109894283125229184144172630553554607112725169432413343763989564437170644270643461665184965150423819594083121075825" : GoString), (0 : GoInt)), _y:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __1:Bool = __tmp__._1;
        var _q = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        var _r = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        _b.resetTimer();
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                _q.quoRem(_y, _x, _r);
            });
        };
    }
function testBitLen(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _test in _bitLenTests) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._in, (0 : GoInt)), _x:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _t.errorf(("#%d test input invalid: %s" : GoString), Go.toInterface(_i), Go.toInterface(_test._in));
                continue;
            };
            {
                var _n:GoInt = _x.bitLen();
                if (_n != (_test._out)) {
                    _t.errorf(("#%d got %d want %d" : GoString), Go.toInterface(_i), Go.toInterface(_n), Go.toInterface(_test._out));
                };
            };
        };
    }
function testExp(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _test in _expTests) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._x, (0 : GoInt)), _x:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, _ok1:Bool = __tmp__._1;
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._y, (0 : GoInt)), _y:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, _ok2:Bool = __tmp__._1;
            var __0:Bool = false, __1:Bool = false, _ok4:Bool = __1, _ok3:Bool = __0;
            var __0:Ref<Int_> = (null : Ref<stdgo.math.big.Big.Int_>), __1:Ref<Int_> = (null : Ref<stdgo.math.big.Big.Int_>), _m:Ref<Int_> = __1, _out:Ref<Int_> = __0;
            if ((_test._out.length) == ((0 : GoInt))) {
                {
                    final __tmp__0 = null;
                    final __tmp__1 = true;
                    _out = __tmp__0;
                    _ok3 = __tmp__1;
                };
            } else {
                {
                    var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._out, (0 : GoInt));
                    _out = __tmp__._0;
                    _ok3 = __tmp__._1;
                };
            };
            if ((_test._m.length) == ((0 : GoInt))) {
                {
                    final __tmp__0 = null;
                    final __tmp__1 = true;
                    _m = __tmp__0;
                    _ok4 = __tmp__1;
                };
            } else {
                {
                    var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._m, (0 : GoInt));
                    _m = __tmp__._0;
                    _ok4 = __tmp__._1;
                };
            };
            if (((!_ok1 || !_ok2) || !_ok3) || !_ok4) {
                _t.errorf(("#%d: error in input" : GoString), Go.toInterface(_i));
                continue;
            };
            var _z1 = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).exp(_x, _y, _m);
            if (((_z1 != null) && ((_z1 : Dynamic).__nil__ == null || !(_z1 : Dynamic).__nil__)) && !_isNormalized(_z1)) {
                _t.errorf(("#%d: %v is not normalized" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface((_z1 : stdgo.math.big.Big.Int_))));
            };
            if (!(((_z1 == null) || (_z1 : Dynamic).__nil__ && (_out == null) || (_out : Dynamic).__nil__) || (_z1.cmp(_out) == (0 : GoInt)))) {
                _t.errorf(("#%d: got %x want %x" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface(_z1)), Go.toInterface(Go.asInterface(_out)));
            };
            if (_m == null || (_m : Dynamic).__nil__) {
                _m = (Go.setRef(({ _abs : (new Slice<stdgo.math.big.Big.Word>(0, 0) : stdgo.math.big.Big.T_nat) } : Int_)) : Ref<stdgo.math.big.Big.Int_>);
                var _z2 = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).exp(_x, _y, _m);
                if (_z2.cmp(_z1) != ((0 : GoInt))) {
                    _t.errorf(("#%d: got %x want %x" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface(_z2)), Go.toInterface(Go.asInterface(_z1)));
                };
            };
        };
    }
function benchmarkExp(_b:Ref<stdgo.testing.Testing.B>):Void {
        var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(("11001289118363089646017359372117963499250546375269047542777928006103246876688756735760905680604646624353196869572752623285140408755420374049317646428185270079555372763503115646054602867593662923894140940837479507194934267532831694565516466765025434902348314525627418515646588160955862839022051353653052947073136084780742729727874803457643848197499548297570026926927502505634297079527299004267769780768565695459945235586892627059178884998772989397505061206395455591503771677500931269477503508150175717121828518985901959919560700853226255420793148986854391552859459511723547532575574664944815966793196961286234040892865" : GoString), (0 : GoInt)), _x:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __0:Bool = __tmp__._1;
        var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(("0xAC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4A099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF6095179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B9078717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF72" : GoString), (0 : GoInt)), _y:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __1:Bool = __tmp__._1;
        var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(("0xAC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4A099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF6095179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B9078717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF73" : GoString), (0 : GoInt)), _n:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __2:Bool = __tmp__._1;
        var _out = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                _out.exp(_x, _y, _n);
            });
        };
    }
function benchmarkExpMont(_b:Ref<stdgo.testing.Testing.B>):Void {
        var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(("297778224889315382157302278696111964193" : GoString), (0 : GoInt)), _x:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __0:Bool = __tmp__._1;
        var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(("2548977943381019743024248146923164919440527843026415174732254534318292492375775985739511369575861449426580651447974311336267954477239437734832604782764979371984246675241012538135715981292390886872929238062252506842498360562303324154310849745753254532852868768268023732398278338025070694508489163836616810661033068070127919590264734220833816416141878688318329193389865030063416339367925710474801991305827284114894677717927892032165200876093838921477120036402410731159852999623461591709308405270748511350289172153076023215" : GoString), (0 : GoInt)), _y:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __1:Bool = __tmp__._1;
        var _mods:Slice<T__struct_38> = (new Slice<T__struct_38>(
0,
0,
({ _name : ("Odd" : GoString), _val : ("0x82828282828200FFFF28FF2B218281FF82828282828200FFFF28FF2B218281FF82828282828200FFFF28FF2B218281FF" : GoString) } : T__struct_38),
({ _name : ("Even1" : GoString), _val : ("0x82828282828200FFFF28FF2B218281FF82828282828200FFFF28FF2B218281FF82828282828200FFFF28FF2B218281FE" : GoString) } : T__struct_38),
({ _name : ("Even2" : GoString), _val : ("0x82828282828200FFFF28FF2B218281FF82828282828200FFFF28FF2B218281FF82828282828200FFFF28FF2B218281FC" : GoString) } : T__struct_38),
({ _name : ("Even3" : GoString), _val : ("0x82828282828200FFFF28FF2B218281FF82828282828200FFFF28FF2B218281FF82828282828200FFFF28FF2B218281F8" : GoString) } : T__struct_38),
({ _name : ("Even4" : GoString), _val : ("0x82828282828200FFFF28FF2B218281FF82828282828200FFFF28FF2B218281FF82828282828200FFFF28FF2B218281F0" : GoString) } : T__struct_38),
({ _name : ("Even8" : GoString), _val : ("0x82828282828200FFFF28FF2B218281FF82828282828200FFFF28FF2B218281FF82828282828200FFFF28FF2B21828100" : GoString) } : T__struct_38),
({ _name : ("Even32" : GoString), _val : ("0x82828282828200FFFF28FF2B218281FF82828282828200FFFF28FF2B218281FF82828282828200FFFF28FF2B00000000" : GoString) } : T__struct_38),
({ _name : ("Even64" : GoString), _val : ("0x82828282828200FFFF28FF2B218281FF82828282828200FFFF28FF2B218281FF82828282828200FF0000000000000000" : GoString) } : T__struct_38),
({ _name : ("Even96" : GoString), _val : ("0x82828282828200FFFF28FF2B218281FF82828282828200FFFF28FF2B218281FF82828283000000000000000000000000" : GoString) } : T__struct_38),
({ _name : ("Even128" : GoString), _val : ("0x82828282828200FFFF28FF2B218281FF82828282828200FFFF28FF2B218281FF00000000000000000000000000000000" : GoString) } : T__struct_38),
({ _name : ("Even255" : GoString), _val : ("0x82828282828200FFFF28FF2B218281FF8000000000000000000000000000000000000000000000000000000000000000" : GoString) } : T__struct_38),
({ _name : ("SmallEven1" : GoString), _val : ("0x7E" : GoString) } : T__struct_38),
({ _name : ("SmallEven2" : GoString), _val : ("0x7C" : GoString) } : T__struct_38),
({ _name : ("SmallEven3" : GoString), _val : ("0x78" : GoString) } : T__struct_38),
({ _name : ("SmallEven4" : GoString), _val : ("0x70" : GoString) } : T__struct_38)) : Slice<T__struct_38>);
        for (__2 => _mod in _mods) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_mod._val, (0 : GoInt)), _n:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __3:Bool = __tmp__._1;
            var _out = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
            _b.run(_mod._name, function(_b:Ref<stdgo.testing.Testing.B>):Void {
                _b.reportAllocs();
                {
                    var _i:GoInt = (0 : GoInt);
                    Go.cfor(_i < _b.n, _i++, {
                        _out.exp(_x, _y, _n);
                    });
                };
            });
        };
    }
function benchmarkExp2(_b:Ref<stdgo.testing.Testing.B>):Void {
        var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(("2" : GoString), (0 : GoInt)), _x:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __0:Bool = __tmp__._1;
        var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(("0xAC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4A099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF6095179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B9078717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF72" : GoString), (0 : GoInt)), _y:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __1:Bool = __tmp__._1;
        var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(("0xAC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4A099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF6095179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B9078717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF73" : GoString), (0 : GoInt)), _n:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __2:Bool = __tmp__._1;
        var _out = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                _out.exp(_x, _y, _n);
            });
        };
    }
private function _checkGcd(_aBytes:Slice<GoByte>, _bBytes:Slice<GoByte>):Bool {
        var _x = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        var _y = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        var _a = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setBytes(_aBytes);
        var _b = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setBytes(_bBytes);
        var _d = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).gcd(_x, _y, _a, _b);
        _x.mul(_x, _a);
        _y.mul(_y, _b);
        _x.add(_x, _y);
        return _x.cmp(_d) == ((0 : GoInt));
    }
/**
    // euclidExtGCD is a reference implementation of Euclid's
    // extended GCD algorithm for testing against optimized algorithms.
    // Requirements: a, b > 0
**/
private function _euclidExtGCD(_a:Ref<Int_>, _b:Ref<Int_>):{ var _0 : Ref<Int_>; var _1 : Ref<Int_>; var _2 : Ref<Int_>; } {
        var _g:Ref<Int_> = (null : Ref<stdgo.math.big.Big.Int_>), _x:Ref<Int_> = (null : Ref<stdgo.math.big.Big.Int_>), _y:Ref<Int_> = (null : Ref<stdgo.math.big.Big.Int_>);
        var a = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).set(_a);
        var b = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).set(_b);
        var ua = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setInt64((1i64 : GoInt64));
        var va = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        var ub = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        var vb = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setInt64((1i64 : GoInt64));
        var _q = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        var _temp = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        var _r = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        while ((b._abs.length) > (0 : GoInt)) {
            {
                var __tmp__ = _q.quoRem(a, b, _r);
                _q = __tmp__._0;
                _r = __tmp__._1;
            };
            {
                final __tmp__0 = b;
                final __tmp__1 = _r;
                final __tmp__2 = a;
                a = __tmp__0;
                b = __tmp__1;
                _r = __tmp__2;
            };
            _temp.set(ub);
            ub.mul(ub, _q);
            ub.sub(ua, ub);
            ua.set(_temp);
            _temp.set(vb);
            vb.mul(vb, _q);
            vb.sub(va, vb);
            va.set(_temp);
        };
        return { _0 : a, _1 : ua, _2 : va };
    }
private function _checkLehmerGcd(_aBytes:Slice<GoByte>, _bBytes:Slice<GoByte>):Bool {
        var _a = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setBytes(_aBytes);
        var _b = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setBytes(_bBytes);
        if ((_a.sign() <= (0 : GoInt)) || (_b.sign() <= (0 : GoInt))) {
            return true;
        };
        var _d = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>)._lehmerGCD(null, null, _a, _b);
        var __tmp__ = _euclidExtGCD(_a, _b), _d0:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __0:Ref<stdgo.math.big.Big.Int_> = __tmp__._1, __1:Ref<stdgo.math.big.Big.Int_> = __tmp__._2;
        return _d.cmp(_d0) == ((0 : GoInt));
    }
private function _checkLehmerExtGcd(_aBytes:Slice<GoByte>, _bBytes:Slice<GoByte>):Bool {
        var _a = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setBytes(_aBytes);
        var _b = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setBytes(_bBytes);
        var _x = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        var _y = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        if ((_a.sign() <= (0 : GoInt)) || (_b.sign() <= (0 : GoInt))) {
            return true;
        };
        var _d = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>)._lehmerGCD(_x, _y, _a, _b);
        var __tmp__ = _euclidExtGCD(_a, _b), _d0:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, _x0:Ref<stdgo.math.big.Big.Int_> = __tmp__._1, _y0:Ref<stdgo.math.big.Big.Int_> = __tmp__._2;
        return ((_d.cmp(_d0) == (0 : GoInt)) && (_x.cmp(_x0) == (0 : GoInt))) && (_y.cmp(_y0) == (0 : GoInt));
    }
private function _testGcd(_t:Ref<stdgo.testing.Testing.T>, _d:Ref<Int_>, _x:Ref<Int_>, _y:Ref<Int_>, _a:Ref<Int_>, _b:Ref<Int_>):Void {
        var x:Ref<Int_> = (null : Ref<stdgo.math.big.Big.Int_>);
        if (_x != null && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) {
            x = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        };
        var y:Ref<Int_> = (null : Ref<stdgo.math.big.Big.Int_>);
        if (_y != null && ((_y : Dynamic).__nil__ == null || !(_y : Dynamic).__nil__)) {
            y = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        };
        var d = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).gcd(x, y, _a, _b);
        if (d.cmp(_d) != ((0 : GoInt))) {
            _t.errorf(("GCD(%s, %s, %s, %s): got d = %s, want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_a)), Go.toInterface(Go.asInterface(_b)), Go.toInterface(Go.asInterface(d)), Go.toInterface(Go.asInterface(_d)));
        };
        if (((_x != null) && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) && (x.cmp(_x) != (0 : GoInt))) {
            _t.errorf(("GCD(%s, %s, %s, %s): got x = %s, want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_a)), Go.toInterface(Go.asInterface(_b)), Go.toInterface(Go.asInterface(x)), Go.toInterface(Go.asInterface(_x)));
        };
        if (((_y != null) && ((_y : Dynamic).__nil__ == null || !(_y : Dynamic).__nil__)) && (y.cmp(_y) != (0 : GoInt))) {
            _t.errorf(("GCD(%s, %s, %s, %s): got y = %s, want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_a)), Go.toInterface(Go.asInterface(_b)), Go.toInterface(Go.asInterface(y)), Go.toInterface(Go.asInterface(_y)));
        };
        var _a2 = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).set(_a);
        var _b2 = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).set(_b);
        _a2.gcd(x, y, _a2, _b2);
        if (_a2.cmp(_d) != ((0 : GoInt))) {
            _t.errorf(("aliased z = a GCD(%s, %s, %s, %s): got d = %s, want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_a)), Go.toInterface(Go.asInterface(_b)), Go.toInterface(Go.asInterface(_a2)), Go.toInterface(Go.asInterface(_d)));
        };
        if (((_x != null) && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) && (x.cmp(_x) != (0 : GoInt))) {
            _t.errorf(("aliased z = a GCD(%s, %s, %s, %s): got x = %s, want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_a)), Go.toInterface(Go.asInterface(_b)), Go.toInterface(Go.asInterface(x)), Go.toInterface(Go.asInterface(_x)));
        };
        if (((_y != null) && ((_y : Dynamic).__nil__ == null || !(_y : Dynamic).__nil__)) && (y.cmp(_y) != (0 : GoInt))) {
            _t.errorf(("aliased z = a GCD(%s, %s, %s, %s): got y = %s, want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_a)), Go.toInterface(Go.asInterface(_b)), Go.toInterface(Go.asInterface(y)), Go.toInterface(Go.asInterface(_y)));
        };
        _a2 = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).set(_a);
        _b2 = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).set(_b);
        _b2.gcd(x, y, _a2, _b2);
        if (_b2.cmp(_d) != ((0 : GoInt))) {
            _t.errorf(("aliased z = b GCD(%s, %s, %s, %s): got d = %s, want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_a)), Go.toInterface(Go.asInterface(_b)), Go.toInterface(Go.asInterface(_b2)), Go.toInterface(Go.asInterface(_d)));
        };
        if (((_x != null) && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) && (x.cmp(_x) != (0 : GoInt))) {
            _t.errorf(("aliased z = b GCD(%s, %s, %s, %s): got x = %s, want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_a)), Go.toInterface(Go.asInterface(_b)), Go.toInterface(Go.asInterface(x)), Go.toInterface(Go.asInterface(_x)));
        };
        if (((_y != null) && ((_y : Dynamic).__nil__ == null || !(_y : Dynamic).__nil__)) && (y.cmp(_y) != (0 : GoInt))) {
            _t.errorf(("aliased z = b GCD(%s, %s, %s, %s): got y = %s, want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_a)), Go.toInterface(Go.asInterface(_b)), Go.toInterface(Go.asInterface(y)), Go.toInterface(Go.asInterface(_y)));
        };
        _a2 = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).set(_a);
        _b2 = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).set(_b);
        d = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).gcd(_a2, _b2, _a2, _b2);
        if (d.cmp(_d) != ((0 : GoInt))) {
            _t.errorf(("aliased x = a, y = b GCD(%s, %s, %s, %s): got d = %s, want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_a)), Go.toInterface(Go.asInterface(_b)), Go.toInterface(Go.asInterface(d)), Go.toInterface(Go.asInterface(_d)));
        };
        if (((_x != null) && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) && (_a2.cmp(_x) != (0 : GoInt))) {
            _t.errorf(("aliased x = a, y = b GCD(%s, %s, %s, %s): got x = %s, want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_a)), Go.toInterface(Go.asInterface(_b)), Go.toInterface(Go.asInterface(_a2)), Go.toInterface(Go.asInterface(_x)));
        };
        if (((_y != null) && ((_y : Dynamic).__nil__ == null || !(_y : Dynamic).__nil__)) && (_b2.cmp(_y) != (0 : GoInt))) {
            _t.errorf(("aliased x = a, y = b GCD(%s, %s, %s, %s): got y = %s, want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_a)), Go.toInterface(Go.asInterface(_b)), Go.toInterface(Go.asInterface(_b2)), Go.toInterface(Go.asInterface(_y)));
        };
        _a2 = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).set(_a);
        _b2 = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).set(_b);
        d = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).gcd(_b2, _a2, _a2, _b2);
        if (d.cmp(_d) != ((0 : GoInt))) {
            _t.errorf(("aliased x = b, y = a GCD(%s, %s, %s, %s): got d = %s, want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_a)), Go.toInterface(Go.asInterface(_b)), Go.toInterface(Go.asInterface(d)), Go.toInterface(Go.asInterface(_d)));
        };
        if (((_x != null) && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) && (_b2.cmp(_x) != (0 : GoInt))) {
            _t.errorf(("aliased x = b, y = a GCD(%s, %s, %s, %s): got x = %s, want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_a)), Go.toInterface(Go.asInterface(_b)), Go.toInterface(Go.asInterface(_b2)), Go.toInterface(Go.asInterface(_x)));
        };
        if (((_y != null) && ((_y : Dynamic).__nil__ == null || !(_y : Dynamic).__nil__)) && (_a2.cmp(_y) != (0 : GoInt))) {
            _t.errorf(("aliased x = b, y = a GCD(%s, %s, %s, %s): got y = %s, want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_a)), Go.toInterface(Go.asInterface(_b)), Go.toInterface(Go.asInterface(_a2)), Go.toInterface(Go.asInterface(_y)));
        };
    }
function testGcd(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in _gcdTests) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._d, (0 : GoInt)), _d:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __1:Bool = __tmp__._1;
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._x, (0 : GoInt)), _x:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __2:Bool = __tmp__._1;
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._y, (0 : GoInt)), _y:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __3:Bool = __tmp__._1;
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._a, (0 : GoInt)), _a:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __4:Bool = __tmp__._1;
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._b, (0 : GoInt)), _b:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __5:Bool = __tmp__._1;
            _testGcd(_t, _d, null, null, _a, _b);
            _testGcd(_t, _d, _x, null, _a, _b);
            _testGcd(_t, _d, null, _y, _a, _b);
            _testGcd(_t, _d, _x, _y, _a, _b);
        };
        {
            var _err:Error = stdgo.testing.quick.Quick.check(Go.toInterface(_checkGcd), null);
            if (_err != null) {
                _t.error(Go.toInterface(_err));
            };
        };
        {
            var _err:Error = stdgo.testing.quick.Quick.check(Go.toInterface(_checkLehmerGcd), null);
            if (_err != null) {
                _t.error(Go.toInterface(_err));
            };
        };
        {
            var _err:Error = stdgo.testing.quick.Quick.check(Go.toInterface(_checkLehmerExtGcd), null);
            if (_err != null) {
                _t.error(Go.toInterface(_err));
            };
        };
    }
function testRsh(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _test in _rshTests) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._in, (10 : GoInt)), _in:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __0:Bool = __tmp__._1;
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._out, (10 : GoInt)), _expected:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __1:Bool = __tmp__._1;
            var _out = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).rsh(_in, _test._shift);
            if (!_isNormalized(_out)) {
                _t.errorf(("#%d: %v is not normalized" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface((_out : stdgo.math.big.Big.Int_))));
            };
            if (_out.cmp(_expected) != ((0 : GoInt))) {
                _t.errorf(("#%d: got %s want %s" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface(_out)), Go.toInterface(Go.asInterface(_expected)));
            };
        };
    }
function testRshSelf(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _test in _rshTests) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._in, (10 : GoInt)), _z:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __0:Bool = __tmp__._1;
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._out, (10 : GoInt)), _expected:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __1:Bool = __tmp__._1;
            _z.rsh(_z, _test._shift);
            if (!_isNormalized(_z)) {
                _t.errorf(("#%d: %v is not normalized" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface((_z : stdgo.math.big.Big.Int_))));
            };
            if (_z.cmp(_expected) != ((0 : GoInt))) {
                _t.errorf(("#%d: got %s want %s" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface(_z)), Go.toInterface(Go.asInterface(_expected)));
            };
        };
    }
function testLsh(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _test in _lshTests) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._in, (10 : GoInt)), _in:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __0:Bool = __tmp__._1;
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._out, (10 : GoInt)), _expected:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __1:Bool = __tmp__._1;
            var _out = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).lsh(_in, _test._shift);
            if (!_isNormalized(_out)) {
                _t.errorf(("#%d: %v is not normalized" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface((_out : stdgo.math.big.Big.Int_))));
            };
            if (_out.cmp(_expected) != ((0 : GoInt))) {
                _t.errorf(("#%d: got %s want %s" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface(_out)), Go.toInterface(Go.asInterface(_expected)));
            };
        };
    }
function testLshSelf(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _test in _lshTests) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._in, (10 : GoInt)), _z:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __0:Bool = __tmp__._1;
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._out, (10 : GoInt)), _expected:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __1:Bool = __tmp__._1;
            _z.lsh(_z, _test._shift);
            if (!_isNormalized(_z)) {
                _t.errorf(("#%d: %v is not normalized" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface((_z : stdgo.math.big.Big.Int_))));
            };
            if (_z.cmp(_expected) != ((0 : GoInt))) {
                _t.errorf(("#%d: got %s want %s" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface(_z)), Go.toInterface(Go.asInterface(_expected)));
            };
        };
    }
function testLshRsh(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _test in _rshTests) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._in, (10 : GoInt)), _in:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __0:Bool = __tmp__._1;
            var _out = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).lsh(_in, _test._shift);
            _out = _out.rsh(_out, _test._shift);
            if (!_isNormalized(_out)) {
                _t.errorf(("#%d: %v is not normalized" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface((_out : stdgo.math.big.Big.Int_))));
            };
            if (_in.cmp(_out) != ((0 : GoInt))) {
                _t.errorf(("#%d: got %s want %s" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface(_out)), Go.toInterface(Go.asInterface(_in)));
            };
        };
        for (_i => _test in _lshTests) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._in, (10 : GoInt)), _in:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __1:Bool = __tmp__._1;
            var _out = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).lsh(_in, _test._shift);
            _out.rsh(_out, _test._shift);
            if (!_isNormalized(_out)) {
                _t.errorf(("#%d: %v is not normalized" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface((_out : stdgo.math.big.Big.Int_))));
            };
            if (_in.cmp(_out) != ((0 : GoInt))) {
                _t.errorf(("#%d: got %s want %s" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface(_out)), Go.toInterface(Go.asInterface(_in)));
            };
        };
    }
function testCmpAbs(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _values = new Slice<Ref<stdgo.math.big.Big.Int_>>((_cmpAbsTests.length : GoInt).toBasic(), 0, ...[for (i in 0 ... (_cmpAbsTests.length : GoInt).toBasic()) (null : Ref<stdgo.math.big.Big.Int_>)]);
        var _prev:Ref<Int_> = (null : Ref<stdgo.math.big.Big.Int_>);
        for (_i => _s in _cmpAbsTests) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_s, (0 : GoInt)), _x:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _t.fatalf(("SetString(%s, 0) failed" : GoString), Go.toInterface(_s));
            };
            if (((_prev != null) && ((_prev : Dynamic).__nil__ == null || !(_prev : Dynamic).__nil__)) && (_prev.cmp(_x) >= (0 : GoInt))) {
                _t.fatal(Go.toInterface(("cmpAbsTests entries not sorted in ascending order" : GoString)));
            };
            _values[(_i : GoInt)] = _x;
            _prev = _x;
        };
        for (_i => _x in _values) {
            for (_j => _y in _values) {
                {
                    var _k:GoInt = (0 : GoInt);
                    Go.cfor(_k < (4 : GoInt), _k++, {
                        var __0:Int_ = ({} : stdgo.math.big.Big.Int_), __1:Int_ = ({} : stdgo.math.big.Big.Int_), _b:Int_ = __1, _a:Int_ = __0;
                        _a.set(_x);
                        _b.set(_y);
                        if (_k & (1 : GoInt) != ((0 : GoInt))) {
                            _a.neg((Go.setRef(_a) : Ref<stdgo.math.big.Big.Int_>));
                        };
                        if (_k & (2 : GoInt) != ((0 : GoInt))) {
                            _b.neg((Go.setRef(_b) : Ref<stdgo.math.big.Big.Int_>));
                        };
                        var _got:GoInt = _a.cmpAbs((Go.setRef(_b) : Ref<stdgo.math.big.Big.Int_>));
                        var _want:GoInt = (0 : GoInt);
                        if (_i > _j) {
                            _want = (1 : GoInt);
                        } else if (_i < _j) {
                            _want = (-1 : GoInt);
                        };
                        if (_got != (_want)) {
                            _t.errorf(("absCmp |%s|, |%s|: got %d; want %d" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_a) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(Go.asInterface((Go.setRef(_b) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(_got), Go.toInterface(_want));
                        };
                    });
                };
            };
        };
    }
function testIntCmpSelf(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _s in _cmpAbsTests) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_s, (0 : GoInt)), _x:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _t.fatalf(("SetString(%s, 0) failed" : GoString), Go.toInterface(_s));
            };
            var _got:GoInt = _x.cmp(_x);
            var _want:GoInt = (0 : GoInt);
            if (_got != (_want)) {
                _t.errorf(("x = %s: x.Cmp(x): got %d; want %d" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function testInt64(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _s in _int64Tests) {
            var _x:Int_ = ({} : stdgo.math.big.Big.Int_);
            var __tmp__ = _x.setString(_s, (0 : GoInt)), __1:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _t.errorf(("SetString(%s, 0) failed" : GoString), Go.toInterface(_s));
                continue;
            };
            var __tmp__ = stdgo.strconv.Strconv.parseInt(_s, (0 : GoInt), (64 : GoInt)), _want:GoInt64 = __tmp__._0, _err:Error = __tmp__._1;
            if (_err != null) {
                if (Go.toInterface((Go.typeAssert((Go.toInterface(_err) : Ref<stdgo.strconv.Strconv.NumError>)) : Ref<stdgo.strconv.Strconv.NumError>).err) == (Go.toInterface(stdgo.strconv.Strconv.errRange))) {
                    if (_x.isInt64()) {
                        _t.errorf(("IsInt64(%s) succeeded unexpectedly" : GoString), Go.toInterface(_s));
                    };
                } else {
                    _t.errorf(("ParseInt(%s) failed" : GoString), Go.toInterface(_s));
                };
                continue;
            };
            if (!_x.isInt64()) {
                _t.errorf(("IsInt64(%s) failed unexpectedly" : GoString), Go.toInterface(_s));
            };
            var _got:GoInt64 = _x.int64();
            if (_got != (_want)) {
                _t.errorf(("Int64(%s) = %d; want %d" : GoString), Go.toInterface(_s), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function testUint64(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _s in _uint64Tests) {
            var _x:Int_ = ({} : stdgo.math.big.Big.Int_);
            var __tmp__ = _x.setString(_s, (0 : GoInt)), __1:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _t.errorf(("SetString(%s, 0) failed" : GoString), Go.toInterface(_s));
                continue;
            };
            var __tmp__ = stdgo.strconv.Strconv.parseUint(_s, (0 : GoInt), (64 : GoInt)), _want:GoUInt64 = __tmp__._0, _err:Error = __tmp__._1;
            if (_err != null) {
                if ((_s[(0 : GoInt)] == (45 : GoUInt8)) || (Go.toInterface((Go.typeAssert((Go.toInterface(_err) : Ref<stdgo.strconv.Strconv.NumError>)) : Ref<stdgo.strconv.Strconv.NumError>).err) == Go.toInterface(stdgo.strconv.Strconv.errRange))) {
                    if (_x.isUint64()) {
                        _t.errorf(("IsUint64(%s) succeeded unexpectedly" : GoString), Go.toInterface(_s));
                    };
                } else {
                    _t.errorf(("ParseUint(%s) failed" : GoString), Go.toInterface(_s));
                };
                continue;
            };
            if (!_x.isUint64()) {
                _t.errorf(("IsUint64(%s) failed unexpectedly" : GoString), Go.toInterface(_s));
            };
            var _got:GoUInt64 = _x.uint64();
            if (_got != (_want)) {
                _t.errorf(("Uint64(%s) = %d; want %d" : GoString), Go.toInterface(_s), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
private function _testBitFun(_t:Ref<stdgo.testing.Testing.T>, _msg:GoString, _f:T_bitFun, _x:Ref<Int_>, _y:Ref<Int_>, _exp:GoString):Void {
        var _expected = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        _expected.setString(_exp, (0 : GoInt));
        var _out = _f((Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>), _x, _y);
        if (_out.cmp(_expected) != ((0 : GoInt))) {
            _t.errorf(("%s: got %s want %s" : GoString), Go.toInterface(_msg), Go.toInterface(Go.asInterface(_out)), Go.toInterface(Go.asInterface(_expected)));
        };
    }
private function _testBitFunSelf(_t:Ref<stdgo.testing.Testing.T>, _msg:GoString, _f:T_bitFun, _x:Ref<Int_>, _y:Ref<Int_>, _exp:GoString):Void {
        var _self = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        _self.set(_x);
        var _expected = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        _expected.setString(_exp, (0 : GoInt));
        _self = _f(_self, _self, _y);
        if (_self.cmp(_expected) != ((0 : GoInt))) {
            _t.errorf(("%s: got %s want %s" : GoString), Go.toInterface(_msg), Go.toInterface(Go.asInterface(_self)), Go.toInterface(Go.asInterface(_expected)));
        };
    }
private function _altBit(_x:Ref<Int_>, _i:GoInt):GoUInt {
        var _z = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).rsh(_x, (_i : GoUInt));
        _z = _z.and(_z, newInt((1i64 : GoInt64)));
        if (_z.cmp((Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>)) != ((0 : GoInt))) {
            return (1u32 : GoUInt);
        };
        return (0u32 : GoUInt);
    }
private function _altSetBit(_z:Ref<Int_>, _x:Ref<Int_>, _i:GoInt, _b:GoUInt):Ref<Int_> {
        var _one = newInt((1i64 : GoInt64));
        var _m = _one.lsh(_one, (_i : GoUInt));
        {
            final __value__ = _b;
            if (__value__ == ((1u32 : GoUInt))) {
                return _z.or(_x, _m);
            } else if (__value__ == ((0u32 : GoUInt))) {
                return _z.andNot(_x, _m);
            };
        };
        throw Go.toInterface(("set bit is not 0 or 1" : GoString));
    }
private function _testBitset(_t:Ref<stdgo.testing.Testing.T>, _x:Ref<Int_>):Void {
        var _n:GoInt = _x.bitLen();
        var _z = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).set(_x);
        var _z1 = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).set(_x);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < (_n + (10 : GoInt)), _i++, {
                var _old:GoUInt = _z.bit(_i);
                var _old1:GoUInt = _altBit(_z1, _i);
                if (_old != (_old1)) {
                    _t.errorf(("bitset: inconsistent value for Bit(%s, %d), got %v want %v" : GoString), Go.toInterface(Go.asInterface(_z1)), Go.toInterface(_i), Go.toInterface(_old), Go.toInterface(_old1));
                };
                var _z = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setBit(_z, _i, (1u32 : GoUInt));
                var _z1 = _altSetBit((Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>), _z1, _i, (1u32 : GoUInt));
                if (_z.bit(_i) == ((0u32 : GoUInt))) {
                    _t.errorf(("bitset: bit %d of %s got 0 want 1" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface(_x)));
                };
                if (_z.cmp(_z1) != ((0 : GoInt))) {
                    _t.errorf(("bitset: inconsistent value after SetBit 1, got %s want %s" : GoString), Go.toInterface(Go.asInterface(_z)), Go.toInterface(Go.asInterface(_z1)));
                };
                _z.setBit(_z, _i, (0u32 : GoUInt));
                _altSetBit(_z1, _z1, _i, (0u32 : GoUInt));
                if (_z.bit(_i) != ((0u32 : GoUInt))) {
                    _t.errorf(("bitset: bit %d of %s got 1 want 0" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface(_x)));
                };
                if (_z.cmp(_z1) != ((0 : GoInt))) {
                    _t.errorf(("bitset: inconsistent value after SetBit 0, got %s want %s" : GoString), Go.toInterface(Go.asInterface(_z)), Go.toInterface(Go.asInterface(_z1)));
                };
                _altSetBit(_z1, _z1, _i, _old);
                _z.setBit(_z, _i, _old);
                if (_z.cmp(_z1) != ((0 : GoInt))) {
                    _t.errorf(("bitset: inconsistent value after SetBit old, got %s want %s" : GoString), Go.toInterface(Go.asInterface(_z)), Go.toInterface(Go.asInterface(_z1)));
                };
            });
        };
        if (_z.cmp(_x) != ((0 : GoInt))) {
            _t.errorf(("bitset: got %s want %s" : GoString), Go.toInterface(Go.asInterface(_z)), Go.toInterface(Go.asInterface(_x)));
        };
    }
function testBitSet(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in _bitwiseTests) {
            var _x = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
            _x.setString(_test._x, (0 : GoInt));
            _testBitset(_t, _x);
            _x = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
            _x.setString(_test._y, (0 : GoInt));
            _testBitset(_t, _x);
        };
        for (_i => _test in _bitsetTests) {
            var _x = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
            _x.setString(_test._x, (0 : GoInt));
            var _b:GoUInt = _x.bit(_test._i);
            if (_b != (_test._b)) {
                _t.errorf(("#%d got %v want %v" : GoString), Go.toInterface(_i), Go.toInterface(_b), Go.toInterface(_test._b));
            };
        };
        var _z = newInt((1i64 : GoInt64));
        _z.setBit(newInt((0i64 : GoInt64)), (2 : GoInt), (1u32 : GoUInt));
        if (_z.cmp(newInt((4i64 : GoInt64))) != ((0 : GoInt))) {
            _t.errorf(("destination leaked into result; got %s want 4" : GoString), Go.toInterface(Go.asInterface(_z)));
        };
    }
function testTrailingZeroBits(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _test in _tzbTests) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._in, (0 : GoInt)), _in:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __0:Bool = __tmp__._1;
            var _want:GoUInt = _test._out;
            var _got:GoUInt = _in.trailingZeroBits();
            if (_got != (_want)) {
                _t.errorf(("#%d: got %v want %v" : GoString), Go.toInterface(_i), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function benchmarkBitset(_b:Ref<stdgo.testing.Testing.B>):Void {
        var _z = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        _z.setBit(_z, (512 : GoInt), (1u32 : GoUInt));
        _b.resetTimer();
        _b.startTimer();
        {
            var _i:GoInt = _b.n - (1 : GoInt);
            Go.cfor(_i >= (0 : GoInt), _i--, {
                _z.setBit(_z, _i & (512 : GoInt), (1u32 : GoUInt));
            });
        };
    }
function benchmarkBitsetNeg(_b:Ref<stdgo.testing.Testing.B>):Void {
        var _z = newInt((-1i64 : GoInt64));
        _z.setBit(_z, (512 : GoInt), (0u32 : GoUInt));
        _b.resetTimer();
        _b.startTimer();
        {
            var _i:GoInt = _b.n - (1 : GoInt);
            Go.cfor(_i >= (0 : GoInt), _i--, {
                _z.setBit(_z, _i & (512 : GoInt), (0u32 : GoUInt));
            });
        };
    }
function benchmarkBitsetOrig(_b:Ref<stdgo.testing.Testing.B>):Void {
        var _z = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        _altSetBit(_z, _z, (512 : GoInt), (1u32 : GoUInt));
        _b.resetTimer();
        _b.startTimer();
        {
            var _i:GoInt = _b.n - (1 : GoInt);
            Go.cfor(_i >= (0 : GoInt), _i--, {
                _altSetBit(_z, _z, _i & (512 : GoInt), (1u32 : GoUInt));
            });
        };
    }
function benchmarkBitsetNegOrig(_b:Ref<stdgo.testing.Testing.B>):Void {
        var _z = newInt((-1i64 : GoInt64));
        _altSetBit(_z, _z, (512 : GoInt), (0u32 : GoUInt));
        _b.resetTimer();
        _b.startTimer();
        {
            var _i:GoInt = _b.n - (1 : GoInt);
            Go.cfor(_i >= (0 : GoInt), _i--, {
                _altSetBit(_z, _z, _i & (512 : GoInt), (0u32 : GoUInt));
            });
        };
    }
/**
    // tri generates the trinomial 2**(n*2) - 2**n - 1, which is always 3 mod 4 and
    // 7 mod 8, so that 2 is always a quadratic residue.
**/
private function _tri(_n:GoUInt):Ref<Int_> {
        var _x = newInt((1i64 : GoInt64));
        _x.lsh(_x, _n);
        var _x2 = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).lsh(_x, _n);
        _x2.sub(_x2, _x);
        _x2.sub(_x2, _intOne);
        return _x2;
    }
function benchmarkModSqrt225_Tonelli(_b:Ref<stdgo.testing.Testing.B>):Void {
        var _p = _tri((225u32 : GoUInt));
        var _x = newInt((2i64 : GoInt64));
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                _x.setUint64((2i64 : GoUInt64));
                _x._modSqrtTonelliShanks(_x, _p);
            });
        };
    }
function benchmarkModSqrt225_3Mod4(_b:Ref<stdgo.testing.Testing.B>):Void {
        var _p = _tri((225u32 : GoUInt));
        var _x = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setUint64((2i64 : GoUInt64));
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                _x.setUint64((2i64 : GoUInt64));
                _x._modSqrt3Mod4Prime(_x, _p);
            });
        };
    }
function benchmarkModSqrt231_Tonelli(_b:Ref<stdgo.testing.Testing.B>):Void {
        var _p = _tri((231u32 : GoUInt));
        _p.sub(_p, _intOne);
        _p.sub(_p, _intOne);
        var _x = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setUint64((7i64 : GoUInt64));
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                _x.setUint64((7i64 : GoUInt64));
                _x._modSqrtTonelliShanks(_x, _p);
            });
        };
    }
function benchmarkModSqrt231_5Mod8(_b:Ref<stdgo.testing.Testing.B>):Void {
        var _p = _tri((231u32 : GoUInt));
        _p.sub(_p, _intOne);
        _p.sub(_p, _intOne);
        var _x = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setUint64((7i64 : GoUInt64));
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                _x.setUint64((7i64 : GoUInt64));
                _x._modSqrt5Mod8Prime(_x, _p);
            });
        };
    }
function testBitwise(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _x = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        var _y = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        for (__0 => _test in _bitwiseTests) {
            _x.setString(_test._x, (0 : GoInt));
            _y.setString(_test._y, (0 : GoInt));
            _testBitFun(_t, ("and" : GoString), Int__static_extension.and, _x, _y, _test._and);
            _testBitFunSelf(_t, ("and" : GoString), Int__static_extension.and, _x, _y, _test._and);
            _testBitFun(_t, ("andNot" : GoString), Int__static_extension.andNot, _x, _y, _test._andNot);
            _testBitFunSelf(_t, ("andNot" : GoString), Int__static_extension.andNot, _x, _y, _test._andNot);
            _testBitFun(_t, ("or" : GoString), Int__static_extension.or, _x, _y, _test._or);
            _testBitFunSelf(_t, ("or" : GoString), Int__static_extension.or, _x, _y, _test._or);
            _testBitFun(_t, ("xor" : GoString), Int__static_extension.xor, _x, _y, _test._xor);
            _testBitFunSelf(_t, ("xor" : GoString), Int__static_extension.xor, _x, _y, _test._xor);
        };
    }
function testNot(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _in = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        var _out = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        var _expected = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        for (_i => _test in _notTests) {
            _in.setString(_test._in, (10 : GoInt));
            _expected.setString(_test._out, (10 : GoInt));
            _out = _out.not(_in);
            if (_out.cmp(_expected) != ((0 : GoInt))) {
                _t.errorf(("#%d: got %s want %s" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface(_out)), Go.toInterface(Go.asInterface(_expected)));
            };
            _out = _out.not(_out);
            if (_out.cmp(_in) != ((0 : GoInt))) {
                _t.errorf(("#%d: got %s want %s" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface(_out)), Go.toInterface(Go.asInterface(_in)));
            };
        };
    }
function testModInverse(_t:Ref<stdgo.testing.Testing.T>):Void {
        var __0:Int_ = ({} : stdgo.math.big.Big.Int_), __1:Int_ = ({} : stdgo.math.big.Big.Int_), __2:Int_ = ({} : stdgo.math.big.Big.Int_), __3:Int_ = ({} : stdgo.math.big.Big.Int_), _inverse:Int_ = __3, _gcd:Int_ = __2, _modulus:Int_ = __1, _element:Int_ = __0;
        var _one = newInt((1i64 : GoInt64));
        for (__0 => _test in _modInverseTests) {
            (Go.setRef(_element) : Ref<stdgo.math.big.Big.Int_>).setString(_test._element, (10 : GoInt));
            (Go.setRef(_modulus) : Ref<stdgo.math.big.Big.Int_>).setString(_test._modulus, (10 : GoInt));
            (Go.setRef(_inverse) : Ref<stdgo.math.big.Big.Int_>).modInverse((Go.setRef(_element) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_modulus) : Ref<stdgo.math.big.Big.Int_>));
            (Go.setRef(_inverse) : Ref<stdgo.math.big.Big.Int_>).mul((Go.setRef(_inverse) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_element) : Ref<stdgo.math.big.Big.Int_>));
            (Go.setRef(_inverse) : Ref<stdgo.math.big.Big.Int_>).mod((Go.setRef(_inverse) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_modulus) : Ref<stdgo.math.big.Big.Int_>));
            if ((Go.setRef(_inverse) : Ref<stdgo.math.big.Big.Int_>).cmp(_one) != ((0 : GoInt))) {
                _t.errorf(("ModInverse(%d,%d)*%d%%%d=%d, not 1" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_element) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(Go.asInterface((Go.setRef(_modulus) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(Go.asInterface((Go.setRef(_element) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(Go.asInterface((Go.setRef(_modulus) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(Go.asInterface((Go.setRef(_inverse) : Ref<stdgo.math.big.Big.Int_>))));
            };
        };
        {
            var _n:GoInt = (2 : GoInt);
            Go.cfor(_n < (100 : GoInt), _n++, {
                (Go.setRef(_modulus) : Ref<stdgo.math.big.Big.Int_>).setInt64((_n : GoInt64));
                {
                    var _x:GoInt = (1 : GoInt);
                    Go.cfor(_x < _n, _x++, {
                        (Go.setRef(_element) : Ref<stdgo.math.big.Big.Int_>).setInt64((_x : GoInt64));
                        (Go.setRef(_gcd) : Ref<stdgo.math.big.Big.Int_>).gcd(null, null, (Go.setRef(_element) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_modulus) : Ref<stdgo.math.big.Big.Int_>));
                        if ((Go.setRef(_gcd) : Ref<stdgo.math.big.Big.Int_>).cmp(_one) != ((0 : GoInt))) {
                            continue;
                        };
                        (Go.setRef(_inverse) : Ref<stdgo.math.big.Big.Int_>).modInverse((Go.setRef(_element) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_modulus) : Ref<stdgo.math.big.Big.Int_>));
                        (Go.setRef(_inverse) : Ref<stdgo.math.big.Big.Int_>).mul((Go.setRef(_inverse) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_element) : Ref<stdgo.math.big.Big.Int_>));
                        (Go.setRef(_inverse) : Ref<stdgo.math.big.Big.Int_>).mod((Go.setRef(_inverse) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_modulus) : Ref<stdgo.math.big.Big.Int_>));
                        if ((Go.setRef(_inverse) : Ref<stdgo.math.big.Big.Int_>).cmp(_one) != ((0 : GoInt))) {
                            _t.errorf(("ModInverse(%d,%d)*%d%%%d=%d, not 1" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_element) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(Go.asInterface((Go.setRef(_modulus) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(Go.asInterface((Go.setRef(_element) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(Go.asInterface((Go.setRef(_modulus) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(Go.asInterface((Go.setRef(_inverse) : Ref<stdgo.math.big.Big.Int_>))));
                        };
                    });
                };
            });
        };
    }
function benchmarkModInverse(_b:Ref<stdgo.testing.Testing.B>):Void {
        var _p = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setInt64((1i64 : GoInt64));
        _p._abs = _p._abs._shl(_p._abs, (1279u32 : GoUInt));
        _p.sub(_p, _intOne);
        var _x = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).sub(_p, _intOne);
        var _z = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                _z.modInverse(_x, _p);
            });
        };
    }
/**
    // testModSqrt is a helper for TestModSqrt,
    // which checks that ModSqrt can compute a square-root of elt^2.
**/
private function _testModSqrt(_t:Ref<stdgo.testing.Testing.T>, _elt:Ref<Int_>, _mod:Ref<Int_>, _sq:Ref<Int_>, _sqrt:Ref<Int_>):Bool {
        var __0:Int_ = ({} : stdgo.math.big.Big.Int_), __1:Int_ = ({} : stdgo.math.big.Big.Int_), __2:Int_ = ({} : stdgo.math.big.Big.Int_), _sqrtsq:Int_ = __2, _sqrtChk:Int_ = __1, _sqChk:Int_ = __0;
        _sq.mul(_elt, _elt);
        _sq.mod(_sq, _mod);
        var _z = _sqrt.modSqrt(_sq, _mod);
        if (_z != (_sqrt)) {
            _t.errorf(("ModSqrt returned wrong value %s" : GoString), Go.toInterface(Go.asInterface(_z)));
        };
        _sqChk.add(_sq, _mod);
        _z = _sqrtChk.modSqrt((Go.setRef(_sqChk) : Ref<stdgo.math.big.Big.Int_>), _mod);
        if ((_z != (Go.setRef(_sqrtChk) : Ref<stdgo.math.big.Big.Int_>)) || (_z.cmp(_sqrt) != (0 : GoInt))) {
            _t.errorf(("ModSqrt returned inconsistent value %s" : GoString), Go.toInterface(Go.asInterface(_z)));
        };
        _sqChk.sub(_sq, _mod);
        _z = _sqrtChk.modSqrt((Go.setRef(_sqChk) : Ref<stdgo.math.big.Big.Int_>), _mod);
        if ((_z != (Go.setRef(_sqrtChk) : Ref<stdgo.math.big.Big.Int_>)) || (_z.cmp(_sqrt) != (0 : GoInt))) {
            _t.errorf(("ModSqrt returned inconsistent value %s" : GoString), Go.toInterface(Go.asInterface(_z)));
        };
        _z = _sqrtChk.modSqrt(_sqrtChk.set(_sq), _mod);
        if ((_z != (Go.setRef(_sqrtChk) : Ref<stdgo.math.big.Big.Int_>)) || (_z.cmp(_sqrt) != (0 : GoInt))) {
            _t.errorf(("ModSqrt returned inconsistent value %s" : GoString), Go.toInterface(Go.asInterface(_z)));
        };
        if (_sqrt.cmp(_elt) == ((0 : GoInt))) {
            return true;
        };
        _sqrtsq.mul(_sqrt, _sqrt);
        _sqrtsq.mod((Go.setRef(_sqrtsq) : Ref<stdgo.math.big.Big.Int_>), _mod);
        return _sq.cmp((Go.setRef(_sqrtsq) : Ref<stdgo.math.big.Big.Int_>)) == ((0 : GoInt));
    }
function testModSqrt(_t:Ref<stdgo.testing.Testing.T>):Void {
        var __0:Int_ = ({} : stdgo.math.big.Big.Int_), __1:Int_ = ({} : stdgo.math.big.Big.Int_), __2:Int_ = ({} : stdgo.math.big.Big.Int_), __3:Int_ = ({} : stdgo.math.big.Big.Int_), __4:Int_ = ({} : stdgo.math.big.Big.Int_), _sqrt:Int_ = __4, _sq:Int_ = __3, _modx4:Int_ = __2, _mod:Int_ = __1, _elt:Int_ = __0;
        var _r = stdgo.math.rand.Rand.new_(stdgo.math.rand.Rand.newSource((9i64 : GoInt64)));
        for (_i => _s in (_primes.__slice__((1 : GoInt)) : Slice<GoString>)) {
            _mod.setString(_s, (10 : GoInt));
            _modx4.lsh((Go.setRef(_mod) : Ref<stdgo.math.big.Big.Int_>), (2u32 : GoUInt));
            {
                var _x:GoInt = (1 : GoInt);
                Go.cfor(_x < (5 : GoInt), _x++, {
                    _elt.rand(_r, (Go.setRef(_modx4) : Ref<stdgo.math.big.Big.Int_>));
                    _elt.sub((Go.setRef(_elt) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_mod) : Ref<stdgo.math.big.Big.Int_>));
                    if (!_testModSqrt(_t, (Go.setRef(_elt) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_mod) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_sq) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_sqrt) : Ref<stdgo.math.big.Big.Int_>))) {
                        _t.errorf(("#%d: failed (sqrt(e) = %s)" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface((Go.setRef(_sqrt) : Ref<stdgo.math.big.Big.Int_>))));
                    };
                });
            };
            if (stdgo.testing.Testing.short() && (_i > (2 : GoInt))) {
                break;
            };
        };
        if (stdgo.testing.Testing.short()) {
            return;
        };
        {
            var _n:GoInt = (3 : GoInt);
            Go.cfor(_n < (100 : GoInt), _n++, {
                _mod.setInt64((_n : GoInt64));
                if (!_mod.probablyPrime((10 : GoInt))) {
                    continue;
                };
                var _isSquare = new Slice<Bool>((_n : GoInt).toBasic(), 0, ...[for (i in 0 ... (_n : GoInt).toBasic()) false]);
                {
                    var _x:GoInt = (1 : GoInt);
                    Go.cfor(_x < _n, _x++, {
                        _elt.setInt64((_x : GoInt64));
                        if (!_testModSqrt(_t, (Go.setRef(_elt) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_mod) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_sq) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_sqrt) : Ref<stdgo.math.big.Big.Int_>))) {
                            _t.errorf(("#%d: failed (sqrt(%d,%d) = %s)" : GoString), Go.toInterface(_x), Go.toInterface(Go.asInterface((Go.setRef(_elt) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(Go.asInterface((Go.setRef(_mod) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(Go.asInterface((Go.setRef(_sqrt) : Ref<stdgo.math.big.Big.Int_>))));
                        };
                        _isSquare[(_sq.uint64() : GoInt)] = true;
                    });
                };
                {
                    var _x:GoInt = (1 : GoInt);
                    Go.cfor(_x < _n, _x++, {
                        _sq.setInt64((_x : GoInt64));
                        var _z = _sqrt.modSqrt((Go.setRef(_sq) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_mod) : Ref<stdgo.math.big.Big.Int_>));
                        if (!_isSquare[(_x : GoInt)] && ((_z != null) && ((_z : Dynamic).__nil__ == null || !(_z : Dynamic).__nil__))) {
                            _t.errorf(("#%d: failed (sqrt(%d,%d) = nil)" : GoString), Go.toInterface(_x), Go.toInterface(Go.asInterface((Go.setRef(_sqrt) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(Go.asInterface((Go.setRef(_mod) : Ref<stdgo.math.big.Big.Int_>))));
                        };
                    });
                };
            });
        };
    }
function testJacobi(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _testCases = (new Slice<T__struct_45>(
0,
0,
({ _x : (0i64 : GoInt64), _y : (1i64 : GoInt64), _result : (1 : GoInt) } : T__struct_45),
({ _x : (0i64 : GoInt64), _y : (-1i64 : GoInt64), _result : (1 : GoInt) } : T__struct_45),
({ _x : (1i64 : GoInt64), _y : (1i64 : GoInt64), _result : (1 : GoInt) } : T__struct_45),
({ _x : (1i64 : GoInt64), _y : (-1i64 : GoInt64), _result : (1 : GoInt) } : T__struct_45),
({ _x : (0i64 : GoInt64), _y : (5i64 : GoInt64), _result : (0 : GoInt) } : T__struct_45),
({ _x : (1i64 : GoInt64), _y : (5i64 : GoInt64), _result : (1 : GoInt) } : T__struct_45),
({ _x : (2i64 : GoInt64), _y : (5i64 : GoInt64), _result : (-1 : GoInt) } : T__struct_45),
({ _x : (-2i64 : GoInt64), _y : (5i64 : GoInt64), _result : (-1 : GoInt) } : T__struct_45),
({ _x : (2i64 : GoInt64), _y : (-5i64 : GoInt64), _result : (-1 : GoInt) } : T__struct_45),
({ _x : (-2i64 : GoInt64), _y : (-5i64 : GoInt64), _result : (1 : GoInt) } : T__struct_45),
({ _x : (3i64 : GoInt64), _y : (5i64 : GoInt64), _result : (-1 : GoInt) } : T__struct_45),
({ _x : (5i64 : GoInt64), _y : (5i64 : GoInt64), _result : (0 : GoInt) } : T__struct_45),
({ _x : (-5i64 : GoInt64), _y : (5i64 : GoInt64), _result : (0 : GoInt) } : T__struct_45),
({ _x : (6i64 : GoInt64), _y : (5i64 : GoInt64), _result : (1 : GoInt) } : T__struct_45),
({ _x : (6i64 : GoInt64), _y : (-5i64 : GoInt64), _result : (1 : GoInt) } : T__struct_45),
({ _x : (-6i64 : GoInt64), _y : (5i64 : GoInt64), _result : (1 : GoInt) } : T__struct_45),
({ _x : (-6i64 : GoInt64), _y : (-5i64 : GoInt64), _result : (-1 : GoInt) } : T__struct_45)) : Slice<T__struct_45>);
        var __0:Int_ = ({} : stdgo.math.big.Big.Int_), __1:Int_ = ({} : stdgo.math.big.Big.Int_), _y:Int_ = __1, _x:Int_ = __0;
        for (_i => _test in _testCases) {
            _x.setInt64(_test._x);
            _y.setInt64(_test._y);
            var _expected:GoInt = _test._result;
            var _actual:GoInt = jacobi((Go.setRef(_x) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_y) : Ref<stdgo.math.big.Big.Int_>));
            if (_actual != (_expected)) {
                _t.errorf(("#%d: Jacobi(%d, %d) = %d, but expected %d" : GoString), Go.toInterface(_i), Go.toInterface(_test._x), Go.toInterface(_test._y), Go.toInterface(_actual), Go.toInterface(_expected));
            };
        };
    }
function testJacobiPanic(_t:Ref<stdgo.testing.Testing.T>):Void {
        var __deferstack__:Array<Void -> Void> = [];
        try {
            {};
            __deferstack__.unshift(() -> {
                var a = function():Void {
                    var _msg:AnyInterface = ({
                        final r = Go.recover_exception;
                        Go.recover_exception = null;
                        r;
                    });
                    if ((_msg == null) || (_msg == Go.toInterface(("test failure" : GoString)))) {
                        throw Go.toInterface(_msg);
                    };
                    _t.log(_msg);
                };
                a();
            });
            var _x = newInt((1i64 : GoInt64));
            var _y = newInt((2i64 : GoInt64));
            jacobi(_x, _y);
            throw Go.toInterface(("test failure" : GoString));
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return;
        };
    }
function testIssue2607(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _n = newInt((10i64 : GoInt64));
        _n.rand(stdgo.math.rand.Rand.new_(stdgo.math.rand.Rand.newSource((9i64 : GoInt64))), _n);
    }
function testSqrt(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _root:GoInt = (0 : GoInt);
        var _r = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < (10000 : GoInt), _i++, {
                if (((_root + (1 : GoInt)) * (_root + (1 : GoInt))) <= _i) {
                    _root++;
                };
                var _n = newInt((_i : GoInt64));
                _r.setInt64((-2i64 : GoInt64));
                _r.sqrt(_n);
                if (_r.cmp(newInt((_root : GoInt64))) != ((0 : GoInt))) {
                    _t.errorf(("Sqrt(%v) = %v, want %v" : GoString), Go.toInterface(Go.asInterface(_n)), Go.toInterface(Go.asInterface(_r)), Go.toInterface(_root));
                };
            });
        };
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < (1000 : GoInt), _i = _i + ((10 : GoInt)), {
                var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(("1" : GoString) + stdgo.strings.Strings.repeat(("0" : GoString), _i), (10 : GoInt)), _n:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __0:Bool = __tmp__._1;
                var _r = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).sqrt(_n);
                var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(("1" : GoString) + stdgo.strings.Strings.repeat(("0" : GoString), _i / (2 : GoInt)), (10 : GoInt)), _root:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __1:Bool = __tmp__._1;
                if (_r.cmp(_root) != ((0 : GoInt))) {
                    _t.errorf(("Sqrt(1e%d) = %v, want 1e%d" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface(_r)), Go.toInterface(_i / (2 : GoInt)));
                };
            });
        };
        _r.setInt64((100i64 : GoInt64));
        _r.sqrt(_r);
        if (_r.int64() != ((10i64 : GoInt64))) {
            _t.errorf(("Sqrt(100) = %v, want 10 (aliased output)" : GoString), Go.toInterface(_r.int64()));
        };
    }
/**
    // We can't test this together with the other Exp tests above because
    // it requires a different receiver setup.
**/
function testIssue22830(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _one = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setInt64((1i64 : GoInt64));
        var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(("84555555300000000000" : GoString), (10 : GoInt)), _base:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __0:Bool = __tmp__._1;
        var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(("66666670001111111111" : GoString), (10 : GoInt)), _mod:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __1:Bool = __tmp__._1;
        var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(("17888885298888888889" : GoString), (10 : GoInt)), _want:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __2:Bool = __tmp__._1;
        var _tests:Slice<GoInt64> = (new Slice<GoInt64>(0, 0, (0i64 : GoInt64), (1i64 : GoInt64), (-1i64 : GoInt64)) : Slice<GoInt64>);
        for (__3 => _n in _tests) {
            var _m = newInt(_n);
            {
                var _got = _m.exp(_base, _one, _mod);
                if (_got.cmp(_want) != ((0 : GoInt))) {
                    _t.errorf(("(%v).Exp(%s, 1, %s) = %s, want %s" : GoString), Go.toInterface(_n), Go.toInterface(Go.asInterface(_base)), Go.toInterface(Go.asInterface(_mod)), Go.toInterface(Go.asInterface(_got)), Go.toInterface(Go.asInterface(_want)));
                };
            };
        };
    }
function benchmarkSqrt(_b:Ref<stdgo.testing.Testing.B>):Void {
        var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(("1" : GoString) + stdgo.strings.Strings.repeat(("0" : GoString), (1001 : GoInt)), (10 : GoInt)), _n:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __0:Bool = __tmp__._1;
        _b.resetTimer();
        var _t = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                _t.sqrt(_n);
            });
        };
    }
private function _benchmarkIntSqr(_b:Ref<stdgo.testing.Testing.B>, _nwords:GoInt):Void {
        var _x = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        _x._abs = _rndNat(_nwords);
        var _t = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        _b.resetTimer();
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                _t.mul(_x, _x);
            });
        };
    }
function benchmarkIntSqr(_b:Ref<stdgo.testing.Testing.B>):Void {
        for (__0 => _n in _sqrBenchSizes) {
            if (_isRaceBuilder && (_n > (1000 : GoInt))) {
                continue;
            };
            _b.run(stdgo.fmt.Fmt.sprintf(("%d" : GoString), Go.toInterface(_n)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                _benchmarkIntSqr(_b, _n);
            });
        };
    }
private function _benchmarkDiv(_b:Ref<stdgo.testing.Testing.B>, _aSize:GoInt, _bSize:GoInt):Void {
        var _r:Ref<stdgo.math.rand.Rand.Rand> = stdgo.math.rand.Rand.new_(stdgo.math.rand.Rand.newSource((1234i64 : GoInt64)));
        var _aa = _randInt(_r, (_aSize : GoUInt));
        var _bb = _randInt(_r, (_bSize : GoUInt));
        if (_aa.cmp(_bb) < (0 : GoInt)) {
            {
                final __tmp__0 = _bb;
                final __tmp__1 = _aa;
                _aa = __tmp__0;
                _bb = __tmp__1;
            };
        };
        var _x = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        var _y = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        _b.resetTimer();
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                _x.divMod(_aa, _bb, _y);
            });
        };
    }
function benchmarkDiv(_b:Ref<stdgo.testing.Testing.B>):Void {
        var _sizes = (new Slice<GoInt>(
0,
0,
(10 : GoInt),
(20 : GoInt),
(50 : GoInt),
(100 : GoInt),
(200 : GoInt),
(500 : GoInt),
(1000 : GoInt),
(10000 : GoInt),
(100000 : GoInt),
(1000000 : GoInt),
(10000000 : GoInt)) : Slice<GoInt>);
        for (__0 => _i in _sizes) {
            var _j:GoInt = (2 : GoInt) * _i;
            _b.run(stdgo.fmt.Fmt.sprintf(("%d/%d" : GoString), Go.toInterface(_j), Go.toInterface(_i)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                _benchmarkDiv(_b, _j, _i);
            });
        };
    }
function testFillBytes(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _checkResult = function(_t:Ref<stdgo.testing.Testing.T>, _buf:Slice<GoByte>, _want:Ref<Int_>):Void {
            _t.helper();
            var _got = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setBytes(_buf);
            if (_got.cmpAbs(_want) != ((0 : GoInt))) {
                _t.errorf(("got 0x%x, want 0x%x: %x" : GoString), Go.toInterface(Go.asInterface(_got)), Go.toInterface(Go.asInterface(_want)), Go.toInterface(_buf));
            };
        };
        var _panics:(() -> Void) -> Bool = function(_f:() -> Void):Bool {
            var __deferstack__:Array<Void -> Void> = [];
            var _panic:Bool = false;
            try {
                __deferstack__.unshift(() -> {
                    var a = function():Void {
                        _panic = ({
                            final r = Go.recover_exception;
                            Go.recover_exception = null;
                            r;
                        }) != null;
                    };
                    a();
                });
                _f();
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return _panic;
                };
                for (defer in __deferstack__) {
                    defer();
                };
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    if (Go.recover_exception != null) throw Go.recover_exception;
                    return _panic;
                };
            } catch(__exception__) {
                var exe:Dynamic = __exception__.native;
                if ((exe is haxe.ValueException)) exe = exe.value;
                if (!(exe is AnyInterfaceData)) {
                    exe = Go.toInterface(__exception__.message);
                };
                Go.recover_exception = exe;
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return _panic;
            };
        };
        for (__0 => _n in (new Slice<GoString>(0, 0, ("0" : GoString), ("1000" : GoString), ("0xffffffff" : GoString), ("-0xffffffff" : GoString), ("0xffffffffffffffff" : GoString), ("0x10000000000000000" : GoString), ("0xabababababababababababababababababababababababababa" : GoString), ("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" : GoString)) : Slice<GoString>)) {
            _t.run(_n, function(_t:Ref<stdgo.testing.Testing.T>):Void {
                _t.logf(_n);
                var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_n, (0 : GoInt)), _x:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
                if (!_ok) {
                    throw Go.toInterface(("invalid test entry" : GoString));
                };
                var _byteLen:GoInt = (_x.bitLen() + (7 : GoInt)) / (8 : GoInt);
                var _buf = new Slice<GoUInt8>((_byteLen : GoInt).toBasic(), 0, ...[for (i in 0 ... (_byteLen : GoInt).toBasic()) (0 : GoUInt8)]);
                _checkResult(_t, _x.fillBytes(_buf), _x);
                _buf = new Slice<GoUInt8>((100 : GoInt).toBasic(), 0, ...[for (i in 0 ... (100 : GoInt).toBasic()) (0 : GoUInt8)]);
                for (_i in 0 ... _buf.length.toBasic()) {
                    _buf[(_i : GoInt)] = (255 : GoUInt8);
                };
                _checkResult(_t, _x.fillBytes(_buf), _x);
                if (_byteLen > (0 : GoInt)) {
                    _buf = new Slice<GoUInt8>((_byteLen - (1 : GoInt) : GoInt).toBasic(), 0, ...[for (i in 0 ... (_byteLen - (1 : GoInt) : GoInt).toBasic()) (0 : GoUInt8)]);
                    if (!_panics(function():Void {
                        _x.fillBytes(_buf);
                    })) {
                        _t.errorf(("expected panic for small buffer and value %x" : GoString), Go.toInterface(Go.asInterface(_x)));
                    };
                };
            });
        };
    }
function testNewIntMinInt64(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _want:GoInt64 = (-9223372036854775808i64 : GoInt64);
        {
            var _got:GoInt64 = newInt(_want).int64();
            if (_got != (_want)) {
                _t.fatalf(("wanted %d, got %d" : GoString), Go.toInterface(_want), Go.toInterface(_got));
            };
        };
    }
function testNewIntAllocs(_t:Ref<stdgo.testing.Testing.T>):Void {
        stdgo.internal.testenv.Testenv.skipIfOptimizationOff(Go.asInterface(_t));
        for (__0 => _n in (new Slice<GoInt64>(0, 0, (0i64 : GoInt64), (7i64 : GoInt64), (-7i64 : GoInt64), (1073741824i64 : GoInt64), (-1073741824i64 : GoInt64), (1125899906842624i64 : GoInt64), (-1125899906842624i64 : GoInt64)) : Slice<GoInt64>)) {
            var _x = newInt((3i64 : GoInt64));
            var _got:GoFloat64 = stdgo.testing.Testing.allocsPerRun((100 : GoInt), function():Void {
                _x.add(_x, newInt(_n));
            });
            if (_got != (0 : GoFloat64)) {
                _t.errorf(("x.Add(x, NewInt(%d)), wanted 0 allocations, got %f" : GoString), Go.toInterface(_n), Go.toInterface(_got));
            };
        };
    }
/**
    // write count copies of text to s.
**/
private function _writeMultiple(_s:stdgo.fmt.Fmt.State, _text:GoString, _count:GoInt):Void {
        if ((_text.length) > (0 : GoInt)) {
            var _b = (_text : Slice<GoByte>);
            Go.cfor(_count > (0 : GoInt), _count--, {
                _s.write(_b);
            });
        };
    }
private function _scanSign(_r:stdgo.io.Io.ByteScanner):{ var _0 : Bool; var _1 : Error; } {
        var _neg:Bool = false, _err:Error = (null : Error);
        var _ch:GoByte = (0 : GoUInt8);
        {
            {
                var __tmp__ = _r.readByte();
                _ch = __tmp__._0;
                _err = __tmp__._1;
            };
            if (_err != null) {
                return { _0 : false, _1 : _err };
            };
        };
        {
            final __value__ = _ch;
            if (__value__ == ((45 : GoUInt8))) {
                _neg = true;
            } else if (__value__ == ((43 : GoUInt8))) {} else {
                _r.unreadByte();
            };
        };
        return { _0 : _neg, _1 : _err };
    }
function testIntText(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _z = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        for (__0 => _test in _stringTests) {
            if (!_test._ok) {
                continue;
            };
            var __tmp__ = _z.setString(_test._in, _test._base), __1:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _t.errorf(("%v: failed to parse" : GoString), Go.toInterface(Go.asInterface(_test)));
                continue;
            };
            var _base:GoInt = _test._base;
            if (_base == ((0 : GoInt))) {
                _base = (10 : GoInt);
            };
            {
                var _got:GoString = _z.text(_base);
                if (_got != (_test._out)) {
                    _t.errorf(("%v: got %s; want %s" : GoString), Go.toInterface(Go.asInterface(_test)), Go.toInterface(_got), Go.toInterface(_test._out));
                };
            };
        };
    }
function testAppendText(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _z = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        var _buf:Slice<GoByte> = (null : Slice<GoUInt8>);
        for (__0 => _test in _stringTests) {
            if (!_test._ok) {
                continue;
            };
            var __tmp__ = _z.setString(_test._in, _test._base), __1:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _t.errorf(("%v: failed to parse" : GoString), Go.toInterface(Go.asInterface(_test)));
                continue;
            };
            var _base:GoInt = _test._base;
            if (_base == ((0 : GoInt))) {
                _base = (10 : GoInt);
            };
            var _i:GoInt = (_buf.length);
            _buf = _z.append(_buf, _base);
            {
                var _got:GoString = ((_buf.__slice__(_i) : Slice<GoUInt8>) : GoString);
                if (_got != (_test._out)) {
                    _t.errorf(("%v: got %s; want %s" : GoString), Go.toInterface(Go.asInterface(_test)), Go.toInterface(_got), Go.toInterface(_test._out));
                };
            };
        };
    }
private function _format(_base:GoInt):GoString {
        {
            final __value__ = _base;
            if (__value__ == ((2 : GoInt))) {
                return ("%b" : GoString);
            } else if (__value__ == ((8 : GoInt))) {
                return ("%o" : GoString);
            } else if (__value__ == ((16 : GoInt))) {
                return ("%x" : GoString);
            };
        };
        return ("%d" : GoString);
    }
function testGetString(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _z = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        for (_i => _test in _stringTests) {
            if (!_test._ok) {
                continue;
            };
            _z.setInt64(_test._val);
            if (_test._base == ((10 : GoInt))) {
                {
                    var _got:GoString = (_z.string() : GoString);
                    if (_got != (_test._out)) {
                        _t.errorf(("#%da got %s; want %s" : GoString), Go.toInterface(_i), Go.toInterface(_got), Go.toInterface(_test._out));
                    };
                };
            };
            var _f:GoString = _format(_test._base);
            var _got:GoString = stdgo.fmt.Fmt.sprintf(_f, Go.toInterface(Go.asInterface(_z)));
            if (_f == (("%d" : GoString))) {
                if (_got != (stdgo.fmt.Fmt.sprintf(("%d" : GoString), Go.toInterface(_test._val)))) {
                    _t.errorf(("#%db got %s; want %d" : GoString), Go.toInterface(_i), Go.toInterface(_got), Go.toInterface(_test._val));
                };
            } else {
                if (_got != (_test._out)) {
                    _t.errorf(("#%dc got %s; want %s" : GoString), Go.toInterface(_i), Go.toInterface(_got), Go.toInterface(_test._out));
                };
            };
        };
    }
function testSetString(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _tmp = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        for (_i => _test in _stringTests) {
            _tmp.setInt64((1234567890i64 : GoInt64));
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._in, _test._base), _n1:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, _ok1:Bool = __tmp__._1;
            var __tmp__ = _tmp.setString(_test._in, _test._base), _n2:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, _ok2:Bool = __tmp__._1;
            var _expected = newInt(_test._val);
            if ((_ok1 != _test._ok) || (_ok2 != _test._ok)) {
                _t.errorf(("#%d (input \'%s\') ok incorrect (should be %t)" : GoString), Go.toInterface(_i), Go.toInterface(_test._in), Go.toInterface(_test._ok));
                continue;
            };
            if (!_ok1) {
                if (_n1 != null && ((_n1 : Dynamic).__nil__ == null || !(_n1 : Dynamic).__nil__)) {
                    _t.errorf(("#%d (input \'%s\') n1 != nil" : GoString), Go.toInterface(_i), Go.toInterface(_test._in));
                };
                continue;
            };
            if (!_ok2) {
                if (_n2 != null && ((_n2 : Dynamic).__nil__ == null || !(_n2 : Dynamic).__nil__)) {
                    _t.errorf(("#%d (input \'%s\') n2 != nil" : GoString), Go.toInterface(_i), Go.toInterface(_test._in));
                };
                continue;
            };
            if (_ok1 && !_isNormalized(_n1)) {
                _t.errorf(("#%d (input \'%s\'): %v is not normalized" : GoString), Go.toInterface(_i), Go.toInterface(_test._in), Go.toInterface(Go.asInterface((_n1 : stdgo.math.big.Big.Int_))));
            };
            if (_ok2 && !_isNormalized(_n2)) {
                _t.errorf(("#%d (input \'%s\'): %v is not normalized" : GoString), Go.toInterface(_i), Go.toInterface(_test._in), Go.toInterface(Go.asInterface((_n2 : stdgo.math.big.Big.Int_))));
            };
            if (_n1.cmp(_expected) != ((0 : GoInt))) {
                _t.errorf(("#%d (input \'%s\') got: %s want: %d" : GoString), Go.toInterface(_i), Go.toInterface(_test._in), Go.toInterface(Go.asInterface(_n1)), Go.toInterface(_test._val));
            };
            if (_n2.cmp(_expected) != ((0 : GoInt))) {
                _t.errorf(("#%d (input \'%s\') got: %s want: %d" : GoString), Go.toInterface(_i), Go.toInterface(_test._in), Go.toInterface(Go.asInterface(_n2)), Go.toInterface(_test._val));
            };
        };
    }
function testFormat(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _test in _formatTests) {
            var _x:Ref<Int_> = (null : Ref<stdgo.math.big.Big.Int_>);
            if (_test._input != (("<nil>" : GoString))) {
                var _ok:Bool = false;
                {
                    var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._input, (0 : GoInt));
                    _x = __tmp__._0;
                    _ok = __tmp__._1;
                };
                if (!_ok) {
                    _t.errorf(("#%d failed reading input %s" : GoString), Go.toInterface(_i), Go.toInterface(_test._input));
                };
            };
            var _output:GoString = stdgo.fmt.Fmt.sprintf(_test._format, Go.toInterface(Go.asInterface(_x)));
            if (_output != (_test._output)) {
                _t.errorf(("#%d got %q; want %q, {%q, %q, %q}" : GoString), Go.toInterface(_i), Go.toInterface(_output), Go.toInterface(_test._output), Go.toInterface(_test._input), Go.toInterface(_test._format), Go.toInterface(_test._output));
            };
        };
    }
function testScan(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        for (_i => _test in _scanTests) {
            var _x = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
            _buf.reset();
            _buf.writeString(_test._input);
            {
                var __tmp__ = stdgo.fmt.Fmt.fscanf(Go.asInterface((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>)), _test._format, Go.toInterface(Go.asInterface(_x))), __0:GoInt = __tmp__._0, _err:Error = __tmp__._1;
                if (_err != null) {
                    _t.errorf(("#%d error: %s" : GoString), Go.toInterface(_i), Go.toInterface(_err));
                };
            };
            if ((_x.string() : GoString) != (_test._output)) {
                _t.errorf(("#%d got %s; want %s" : GoString), Go.toInterface(_i), Go.toInterface((_x.string() : GoString)), Go.toInterface(_test._output));
            };
            if (_buf.len() != (_test._remaining)) {
                _t.errorf(("#%d got %d bytes remaining; want %d" : GoString), Go.toInterface(_i), Go.toInterface(_buf.len()), Go.toInterface(_test._remaining));
            };
        };
    }
function testIntGobEncoding(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _medium:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        var _enc = stdgo.encoding.gob.Gob.newEncoder(Go.asInterface((Go.setRef(_medium) : Ref<stdgo.bytes.Bytes.Buffer>)));
        var _dec = stdgo.encoding.gob.Gob.newDecoder(Go.asInterface((Go.setRef(_medium) : Ref<stdgo.bytes.Bytes.Buffer>)));
        for (__0 => _test in _encodingTests) {
            for (__1 => _sign in (new Slice<GoString>(0, 0, Go.str(), ("+" : GoString), ("-" : GoString)) : Slice<GoString>)) {
                var _x:GoString = _sign + _test;
                _medium.reset();
                var _tx:Int_ = ({} : stdgo.math.big.Big.Int_);
                _tx.setString(_x, (10 : GoInt));
                {
                    var _err:Error = _enc.encode(Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Int_>))));
                    if (_err != null) {
                        _t.errorf(("encoding of %s failed: %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(_err));
                        continue;
                    };
                };
                var _rx:Int_ = ({} : stdgo.math.big.Big.Int_);
                {
                    var _err:Error = _dec.decode(Go.toInterface(Go.asInterface((Go.setRef(_rx) : Ref<stdgo.math.big.Big.Int_>))));
                    if (_err != null) {
                        _t.errorf(("decoding of %s failed: %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(_err));
                        continue;
                    };
                };
                if (_rx.cmp((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Int_>)) != ((0 : GoInt))) {
                    _t.errorf(("transmission of %s failed: got %s want %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(Go.asInterface((Go.setRef(_rx) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Int_>))));
                };
            };
        };
    }
/**
    // Sending a nil Int pointer (inside a slice) on a round trip through gob should yield a zero.
    // TODO: top-level nils.
**/
function testGobEncodingNilIntInSlice(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _buf = (Go.setRef(({} : stdgo.bytes.Bytes.Buffer)) : Ref<stdgo.bytes.Bytes.Buffer>);
        var _enc = stdgo.encoding.gob.Gob.newEncoder(Go.asInterface(_buf));
        var _dec = stdgo.encoding.gob.Gob.newDecoder(Go.asInterface(_buf));
        var _in:Slice<Ref<stdgo.math.big.Big.Int_>> = new Slice<Ref<stdgo.math.big.Big.Int_>>((1 : GoInt).toBasic(), 0, ...[for (i in 0 ... (1 : GoInt).toBasic()) (null : Ref<stdgo.math.big.Big.Int_>)]);
        var _err:Error = _enc.encode(Go.toInterface((Go.setRef(_in) : Ref<Slice<Ref<stdgo.math.big.Big.Int_>>>)));
        if (_err != null) {
            _t.errorf(("gob encode failed: %q" : GoString), Go.toInterface(_err));
        };
        var _out:Slice<Ref<Int_>> = (null : Slice<Ref<stdgo.math.big.Big.Int_>>);
        _err = _dec.decode(Go.toInterface((Go.setRef(_out) : Ref<Slice<Ref<stdgo.math.big.Big.Int_>>>)));
        if (_err != null) {
            _t.fatalf(("gob decode failed: %q" : GoString), Go.toInterface(_err));
        };
        if ((_out.length) != ((1 : GoInt))) {
            _t.fatalf(("wrong len; want 1 got %d" : GoString), Go.toInterface((_out.length)));
        };
        var _zero:Int_ = ({} : stdgo.math.big.Big.Int_);
        if (_out[(0 : GoInt)].cmp((Go.setRef(_zero) : Ref<stdgo.math.big.Big.Int_>)) != ((0 : GoInt))) {
            _t.fatalf(("transmission of (*Int)(nil) failed: got %s want 0" : GoString), Go.toInterface(_out));
        };
    }
function testIntJSONEncoding(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in _encodingTests) {
            for (__1 => _sign in (new Slice<GoString>(0, 0, Go.str(), ("+" : GoString), ("-" : GoString)) : Slice<GoString>)) {
                var _x:GoString = _sign + _test;
                var _tx:Int_ = ({} : stdgo.math.big.Big.Int_);
                _tx.setString(_x, (10 : GoInt));
                var __tmp__ = stdgo.encoding.json.Json.marshal(Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Int_>)))), _b:Slice<GoUInt8> = __tmp__._0, _err:Error = __tmp__._1;
                if (_err != null) {
                    _t.errorf(("marshaling of %s failed: %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(_err));
                    continue;
                };
                var _rx:Int_ = ({} : stdgo.math.big.Big.Int_);
                {
                    var _err:Error = stdgo.encoding.json.Json.unmarshal(_b, Go.toInterface(Go.asInterface((Go.setRef(_rx) : Ref<stdgo.math.big.Big.Int_>))));
                    if (_err != null) {
                        _t.errorf(("unmarshaling of %s failed: %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(_err));
                        continue;
                    };
                };
                if (_rx.cmp((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Int_>)) != ((0 : GoInt))) {
                    _t.errorf(("JSON encoding of %s failed: got %s want %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(Go.asInterface((Go.setRef(_rx) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Int_>))));
                };
            };
        };
    }
function testIntJSONEncodingNil(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _x:Ref<Int_> = (null : Ref<stdgo.math.big.Big.Int_>);
        var __tmp__ = _x.marshalJSON(), _b:Slice<GoUInt8> = __tmp__._0, _err:Error = __tmp__._1;
        if (_err != null) {
            _t.fatalf(("marshaling of nil failed: %s" : GoString), Go.toInterface(_err));
        };
        var _got:GoString = (_b : GoString);
        var _want:GoString = ("null" : GoString);
        if (_got != (_want)) {
            _t.fatalf(("marshaling of nil failed: got %s want %s" : GoString), Go.toInterface(_got), Go.toInterface(_want));
        };
    }
function testIntXMLEncoding(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in _encodingTests) {
            for (__1 => _sign in (new Slice<GoString>(0, 0, Go.str(), ("+" : GoString), ("-" : GoString)) : Slice<GoString>)) {
                var _x:GoString = _sign + _test;
                var _tx:Int_ = ({} : stdgo.math.big.Big.Int_);
                _tx.setString(_x, (0 : GoInt));
                var __tmp__ = stdgo.encoding.xml.Xml_.marshal(Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Int_>)))), _b:Slice<GoUInt8> = __tmp__._0, _err:Error = __tmp__._1;
                if (_err != null) {
                    _t.errorf(("marshaling of %s failed: %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(_err));
                    continue;
                };
                var _rx:Int_ = ({} : stdgo.math.big.Big.Int_);
                {
                    var _err:Error = stdgo.encoding.xml.Xml_.unmarshal(_b, Go.toInterface(Go.asInterface((Go.setRef(_rx) : Ref<stdgo.math.big.Big.Int_>))));
                    if (_err != null) {
                        _t.errorf(("unmarshaling of %s failed: %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(_err));
                        continue;
                    };
                };
                if (_rx.cmp((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Int_>)) != ((0 : GoInt))) {
                    _t.errorf(("XML encoding of %s failed: got %s want %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(Go.asInterface((Go.setRef(_rx) : Ref<stdgo.math.big.Big.Int_>))), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Int_>))));
                };
            };
        };
    }
/**
    // Tests that the linker is able to remove references to Float, Rat,
    // and Int if unused (notably, not used by init).
**/
function testLinkerGC(_t:Ref<stdgo.testing.Testing.T>):Void {
        if (stdgo.testing.Testing.short()) {
            _t.skip(Go.toInterface(("skipping in short mode" : GoString)));
        };
        _t.parallel();
        var _tmp:GoString = _t.tempDir();
        var _goBin:GoString = stdgo.internal.testenv.Testenv.goToolPath(Go.asInterface(_t));
        var _goFile:GoString = stdgo.path.filepath.Filepath.join(_tmp, ("x.go" : GoString));
        var _file = (("package main\nimport _ \"math/big\"\nfunc main() {}\n" : GoString) : Slice<GoByte>);
        {
            var _err:Error = stdgo.os.Os.writeFile(_goFile, _file, (420u32 : stdgo.io.fs.Fs.FileMode));
            if (_err != null) {
                _t.fatal(Go.toInterface(_err));
            };
        };
        var _cmd = stdgo.os.exec.Exec.command(_goBin, ("build" : GoString), ("-o" : GoString), ("x.exe" : GoString), ("x.go" : GoString));
        _cmd.dir = _tmp;
        {
            var __tmp__ = _cmd.combinedOutput(), _out:Slice<GoUInt8> = __tmp__._0, _err:Error = __tmp__._1;
            if (_err != null) {
                _t.fatalf(("compile: %v, %s" : GoString), Go.toInterface(_err), Go.toInterface(_out));
            };
        };
        _cmd = stdgo.os.exec.Exec.command(_goBin, ("tool" : GoString), ("nm" : GoString), ("x.exe" : GoString));
        _cmd.dir = _tmp;
        var __tmp__ = _cmd.combinedOutput(), _nm:Slice<GoUInt8> = __tmp__._0, _err:Error = __tmp__._1;
        if (_err != null) {
            _t.fatalf(("nm: %v, %s" : GoString), Go.toInterface(_err), Go.toInterface(_nm));
        };
        {};
        if (!stdgo.bytes.Bytes.contains(_nm, (("runtime.main" : GoString) : Slice<GoByte>))) {
            _t.errorf(("expected symbol %q not found" : GoString), Go.toInterface(("runtime.main" : GoString)));
        };
        var _bad = (new Slice<GoString>(0, 0, ("math/big.(*Float)" : GoString), ("math/big.(*Rat)" : GoString), ("math/big.(*Int)" : GoString)) : Slice<GoString>);
        for (__12 => _sym in _bad) {
            if (stdgo.bytes.Bytes.contains(_nm, (_sym : Slice<GoByte>))) {
                _t.errorf(("unexpected symbol %q found" : GoString), Go.toInterface(_sym));
            };
        };
        if (_t.failed()) {
            _t.logf(("Got: %s" : GoString), Go.toInterface(_nm));
        };
    }
/**
    // basicMul multiplies x and y and leaves the result in z.
    // The (non-normalized) result is placed in z[0 : len(x) + len(y)].
**/
private function _basicMul(_z:T_nat, _x:T_nat, _y:T_nat):Void {
        (_z.__slice__((0 : GoInt), (_x.length) + (_y.length)) : stdgo.math.big.Big.T_nat)._clear();
        for (_i => _d in _y) {
            if (_d != ((0u32 : stdgo.math.big.Big.Word))) {
                _z[((_x.length) + _i : GoInt)] = _addMulVVW((_z.__slice__(_i, _i + (_x.length)) : stdgo.math.big.Big.T_nat), _x, _d);
            };
        };
    }
/**
    // Fast version of z[0:n+n>>1].add(z[0:n+n>>1], x[0:n]) w/o bounds checks.
    // Factored out for readability - do not use outside karatsuba.
**/
private function _karatsubaAdd(_z:T_nat, _x:T_nat, _n:GoInt):Void {
        {
            var _c:stdgo.math.big.Big.Word = _addVV((_z.__slice__((0 : GoInt), _n) : stdgo.math.big.Big.T_nat), _z, _x);
            if (_c != ((0u32 : stdgo.math.big.Big.Word))) {
                _addVW((_z.__slice__(_n, _n + (_n >> (1i64 : GoUInt64))) : stdgo.math.big.Big.T_nat), (_z.__slice__(_n) : stdgo.math.big.Big.T_nat), _c);
            };
        };
    }
/**
    // Like karatsubaAdd, but does subtract.
**/
private function _karatsubaSub(_z:T_nat, _x:T_nat, _n:GoInt):Void {
        {
            var _c:stdgo.math.big.Big.Word = _subVV((_z.__slice__((0 : GoInt), _n) : stdgo.math.big.Big.T_nat), _z, _x);
            if (_c != ((0u32 : stdgo.math.big.Big.Word))) {
                _subVW((_z.__slice__(_n, _n + (_n >> (1i64 : GoUInt64))) : stdgo.math.big.Big.T_nat), (_z.__slice__(_n) : stdgo.math.big.Big.T_nat), _c);
            };
        };
    }
/**
    // karatsuba multiplies x and y and leaves the result in z.
    // Both x and y must have the same length n and n must be a
    // power of 2. The result vector z must have len(z) >= 6*n.
    // The (non-normalized) result is placed in z[0 : 2*n].
**/
private function _karatsuba(_z:T_nat, _x:T_nat, _y:T_nat):Void {
        var _n:GoInt = (_y.length);
        if ((((_n & (1 : GoInt)) != (0 : GoInt)) || (_n < _karatsubaThreshold)) || (_n < (2 : GoInt))) {
            _basicMul(_z, _x, _y);
            return;
        };
        var _n2:GoInt = _n >> (1i64 : GoUInt64);
        var __0:stdgo.math.big.Big.T_nat = (_x.__slice__(_n2) : stdgo.math.big.Big.T_nat), __1:stdgo.math.big.Big.T_nat = (_x.__slice__((0 : GoInt), _n2) : stdgo.math.big.Big.T_nat), _x0:stdgo.math.big.Big.T_nat = __1, _x1:stdgo.math.big.Big.T_nat = __0;
        var __0:stdgo.math.big.Big.T_nat = (_y.__slice__(_n2) : stdgo.math.big.Big.T_nat), __1:stdgo.math.big.Big.T_nat = (_y.__slice__((0 : GoInt), _n2) : stdgo.math.big.Big.T_nat), _y0:stdgo.math.big.Big.T_nat = __1, _y1:stdgo.math.big.Big.T_nat = __0;
        _karatsuba(_z, _x0, _y0);
        _karatsuba((_z.__slice__(_n) : stdgo.math.big.Big.T_nat), _x1, _y1);
        var _s:GoInt = (1 : GoInt);
        var _xd:stdgo.math.big.Big.T_nat = (_z.__slice__((2 : GoInt) * _n, ((2 : GoInt) * _n) + _n2) : stdgo.math.big.Big.T_nat);
        if (_subVV(_xd, _x1, _x0) != ((0u32 : stdgo.math.big.Big.Word))) {
            _s = -_s;
            _subVV(_xd, _x0, _x1);
        };
        var _yd:stdgo.math.big.Big.T_nat = (_z.__slice__(((2 : GoInt) * _n) + _n2, (3 : GoInt) * _n) : stdgo.math.big.Big.T_nat);
        if (_subVV(_yd, _y0, _y1) != ((0u32 : stdgo.math.big.Big.Word))) {
            _s = -_s;
            _subVV(_yd, _y1, _y0);
        };
        var _p:stdgo.math.big.Big.T_nat = (_z.__slice__(_n * (3 : GoInt)) : stdgo.math.big.Big.T_nat);
        _karatsuba(_p, _xd, _yd);
        var _r:stdgo.math.big.Big.T_nat = (_z.__slice__(_n * (4 : GoInt)) : stdgo.math.big.Big.T_nat);
        Go.copySlice(_r, (_z.__slice__(0, _n * (2 : GoInt)) : stdgo.math.big.Big.T_nat));
        _karatsubaAdd((_z.__slice__(_n2) : stdgo.math.big.Big.T_nat), _r, _n);
        _karatsubaAdd((_z.__slice__(_n2) : stdgo.math.big.Big.T_nat), (_r.__slice__(_n) : stdgo.math.big.Big.T_nat), _n);
        if (_s > (0 : GoInt)) {
            _karatsubaAdd((_z.__slice__(_n2) : stdgo.math.big.Big.T_nat), _p, _n);
        } else {
            _karatsubaSub((_z.__slice__(_n2) : stdgo.math.big.Big.T_nat), _p, _n);
        };
    }
/**
    // alias reports whether x and y share the same base array.
    //
    // Note: alias assumes that the capacity of underlying arrays
    // is never changed for nat values; i.e. that there are
    // no 3-operand slice expressions in this code (or worse,
    // reflect-based operations to the same effect).
**/
private function _alias(_x:T_nat, _y:T_nat):Bool {
        return ((_x.capacity > (0 : GoInt)) && (_y.capacity > (0 : GoInt))) && (Go.pointer((_x.__slice__((0 : GoInt), _x.capacity) : stdgo.math.big.Big.T_nat)[(_x.capacity - (1 : GoInt) : GoInt)]) == Go.pointer((_y.__slice__((0 : GoInt), _y.capacity) : stdgo.math.big.Big.T_nat)[(_y.capacity - (1 : GoInt) : GoInt)]));
    }
/**
    // addAt implements z += x<<(_W*i); z must be long enough.
    // (we don't use nat.add because we need z to stay the same
    // slice, and we don't need to normalize z after each addition)
**/
private function _addAt(_z:T_nat, _x:T_nat, _i:GoInt):Void {
        {
            var _n:GoInt = (_x.length);
            if (_n > (0 : GoInt)) {
                {
                    var _c:stdgo.math.big.Big.Word = _addVV((_z.__slice__(_i, _i + _n) : stdgo.math.big.Big.T_nat), (_z.__slice__(_i) : stdgo.math.big.Big.T_nat), _x);
                    if (_c != ((0u32 : stdgo.math.big.Big.Word))) {
                        var _j:GoInt = _i + _n;
                        if (_j < (_z.length)) {
                            _addVW((_z.__slice__(_j) : stdgo.math.big.Big.T_nat), (_z.__slice__(_j) : stdgo.math.big.Big.T_nat), _c);
                        };
                    };
                };
            };
        };
    }
private function _max(_x:GoInt, _y:GoInt):GoInt {
        if (_x > _y) {
            return _x;
        };
        return _y;
    }
/**
    // karatsubaLen computes an approximation to the maximum k <= n such that
    // k = p<<i for a number p <= threshold and an i >= 0. Thus, the
    // result is the largest number that can be divided repeatedly by 2 before
    // becoming about the value of threshold.
**/
private function _karatsubaLen(_n:GoInt, _threshold:GoInt):GoInt {
        var _i:GoUInt = (0u32 : GoUInt);
        while (_n > _threshold) {
            _n = _n >> ((1i64 : GoUInt64));
            _i++;
        };
        return _n << _i;
    }
/**
    // basicSqr sets z = x*x and is asymptotically faster than basicMul
    // by about a factor of 2, but slower for small arguments due to overhead.
    // Requirements: len(x) > 0, len(z) == 2*len(x)
    // The (non-normalized) result is placed in z.
**/
private function _basicSqr(_z:T_nat, _x:T_nat):Void {
        var _n:GoInt = (_x.length);
        var _tp = _getNat((2 : GoInt) * _n);
        var _t:stdgo.math.big.Big.T_nat = (_tp : stdgo.math.big.Big.T_nat);
        _t._clear();
        {
            var __tmp__ = _mulWW(_x[(0 : GoInt)], _x[(0 : GoInt)]);
            _z[(1 : GoInt)] = __tmp__._0;
            _z[(0 : GoInt)] = __tmp__._1;
        };
        {
            var _i:GoInt = (1 : GoInt);
            Go.cfor(_i < _n, _i++, {
                var _d:stdgo.math.big.Big.Word = _x[(_i : GoInt)];
                {
                    var __tmp__ = _mulWW(_d, _d);
                    _z[(((2 : GoInt) * _i) + (1 : GoInt) : GoInt)] = __tmp__._0;
                    _z[((2 : GoInt) * _i : GoInt)] = __tmp__._1;
                };
                _t[((2 : GoInt) * _i : GoInt)] = _addMulVVW((_t.__slice__(_i, (2 : GoInt) * _i) : stdgo.math.big.Big.T_nat), (_x.__slice__((0 : GoInt), _i) : stdgo.math.big.Big.T_nat), _d);
            });
        };
        _t[(((2 : GoInt) * _n) - (1 : GoInt) : GoInt)] = _shlVU((_t.__slice__((1 : GoInt), ((2 : GoInt) * _n) - (1 : GoInt)) : stdgo.math.big.Big.T_nat), (_t.__slice__((1 : GoInt), ((2 : GoInt) * _n) - (1 : GoInt)) : stdgo.math.big.Big.T_nat), (1u32 : GoUInt));
        _addVV(_z, _z, _t);
        _putNat(_tp);
    }
/**
    // karatsubaSqr squares x and leaves the result in z.
    // len(x) must be a power of 2 and len(z) >= 6*len(x).
    // The (non-normalized) result is placed in z[0 : 2*len(x)].
    //
    // The algorithm and the layout of z are the same as for karatsuba.
**/
private function _karatsubaSqr(_z:T_nat, _x:T_nat):Void {
        var _n:GoInt = (_x.length);
        if ((((_n & (1 : GoInt)) != (0 : GoInt)) || (_n < _karatsubaSqrThreshold)) || (_n < (2 : GoInt))) {
            _basicSqr((_z.__slice__(0, (2 : GoInt) * _n) : stdgo.math.big.Big.T_nat), _x);
            return;
        };
        var _n2:GoInt = _n >> (1i64 : GoUInt64);
        var __0:stdgo.math.big.Big.T_nat = (_x.__slice__(_n2) : stdgo.math.big.Big.T_nat), __1:stdgo.math.big.Big.T_nat = (_x.__slice__((0 : GoInt), _n2) : stdgo.math.big.Big.T_nat), _x0:stdgo.math.big.Big.T_nat = __1, _x1:stdgo.math.big.Big.T_nat = __0;
        _karatsubaSqr(_z, _x0);
        _karatsubaSqr((_z.__slice__(_n) : stdgo.math.big.Big.T_nat), _x1);
        var _xd:stdgo.math.big.Big.T_nat = (_z.__slice__((2 : GoInt) * _n, ((2 : GoInt) * _n) + _n2) : stdgo.math.big.Big.T_nat);
        if (_subVV(_xd, _x1, _x0) != ((0u32 : stdgo.math.big.Big.Word))) {
            _subVV(_xd, _x0, _x1);
        };
        var _p:stdgo.math.big.Big.T_nat = (_z.__slice__(_n * (3 : GoInt)) : stdgo.math.big.Big.T_nat);
        _karatsubaSqr(_p, _xd);
        var _r:stdgo.math.big.Big.T_nat = (_z.__slice__(_n * (4 : GoInt)) : stdgo.math.big.Big.T_nat);
        Go.copySlice(_r, (_z.__slice__(0, _n * (2 : GoInt)) : stdgo.math.big.Big.T_nat));
        _karatsubaAdd((_z.__slice__(_n2) : stdgo.math.big.Big.T_nat), _r, _n);
        _karatsubaAdd((_z.__slice__(_n2) : stdgo.math.big.Big.T_nat), (_r.__slice__(_n) : stdgo.math.big.Big.T_nat), _n);
        _karatsubaSub((_z.__slice__(_n2) : stdgo.math.big.Big.T_nat), _p, _n);
    }
/**
    // getNat returns a *nat of len n. The contents may not be zero.
    // The pool holds *nat to avoid allocation when converting to interface{}.
**/
private function _getNat(_n:GoInt):Ref<T_nat> {
        var _z:Ref<T_nat> = (null : Ref<stdgo.math.big.Big.T_nat>);
        {
            var _v:AnyInterface = _natPool.get();
            if (_v != null) {
                _z = (Go.typeAssert((_v : Ref<T_nat>)) : Ref<T_nat>);
            };
        };
        if (_z == null || (_z : Dynamic).__nil__) {
            _z = (Go.setRef(new stdgo.math.big.Big.T_nat(0, 0)) : Ref<stdgo.math.big.Big.T_nat>);
        };
        _z.__setData__(_z._make(_n));
        if (_n > (0 : GoInt)) {
            ((_z : stdgo.math.big.Big.T_nat))[(0 : GoInt)] = (1043915u32 : stdgo.math.big.Big.Word);
        };
        return _z;
    }
private function _putNat(_x:Ref<T_nat>):Void {
        _natPool.put(Go.toInterface(Go.asInterface(_x)));
    }
private function _same(_x:T_nat, _y:T_nat):Bool {
        return ((_x.length == (_y.length)) && (_x.length > (0 : GoInt))) && (Go.pointer(_x[(0 : GoInt)]) == Go.pointer(_y[(0 : GoInt)]));
    }
/**
    // bigEndianWord returns the contents of buf interpreted as a big-endian encoded Word value.
**/
private function _bigEndianWord(_buf:Slice<GoByte>):Word {
        if (false) {
            return (stdgo.encoding.binary.Binary.bigEndian.uint64(_buf) : Word);
        };
        return (stdgo.encoding.binary.Binary.bigEndian.uint32(_buf) : Word);
    }
function testCmp(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _a in _cmpTests) {
            var _r:GoInt = _a._x._cmp(_a._y);
            if (_r != (_a._r)) {
                _t.errorf(("#%d got r = %v; want %v" : GoString), Go.toInterface(_i), Go.toInterface(_r), Go.toInterface(_a._r));
            };
        };
    }
private function _natFromString(_s:GoString):T_nat {
        var __tmp__ = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._scan(Go.asInterface(stdgo.strings.Strings.newReader(_s)), (0 : GoInt), false), _x:stdgo.math.big.Big.T_nat = __tmp__._0, __0:GoInt = __tmp__._1, __1:GoInt = __tmp__._2, _err:Error = __tmp__._3;
        if (_err != null) {
            throw Go.toInterface(_err);
        };
        return _x;
    }
function testSet(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _a in _sumNN) {
            var _z:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._set(_a._z);
            if (_z._cmp(_a._z) != ((0 : GoInt))) {
                _t.errorf(("got z = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_z)), Go.toInterface(Go.asInterface(_a._z)));
            };
        };
    }
private function _testFunNN(_t:Ref<stdgo.testing.Testing.T>, _msg:GoString, _f:T_funNN, _a:T_argNN):Void {
        var _z:stdgo.math.big.Big.T_nat = _f(null, _a._x, _a._y);
        if (_z._cmp(_a._z) != ((0 : GoInt))) {
            _t.errorf(("%s%+v\n\tgot z = %v; want %v" : GoString), Go.toInterface(_msg), Go.toInterface(_a), Go.toInterface(Go.asInterface(_z)), Go.toInterface(Go.asInterface(_a._z)));
        };
    }
function testFunNN(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _a in _sumNN) {
            var _arg:stdgo.math.big.Big.T_argNN = _a?.__copy__();
            _testFunNN(_t, ("add" : GoString), T_nat_static_extension._add, _arg?.__copy__());
            _arg = (new T_argNN(_a._z, _a._y, _a._x) : T_argNN);
            _testFunNN(_t, ("add symmetric" : GoString), T_nat_static_extension._add, _arg?.__copy__());
            _arg = (new T_argNN(_a._x, _a._z, _a._y) : T_argNN);
            _testFunNN(_t, ("sub" : GoString), T_nat_static_extension._sub, _arg?.__copy__());
            _arg = (new T_argNN(_a._y, _a._z, _a._x) : T_argNN);
            _testFunNN(_t, ("sub symmetric" : GoString), T_nat_static_extension._sub, _arg?.__copy__());
        };
        for (__1 => _a in _prodNN) {
            var _arg:stdgo.math.big.Big.T_argNN = _a?.__copy__();
            _testFunNN(_t, ("mul" : GoString), T_nat_static_extension._mul, _arg?.__copy__());
            _arg = (new T_argNN(_a._z, _a._y, _a._x) : T_argNN);
            _testFunNN(_t, ("mul symmetric" : GoString), T_nat_static_extension._mul, _arg?.__copy__());
        };
    }
function testMulRangeN(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _r in _mulRangesN) {
            var _prod:GoString = ((new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._mulRange(_r._a, _r._b)._utoa((10 : GoInt)) : GoString);
            if (_prod != (_r._prod)) {
                _t.errorf(("#%d: got %s; want %s" : GoString), Go.toInterface(_i), Go.toInterface(_prod), Go.toInterface(_r._prod));
            };
        };
    }
/**
    // allocBytes returns the number of bytes allocated by invoking f.
**/
private function _allocBytes(_f:() -> Void):GoUInt64 {
        var _stats:stdgo.runtime.Runtime.MemStats = ({} : stdgo.runtime.Runtime.MemStats);
        stdgo.runtime.Runtime.readMemStats((Go.setRef(_stats) : Ref<stdgo.runtime.Runtime.MemStats>));
        var _t:GoUInt64 = _stats.totalAlloc;
        _f();
        stdgo.runtime.Runtime.readMemStats((Go.setRef(_stats) : Ref<stdgo.runtime.Runtime.MemStats>));
        return _stats.totalAlloc - _t;
    }
/**
    // TestMulUnbalanced tests that multiplying numbers of different lengths
    // does not cause deep recursion and in turn allocate too much memory.
    // Test case for issue 3807.
**/
function testMulUnbalanced(_t:Ref<stdgo.testing.Testing.T>):Void {
        var __deferstack__:Array<Void -> Void> = [];
        try {
            {
                var _a0 = stdgo.runtime.Runtime.gomaxprocs((1 : GoInt));
                __deferstack__.unshift(() -> stdgo.runtime.Runtime.gomaxprocs(_a0));
            };
            var _x:stdgo.math.big.Big.T_nat = _rndNat((50000 : GoInt));
            var _y:stdgo.math.big.Big.T_nat = _rndNat((40 : GoInt));
            var _allocSize:GoUInt64 = _allocBytes(function():Void {
                (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._mul(_x, _y);
            });
            var _inputSize:GoUInt64 = ((_x.length) + (_y.length) : GoUInt64) * (4i64 : GoUInt64);
            {
                var _ratio:GoUInt64 = _allocSize / (_inputSize : GoUInt64);
                if (_ratio > (10i64 : GoUInt64)) {
                    _t.errorf(("multiplication uses too much memory (%d > %d times the size of inputs)" : GoString), Go.toInterface(_allocSize), Go.toInterface(_ratio));
                };
            };
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return;
        };
    }
/**
    // rndNat returns a random nat value >= 0 of (usually) n words in length.
    // In extremely unlikely cases it may be smaller than n words if the top-
    // most words are 0.
**/
private function _rndNat(_n:GoInt):T_nat {
        return (_rndV(_n) : T_nat)._norm();
    }
/**
    // rndNat1 is like rndNat but the result is guaranteed to be > 0.
**/
private function _rndNat1(_n:GoInt):T_nat {
        var _x:stdgo.math.big.Big.T_nat = (_rndV(_n) : T_nat)._norm();
        if ((_x.length) == ((0 : GoInt))) {
            _x._setWord((1u32 : stdgo.math.big.Big.Word));
        };
        return _x;
    }
function benchmarkMul(_b:Ref<stdgo.testing.Testing.B>):Void {
        var _mulx:stdgo.math.big.Big.T_nat = _rndNat((10000 : GoInt));
        var _muly:stdgo.math.big.Big.T_nat = _rndNat((10000 : GoInt));
        _b.resetTimer();
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                var _z:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
                _z._mul(_mulx, _muly);
            });
        };
    }
private function _benchmarkNatMul(_b:Ref<stdgo.testing.Testing.B>, _nwords:GoInt):Void {
        var _x:stdgo.math.big.Big.T_nat = _rndNat(_nwords);
        var _y:stdgo.math.big.Big.T_nat = _rndNat(_nwords);
        var _z:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
        _b.resetTimer();
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                _z._mul(_x, _y);
            });
        };
    }
function benchmarkNatMul(_b:Ref<stdgo.testing.Testing.B>):Void {
        for (__0 => _n in _mulBenchSizes) {
            if (_isRaceBuilder && (_n > (1000 : GoInt))) {
                continue;
            };
            _b.run(stdgo.fmt.Fmt.sprintf(("%d" : GoString), Go.toInterface(_n)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                _benchmarkNatMul(_b, _n);
            });
        };
    }
function testNLZ(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _x:Word = (-2147483648u32 : stdgo.math.big.Big.Word);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i <= (32 : GoInt), _i++, {
                if ((_nlz(_x) : GoInt) != (_i)) {
                    _t.errorf(("failed at %x: got %d want %d" : GoString), Go.toInterface(_x), Go.toInterface(_nlz(_x)), Go.toInterface(_i));
                };
                _x = _x >> ((1i64 : GoUInt64));
            });
        };
    }
function testShiftLeft(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _test in _leftShiftTests) {
            var _z:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
            _z = _z._shl(_test._in, _test._shift);
            for (_j => _d in _test._out) {
                if ((_j >= _z.length) || (_z[(_j : GoInt)] != _d)) {
                    _t.errorf(("#%d: got: %v want: %v" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface(_z)), Go.toInterface(Go.asInterface(_test._out)));
                    break;
                };
            };
        };
    }
function testShiftRight(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _test in _rightShiftTests) {
            var _z:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
            _z = _z._shr(_test._in, _test._shift);
            for (_j => _d in _test._out) {
                if ((_j >= _z.length) || (_z[(_j : GoInt)] != _d)) {
                    _t.errorf(("#%d: got: %v want: %v" : GoString), Go.toInterface(_i), Go.toInterface(Go.asInterface(_z)), Go.toInterface(Go.asInterface(_test._out)));
                    break;
                };
            };
        };
    }
function benchmarkZeroShifts(_b:Ref<stdgo.testing.Testing.B>):Void {
        var _x:stdgo.math.big.Big.T_nat = _rndNat((800 : GoInt));
        _b.run(("Shl" : GoString), function(_b:Ref<stdgo.testing.Testing.B>):Void {
            {
                var _i:GoInt = (0 : GoInt);
                Go.cfor(_i < _b.n, _i++, {
                    var _z:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
                    _z._shl(_x, (0u32 : GoUInt));
                });
            };
        });
        _b.run(("ShlSame" : GoString), function(_b:Ref<stdgo.testing.Testing.B>):Void {
            {
                var _i:GoInt = (0 : GoInt);
                Go.cfor(_i < _b.n, _i++, {
                    _x._shl(_x, (0u32 : GoUInt));
                });
            };
        });
        _b.run(("Shr" : GoString), function(_b:Ref<stdgo.testing.Testing.B>):Void {
            {
                var _i:GoInt = (0 : GoInt);
                Go.cfor(_i < _b.n, _i++, {
                    var _z:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
                    _z._shr(_x, (0u32 : GoUInt));
                });
            };
        });
        _b.run(("ShrSame" : GoString), function(_b:Ref<stdgo.testing.Testing.B>):Void {
            {
                var _i:GoInt = (0 : GoInt);
                Go.cfor(_i < _b.n, _i++, {
                    _x._shr(_x, (0u32 : GoUInt));
                });
            };
        });
    }
private function _runModWTests(_t:Ref<stdgo.testing.Testing.T>, _tests:Slice<T_modWTest>):Void {
        for (_i => _test in _tests) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._in, (10 : GoInt)), _in:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __0:Bool = __tmp__._1;
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._dividend, (10 : GoInt)), _d:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __1:Bool = __tmp__._1;
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_test._out, (10 : GoInt)), _out:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __2:Bool = __tmp__._1;
            var _r:stdgo.math.big.Big.Word = _in._abs._modW(_d._abs[(0 : GoInt)]);
            if (_r != (_out._abs[((0 : GoInt) : GoInt)])) {
                _t.errorf(("#%d failed: got %d want %s" : GoString), Go.toInterface(_i), Go.toInterface(_r), Go.toInterface(Go.asInterface(_out)));
            };
        };
    }
function testModW(_t:Ref<stdgo.testing.Testing.T>):Void {
        if (true) {
            _runModWTests(_t, _modWTests32);
        };
        if (false) {
            _runModWTests(_t, _modWTests64);
        };
    }
function testMontgomery(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _one = newInt((1i64 : GoInt64));
        var __B = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).lsh(_one, (32u32 : GoUInt));
        for (_i => _test in _montgomeryTests) {
            var _x:stdgo.math.big.Big.T_nat = _natFromString(_test._x);
            var _y:stdgo.math.big.Big.T_nat = _natFromString(_test._y);
            var _m:stdgo.math.big.Big.T_nat = _natFromString(_test._m);
            while ((_x.length) < (_m.length)) {
                _x = _x.__appendref__((0u32 : stdgo.math.big.Big.Word));
            };
            while ((_y.length) < (_m.length)) {
                _y = _y.__appendref__((0u32 : stdgo.math.big.Big.Word));
            };
            if (_x._cmp(_m) > (0 : GoInt)) {
                var __tmp__ = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._div(null, _x, _m), __0:stdgo.math.big.Big.T_nat = __tmp__._0, _r:stdgo.math.big.Big.T_nat = __tmp__._1;
                _t.errorf(("#%d: x > m (0x%s > 0x%s; use 0x%s)" : GoString), Go.toInterface(_i), Go.toInterface(_x._utoa((16 : GoInt))), Go.toInterface(_m._utoa((16 : GoInt))), Go.toInterface(_r._utoa((16 : GoInt))));
            };
            if (_y._cmp(_m) > (0 : GoInt)) {
                var __tmp__ = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._div(null, _x, _m), __1:stdgo.math.big.Big.T_nat = __tmp__._0, _r:stdgo.math.big.Big.T_nat = __tmp__._1;
                _t.errorf(("#%d: y > m (0x%s > 0x%s; use 0x%s)" : GoString), Go.toInterface(_i), Go.toInterface(_y._utoa((16 : GoInt))), Go.toInterface(_m._utoa((16 : GoInt))), Go.toInterface(_r._utoa((16 : GoInt))));
            };
            var _out:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
            if (true) {
                _out = _natFromString(_test._out32);
            } else {
                _out = _natFromString(_test._out64);
            };
            var _xi = (Go.setRef(({ _abs : _x } : Int_)) : Ref<stdgo.math.big.Big.Int_>);
            var _yi = (Go.setRef(({ _abs : _y } : Int_)) : Ref<stdgo.math.big.Big.Int_>);
            var _mi = (Go.setRef(({ _abs : _m } : Int_)) : Ref<stdgo.math.big.Big.Int_>);
            var _p = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).mod((Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).mul(_xi, (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).mul(_yi, (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).modInverse((Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).lsh(_one, (_m.length : GoUInt) * (32u32 : GoUInt)), _mi))), _mi);
            if (_out._cmp(_p._abs._norm()) != ((0 : GoInt))) {
                _t.errorf(("#%d: out in table=0x%s, computed=0x%s" : GoString), Go.toInterface(_i), Go.toInterface(_out._utoa((16 : GoInt))), Go.toInterface(_p._abs._norm()._utoa((16 : GoInt))));
            };
            var _k = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).mod((Go.setRef(({ _abs : _m } : Int_)) : Ref<stdgo.math.big.Big.Int_>), __B);
            _k = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).sub(__B, _k);
            _k = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).mod(_k, __B);
            var _k0:stdgo.math.big.Big.Word = ((Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).modInverse(_k, __B).uint64() : Word);
            if (_k0 != ((_test._k0 : Word))) {
                _t.errorf(("#%d: k0 in table=%#x, computed=%#x\n" : GoString), Go.toInterface(_i), Go.toInterface(_test._k0), Go.toInterface(_k0));
            };
            var _z:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._montgomery(_x, _y, _m, _k0, (_m.length));
            _z = _z._norm();
            if (_z._cmp(_out) != ((0 : GoInt))) {
                _t.errorf(("#%d: got 0x%s want 0x%s" : GoString), Go.toInterface(_i), Go.toInterface(_z._utoa((16 : GoInt))), Go.toInterface(_out._utoa((16 : GoInt))));
            };
        };
    }
function testExpNN(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _test in _expNNTests) {
            var _x:stdgo.math.big.Big.T_nat = _natFromString(_test._x);
            var _y:stdgo.math.big.Big.T_nat = _natFromString(_test._y);
            var _out:stdgo.math.big.Big.T_nat = _natFromString(_test._out);
            var _m:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
            if ((_test._m.length) > (0 : GoInt)) {
                _m = _natFromString(_test._m);
            };
            var _z:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._expNN(_x, _y, _m, false);
            if (_z._cmp(_out) != ((0 : GoInt))) {
                _t.errorf(("#%d got %s want %s" : GoString), Go.toInterface(_i), Go.toInterface(_z._utoa((10 : GoInt))), Go.toInterface(_out._utoa((10 : GoInt))));
            };
        };
    }
function fuzzExpMont(_f:Ref<stdgo.testing.Testing.F>):Void {
        _f.fuzz(Go.toInterface(function(_t:Ref<stdgo.testing.Testing.T>, _x1:GoUInt, _x2:GoUInt, _x3:GoUInt, _y1:GoUInt, _y2:GoUInt, _y3:GoUInt, _m1:GoUInt, _m2:GoUInt, _m3:GoUInt):Void {
            if (((_m1 == (0u32 : GoUInt)) && (_m2 == (0u32 : GoUInt))) && (_m3 == (0u32 : GoUInt))) {
                return;
            };
            var _x = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setBits((new Slice<stdgo.math.big.Big.Word>(0, 0, (_x1 : Word), (_x2 : Word), (_x3 : Word)) : Slice<stdgo.math.big.Big.Word>));
            var _y = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setBits((new Slice<stdgo.math.big.Big.Word>(0, 0, (_y1 : Word), (_y2 : Word), (_y3 : Word)) : Slice<stdgo.math.big.Big.Word>));
            var _m = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setBits((new Slice<stdgo.math.big.Big.Word>(0, 0, (_m1 : Word), (_m2 : Word), (_m3 : Word)) : Slice<stdgo.math.big.Big.Word>));
            var _out = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).exp(_x, _y, _m);
            var _want = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>)._expSlow(_x, _y, _m);
            if (_out.cmp(_want) != ((0 : GoInt))) {
                _t.errorf(("x = %#x\ny=%#x\nz=%#x\nout=%#x\nwant=%#x\ndc: 16o 16i %X %X %X |p" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_m)), Go.toInterface(Go.asInterface(_out)), Go.toInterface(Go.asInterface(_want)), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_y)), Go.toInterface(Go.asInterface(_m)));
            };
        }));
    }
function benchmarkExp3Power(_b:Ref<stdgo.testing.Testing.B>):Void {
        {};
        for (__0 => _y in (new Slice<stdgo.math.big.Big.Word>(
0,
0,
(16u32 : stdgo.math.big.Big.Word),
(64u32 : stdgo.math.big.Big.Word),
(256u32 : stdgo.math.big.Big.Word),
(1024u32 : stdgo.math.big.Big.Word),
(4096u32 : stdgo.math.big.Big.Word),
(16384u32 : stdgo.math.big.Big.Word),
(65536u32 : stdgo.math.big.Big.Word),
(262144u32 : stdgo.math.big.Big.Word),
(1048576u32 : stdgo.math.big.Big.Word),
(4194304u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>)) {
            _b.run(stdgo.fmt.Fmt.sprintf(("%#x" : GoString), Go.toInterface(_y)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                var _z:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
                {
                    var _i:GoInt = (0 : GoInt);
                    Go.cfor(_i < _b.n, _i++, {
                        _z._expWW((3u32 : stdgo.math.big.Big.Word), _y);
                    });
                };
            });
        };
    }
private function _fibo(_n:GoInt):T_nat {
        {
            final __value__ = _n;
            if (__value__ == ((0 : GoInt))) {
                return null;
            } else if (__value__ == ((1 : GoInt))) {
                return (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat);
            };
        };
        var _f0:stdgo.math.big.Big.T_nat = _fibo((0 : GoInt));
        var _f1:stdgo.math.big.Big.T_nat = _fibo((1 : GoInt));
        var _f2:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
        {
            var _i:GoInt = (1 : GoInt);
            Go.cfor(_i < _n, _i++, {
                _f2 = _f2._add(_f0, _f1);
                {
                    final __tmp__0 = _f1;
                    final __tmp__1 = _f2;
                    final __tmp__2 = _f0;
                    _f0 = __tmp__0;
                    _f1 = __tmp__1;
                    _f2 = __tmp__2;
                };
            });
        };
        return _f1;
    }
function testFibo(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _want in _fiboNums) {
            var _n:GoInt = _i * (10 : GoInt);
            var _got:GoString = (_fibo(_n)._utoa((10 : GoInt)) : GoString);
            if (_got != (_want)) {
                _t.errorf(("fibo(%d) failed: got %s want %s" : GoString), Go.toInterface(_n), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function benchmarkFibo(_b:Ref<stdgo.testing.Testing.B>):Void {
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                _fibo((1 : GoInt));
                _fibo((10 : GoInt));
                _fibo((100 : GoInt));
                _fibo((1000 : GoInt));
                _fibo((10000 : GoInt));
                _fibo((100000 : GoInt));
            });
        };
    }
function testBit(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _test in _bitTests) {
            var _x:stdgo.math.big.Big.T_nat = _natFromString(_test._x);
            {
                var _got:GoUInt = _x._bit(_test._i);
                if (_got != (_test._want)) {
                    _t.errorf(("#%d: %s.bit(%d) = %v; want %v" : GoString), Go.toInterface(_i), Go.toInterface(_test._x), Go.toInterface(_test._i), Go.toInterface(_got), Go.toInterface(_test._want));
                };
            };
        };
    }
function testSticky(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _test in _stickyTests) {
            var _x:stdgo.math.big.Big.T_nat = _natFromString(_test._x);
            {
                var _got:GoUInt = _x._sticky(_test._i);
                if (_got != (_test._want)) {
                    _t.errorf(("#%d: %s.sticky(%d) = %v; want %v" : GoString), Go.toInterface(_i), Go.toInterface(_test._x), Go.toInterface(_test._i), Go.toInterface(_got), Go.toInterface(_test._want));
                };
            };
            if (_test._want == ((1u32 : GoUInt))) {
                {
                    var _d:GoUInt = (1u32 : GoUInt);
                    Go.cfor(_d <= (3u32 : GoUInt), _d++, {
                        {
                            var _got:GoUInt = _x._sticky(_test._i + _d);
                            if (_got != ((1u32 : GoUInt))) {
                                _t.errorf(("#%d: %s.sticky(%d) = %v; want %v" : GoString), Go.toInterface(_i), Go.toInterface(_test._x), Go.toInterface(_test._i + _d), Go.toInterface(_got), Go.toInterface((1 : GoInt)));
                            };
                        };
                    });
                };
            };
        };
    }
private function _testSqr(_t:Ref<stdgo.testing.Testing.T>, _x:T_nat):Void {
        var _got:stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat(((2 : GoInt) * (_x.length) : GoInt).toBasic(), 0, ...[for (i in 0 ... ((2 : GoInt) * (_x.length) : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
        var _want:stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat(((2 : GoInt) * (_x.length) : GoInt).toBasic(), 0, ...[for (i in 0 ... ((2 : GoInt) * (_x.length) : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
        _got = _got._sqr(_x);
        _want = _want._mul(_x, _x);
        if (_got._cmp(_want) != ((0 : GoInt))) {
            _t.errorf(("basicSqr(%v), got %v, want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_got)), Go.toInterface(Go.asInterface(_want)));
        };
    }
function testSqr(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _a in _prodNN) {
            if (_a._x != null) {
                _testSqr(_t, _a._x);
            };
            if (_a._y != null) {
                _testSqr(_t, _a._y);
            };
            if (_a._z != null) {
                _testSqr(_t, _a._z);
            };
        };
    }
private function _benchmarkNatSqr(_b:Ref<stdgo.testing.Testing.B>, _nwords:GoInt):Void {
        var _x:stdgo.math.big.Big.T_nat = _rndNat(_nwords);
        var _z:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
        _b.resetTimer();
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                _z._sqr(_x);
            });
        };
    }
function benchmarkNatSqr(_b:Ref<stdgo.testing.Testing.B>):Void {
        for (__0 => _n in _sqrBenchSizes) {
            if (_isRaceBuilder && (_n > (1000 : GoInt))) {
                continue;
            };
            _b.run(stdgo.fmt.Fmt.sprintf(("%d" : GoString), Go.toInterface(_n)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                _benchmarkNatSqr(_b, _n);
            });
        };
    }
function testNatSubMod2N(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _mode in (new Slice<GoString>(0, 0, ("noalias" : GoString), ("aliasX" : GoString), ("aliasY" : GoString)) : Slice<GoString>)) {
            _t.run(_mode, function(_t:Ref<stdgo.testing.Testing.T>):Void {
                for (__0 => _tt in _subMod2NTests) {
                    var _x0:stdgo.math.big.Big.T_nat = _natFromString(_tt._x);
                    var _y0:stdgo.math.big.Big.T_nat = _natFromString(_tt._y);
                    var _want:stdgo.math.big.Big.T_nat = _natFromString(_tt._z);
                    var _x:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._set(_x0);
                    var _y:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._set(_y0);
                    var _z:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
                    {
                        final __value__ = _mode;
                        if (__value__ == (("aliasX" : GoString))) {
                            _z = _x;
                        } else if (__value__ == (("aliasY" : GoString))) {
                            _z = _y;
                        };
                    };
                    _z = _z._subMod2N(_x, _y, _tt._n);
                    if (_z._cmp(_want) != ((0 : GoInt))) {
                        _t.fatalf(("subMod2N(%d, %d, %d) = %d, want %d" : GoString), Go.toInterface(Go.asInterface(_x0)), Go.toInterface(Go.asInterface(_y0)), Go.toInterface(_tt._n), Go.toInterface(Go.asInterface(_z)), Go.toInterface(Go.asInterface(_want)));
                    };
                    if ((_mode != ("aliasX" : GoString)) && (_x._cmp(_x0) != (0 : GoInt))) {
                        _t.fatalf(("subMod2N(%d, %d, %d) modified x" : GoString), Go.toInterface(Go.asInterface(_x0)), Go.toInterface(Go.asInterface(_y0)), Go.toInterface(_tt._n));
                    };
                    if ((_mode != ("aliasY" : GoString)) && (_y._cmp(_y0) != (0 : GoInt))) {
                        _t.fatalf(("subMod2N(%d, %d, %d) modified y" : GoString), Go.toInterface(Go.asInterface(_x0)), Go.toInterface(Go.asInterface(_y0)), Go.toInterface(_tt._n));
                    };
                };
            });
        };
    }
function benchmarkNatSetBytes(_b:Ref<stdgo.testing.Testing.B>):Void {
        {};
        var _lengths = (new Slice<GoInt>(0, 0, (8 : GoInt), (24 : GoInt), (128 : GoInt), (7 : GoInt), (23 : GoInt), (127 : GoInt)) : Slice<GoInt>);
        var _n:stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat((4 : GoInt).toBasic(), 0, ...[for (i in 0 ... (4 : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
        var _buf = new Slice<GoUInt8>((128 : GoInt).toBasic(), 0, ...[for (i in 0 ... (128 : GoInt).toBasic()) (0 : GoUInt8)]);
        for (__0 => _l in _lengths) {
            _b.run(stdgo.fmt.Fmt.sprint(Go.toInterface(_l)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                {
                    var _i:GoInt = (0 : GoInt);
                    Go.cfor(_i < _b.n, _i++, {
                        _n._setBytes((_buf.__slice__(0, _l) : Slice<GoUInt8>));
                    });
                };
            });
        };
    }
function testNatDiv(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _sizes = (new Slice<GoInt>(
0,
0,
(1 : GoInt),
(2 : GoInt),
(5 : GoInt),
(8 : GoInt),
(15 : GoInt),
(25 : GoInt),
(40 : GoInt),
(65 : GoInt),
(100 : GoInt),
(200 : GoInt),
(500 : GoInt),
(800 : GoInt),
(1500 : GoInt),
(2500 : GoInt),
(4000 : GoInt),
(6500 : GoInt),
(10000 : GoInt)) : Slice<GoInt>);
        for (__0 => _i in _sizes) {
            for (__1 => _j in _sizes) {
                var _a:stdgo.math.big.Big.T_nat = _rndNat1(_i);
                var _b:stdgo.math.big.Big.T_nat = _rndNat1(_j);
                if ((_b.length == (1 : GoInt)) && (_b[(0 : GoInt)] == (1u32 : stdgo.math.big.Big.Word))) {
                    _b[(0 : GoInt)] = (2u32 : stdgo.math.big.Big.Word);
                };
                var _c:stdgo.math.big.Big.T_nat = _rndNat1((_b.length));
                if ((_c.length == (_b.length)) && (_c[((_c.length) - (1 : GoInt) : GoInt)] >= _b[((_b.length) - (1 : GoInt) : GoInt)])) {
                    _c[((_c.length) - (1 : GoInt) : GoInt)] = (0u32 : stdgo.math.big.Big.Word);
                    _c = _c._norm();
                };
                var _x:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._mul(_a, _b);
                _x = _x._add(_x, _c);
                var __0:T_nat = new stdgo.math.big.Big.T_nat(0, 0), __1:T_nat = new stdgo.math.big.Big.T_nat(0, 0), _r:T_nat = __1, _q:T_nat = __0;
                {
                    var __tmp__ = _q._div(_r, _x, _b);
                    _q = __tmp__._0;
                    _r = __tmp__._1;
                };
                if (_q._cmp(_a) != ((0 : GoInt))) {
                    _t.fatalf(("wrong quotient: got %s; want %s for %s/%s" : GoString), Go.toInterface(_q._utoa((10 : GoInt))), Go.toInterface(_a._utoa((10 : GoInt))), Go.toInterface(_x._utoa((10 : GoInt))), Go.toInterface(_b._utoa((10 : GoInt))));
                };
                if (_r._cmp(_c) != ((0 : GoInt))) {
                    _t.fatalf(("wrong remainder: got %s; want %s for %s/%s" : GoString), Go.toInterface(_r._utoa((10 : GoInt))), Go.toInterface(_c._utoa((10 : GoInt))), Go.toInterface(_x._utoa((10 : GoInt))), Go.toInterface(_b._utoa((10 : GoInt))));
                };
            };
        };
    }
/**
    // TestIssue37499 triggers the edge case of divBasic where
    // the inaccurate estimate of the first word's quotient
    // happens at the very beginning of the loop.
**/
function testIssue37499(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _u:stdgo.math.big.Big.T_nat = _natFromString(("0x2b6c385a05be027f5c22005b63c42a1165b79ff510e1706b39f8489c1d28e57bb5ba4ef9fd9387a3e344402c0a453381" : GoString));
        var _v:stdgo.math.big.Big.T_nat = _natFromString(("0x2b6c385a05be027f5c22005b63c42a1165b79ff510e1706c" : GoString));
        var _q:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._make((8 : GoInt));
        _q._divBasic(_u, _v);
        _q = _q._norm();
        {
            var _s:GoString = (_q._utoa((16 : GoInt)) : GoString);
            if (_s != (("fffffffffffffffffffffffffffffffffffffffffffffffb" : GoString))) {
                _t.fatalf(("incorrect quotient: %s" : GoString), Go.toInterface(_s));
            };
        };
    }
/**
    // TestIssue42552 triggers an edge case of recursive division
    // where the first division loop is never entered, and correcting
    // the remainder takes exactly two iterations in the final loop.
**/
function testIssue42552(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _u:stdgo.math.big.Big.T_nat = _natFromString(("0xc23b166884c3869092a520eceedeced2b00847bd256c9cf3b2c5e2227c15bd5e6ee7ef8a2f49236ad0eedf2c8a3b453cf6e0706f64285c526b372c4b1321245519d430540804a50b7ca8b6f1b34a2ec05cdbc24de7599af112d3e3c8db347e8799fe70f16e43c6566ba3aeb169463a3ecc486172deb2d9b80a3699c776e44fef20036bd946f1b4d054dd88a2c1aeb986199b0b2b7e58c42288824b74934d112fe1fc06e06b4d99fe1c5e725946b23210521e209cd507cce90b5f39a523f27e861f9e232aee50c3f585208b4573dcc0b897b6177f2ba20254fd5c50a033e849dee1b3a93bd2dc44ba8ca836cab2c2ae50e50b126284524fa0187af28628ff0face68d87709200329db1392852c8b8963fbe3d05fb1efe19f0ed5ca9fadc2f96f82187c24bb2512b2e85a66333a7e176605695211e1c8e0b9b9e82813e50654964945b1e1e66a90840396c7d10e23e47f364d2d3f660fa54598e18d1ca2ea4fe4f35a40a11f69f201c80b48eaee3e2e9b0eda63decf92bec08a70f731587d4ed0f218d5929285c8b2ccbc497e20db42de73885191fa453350335990184d8df805072f958d5354debda38f5421effaaafd6cb9b721ace74be0892d77679f62a4a126697cd35797f6858193da4ba1770c06aea2e5c59ec04b8ea26749e61b72ecdde403f3bc7e5e546cd799578cc939fa676dfd5e648576d4a06cbadb028adc2c0b461f145b2321f42e5e0f3b4fb898ecd461df07a6f5154067787bf74b5cc5c03704a1ce47494961931f0263b0aac32505102595957531a2de69dd71aac51f8a49902f81f21283dbe8e21e01e5d82517868826f86acf338d935aa6b4d5a25c8d540389b277dd9d64569d68baf0f71bd03dba45b92a7fc052601d1bd011a2fc6790a23f97c6fa5caeea040ab86841f268d39ce4f7caf01069df78bba098e04366492f0c2ac24f1bf16828752765fa523c9a4d42b71109d123e6be8c7b1ab3ccf8ea03404075fe1a9596f1bba1d267f9a7879ceece514818316c9c0583469d2367831fc42b517ea028a28df7c18d783d16ea2436cee2b15d52db68b5dfdee6b4d26f0905f9b030c911a04d078923a4136afea96eed6874462a482917353264cc9bee298f167ac65a6db4e4eda88044b39cc0b33183843eaa946564a00c3a0ab661f2c915e70bf0bb65bfbb6fa2eea20aed16bf2c1a1d00ec55fb4ff2f76b8e462ea70c19efa579c9ee78194b86708fdae66a9ce6e2cf3d366037798cfb50277ba6d2fd4866361022fd788ab7735b40b8b61d55e32243e06719e53992e9ac16c9c4b6e6933635c3c47c8f7e73e17dd54d0dd8aeba5d76de46894e7b3f9d3ec25ad78ee82297ba69905ea0fa094b8667faa2b8885e2187b3da80268aa1164761d7b0d6de206b676777348152b8ae1d4afed753bc63c739a5ca8ce7afb2b241a226bd9e502baba391b5b13f5054f070b65a9cf3a67063bfaa803ba390732cd03888f664023f888741d04d564e0b5674b0a183ace81452001b3fbb4214c77d42ca75376742c471e58f67307726d56a1032bd236610cbcbcd03d0d7a452900136897dc55bb3ce959d10d4e6a10fb635006bd8c41cd9ded2d3dfdd8f2e229590324a7370cb2124210b2330f4c56155caa09a2564932ceded8d92c79664dcdeb87faad7d3da006cc2ea267ee3df41e9677789cc5a8cc3b83add6491561b3047919e0648b1b2e97d7ad6f6c2aa80cab8e9ae10e1f75b1fdd0246151af709d259a6a0ed0b26bd711024965ecad7c41387de45443defce53f66612948694a6032279131c257119ed876a8e805dfb49576ef5c563574115ee87050d92d191bc761ef51d966918e2ef925639400069e3959d8fe19f36136e947ff430bf74e71da0aa5923b00000000" : GoString));
        var _v:stdgo.math.big.Big.T_nat = _natFromString(("0x838332321d443a3d30373d47301d47073847473a383d3030f25b3d3d3e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002e00000000000000000041603038331c3d32f5303441e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e01c0a5459bfc7b9be9fcbb9d2383840464319434707303030f43a32f53034411c0a5459413820878787878787878787878787878787878787878787878787878787878787878787870630303a3a30334036605b923a6101f83638413943413960204337602043323801526040523241846038414143015238604060328452413841413638523c0240384141364036605b923a6101f83638413943413960204334602043323801526040523241846038414143015238604060328452413841413638523c02403841413638433030f25a8b83838383838383838383838383838383837d838383ffffffffffffffff838383838383838383000000000000000000030000007d26e27c7c8b83838383838383838383838383838383837d838383ffffffffffffffff83838383838383838383838383838383838383838383435960f535073030f3343200000000000000011881301938343030fa398383300000002300000000000000000000f11af4600c845252904141364138383c60406032414443095238010241414303364443434132305b595a15434160b042385341ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff47476043410536613603593a6005411c437405fcfcfcfcfcfcfc0000000000005a3b075815054359000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" : GoString));
        var _q:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._make((16 : GoInt));
        _q._div(_q, _u, _v);
    }
/**
    // maxPow returns (b**n, n) such that b**n is the largest power b**n <= _M.
    // For instance maxPow(10) == (1e19, 19) for 19 decimal digits in a 64bit Word.
    // In other words, at most n digits in base b fit into a Word.
    // TODO(gri) replace this with a table, generated at build time.
**/
private function _maxPow(_b:Word):{ var _0 : Word; var _1 : GoInt; } {
        var _p:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word), _n:GoInt = (0 : GoInt);
        {
            final __tmp__0 = _b;
            final __tmp__1 = (1 : GoInt);
            _p = __tmp__0;
            _n = __tmp__1;
        };
        {
            var _max:stdgo.math.big.Big.Word = (-1u32 : stdgo.math.big.Big.Word) / _b;
            while (_p <= _max) {
                _p = _p * (_b);
                _n++;
            };
        };
        return { _0 : _p, _1 : _n };
    }
/**
    // pow returns x**n for n > 0, and 1 otherwise.
**/
private function _pow(_x:Word, _n:GoInt):Word {
        var _p:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        _p = (1u32 : stdgo.math.big.Big.Word);
        while (_n > (0 : GoInt)) {
            if (_n & (1 : GoInt) != ((0 : GoInt))) {
                _p = _p * (_x);
            };
            _x = _x * (_x);
            _n = _n >> ((1i64 : GoUInt64));
        };
        return _p;
    }
/**
    // construct table of powers of bb*leafSize to use in subdivisions.
**/
private function _divisors(_m:GoInt, _b:Word, _ndigits:GoInt, _bb:Word):Slice<T_divisor> {
        if ((_leafSize == (0 : GoInt)) || (_m <= _leafSize)) {
            return (null : Slice<stdgo.math.big.Big.T_divisor>);
        };
        var _k:GoInt = (1 : GoInt);
        {
            var _words:GoInt = _leafSize;
            Go.cfor((_words < (_m >> (1i64 : GoUInt64))) && (_k < _cacheBase10._table.length), _words = _words << ((1i64 : GoUInt64)), {
                _k++;
            });
        };
        var _table:Slice<T_divisor> = (null : Slice<stdgo.math.big.Big.T_divisor>);
        if (_b == ((10u32 : stdgo.math.big.Big.Word))) {
            _cacheBase10.lock();
            _table = (_cacheBase10._table.__slice__((0 : GoInt), _k) : Slice<stdgo.math.big.Big.T_divisor>);
        } else {
            _table = new Slice<stdgo.math.big.Big.T_divisor>((_k : GoInt).toBasic(), 0, ...[for (i in 0 ... (_k : GoInt).toBasic()) ({} : stdgo.math.big.Big.T_divisor)]);
        };
        if (_table[(_k - (1 : GoInt) : GoInt)]._ndigits == ((0 : GoInt))) {
            var _larger:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
            {
                var _i:GoInt = (0 : GoInt);
                Go.cfor(_i < _k, _i++, {
                    if (_table[(_i : GoInt)]._ndigits == ((0 : GoInt))) {
                        if (_i == ((0 : GoInt))) {
                            _table[(0 : GoInt)]._bbb = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._expWW(_bb, (_leafSize : Word));
                            _table[(0 : GoInt)]._ndigits = _ndigits * _leafSize;
                        } else {
                            _table[(_i : GoInt)]._bbb = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._sqr(_table[(_i - (1 : GoInt) : GoInt)]._bbb);
                            _table[(_i : GoInt)]._ndigits = (2 : GoInt) * _table[(_i - (1 : GoInt) : GoInt)]._ndigits;
                        };
                        _larger = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._set(_table[(_i : GoInt)]._bbb);
                        while (_mulAddVWW(_larger, _larger, _b, (0u32 : stdgo.math.big.Big.Word)) == ((0u32 : stdgo.math.big.Big.Word))) {
                            _table[(_i : GoInt)]._bbb = _table[(_i : GoInt)]._bbb._set(_larger);
                            _table[(_i : GoInt)]._ndigits++;
                        };
                        _table[(_i : GoInt)]._nbits = _table[(_i : GoInt)]._bbb._bitLen();
                    };
                });
            };
        };
        if (_b == ((10u32 : stdgo.math.big.Big.Word))) {
            _cacheBase10.unlock();
        };
        return _table;
    }
function testMaxBase(_t:Ref<stdgo.testing.Testing.T>):Void {
        if (false) {
            _t.fatalf(("%d != %d" : GoString), Go.toInterface((62 : GoInt32)), Go.toInterface((("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString).length)));
        };
    }
/**
    // log2 computes the integer binary logarithm of x.
    // The result is the integer n for which 2^n <= x < 2^(n+1).
    // If x == 0, the result is -1.
**/
private function _log2(_x:Word):GoInt {
        return stdgo.math.bits.Bits.len((_x : GoUInt)) - (1 : GoInt);
    }
private function _itoa(_x:T_nat, _base:GoInt):Slice<GoByte> {
        if (_base < (2 : GoInt)) {
            throw Go.toInterface(("illegal base" : GoString));
        } else if ((_x.length) == ((0 : GoInt))) {
            return (("0" : GoString) : Slice<GoByte>);
        };
        var _i:GoInt = (_x._bitLen() / _log2((_base : Word))) + (1 : GoInt);
        var _s = new Slice<GoUInt8>((_i : GoInt).toBasic(), 0, ...[for (i in 0 ... (_i : GoInt).toBasic()) (0 : GoUInt8)]);
        var _q:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._set(_x);
        while ((_q.length) > (0 : GoInt)) {
            _i--;
            var _r:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
            {
                var __tmp__ = _q._divW(_q, (_base : Word));
                _q = __tmp__._0;
                _r = __tmp__._1;
            };
            _s[(_i : GoInt)] = ("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString)[(_r : GoInt)];
        };
        return (_s.__slice__(_i) : Slice<GoUInt8>);
    }
function testString(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _panicStr:GoString = ("" : GoString);
        {
            var a = function():Void {
                var __deferstack__:Array<Void -> Void> = [];
                try {
                    __deferstack__.unshift(() -> {
                        var a = function():Void {
                            _panicStr = (Go.typeAssert(({
                                final r = Go.recover_exception;
                                Go.recover_exception = null;
                                r;
                            } : GoString)) : GoString);
                        };
                        a();
                    });
                    _natOne._utoa((1 : GoInt));
                    for (defer in __deferstack__) {
                        defer();
                    };
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        if (Go.recover_exception != null) throw Go.recover_exception;
                        return;
                    };
                } catch(__exception__) {
                    var exe:Dynamic = __exception__.native;
                    if ((exe is haxe.ValueException)) exe = exe.value;
                    if (!(exe is AnyInterfaceData)) {
                        exe = Go.toInterface(__exception__.message);
                    };
                    Go.recover_exception = exe;
                    for (defer in __deferstack__) {
                        defer();
                    };
                    if (Go.recover_exception != null) throw Go.recover_exception;
                    return;
                };
            };
            a();
        };
        if (_panicStr != (("invalid base" : GoString))) {
            _t.errorf(("expected panic for invalid base" : GoString));
        };
        for (__0 => _a in _strTests) {
            var _s:GoString = (_a._x._utoa(_a._b) : GoString);
            if (_s != (_a._s)) {
                _t.errorf(("string%+v\n\tgot s = %s; want %s" : GoString), Go.toInterface(Go.asInterface(_a)), Go.toInterface(_s), Go.toInterface(_a._s));
            };
            var __tmp__ = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._scan(Go.asInterface(stdgo.strings.Strings.newReader(_a._s)), _a._b, false), _x:stdgo.math.big.Big.T_nat = __tmp__._0, _b:GoInt = __tmp__._1, __1:GoInt = __tmp__._2, _err:Error = __tmp__._3;
            if (_x._cmp(_a._x) != ((0 : GoInt))) {
                _t.errorf(("scan%+v\n\tgot z = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_a)), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_a._x)));
            };
            if (_b != (_a._b)) {
                _t.errorf(("scan%+v\n\tgot b = %d; want %d" : GoString), Go.toInterface(Go.asInterface(_a)), Go.toInterface(_b), Go.toInterface(_a._b));
            };
            if (_err != null) {
                _t.errorf(("scan%+v\n\tgot error = %s" : GoString), Go.toInterface(Go.asInterface(_a)), Go.toInterface(_err));
            };
        };
    }
function testScanBase(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _a in _natScanTests) {
            var _r = stdgo.strings.Strings.newReader(_a._s);
            var __tmp__ = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._scan(Go.asInterface(_r), _a._base, _a._frac), _x:stdgo.math.big.Big.T_nat = __tmp__._0, _b:GoInt = __tmp__._1, _count:GoInt = __tmp__._2, _err:Error = __tmp__._3;
            if (Go.toInterface(_err) != (Go.toInterface(_a._err))) {
                _t.errorf(("scan%+v\n\tgot error = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_a)), Go.toInterface(_err), Go.toInterface(_a._err));
            };
            if (_x._cmp(_a._x) != ((0 : GoInt))) {
                _t.errorf(("scan%+v\n\tgot z = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_a)), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_a._x)));
            };
            if (_b != (_a._b)) {
                _t.errorf(("scan%+v\n\tgot b = %d; want %d" : GoString), Go.toInterface(Go.asInterface(_a)), Go.toInterface(_b), Go.toInterface(_a._base));
            };
            if (_count != (_a._count)) {
                _t.errorf(("scan%+v\n\tgot count = %d; want %d" : GoString), Go.toInterface(Go.asInterface(_a)), Go.toInterface(_count), Go.toInterface(_a._count));
            };
            var __tmp__ = _r.readRune(), _next:GoInt32 = __tmp__._0, __1:GoInt = __tmp__._1, _err:Error = __tmp__._2;
            if (Go.toInterface(_err) == (Go.toInterface(stdgo.io.Io.eof))) {
                _next = (0 : GoInt32);
                _err = (null : Error);
            };
            if ((_err == null) && (_next != _a._next)) {
                _t.errorf(("scan%+v\n\tgot next = %q; want %q" : GoString), Go.toInterface(Go.asInterface(_a)), Go.toInterface(_next), Go.toInterface(_a._next));
            };
        };
    }
/**
    // Test case for BenchmarkScanPi.
**/
function testScanPi(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _x:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
        var __tmp__ = _x._scan(Go.asInterface(stdgo.strings.Strings.newReader(_pi)), (10 : GoInt), false), _z:stdgo.math.big.Big.T_nat = __tmp__._0, __0:GoInt = __tmp__._1, __1:GoInt = __tmp__._2, _err:Error = __tmp__._3;
        if (_err != null) {
            _t.errorf(("scanning pi: %s" : GoString), Go.toInterface(_err));
        };
        {
            var _s:GoString = (_z._utoa((10 : GoInt)) : GoString);
            if (_s != (_pi)) {
                _t.errorf(("scanning pi: got %s" : GoString), Go.toInterface(_s));
            };
        };
    }
function testScanPiParallel(_t:Ref<stdgo.testing.Testing.T>):Void {
        {};
        var _c = new Chan<GoInt>(0, () -> (0 : GoInt));
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < (2 : GoInt), _i++, {
                Go.routine(() -> {
                    var a = function():Void {
                        testScanPi(_t);
                        _c.__send__((0 : GoInt));
                    };
                    a();
                });
            });
        };
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < (2 : GoInt), _i++, {
                _c.__get__();
            });
        };
    }
function benchmarkScanPi(_b:Ref<stdgo.testing.Testing.B>):Void {
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                var _x:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
                _x._scan(Go.asInterface(stdgo.strings.Strings.newReader(_pi)), (10 : GoInt), false);
            });
        };
    }
function benchmarkStringPiParallel(_b:Ref<stdgo.testing.Testing.B>):Void {
        var _x:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
        {
            var __tmp__ = _x._scan(Go.asInterface(stdgo.strings.Strings.newReader(_pi)), (0 : GoInt), false);
            _x = __tmp__._0;
        };
        if ((_x._utoa((10 : GoInt)) : GoString) != (_pi)) {
            throw Go.toInterface(("benchmark incorrect: conversion failed" : GoString));
        };
        _b.runParallel(function(_pb:Ref<stdgo.testing.Testing.PB>):Void {
            while (_pb.next()) {
                _x._utoa((10 : GoInt));
            };
        });
    }
function benchmarkScan(_b:Ref<stdgo.testing.Testing.B>):Void {
        {};
        for (__0 => _base in (new Slice<GoInt>(0, 0, (2 : GoInt), (8 : GoInt), (10 : GoInt), (16 : GoInt)) : Slice<GoInt>)) {
            for (__1 => _y in (new Slice<stdgo.math.big.Big.Word>(0, 0, (10u32 : stdgo.math.big.Big.Word), (100u32 : stdgo.math.big.Big.Word), (1000u32 : stdgo.math.big.Big.Word), (10000u32 : stdgo.math.big.Big.Word), (100000u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>)) {
                if (_isRaceBuilder && (_y > (1000u32 : stdgo.math.big.Big.Word))) {
                    continue;
                };
                _b.run(stdgo.fmt.Fmt.sprintf(("%d/Base%d" : GoString), Go.toInterface(_y), Go.toInterface(_base)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                    _b.stopTimer();
                    var _z:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
                    _z = _z._expWW((10u32 : stdgo.math.big.Big.Word), _y);
                    var _s = _z._utoa(_base);
                    {
                        var _t = _itoa(_z, _base);
                        if (!stdgo.bytes.Bytes.equal(_s, _t)) {
                            _b.fatalf(("scanning: got %s; want %s" : GoString), Go.toInterface(_s), Go.toInterface(_t));
                        };
                    };
                    _b.startTimer();
                    {
                        var _i:GoInt = (0 : GoInt);
                        Go.cfor(_i < _b.n, _i++, {
                            _z._scan(Go.asInterface(stdgo.bytes.Bytes.newReader(_s)), _base, false);
                        });
                    };
                });
            };
        };
    }
function benchmarkString(_b:Ref<stdgo.testing.Testing.B>):Void {
        {};
        for (__0 => _base in (new Slice<GoInt>(0, 0, (2 : GoInt), (8 : GoInt), (10 : GoInt), (16 : GoInt)) : Slice<GoInt>)) {
            for (__1 => _y in (new Slice<stdgo.math.big.Big.Word>(0, 0, (10u32 : stdgo.math.big.Big.Word), (100u32 : stdgo.math.big.Big.Word), (1000u32 : stdgo.math.big.Big.Word), (10000u32 : stdgo.math.big.Big.Word), (100000u32 : stdgo.math.big.Big.Word)) : Slice<stdgo.math.big.Big.Word>)) {
                if (_isRaceBuilder && (_y > (1000u32 : stdgo.math.big.Big.Word))) {
                    continue;
                };
                _b.run(stdgo.fmt.Fmt.sprintf(("%d/Base%d" : GoString), Go.toInterface(_y), Go.toInterface(_base)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                    _b.stopTimer();
                    var _z:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
                    _z = _z._expWW((10u32 : stdgo.math.big.Big.Word), _y);
                    _z._utoa(_base);
                    _b.startTimer();
                    {
                        var _i:GoInt = (0 : GoInt);
                        Go.cfor(_i < _b.n, _i++, {
                            _z._utoa(_base);
                        });
                    };
                });
            };
        };
    }
function benchmarkLeafSize(_b:Ref<stdgo.testing.Testing.B>):Void {
        {
            var _n:GoInt = (0 : GoInt);
            Go.cfor(_n <= (16 : GoInt), _n++, {
                _b.run(stdgo.fmt.Fmt.sprint(Go.toInterface(_n)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                    leafSizeHelper(_b, (10 : GoInt), _n);
                });
            });
        };
        for (__0 => _n in (new Slice<GoInt>(0, 0, (32 : GoInt), (64 : GoInt)) : Slice<GoInt>)) {
            _b.run(stdgo.fmt.Fmt.sprint(Go.toInterface(_n)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                leafSizeHelper(_b, (10 : GoInt), _n);
            });
        };
    }
function leafSizeHelper(_b:Ref<stdgo.testing.Testing.B>, _base:GoInt, _size:GoInt):Void {
        _b.stopTimer();
        var _originalLeafSize:GoInt = _leafSize;
        _resetTable((_cacheBase10._table.__slice__(0) : Slice<stdgo.math.big.Big.T_divisor>));
        _leafSize = _size;
        _b.startTimer();
        {
            var _d:GoInt = (1 : GoInt);
            Go.cfor(_d <= (10000 : GoInt), _d = _d * ((10 : GoInt)), {
                _b.stopTimer();
                var _z:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
                _z = _z._expWW((_base : Word), (_d : Word));
                _z._utoa(_base);
                _b.startTimer();
                {
                    var _i:GoInt = (0 : GoInt);
                    Go.cfor(_i < _b.n, _i++, {
                        _z._utoa(_base);
                    });
                };
            });
        };
        _b.stopTimer();
        _resetTable((_cacheBase10._table.__slice__(0) : Slice<stdgo.math.big.Big.T_divisor>));
        _leafSize = _originalLeafSize;
        _b.startTimer();
    }
private function _resetTable(_table:Slice<T_divisor>):Void {
        if ((_table != null) && (_table[(0 : GoInt)]._bbb != null)) {
            {
                var _i:GoInt = (0 : GoInt);
                Go.cfor(_i < (_table.length), _i++, {
                    _table[(_i : GoInt)]._bbb = null;
                    _table[(_i : GoInt)]._nbits = (0 : GoInt);
                    _table[(_i : GoInt)]._ndigits = (0 : GoInt);
                });
            };
        };
    }
function testStringPowers(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _p:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        {
            var _b:GoInt = (2 : GoInt);
            Go.cfor(_b <= (16 : GoInt), _b++, {
                {
                    _p = (0u32 : stdgo.math.big.Big.Word);
                    Go.cfor(_p <= (512u32 : stdgo.math.big.Big.Word), _p++, {
                        if (stdgo.testing.Testing.short() && (_p > (10u32 : stdgo.math.big.Big.Word))) {
                            break;
                        };
                        var _x:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._expWW((_b : Word), _p);
                        var _xs = _x._utoa(_b);
                        var _xs2 = _itoa(_x, _b);
                        if (!stdgo.bytes.Bytes.equal(_xs, _xs2)) {
                            _t.errorf(("failed at %d ** %d in base %d: %s != %s" : GoString), Go.toInterface(_b), Go.toInterface(_p), Go.toInterface(_b), Go.toInterface(_xs), Go.toInterface(_xs2));
                        };
                    });
                };
                if ((_b >= (3 : GoInt)) && stdgo.testing.Testing.short()) {
                    break;
                };
            });
        };
    }
/**
    // divWVW overwrites z with x/y, returning the remainder r.
    // The caller must ensure that len(z) = len(x).
**/
private function _divWVW(_z:Slice<Word>, _xn:Word, _x:Slice<Word>, _y:Word):Word {
        var _r:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        _r = _xn;
        if ((_x.length) == ((1 : GoInt))) {
            var __tmp__ = stdgo.math.bits.Bits.div((_r : GoUInt), (_x[(0 : GoInt)] : GoUInt), (_y : GoUInt)), _qq:GoUInt = __tmp__._0, _rr:GoUInt = __tmp__._1;
            _z[(0 : GoInt)] = (_qq : Word);
            return (_rr : Word);
        };
        var _rec:stdgo.math.big.Big.Word = _reciprocalWord(_y);
        {
            var _i:GoInt = (_z.length) - (1 : GoInt);
            Go.cfor(_i >= (0 : GoInt), _i--, {
                {
                    var __tmp__ = _divWW(_r, _x[(_i : GoInt)], _y, _rec);
                    _z[(_i : GoInt)] = __tmp__._0;
                    _r = __tmp__._1;
                };
            });
        };
        return _r;
    }
/**
    // greaterThan reports whether the two digit numbers x1 x2 > y1 y2.
    // TODO(rsc): In contradiction to most of this file, x1 is the high
    // digit and x2 is the low digit. This should be fixed.
**/
private function _greaterThan(_x1:Word, _x2:Word, _y1:Word, _y2:Word):Bool {
        return (_x1 > _y1) || ((_x1 == _y1) && (_x2 > _y2));
    }
private function _cutSpace(_r:GoRune):GoRune {
        if (stdgo.unicode.Unicode.isSpace(_r)) {
            return (-1 : GoInt32);
        };
        return _r;
    }
function testProbablyPrime(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _nreps:GoInt = (20 : GoInt);
        if (stdgo.testing.Testing.short()) {
            _nreps = (1 : GoInt);
        };
        for (_i => _s in _primes) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_s, (10 : GoInt)), _p:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __0:Bool = __tmp__._1;
            if ((!_p.probablyPrime(_nreps) || ((_nreps != (1 : GoInt)) && !_p.probablyPrime((1 : GoInt)))) || !_p.probablyPrime((0 : GoInt))) {
                _t.errorf(("#%d prime found to be non-prime (%s)" : GoString), Go.toInterface(_i), Go.toInterface(_s));
            };
        };
        for (_i => _s in _composites) {
            _s = stdgo.strings.Strings.map(_cutSpace, _s);
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(_s, (10 : GoInt)), _c:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __1:Bool = __tmp__._1;
            if ((_c.probablyPrime(_nreps) || ((_nreps != (1 : GoInt)) && _c.probablyPrime((1 : GoInt)))) || _c.probablyPrime((0 : GoInt))) {
                _t.errorf(("#%d composite found to be prime (%s)" : GoString), Go.toInterface(_i), Go.toInterface(_s));
            };
        };
        var _c = newInt((11i64 : GoInt64));
        for (__2 => _n in (new Slice<GoInt>(0, 0, (-1 : GoInt), (0 : GoInt), (1 : GoInt)) : Slice<GoInt>)) {
            {
                var a = function():Void {
                    var __deferstack__:Array<Void -> Void> = [];
                    try {
                        __deferstack__.unshift(() -> {
                            var a = function():Void {
                                if ((_n < (0 : GoInt)) && (({
                                    final r = Go.recover_exception;
                                    Go.recover_exception = null;
                                    r;
                                }) == null)) {
                                    _t.fatalf(("expected panic from ProbablyPrime(%d)" : GoString), Go.toInterface(_n));
                                };
                            };
                            a();
                        });
                        if (!_c.probablyPrime(_n)) {
                            _t.fatalf(("%v should be a prime" : GoString), Go.toInterface(Go.asInterface(_c)));
                        };
                        for (defer in __deferstack__) {
                            defer();
                        };
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            if (Go.recover_exception != null) throw Go.recover_exception;
                            return;
                        };
                    } catch(__exception__) {
                        var exe:Dynamic = __exception__.native;
                        if ((exe is haxe.ValueException)) exe = exe.value;
                        if (!(exe is AnyInterfaceData)) {
                            exe = Go.toInterface(__exception__.message);
                        };
                        Go.recover_exception = exe;
                        for (defer in __deferstack__) {
                            defer();
                        };
                        if (Go.recover_exception != null) throw Go.recover_exception;
                        return;
                    };
                };
                a();
            };
        };
    }
function benchmarkProbablyPrime(_b:Ref<stdgo.testing.Testing.B>):Void {
        var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setString(("203956878356401977405765866929034577280193993314348263094772646453283062722701277632936616063144088173312372882677123879538709400158306567338328279154499698366071906766440037074217117805690872792848149112022286332144876183376326512083574821647933992961249917319836219304274280243803104015000563790123" : GoString), (10 : GoInt)), _p:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __0:Bool = __tmp__._1;
        for (__1 => _n in (new Slice<GoInt>(0, 0, (0 : GoInt), (1 : GoInt), (5 : GoInt), (10 : GoInt), (20 : GoInt)) : Slice<GoInt>)) {
            _b.run(stdgo.fmt.Fmt.sprintf(("n=%d" : GoString), Go.toInterface(_n)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                {
                    var _i:GoInt = (0 : GoInt);
                    Go.cfor(_i < _b.n, _i++, {
                        _p.probablyPrime(_n);
                    });
                };
            });
        };
        _b.run(("Lucas" : GoString), function(_b:Ref<stdgo.testing.Testing.B>):Void {
            {
                var _i:GoInt = (0 : GoInt);
                Go.cfor(_i < _b.n, _i++, {
                    _p._abs._probablyPrimeLucas();
                });
            };
        });
        _b.run(("MillerRabinBase2" : GoString), function(_b:Ref<stdgo.testing.Testing.B>):Void {
            {
                var _i:GoInt = (0 : GoInt);
                Go.cfor(_i < _b.n, _i++, {
                    _p._abs._probablyPrimeMillerRabin((1 : GoInt), true);
                });
            };
        });
    }
function testMillerRabinPseudoprimes(_t:Ref<stdgo.testing.Testing.T>):Void {
        _testPseudoprimes(_t, ("probablyPrimeMillerRabin" : GoString), function(_n:T_nat):Bool {
            return _n._probablyPrimeMillerRabin((1 : GoInt), true) && !_n._probablyPrimeLucas();
        }, (new Slice<GoInt>(
0,
0,
(2047 : GoInt),
(3277 : GoInt),
(4033 : GoInt),
(4681 : GoInt),
(8321 : GoInt),
(15841 : GoInt),
(29341 : GoInt),
(42799 : GoInt),
(49141 : GoInt),
(52633 : GoInt),
(65281 : GoInt),
(74665 : GoInt),
(80581 : GoInt),
(85489 : GoInt),
(88357 : GoInt),
(90751 : GoInt)) : Slice<GoInt>));
    }
function testLucasPseudoprimes(_t:Ref<stdgo.testing.Testing.T>):Void {
        _testPseudoprimes(_t, ("probablyPrimeLucas" : GoString), function(_n:T_nat):Bool {
            return _n._probablyPrimeLucas() && !_n._probablyPrimeMillerRabin((1 : GoInt), true);
        }, (new Slice<GoInt>(
0,
0,
(989 : GoInt),
(3239 : GoInt),
(5777 : GoInt),
(10877 : GoInt),
(27971 : GoInt),
(29681 : GoInt),
(30739 : GoInt),
(31631 : GoInt),
(39059 : GoInt),
(72389 : GoInt),
(73919 : GoInt),
(75077 : GoInt)) : Slice<GoInt>));
    }
private function _testPseudoprimes(_t:Ref<stdgo.testing.Testing.T>, _name:GoString, _cond:T_nat -> Bool, _want:Slice<GoInt>):Void {
        var _n:stdgo.math.big.Big.T_nat = (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat);
        {
            var _i:GoInt = (3 : GoInt);
            Go.cfor(_i < (100000 : GoInt), _i = _i + ((2 : GoInt)), {
                if (stdgo.testing.Testing.short()) {
                    if ((_want.length) == ((0 : GoInt))) {
                        break;
                    };
                    if (_i < (_want[(0 : GoInt)] - (2 : GoInt))) {
                        _i = _want[(0 : GoInt)] - (2 : GoInt);
                    };
                };
                _n[(0 : GoInt)] = (_i : Word);
                var _pseudo:Bool = _cond(_n);
                if (_pseudo && ((_want.length == (0 : GoInt)) || (_i != _want[(0 : GoInt)]))) {
                    _t.errorf(("%s(%v, base=2) = true, want false" : GoString), Go.toInterface(_name), Go.toInterface(_i));
                } else if ((!_pseudo && (_want.length >= (1 : GoInt))) && (_i == _want[(0 : GoInt)])) {
                    _t.errorf(("%s(%v, base=2) = false, want true" : GoString), Go.toInterface(_name), Go.toInterface(_i));
                };
                if ((_want.length > (0 : GoInt)) && (_i == _want[(0 : GoInt)])) {
                    _want = (_want.__slice__((1 : GoInt)) : Slice<GoInt>);
                };
            });
        };
        if ((_want.length) > (0 : GoInt)) {
            _t.fatalf(("forgot to test %v" : GoString), Go.toInterface(_want));
        };
    }
/**
    // NewRat creates a new Rat with numerator a and denominator b.
**/
function newRat(_a:GoInt64, _b:GoInt64):Ref<Rat> {
        return (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setFrac64(_a, _b);
    }
/**
    // quotToFloat32 returns the non-negative float32 value
    // nearest to the quotient a/b, using round-to-even in
    // halfway cases. It does not mutate its arguments.
    // Preconditions: b is non-zero; a and b have no common factors.
**/
private function _quotToFloat32(_a:T_nat, _b:T_nat):{ var _0 : GoFloat32; var _1 : Bool; } {
        var _f:GoFloat32 = (0 : GoFloat32), _exact:Bool = false;
        {};
        var _alen:GoInt = _a._bitLen();
        if (_alen == ((0 : GoInt))) {
            return { _0 : (0 : GoFloat64), _1 : true };
        };
        var _blen:GoInt = _b._bitLen();
        if (_blen == ((0 : GoInt))) {
            throw Go.toInterface(("division by zero" : GoString));
        };
        var _exp:GoInt = _alen - _blen;
        var __0:T_nat = new stdgo.math.big.Big.T_nat(0, 0), __1:T_nat = new stdgo.math.big.Big.T_nat(0, 0), _b2:T_nat = __1, _a2:T_nat = __0;
        _a2 = _a2._set(_a);
        _b2 = _b2._set(_b);
        {
            var _shift:GoInt = (25 : GoInt) - _exp;
            if (_shift > (0 : GoInt)) {
                _a2 = _a2._shl(_a2, (_shift : GoUInt));
            } else if (_shift < (0 : GoInt)) {
                _b2 = _b2._shl(_b2, (-_shift : GoUInt));
            };
        };
        var _q:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
        var __tmp__ = _q._div(_a2, _a2, _b2), _q:stdgo.math.big.Big.T_nat = __tmp__._0, _r:stdgo.math.big.Big.T_nat = __tmp__._1;
        var _mantissa:GoUInt32 = _low32(_q);
        var _haveRem:Bool = (_r.length) > (0 : GoInt);
        if (_mantissa >> (25i64 : GoUInt64) == ((1u32 : GoUInt32))) {
            if (_mantissa & (1u32 : GoUInt32) == ((1u32 : GoUInt32))) {
                _haveRem = true;
            };
            _mantissa = _mantissa >> ((1i64 : GoUInt64));
            _exp++;
        };
        if (_mantissa >> (24i64 : GoUInt64) != ((1u32 : GoUInt32))) {
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("expected exactly %d bits of result" : GoString), Go.toInterface((25 : GoInt))));
        };
        if (((-149 : GoInt) <= _exp) && (_exp <= (-126 : GoInt))) {
            var _shift:GoUInt = ((-126 : GoInt) - (_exp - (1 : GoInt)) : GoUInt);
            var _lostbits:GoUInt32 = _mantissa & (((1u32 : GoUInt32) << _shift) - (1u32 : GoUInt32));
            _haveRem = _haveRem || (_lostbits != (0u32 : GoUInt32));
            _mantissa = _mantissa >> (_shift);
            _exp = (-125 : GoInt);
        };
        _exact = !_haveRem;
        if (_mantissa & (1u32 : GoUInt32) != ((0u32 : GoUInt32))) {
            _exact = false;
            if (_haveRem || ((_mantissa & (2u32 : GoUInt32)) != (0u32 : GoUInt32))) {
                {
                    _mantissa++;
                    if (_mantissa >= (33554432u32 : GoUInt32)) {
                        _mantissa = _mantissa >> ((1i64 : GoUInt64));
                        _exp++;
                    };
                };
            };
        };
        _mantissa = _mantissa >> ((1i64 : GoUInt64));
        _f = (stdgo.math.Math.ldexp((_mantissa : GoFloat64), _exp - (24 : GoInt)) : GoFloat32);
        if (stdgo.math.Math.isInf((_f : GoFloat64), (0 : GoInt))) {
            _exact = false;
        };
        return { _0 : _f, _1 : _exact };
    }
/**
    // quotToFloat64 returns the non-negative float64 value
    // nearest to the quotient a/b, using round-to-even in
    // halfway cases. It does not mutate its arguments.
    // Preconditions: b is non-zero; a and b have no common factors.
**/
private function _quotToFloat64(_a:T_nat, _b:T_nat):{ var _0 : GoFloat64; var _1 : Bool; } {
        var _f:GoFloat64 = (0 : GoFloat64), _exact:Bool = false;
        {};
        var _alen:GoInt = _a._bitLen();
        if (_alen == ((0 : GoInt))) {
            return { _0 : (0 : GoFloat64), _1 : true };
        };
        var _blen:GoInt = _b._bitLen();
        if (_blen == ((0 : GoInt))) {
            throw Go.toInterface(("division by zero" : GoString));
        };
        var _exp:GoInt = _alen - _blen;
        var __0:T_nat = new stdgo.math.big.Big.T_nat(0, 0), __1:T_nat = new stdgo.math.big.Big.T_nat(0, 0), _b2:T_nat = __1, _a2:T_nat = __0;
        _a2 = _a2._set(_a);
        _b2 = _b2._set(_b);
        {
            var _shift:GoInt = (54 : GoInt) - _exp;
            if (_shift > (0 : GoInt)) {
                _a2 = _a2._shl(_a2, (_shift : GoUInt));
            } else if (_shift < (0 : GoInt)) {
                _b2 = _b2._shl(_b2, (-_shift : GoUInt));
            };
        };
        var _q:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
        var __tmp__ = _q._div(_a2, _a2, _b2), _q:stdgo.math.big.Big.T_nat = __tmp__._0, _r:stdgo.math.big.Big.T_nat = __tmp__._1;
        var _mantissa:GoUInt64 = _low64(_q);
        var _haveRem:Bool = (_r.length) > (0 : GoInt);
        if (_mantissa >> (54i64 : GoUInt64) == ((1i64 : GoUInt64))) {
            if (_mantissa & (1i64 : GoUInt64) == ((1i64 : GoUInt64))) {
                _haveRem = true;
            };
            _mantissa = _mantissa >> ((1i64 : GoUInt64));
            _exp++;
        };
        if (_mantissa >> (53i64 : GoUInt64) != ((1i64 : GoUInt64))) {
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("expected exactly %d bits of result" : GoString), Go.toInterface((54 : GoInt))));
        };
        if (((-1074 : GoInt) <= _exp) && (_exp <= (-1022 : GoInt))) {
            var _shift:GoUInt = ((-1022 : GoInt) - (_exp - (1 : GoInt)) : GoUInt);
            var _lostbits:GoUInt64 = _mantissa & (((1i64 : GoUInt64) << _shift) - (1i64 : GoUInt64));
            _haveRem = _haveRem || (_lostbits != (0i64 : GoUInt64));
            _mantissa = _mantissa >> (_shift);
            _exp = (-1021 : GoInt);
        };
        _exact = !_haveRem;
        if (_mantissa & (1i64 : GoUInt64) != ((0i64 : GoUInt64))) {
            _exact = false;
            if (_haveRem || ((_mantissa & (2i64 : GoUInt64)) != (0i64 : GoUInt64))) {
                {
                    _mantissa++;
                    if (_mantissa >= (18014398509481984i64 : GoUInt64)) {
                        _mantissa = _mantissa >> ((1i64 : GoUInt64));
                        _exp++;
                    };
                };
            };
        };
        _mantissa = _mantissa >> ((1i64 : GoUInt64));
        _f = stdgo.math.Math.ldexp((_mantissa : GoFloat64), _exp - (53 : GoInt));
        if (stdgo.math.Math.isInf(_f, (0 : GoInt))) {
            _exact = false;
        };
        return { _0 : _f, _1 : _exact };
    }
/**
    // mulDenom sets z to the denominator product x*y (by taking into
    // account that 0 values for x or y must be interpreted as 1) and
    // returns z.
**/
private function _mulDenom(_z:T_nat, _x:T_nat, _y:T_nat):T_nat {
        if ((_x.length == (0 : GoInt)) && (_y.length == (0 : GoInt))) {
            return _z._setWord((1u32 : stdgo.math.big.Big.Word));
        } else if ((_x.length) == ((0 : GoInt))) {
            return _z._set(_y);
        } else if ((_y.length) == ((0 : GoInt))) {
            return _z._set(_x);
        };
        return _z._mul(_x, _y);
    }
function testZeroRat(_t:Ref<stdgo.testing.Testing.T>):Void {
        var __deferstack__:Array<Void -> Void> = [];
        try {
            var __0:Rat = ({} : stdgo.math.big.Big.Rat), __1:Rat = ({} : stdgo.math.big.Big.Rat), __2:Rat = ({} : stdgo.math.big.Big.Rat), _z:Rat = __2, _y:Rat = __1, _x:Rat = __0;
            _y.setFrac64((0i64 : GoInt64), (42i64 : GoInt64));
            if (_x.cmp((Go.setRef(_y) : Ref<stdgo.math.big.Big.Rat>)) != ((0 : GoInt))) {
                _t.errorf(("x and y should be both equal and zero" : GoString));
            };
            {
                var _s:GoString = (_x.string() : GoString);
                if (_s != (("0/1" : GoString))) {
                    _t.errorf(("got x = %s, want 0/1" : GoString), Go.toInterface(_s));
                };
            };
            {
                var _s:GoString = _x.ratString();
                if (_s != (("0" : GoString))) {
                    _t.errorf(("got x = %s, want 0" : GoString), Go.toInterface(_s));
                };
            };
            _z.add((Go.setRef(_x) : Ref<stdgo.math.big.Big.Rat>), (Go.setRef(_y) : Ref<stdgo.math.big.Big.Rat>));
            {
                var _s:GoString = _z.ratString();
                if (_s != (("0" : GoString))) {
                    _t.errorf(("got x+y = %s, want 0" : GoString), Go.toInterface(_s));
                };
            };
            _z.sub((Go.setRef(_x) : Ref<stdgo.math.big.Big.Rat>), (Go.setRef(_y) : Ref<stdgo.math.big.Big.Rat>));
            {
                var _s:GoString = _z.ratString();
                if (_s != (("0" : GoString))) {
                    _t.errorf(("got x-y = %s, want 0" : GoString), Go.toInterface(_s));
                };
            };
            _z.mul((Go.setRef(_x) : Ref<stdgo.math.big.Big.Rat>), (Go.setRef(_y) : Ref<stdgo.math.big.Big.Rat>));
            {
                var _s:GoString = _z.ratString();
                if (_s != (("0" : GoString))) {
                    _t.errorf(("got x*y = %s, want 0" : GoString), Go.toInterface(_s));
                };
            };
            __deferstack__.unshift(() -> {
                var a = function():Void {
                    {
                        var _s:AnyInterface = ({
                            final r = Go.recover_exception;
                            Go.recover_exception = null;
                            r;
                        });
                        if ((_s == null) || ((Go.typeAssert((_s : GoString)) : GoString) != ("division by zero" : GoString))) {
                            throw Go.toInterface(_s);
                        };
                    };
                };
                a();
            });
            _z.quo((Go.setRef(_x) : Ref<stdgo.math.big.Big.Rat>), (Go.setRef(_y) : Ref<stdgo.math.big.Big.Rat>));
            for (defer in __deferstack__) {
                defer();
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (Go.recover_exception != null) throw Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is AnyInterfaceData)) {
                exe = Go.toInterface(__exception__.message);
            };
            Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (Go.recover_exception != null) throw Go.recover_exception;
            return;
        };
    }
function testRatSign(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _zero = newRat((0i64 : GoInt64), (1i64 : GoInt64));
        for (__0 => _a in _setStringTests) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setString(_a._in), _x:Ref<stdgo.math.big.Big.Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                continue;
            };
            var _s:GoInt = _x.sign();
            var _e:GoInt = _x.cmp(_zero);
            if (_s != (_e)) {
                _t.errorf(("got %d; want %d for z = %v" : GoString), Go.toInterface(_s), Go.toInterface(_e), Go.toInterface((Go.setRef(_x) : Ref<Ref<stdgo.math.big.Big.Rat>>)));
            };
        };
    }
function testRatCmp(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _test in _ratCmpTests) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setString(_test._rat1), _x:Ref<stdgo.math.big.Big.Rat> = __tmp__._0, __0:Bool = __tmp__._1;
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setString(_test._rat2), _y:Ref<stdgo.math.big.Big.Rat> = __tmp__._0, __1:Bool = __tmp__._1;
            var _out:GoInt = _x.cmp(_y);
            if (_out != (_test._out)) {
                _t.errorf(("#%d got out = %v; want %v" : GoString), Go.toInterface(_i), Go.toInterface(_out), Go.toInterface(_test._out));
            };
        };
    }
function testIsInt(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _one = newInt((1i64 : GoInt64));
        for (__0 => _a in _setStringTests) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setString(_a._in), _x:Ref<stdgo.math.big.Big.Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                continue;
            };
            var _i:Bool = _x.isInt();
            var _e:Bool = _x.denom().cmp(_one) == ((0 : GoInt));
            if (_i != (_e)) {
                _t.errorf(("got IsInt(%v) == %v; want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(_i), Go.toInterface(_e));
            };
        };
    }
function testRatAbs(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _zero = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>);
        for (__0 => _a in _setStringTests) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setString(_a._in), _x:Ref<stdgo.math.big.Big.Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                continue;
            };
            var _e = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).set(_x);
            if (_e.cmp(_zero) < (0 : GoInt)) {
                _e.sub(_zero, _e);
            };
            var _z = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).abs(_x);
            if (_z.cmp(_e) != ((0 : GoInt))) {
                _t.errorf(("got Abs(%v) = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_z)), Go.toInterface(Go.asInterface(_e)));
            };
        };
    }
function testRatNeg(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _zero = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>);
        for (__0 => _a in _setStringTests) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setString(_a._in), _x:Ref<stdgo.math.big.Big.Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                continue;
            };
            var _e = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).sub(_zero, _x);
            var _z = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).neg(_x);
            if (_z.cmp(_e) != ((0 : GoInt))) {
                _t.errorf(("got Neg(%v) = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_z)), Go.toInterface(Go.asInterface(_e)));
            };
        };
    }
function testRatInv(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _zero = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>);
        for (__0 => _a in _setStringTests) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setString(_a._in), _x:Ref<stdgo.math.big.Big.Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                continue;
            };
            if (_x.cmp(_zero) == ((0 : GoInt))) {
                continue;
            };
            var _e = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setFrac(_x.denom(), _x.num());
            var _z = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).inv(_x);
            if (_z.cmp(_e) != ((0 : GoInt))) {
                _t.errorf(("got Inv(%v) = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_z)), Go.toInterface(Go.asInterface(_e)));
            };
        };
    }
private function _testRatBin(_t:Ref<stdgo.testing.Testing.T>, _i:GoInt, _name:GoString, _f:T_ratBinFun, _a:T_ratBinArg):Void {
        var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setString(_a._x), _x:Ref<stdgo.math.big.Big.Rat> = __tmp__._0, __0:Bool = __tmp__._1;
        var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setString(_a._y), _y:Ref<stdgo.math.big.Big.Rat> = __tmp__._0, __1:Bool = __tmp__._1;
        var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setString(_a._z), _z:Ref<stdgo.math.big.Big.Rat> = __tmp__._0, __2:Bool = __tmp__._1;
        var _out = _f((Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>), _x, _y);
        if (_out.cmp(_z) != ((0 : GoInt))) {
            _t.errorf(("%s #%d got %s want %s" : GoString), Go.toInterface(_name), Go.toInterface(_i), Go.toInterface(Go.asInterface(_out)), Go.toInterface(Go.asInterface(_z)));
        };
    }
function testRatBin(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _test in _ratBinTests) {
            var _arg:stdgo.math.big.Big.T_ratBinArg = (new T_ratBinArg(_test._x, _test._y, _test._sum) : T_ratBinArg);
            _testRatBin(_t, _i, ("Add" : GoString), Rat_static_extension.add, _arg?.__copy__());
            _arg = (new T_ratBinArg(_test._y, _test._x, _test._sum) : T_ratBinArg);
            _testRatBin(_t, _i, ("Add symmetric" : GoString), Rat_static_extension.add, _arg?.__copy__());
            _arg = (new T_ratBinArg(_test._sum, _test._x, _test._y) : T_ratBinArg);
            _testRatBin(_t, _i, ("Sub" : GoString), Rat_static_extension.sub, _arg?.__copy__());
            _arg = (new T_ratBinArg(_test._sum, _test._y, _test._x) : T_ratBinArg);
            _testRatBin(_t, _i, ("Sub symmetric" : GoString), Rat_static_extension.sub, _arg?.__copy__());
            _arg = (new T_ratBinArg(_test._x, _test._y, _test._prod) : T_ratBinArg);
            _testRatBin(_t, _i, ("Mul" : GoString), Rat_static_extension.mul, _arg?.__copy__());
            _arg = (new T_ratBinArg(_test._y, _test._x, _test._prod) : T_ratBinArg);
            _testRatBin(_t, _i, ("Mul symmetric" : GoString), Rat_static_extension.mul, _arg?.__copy__());
            if (_test._x != (("0" : GoString))) {
                _arg = (new T_ratBinArg(_test._prod, _test._x, _test._y) : T_ratBinArg);
                _testRatBin(_t, _i, ("Quo" : GoString), Rat_static_extension.quo, _arg?.__copy__());
            };
            if (_test._y != (("0" : GoString))) {
                _arg = (new T_ratBinArg(_test._prod, _test._y, _test._x) : T_ratBinArg);
                _testRatBin(_t, _i, ("Quo symmetric" : GoString), Rat_static_extension.quo, _arg?.__copy__());
            };
        };
    }
function testIssue820(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _x = newRat((3i64 : GoInt64), (1i64 : GoInt64));
        var _y = newRat((2i64 : GoInt64), (1i64 : GoInt64));
        var _z = _y.quo(_x, _y);
        var _q = newRat((3i64 : GoInt64), (2i64 : GoInt64));
        if (_z.cmp(_q) != ((0 : GoInt))) {
            _t.errorf(("got %s want %s" : GoString), Go.toInterface(Go.asInterface(_z)), Go.toInterface(Go.asInterface(_q)));
        };
        _y = newRat((3i64 : GoInt64), (1i64 : GoInt64));
        _x = newRat((2i64 : GoInt64), (1i64 : GoInt64));
        _z = _y.quo(_x, _y);
        _q = newRat((2i64 : GoInt64), (3i64 : GoInt64));
        if (_z.cmp(_q) != ((0 : GoInt))) {
            _t.errorf(("got %s want %s" : GoString), Go.toInterface(Go.asInterface(_z)), Go.toInterface(Go.asInterface(_q)));
        };
        _x = newRat((3i64 : GoInt64), (1i64 : GoInt64));
        _z = _x.quo(_x, _x);
        _q = newRat((3i64 : GoInt64), (3i64 : GoInt64));
        if (_z.cmp(_q) != ((0 : GoInt))) {
            _t.errorf(("got %s want %s" : GoString), Go.toInterface(Go.asInterface(_z)), Go.toInterface(Go.asInterface(_q)));
        };
    }
function testRatSetFrac64Rat(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _test in _setFrac64Tests) {
            var _x = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setFrac64(_test._a, _test._b);
            if (_x.ratString() != (_test._out)) {
                _t.errorf(("#%d got %s want %s" : GoString), Go.toInterface(_i), Go.toInterface(_x.ratString()), Go.toInterface(_test._out));
            };
        };
    }
function testIssue2379(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _q = newRat((3i64 : GoInt64), (2i64 : GoInt64));
        var _x = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>);
        _x.setFrac(newInt((3i64 : GoInt64)), newInt((2i64 : GoInt64)));
        if (_x.cmp(_q) != ((0 : GoInt))) {
            _t.errorf(("1) got %s want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_q)));
        };
        _x = newRat((2i64 : GoInt64), (3i64 : GoInt64));
        _x.setFrac(newInt((3i64 : GoInt64)), _x.num());
        if (_x.cmp(_q) != ((0 : GoInt))) {
            _t.errorf(("2) got %s want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_q)));
        };
        _x = newRat((2i64 : GoInt64), (3i64 : GoInt64));
        _x.setFrac(_x.denom(), newInt((2i64 : GoInt64)));
        if (_x.cmp(_q) != ((0 : GoInt))) {
            _t.errorf(("3) got %s want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_q)));
        };
        _x = newRat((2i64 : GoInt64), (3i64 : GoInt64));
        _x.setFrac(_x.denom(), _x.num());
        if (_x.cmp(_q) != ((0 : GoInt))) {
            _t.errorf(("4) got %s want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_q)));
        };
        _q = newRat((1i64 : GoInt64), (1i64 : GoInt64));
        _x = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>);
        var _n = newInt((7i64 : GoInt64));
        _x.setFrac(_n, _n);
        if (_x.cmp(_q) != ((0 : GoInt))) {
            _t.errorf(("5) got %s want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_q)));
        };
    }
function testIssue3521(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _a = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        var _b = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        _a.setString(("64375784358435883458348587" : GoString), (0 : GoInt));
        _b.setString(("4789759874531" : GoString), (0 : GoInt));
        var _zero = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>);
        var _one = newInt((1i64 : GoInt64));
        if (_zero.denom().cmp(_one) != ((0 : GoInt))) {
            _t.errorf(("0) got %s want %s" : GoString), Go.toInterface(Go.asInterface(_zero.denom())), Go.toInterface(Go.asInterface(_one)));
        };
        var _s = (Go.setRef(_zero._b) : Ref<stdgo.math.big.Big.Int_>);
        var _d = _zero.denom();
        if (_d == (_s)) {
            _t.errorf(("1a) got %s (%p) == %s (%p) want different *Int values" : GoString), Go.toInterface(Go.asInterface(_d)), Go.toInterface(Go.asInterface(_d)), Go.toInterface(Go.asInterface(_s)), Go.toInterface(Go.asInterface(_s)));
        };
        var _d1 = _zero.denom();
        var _d2 = _zero.denom();
        if (_d1 == (_d2)) {
            _t.errorf(("1b) got %s (%p) == %s (%p) want different *Int values" : GoString), Go.toInterface(Go.asInterface(_d1)), Go.toInterface(Go.asInterface(_d1)), Go.toInterface(Go.asInterface(_d2)), Go.toInterface(Go.asInterface(_d2)));
        };
        var _x = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>);
        _x.set(_x);
        _s = (Go.setRef(_x._b) : Ref<stdgo.math.big.Big.Int_>);
        _d = _x.denom();
        if (_d != (_s)) {
            _t.errorf(("1c) got %s (%p) != %s (%p) want identical *Int values" : GoString), Go.toInterface(Go.asInterface(_d)), Go.toInterface(Go.asInterface(_d)), Go.toInterface(Go.asInterface(_s)), Go.toInterface(Go.asInterface(_s)));
        };
        _x.denom().set((Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).neg(_b));
        if (_x.cmp(_zero) != ((0 : GoInt))) {
            _t.errorf(("1d) got %s want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_zero)));
        };
        _x.num().set(_a);
        var _qab = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setFrac(_a, _b);
        if (_x.cmp(_qab) != ((0 : GoInt))) {
            _t.errorf(("1e) got %s want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_qab)));
        };
        _x.setFrac64((10i64 : GoInt64), (2i64 : GoInt64));
        _x.denom().setInt64((3i64 : GoInt64));
        var _q53 = newRat((5i64 : GoInt64), (3i64 : GoInt64));
        if (_x.cmp(_q53) != ((0 : GoInt))) {
            _t.errorf(("2a) got %s want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_q53)));
        };
        _x = newRat((10i64 : GoInt64), (2i64 : GoInt64));
        _x.denom().setInt64((3i64 : GoInt64));
        if (_x.cmp(_q53) != ((0 : GoInt))) {
            _t.errorf(("2b) got %s want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_q53)));
        };
        _x.setFrac(_a, _b);
        _a = _x.num();
        _b = _x.denom();
        _a.setInt64((5i64 : GoInt64));
        _b.setInt64((3i64 : GoInt64));
        if (_x.cmp(_q53) != ((0 : GoInt))) {
            _t.errorf(("3) got %s want %s" : GoString), Go.toInterface(Go.asInterface(_x)), Go.toInterface(Go.asInterface(_q53)));
        };
    }
function testFloat32Distribution(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _add:Slice<GoInt64> = (new Slice<GoInt64>(0, 0, (0i64 : GoInt64), (1i64 : GoInt64), (3i64 : GoInt64), (5i64 : GoInt64), (7i64 : GoInt64), (9i64 : GoInt64), (11i64 : GoInt64)) : Slice<GoInt64>);
        var __0:GoUInt64 = (5i64 : GoUInt64), __1:GoInt = (15 : GoInt), _einc:GoInt = __1, _winc:GoUInt64 = __0;
        if (_long.value) {
            {
                final __tmp__0 = (1i64 : GoUInt64);
                final __tmp__1 = (1 : GoInt);
                _winc = __tmp__0;
                _einc = __tmp__1;
            };
        };
        for (__0 => _sign in ("+-" : GoString)) {
            for (__1 => _a in _add) {
                {
                    var _wid:GoUInt64 = (0i64 : GoUInt64);
                    Go.cfor(_wid < (30i64 : GoUInt64), _wid = _wid + (_winc), {
                        var _b:GoInt64 = ((1i64 : GoInt64) << _wid) + _a;
                        if (_sign == ((45 : GoInt32))) {
                            _b = -_b;
                        };
                        {
                            var _exp:GoInt = (-150 : GoInt);
                            Go.cfor(_exp < (150 : GoInt), _exp = _exp + (_einc), {
                                var __0 = newInt(_b), __1 = newInt((1i64 : GoInt64)), _den = __1, _num = __0;
                                if (_exp > (0 : GoInt)) {
                                    _num.lsh(_num, (_exp : GoUInt));
                                } else {
                                    _den.lsh(_den, (-_exp : GoUInt));
                                };
                                var _r = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setFrac(_num, _den);
                                var __tmp__ = _r.float32(), _f:GoFloat32 = __tmp__._0, __2:Bool = __tmp__._1;
                                if (!_checkIsBestApprox32(_t, _f, _r)) {
                                    _t.errorf(("(input was mantissa %#x, exp %d; f = %g (%b); f ~ %g; r = %v)" : GoString), Go.toInterface(_b), Go.toInterface(_exp), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(stdgo.math.Math.ldexp((_b : GoFloat64), _exp)), Go.toInterface(Go.asInterface(_r)));
                                };
                                _checkNonLossyRoundtrip32(_t, _f);
                            });
                        };
                    });
                };
            };
        };
    }
function testFloat64Distribution(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _add:Slice<GoInt64> = (new Slice<GoInt64>(0, 0, (0i64 : GoInt64), (1i64 : GoInt64), (3i64 : GoInt64), (5i64 : GoInt64), (7i64 : GoInt64), (9i64 : GoInt64), (11i64 : GoInt64)) : Slice<GoInt64>);
        var __0:GoUInt64 = (10i64 : GoUInt64), __1:GoInt = (500 : GoInt), _einc:GoInt = __1, _winc:GoUInt64 = __0;
        if (_long.value) {
            {
                final __tmp__0 = (1i64 : GoUInt64);
                final __tmp__1 = (1 : GoInt);
                _winc = __tmp__0;
                _einc = __tmp__1;
            };
        };
        for (__0 => _sign in ("+-" : GoString)) {
            for (__1 => _a in _add) {
                {
                    var _wid:GoUInt64 = (0i64 : GoUInt64);
                    Go.cfor(_wid < (60i64 : GoUInt64), _wid = _wid + (_winc), {
                        var _b:GoInt64 = ((1i64 : GoInt64) << _wid) + _a;
                        if (_sign == ((45 : GoInt32))) {
                            _b = -_b;
                        };
                        {
                            var _exp:GoInt = (-1100 : GoInt);
                            Go.cfor(_exp < (1100 : GoInt), _exp = _exp + (_einc), {
                                var __0 = newInt(_b), __1 = newInt((1i64 : GoInt64)), _den = __1, _num = __0;
                                if (_exp > (0 : GoInt)) {
                                    _num.lsh(_num, (_exp : GoUInt));
                                } else {
                                    _den.lsh(_den, (-_exp : GoUInt));
                                };
                                var _r = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setFrac(_num, _den);
                                var __tmp__ = _r.float64(), _f:GoFloat64 = __tmp__._0, __2:Bool = __tmp__._1;
                                if (!_checkIsBestApprox64(_t, _f, _r)) {
                                    _t.errorf(("(input was mantissa %#x, exp %d; f = %g (%b); f ~ %g; r = %v)" : GoString), Go.toInterface(_b), Go.toInterface(_exp), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(stdgo.math.Math.ldexp((_b : GoFloat64), _exp)), Go.toInterface(Go.asInterface(_r)));
                                };
                                _checkNonLossyRoundtrip64(_t, _f);
                            });
                        };
                    });
                };
            };
        };
    }
/**
    // TestSetFloat64NonFinite checks that SetFloat64 of a non-finite value
    // returns nil.
**/
function testSetFloat64NonFinite(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _f in (new Slice<GoFloat64>(0, 0, stdgo.math.Math.naN(), stdgo.math.Math.inf((1 : GoInt)), stdgo.math.Math.inf((-1 : GoInt))) : Slice<GoFloat64>)) {
            var _r:Rat = ({} : stdgo.math.big.Big.Rat);
            {
                var _r2 = _r.setFloat64(_f);
                if (_r2 != null && ((_r2 : Dynamic).__nil__ == null || !(_r2 : Dynamic).__nil__)) {
                    _t.errorf(("SetFloat64(%g) was %v, want nil" : GoString), Go.toInterface(_f), Go.toInterface(Go.asInterface(_r2)));
                };
            };
        };
    }
/**
    // checkNonLossyRoundtrip32 checks that a float->Rat->float roundtrip is
    // non-lossy for finite f.
**/
private function _checkNonLossyRoundtrip32(_t:Ref<stdgo.testing.Testing.T>, _f:GoFloat32):Void {
        if (!_isFinite((_f : GoFloat64))) {
            return;
        };
        var _r = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setFloat64((_f : GoFloat64));
        if (_r == null || (_r : Dynamic).__nil__) {
            _t.errorf(("Rat.SetFloat64(float64(%g) (%b)) == nil" : GoString), Go.toInterface(_f), Go.toInterface(_f));
            return;
        };
        var __tmp__ = _r.float32(), _f2:GoFloat32 = __tmp__._0, _exact:Bool = __tmp__._1;
        if ((_f != _f2) || !_exact) {
            _t.errorf(("Rat.SetFloat64(float64(%g)).Float32() = %g (%b), %v, want %g (%b), %v; delta = %b" : GoString), Go.toInterface(_f), Go.toInterface(_f2), Go.toInterface(_f2), Go.toInterface(_exact), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(true), Go.toInterface(_f2 - _f));
        };
    }
/**
    // checkNonLossyRoundtrip64 checks that a float->Rat->float roundtrip is
    // non-lossy for finite f.
**/
private function _checkNonLossyRoundtrip64(_t:Ref<stdgo.testing.Testing.T>, _f:GoFloat64):Void {
        if (!_isFinite(_f)) {
            return;
        };
        var _r = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setFloat64(_f);
        if (_r == null || (_r : Dynamic).__nil__) {
            _t.errorf(("Rat.SetFloat64(%g (%b)) == nil" : GoString), Go.toInterface(_f), Go.toInterface(_f));
            return;
        };
        var __tmp__ = _r.float64(), _f2:GoFloat64 = __tmp__._0, _exact:Bool = __tmp__._1;
        if ((_f != _f2) || !_exact) {
            _t.errorf(("Rat.SetFloat64(%g).Float64() = %g (%b), %v, want %g (%b), %v; delta = %b" : GoString), Go.toInterface(_f), Go.toInterface(_f2), Go.toInterface(_f2), Go.toInterface(_exact), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(true), Go.toInterface(_f2 - _f));
        };
    }
/**
    // delta returns the absolute difference between r and f.
**/
private function _delta(_r:Ref<Rat>, _f:GoFloat64):Ref<Rat> {
        var _d = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).sub(_r, (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setFloat64(_f));
        return _d.abs(_d);
    }
/**
    // checkIsBestApprox32 checks that f is the best possible float32
    // approximation of r.
    // Returns true on success.
**/
private function _checkIsBestApprox32(_t:Ref<stdgo.testing.Testing.T>, _f:GoFloat32, _r:Ref<Rat>):Bool {
        if (stdgo.math.Math.abs((_f : GoFloat64)) >= (3.4028234663852886e+38 : GoFloat64)) {
            return true;
        };
        var _f0:GoFloat32 = stdgo.math.Math.nextafter32(_f, (stdgo.math.Math.inf((-1 : GoInt)) : GoFloat32));
        var _f1:GoFloat32 = stdgo.math.Math.nextafter32(_f, (stdgo.math.Math.inf((1 : GoInt)) : GoFloat32));
        var _df = _delta(_r, (_f : GoFloat64));
        var _df0 = _delta(_r, (_f0 : GoFloat64));
        var _df1 = _delta(_r, (_f1 : GoFloat64));
        if (_df.cmp(_df0) > (0 : GoInt)) {
            _t.errorf(("Rat(%v).Float32() = %g (%b), but previous float32 %g (%b) is closer" : GoString), Go.toInterface(Go.asInterface(_r)), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(_f0), Go.toInterface(_f0));
            return false;
        };
        if (_df.cmp(_df1) > (0 : GoInt)) {
            _t.errorf(("Rat(%v).Float32() = %g (%b), but next float32 %g (%b) is closer" : GoString), Go.toInterface(Go.asInterface(_r)), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(_f1), Go.toInterface(_f1));
            return false;
        };
        if ((_df.cmp(_df0) == (0 : GoInt)) && !_isEven32(_f)) {
            _t.errorf(("Rat(%v).Float32() = %g (%b); halfway should have rounded to %g (%b) instead" : GoString), Go.toInterface(Go.asInterface(_r)), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(_f0), Go.toInterface(_f0));
            return false;
        };
        if ((_df.cmp(_df1) == (0 : GoInt)) && !_isEven32(_f)) {
            _t.errorf(("Rat(%v).Float32() = %g (%b); halfway should have rounded to %g (%b) instead" : GoString), Go.toInterface(Go.asInterface(_r)), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(_f1), Go.toInterface(_f1));
            return false;
        };
        return true;
    }
/**
    // checkIsBestApprox64 checks that f is the best possible float64
    // approximation of r.
    // Returns true on success.
**/
private function _checkIsBestApprox64(_t:Ref<stdgo.testing.Testing.T>, _f:GoFloat64, _r:Ref<Rat>):Bool {
        if (stdgo.math.Math.abs(_f) >= (1.7976931348623157e+308 : GoFloat64)) {
            return true;
        };
        var _f0:GoFloat64 = stdgo.math.Math.nextafter(_f, stdgo.math.Math.inf((-1 : GoInt)));
        var _f1:GoFloat64 = stdgo.math.Math.nextafter(_f, stdgo.math.Math.inf((1 : GoInt)));
        var _df = _delta(_r, _f);
        var _df0 = _delta(_r, _f0);
        var _df1 = _delta(_r, _f1);
        if (_df.cmp(_df0) > (0 : GoInt)) {
            _t.errorf(("Rat(%v).Float64() = %g (%b), but previous float64 %g (%b) is closer" : GoString), Go.toInterface(Go.asInterface(_r)), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(_f0), Go.toInterface(_f0));
            return false;
        };
        if (_df.cmp(_df1) > (0 : GoInt)) {
            _t.errorf(("Rat(%v).Float64() = %g (%b), but next float64 %g (%b) is closer" : GoString), Go.toInterface(Go.asInterface(_r)), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(_f1), Go.toInterface(_f1));
            return false;
        };
        if ((_df.cmp(_df0) == (0 : GoInt)) && !_isEven64(_f)) {
            _t.errorf(("Rat(%v).Float64() = %g (%b); halfway should have rounded to %g (%b) instead" : GoString), Go.toInterface(Go.asInterface(_r)), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(_f0), Go.toInterface(_f0));
            return false;
        };
        if ((_df.cmp(_df1) == (0 : GoInt)) && !_isEven64(_f)) {
            _t.errorf(("Rat(%v).Float64() = %g (%b); halfway should have rounded to %g (%b) instead" : GoString), Go.toInterface(Go.asInterface(_r)), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(_f1), Go.toInterface(_f1));
            return false;
        };
        return true;
    }
private function _isEven32(_f:GoFloat32):Bool {
        return stdgo.math.Math.float32bits(_f) & (1u32 : GoUInt32) == ((0u32 : GoUInt32));
    }
private function _isEven64(_f:GoFloat64):Bool {
        return stdgo.math.Math.float64bits(_f) & (1i64 : GoUInt64) == ((0i64 : GoUInt64));
    }
function testIsFinite(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _finites = (new Slice<GoFloat64>(0, 0, (0.3333333333333333 : GoFloat64), (4.8915598712767145e+243 : GoFloat64), (1.7976931348623157e+308 : GoFloat64), (5e-324 : GoFloat64), (-1.7976931348623157e+308 : GoFloat64), (-5e-324 : GoFloat64)) : Slice<GoFloat64>);
        for (__0 => _f in _finites) {
            if (!_isFinite(_f)) {
                _t.errorf(("!IsFinite(%g (%b))" : GoString), Go.toInterface(_f), Go.toInterface(_f));
            };
        };
        var _nonfinites = (new Slice<GoFloat64>(0, 0, stdgo.math.Math.naN(), stdgo.math.Math.inf((-1 : GoInt)), stdgo.math.Math.inf((1 : GoInt))) : Slice<GoFloat64>);
        for (__1 => _f in _nonfinites) {
            if (_isFinite(_f)) {
                _t.errorf(("IsFinite(%g, (%b))" : GoString), Go.toInterface(_f), Go.toInterface(_f));
            };
        };
    }
function testRatSetInt64(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _testCases:Slice<GoInt64> = (new Slice<GoInt64>(0, 0, (0i64 : GoInt64), (1i64 : GoInt64), (-1i64 : GoInt64), (12345i64 : GoInt64), (-98765i64 : GoInt64), (9223372036854775807i64 : GoInt64), (-9223372036854775808i64 : GoInt64)) : Slice<GoInt64>);
        var _r:Ref<stdgo.math.big.Big.Rat> = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>);
        for (_i => _want in _testCases) {
            _r.setInt64(_want);
            if (!_r.isInt()) {
                _t.errorf(("#%d: Rat.SetInt64(%d) is not an integer" : GoString), Go.toInterface(_i), Go.toInterface(_want));
            };
            var _num = _r.num();
            if (!_num.isInt64()) {
                _t.errorf(("#%d: Rat.SetInt64(%d) numerator is not an int64" : GoString), Go.toInterface(_i), Go.toInterface(_want));
            };
            var _got:GoInt64 = _num.int64();
            if (_got != (_want)) {
                _t.errorf(("#%d: Rat.SetInt64(%d) = %d, but expected %d" : GoString), Go.toInterface(_i), Go.toInterface(_want), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function testRatSetUint64(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _testCases:Slice<GoUInt64> = (new Slice<GoUInt64>(0, 0, (0i64 : GoUInt64), (1i64 : GoUInt64), (12345i64 : GoUInt64), (-1i64 : GoUInt64)) : Slice<GoUInt64>);
        var _r:Ref<stdgo.math.big.Big.Rat> = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>);
        for (_i => _want in _testCases) {
            _r.setUint64(_want);
            if (!_r.isInt()) {
                _t.errorf(("#%d: Rat.SetUint64(%d) is not an integer" : GoString), Go.toInterface(_i), Go.toInterface(_want));
            };
            var _num = _r.num();
            if (!_num.isUint64()) {
                _t.errorf(("#%d: Rat.SetUint64(%d) numerator is not a uint64" : GoString), Go.toInterface(_i), Go.toInterface(_want));
            };
            var _got:GoUInt64 = _num.uint64();
            if (_got != (_want)) {
                _t.errorf(("#%d: Rat.SetUint64(%d) = %d, but expected %d" : GoString), Go.toInterface(_i), Go.toInterface(_want), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function benchmarkRatCmp(_b:Ref<stdgo.testing.Testing.B>):Void {
        var __0 = newRat((4i64 : GoInt64), (1i64 : GoInt64)), __1 = newRat((7i64 : GoInt64), (2i64 : GoInt64)), _y = __1, _x = __0;
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _b.n, _i++, {
                _x.cmp(_y);
            });
        };
    }
/**
    // TestIssue34919 verifies that a Rat's denominator is not modified
    // when simply accessing the Rat value.
**/
function testIssue34919(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _acc in (new Slice<T__struct_60>(0, 0, ({ _name : ("Float32" : GoString), _f : function(_x:Ref<Rat>):Void {
            _x.float32();
        } } : T__struct_60), ({ _name : ("Float64" : GoString), _f : function(_x:Ref<Rat>):Void {
            _x.float64();
        } } : T__struct_60), ({ _name : ("Inv" : GoString), _f : function(_x:Ref<Rat>):Void {
            (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).inv(_x);
        } } : T__struct_60), ({ _name : ("Sign" : GoString), _f : function(_x:Ref<Rat>):Void {
            _x.sign();
        } } : T__struct_60), ({ _name : ("IsInt" : GoString), _f : function(_x:Ref<Rat>):Void {
            _x.isInt();
        } } : T__struct_60), ({ _name : ("Num" : GoString), _f : function(_x:Ref<Rat>):Void {
            _x.num();
        } } : T__struct_60)) : Slice<T__struct_60>)) {
            var _r = (Go.setRef((new Rat(({ _abs : (new Slice<stdgo.math.big.Big.Word>(0, 0, (991u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat) } : Int_), ({ _abs : new stdgo.math.big.Big.T_nat((0 : GoInt).toBasic(), (1 : GoInt), ...[for (i in 0 ... (0 : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]) } : Int_)) : Rat)) : Ref<stdgo.math.big.Big.Rat>);
            _acc._f(_r);
            {
                var _d:stdgo.math.big.Big.Word = (_r._b._abs.__slice__(0, (1 : GoInt)) : stdgo.math.big.Big.T_nat)[(0 : GoInt)];
                if (_d != ((0u32 : stdgo.math.big.Big.Word))) {
                    _t.errorf(("%s modified denominator: got %d, want 0" : GoString), Go.toInterface(_acc._name), Go.toInterface(_d));
                };
            };
        };
    }
function testDenomRace(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _x = newRat((1i64 : GoInt64), (2i64 : GoInt64));
        {};
        var _c = new Chan<Bool>((3 : GoInt).toBasic(), () -> false);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < (3 : GoInt), _i++, {
                Go.routine(() -> {
                    var a = function():Void {
                        _x.denom();
                        (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setRat(_x);
                        _c.__send__(true);
                    };
                    a();
                });
            });
        };
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < (3 : GoInt), _i++, {
                _c.__get__();
            });
        };
    }
private function _ratTok(_ch:GoRune):Bool {
        return stdgo.strings.Strings.containsRune(("+-/0123456789.eE" : GoString), _ch);
    }
/**
    // scanExponent scans the longest possible prefix of r representing a base 10
    // (e, E) or a base 2 (p, P) exponent, if any. It returns the
    // exponent, the exponent base (10 or 2), or a read or syntax error, if any.
    //
    // If sepOk is set, an underscore character _ may appear between successive
    // exponent digits; such underscores do not change the value of the exponent.
    // Incorrect placement of underscores is reported as an error if there are no
    // other errors. If sepOk is not set, underscores are not recognized and thus
    // terminate scanning like any other character that is not a valid digit.
    //
    //	exponent = ( "e" | "E" | "p" | "P" ) [ sign ] digits .
    //	sign     = "+" | "-" .
    //	digits   = digit { [ '_' ] digit } .
    //	digit    = "0" ... "9" .
    //
    // A base 2 exponent is only permitted if base2ok is set.
**/
private function _scanExponent(_r:stdgo.io.Io.ByteScanner, _base2ok:Bool, _sepOk:Bool):{ var _0 : GoInt64; var _1 : GoInt; var _2 : Error; } {
        var _exp:GoInt64 = (0 : GoInt64), _base:GoInt = (0 : GoInt), _err:Error = (null : Error);
        var __tmp__ = _r.readByte(), _ch:GoUInt8 = __tmp__._0, _err:Error = __tmp__._1;
        if (_err != null) {
            if (Go.toInterface(_err) == (Go.toInterface(stdgo.io.Io.eof))) {
                _err = (null : Error);
            };
            return { _0 : (0i64 : GoInt64), _1 : (10 : GoInt), _2 : _err };
        };
        {
            var __switchIndex__ = -1;
            while (true) {
                {
                    final __value__ = _ch;
                    if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (__value__ == ((101 : GoUInt8)) || __value__ == ((69 : GoUInt8))))) {
                        _base = (10 : GoInt);
                        break;
                        break;
                    } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && (__value__ == ((112 : GoUInt8)) || __value__ == ((80 : GoUInt8))))) {
                        if (_base2ok) {
                            _base = (2 : GoInt);
                            break;
                        };
                        @:fallthrough {
                            __switchIndex__ = 2;
                            continue;
                        };
                        break;
                    } else {
                        _r.unreadByte();
                        return { _0 : (0i64 : GoInt64), _1 : (10 : GoInt), _2 : (null : Error) };
                        break;
                    };
                };
                break;
            };
        };
        var _digits:Slice<GoByte> = (null : Slice<GoUInt8>);
        {
            var __tmp__ = _r.readByte();
            _ch = __tmp__._0;
            _err = __tmp__._1;
        };
        if ((_err == null) && ((_ch == (43 : GoUInt8)) || (_ch == (45 : GoUInt8)))) {
            if (_ch == ((45 : GoUInt8))) {
                _digits = _digits.__appendref__((45 : GoUInt8));
            };
            {
                var __tmp__ = _r.readByte();
                _ch = __tmp__._0;
                _err = __tmp__._1;
            };
        };
        var _prev:GoInt32 = (46 : GoInt32);
        var _invalSep:Bool = false;
        var _hasDigits:Bool = false;
        while (_err == null) {
            if (((48 : GoUInt8) <= _ch) && (_ch <= (57 : GoUInt8))) {
                _digits = _digits.__appendref__(_ch);
                _prev = (48 : GoInt32);
                _hasDigits = true;
            } else if ((_ch == (95 : GoUInt8)) && _sepOk) {
                if (_prev != ((48 : GoInt32))) {
                    _invalSep = true;
                };
                _prev = (95 : GoInt32);
            } else {
                _r.unreadByte();
                break;
            };
            {
                var __tmp__ = _r.readByte();
                _ch = __tmp__._0;
                _err = __tmp__._1;
            };
        };
        if (Go.toInterface(_err) == (Go.toInterface(stdgo.io.Io.eof))) {
            _err = (null : Error);
        };
        if ((_err == null) && !_hasDigits) {
            _err = _errNoDigits;
        };
        if (_err == null) {
            {
                var __tmp__ = stdgo.strconv.Strconv.parseInt((_digits : GoString), (10 : GoInt), (64 : GoInt));
                _exp = __tmp__._0;
                _err = __tmp__._1;
            };
        };
        if ((_err == null) && (_invalSep || (_prev == (95 : GoInt32)))) {
            _err = _errInvalSep;
        };
        return { _0 : _exp, _1 : _base, _2 : _err };
    }
function testScanExponent(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _a in _exponentTests) {
            var _r = stdgo.strings.Strings.newReader(_a._s);
            var __tmp__ = _scanExponent(Go.asInterface(_r), _a._base2ok, _a._sepOk), _x:GoInt64 = __tmp__._0, _b:GoInt = __tmp__._1, _err:Error = __tmp__._2;
            if (Go.toInterface(_err) != (Go.toInterface(_a._err))) {
                _t.errorf(("scanExponent%+v\n\tgot error = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_a)), Go.toInterface(_err), Go.toInterface(_a._err));
            };
            if (_x != (_a._x)) {
                _t.errorf(("scanExponent%+v\n\tgot z = %v; want %v" : GoString), Go.toInterface(Go.asInterface(_a)), Go.toInterface(_x), Go.toInterface(_a._x));
            };
            if (_b != (_a._b)) {
                _t.errorf(("scanExponent%+v\n\tgot b = %d; want %d" : GoString), Go.toInterface(Go.asInterface(_a)), Go.toInterface(_b), Go.toInterface(_a._b));
            };
            var __tmp__ = _r.readRune(), _next:GoInt32 = __tmp__._0, __1:GoInt = __tmp__._1, _err:Error = __tmp__._2;
            if (Go.toInterface(_err) == (Go.toInterface(stdgo.io.Io.eof))) {
                _next = (0 : GoInt32);
                _err = (null : Error);
            };
            if ((_err == null) && (_next != _a._next)) {
                _t.errorf(("scanExponent%+v\n\tgot next = %q; want %q" : GoString), Go.toInterface(Go.asInterface(_a)), Go.toInterface(_next), Go.toInterface(_a._next));
            };
        };
    }
function testRatSetString(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _tests:Slice<StringTest> = (null : Slice<stdgo.math.big.Big.StringTest>);
        _tests = _tests.__appendref__(..._setStringTests.__toArray__());
        _tests = _tests.__appendref__(..._setStringTests2.__toArray__());
        for (_i => _test in _tests) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setString(_test._in), _x:Ref<stdgo.math.big.Big.Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (_ok) {
                if (!_test._ok) {
                    _t.errorf(("#%d SetString(%q) expected failure" : GoString), Go.toInterface(_i), Go.toInterface(_test._in));
                } else if (_x.ratString() != (_test._out)) {
                    _t.errorf(("#%d SetString(%q) got %s want %s" : GoString), Go.toInterface(_i), Go.toInterface(_test._in), Go.toInterface(_x.ratString()), Go.toInterface(_test._out));
                };
            } else {
                if (_test._ok) {
                    _t.errorf(("#%d SetString(%q) expected success" : GoString), Go.toInterface(_i), Go.toInterface(_test._in));
                } else if (_x != null && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) {
                    _t.errorf(("#%d SetString(%q) got %p want nil" : GoString), Go.toInterface(_i), Go.toInterface(_test._in), Go.toInterface(Go.asInterface(_x)));
                };
            };
        };
    }
function testRatSetStringZero(_t:Ref<stdgo.testing.Testing.T>):Void {
        var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setString(("0" : GoString)), _got:Ref<stdgo.math.big.Big.Rat> = __tmp__._0, __0:Bool = __tmp__._1;
        var _want = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setInt64((0i64 : GoInt64));
        if (!stdgo.reflect.Reflect.deepEqual(Go.toInterface(Go.asInterface(_got)), Go.toInterface(Go.asInterface(_want)))) {
            _t.errorf(("got %#+v, want %#+v" : GoString), Go.toInterface(Go.asInterface(_got)), Go.toInterface(Go.asInterface(_want)));
        };
    }
function testRatScan(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _buf:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        for (_i => _test in _setStringTests) {
            var _x = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>);
            _buf.reset();
            _buf.writeString(_test._in);
            var __tmp__ = stdgo.fmt.Fmt.fscanf(Go.asInterface((Go.setRef(_buf) : Ref<stdgo.bytes.Bytes.Buffer>)), ("%v" : GoString), Go.toInterface(Go.asInterface(_x))), __0:GoInt = __tmp__._0, _err:Error = __tmp__._1;
            if (_err == null != (_test._ok)) {
                if (_test._ok) {
                    _t.errorf(("#%d (%s) error: %s" : GoString), Go.toInterface(_i), Go.toInterface(_test._in), Go.toInterface(_err));
                } else {
                    _t.errorf(("#%d (%s) expected error" : GoString), Go.toInterface(_i), Go.toInterface(_test._in));
                };
                continue;
            };
            if ((_err == null) && (_x.ratString() != _test._out)) {
                _t.errorf(("#%d got %s want %s" : GoString), Go.toInterface(_i), Go.toInterface(_x.ratString()), Go.toInterface(_test._out));
            };
        };
    }
function testFloatString(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (_i => _test in _floatStringTests) {
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setString(_test._in), _x:Ref<stdgo.math.big.Big.Rat> = __tmp__._0, __0:Bool = __tmp__._1;
            if (_x.floatString(_test._prec) != (_test._out)) {
                _t.errorf(("#%d got %s want %s" : GoString), Go.toInterface(_i), Go.toInterface(_x.floatString(_test._prec)), Go.toInterface(_test._out));
            };
        };
    }
/**
    // isFinite reports whether f represents a finite rational value.
    // It is equivalent to !math.IsNan(f) && !math.IsInf(f, 0).
**/
private function _isFinite(_f:GoFloat64):Bool {
        return stdgo.math.Math.abs(_f) <= (1.7976931348623157e+308 : GoFloat64);
    }
function testFloat32SpecialCases(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _input in _float64inputs) {
            if (stdgo.strings.Strings.hasPrefix(_input, ("long:" : GoString))) {
                if (!_long.value) {
                    continue;
                };
                _input = (_input.__slice__((("long:" : GoString).length)) : GoString);
            };
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setString(_input), _r:Ref<stdgo.math.big.Big.Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _t.errorf(("Rat.SetString(%q) failed" : GoString), Go.toInterface(_input));
                continue;
            };
            var __tmp__ = _r.float32(), _f:GoFloat32 = __tmp__._0, _exact:Bool = __tmp__._1;
            if (!stdgo.strings.Strings.contains(_input, ("/" : GoString))) {
                var __tmp__ = stdgo.strconv.Strconv.parseFloat(_input, (32 : GoInt)), _e64:GoFloat64 = __tmp__._0, __1:Error = __tmp__._1;
                var _e:GoFloat32 = (_e64 : GoFloat32);
                if (stdgo.math.Math.float32bits(_e) == (stdgo.math.Math.float32bits(_f))) {} else if ((_f == (0 : GoFloat64)) && (_r.num().bitLen() == (0 : GoInt))) {} else {
                    _t.errorf(("strconv.ParseFloat(%q) = %g (%b), want %g (%b); delta = %g" : GoString), Go.toInterface(_input), Go.toInterface(_e), Go.toInterface(_e), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(_f - _e));
                };
            };
            if (!_isFinite((_f : GoFloat64))) {
                continue;
            };
            if (!_checkIsBestApprox32(_t, _f, _r)) {
                _t.errorf(("(input was %q)" : GoString), Go.toInterface(_input));
            };
            _checkNonLossyRoundtrip32(_t, _f);
            {
                var _wasExact:Bool = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setFloat64((_f : GoFloat64)).cmp(_r) == ((0 : GoInt));
                if (_wasExact != (_exact)) {
                    _t.errorf(("Rat.SetString(%q).Float32().exact = %t, want %t" : GoString), Go.toInterface(_input), Go.toInterface(_exact), Go.toInterface(_wasExact));
                };
            };
        };
    }
function testFloat64SpecialCases(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _input in _float64inputs) {
            if (stdgo.strings.Strings.hasPrefix(_input, ("long:" : GoString))) {
                if (!_long.value) {
                    continue;
                };
                _input = (_input.__slice__((("long:" : GoString).length)) : GoString);
            };
            var __tmp__ = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setString(_input), _r:Ref<stdgo.math.big.Big.Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _t.errorf(("Rat.SetString(%q) failed" : GoString), Go.toInterface(_input));
                continue;
            };
            var __tmp__ = _r.float64(), _f:GoFloat64 = __tmp__._0, _exact:Bool = __tmp__._1;
            if (!stdgo.strings.Strings.contains(_input, ("/" : GoString))) {
                var __tmp__ = stdgo.strconv.Strconv.parseFloat(_input, (64 : GoInt)), _e:GoFloat64 = __tmp__._0, __1:Error = __tmp__._1;
                if (stdgo.math.Math.float64bits(_e) == (stdgo.math.Math.float64bits(_f))) {} else if ((_f == (0 : GoFloat64)) && (_r.num().bitLen() == (0 : GoInt))) {} else {
                    _t.errorf(("strconv.ParseFloat(%q) = %g (%b), want %g (%b); delta = %g" : GoString), Go.toInterface(_input), Go.toInterface(_e), Go.toInterface(_e), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(_f - _e));
                };
            };
            if (!_isFinite(_f)) {
                continue;
            };
            if (!_checkIsBestApprox64(_t, _f, _r)) {
                _t.errorf(("(input was %q)" : GoString), Go.toInterface(_input));
            };
            _checkNonLossyRoundtrip64(_t, _f);
            {
                var _wasExact:Bool = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).setFloat64(_f).cmp(_r) == ((0 : GoInt));
                if (_wasExact != (_exact)) {
                    _t.errorf(("Rat.SetString(%q).Float64().exact = %t, want %t" : GoString), Go.toInterface(_input), Go.toInterface(_exact), Go.toInterface(_wasExact));
                };
            };
        };
    }
function testIssue31184(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _x:Rat = ({} : stdgo.math.big.Big.Rat);
        for (__0 => _want in (new Slice<GoString>(0, 0, ("-213.090" : GoString), ("8.192" : GoString), ("16.000" : GoString)) : Slice<GoString>)) {
            _x.setString(_want);
            var _got:GoString = _x.floatString((3 : GoInt));
            if (_got != (_want)) {
                _t.errorf(("got %s, want %s" : GoString), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function testIssue45910(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _x:Rat = ({} : stdgo.math.big.Big.Rat);
        for (__0 => _test in (new Slice<T__struct_63>(
0,
0,
({ _input : ("1e-1000001" : GoString), _want : false } : T__struct_63),
({ _input : ("1e-1000000" : GoString), _want : true } : T__struct_63),
({ _input : ("1e+1000000" : GoString), _want : true } : T__struct_63),
({ _input : ("1e+1000001" : GoString), _want : false } : T__struct_63),
({ _input : ("0p1000000000000" : GoString), _want : true } : T__struct_63),
({ _input : ("1p-10000001" : GoString), _want : false } : T__struct_63),
({ _input : ("1p-10000000" : GoString), _want : true } : T__struct_63),
({ _input : ("1p+10000000" : GoString), _want : true } : T__struct_63),
({ _input : ("1p+10000001" : GoString), _want : false } : T__struct_63),
({ _input : ("1.770p02041010010011001001" : GoString), _want : false } : T__struct_63)) : Slice<T__struct_63>)) {
            var __tmp__ = _x.setString(_test._input), __1:Ref<stdgo.math.big.Big.Rat> = __tmp__._0, _got:Bool = __tmp__._1;
            if (_got != (_test._want)) {
                _t.errorf(("SetString(%s) got ok = %v; want %v" : GoString), Go.toInterface(_test._input), Go.toInterface(_got), Go.toInterface(_test._want));
            };
        };
    }
function testRatGobEncoding(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _medium:stdgo.bytes.Bytes.Buffer = ({} : stdgo.bytes.Bytes.Buffer);
        var _enc = stdgo.encoding.gob.Gob.newEncoder(Go.asInterface((Go.setRef(_medium) : Ref<stdgo.bytes.Bytes.Buffer>)));
        var _dec = stdgo.encoding.gob.Gob.newDecoder(Go.asInterface((Go.setRef(_medium) : Ref<stdgo.bytes.Bytes.Buffer>)));
        for (__0 => _test in _encodingTests) {
            _medium.reset();
            var _tx:Rat = ({} : stdgo.math.big.Big.Rat);
            _tx.setString(_test + (".14159265" : GoString));
            {
                var _err:Error = _enc.encode(Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Rat>))));
                if (_err != null) {
                    _t.errorf(("encoding of %s failed: %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Rat>))), Go.toInterface(_err));
                    continue;
                };
            };
            var _rx:Rat = ({} : stdgo.math.big.Big.Rat);
            {
                var _err:Error = _dec.decode(Go.toInterface(Go.asInterface((Go.setRef(_rx) : Ref<stdgo.math.big.Big.Rat>))));
                if (_err != null) {
                    _t.errorf(("decoding of %s failed: %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Rat>))), Go.toInterface(_err));
                    continue;
                };
            };
            if (_rx.cmp((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Rat>)) != ((0 : GoInt))) {
                _t.errorf(("transmission of %s failed: got %s want %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Rat>))), Go.toInterface(Go.asInterface((Go.setRef(_rx) : Ref<stdgo.math.big.Big.Rat>))), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Rat>))));
            };
        };
    }
/**
    // Sending a nil Rat pointer (inside a slice) on a round trip through gob should yield a zero.
    // TODO: top-level nils.
**/
function testGobEncodingNilRatInSlice(_t:Ref<stdgo.testing.Testing.T>):Void {
        var _buf = (Go.setRef(({} : stdgo.bytes.Bytes.Buffer)) : Ref<stdgo.bytes.Bytes.Buffer>);
        var _enc = stdgo.encoding.gob.Gob.newEncoder(Go.asInterface(_buf));
        var _dec = stdgo.encoding.gob.Gob.newDecoder(Go.asInterface(_buf));
        var _in:Slice<Ref<stdgo.math.big.Big.Rat>> = new Slice<Ref<stdgo.math.big.Big.Rat>>((1 : GoInt).toBasic(), 0, ...[for (i in 0 ... (1 : GoInt).toBasic()) (null : Ref<stdgo.math.big.Big.Rat>)]);
        var _err:Error = _enc.encode(Go.toInterface((Go.setRef(_in) : Ref<Slice<Ref<stdgo.math.big.Big.Rat>>>)));
        if (_err != null) {
            _t.errorf(("gob encode failed: %q" : GoString), Go.toInterface(_err));
        };
        var _out:Slice<Ref<Rat>> = (null : Slice<Ref<stdgo.math.big.Big.Rat>>);
        _err = _dec.decode(Go.toInterface((Go.setRef(_out) : Ref<Slice<Ref<stdgo.math.big.Big.Rat>>>)));
        if (_err != null) {
            _t.fatalf(("gob decode failed: %q" : GoString), Go.toInterface(_err));
        };
        if ((_out.length) != ((1 : GoInt))) {
            _t.fatalf(("wrong len; want 1 got %d" : GoString), Go.toInterface((_out.length)));
        };
        var _zero:Rat = ({} : stdgo.math.big.Big.Rat);
        if (_out[(0 : GoInt)].cmp((Go.setRef(_zero) : Ref<stdgo.math.big.Big.Rat>)) != ((0 : GoInt))) {
            _t.fatalf(("transmission of (*Int)(nil) failed: got %s want 0" : GoString), Go.toInterface(_out));
        };
    }
function testRatJSONEncoding(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _num in _ratNums) {
            for (__1 => _denom in _ratDenoms) {
                var _tx:Rat = ({} : stdgo.math.big.Big.Rat);
                _tx.setString((_num + ("/" : GoString)) + _denom);
                var __tmp__ = stdgo.encoding.json.Json.marshal(Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Rat>)))), _b:Slice<GoUInt8> = __tmp__._0, _err:Error = __tmp__._1;
                if (_err != null) {
                    _t.errorf(("marshaling of %s failed: %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Rat>))), Go.toInterface(_err));
                    continue;
                };
                var _rx:Rat = ({} : stdgo.math.big.Big.Rat);
                {
                    var _err:Error = stdgo.encoding.json.Json.unmarshal(_b, Go.toInterface(Go.asInterface((Go.setRef(_rx) : Ref<stdgo.math.big.Big.Rat>))));
                    if (_err != null) {
                        _t.errorf(("unmarshaling of %s failed: %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Rat>))), Go.toInterface(_err));
                        continue;
                    };
                };
                if (_rx.cmp((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Rat>)) != ((0 : GoInt))) {
                    _t.errorf(("JSON encoding of %s failed: got %s want %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Rat>))), Go.toInterface(Go.asInterface((Go.setRef(_rx) : Ref<stdgo.math.big.Big.Rat>))), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Rat>))));
                };
            };
        };
    }
function testRatXMLEncoding(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _num in _ratNums) {
            for (__1 => _denom in _ratDenoms) {
                var _tx:Rat = ({} : stdgo.math.big.Big.Rat);
                _tx.setString((_num + ("/" : GoString)) + _denom);
                var __tmp__ = stdgo.encoding.xml.Xml_.marshal(Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Rat>)))), _b:Slice<GoUInt8> = __tmp__._0, _err:Error = __tmp__._1;
                if (_err != null) {
                    _t.errorf(("marshaling of %s failed: %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Rat>))), Go.toInterface(_err));
                    continue;
                };
                var _rx:Rat = ({} : stdgo.math.big.Big.Rat);
                {
                    var _err:Error = stdgo.encoding.xml.Xml_.unmarshal(_b, Go.toInterface(Go.asInterface((Go.setRef(_rx) : Ref<stdgo.math.big.Big.Rat>))));
                    if (_err != null) {
                        _t.errorf(("unmarshaling of %s failed: %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Rat>))), Go.toInterface(_err));
                        continue;
                    };
                };
                if (_rx.cmp((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Rat>)) != ((0 : GoInt))) {
                    _t.errorf(("XML encoding of %s failed: got %s want %s" : GoString), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Rat>))), Go.toInterface(Go.asInterface((Go.setRef(_rx) : Ref<stdgo.math.big.Big.Rat>))), Go.toInterface(Go.asInterface((Go.setRef(_tx) : Ref<stdgo.math.big.Big.Rat>))));
                };
            };
        };
    }
function testRatGobDecodeShortBuffer(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _tc in (new Slice<Slice<GoUInt8>>(0, 0, (new Slice<GoUInt8>(0, 0, (2 : GoUInt8)) : Slice<GoUInt8>), (new Slice<GoUInt8>(0, 0, (2 : GoUInt8), (0 : GoUInt8), (0 : GoUInt8), (0 : GoUInt8), (255 : GoUInt8)) : Slice<GoUInt8>), (new Slice<GoUInt8>(0, 0, (2 : GoUInt8), (255 : GoUInt8), (255 : GoUInt8), (255 : GoUInt8), (255 : GoUInt8)) : Slice<GoUInt8>)) : Slice<Slice<GoUInt8>>)) {
            var _err:Error = newRat((1i64 : GoInt64), (2i64 : GoInt64)).gobDecode(_tc);
            if (_err == null) {
                _t.error(Go.toInterface(("expected GobDecode to return error for malformed input" : GoString)));
            };
        };
    }
private function _three():Ref<Float_> {
        _threeOnce.do_(function():Void {
            _threeOnce._v = newFloat((3 : GoFloat64));
        });
        return _threeOnce._v;
    }
/**
    // newFloat returns a new *Float with space for twice the given
    // precision.
**/
private function _newFloat(_prec2:GoUInt32):Ref<Float_> {
        var _z = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>);
        _z._mant = _z._mant._make((_prec2 / (32u32 : GoUInt32) : GoInt) * (2 : GoInt));
        return _z;
    }
/**
    // TestFloatSqrt64 tests that Float.Sqrt of numbers with 53bit mantissa
    // behaves like float math.Sqrt.
**/
function testFloatSqrt64(_t:Ref<stdgo.testing.Testing.T>):Void {
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < (100000 : GoInt), _i++, {
                if ((_i == (100 : GoInt)) && stdgo.testing.Testing.short()) {
                    break;
                };
                var _r:GoFloat64 = stdgo.math.rand.Rand.float64();
                var _got = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec((53u32 : GoUInt));
                _got.sqrt(newFloat(_r));
                var _want = newFloat(stdgo.math.Math.sqrt(_r));
                if (_got.cmp(_want) != ((0 : GoInt))) {
                    _t.fatalf(("Sqrt(%g) =\n got %g;\nwant %g" : GoString), Go.toInterface(_r), Go.toInterface(Go.asInterface(_got)), Go.toInterface(Go.asInterface(_want)));
                };
            });
        };
    }
function testFloatSqrt(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_65>(
0,
0,
({ _x : ("0.03125" : GoString), _want : ("0.17677669529663688110021109052621225982120898442211850914708496724884155980776337985629844179095519659187673077886403712811560450698134215158051518713749197892665283324093819909447499381264409775757143376369499645074628431682460775184106467733011114982619404115381053858929018135497032545349940642599871090667456829147610370507757690729404938184321879" : GoString) } : T__struct_65),
({ _x : ("0.125" : GoString), _want : ("0.35355339059327376220042218105242451964241796884423701829416993449768311961552675971259688358191039318375346155772807425623120901396268430316103037427498395785330566648187639818894998762528819551514286752738999290149256863364921550368212935466022229965238808230762107717858036270994065090699881285199742181334913658295220741015515381458809876368643757" : GoString) } : T__struct_65),
({ _x : ("0.5" : GoString), _want : ("0.70710678118654752440084436210484903928483593768847403658833986899536623923105351942519376716382078636750692311545614851246241802792536860632206074854996791570661133296375279637789997525057639103028573505477998580298513726729843100736425870932044459930477616461524215435716072541988130181399762570399484362669827316590441482031030762917619752737287514" : GoString) } : T__struct_65),
({ _x : ("2.0" : GoString), _want : ("1.4142135623730950488016887242096980785696718753769480731766797379907324784621070388503875343276415727350138462309122970249248360558507372126441214970999358314132226659275055927557999505011527820605714701095599716059702745345968620147285174186408891986095523292304843087143214508397626036279952514079896872533965463318088296406206152583523950547457503" : GoString) } : T__struct_65),
({ _x : ("3.0" : GoString), _want : ("1.7320508075688772935274463415058723669428052538103806280558069794519330169088000370811461867572485756756261414154067030299699450949989524788116555120943736485280932319023055820679748201010846749232650153123432669033228866506722546689218379712270471316603678615880190499865373798593894676503475065760507566183481296061009476021871903250831458295239598" : GoString) } : T__struct_65),
({ _x : ("4.0" : GoString), _want : ("2.0" : GoString) } : T__struct_65),
({ _x : ("1p512" : GoString), _want : ("1p256" : GoString) } : T__struct_65),
({ _x : ("4p1024" : GoString), _want : ("2p512" : GoString) } : T__struct_65),
({ _x : ("9p2048" : GoString), _want : ("3p1024" : GoString) } : T__struct_65),
({ _x : ("1p-1024" : GoString), _want : ("1p-512" : GoString) } : T__struct_65),
({ _x : ("4p-2048" : GoString), _want : ("2p-1024" : GoString) } : T__struct_65),
({ _x : ("9p-4096" : GoString), _want : ("3p-2048" : GoString) } : T__struct_65)) : Slice<T__struct_65>)) {
            for (__1 => _prec in (new Slice<GoUInt>(
0,
0,
(24u32 : GoUInt),
(53u32 : GoUInt),
(64u32 : GoUInt),
(65u32 : GoUInt),
(100u32 : GoUInt),
(128u32 : GoUInt),
(129u32 : GoUInt),
(200u32 : GoUInt),
(256u32 : GoUInt),
(400u32 : GoUInt),
(600u32 : GoUInt),
(800u32 : GoUInt),
(1000u32 : GoUInt)) : Slice<GoUInt>)) {
                var _x = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_prec);
                _x.parse(_test._x, (10 : GoInt));
                var _got = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_prec).sqrt(_x);
                var _want = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_prec);
                _want.parse(_test._want, (10 : GoInt));
                if (_got.cmp(_want) != ((0 : GoInt))) {
                    _t.errorf(("prec = %d, Sqrt(%v) =\ngot  %g;\nwant %g" : GoString), Go.toInterface(_prec), Go.toInterface(_test._x), Go.toInterface(Go.asInterface(_got)), Go.toInterface(Go.asInterface(_want)));
                };
                var _sq = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_prec + (32u32 : GoUInt)).mul(_got, _got);
                var _diff = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).sub(_sq, _x);
                var _err = _diff.abs(_diff).setPrec(_prec);
                var _one = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_prec).setInt64((1i64 : GoInt64));
                var _maxErr = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).mul((Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setMantExp(_one, -(_prec : GoInt) + (1 : GoInt)), _got);
                if (_err.cmp(_maxErr) >= (0 : GoInt)) {
                    _t.errorf(("prec = %d, Sqrt(%v) =\ngot err  %g;\nwant maxErr %g" : GoString), Go.toInterface(_prec), Go.toInterface(_test._x), Go.toInterface(Go.asInterface(_err)), Go.toInterface(Go.asInterface(_maxErr)));
                };
            };
        };
    }
function testFloatSqrtSpecial(_t:Ref<stdgo.testing.Testing.T>):Void {
        for (__0 => _test in (new Slice<T__struct_66>(0, 0, ({ _x : newFloat((0 : GoFloat64)), _want : newFloat((0 : GoFloat64)) } : T__struct_66), ({ _x : newFloat((0 : GoFloat64)), _want : newFloat((0 : GoFloat64)) } : T__struct_66), ({ _x : newFloat(stdgo.math.Math.inf((1 : GoInt))), _want : newFloat(stdgo.math.Math.inf((1 : GoInt))) } : T__struct_66)) : Slice<T__struct_66>)) {
            var _got = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).sqrt(_test._x);
            if ((_got._neg != _test._want._neg) || (_got._form != _test._want._form)) {
                _t.errorf(("Sqrt(%v) = %v (neg: %v); want %v (neg: %v)" : GoString), Go.toInterface(Go.asInterface(_test._x)), Go.toInterface(Go.asInterface(_got)), Go.toInterface(_got._neg), Go.toInterface(Go.asInterface(_test._want)), Go.toInterface(_test._want._neg));
            };
        };
    }
function benchmarkFloatSqrt(_b:Ref<stdgo.testing.Testing.B>):Void {
        for (__0 => _prec in (new Slice<GoUInt>(0, 0, (64u32 : GoUInt), (128u32 : GoUInt), (256u32 : GoUInt), (1000u32 : GoUInt), (10000u32 : GoUInt), (100000u32 : GoUInt), (1000000u32 : GoUInt)) : Slice<GoUInt>)) {
            var _x = newFloat((2 : GoFloat64));
            var _z = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_prec);
            _b.run(stdgo.fmt.Fmt.sprintf(("%v" : GoString), Go.toInterface(_prec)), function(_b:Ref<stdgo.testing.Testing.B>):Void {
                _b.reportAllocs();
                {
                    var _n:GoInt = (0 : GoInt);
                    Go.cfor(_n < _b.n, _n++, {
                        _z.sqrt(_x);
                    });
                };
            });
        };
    }
class T_decimal_asInterface {
    @:keep
    public dynamic function _roundDown(_n:GoInt):Void __self__.value._roundDown(_n);
    @:keep
    public dynamic function _roundUp(_n:GoInt):Void __self__.value._roundUp(_n);
    /**
        // round sets x to (at most) n mantissa digits by rounding it
        // to the nearest even value with n (or fever) mantissa digits.
        // If n < 0, x remains unchanged.
    **/
    @:keep
    public dynamic function _round(_n:GoInt):Void __self__.value._round(_n);
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    /**
        // Init initializes x to the decimal representation of m << shift (for
        // shift >= 0), or m >> -shift (for shift < 0).
    **/
    @:keep
    public dynamic function _init(_m:T_nat, _shift:GoInt):Void __self__.value._init(_m, _shift);
    /**
        // at returns the i'th mantissa digit, starting with the most significant digit at 0.
    **/
    @:keep
    public dynamic function _at(_i:GoInt):GoByte return __self__.value._at(_i);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_decimal>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T_decimal_asInterface) class T_decimal_static_extension {
    @:keep
    static public function _roundDown( _x:Ref<T_decimal>, _n:GoInt):Void {
        if ((_n < (0 : GoInt)) || (_n >= _x._mant.length)) {
            return;
        };
        _x._mant = (_x._mant.__slice__(0, _n) : Slice<GoUInt8>);
        _trim(_x);
    }
    @:keep
    static public function _roundUp( _x:Ref<T_decimal>, _n:GoInt):Void {
        if ((_n < (0 : GoInt)) || (_n >= _x._mant.length)) {
            return;
        };
        while ((_n > (0 : GoInt)) && (_x._mant[(_n - (1 : GoInt) : GoInt)] >= (57 : GoUInt8))) {
            _n--;
        };
        if (_n == ((0 : GoInt))) {
            _x._mant[(0 : GoInt)] = (49 : GoUInt8);
            _x._mant = (_x._mant.__slice__(0, (1 : GoInt)) : Slice<GoUInt8>);
            _x._exp++;
            return;
        };
        _x._mant[(_n - (1 : GoInt) : GoInt)]++;
        _x._mant = (_x._mant.__slice__(0, _n) : Slice<GoUInt8>);
    }
    /**
        // round sets x to (at most) n mantissa digits by rounding it
        // to the nearest even value with n (or fever) mantissa digits.
        // If n < 0, x remains unchanged.
    **/
    @:keep
    static public function _round( _x:Ref<T_decimal>, _n:GoInt):Void {
        if ((_n < (0 : GoInt)) || (_n >= _x._mant.length)) {
            return;
        };
        if (_shouldRoundUp(_x, _n)) {
            _x._roundUp(_n);
        } else {
            _x._roundDown(_n);
        };
    }
    @:keep
    static public function string( _x:Ref<T_decimal>):GoString {
        if ((_x._mant.length) == ((0 : GoInt))) {
            return ("0" : GoString);
        };
        var _buf:Slice<GoByte> = (null : Slice<GoUInt8>);
        if (_x._exp <= (0 : GoInt)) {
            _buf = new Slice<GoUInt8>((0 : GoInt).toBasic(), ((2 : GoInt) + -_x._exp) + (_x._mant.length), ...[for (i in 0 ... (0 : GoInt).toBasic()) (0 : GoUInt8)]);
            _buf = _buf.__appendref__(...("0." : GoString).__toArray__());
            _buf = _appendZeros(_buf, -_x._exp);
            _buf = _buf.__appendref__(..._x._mant.__toArray__());
        } else if (_x._exp < (_x._mant.length)) {
            _buf = new Slice<GoUInt8>((0 : GoInt).toBasic(), (1 : GoInt) + (_x._mant.length), ...[for (i in 0 ... (0 : GoInt).toBasic()) (0 : GoUInt8)]);
            _buf = _buf.__appendref__(...(_x._mant.__slice__(0, _x._exp) : Slice<GoUInt8>).__toArray__());
            _buf = _buf.__appendref__((46 : GoUInt8));
            _buf = _buf.__appendref__(...(_x._mant.__slice__(_x._exp) : Slice<GoUInt8>).__toArray__());
        } else {
            _buf = new Slice<GoUInt8>((0 : GoInt).toBasic(), _x._exp, ...[for (i in 0 ... (0 : GoInt).toBasic()) (0 : GoUInt8)]);
            _buf = _buf.__appendref__(..._x._mant.__toArray__());
            _buf = _appendZeros(_buf, _x._exp - (_x._mant.length));
        };
        return (_buf : GoString);
    }
    /**
        // Init initializes x to the decimal representation of m << shift (for
        // shift >= 0), or m >> -shift (for shift < 0).
    **/
    @:keep
    static public function _init( _x:Ref<T_decimal>, _m:T_nat, _shift:GoInt):Void {
        if ((_m.length) == ((0 : GoInt))) {
            _x._mant = (_x._mant.__slice__(0, (0 : GoInt)) : Slice<GoUInt8>);
            _x._exp = (0 : GoInt);
            return;
        };
        if (_shift < (0 : GoInt)) {
            var _ntz:GoUInt = _m._trailingZeroBits();
            var _s:GoUInt = (-_shift : GoUInt);
            if (_s >= _ntz) {
                _s = _ntz;
            };
            _m = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._shr(_m, _s);
            _shift = _shift + ((_s : GoInt));
        };
        if (_shift > (0 : GoInt)) {
            _m = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._shl(_m, (_shift : GoUInt));
            _shift = (0 : GoInt);
        };
        var _s = _m._utoa((10 : GoInt));
        var _n:GoInt = (_s.length);
        _x._exp = _n;
        while ((_n > (0 : GoInt)) && (_s[(_n - (1 : GoInt) : GoInt)] == (48 : GoUInt8))) {
            _n--;
        };
        _x._mant = ((_x._mant.__slice__(0, (0 : GoInt)) : Slice<GoUInt8>).__append__(...(_s.__slice__(0, _n) : Slice<GoUInt8>).__toArray__()));
        if (_shift < (0 : GoInt)) {
            while (_shift < (-28 : GoInt)) {
                _shr(_x, (28u32 : GoUInt));
                _shift = _shift + ((28 : GoInt));
            };
            _shr(_x, (-_shift : GoUInt));
        };
    }
    /**
        // at returns the i'th mantissa digit, starting with the most significant digit at 0.
    **/
    @:keep
    static public function _at( _d:Ref<T_decimal>, _i:GoInt):GoByte {
        if (((0 : GoInt) <= _i) && (_i < _d._mant.length)) {
            return _d._mant[(_i : GoInt)];
        };
        return (48 : GoUInt8);
    }
}
class Float__asInterface {
    /**
        // Compute x (to z.prec precision) by solving
        //
        //	1/t - x = 0
        //
        // for t (using Newton's method), and then inverting.
    **/
    @:keep
    public dynamic function _sqrtInverse(_x:Ref<Float_>):Void __self__.value._sqrtInverse(_x);
    /**
        // Sqrt sets z to the rounded square root of x, and returns it.
        //
        // If z's precision is 0, it is changed to x's precision before the
        // operation. Rounding is performed according to z's precision and
        // rounding mode, but z's accuracy is not computed. Specifically, the
        // result of z.Acc() is undefined.
        //
        // The function panics if z < 0. The value of z is undefined in that
        // case.
    **/
    @:keep
    public dynamic function sqrt(_x:Ref<Float_>):Ref<Float_> return __self__.value.sqrt(_x);
    /**
        // Format implements fmt.Formatter. It accepts all the regular
        // formats for floating-point numbers ('b', 'e', 'E', 'f', 'F',
        // 'g', 'G', 'x') as well as 'p' and 'v'. See (*Float).Text for the
        // interpretation of 'p'. The 'v' format is handled like 'g'.
        // Format also supports specification of the minimum precision
        // in digits, the output field width, as well as the format flags
        // '+' and ' ' for sign control, '0' for space or zero padding,
        // and '-' for left or right justification. See the fmt package
        // for details.
    **/
    @:keep
    public dynamic function format(_s:stdgo.fmt.Fmt.State, _format:GoRune):Void __self__.value.format(_s, _format);
    /**
        // fmtP appends the string of x in the format "0x." mantissa "p" exponent
        // with a hexadecimal mantissa and a binary exponent, or "0" if x is zero,
        // and returns the extended buffer.
        // The mantissa is normalized such that 0.5 <= 0.mantissa < 1.0.
        // The sign of x is ignored, and x must not be an Inf.
        // (The caller handles Inf before invoking fmtP.)
    **/
    @:keep
    public dynamic function _fmtP(_buf:Slice<GoByte>):Slice<GoByte> return __self__.value._fmtP(_buf);
    /**
        // fmtX appends the string of x in the format "0x1." mantissa "p" exponent
        // with a hexadecimal mantissa and a binary exponent, or "0x0p0" if x is zero,
        // and returns the extended buffer.
        // A non-zero mantissa is normalized such that 1.0 <= mantissa < 2.0.
        // The sign of x is ignored, and x must not be an Inf.
        // (The caller handles Inf before invoking fmtX.)
    **/
    @:keep
    public dynamic function _fmtX(_buf:Slice<GoByte>, _prec:GoInt):Slice<GoByte> return __self__.value._fmtX(_buf, _prec);
    /**
        // fmtB appends the string of x in the format mantissa "p" exponent
        // with a decimal mantissa and a binary exponent, or 0" if x is zero,
        // and returns the extended buffer.
        // The mantissa is normalized such that is uses x.Prec() bits in binary
        // representation.
        // The sign of x is ignored, and x must not be an Inf.
        // (The caller handles Inf before invoking fmtB.)
    **/
    @:keep
    public dynamic function _fmtB(_buf:Slice<GoByte>):Slice<GoByte> return __self__.value._fmtB(_buf);
    /**
        // Append appends to buf the string form of the floating-point number x,
        // as generated by x.Text, and returns the extended buffer.
    **/
    @:keep
    public dynamic function append(_buf:Slice<GoByte>, _fmt:GoByte, _prec:GoInt):Slice<GoByte> return __self__.value.append(_buf, _fmt, _prec);
    /**
        // String formats x like x.Text('g', 10).
        // (String must be called explicitly, Float.Format does not support %s verb.)
    **/
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    /**
        // Text converts the floating-point number x to a string according
        // to the given format and precision prec. The format is one of:
        //
        //	'e'	-d.ddddedd, decimal exponent, at least two (possibly 0) exponent digits
        //	'E'	-d.ddddEdd, decimal exponent, at least two (possibly 0) exponent digits
        //	'f'	-ddddd.dddd, no exponent
        //	'g'	like 'e' for large exponents, like 'f' otherwise
        //	'G'	like 'E' for large exponents, like 'f' otherwise
        //	'x'	-0xd.dddddpdd, hexadecimal mantissa, decimal power of two exponent
        //	'p'	-0x.dddpdd, hexadecimal mantissa, decimal power of two exponent (non-standard)
        //	'b'	-ddddddpdd, decimal mantissa, decimal power of two exponent (non-standard)
        //
        // For the power-of-two exponent formats, the mantissa is printed in normalized form:
        //
        //	'x'	hexadecimal mantissa in [1, 2), or 0
        //	'p'	hexadecimal mantissa in [, 1), or 0
        //	'b'	decimal integer mantissa using x.Prec() bits, or 0
        //
        // Note that the 'x' form is the one used by most other languages and libraries.
        //
        // If format is a different character, Text returns a "%" followed by the
        // unrecognized format character.
        //
        // The precision prec controls the number of digits (excluding the exponent)
        // printed by the 'e', 'E', 'f', 'g', 'G', and 'x' formats.
        // For 'e', 'E', 'f', and 'x', it is the number of digits after the decimal point.
        // For 'g' and 'G' it is the total number of digits. A negative precision selects
        // the smallest number of decimal digits necessary to identify the value x uniquely
        // using x.Prec() mantissa bits.
        // The prec value is ignored for the 'b' and 'p' formats.
    **/
    @:keep
    public dynamic function text(_format:GoByte, _prec:GoInt):GoString return __self__.value.text(_format, _prec);
    /**
        // UnmarshalText implements the encoding.TextUnmarshaler interface.
        // The result is rounded per the precision and rounding mode of z.
        // If z's precision is 0, it is changed to 64 before rounding takes
        // effect.
    **/
    @:keep
    public dynamic function unmarshalText(_text:Slice<GoByte>):Error return __self__.value.unmarshalText(_text);
    /**
        // MarshalText implements the encoding.TextMarshaler interface.
        // Only the Float value is marshaled (in full precision), other
        // attributes such as precision or accuracy are ignored.
    **/
    @:keep
    public dynamic function marshalText():{ var _0 : Slice<GoByte>; var _1 : Error; } return __self__.value.marshalText();
    /**
        // GobDecode implements the gob.GobDecoder interface.
        // The result is rounded per the precision and rounding mode of
        // z unless z's precision is 0, in which case z is set exactly
        // to the decoded value.
    **/
    @:keep
    public dynamic function gobDecode(_buf:Slice<GoByte>):Error return __self__.value.gobDecode(_buf);
    /**
        // GobEncode implements the gob.GobEncoder interface.
        // The Float value and all its attributes (precision,
        // rounding mode, accuracy) are marshaled.
    **/
    @:keep
    public dynamic function gobEncode():{ var _0 : Slice<GoByte>; var _1 : Error; } return __self__.value.gobEncode();
    /**
        // Scan is a support routine for fmt.Scanner; it sets z to the value of
        // the scanned number. It accepts formats whose verbs are supported by
        // fmt.Scan for floating point values, which are:
        // 'b' (binary), 'e', 'E', 'f', 'F', 'g' and 'G'.
        // Scan doesn't handle Inf.
    **/
    @:keep
    public dynamic function scan(_s:stdgo.fmt.Fmt.ScanState, _ch:GoRune):Error return __self__.value.scan(_s, _ch);
    /**
        // Parse parses s which must contain a text representation of a floating-
        // point number with a mantissa in the given conversion base (the exponent
        // is always a decimal number), or a string representing an infinite value.
        //
        // For base 0, an underscore character _ may appear between a base
        // prefix and an adjacent digit, and between successive digits; such
        // underscores do not change the value of the number, or the returned
        // digit count. Incorrect placement of underscores is reported as an
        // error if there are no other errors. If base != 0, underscores are
        // not recognized and thus terminate scanning like any other character
        // that is not a valid radix point or digit.
        //
        // It sets z to the (possibly rounded) value of the corresponding floating-
        // point value, and returns z, the actual base b, and an error err, if any.
        // The entire string (not just a prefix) must be consumed for success.
        // If z's precision is 0, it is changed to 64 before rounding takes effect.
        // The number must be of the form:
        //
        //	number    = [ sign ] ( float | "inf" | "Inf" ) .
        //	sign      = "+" | "-" .
        //	float     = ( mantissa | prefix pmantissa ) [ exponent ] .
        //	prefix    = "0" [ "b" | "B" | "o" | "O" | "x" | "X" ] .
        //	mantissa  = digits "." [ digits ] | digits | "." digits .
        //	pmantissa = [ "_" ] digits "." [ digits ] | [ "_" ] digits | "." digits .
        //	exponent  = ( "e" | "E" | "p" | "P" ) [ sign ] digits .
        //	digits    = digit { [ "_" ] digit } .
        //	digit     = "0" ... "9" | "a" ... "z" | "A" ... "Z" .
        //
        // The base argument must be 0, 2, 8, 10, or 16. Providing an invalid base
        // argument will lead to a run-time panic.
        //
        // For base 0, the number prefix determines the actual base: A prefix of
        // 0b or 0B selects base 2, 0o or 0O selects base 8, and
        // 0x or 0X selects base 16. Otherwise, the actual base is 10 and
        // no prefix is accepted. The octal prefix "0" is not supported (a leading
        // "0" is simply considered a "0").
        //
        // A "p" or "P" exponent indicates a base 2 (rather then base 10) exponent;
        // for instance, "0x1.fffffffffffffp1023" (using base 0) represents the
        // maximum float64 value. For hexadecimal mantissae, the exponent character
        // must be one of 'p' or 'P', if present (an "e" or "E" exponent indicator
        // cannot be distinguished from a mantissa digit).
        //
        // The returned *Float f is nil and the value of z is valid but not
        // defined if an error is reported.
    **/
    @:keep
    public dynamic function parse(_s:GoString, _base:GoInt):{ var _0 : Ref<Float_>; var _1 : GoInt; var _2 : Error; } return __self__.value.parse(_s, _base);
    /**
        // pow5 sets z to 5**n and returns z.
        // n must not be negative.
    **/
    @:keep
    public dynamic function _pow5(_n:GoUInt64):Ref<Float_> return __self__.value._pow5(_n);
    /**
        // scan is like Parse but reads the longest possible prefix representing a valid
        // floating point number from an io.ByteScanner rather than a string. It serves
        // as the implementation of Parse. It does not recognize Inf and does not expect
        // EOF at the end.
    **/
    @:keep
    public dynamic function _scan(_r:stdgo.io.Io.ByteScanner, _base:GoInt):{ var _0 : Ref<Float_>; var _1 : GoInt; var _2 : Error; } return __self__.value._scan(_r, _base);
    /**
        // SetString sets z to the value of s and returns z and a boolean indicating
        // success. s must be a floating-point number of the same format as accepted
        // by Parse, with base argument 0. The entire string (not just a prefix) must
        // be valid for success. If the operation failed, the value of z is undefined
        // but the returned value is nil.
    **/
    @:keep
    public dynamic function setString(_s:GoString):{ var _0 : Ref<Float_>; var _1 : Bool; } return __self__.value.setString(_s);
    @:keep
    public dynamic function _int64():GoInt64 return __self__.value._int64();
    @:keep
    public dynamic function _uint64():GoUInt64 return __self__.value._uint64();
    /**
        // ord classifies x and returns:
        //
        //	-2 if -Inf == x
        //	-1 if -Inf < x < 0
        //	 0 if x == 0 (signed or unsigned)
        //	+1 if 0 < x < +Inf
        //	+2 if x == +Inf
    **/
    @:keep
    public dynamic function _ord():GoInt return __self__.value._ord();
    /**
        // Cmp compares x and y and returns:
        //
        //	-1 if x <  y
        //	 0 if x == y (incl. -0 == 0, -Inf == -Inf, and +Inf == +Inf)
        //	+1 if x >  y
    **/
    @:keep
    public dynamic function cmp(_y:Ref<Float_>):GoInt return __self__.value.cmp(_y);
    /**
        // Quo sets z to the rounded quotient x/y and returns z.
        // Precision, rounding, and accuracy reporting are as for Add.
        // Quo panics with ErrNaN if both operands are zero or infinities.
        // The value of z is undefined in that case.
    **/
    @:keep
    public dynamic function quo(_x:Ref<Float_>, _y:Ref<Float_>):Ref<Float_> return __self__.value.quo(_x, _y);
    /**
        // Mul sets z to the rounded product x*y and returns z.
        // Precision, rounding, and accuracy reporting are as for Add.
        // Mul panics with ErrNaN if one operand is zero and the other
        // operand an infinity. The value of z is undefined in that case.
    **/
    @:keep
    public dynamic function mul(_x:Ref<Float_>, _y:Ref<Float_>):Ref<Float_> return __self__.value.mul(_x, _y);
    /**
        // Sub sets z to the rounded difference x-y and returns z.
        // Precision, rounding, and accuracy reporting are as for Add.
        // Sub panics with ErrNaN if x and y are infinities with equal
        // signs. The value of z is undefined in that case.
    **/
    @:keep
    public dynamic function sub(_x:Ref<Float_>, _y:Ref<Float_>):Ref<Float_> return __self__.value.sub(_x, _y);
    /**
        // Add sets z to the rounded sum x+y and returns z. If z's precision is 0,
        // it is changed to the larger of x's or y's precision before the operation.
        // Rounding is performed according to z's precision and rounding mode; and
        // z's accuracy reports the result error relative to the exact (not rounded)
        // result. Add panics with ErrNaN if x and y are infinities with opposite
        // signs. The value of z is undefined in that case.
    **/
    @:keep
    public dynamic function add(_x:Ref<Float_>, _y:Ref<Float_>):Ref<Float_> return __self__.value.add(_x, _y);
    /**
        // ucmp returns -1, 0, or +1, depending on whether
        // |x| < |y|, |x| == |y|, or |x| > |y|.
        // x and y must have a non-empty mantissa and valid exponent.
    **/
    @:keep
    public dynamic function _ucmp(_y:Ref<Float_>):GoInt return __self__.value._ucmp(_y);
    /**
        // z = x / y, ignoring signs of x and y for the division
        // but using the sign of z for rounding the result.
        // x and y must have a non-empty mantissa and valid exponent.
    **/
    @:keep
    public dynamic function _uquo(_x:Ref<Float_>, _y:Ref<Float_>):Void __self__.value._uquo(_x, _y);
    /**
        // z = x * y, ignoring signs of x and y for the multiplication
        // but using the sign of z for rounding the result.
        // x and y must have a non-empty mantissa and valid exponent.
    **/
    @:keep
    public dynamic function _umul(_x:Ref<Float_>, _y:Ref<Float_>):Void __self__.value._umul(_x, _y);
    /**
        // z = x - y for |x| > |y|, ignoring signs of x and y for the subtraction
        // but using the sign of z for rounding the result.
        // x and y must have a non-empty mantissa and valid exponent.
    **/
    @:keep
    public dynamic function _usub(_x:Ref<Float_>, _y:Ref<Float_>):Void __self__.value._usub(_x, _y);
    /**
        // z = x + y, ignoring signs of x and y for the addition
        // but using the sign of z for rounding the result.
        // x and y must have a non-empty mantissa and valid exponent.
    **/
    @:keep
    public dynamic function _uadd(_x:Ref<Float_>, _y:Ref<Float_>):Void __self__.value._uadd(_x, _y);
    /**
        // Neg sets z to the (possibly rounded) value of x with its sign negated,
        // and returns z.
    **/
    @:keep
    public dynamic function neg(_x:Ref<Float_>):Ref<Float_> return __self__.value.neg(_x);
    /**
        // Abs sets z to the (possibly rounded) value |x| (the absolute value of x)
        // and returns z.
    **/
    @:keep
    public dynamic function abs(_x:Ref<Float_>):Ref<Float_> return __self__.value.abs(_x);
    /**
        // Rat returns the rational number corresponding to x;
        // or nil if x is an infinity.
        // The result is Exact if x is not an Inf.
        // If a non-nil *Rat argument z is provided, Rat stores
        // the result in z instead of allocating a new Rat.
    **/
    @:keep
    public dynamic function rat(_z:Ref<Rat>):{ var _0 : Ref<Rat>; var _1 : Accuracy; } return __self__.value.rat(_z);
    /**
        // Int returns the result of truncating x towards zero;
        // or nil if x is an infinity.
        // The result is Exact if x.IsInt(); otherwise it is Below
        // for x > 0, and Above for x < 0.
        // If a non-nil *Int argument z is provided, Int stores
        // the result in z instead of allocating a new Int.
    **/
    @:keep
    public dynamic function int_(_z:Ref<Int_>):{ var _0 : Ref<Int_>; var _1 : Accuracy; } return __self__.value.int_(_z);
    /**
        // Float64 returns the float64 value nearest to x. If x is too small to be
        // represented by a float64 (|x| < math.SmallestNonzeroFloat64), the result
        // is (0, Below) or (-0, Above), respectively, depending on the sign of x.
        // If x is too large to be represented by a float64 (|x| > math.MaxFloat64),
        // the result is (+Inf, Above) or (-Inf, Below), depending on the sign of x.
    **/
    @:keep
    public dynamic function float64():{ var _0 : GoFloat64; var _1 : Accuracy; } return __self__.value.float64();
    /**
        // Float32 returns the float32 value nearest to x. If x is too small to be
        // represented by a float32 (|x| < math.SmallestNonzeroFloat32), the result
        // is (0, Below) or (-0, Above), respectively, depending on the sign of x.
        // If x is too large to be represented by a float32 (|x| > math.MaxFloat32),
        // the result is (+Inf, Above) or (-Inf, Below), depending on the sign of x.
    **/
    @:keep
    public dynamic function float32():{ var _0 : GoFloat32; var _1 : Accuracy; } return __self__.value.float32();
    /**
        // Int64 returns the integer resulting from truncating x towards zero.
        // If math.MinInt64 <= x <= math.MaxInt64, the result is Exact if x is
        // an integer, and Above (x < 0) or Below (x > 0) otherwise.
        // The result is (math.MinInt64, Above) for x < math.MinInt64,
        // and (math.MaxInt64, Below) for x > math.MaxInt64.
    **/
    @:keep
    public dynamic function int64():{ var _0 : GoInt64; var _1 : Accuracy; } return __self__.value.int64();
    /**
        // Uint64 returns the unsigned integer resulting from truncating x
        // towards zero. If 0 <= x <= math.MaxUint64, the result is Exact
        // if x is an integer and Below otherwise.
        // The result is (0, Above) for x < 0, and (math.MaxUint64, Below)
        // for x > math.MaxUint64.
    **/
    @:keep
    public dynamic function uint64():{ var _0 : GoUInt64; var _1 : Accuracy; } return __self__.value.uint64();
    /**
        // Copy sets z to x, with the same precision, rounding mode, and
        // accuracy as x, and returns z. x is not changed even if z and
        // x are the same.
    **/
    @:keep
    public dynamic function copy(_x:Ref<Float_>):Ref<Float_> return __self__.value.copy(_x);
    /**
        // Set sets z to the (possibly rounded) value of x and returns z.
        // If z's precision is 0, it is changed to the precision of x
        // before setting z (and rounding will have no effect).
        // Rounding is performed according to z's precision and rounding
        // mode; and z's accuracy reports the result error relative to the
        // exact (not rounded) result.
    **/
    @:keep
    public dynamic function set(_x:Ref<Float_>):Ref<Float_> return __self__.value.set(_x);
    /**
        // SetInf sets z to the infinite Float -Inf if signbit is
        // set, or +Inf if signbit is not set, and returns z. The
        // precision of z is unchanged and the result is always
        // Exact.
    **/
    @:keep
    public dynamic function setInf(_signbit:Bool):Ref<Float_> return __self__.value.setInf(_signbit);
    /**
        // SetRat sets z to the (possibly rounded) value of x and returns z.
        // If z's precision is 0, it is changed to the largest of a.BitLen(),
        // b.BitLen(), or 64; with x = a/b.
    **/
    @:keep
    public dynamic function setRat(_x:Ref<Rat>):Ref<Float_> return __self__.value.setRat(_x);
    /**
        // SetInt sets z to the (possibly rounded) value of x and returns z.
        // If z's precision is 0, it is changed to the larger of x.BitLen()
        // or 64 (and rounding will have no effect).
    **/
    @:keep
    public dynamic function setInt(_x:Ref<Int_>):Ref<Float_> return __self__.value.setInt(_x);
    /**
        // SetFloat64 sets z to the (possibly rounded) value of x and returns z.
        // If z's precision is 0, it is changed to 53 (and rounding will have
        // no effect). SetFloat64 panics with ErrNaN if x is a NaN.
    **/
    @:keep
    public dynamic function setFloat64(_x:GoFloat64):Ref<Float_> return __self__.value.setFloat64(_x);
    /**
        // SetInt64 sets z to the (possibly rounded) value of x and returns z.
        // If z's precision is 0, it is changed to 64 (and rounding will have
        // no effect).
    **/
    @:keep
    public dynamic function setInt64(_x:GoInt64):Ref<Float_> return __self__.value.setInt64(_x);
    /**
        // SetUint64 sets z to the (possibly rounded) value of x and returns z.
        // If z's precision is 0, it is changed to 64 (and rounding will have
        // no effect).
    **/
    @:keep
    public dynamic function setUint64(_x:GoUInt64):Ref<Float_> return __self__.value.setUint64(_x);
    @:keep
    public dynamic function _setBits64(_neg:Bool, _x:GoUInt64):Ref<Float_> return __self__.value._setBits64(_neg, _x);
    /**
        // round rounds z according to z.mode to z.prec bits and sets z.acc accordingly.
        // sbit must be 0 or 1 and summarizes any "sticky bit" information one might
        // have before calling round. z's mantissa must be normalized (with the msb set)
        // or empty.
        //
        // CAUTION: The rounding modes ToNegativeInf, ToPositiveInf are affected by the
        // sign of z. For correct rounding, the sign of z must be set correctly before
        // calling round.
    **/
    @:keep
    public dynamic function _round(_sbit:GoUInt):Void __self__.value._round(_sbit);
    /**
        // debugging support
    **/
    @:keep
    public dynamic function _validate():Void __self__.value._validate();
    /**
        // IsInt reports whether x is an integer.
        // Inf values are not integers.
    **/
    @:keep
    public dynamic function isInt():Bool return __self__.value.isInt();
    /**
        // IsInf reports whether x is +Inf or -Inf.
    **/
    @:keep
    public dynamic function isInf():Bool return __self__.value.isInf();
    /**
        // Signbit reports whether x is negative or negative zero.
    **/
    @:keep
    public dynamic function signbit():Bool return __self__.value.signbit();
    /**
        // SetMantExp sets z to mant  2**exp and returns z.
        // The result z has the same precision and rounding mode
        // as mant. SetMantExp is an inverse of MantExp but does
        // not require 0.5 <= |mant| < 1.0. Specifically, for a
        // given x of type *Float, SetMantExp relates to MantExp
        // as follows:
        //
        //	mant := new(Float)
        //	new(Float).SetMantExp(mant, x.MantExp(mant)).Cmp(x) == 0
        //
        // Special cases are:
        //
        //	z.SetMantExp(  0, exp) =   0
        //	z.SetMantExp(Inf, exp) = Inf
        //
        // z and mant may be the same in which case z's exponent
        // is set to exp.
    **/
    @:keep
    public dynamic function setMantExp(_mant:Ref<Float_>, _exp:GoInt):Ref<Float_> return __self__.value.setMantExp(_mant, _exp);
    @:keep
    public dynamic function _setExpAndRound(_exp:GoInt64, _sbit:GoUInt):Void __self__.value._setExpAndRound(_exp, _sbit);
    /**
        // MantExp breaks x into its mantissa and exponent components
        // and returns the exponent. If a non-nil mant argument is
        // provided its value is set to the mantissa of x, with the
        // same precision and rounding mode as x. The components
        // satisfy x == mant  2**exp, with 0.5 <= |mant| < 1.0.
        // Calling MantExp with a nil argument is an efficient way to
        // get the exponent of the receiver.
        //
        // Special cases are:
        //
        //	(  0).MantExp(mant) = 0, with mant set to   0
        //	(Inf).MantExp(mant) = 0, with mant set to Inf
        //
        // x and mant may be the same in which case x is set to its
        // mantissa value.
    **/
    @:keep
    public dynamic function mantExp(_mant:Ref<Float_>):GoInt return __self__.value.mantExp(_mant);
    /**
        // Sign returns:
        //
        //	-1 if x <   0
        //	 0 if x is 0
        //	+1 if x >   0
    **/
    @:keep
    public dynamic function sign():GoInt return __self__.value.sign();
    /**
        // Acc returns the accuracy of x produced by the most recent
        // operation, unless explicitly documented otherwise by that
        // operation.
    **/
    @:keep
    public dynamic function acc():Accuracy return __self__.value.acc();
    /**
        // Mode returns the rounding mode of x.
    **/
    @:keep
    public dynamic function mode():RoundingMode return __self__.value.mode();
    /**
        // MinPrec returns the minimum precision required to represent x exactly
        // (i.e., the smallest prec before x.SetPrec(prec) would start rounding x).
        // The result is 0 for |x| == 0 and |x| == Inf.
    **/
    @:keep
    public dynamic function minPrec():GoUInt return __self__.value.minPrec();
    /**
        // Prec returns the mantissa precision of x in bits.
        // The result may be 0 for |x| == 0 and |x| == Inf.
    **/
    @:keep
    public dynamic function prec():GoUInt return __self__.value.prec();
    /**
        // SetMode sets z's rounding mode to mode and returns an exact z.
        // z remains unchanged otherwise.
        // z.SetMode(z.Mode()) is a cheap way to set z's accuracy to Exact.
    **/
    @:keep
    public dynamic function setMode(_mode:RoundingMode):Ref<Float_> return __self__.value.setMode(_mode);
    /**
        // SetPrec sets z's precision to prec and returns the (possibly) rounded
        // value of z. Rounding occurs according to z's rounding mode if the mantissa
        // cannot be represented in prec bits without loss of precision.
        // SetPrec(0) maps all finite values to 0; infinite values remain unchanged.
        // If prec > MaxPrec, it is set to MaxPrec.
    **/
    @:keep
    public dynamic function setPrec(_prec:GoUInt):Ref<Float_> return __self__.value.setPrec(_prec);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Float_>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.Float__asInterface) class Float__static_extension {
    /**
        // Compute x (to z.prec precision) by solving
        //
        //	1/t - x = 0
        //
        // for t (using Newton's method), and then inverting.
    **/
    @:keep
    static public function _sqrtInverse( _z:Ref<Float_>, _x:Ref<Float_>):Void {
        var _u = _newFloat(_z._prec);
        var _v = _newFloat(_z._prec);
        var _three = _three();
        var _ng = function(_t:Ref<Float_>):Ref<Float_> {
            _u._prec = _t._prec;
            _v._prec = _t._prec;
            _u.mul(_t, _t);
            _u.mul(_x, _u);
            _v.sub(_three, _u);
            _u.mul(_t, _v);
            _u._exp--;
            return _t.set(_u);
        };
        var __tmp__ = _x.float64(), _xf:GoFloat64 = __tmp__._0, __0:stdgo.math.big.Big.Accuracy = __tmp__._1;
        var _sqi = _newFloat(_z._prec);
        _sqi.setFloat64((1 : GoFloat64) / stdgo.math.Math.sqrt(_xf));
        {
            var _prec:GoUInt32 = _z._prec + (32u32 : GoUInt32);
            while (_sqi._prec < _prec) {
                _sqi._prec = _sqi._prec * ((2u32 : GoUInt32));
                _sqi = _ng(_sqi);
            };
        };
        _z.mul(_x, _sqi);
    }
    /**
        // Sqrt sets z to the rounded square root of x, and returns it.
        //
        // If z's precision is 0, it is changed to x's precision before the
        // operation. Rounding is performed according to z's precision and
        // rounding mode, but z's accuracy is not computed. Specifically, the
        // result of z.Acc() is undefined.
        //
        // The function panics if z < 0. The value of z is undefined in that
        // case.
    **/
    @:keep
    static public function sqrt( _z:Ref<Float_>, _x:Ref<Float_>):Ref<Float_> {
        if (false) {
            _x._validate();
        };
        if (_z._prec == ((0u32 : GoUInt32))) {
            _z._prec = _x._prec;
        };
        if (_x.sign() == ((-1 : GoInt))) {
            throw Go.toInterface(Go.asInterface((new ErrNaN(("square root of negative operand" : GoString)) : ErrNaN)));
        };
        if (_x._form != ((1 : stdgo.math.big.Big.T_form))) {
            _z._acc = (0 : stdgo.math.big.Big.Accuracy);
            _z._form = _x._form;
            _z._neg = _x._neg;
            return _z;
        };
        var _prec:GoUInt32 = _z._prec;
        var _b:GoInt = _x.mantExp(_z);
        _z._prec = _prec;
        {
            final __value__ = _b % (2 : GoInt);
            if (__value__ == ((0 : GoInt))) {} else if (__value__ == ((1 : GoInt))) {
                _z._exp++;
            } else if (__value__ == ((-1 : GoInt))) {
                _z._exp--;
            };
        };
        _z._sqrtInverse(_z);
        return _z.setMantExp(_z, _b / (2 : GoInt));
    }
    /**
        // Format implements fmt.Formatter. It accepts all the regular
        // formats for floating-point numbers ('b', 'e', 'E', 'f', 'F',
        // 'g', 'G', 'x') as well as 'p' and 'v'. See (*Float).Text for the
        // interpretation of 'p'. The 'v' format is handled like 'g'.
        // Format also supports specification of the minimum precision
        // in digits, the output field width, as well as the format flags
        // '+' and ' ' for sign control, '0' for space or zero padding,
        // and '-' for left or right justification. See the fmt package
        // for details.
    **/
    @:keep
    static public function format( _x:Ref<Float_>, _s:stdgo.fmt.Fmt.State, _format:GoRune):Void {
        var __tmp__ = _s.precision(), _prec:GoInt = __tmp__._0, _hasPrec:Bool = __tmp__._1;
        if (!_hasPrec) {
            _prec = (6 : GoInt);
        };
        {
            var __switchIndex__ = -1;
            while (true) {
                {
                    final __value__ = _format;
                    if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (__value__ == ((101 : GoInt32)) || __value__ == ((69 : GoInt32)) || __value__ == ((102 : GoInt32)) || __value__ == ((98 : GoInt32)) || __value__ == ((112 : GoInt32)) || __value__ == ((120 : GoInt32))))) {
                        break;
                    } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && (__value__ == (70 : GoInt32)))) {
                        _format = (102 : GoInt32);
                        break;
                        break;
                    } else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && (__value__ == (118 : GoInt32)))) {
                        _format = (103 : GoInt32);
                        @:fallthrough {
                            __switchIndex__ = 3;
                            continue;
                        };
                        break;
                    } else if (__switchIndex__ == 3 || (__switchIndex__ == -1 && (__value__ == ((103 : GoInt32)) || __value__ == ((71 : GoInt32))))) {
                        if (!_hasPrec) {
                            _prec = (-1 : GoInt);
                        };
                        break;
                        break;
                    } else {
                        stdgo.fmt.Fmt.fprintf(_s, ("%%!%c(*big.Float=%s)" : GoString), Go.toInterface(_format), Go.toInterface((_x.string() : GoString)));
                        return;
                        break;
                    };
                };
                break;
            };
        };
        var _buf:Slice<GoByte> = (null : Slice<GoUInt8>);
        _buf = _x.append(_buf, (_format : GoByte), _prec);
        if ((_buf.length) == ((0 : GoInt))) {
            _buf = (("?" : GoString) : Slice<GoByte>);
        };
        var _sign:GoString = ("" : GoString);
        if (_buf[(0 : GoInt)] == ((45 : GoUInt8))) {
            _sign = ("-" : GoString);
            _buf = (_buf.__slice__((1 : GoInt)) : Slice<GoUInt8>);
        } else if (_buf[(0 : GoInt)] == ((43 : GoUInt8))) {
            _sign = ("+" : GoString);
            if (_s.flag((32 : GoInt))) {
                _sign = (" " : GoString);
            };
            _buf = (_buf.__slice__((1 : GoInt)) : Slice<GoUInt8>);
        } else if (_s.flag((43 : GoInt))) {
            _sign = ("+" : GoString);
        } else if (_s.flag((32 : GoInt))) {
            _sign = (" " : GoString);
        };
        var _padding:GoInt = (0 : GoInt);
        {
            var __tmp__ = _s.width(), _width:GoInt = __tmp__._0, _hasWidth:Bool = __tmp__._1;
            if (_hasWidth && (_width > (_sign.length + _buf.length))) {
                _padding = (_width - _sign.length) - (_buf.length);
            };
        };
        if (_s.flag((48 : GoInt)) && !_x.isInf()) {
            _writeMultiple(_s, _sign, (1 : GoInt));
            _writeMultiple(_s, ("0" : GoString), _padding);
            _s.write(_buf);
        } else if (_s.flag((45 : GoInt))) {
            _writeMultiple(_s, _sign, (1 : GoInt));
            _s.write(_buf);
            _writeMultiple(_s, (" " : GoString), _padding);
        } else {
            _writeMultiple(_s, (" " : GoString), _padding);
            _writeMultiple(_s, _sign, (1 : GoInt));
            _s.write(_buf);
        };
    }
    /**
        // fmtP appends the string of x in the format "0x." mantissa "p" exponent
        // with a hexadecimal mantissa and a binary exponent, or "0" if x is zero,
        // and returns the extended buffer.
        // The mantissa is normalized such that 0.5 <= 0.mantissa < 1.0.
        // The sign of x is ignored, and x must not be an Inf.
        // (The caller handles Inf before invoking fmtP.)
    **/
    @:keep
    static public function _fmtP( _x:Ref<Float_>, _buf:Slice<GoByte>):Slice<GoByte> {
        if (_x._form == ((0 : stdgo.math.big.Big.T_form))) {
            return (_buf.__append__((48 : GoUInt8)));
        };
        if (false && (_x._form != (1 : stdgo.math.big.Big.T_form))) {
            throw Go.toInterface(("non-finite float" : GoString));
        };
        var _m:stdgo.math.big.Big.T_nat = _x._mant;
        var _i:GoInt = (0 : GoInt);
        while ((_i < _m.length) && (_m[(_i : GoInt)] == (0u32 : stdgo.math.big.Big.Word))) {
            _i++;
        };
        _m = (_m.__slice__(_i) : stdgo.math.big.Big.T_nat);
        _buf = _buf.__appendref__(...("0x." : GoString).__toArray__());
        _buf = _buf.__appendref__(...stdgo.bytes.Bytes.trimRight(_m._utoa((16 : GoInt)), ("0" : GoString)).__toArray__());
        _buf = _buf.__appendref__((112 : GoUInt8));
        if (_x._exp >= (0 : GoInt32)) {
            _buf = _buf.__appendref__((43 : GoUInt8));
        };
        return stdgo.strconv.Strconv.appendInt(_buf, (_x._exp : GoInt64), (10 : GoInt));
    }
    /**
        // fmtX appends the string of x in the format "0x1." mantissa "p" exponent
        // with a hexadecimal mantissa and a binary exponent, or "0x0p0" if x is zero,
        // and returns the extended buffer.
        // A non-zero mantissa is normalized such that 1.0 <= mantissa < 2.0.
        // The sign of x is ignored, and x must not be an Inf.
        // (The caller handles Inf before invoking fmtX.)
    **/
    @:keep
    static public function _fmtX( _x:Ref<Float_>, _buf:Slice<GoByte>, _prec:GoInt):Slice<GoByte> {
        if (_x._form == ((0 : stdgo.math.big.Big.T_form))) {
            _buf = _buf.__appendref__(...("0x0" : GoString).__toArray__());
            if (_prec > (0 : GoInt)) {
                _buf = _buf.__appendref__((46 : GoUInt8));
                {
                    var _i:GoInt = (0 : GoInt);
                    Go.cfor(_i < _prec, _i++, {
                        _buf = _buf.__appendref__((48 : GoUInt8));
                    });
                };
            };
            _buf = _buf.__appendref__(...("p+00" : GoString).__toArray__());
            return _buf;
        };
        if (false && (_x._form != (1 : stdgo.math.big.Big.T_form))) {
            throw Go.toInterface(("non-finite float" : GoString));
        };
        var _n:GoUInt = (0 : GoUInt);
        if (_prec < (0 : GoInt)) {
            _n = (1u32 : GoUInt) + ((((_x.minPrec() - (1u32 : GoUInt)) + (3u32 : GoUInt)) / (4u32 : GoUInt)) * (4u32 : GoUInt));
        } else {
            _n = (1u32 : GoUInt) + ((4u32 : GoUInt) * (_prec : GoUInt));
        };
        _x = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_n).setMode(_x._mode).set(_x);
        var _m:stdgo.math.big.Big.T_nat = _x._mant;
        {
            var _w:GoUInt = (_x._mant.length : GoUInt) * (32u32 : GoUInt);
            if (_w < _n) {
                _m = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._shl(_m, _n - _w);
            } else if (_w > _n) {
                _m = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._shr(_m, _w - _n);
            };
        };
        var _exp64:GoInt64 = (_x._exp : GoInt64) - (1i64 : GoInt64);
        var _hm = _m._utoa((16 : GoInt));
        if (false && (_hm[(0 : GoInt)] != (49 : GoUInt8))) {
            throw Go.toInterface(("incorrect mantissa: " : GoString) + (_hm : GoString));
        };
        _buf = _buf.__appendref__(...("0x1" : GoString).__toArray__());
        if ((_hm.length) > (1 : GoInt)) {
            _buf = _buf.__appendref__((46 : GoUInt8));
            _buf = _buf.__appendref__(...(_hm.__slice__((1 : GoInt)) : Slice<GoUInt8>).__toArray__());
        };
        _buf = _buf.__appendref__((112 : GoUInt8));
        if (_exp64 >= (0i64 : GoInt64)) {
            _buf = _buf.__appendref__((43 : GoUInt8));
        } else {
            _exp64 = -_exp64;
            _buf = _buf.__appendref__((45 : GoUInt8));
        };
        if (_exp64 < (10i64 : GoInt64)) {
            _buf = _buf.__appendref__((48 : GoUInt8));
        };
        return stdgo.strconv.Strconv.appendInt(_buf, _exp64, (10 : GoInt));
    }
    /**
        // fmtB appends the string of x in the format mantissa "p" exponent
        // with a decimal mantissa and a binary exponent, or 0" if x is zero,
        // and returns the extended buffer.
        // The mantissa is normalized such that is uses x.Prec() bits in binary
        // representation.
        // The sign of x is ignored, and x must not be an Inf.
        // (The caller handles Inf before invoking fmtB.)
    **/
    @:keep
    static public function _fmtB( _x:Ref<Float_>, _buf:Slice<GoByte>):Slice<GoByte> {
        if (_x._form == ((0 : stdgo.math.big.Big.T_form))) {
            return (_buf.__append__((48 : GoUInt8)));
        };
        if (false && (_x._form != (1 : stdgo.math.big.Big.T_form))) {
            throw Go.toInterface(("non-finite float" : GoString));
        };
        var _m:stdgo.math.big.Big.T_nat = _x._mant;
        {
            var _w:GoUInt32 = (_x._mant.length : GoUInt32) * (32u32 : GoUInt32);
            if (_w < _x._prec) {
                _m = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._shl(_m, (_x._prec - _w : GoUInt));
            } else if (_w > _x._prec) {
                _m = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._shr(_m, (_w - _x._prec : GoUInt));
            };
        };
        _buf = _buf.__appendref__(..._m._utoa((10 : GoInt)).__toArray__());
        _buf = _buf.__appendref__((112 : GoUInt8));
        var _e:GoInt64 = (_x._exp : GoInt64) - (_x._prec : GoInt64);
        if (_e >= (0i64 : GoInt64)) {
            _buf = _buf.__appendref__((43 : GoUInt8));
        };
        return stdgo.strconv.Strconv.appendInt(_buf, _e, (10 : GoInt));
    }
    /**
        // Append appends to buf the string form of the floating-point number x,
        // as generated by x.Text, and returns the extended buffer.
    **/
    @:keep
    static public function append( _x:Ref<Float_>, _buf:Slice<GoByte>, _fmt:GoByte, _prec:GoInt):Slice<GoByte> {
        if (_x._neg) {
            _buf = _buf.__appendref__((45 : GoUInt8));
        };
        if (_x._form == ((2 : stdgo.math.big.Big.T_form))) {
            if (!_x._neg) {
                _buf = _buf.__appendref__((43 : GoUInt8));
            };
            return (_buf.__append__(...("Inf" : GoString).__toArray__()));
        };
        {
            final __value__ = _fmt;
            if (__value__ == ((98 : GoUInt8))) {
                return _x._fmtB(_buf);
            } else if (__value__ == ((112 : GoUInt8))) {
                return _x._fmtP(_buf);
            } else if (__value__ == ((120 : GoUInt8))) {
                return _x._fmtX(_buf, _prec);
            };
        };
        var _d:T_decimal = ({} : stdgo.math.big.Big.T_decimal);
        if (_x._form == ((1 : stdgo.math.big.Big.T_form))) {
            _d._init(_x._mant, (_x._exp : GoInt) - _x._mant._bitLen());
        };
        var _shortest:Bool = false;
        if (_prec < (0 : GoInt)) {
            _shortest = true;
            _roundShortest((Go.setRef(_d) : Ref<stdgo.math.big.Big.T_decimal>), _x);
            {
                final __value__ = _fmt;
                if (__value__ == ((101 : GoUInt8)) || __value__ == ((69 : GoUInt8))) {
                    _prec = (_d._mant.length) - (1 : GoInt);
                } else if (__value__ == ((102 : GoUInt8))) {
                    _prec = _max((_d._mant.length) - _d._exp, (0 : GoInt));
                } else if (__value__ == ((103 : GoUInt8)) || __value__ == ((71 : GoUInt8))) {
                    _prec = (_d._mant.length);
                };
            };
        } else {
            {
                final __value__ = _fmt;
                if (__value__ == ((101 : GoUInt8)) || __value__ == ((69 : GoUInt8))) {
                    _d._round((1 : GoInt) + _prec);
                } else if (__value__ == ((102 : GoUInt8))) {
                    _d._round(_d._exp + _prec);
                } else if (__value__ == ((103 : GoUInt8)) || __value__ == ((71 : GoUInt8))) {
                    if (_prec == ((0 : GoInt))) {
                        _prec = (1 : GoInt);
                    };
                    _d._round(_prec);
                };
            };
        };
        {
            final __value__ = _fmt;
            if (__value__ == ((101 : GoUInt8)) || __value__ == ((69 : GoUInt8))) {
                return _fmtE(_buf, _fmt, _prec, _d?.__copy__());
            } else if (__value__ == ((102 : GoUInt8))) {
                return _fmtF(_buf, _prec, _d?.__copy__());
            } else if (__value__ == ((103 : GoUInt8)) || __value__ == ((71 : GoUInt8))) {
                var _eprec:GoInt = _prec;
                if ((_eprec > _d._mant.length) && (_d._mant.length >= _d._exp)) {
                    _eprec = (_d._mant.length);
                };
                if (_shortest) {
                    _eprec = (6 : GoInt);
                };
                var _exp:GoInt = _d._exp - (1 : GoInt);
                if ((_exp < (-4 : GoInt)) || (_exp >= _eprec)) {
                    if (_prec > (_d._mant.length)) {
                        _prec = (_d._mant.length);
                    };
                    return _fmtE(_buf, (_fmt + (101 : GoUInt8)) - (103 : GoUInt8), _prec - (1 : GoInt), _d?.__copy__());
                };
                if (_prec > _d._exp) {
                    _prec = (_d._mant.length);
                };
                return _fmtF(_buf, _max(_prec - _d._exp, (0 : GoInt)), _d?.__copy__());
            };
        };
        if (_x._neg) {
            _buf = (_buf.__slice__(0, (_buf.length) - (1 : GoInt)) : Slice<GoUInt8>);
        };
        return (_buf.__append__((37 : GoUInt8), _fmt));
    }
    /**
        // String formats x like x.Text('g', 10).
        // (String must be called explicitly, Float.Format does not support %s verb.)
    **/
    @:keep
    static public function string( _x:Ref<Float_>):GoString {
        return _x.text((103 : GoUInt8), (10 : GoInt));
    }
    /**
        // Text converts the floating-point number x to a string according
        // to the given format and precision prec. The format is one of:
        //
        //	'e'	-d.ddddedd, decimal exponent, at least two (possibly 0) exponent digits
        //	'E'	-d.ddddEdd, decimal exponent, at least two (possibly 0) exponent digits
        //	'f'	-ddddd.dddd, no exponent
        //	'g'	like 'e' for large exponents, like 'f' otherwise
        //	'G'	like 'E' for large exponents, like 'f' otherwise
        //	'x'	-0xd.dddddpdd, hexadecimal mantissa, decimal power of two exponent
        //	'p'	-0x.dddpdd, hexadecimal mantissa, decimal power of two exponent (non-standard)
        //	'b'	-ddddddpdd, decimal mantissa, decimal power of two exponent (non-standard)
        //
        // For the power-of-two exponent formats, the mantissa is printed in normalized form:
        //
        //	'x'	hexadecimal mantissa in [1, 2), or 0
        //	'p'	hexadecimal mantissa in [, 1), or 0
        //	'b'	decimal integer mantissa using x.Prec() bits, or 0
        //
        // Note that the 'x' form is the one used by most other languages and libraries.
        //
        // If format is a different character, Text returns a "%" followed by the
        // unrecognized format character.
        //
        // The precision prec controls the number of digits (excluding the exponent)
        // printed by the 'e', 'E', 'f', 'g', 'G', and 'x' formats.
        // For 'e', 'E', 'f', and 'x', it is the number of digits after the decimal point.
        // For 'g' and 'G' it is the total number of digits. A negative precision selects
        // the smallest number of decimal digits necessary to identify the value x uniquely
        // using x.Prec() mantissa bits.
        // The prec value is ignored for the 'b' and 'p' formats.
    **/
    @:keep
    static public function text( _x:Ref<Float_>, _format:GoByte, _prec:GoInt):GoString {
        var _cap:GoInt = (10 : GoInt);
        if (_prec > (0 : GoInt)) {
            _cap = _cap + (_prec);
        };
        return (_x.append(new Slice<GoUInt8>((0 : GoInt).toBasic(), _cap, ...[for (i in 0 ... (0 : GoInt).toBasic()) (0 : GoUInt8)]), _format, _prec) : GoString);
    }
    /**
        // UnmarshalText implements the encoding.TextUnmarshaler interface.
        // The result is rounded per the precision and rounding mode of z.
        // If z's precision is 0, it is changed to 64 before rounding takes
        // effect.
    **/
    @:keep
    static public function unmarshalText( _z:Ref<Float_>, _text:Slice<GoByte>):Error {
        var __tmp__ = _z.parse((_text : GoString), (0 : GoInt)), __0:Ref<stdgo.math.big.Big.Float_> = __tmp__._0, __1:GoInt = __tmp__._1, _err:Error = __tmp__._2;
        if (_err != null) {
            _err = stdgo.fmt.Fmt.errorf(("math/big: cannot unmarshal %q into a *big.Float (%v)" : GoString), Go.toInterface(_text), Go.toInterface(_err));
        };
        return _err;
    }
    /**
        // MarshalText implements the encoding.TextMarshaler interface.
        // Only the Float value is marshaled (in full precision), other
        // attributes such as precision or accuracy are ignored.
    **/
    @:keep
    static public function marshalText( _x:Ref<Float_>):{ var _0 : Slice<GoByte>; var _1 : Error; } {
        var _text:Slice<GoByte> = (null : Slice<GoUInt8>), _err:Error = (null : Error);
        if (_x == null || (_x : Dynamic).__nil__) {
            return { _0 : (("<nil>" : GoString) : Slice<GoByte>), _1 : (null : Error) };
        };
        var _buf:Slice<GoByte> = (null : Slice<GoUInt8>);
        return { _0 : _x.append(_buf, (103 : GoUInt8), (-1 : GoInt)), _1 : (null : Error) };
    }
    /**
        // GobDecode implements the gob.GobDecoder interface.
        // The result is rounded per the precision and rounding mode of
        // z unless z's precision is 0, in which case z is set exactly
        // to the decoded value.
    **/
    @:keep
    static public function gobDecode( _z:Ref<Float_>, _buf:Slice<GoByte>):Error {
        if ((_buf.length) == ((0 : GoInt))) {
            {
                var __tmp__ = (new Float_() : Float_);
                _z._prec = __tmp__._prec;
                _z._mode = __tmp__._mode;
                _z._acc = __tmp__._acc;
                _z._form = __tmp__._form;
                _z._neg = __tmp__._neg;
                _z._mant = __tmp__._mant;
                _z._exp = __tmp__._exp;
            };
            return (null : Error);
        };
        if ((_buf.length) < (6 : GoInt)) {
            return stdgo.errors.Errors.new_(("Float.GobDecode: buffer too small" : GoString));
        };
        if (_buf[(0 : GoInt)] != ((1 : GoUInt8))) {
            return stdgo.fmt.Fmt.errorf(("Float.GobDecode: encoding version %d not supported" : GoString), Go.toInterface(_buf[(0 : GoInt)]));
        };
        var _oldPrec:GoUInt32 = _z._prec;
        var _oldMode:stdgo.math.big.Big.RoundingMode = _z._mode;
        var _b:GoUInt8 = _buf[(1 : GoInt)];
        _z._mode = ((_b >> (5i64 : GoUInt64)) & (7 : GoUInt8) : RoundingMode);
        _z._acc = ((_b >> (3i64 : GoUInt64)) & (3 : GoUInt8) : Accuracy) - (1 : stdgo.math.big.Big.Accuracy);
        _z._form = ((_b >> (1i64 : GoUInt64)) & (3 : GoUInt8) : T_form);
        _z._neg = _b & (1 : GoUInt8) != ((0 : GoUInt8));
        _z._prec = stdgo.encoding.binary.Binary.bigEndian.uint32((_buf.__slice__((2 : GoInt)) : Slice<GoUInt8>));
        if (_z._form == ((1 : stdgo.math.big.Big.T_form))) {
            if ((_buf.length) < (10 : GoInt)) {
                return stdgo.errors.Errors.new_(("Float.GobDecode: buffer too small for finite form float" : GoString));
            };
            _z._exp = (stdgo.encoding.binary.Binary.bigEndian.uint32((_buf.__slice__((6 : GoInt)) : Slice<GoUInt8>)) : GoInt32);
            _z._mant = _z._mant._setBytes((_buf.__slice__((10 : GoInt)) : Slice<GoUInt8>));
        };
        if (_oldPrec != ((0u32 : GoUInt32))) {
            _z._mode = _oldMode;
            _z.setPrec((_oldPrec : GoUInt));
        };
        return (null : Error);
    }
    /**
        // GobEncode implements the gob.GobEncoder interface.
        // The Float value and all its attributes (precision,
        // rounding mode, accuracy) are marshaled.
    **/
    @:keep
    static public function gobEncode( _x:Ref<Float_>):{ var _0 : Slice<GoByte>; var _1 : Error; } {
        if (_x == null || (_x : Dynamic).__nil__) {
            return { _0 : (null : Slice<GoUInt8>), _1 : (null : Error) };
        };
        var _sz:GoInt = (6 : GoInt);
        var _n:GoInt = (0 : GoInt);
        if (_x._form == ((1 : stdgo.math.big.Big.T_form))) {
            _n = ((_x._prec + (31u32 : GoUInt32)) / (32u32 : GoUInt32) : GoInt);
            if ((_x._mant.length) < _n) {
                _n = (_x._mant.length);
            };
            _sz = _sz + ((4 : GoInt) + (_n * (4 : GoInt)));
        };
        var _buf = new Slice<GoUInt8>((_sz : GoInt).toBasic(), 0, ...[for (i in 0 ... (_sz : GoInt).toBasic()) (0 : GoUInt8)]);
        _buf[(0 : GoInt)] = (1 : GoUInt8);
        var _b:GoUInt8 = (((_x._mode & (7 : stdgo.math.big.Big.RoundingMode) : GoByte) << (5i64 : GoUInt64)) | (((_x._acc + (1 : stdgo.math.big.Big.Accuracy)) & (3 : stdgo.math.big.Big.Accuracy) : GoByte) << (3i64 : GoUInt64))) | ((_x._form & (3 : stdgo.math.big.Big.T_form) : GoByte) << (1i64 : GoUInt64));
        if (_x._neg) {
            _b = _b | ((1 : GoUInt8));
        };
        _buf[(1 : GoInt)] = _b;
        stdgo.encoding.binary.Binary.bigEndian.putUint32((_buf.__slice__((2 : GoInt)) : Slice<GoUInt8>), _x._prec);
        if (_x._form == ((1 : stdgo.math.big.Big.T_form))) {
            stdgo.encoding.binary.Binary.bigEndian.putUint32((_buf.__slice__((6 : GoInt)) : Slice<GoUInt8>), (_x._exp : GoUInt32));
            (_x._mant.__slice__((_x._mant.length) - _n) : stdgo.math.big.Big.T_nat)._bytes((_buf.__slice__((10 : GoInt)) : Slice<GoUInt8>));
        };
        return { _0 : _buf, _1 : (null : Error) };
    }
    /**
        // Scan is a support routine for fmt.Scanner; it sets z to the value of
        // the scanned number. It accepts formats whose verbs are supported by
        // fmt.Scan for floating point values, which are:
        // 'b' (binary), 'e', 'E', 'f', 'F', 'g' and 'G'.
        // Scan doesn't handle Inf.
    **/
    @:keep
    static public function scan( _z:Ref<Float_>, _s:stdgo.fmt.Fmt.ScanState, _ch:GoRune):Error {
        _s.skipSpace();
        var __tmp__ = _z._scan(Go.asInterface((new T_byteReader(_s) : T_byteReader)), (0 : GoInt)), __0:Ref<stdgo.math.big.Big.Float_> = __tmp__._0, __1:GoInt = __tmp__._1, _err:Error = __tmp__._2;
        return _err;
    }
    /**
        // Parse parses s which must contain a text representation of a floating-
        // point number with a mantissa in the given conversion base (the exponent
        // is always a decimal number), or a string representing an infinite value.
        //
        // For base 0, an underscore character _ may appear between a base
        // prefix and an adjacent digit, and between successive digits; such
        // underscores do not change the value of the number, or the returned
        // digit count. Incorrect placement of underscores is reported as an
        // error if there are no other errors. If base != 0, underscores are
        // not recognized and thus terminate scanning like any other character
        // that is not a valid radix point or digit.
        //
        // It sets z to the (possibly rounded) value of the corresponding floating-
        // point value, and returns z, the actual base b, and an error err, if any.
        // The entire string (not just a prefix) must be consumed for success.
        // If z's precision is 0, it is changed to 64 before rounding takes effect.
        // The number must be of the form:
        //
        //	number    = [ sign ] ( float | "inf" | "Inf" ) .
        //	sign      = "+" | "-" .
        //	float     = ( mantissa | prefix pmantissa ) [ exponent ] .
        //	prefix    = "0" [ "b" | "B" | "o" | "O" | "x" | "X" ] .
        //	mantissa  = digits "." [ digits ] | digits | "." digits .
        //	pmantissa = [ "_" ] digits "." [ digits ] | [ "_" ] digits | "." digits .
        //	exponent  = ( "e" | "E" | "p" | "P" ) [ sign ] digits .
        //	digits    = digit { [ "_" ] digit } .
        //	digit     = "0" ... "9" | "a" ... "z" | "A" ... "Z" .
        //
        // The base argument must be 0, 2, 8, 10, or 16. Providing an invalid base
        // argument will lead to a run-time panic.
        //
        // For base 0, the number prefix determines the actual base: A prefix of
        // 0b or 0B selects base 2, 0o or 0O selects base 8, and
        // 0x or 0X selects base 16. Otherwise, the actual base is 10 and
        // no prefix is accepted. The octal prefix "0" is not supported (a leading
        // "0" is simply considered a "0").
        //
        // A "p" or "P" exponent indicates a base 2 (rather then base 10) exponent;
        // for instance, "0x1.fffffffffffffp1023" (using base 0) represents the
        // maximum float64 value. For hexadecimal mantissae, the exponent character
        // must be one of 'p' or 'P', if present (an "e" or "E" exponent indicator
        // cannot be distinguished from a mantissa digit).
        //
        // The returned *Float f is nil and the value of z is valid but not
        // defined if an error is reported.
    **/
    @:keep
    static public function parse( _z:Ref<Float_>, _s:GoString, _base:GoInt):{ var _0 : Ref<Float_>; var _1 : GoInt; var _2 : Error; } {
        var _f:Ref<Float_> = (null : Ref<stdgo.math.big.Big.Float_>), _b:GoInt = (0 : GoInt), _err:Error = (null : Error);
        if ((_s.length == (3 : GoInt)) && ((_s == ("Inf" : GoString)) || (_s == ("inf" : GoString)))) {
            _f = _z.setInf(false);
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        if (((_s.length == (4 : GoInt)) && ((_s[(0 : GoInt)] == (43 : GoUInt8)) || (_s[(0 : GoInt)] == (45 : GoUInt8)))) && (((_s.__slice__((1 : GoInt)) : GoString) == ("Inf" : GoString)) || ((_s.__slice__((1 : GoInt)) : GoString) == ("inf" : GoString)))) {
            _f = _z.setInf(_s[(0 : GoInt)] == ((45 : GoUInt8)));
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        var _r = stdgo.strings.Strings.newReader(_s);
        {
            {
                var __tmp__ = _z._scan(Go.asInterface(_r), _base);
                _f = __tmp__._0;
                _b = __tmp__._1;
                _err = __tmp__._2;
            };
            if (_err != null) {
                return { _0 : _f, _1 : _b, _2 : _err };
            };
        };
        {
            var __tmp__ = _r.readByte(), _ch:GoUInt8 = __tmp__._0, _err2:Error = __tmp__._1;
            if (_err2 == null) {
                _err = stdgo.fmt.Fmt.errorf(("expected end of string, found %q" : GoString), Go.toInterface(_ch));
            } else if (Go.toInterface(_err2) != (Go.toInterface(stdgo.io.Io.eof))) {
                _err = _err2;
            };
        };
        return { _0 : _f, _1 : _b, _2 : _err };
    }
    /**
        // pow5 sets z to 5**n and returns z.
        // n must not be negative.
    **/
    @:keep
    static public function _pow5( _z:Ref<Float_>, _n:GoUInt64):Ref<Float_> {
        {};
        if (_n <= (27i64 : GoUInt64)) {
            return _z.setUint64(_pow5tab[(_n : GoInt)]);
        };
        _z.setUint64(_pow5tab[((27i64 : GoUInt64) : GoInt)]);
        _n = _n - ((27i64 : GoUInt64));
        var _f = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_z.prec() + (64u32 : GoUInt)).setUint64((5i64 : GoUInt64));
        while (_n > (0i64 : GoUInt64)) {
            if (_n & (1i64 : GoUInt64) != ((0i64 : GoUInt64))) {
                _z.mul(_z, _f);
            };
            _f.mul(_f, _f);
            _n = _n >> ((1i64 : GoUInt64));
        };
        return _z;
    }
    /**
        // scan is like Parse but reads the longest possible prefix representing a valid
        // floating point number from an io.ByteScanner rather than a string. It serves
        // as the implementation of Parse. It does not recognize Inf and does not expect
        // EOF at the end.
    **/
    @:keep
    static public function _scan( _z:Ref<Float_>, _r:stdgo.io.Io.ByteScanner, _base:GoInt):{ var _0 : Ref<Float_>; var _1 : GoInt; var _2 : Error; } {
        var _f:Ref<Float_> = (null : Ref<stdgo.math.big.Big.Float_>), _b:GoInt = (0 : GoInt), _err:Error = (null : Error);
        var _prec:GoUInt32 = _z._prec;
        if (_prec == ((0u32 : GoUInt32))) {
            _prec = (64u32 : GoUInt32);
        };
        _z._form = (0 : stdgo.math.big.Big.T_form);
        {
            var __tmp__ = _scanSign(_r);
            _z._neg = __tmp__._0;
            _err = __tmp__._1;
        };
        if (_err != null) {
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        var _fcount:GoInt = (0 : GoInt);
        {
            var __tmp__ = _z._mant._scan(_r, _base, true);
            _z._mant = __tmp__._0;
            _b = __tmp__._1;
            _fcount = __tmp__._2;
            _err = __tmp__._3;
        };
        if (_err != null) {
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        var _exp:GoInt64 = (0 : GoInt64);
        var _ebase:GoInt = (0 : GoInt);
        {
            var __tmp__ = _scanExponent(_r, true, _base == ((0 : GoInt)));
            _exp = __tmp__._0;
            _ebase = __tmp__._1;
            _err = __tmp__._2;
        };
        if (_err != null) {
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        if ((_z._mant.length) == ((0 : GoInt))) {
            _z._prec = _prec;
            _z._acc = (0 : stdgo.math.big.Big.Accuracy);
            _z._form = (0 : stdgo.math.big.Big.T_form);
            _f = _z;
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        var _exp2:GoInt64 = ((_z._mant.length : GoInt64) * (32i64 : GoInt64)) - _fnorm(_z._mant);
        var _exp5:GoInt64 = (0i64 : GoInt64);
        if (_fcount < (0 : GoInt)) {
            var _d:GoInt64 = (_fcount : GoInt64);
            {
                var __switchIndex__ = -1;
                while (true) {
                    {
                        final __value__ = _b;
                        if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (__value__ == (10 : GoInt)))) {
                            _exp5 = _d;
                            @:fallthrough {
                                __switchIndex__ = 1;
                                continue;
                            };
                            break;
                        } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && (__value__ == (2 : GoInt)))) {
                            _exp2 = _exp2 + (_d);
                            break;
                            break;
                        } else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && (__value__ == (8 : GoInt)))) {
                            _exp2 = _exp2 + (_d * (3i64 : GoInt64));
                            break;
                            break;
                        } else if (__switchIndex__ == 3 || (__switchIndex__ == -1 && (__value__ == (16 : GoInt)))) {
                            _exp2 = _exp2 + (_d * (4i64 : GoInt64));
                            break;
                            break;
                        } else {
                            throw Go.toInterface(("unexpected mantissa base" : GoString));
                            break;
                        };
                    };
                    break;
                };
            };
        };
        {
            var __switchIndex__ = -1;
            while (true) {
                {
                    final __value__ = _ebase;
                    if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (__value__ == (10 : GoInt)))) {
                        _exp5 = _exp5 + (_exp);
                        @:fallthrough {
                            __switchIndex__ = 1;
                            continue;
                        };
                        break;
                    } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && (__value__ == (2 : GoInt)))) {
                        _exp2 = _exp2 + (_exp);
                        break;
                        break;
                    } else {
                        throw Go.toInterface(("unexpected exponent base" : GoString));
                        break;
                    };
                };
                break;
            };
        };
        if (((-2147483648i64 : GoInt64) <= _exp2) && (_exp2 <= (2147483647i64 : GoInt64))) {
            _z._prec = _prec;
            _z._form = (1 : stdgo.math.big.Big.T_form);
            _z._exp = (_exp2 : GoInt32);
            _f = _z;
        } else {
            _err = stdgo.fmt.Fmt.errorf(("exponent overflow" : GoString));
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        if (_exp5 == ((0i64 : GoInt64))) {
            _z._round((0u32 : GoUInt));
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        var _p = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setPrec(_z.prec() + (64u32 : GoUInt));
        if (_exp5 < (0i64 : GoInt64)) {
            _z.quo(_z, _p._pow5((-_exp5 : GoUInt64)));
        } else {
            _z.mul(_z, _p._pow5((_exp5 : GoUInt64)));
        };
        return { _0 : _f, _1 : _b, _2 : _err };
    }
    /**
        // SetString sets z to the value of s and returns z and a boolean indicating
        // success. s must be a floating-point number of the same format as accepted
        // by Parse, with base argument 0. The entire string (not just a prefix) must
        // be valid for success. If the operation failed, the value of z is undefined
        // but the returned value is nil.
    **/
    @:keep
    static public function setString( _z:Ref<Float_>, _s:GoString):{ var _0 : Ref<Float_>; var _1 : Bool; } {
        {
            var __tmp__ = _z.parse(_s, (0 : GoInt)), _f:Ref<stdgo.math.big.Big.Float_> = __tmp__._0, __0:GoInt = __tmp__._1, _err:Error = __tmp__._2;
            if (_err == null) {
                return { _0 : _f, _1 : true };
            };
        };
        return { _0 : null, _1 : false };
    }
    @:keep
    static public function _int64( _x:Ref<Float_>):GoInt64 {
        var __tmp__ = _x.int64(), _i:GoInt64 = __tmp__._0, _acc:stdgo.math.big.Big.Accuracy = __tmp__._1;
        if (_acc != ((0 : stdgo.math.big.Big.Accuracy))) {
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("%s is not an int64" : GoString), Go.toInterface(_x.text((103 : GoUInt8), (10 : GoInt)))));
        };
        return _i;
    }
    @:keep
    static public function _uint64( _x:Ref<Float_>):GoUInt64 {
        var __tmp__ = _x.uint64(), _u:GoUInt64 = __tmp__._0, _acc:stdgo.math.big.Big.Accuracy = __tmp__._1;
        if (_acc != ((0 : stdgo.math.big.Big.Accuracy))) {
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("%s is not a uint64" : GoString), Go.toInterface(_x.text((103 : GoUInt8), (10 : GoInt)))));
        };
        return _u;
    }
    /**
        // ord classifies x and returns:
        //
        //	-2 if -Inf == x
        //	-1 if -Inf < x < 0
        //	 0 if x == 0 (signed or unsigned)
        //	+1 if 0 < x < +Inf
        //	+2 if x == +Inf
    **/
    @:keep
    static public function _ord( _x:Ref<Float_>):GoInt {
        var _m:GoInt = (0 : GoInt);
        {
            final __value__ = _x._form;
            if (__value__ == ((1 : stdgo.math.big.Big.T_form))) {
                _m = (1 : GoInt);
            } else if (__value__ == ((0 : stdgo.math.big.Big.T_form))) {
                return (0 : GoInt);
            } else if (__value__ == ((2 : stdgo.math.big.Big.T_form))) {
                _m = (2 : GoInt);
            };
        };
        if (_x._neg) {
            _m = -_m;
        };
        return _m;
    }
    /**
        // Cmp compares x and y and returns:
        //
        //	-1 if x <  y
        //	 0 if x == y (incl. -0 == 0, -Inf == -Inf, and +Inf == +Inf)
        //	+1 if x >  y
    **/
    @:keep
    static public function cmp( _x:Ref<Float_>, _y:Ref<Float_>):GoInt {
        if (false) {
            _x._validate();
            _y._validate();
        };
        var _mx:GoInt = _x._ord();
        var _my:GoInt = _y._ord();
        if (_mx < _my) {
            return (-1 : GoInt);
        } else if (_mx > _my) {
            return (1 : GoInt);
        };
        {
            final __value__ = _mx;
            if (__value__ == ((-1 : GoInt))) {
                return _y._ucmp(_x);
            } else if (__value__ == ((1 : GoInt))) {
                return _x._ucmp(_y);
            };
        };
        return (0 : GoInt);
    }
    /**
        // Quo sets z to the rounded quotient x/y and returns z.
        // Precision, rounding, and accuracy reporting are as for Add.
        // Quo panics with ErrNaN if both operands are zero or infinities.
        // The value of z is undefined in that case.
    **/
    @:keep
    static public function quo( _z:Ref<Float_>, _x:Ref<Float_>, _y:Ref<Float_>):Ref<Float_> {
        if (false) {
            _x._validate();
            _y._validate();
        };
        if (_z._prec == ((0u32 : GoUInt32))) {
            _z._prec = _umax32(_x._prec, _y._prec);
        };
        _z._neg = _x._neg != (_y._neg);
        if ((_x._form == (1 : stdgo.math.big.Big.T_form)) && (_y._form == (1 : stdgo.math.big.Big.T_form))) {
            _z._uquo(_x, _y);
            return _z;
        };
        _z._acc = (0 : stdgo.math.big.Big.Accuracy);
        if (((_x._form == (0 : stdgo.math.big.Big.T_form)) && (_y._form == (0 : stdgo.math.big.Big.T_form))) || ((_x._form == (2 : stdgo.math.big.Big.T_form)) && (_y._form == (2 : stdgo.math.big.Big.T_form)))) {
            _z._form = (0 : stdgo.math.big.Big.T_form);
            _z._neg = false;
            throw Go.toInterface(Go.asInterface((new ErrNaN(("division of zero by zero or infinity by infinity" : GoString)) : ErrNaN)));
        };
        if ((_x._form == (0 : stdgo.math.big.Big.T_form)) || (_y._form == (2 : stdgo.math.big.Big.T_form))) {
            _z._form = (0 : stdgo.math.big.Big.T_form);
            return _z;
        };
        _z._form = (2 : stdgo.math.big.Big.T_form);
        return _z;
    }
    /**
        // Mul sets z to the rounded product x*y and returns z.
        // Precision, rounding, and accuracy reporting are as for Add.
        // Mul panics with ErrNaN if one operand is zero and the other
        // operand an infinity. The value of z is undefined in that case.
    **/
    @:keep
    static public function mul( _z:Ref<Float_>, _x:Ref<Float_>, _y:Ref<Float_>):Ref<Float_> {
        if (false) {
            _x._validate();
            _y._validate();
        };
        if (_z._prec == ((0u32 : GoUInt32))) {
            _z._prec = _umax32(_x._prec, _y._prec);
        };
        _z._neg = _x._neg != (_y._neg);
        if ((_x._form == (1 : stdgo.math.big.Big.T_form)) && (_y._form == (1 : stdgo.math.big.Big.T_form))) {
            _z._umul(_x, _y);
            return _z;
        };
        _z._acc = (0 : stdgo.math.big.Big.Accuracy);
        if (((_x._form == (0 : stdgo.math.big.Big.T_form)) && (_y._form == (2 : stdgo.math.big.Big.T_form))) || ((_x._form == (2 : stdgo.math.big.Big.T_form)) && (_y._form == (0 : stdgo.math.big.Big.T_form)))) {
            _z._form = (0 : stdgo.math.big.Big.T_form);
            _z._neg = false;
            throw Go.toInterface(Go.asInterface((new ErrNaN(("multiplication of zero with infinity" : GoString)) : ErrNaN)));
        };
        if ((_x._form == (2 : stdgo.math.big.Big.T_form)) || (_y._form == (2 : stdgo.math.big.Big.T_form))) {
            _z._form = (2 : stdgo.math.big.Big.T_form);
            return _z;
        };
        _z._form = (0 : stdgo.math.big.Big.T_form);
        return _z;
    }
    /**
        // Sub sets z to the rounded difference x-y and returns z.
        // Precision, rounding, and accuracy reporting are as for Add.
        // Sub panics with ErrNaN if x and y are infinities with equal
        // signs. The value of z is undefined in that case.
    **/
    @:keep
    static public function sub( _z:Ref<Float_>, _x:Ref<Float_>, _y:Ref<Float_>):Ref<Float_> {
        if (false) {
            _x._validate();
            _y._validate();
        };
        if (_z._prec == ((0u32 : GoUInt32))) {
            _z._prec = _umax32(_x._prec, _y._prec);
        };
        if ((_x._form == (1 : stdgo.math.big.Big.T_form)) && (_y._form == (1 : stdgo.math.big.Big.T_form))) {
            var _yneg:Bool = _y._neg;
            _z._neg = _x._neg;
            if (_x._neg != (_yneg)) {
                _z._uadd(_x, _y);
            } else {
                if (_x._ucmp(_y) > (0 : GoInt)) {
                    _z._usub(_x, _y);
                } else {
                    _z._neg = !_z._neg;
                    _z._usub(_y, _x);
                };
            };
            if (((_z._form == (0 : stdgo.math.big.Big.T_form)) && (_z._mode == (4 : stdgo.math.big.Big.RoundingMode))) && (_z._acc == (0 : stdgo.math.big.Big.Accuracy))) {
                _z._neg = true;
            };
            return _z;
        };
        if (((_x._form == (2 : stdgo.math.big.Big.T_form)) && (_y._form == (2 : stdgo.math.big.Big.T_form))) && (_x._neg == _y._neg)) {
            _z._acc = (0 : stdgo.math.big.Big.Accuracy);
            _z._form = (0 : stdgo.math.big.Big.T_form);
            _z._neg = false;
            throw Go.toInterface(Go.asInterface((new ErrNaN(("subtraction of infinities with equal signs" : GoString)) : ErrNaN)));
        };
        if ((_x._form == (0 : stdgo.math.big.Big.T_form)) && (_y._form == (0 : stdgo.math.big.Big.T_form))) {
            _z._acc = (0 : stdgo.math.big.Big.Accuracy);
            _z._form = (0 : stdgo.math.big.Big.T_form);
            _z._neg = _x._neg && !_y._neg;
            return _z;
        };
        if ((_x._form == (2 : stdgo.math.big.Big.T_form)) || (_y._form == (0 : stdgo.math.big.Big.T_form))) {
            return _z.set(_x);
        };
        return _z.neg(_y);
    }
    /**
        // Add sets z to the rounded sum x+y and returns z. If z's precision is 0,
        // it is changed to the larger of x's or y's precision before the operation.
        // Rounding is performed according to z's precision and rounding mode; and
        // z's accuracy reports the result error relative to the exact (not rounded)
        // result. Add panics with ErrNaN if x and y are infinities with opposite
        // signs. The value of z is undefined in that case.
    **/
    @:keep
    static public function add( _z:Ref<Float_>, _x:Ref<Float_>, _y:Ref<Float_>):Ref<Float_> {
        if (false) {
            _x._validate();
            _y._validate();
        };
        if (_z._prec == ((0u32 : GoUInt32))) {
            _z._prec = _umax32(_x._prec, _y._prec);
        };
        if ((_x._form == (1 : stdgo.math.big.Big.T_form)) && (_y._form == (1 : stdgo.math.big.Big.T_form))) {
            var _yneg:Bool = _y._neg;
            _z._neg = _x._neg;
            if (_x._neg == (_yneg)) {
                _z._uadd(_x, _y);
            } else {
                if (_x._ucmp(_y) > (0 : GoInt)) {
                    _z._usub(_x, _y);
                } else {
                    _z._neg = !_z._neg;
                    _z._usub(_y, _x);
                };
            };
            if (((_z._form == (0 : stdgo.math.big.Big.T_form)) && (_z._mode == (4 : stdgo.math.big.Big.RoundingMode))) && (_z._acc == (0 : stdgo.math.big.Big.Accuracy))) {
                _z._neg = true;
            };
            return _z;
        };
        if (((_x._form == (2 : stdgo.math.big.Big.T_form)) && (_y._form == (2 : stdgo.math.big.Big.T_form))) && (_x._neg != _y._neg)) {
            _z._acc = (0 : stdgo.math.big.Big.Accuracy);
            _z._form = (0 : stdgo.math.big.Big.T_form);
            _z._neg = false;
            throw Go.toInterface(Go.asInterface((new ErrNaN(("addition of infinities with opposite signs" : GoString)) : ErrNaN)));
        };
        if ((_x._form == (0 : stdgo.math.big.Big.T_form)) && (_y._form == (0 : stdgo.math.big.Big.T_form))) {
            _z._acc = (0 : stdgo.math.big.Big.Accuracy);
            _z._form = (0 : stdgo.math.big.Big.T_form);
            _z._neg = _x._neg && _y._neg;
            return _z;
        };
        if ((_x._form == (2 : stdgo.math.big.Big.T_form)) || (_y._form == (0 : stdgo.math.big.Big.T_form))) {
            return _z.set(_x);
        };
        return _z.set(_y);
    }
    /**
        // ucmp returns -1, 0, or +1, depending on whether
        // |x| < |y|, |x| == |y|, or |x| > |y|.
        // x and y must have a non-empty mantissa and valid exponent.
    **/
    @:keep
    static public function _ucmp( _x:Ref<Float_>, _y:Ref<Float_>):GoInt {
        if (false) {
            _validateBinaryOperands(_x, _y);
        };
        if (_x._exp < _y._exp) {
            return (-1 : GoInt);
        } else if (_x._exp > _y._exp) {
            return (1 : GoInt);
        };
        var _i:GoInt = (_x._mant.length);
        var _j:GoInt = (_y._mant.length);
        while ((_i > (0 : GoInt)) || (_j > (0 : GoInt))) {
            var __0:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word), __1:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word), _ym:Word = __1, _xm:Word = __0;
            if (_i > (0 : GoInt)) {
                _i--;
                _xm = _x._mant[(_i : GoInt)];
            };
            if (_j > (0 : GoInt)) {
                _j--;
                _ym = _y._mant[(_j : GoInt)];
            };
            if (_xm < _ym) {
                return (-1 : GoInt);
            } else if (_xm > _ym) {
                return (1 : GoInt);
            };
        };
        return (0 : GoInt);
    }
    /**
        // z = x / y, ignoring signs of x and y for the division
        // but using the sign of z for rounding the result.
        // x and y must have a non-empty mantissa and valid exponent.
    **/
    @:keep
    static public function _uquo( _z:Ref<Float_>, _x:Ref<Float_>, _y:Ref<Float_>):Void {
        if (false) {
            _validateBinaryOperands(_x, _y);
        };
        var _n:GoInt = (_z._prec / (32u32 : GoUInt32) : GoInt) + (1 : GoInt);
        var _xadj:stdgo.math.big.Big.T_nat = _x._mant;
        {
            var _d:GoInt = (_n - _x._mant.length) + (_y._mant.length);
            if (_d > (0 : GoInt)) {
                _xadj = new stdgo.math.big.Big.T_nat(((_x._mant.length) + _d : GoInt).toBasic(), 0, ...[for (i in 0 ... ((_x._mant.length) + _d : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
                Go.copySlice((_xadj.__slice__(_d) : stdgo.math.big.Big.T_nat), _x._mant);
            };
        };
        var _d:GoInt = (_xadj.length) - (_y._mant.length);
        var _r:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
        {
            var __tmp__ = _z._mant._div(null, _xadj, _y._mant);
            _z._mant = __tmp__._0;
            _r = __tmp__._1;
        };
        var _e:GoInt64 = ((_x._exp : GoInt64) - (_y._exp : GoInt64)) - ((_d - (_z._mant.length) : GoInt64) * (32i64 : GoInt64));
        var _sbit:GoUInt = (0 : GoUInt);
        if ((_r.length) > (0 : GoInt)) {
            _sbit = (1u32 : GoUInt);
        };
        _z._setExpAndRound(_e - _fnorm(_z._mant), _sbit);
    }
    /**
        // z = x * y, ignoring signs of x and y for the multiplication
        // but using the sign of z for rounding the result.
        // x and y must have a non-empty mantissa and valid exponent.
    **/
    @:keep
    static public function _umul( _z:Ref<Float_>, _x:Ref<Float_>, _y:Ref<Float_>):Void {
        if (false) {
            _validateBinaryOperands(_x, _y);
        };
        var _e:GoInt64 = (_x._exp : GoInt64) + (_y._exp : GoInt64);
        if (_x == (_y)) {
            _z._mant = _z._mant._sqr(_x._mant);
        } else {
            _z._mant = _z._mant._mul(_x._mant, _y._mant);
        };
        _z._setExpAndRound(_e - _fnorm(_z._mant), (0u32 : GoUInt));
    }
    /**
        // z = x - y for |x| > |y|, ignoring signs of x and y for the subtraction
        // but using the sign of z for rounding the result.
        // x and y must have a non-empty mantissa and valid exponent.
    **/
    @:keep
    static public function _usub( _z:Ref<Float_>, _x:Ref<Float_>, _y:Ref<Float_>):Void {
        if (false) {
            _validateBinaryOperands(_x, _y);
        };
        var _ex:GoInt64 = (_x._exp : GoInt64) - ((_x._mant.length : GoInt64) * (32i64 : GoInt64));
        var _ey:GoInt64 = (_y._exp : GoInt64) - ((_y._mant.length : GoInt64) * (32i64 : GoInt64));
        var _al:Bool = _alias(_z._mant, _x._mant) || _alias(_z._mant, _y._mant);
        if (_ex < _ey) {
            if (_al) {
                var _t:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._shl(_y._mant, (_ey - _ex : GoUInt));
                _z._mant = _t._sub(_x._mant, _t);
            } else {
                _z._mant = _z._mant._shl(_y._mant, (_ey - _ex : GoUInt));
                _z._mant = _z._mant._sub(_x._mant, _z._mant);
            };
        } else if (_ex > _ey) {
            if (_al) {
                var _t:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._shl(_x._mant, (_ex - _ey : GoUInt));
                _z._mant = _t._sub(_t, _y._mant);
            } else {
                _z._mant = _z._mant._shl(_x._mant, (_ex - _ey : GoUInt));
                _z._mant = _z._mant._sub(_z._mant, _y._mant);
            };
            _ex = _ey;
        } else {
            _z._mant = _z._mant._sub(_x._mant, _y._mant);
        };
        if ((_z._mant.length) == ((0 : GoInt))) {
            _z._acc = (0 : stdgo.math.big.Big.Accuracy);
            _z._form = (0 : stdgo.math.big.Big.T_form);
            _z._neg = false;
            return;
        };
        _z._setExpAndRound((_ex + ((_z._mant.length : GoInt64) * (32i64 : GoInt64))) - _fnorm(_z._mant), (0u32 : GoUInt));
    }
    /**
        // z = x + y, ignoring signs of x and y for the addition
        // but using the sign of z for rounding the result.
        // x and y must have a non-empty mantissa and valid exponent.
    **/
    @:keep
    static public function _uadd( _z:Ref<Float_>, _x:Ref<Float_>, _y:Ref<Float_>):Void {
        if (false) {
            _validateBinaryOperands(_x, _y);
        };
        var _ex:GoInt64 = (_x._exp : GoInt64) - ((_x._mant.length : GoInt64) * (32i64 : GoInt64));
        var _ey:GoInt64 = (_y._exp : GoInt64) - ((_y._mant.length : GoInt64) * (32i64 : GoInt64));
        var _al:Bool = _alias(_z._mant, _x._mant) || _alias(_z._mant, _y._mant);
        if (_ex < _ey) {
            if (_al) {
                var _t:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._shl(_y._mant, (_ey - _ex : GoUInt));
                _z._mant = _z._mant._add(_x._mant, _t);
            } else {
                _z._mant = _z._mant._shl(_y._mant, (_ey - _ex : GoUInt));
                _z._mant = _z._mant._add(_x._mant, _z._mant);
            };
        } else if (_ex > _ey) {
            if (_al) {
                var _t:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._shl(_x._mant, (_ex - _ey : GoUInt));
                _z._mant = _z._mant._add(_t, _y._mant);
            } else {
                _z._mant = _z._mant._shl(_x._mant, (_ex - _ey : GoUInt));
                _z._mant = _z._mant._add(_z._mant, _y._mant);
            };
            _ex = _ey;
        } else {
            _z._mant = _z._mant._add(_x._mant, _y._mant);
        };
        _z._setExpAndRound((_ex + ((_z._mant.length : GoInt64) * (32i64 : GoInt64))) - _fnorm(_z._mant), (0u32 : GoUInt));
    }
    /**
        // Neg sets z to the (possibly rounded) value of x with its sign negated,
        // and returns z.
    **/
    @:keep
    static public function neg( _z:Ref<Float_>, _x:Ref<Float_>):Ref<Float_> {
        _z.set(_x);
        _z._neg = !_z._neg;
        return _z;
    }
    /**
        // Abs sets z to the (possibly rounded) value |x| (the absolute value of x)
        // and returns z.
    **/
    @:keep
    static public function abs( _z:Ref<Float_>, _x:Ref<Float_>):Ref<Float_> {
        _z.set(_x);
        _z._neg = false;
        return _z;
    }
    /**
        // Rat returns the rational number corresponding to x;
        // or nil if x is an infinity.
        // The result is Exact if x is not an Inf.
        // If a non-nil *Rat argument z is provided, Rat stores
        // the result in z instead of allocating a new Rat.
    **/
    @:keep
    static public function rat( _x:Ref<Float_>, _z:Ref<Rat>):{ var _0 : Ref<Rat>; var _1 : Accuracy; } {
        if (false) {
            _x._validate();
        };
        if ((_z == null) || (_z : Dynamic).__nil__ && (_x._form <= (1 : stdgo.math.big.Big.T_form))) {
            _z = (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>);
        };
        {
            final __value__ = _x._form;
            if (__value__ == ((1 : stdgo.math.big.Big.T_form))) {
                var _allBits:GoInt32 = (_x._mant.length : GoInt32) * (32 : GoInt32);
                _z._a._neg = _x._neg;
                if (_x._exp > _allBits) {
                    _z._a._abs = _z._a._abs._shl(_x._mant, (_x._exp - _allBits : GoUInt));
                    _z._b._abs = (_z._b._abs.__slice__(0, (0 : GoInt)) : stdgo.math.big.Big.T_nat);
                } else if (_x._exp < _allBits) {
                    _z._a._abs = _z._a._abs._set(_x._mant);
                    var _t:stdgo.math.big.Big.T_nat = _z._b._abs._setUint64((1i64 : GoUInt64));
                    _z._b._abs = _t._shl(_t, (_allBits - _x._exp : GoUInt));
                    _z._norm();
                } else {
                    _z._a._abs = _z._a._abs._set(_x._mant);
                    _z._b._abs = (_z._b._abs.__slice__(0, (0 : GoInt)) : stdgo.math.big.Big.T_nat);
                };
                return { _0 : _z, _1 : (0 : stdgo.math.big.Big.Accuracy) };
            } else if (__value__ == ((0 : stdgo.math.big.Big.T_form))) {
                return { _0 : _z.setInt64((0i64 : GoInt64)), _1 : (0 : stdgo.math.big.Big.Accuracy) };
            } else if (__value__ == ((2 : stdgo.math.big.Big.T_form))) {
                return { _0 : null, _1 : _makeAcc(_x._neg) };
            };
        };
        throw Go.toInterface(("unreachable" : GoString));
    }
    /**
        // Int returns the result of truncating x towards zero;
        // or nil if x is an infinity.
        // The result is Exact if x.IsInt(); otherwise it is Below
        // for x > 0, and Above for x < 0.
        // If a non-nil *Int argument z is provided, Int stores
        // the result in z instead of allocating a new Int.
    **/
    @:keep
    static public function int_( _x:Ref<Float_>, _z:Ref<Int_>):{ var _0 : Ref<Int_>; var _1 : Accuracy; } {
        if (false) {
            _x._validate();
        };
        if ((_z == null) || (_z : Dynamic).__nil__ && (_x._form <= (1 : stdgo.math.big.Big.T_form))) {
            _z = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        };
        {
            final __value__ = _x._form;
            if (__value__ == ((1 : stdgo.math.big.Big.T_form))) {
                var _acc:stdgo.math.big.Big.Accuracy = _makeAcc(_x._neg);
                if (_x._exp <= (0 : GoInt32)) {
                    return { _0 : _z.setInt64((0i64 : GoInt64)), _1 : _acc };
                };
                var _allBits:GoUInt = (_x._mant.length : GoUInt) * (32u32 : GoUInt);
                var _exp:GoUInt = (_x._exp : GoUInt);
                if (_x.minPrec() <= _exp) {
                    _acc = (0 : stdgo.math.big.Big.Accuracy);
                };
                if (_z == null || (_z : Dynamic).__nil__) {
                    _z = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
                };
                _z._neg = _x._neg;
                if (_exp > _allBits) {
                    _z._abs = _z._abs._shl(_x._mant, _exp - _allBits);
                } else if (_exp < _allBits) {
                    _z._abs = _z._abs._shr(_x._mant, _allBits - _exp);
                } else {
                    _z._abs = _z._abs._set(_x._mant);
                };
                return { _0 : _z, _1 : _acc };
            } else if (__value__ == ((0 : stdgo.math.big.Big.T_form))) {
                return { _0 : _z.setInt64((0i64 : GoInt64)), _1 : (0 : stdgo.math.big.Big.Accuracy) };
            } else if (__value__ == ((2 : stdgo.math.big.Big.T_form))) {
                return { _0 : null, _1 : _makeAcc(_x._neg) };
            };
        };
        throw Go.toInterface(("unreachable" : GoString));
    }
    /**
        // Float64 returns the float64 value nearest to x. If x is too small to be
        // represented by a float64 (|x| < math.SmallestNonzeroFloat64), the result
        // is (0, Below) or (-0, Above), respectively, depending on the sign of x.
        // If x is too large to be represented by a float64 (|x| > math.MaxFloat64),
        // the result is (+Inf, Above) or (-Inf, Below), depending on the sign of x.
    **/
    @:keep
    static public function float64( _x:Ref<Float_>):{ var _0 : GoFloat64; var _1 : Accuracy; } {
        if (false) {
            _x._validate();
        };
        {
            final __value__ = _x._form;
            if (__value__ == ((1 : stdgo.math.big.Big.T_form))) {
                {};
                var _e:GoInt32 = _x._exp - (1 : GoInt32);
                var _p:GoInt = (53 : GoInt);
                if (_e < (-1022 : GoInt32)) {
                    _p = (1075 : GoInt) + (_e : GoInt);
                    if ((_p < (0 : GoInt)) || ((_p == (0 : GoInt)) && (_x._mant._sticky(((_x._mant.length : GoUInt) * (32u32 : GoUInt)) - (1u32 : GoUInt)) == (0u32 : GoUInt)))) {
                        if (_x._neg) {
                            var _z:GoFloat64 = (0 : GoFloat64);
                            return { _0 : -_z, _1 : (1 : stdgo.math.big.Big.Accuracy) };
                        };
                        return { _0 : (0 : GoFloat64), _1 : (-1 : stdgo.math.big.Big.Accuracy) };
                    };
                    if (_p == ((0 : GoInt))) {
                        if (_x._neg) {
                            return { _0 : (-5e-324 : GoFloat64), _1 : (-1 : stdgo.math.big.Big.Accuracy) };
                        };
                        return { _0 : (5e-324 : GoFloat64), _1 : (1 : stdgo.math.big.Big.Accuracy) };
                    };
                };
                var _r:Float_ = ({} : stdgo.math.big.Big.Float_);
                _r._prec = (_p : GoUInt32);
                _r.set(_x);
                _e = _r._exp - (1 : GoInt32);
                if ((_r._form == (2 : stdgo.math.big.Big.T_form)) || (_e > (1023 : GoInt32))) {
                    if (_x._neg) {
                        return { _0 : stdgo.math.Math.inf((-1 : GoInt)), _1 : (-1 : stdgo.math.big.Big.Accuracy) };
                    };
                    return { _0 : stdgo.math.Math.inf((1 : GoInt)), _1 : (1 : stdgo.math.big.Big.Accuracy) };
                };
                var __0:GoUInt64 = (0 : GoUInt64), __1:GoUInt64 = (0 : GoUInt64), __2:GoUInt64 = (0 : GoUInt64), _mant:GoUInt64 = __2, _bexp:GoUInt64 = __1, _sign:GoUInt64 = __0;
                if (_x._neg) {
                    _sign = (-9223372036854775808i64 : GoUInt64);
                };
                if (_e < (-1022 : GoInt32)) {
                    _p = (1075 : GoInt) + (_e : GoInt);
                    _mant = _msb64(_r._mant) >> ((64 : GoInt) - _p : GoUInt);
                } else {
                    _bexp = (_e + (1023 : GoInt32) : GoUInt64) << (52i64 : GoUInt64);
                    _mant = (_msb64(_r._mant) >> (11i64 : GoUInt64)) & (4503599627370495i64 : GoUInt64);
                };
                return { _0 : stdgo.math.Math.float64frombits((_sign | _bexp) | _mant), _1 : _r._acc };
            } else if (__value__ == ((0 : stdgo.math.big.Big.T_form))) {
                if (_x._neg) {
                    var _z:GoFloat64 = (0 : GoFloat64);
                    return { _0 : -_z, _1 : (0 : stdgo.math.big.Big.Accuracy) };
                };
                return { _0 : (0 : GoFloat64), _1 : (0 : stdgo.math.big.Big.Accuracy) };
            } else if (__value__ == ((2 : stdgo.math.big.Big.T_form))) {
                if (_x._neg) {
                    return { _0 : stdgo.math.Math.inf((-1 : GoInt)), _1 : (0 : stdgo.math.big.Big.Accuracy) };
                };
                return { _0 : stdgo.math.Math.inf((1 : GoInt)), _1 : (0 : stdgo.math.big.Big.Accuracy) };
            };
        };
        throw Go.toInterface(("unreachable" : GoString));
    }
    /**
        // Float32 returns the float32 value nearest to x. If x is too small to be
        // represented by a float32 (|x| < math.SmallestNonzeroFloat32), the result
        // is (0, Below) or (-0, Above), respectively, depending on the sign of x.
        // If x is too large to be represented by a float32 (|x| > math.MaxFloat32),
        // the result is (+Inf, Above) or (-Inf, Below), depending on the sign of x.
    **/
    @:keep
    static public function float32( _x:Ref<Float_>):{ var _0 : GoFloat32; var _1 : Accuracy; } {
        if (false) {
            _x._validate();
        };
        {
            final __value__ = _x._form;
            if (__value__ == ((1 : stdgo.math.big.Big.T_form))) {
                {};
                var _e:GoInt32 = _x._exp - (1 : GoInt32);
                var _p:GoInt = (24 : GoInt);
                if (_e < (-126 : GoInt32)) {
                    _p = (150 : GoInt) + (_e : GoInt);
                    if ((_p < (0 : GoInt)) || ((_p == (0 : GoInt)) && (_x._mant._sticky(((_x._mant.length : GoUInt) * (32u32 : GoUInt)) - (1u32 : GoUInt)) == (0u32 : GoUInt)))) {
                        if (_x._neg) {
                            var _z:GoFloat32 = (0 : GoFloat32);
                            return { _0 : -_z, _1 : (1 : stdgo.math.big.Big.Accuracy) };
                        };
                        return { _0 : (0 : GoFloat64), _1 : (-1 : stdgo.math.big.Big.Accuracy) };
                    };
                    if (_p == ((0 : GoInt))) {
                        if (_x._neg) {
                            return { _0 : (-1.401298464324817e-45 : GoFloat64), _1 : (-1 : stdgo.math.big.Big.Accuracy) };
                        };
                        return { _0 : (1.401298464324817e-45 : GoFloat64), _1 : (1 : stdgo.math.big.Big.Accuracy) };
                    };
                };
                var _r:Float_ = ({} : stdgo.math.big.Big.Float_);
                _r._prec = (_p : GoUInt32);
                _r.set(_x);
                _e = _r._exp - (1 : GoInt32);
                if ((_r._form == (2 : stdgo.math.big.Big.T_form)) || (_e > (127 : GoInt32))) {
                    if (_x._neg) {
                        return { _0 : (stdgo.math.Math.inf((-1 : GoInt)) : GoFloat32), _1 : (-1 : stdgo.math.big.Big.Accuracy) };
                    };
                    return { _0 : (stdgo.math.Math.inf((1 : GoInt)) : GoFloat32), _1 : (1 : stdgo.math.big.Big.Accuracy) };
                };
                var __0:GoUInt32 = (0 : GoUInt32), __1:GoUInt32 = (0 : GoUInt32), __2:GoUInt32 = (0 : GoUInt32), _mant:GoUInt32 = __2, _bexp:GoUInt32 = __1, _sign:GoUInt32 = __0;
                if (_x._neg) {
                    _sign = (-2147483648u32 : GoUInt32);
                };
                if (_e < (-126 : GoInt32)) {
                    _p = (150 : GoInt) + (_e : GoInt);
                    _mant = _msb32(_r._mant) >> ((32 : GoInt) - _p : GoUInt);
                } else {
                    _bexp = (_e + (127 : GoInt32) : GoUInt32) << (23i64 : GoUInt64);
                    _mant = (_msb32(_r._mant) >> (8i64 : GoUInt64)) & (8388607u32 : GoUInt32);
                };
                return { _0 : stdgo.math.Math.float32frombits((_sign | _bexp) | _mant), _1 : _r._acc };
            } else if (__value__ == ((0 : stdgo.math.big.Big.T_form))) {
                if (_x._neg) {
                    var _z:GoFloat32 = (0 : GoFloat32);
                    return { _0 : -_z, _1 : (0 : stdgo.math.big.Big.Accuracy) };
                };
                return { _0 : (0 : GoFloat64), _1 : (0 : stdgo.math.big.Big.Accuracy) };
            } else if (__value__ == ((2 : stdgo.math.big.Big.T_form))) {
                if (_x._neg) {
                    return { _0 : (stdgo.math.Math.inf((-1 : GoInt)) : GoFloat32), _1 : (0 : stdgo.math.big.Big.Accuracy) };
                };
                return { _0 : (stdgo.math.Math.inf((1 : GoInt)) : GoFloat32), _1 : (0 : stdgo.math.big.Big.Accuracy) };
            };
        };
        throw Go.toInterface(("unreachable" : GoString));
    }
    /**
        // Int64 returns the integer resulting from truncating x towards zero.
        // If math.MinInt64 <= x <= math.MaxInt64, the result is Exact if x is
        // an integer, and Above (x < 0) or Below (x > 0) otherwise.
        // The result is (math.MinInt64, Above) for x < math.MinInt64,
        // and (math.MaxInt64, Below) for x > math.MaxInt64.
    **/
    @:keep
    static public function int64( _x:Ref<Float_>):{ var _0 : GoInt64; var _1 : Accuracy; } {
        if (false) {
            _x._validate();
        };
        {
            final __value__ = _x._form;
            if (__value__ == ((1 : stdgo.math.big.Big.T_form))) {
                var _acc:stdgo.math.big.Big.Accuracy = _makeAcc(_x._neg);
                if (_x._exp <= (0 : GoInt32)) {
                    return { _0 : (0i64 : GoInt64), _1 : _acc };
                };
                if (_x._exp <= (63 : GoInt32)) {
                    var _i:GoInt64 = (_msb64(_x._mant) >> ((64u32 : GoUInt32) - (_x._exp : GoUInt32)) : GoInt64);
                    if (_x._neg) {
                        _i = -_i;
                    };
                    if (_x.minPrec() <= (_x._exp : GoUInt)) {
                        return { _0 : _i, _1 : (0 : stdgo.math.big.Big.Accuracy) };
                    };
                    return { _0 : _i, _1 : _acc };
                };
                if (_x._neg) {
                    if ((_x._exp == (64 : GoInt32)) && (_x.minPrec() == (1u32 : GoUInt))) {
                        _acc = (0 : stdgo.math.big.Big.Accuracy);
                    };
                    return { _0 : (-9223372036854775808i64 : GoInt64), _1 : _acc };
                };
                return { _0 : (9223372036854775807i64 : GoInt64), _1 : (-1 : stdgo.math.big.Big.Accuracy) };
            } else if (__value__ == ((0 : stdgo.math.big.Big.T_form))) {
                return { _0 : (0i64 : GoInt64), _1 : (0 : stdgo.math.big.Big.Accuracy) };
            } else if (__value__ == ((2 : stdgo.math.big.Big.T_form))) {
                if (_x._neg) {
                    return { _0 : (-9223372036854775808i64 : GoInt64), _1 : (1 : stdgo.math.big.Big.Accuracy) };
                };
                return { _0 : (9223372036854775807i64 : GoInt64), _1 : (-1 : stdgo.math.big.Big.Accuracy) };
            };
        };
        throw Go.toInterface(("unreachable" : GoString));
    }
    /**
        // Uint64 returns the unsigned integer resulting from truncating x
        // towards zero. If 0 <= x <= math.MaxUint64, the result is Exact
        // if x is an integer and Below otherwise.
        // The result is (0, Above) for x < 0, and (math.MaxUint64, Below)
        // for x > math.MaxUint64.
    **/
    @:keep
    static public function uint64( _x:Ref<Float_>):{ var _0 : GoUInt64; var _1 : Accuracy; } {
        if (false) {
            _x._validate();
        };
        {
            final __value__ = _x._form;
            if (__value__ == ((1 : stdgo.math.big.Big.T_form))) {
                if (_x._neg) {
                    return { _0 : (0i64 : GoUInt64), _1 : (1 : stdgo.math.big.Big.Accuracy) };
                };
                if (_x._exp <= (0 : GoInt32)) {
                    return { _0 : (0i64 : GoUInt64), _1 : (-1 : stdgo.math.big.Big.Accuracy) };
                };
                if (_x._exp <= (64 : GoInt32)) {
                    var _u:GoUInt64 = _msb64(_x._mant) >> ((64u32 : GoUInt32) - (_x._exp : GoUInt32));
                    if (_x.minPrec() <= (64u32 : GoUInt)) {
                        return { _0 : _u, _1 : (0 : stdgo.math.big.Big.Accuracy) };
                    };
                    return { _0 : _u, _1 : (-1 : stdgo.math.big.Big.Accuracy) };
                };
                return { _0 : (-1i64 : GoUInt64), _1 : (-1 : stdgo.math.big.Big.Accuracy) };
            } else if (__value__ == ((0 : stdgo.math.big.Big.T_form))) {
                return { _0 : (0i64 : GoUInt64), _1 : (0 : stdgo.math.big.Big.Accuracy) };
            } else if (__value__ == ((2 : stdgo.math.big.Big.T_form))) {
                if (_x._neg) {
                    return { _0 : (0i64 : GoUInt64), _1 : (1 : stdgo.math.big.Big.Accuracy) };
                };
                return { _0 : (-1i64 : GoUInt64), _1 : (-1 : stdgo.math.big.Big.Accuracy) };
            };
        };
        throw Go.toInterface(("unreachable" : GoString));
    }
    /**
        // Copy sets z to x, with the same precision, rounding mode, and
        // accuracy as x, and returns z. x is not changed even if z and
        // x are the same.
    **/
    @:keep
    static public function copy( _z:Ref<Float_>, _x:Ref<Float_>):Ref<Float_> {
        if (false) {
            _x._validate();
        };
        if (_z != (_x)) {
            _z._prec = _x._prec;
            _z._mode = _x._mode;
            _z._acc = _x._acc;
            _z._form = _x._form;
            _z._neg = _x._neg;
            if (_z._form == ((1 : stdgo.math.big.Big.T_form))) {
                _z._mant = _z._mant._set(_x._mant);
                _z._exp = _x._exp;
            };
        };
        return _z;
    }
    /**
        // Set sets z to the (possibly rounded) value of x and returns z.
        // If z's precision is 0, it is changed to the precision of x
        // before setting z (and rounding will have no effect).
        // Rounding is performed according to z's precision and rounding
        // mode; and z's accuracy reports the result error relative to the
        // exact (not rounded) result.
    **/
    @:keep
    static public function set( _z:Ref<Float_>, _x:Ref<Float_>):Ref<Float_> {
        if (false) {
            _x._validate();
        };
        _z._acc = (0 : stdgo.math.big.Big.Accuracy);
        if (_z != (_x)) {
            _z._form = _x._form;
            _z._neg = _x._neg;
            if (_x._form == ((1 : stdgo.math.big.Big.T_form))) {
                _z._exp = _x._exp;
                _z._mant = _z._mant._set(_x._mant);
            };
            if (_z._prec == ((0u32 : GoUInt32))) {
                _z._prec = _x._prec;
            } else if (_z._prec < _x._prec) {
                _z._round((0u32 : GoUInt));
            };
        };
        return _z;
    }
    /**
        // SetInf sets z to the infinite Float -Inf if signbit is
        // set, or +Inf if signbit is not set, and returns z. The
        // precision of z is unchanged and the result is always
        // Exact.
    **/
    @:keep
    static public function setInf( _z:Ref<Float_>, _signbit:Bool):Ref<Float_> {
        _z._acc = (0 : stdgo.math.big.Big.Accuracy);
        _z._form = (2 : stdgo.math.big.Big.T_form);
        _z._neg = _signbit;
        return _z;
    }
    /**
        // SetRat sets z to the (possibly rounded) value of x and returns z.
        // If z's precision is 0, it is changed to the largest of a.BitLen(),
        // b.BitLen(), or 64; with x = a/b.
    **/
    @:keep
    static public function setRat( _z:Ref<Float_>, _x:Ref<Rat>):Ref<Float_> {
        if (_x.isInt()) {
            return _z.setInt(_x.num());
        };
        var __0:Float_ = ({} : stdgo.math.big.Big.Float_), __1:Float_ = ({} : stdgo.math.big.Big.Float_), _b:Float_ = __1, _a:Float_ = __0;
        _a.setInt(_x.num());
        _b.setInt(_x.denom());
        if (_z._prec == ((0u32 : GoUInt32))) {
            _z._prec = _umax32(_a._prec, _b._prec);
        };
        return _z.quo((Go.setRef(_a) : Ref<stdgo.math.big.Big.Float_>), (Go.setRef(_b) : Ref<stdgo.math.big.Big.Float_>));
    }
    /**
        // SetInt sets z to the (possibly rounded) value of x and returns z.
        // If z's precision is 0, it is changed to the larger of x.BitLen()
        // or 64 (and rounding will have no effect).
    **/
    @:keep
    static public function setInt( _z:Ref<Float_>, _x:Ref<Int_>):Ref<Float_> {
        var _bits:GoUInt32 = (_x.bitLen() : GoUInt32);
        if (_z._prec == ((0u32 : GoUInt32))) {
            _z._prec = _umax32(_bits, (64u32 : GoUInt32));
        };
        _z._acc = (0 : stdgo.math.big.Big.Accuracy);
        _z._neg = _x._neg;
        if ((_x._abs.length) == ((0 : GoInt))) {
            _z._form = (0 : stdgo.math.big.Big.T_form);
            return _z;
        };
        _z._mant = _z._mant._set(_x._abs);
        _fnorm(_z._mant);
        _z._setExpAndRound((_bits : GoInt64), (0u32 : GoUInt));
        return _z;
    }
    /**
        // SetFloat64 sets z to the (possibly rounded) value of x and returns z.
        // If z's precision is 0, it is changed to 53 (and rounding will have
        // no effect). SetFloat64 panics with ErrNaN if x is a NaN.
    **/
    @:keep
    static public function setFloat64( _z:Ref<Float_>, _x:GoFloat64):Ref<Float_> {
        if (_z._prec == ((0u32 : GoUInt32))) {
            _z._prec = (53u32 : GoUInt32);
        };
        if (stdgo.math.Math.isNaN(_x)) {
            throw Go.toInterface(Go.asInterface((new ErrNaN(("Float.SetFloat64(NaN)" : GoString)) : ErrNaN)));
        };
        _z._acc = (0 : stdgo.math.big.Big.Accuracy);
        _z._neg = stdgo.math.Math.signbit(_x);
        if (_x == (0 : GoFloat64)) {
            _z._form = (0 : stdgo.math.big.Big.T_form);
            return _z;
        };
        if (stdgo.math.Math.isInf(_x, (0 : GoInt))) {
            _z._form = (2 : stdgo.math.big.Big.T_form);
            return _z;
        };
        _z._form = (1 : stdgo.math.big.Big.T_form);
        var __tmp__ = stdgo.math.Math.frexp(_x), _fmant:GoFloat64 = __tmp__._0, _exp:GoInt = __tmp__._1;
        _z._mant = _z._mant._setUint64((-9223372036854775808i64 : GoUInt64) | (stdgo.math.Math.float64bits(_fmant) << (11i64 : GoUInt64)));
        _z._exp = (_exp : GoInt32);
        if (_z._prec < (53u32 : GoUInt32)) {
            _z._round((0u32 : GoUInt));
        };
        return _z;
    }
    /**
        // SetInt64 sets z to the (possibly rounded) value of x and returns z.
        // If z's precision is 0, it is changed to 64 (and rounding will have
        // no effect).
    **/
    @:keep
    static public function setInt64( _z:Ref<Float_>, _x:GoInt64):Ref<Float_> {
        var _u:GoInt64 = _x;
        if (_u < (0i64 : GoInt64)) {
            _u = -_u;
        };
        return _z._setBits64(_x < (0i64 : GoInt64), (_u : GoUInt64));
    }
    /**
        // SetUint64 sets z to the (possibly rounded) value of x and returns z.
        // If z's precision is 0, it is changed to 64 (and rounding will have
        // no effect).
    **/
    @:keep
    static public function setUint64( _z:Ref<Float_>, _x:GoUInt64):Ref<Float_> {
        return _z._setBits64(false, _x);
    }
    @:keep
    static public function _setBits64( _z:Ref<Float_>, _neg:Bool, _x:GoUInt64):Ref<Float_> {
        if (_z._prec == ((0u32 : GoUInt32))) {
            _z._prec = (64u32 : GoUInt32);
        };
        _z._acc = (0 : stdgo.math.big.Big.Accuracy);
        _z._neg = _neg;
        if (_x == ((0i64 : GoUInt64))) {
            _z._form = (0 : stdgo.math.big.Big.T_form);
            return _z;
        };
        _z._form = (1 : stdgo.math.big.Big.T_form);
        var _s:GoInt = stdgo.math.bits.Bits.leadingZeros64(_x);
        _z._mant = _z._mant._setUint64(_x << (_s : GoUInt));
        _z._exp = ((64 : GoInt) - _s : GoInt32);
        if (_z._prec < (64u32 : GoUInt32)) {
            _z._round((0u32 : GoUInt));
        };
        return _z;
    }
    /**
        // round rounds z according to z.mode to z.prec bits and sets z.acc accordingly.
        // sbit must be 0 or 1 and summarizes any "sticky bit" information one might
        // have before calling round. z's mantissa must be normalized (with the msb set)
        // or empty.
        //
        // CAUTION: The rounding modes ToNegativeInf, ToPositiveInf are affected by the
        // sign of z. For correct rounding, the sign of z must be set correctly before
        // calling round.
    **/
    @:keep
    static public function _round( _z:Ref<Float_>, _sbit:GoUInt):Void {
        if (false) {
            _z._validate();
        };
        _z._acc = (0 : stdgo.math.big.Big.Accuracy);
        if (_z._form != ((1 : stdgo.math.big.Big.T_form))) {
            return;
        };
        var _m:GoUInt32 = (_z._mant.length : GoUInt32);
        var _bits:GoUInt32 = _m * (32u32 : GoUInt32);
        if (_bits <= _z._prec) {
            return;
        };
        var _r:GoUInt = ((_bits - _z._prec) - (1u32 : GoUInt32) : GoUInt);
        var _rbit:GoUInt = _z._mant._bit(_r) & (1u32 : GoUInt);
        if ((_sbit == (0u32 : GoUInt)) && ((_rbit == (0u32 : GoUInt)) || (_z._mode == (0 : stdgo.math.big.Big.RoundingMode)))) {
            _sbit = _z._mant._sticky(_r);
        };
        _sbit = _sbit & ((1u32 : GoUInt));
        var _n:GoUInt32 = (_z._prec + (31u32 : GoUInt32)) / (32u32 : GoUInt32);
        if (_m > _n) {
            Go.copySlice(_z._mant, (_z._mant.__slice__(_m - _n) : stdgo.math.big.Big.T_nat));
            _z._mant = (_z._mant.__slice__(0, _n) : stdgo.math.big.Big.T_nat);
        };
        var _ntz:GoUInt32 = (_n * (32u32 : GoUInt32)) - _z._prec;
        var _lsb:stdgo.math.big.Big.Word = ((1u32 : stdgo.math.big.Big.Word) : Word) << _ntz;
        if (_rbit | _sbit != ((0u32 : GoUInt))) {
            var _inc:Bool = false;
            {
                final __value__ = _z._mode;
                if (__value__ == ((4 : stdgo.math.big.Big.RoundingMode))) {
                    _inc = _z._neg;
                } else if (__value__ == ((2 : stdgo.math.big.Big.RoundingMode))) {} else if (__value__ == ((0 : stdgo.math.big.Big.RoundingMode))) {
                    _inc = (_rbit != (0u32 : GoUInt)) && ((_sbit != (0u32 : GoUInt)) || ((_z._mant[(0 : GoInt)] & _lsb) != (0u32 : stdgo.math.big.Big.Word)));
                } else if (__value__ == ((1 : stdgo.math.big.Big.RoundingMode))) {
                    _inc = _rbit != ((0u32 : GoUInt));
                } else if (__value__ == ((3 : stdgo.math.big.Big.RoundingMode))) {
                    _inc = true;
                } else if (__value__ == ((5 : stdgo.math.big.Big.RoundingMode))) {
                    _inc = !_z._neg;
                } else {
                    throw Go.toInterface(("unreachable" : GoString));
                };
            };
            _z._acc = _makeAcc(_inc != (_z._neg));
            if (_inc) {
                if (_addVW(_z._mant, _z._mant, _lsb) != ((0u32 : stdgo.math.big.Big.Word))) {
                    if (_z._exp >= (2147483647 : GoInt32)) {
                        _z._form = (2 : stdgo.math.big.Big.T_form);
                        return;
                    };
                    _z._exp++;
                    _shrVU(_z._mant, _z._mant, (1u32 : GoUInt));
                    {};
                    _z._mant[(_n - (1u32 : GoUInt32) : GoInt)] = _z._mant[(_n - (1u32 : GoUInt32) : GoInt)] | ((-2147483648u32 : stdgo.math.big.Big.Word));
                };
            };
        };
        _z._mant[(0 : GoInt)] = _z._mant[(0 : GoInt)] & ((_lsb - (1u32 : stdgo.math.big.Big.Word)) ^ (-1i32 : GoInt));
        if (false) {
            _z._validate();
        };
    }
    /**
        // debugging support
    **/
    @:keep
    static public function _validate( _x:Ref<Float_>):Void {
        if (true) {
            throw Go.toInterface(("validate called but debugFloat is not set" : GoString));
        };
        if (_x._form != ((1 : stdgo.math.big.Big.T_form))) {
            return;
        };
        var _m:GoInt = (_x._mant.length);
        if (_m == ((0 : GoInt))) {
            throw Go.toInterface(("nonzero finite number with empty mantissa" : GoString));
        };
        {};
        if (_x._mant[(_m - (1 : GoInt) : GoInt)] & (-2147483648u32 : stdgo.math.big.Big.Word) == ((0u32 : stdgo.math.big.Big.Word))) {
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("msb not set in last word %#x of %s" : GoString), Go.toInterface(_x._mant[(_m - (1 : GoInt) : GoInt)]), Go.toInterface(_x.text((112 : GoUInt8), (0 : GoInt)))));
        };
        if (_x._prec == ((0u32 : GoUInt32))) {
            throw Go.toInterface(("zero precision finite number" : GoString));
        };
    }
    /**
        // IsInt reports whether x is an integer.
        // Inf values are not integers.
    **/
    @:keep
    static public function isInt( _x:Ref<Float_>):Bool {
        if (false) {
            _x._validate();
        };
        if (_x._form != ((1 : stdgo.math.big.Big.T_form))) {
            return _x._form == ((0 : stdgo.math.big.Big.T_form));
        };
        if (_x._exp <= (0 : GoInt32)) {
            return false;
        };
        return (_x._prec <= (_x._exp : GoUInt32)) || (_x.minPrec() <= (_x._exp : GoUInt));
    }
    /**
        // IsInf reports whether x is +Inf or -Inf.
    **/
    @:keep
    static public function isInf( _x:Ref<Float_>):Bool {
        return _x._form == ((2 : stdgo.math.big.Big.T_form));
    }
    /**
        // Signbit reports whether x is negative or negative zero.
    **/
    @:keep
    static public function signbit( _x:Ref<Float_>):Bool {
        return _x._neg;
    }
    /**
        // SetMantExp sets z to mant  2**exp and returns z.
        // The result z has the same precision and rounding mode
        // as mant. SetMantExp is an inverse of MantExp but does
        // not require 0.5 <= |mant| < 1.0. Specifically, for a
        // given x of type *Float, SetMantExp relates to MantExp
        // as follows:
        //
        //	mant := new(Float)
        //	new(Float).SetMantExp(mant, x.MantExp(mant)).Cmp(x) == 0
        //
        // Special cases are:
        //
        //	z.SetMantExp(  0, exp) =   0
        //	z.SetMantExp(Inf, exp) = Inf
        //
        // z and mant may be the same in which case z's exponent
        // is set to exp.
    **/
    @:keep
    static public function setMantExp( _z:Ref<Float_>, _mant:Ref<Float_>, _exp:GoInt):Ref<Float_> {
        if (false) {
            _z._validate();
            _mant._validate();
        };
        _z.copy(_mant);
        if (_z._form == ((1 : stdgo.math.big.Big.T_form))) {
            _z._setExpAndRound((_z._exp : GoInt64) + (_exp : GoInt64), (0u32 : GoUInt));
        };
        return _z;
    }
    @:keep
    static public function _setExpAndRound( _z:Ref<Float_>, _exp:GoInt64, _sbit:GoUInt):Void {
        if (_exp < (-2147483648i64 : GoInt64)) {
            _z._acc = _makeAcc(_z._neg);
            _z._form = (0 : stdgo.math.big.Big.T_form);
            return;
        };
        if (_exp > (2147483647i64 : GoInt64)) {
            _z._acc = _makeAcc(!_z._neg);
            _z._form = (2 : stdgo.math.big.Big.T_form);
            return;
        };
        _z._form = (1 : stdgo.math.big.Big.T_form);
        _z._exp = (_exp : GoInt32);
        _z._round(_sbit);
    }
    /**
        // MantExp breaks x into its mantissa and exponent components
        // and returns the exponent. If a non-nil mant argument is
        // provided its value is set to the mantissa of x, with the
        // same precision and rounding mode as x. The components
        // satisfy x == mant  2**exp, with 0.5 <= |mant| < 1.0.
        // Calling MantExp with a nil argument is an efficient way to
        // get the exponent of the receiver.
        //
        // Special cases are:
        //
        //	(  0).MantExp(mant) = 0, with mant set to   0
        //	(Inf).MantExp(mant) = 0, with mant set to Inf
        //
        // x and mant may be the same in which case x is set to its
        // mantissa value.
    **/
    @:keep
    static public function mantExp( _x:Ref<Float_>, _mant:Ref<Float_>):GoInt {
        var _exp:GoInt = (0 : GoInt);
        if (false) {
            _x._validate();
        };
        if (_x._form == ((1 : stdgo.math.big.Big.T_form))) {
            _exp = (_x._exp : GoInt);
        };
        if (_mant != null && ((_mant : Dynamic).__nil__ == null || !(_mant : Dynamic).__nil__)) {
            _mant.copy(_x);
            if (_mant._form == ((1 : stdgo.math.big.Big.T_form))) {
                _mant._exp = (0 : GoInt32);
            };
        };
        return _exp;
    }
    /**
        // Sign returns:
        //
        //	-1 if x <   0
        //	 0 if x is 0
        //	+1 if x >   0
    **/
    @:keep
    static public function sign( _x:Ref<Float_>):GoInt {
        if (false) {
            _x._validate();
        };
        if (_x._form == ((0 : stdgo.math.big.Big.T_form))) {
            return (0 : GoInt);
        };
        if (_x._neg) {
            return (-1 : GoInt);
        };
        return (1 : GoInt);
    }
    /**
        // Acc returns the accuracy of x produced by the most recent
        // operation, unless explicitly documented otherwise by that
        // operation.
    **/
    @:keep
    static public function acc( _x:Ref<Float_>):Accuracy {
        return _x._acc;
    }
    /**
        // Mode returns the rounding mode of x.
    **/
    @:keep
    static public function mode( _x:Ref<Float_>):RoundingMode {
        return _x._mode;
    }
    /**
        // MinPrec returns the minimum precision required to represent x exactly
        // (i.e., the smallest prec before x.SetPrec(prec) would start rounding x).
        // The result is 0 for |x| == 0 and |x| == Inf.
    **/
    @:keep
    static public function minPrec( _x:Ref<Float_>):GoUInt {
        if (_x._form != ((1 : stdgo.math.big.Big.T_form))) {
            return (0u32 : GoUInt);
        };
        return ((_x._mant.length : GoUInt) * (32u32 : GoUInt)) - _x._mant._trailingZeroBits();
    }
    /**
        // Prec returns the mantissa precision of x in bits.
        // The result may be 0 for |x| == 0 and |x| == Inf.
    **/
    @:keep
    static public function prec( _x:Ref<Float_>):GoUInt {
        return (_x._prec : GoUInt);
    }
    /**
        // SetMode sets z's rounding mode to mode and returns an exact z.
        // z remains unchanged otherwise.
        // z.SetMode(z.Mode()) is a cheap way to set z's accuracy to Exact.
    **/
    @:keep
    static public function setMode( _z:Ref<Float_>, _mode:RoundingMode):Ref<Float_> {
        _z._mode = _mode;
        _z._acc = (0 : stdgo.math.big.Big.Accuracy);
        return _z;
    }
    /**
        // SetPrec sets z's precision to prec and returns the (possibly) rounded
        // value of z. Rounding occurs according to z's rounding mode if the mantissa
        // cannot be represented in prec bits without loss of precision.
        // SetPrec(0) maps all finite values to 0; infinite values remain unchanged.
        // If prec > MaxPrec, it is set to MaxPrec.
    **/
    @:keep
    static public function setPrec( _z:Ref<Float_>, _prec:GoUInt):Ref<Float_> {
        _z._acc = (0 : stdgo.math.big.Big.Accuracy);
        if (_prec == ((0u32 : GoUInt))) {
            _z._prec = (0u32 : GoUInt32);
            if (_z._form == ((1 : stdgo.math.big.Big.T_form))) {
                _z._acc = _makeAcc(_z._neg);
                _z._form = (0 : stdgo.math.big.Big.T_form);
            };
            return _z;
        };
        if (_prec > (-1u32 : GoUInt)) {
            _prec = (-1u32 : GoUInt);
        };
        var _old:GoUInt32 = _z._prec;
        _z._prec = (_prec : GoUInt32);
        if (_z._prec < _old) {
            _z._round((0u32 : GoUInt));
        };
        return _z;
    }
}
class ErrNaN_asInterface {
    @:keep
    public dynamic function error():GoString return __self__.value.error();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<ErrNaN>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.ErrNaN_asInterface) class ErrNaN_static_extension {
    @:keep
    static public function error( _err:ErrNaN):GoString {
        return _err._msg;
    }
}
class T_matrix_asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:keep
    public dynamic function _eql(_b:Ref<T_matrix>):Bool return __self__.value._eql(_b);
    @:keep
    public dynamic function _mul(_b:Ref<T_matrix>):Ref<T_matrix> return __self__.value._mul(_b);
    @:keep
    public dynamic function _set(_i:GoInt, _j:GoInt, _x:Ref<Rat>):Void __self__.value._set(_i, _j, _x);
    @:keep
    public dynamic function _at(_i:GoInt, _j:GoInt):Ref<Rat> return __self__.value._at(_i, _j);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_matrix>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T_matrix_asInterface) class T_matrix_static_extension {
    @:keep
    static public function string( _a:Ref<T_matrix>):GoString {
        var _s:GoString = Go.str();
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _a._n, _i++, {
                {
                    var _j:GoInt = (0 : GoInt);
                    Go.cfor(_j < _a._m, _j++, {
                        _s = _s + (stdgo.fmt.Fmt.sprintf(("\t%s" : GoString), Go.toInterface(Go.asInterface(_a._at(_i, _j)))));
                    });
                };
                _s = _s + (("\n" : GoString));
            });
        };
        return _s;
    }
    @:keep
    static public function _eql( _a:Ref<T_matrix>, _b:Ref<T_matrix>):Bool {
        if ((_a._n != _b._n) || (_a._m != _b._m)) {
            return false;
        };
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _a._n, _i++, {
                {
                    var _j:GoInt = (0 : GoInt);
                    Go.cfor(_j < _a._m, _j++, {
                        if (_a._at(_i, _j).cmp(_b._at(_i, _j)) != ((0 : GoInt))) {
                            return false;
                        };
                    });
                };
            });
        };
        return true;
    }
    @:keep
    static public function _mul( _a:Ref<T_matrix>, _b:Ref<T_matrix>):Ref<T_matrix> {
        if (_a._m != (_b._n)) {
            throw Go.toInterface(("illegal matrix multiply" : GoString));
        };
        var _c = _newMatrix(_a._n, _b._m);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _c._n, _i++, {
                {
                    var _j:GoInt = (0 : GoInt);
                    Go.cfor(_j < _c._m, _j++, {
                        var _x = newRat((0i64 : GoInt64), (1i64 : GoInt64));
                        {
                            var _k:GoInt = (0 : GoInt);
                            Go.cfor(_k < _a._m, _k++, {
                                _x.add(_x, (Go.setRef(({} : stdgo.math.big.Big.Rat)) : Ref<stdgo.math.big.Big.Rat>).mul(_a._at(_i, _k), _b._at(_k, _j)));
                            });
                        };
                        _c._set(_i, _j, _x);
                    });
                };
            });
        };
        return _c;
    }
    @:keep
    static public function _set( _a:Ref<T_matrix>, _i:GoInt, _j:GoInt, _x:Ref<Rat>):Void {
        if (!(((((0 : GoInt) <= _i) && (_i < _a._n)) && ((0 : GoInt) <= _j)) && (_j < _a._m))) {
            throw Go.toInterface(("index out of range" : GoString));
        };
        _a._a[((_i * _a._m) + _j : GoInt)] = _x;
    }
    @:keep
    static public function _at( _a:Ref<T_matrix>, _i:GoInt, _j:GoInt):Ref<Rat> {
        if (!(((((0 : GoInt) <= _i) && (_i < _a._n)) && ((0 : GoInt) <= _j)) && (_j < _a._m))) {
            throw Go.toInterface(("index out of range" : GoString));
        };
        return _a._a[((_i * _a._m) + _j : GoInt)];
    }
}
class Int__asInterface {
    /**
        // scaleDenom sets z to the product x*f.
        // If f == 0 (zero value of denominator), z is set to (a copy of) x.
    **/
    @:keep
    public dynamic function _scaleDenom(_x:Ref<Int_>, _f:T_nat):Void __self__.value._scaleDenom(_x, _f);
    /**
        // ProbablyPrime reports whether x is probably prime,
        // applying the Miller-Rabin test with n pseudorandomly chosen bases
        // as well as a Baillie-PSW test.
        //
        // If x is prime, ProbablyPrime returns true.
        // If x is chosen randomly and not prime, ProbablyPrime probably returns false.
        // The probability of returning true for a randomly chosen non-prime is at most .
        //
        // ProbablyPrime is 100% accurate for inputs less than 2.
        // See Menezes et al., Handbook of Applied Cryptography, 1997, pp. 145-149,
        // and FIPS 186-4 Appendix F for further discussion of the error probabilities.
        //
        // ProbablyPrime is not suitable for judging primes that an adversary may
        // have crafted to fool the test.
        //
        // As of Go 1.8, ProbablyPrime(0) is allowed and applies only a Baillie-PSW test.
        // Before Go 1.8, ProbablyPrime applied only the Miller-Rabin tests, and ProbablyPrime(0) panicked.
    **/
    @:keep
    public dynamic function probablyPrime(_n:GoInt):Bool return __self__.value.probablyPrime(_n);
    /**
        // UnmarshalJSON implements the json.Unmarshaler interface.
    **/
    @:keep
    public dynamic function unmarshalJSON(_text:Slice<GoByte>):Error return __self__.value.unmarshalJSON(_text);
    /**
        // MarshalJSON implements the json.Marshaler interface.
    **/
    @:keep
    public dynamic function marshalJSON():{ var _0 : Slice<GoByte>; var _1 : Error; } return __self__.value.marshalJSON();
    /**
        // UnmarshalText implements the encoding.TextUnmarshaler interface.
    **/
    @:keep
    public dynamic function unmarshalText(_text:Slice<GoByte>):Error return __self__.value.unmarshalText(_text);
    /**
        // MarshalText implements the encoding.TextMarshaler interface.
    **/
    @:keep
    public dynamic function marshalText():{ var _0 : Slice<GoByte>; var _1 : Error; } return __self__.value.marshalText();
    /**
        // GobDecode implements the gob.GobDecoder interface.
    **/
    @:keep
    public dynamic function gobDecode(_buf:Slice<GoByte>):Error return __self__.value.gobDecode(_buf);
    /**
        // GobEncode implements the gob.GobEncoder interface.
    **/
    @:keep
    public dynamic function gobEncode():{ var _0 : Slice<GoByte>; var _1 : Error; } return __self__.value.gobEncode();
    /**
        // Scan is a support routine for fmt.Scanner; it sets z to the value of
        // the scanned number. It accepts the formats 'b' (binary), 'o' (octal),
        // 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal).
    **/
    @:keep
    public dynamic function scan(_s:stdgo.fmt.Fmt.ScanState, _ch:GoRune):Error return __self__.value.scan(_s, _ch);
    /**
        // scan sets z to the integer value corresponding to the longest possible prefix
        // read from r representing a signed integer number in a given conversion base.
        // It returns z, the actual conversion base used, and an error, if any. In the
        // error case, the value of z is undefined but the returned value is nil. The
        // syntax follows the syntax of integer literals in Go.
        //
        // The base argument must be 0 or a value from 2 through MaxBase. If the base
        // is 0, the string prefix determines the actual conversion base. A prefix of
        // 0b or 0B selects base 2; a 0, 0o, or 0O prefix selects
        // base 8, and a 0x or 0X prefix selects base 16. Otherwise the selected
        // base is 10.
    **/
    @:keep
    public dynamic function _scan(_r:stdgo.io.Io.ByteScanner, _base:GoInt):{ var _0 : Ref<Int_>; var _1 : GoInt; var _2 : Error; } return __self__.value._scan(_r, _base);
    /**
        // Format implements fmt.Formatter. It accepts the formats
        // 'b' (binary), 'o' (octal with 0 prefix), 'O' (octal with 0o prefix),
        // 'd' (decimal), 'x' (lowercase hexadecimal), and
        // 'X' (uppercase hexadecimal).
        // Also supported are the full suite of package fmt's format
        // flags for integral types, including '+' and ' ' for sign
        // control, '#' for leading zero in octal and for hexadecimal,
        // a leading "0x" or "0X" for "%#x" and "%#X" respectively,
        // specification of minimum digits precision, output field
        // width, space or zero padding, and '-' for left or right
        // justification.
    **/
    @:keep
    public dynamic function format(_s:stdgo.fmt.Fmt.State, _ch:GoRune):Void __self__.value.format(_s, _ch);
    /**
        // String returns the decimal representation of x as generated by
        // x.Text(10).
    **/
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    /**
        // Append appends the string representation of x, as generated by
        // x.Text(base), to buf and returns the extended buffer.
    **/
    @:keep
    public dynamic function append(_buf:Slice<GoByte>, _base:GoInt):Slice<GoByte> return __self__.value.append(_buf, _base);
    /**
        // Text returns the string representation of x in the given base.
        // Base must be between 2 and 62, inclusive. The result uses the
        // lower-case letters 'a' to 'z' for digit values 10 to 35, and
        // the upper-case letters 'A' to 'Z' for digit values 36 to 61.
        // No prefix (such as "0x") is added to the string. If x is a nil
        // pointer it returns "<nil>".
    **/
    @:keep
    public dynamic function text(_base:GoInt):GoString return __self__.value.text(_base);
    /**
        // Sqrt sets z to x, the largest integer such that z  x, and returns z.
        // It panics if x is negative.
    **/
    @:keep
    public dynamic function sqrt(_x:Ref<Int_>):Ref<Int_> return __self__.value.sqrt(_x);
    /**
        // Not sets z = ^x and returns z.
    **/
    @:keep
    public dynamic function not(_x:Ref<Int_>):Ref<Int_> return __self__.value.not(_x);
    /**
        // Xor sets z = x ^ y and returns z.
    **/
    @:keep
    public dynamic function xor(_x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> return __self__.value.xor(_x, _y);
    /**
        // Or sets z = x | y and returns z.
    **/
    @:keep
    public dynamic function or(_x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> return __self__.value.or(_x, _y);
    /**
        // AndNot sets z = x &^ y and returns z.
    **/
    @:keep
    public dynamic function andNot(_x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> return __self__.value.andNot(_x, _y);
    /**
        // And sets z = x & y and returns z.
    **/
    @:keep
    public dynamic function and(_x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> return __self__.value.and(_x, _y);
    /**
        // SetBit sets z to x, with x's i'th bit set to b (0 or 1).
        // That is, if b is 1 SetBit sets z = x | (1 << i);
        // if b is 0 SetBit sets z = x &^ (1 << i). If b is not 0 or 1,
        // SetBit will panic.
    **/
    @:keep
    public dynamic function setBit(_x:Ref<Int_>, _i:GoInt, _b:GoUInt):Ref<Int_> return __self__.value.setBit(_x, _i, _b);
    /**
        // Bit returns the value of the i'th bit of x. That is, it
        // returns (x>>i)&1. The bit index i must be >= 0.
    **/
    @:keep
    public dynamic function bit(_i:GoInt):GoUInt return __self__.value.bit(_i);
    /**
        // Rsh sets z = x >> n and returns z.
    **/
    @:keep
    public dynamic function rsh(_x:Ref<Int_>, _n:GoUInt):Ref<Int_> return __self__.value.rsh(_x, _n);
    /**
        // Lsh sets z = x << n and returns z.
    **/
    @:keep
    public dynamic function lsh(_x:Ref<Int_>, _n:GoUInt):Ref<Int_> return __self__.value.lsh(_x, _n);
    /**
        // ModSqrt sets z to a square root of x mod p if such a square root exists, and
        // returns z. The modulus p must be an odd prime. If x is not a square mod p,
        // ModSqrt leaves z unchanged and returns nil. This function panics if p is
        // not an odd integer, its behavior is undefined if p is odd but not prime.
    **/
    @:keep
    public dynamic function modSqrt(_x:Ref<Int_>, _p:Ref<Int_>):Ref<Int_> return __self__.value.modSqrt(_x, _p);
    /**
        // modSqrtTonelliShanks uses the Tonelli-Shanks algorithm to find the square
        // root of a quadratic residue modulo any prime.
    **/
    @:keep
    public dynamic function _modSqrtTonelliShanks(_x:Ref<Int_>, _p:Ref<Int_>):Ref<Int_> return __self__.value._modSqrtTonelliShanks(_x, _p);
    /**
        // modSqrt5Mod8 uses Atkin's observation that 2 is not a square mod p
        //
        //	alpha ==  (2*a)^((p-5)/8)    mod p
        //	beta  ==  2*a*alpha^2        mod p  is a square root of -1
        //	b     ==  a*alpha*(beta-1)   mod p  is a square root of a
        //
        // to calculate the square root of any quadratic residue mod p quickly for 5
        // mod 8 primes.
    **/
    @:keep
    public dynamic function _modSqrt5Mod8Prime(_x:Ref<Int_>, _p:Ref<Int_>):Ref<Int_> return __self__.value._modSqrt5Mod8Prime(_x, _p);
    /**
        // modSqrt3Mod4 uses the identity
        //
        //	   (a^((p+1)/4))^2  mod p
        //	== u^(p+1)          mod p
        //	== u^2              mod p
        //
        // to calculate the square root of any quadratic residue mod p quickly for 3
        // mod 4 primes.
    **/
    @:keep
    public dynamic function _modSqrt3Mod4Prime(_x:Ref<Int_>, _p:Ref<Int_>):Ref<Int_> return __self__.value._modSqrt3Mod4Prime(_x, _p);
    /**
        // ModInverse sets z to the multiplicative inverse of g in the ring /n
        // and returns z. If g and n are not relatively prime, g has no multiplicative
        // inverse in the ring /n.  In this case, z is unchanged and the return value
        // is nil. If n == 0, a division-by-zero run-time panic occurs.
    **/
    @:keep
    public dynamic function modInverse(_g:Ref<Int_>, _n:Ref<Int_>):Ref<Int_> return __self__.value.modInverse(_g, _n);
    /**
        // Rand sets z to a pseudo-random number in [0, n) and returns z.
        //
        // As this uses the math/rand package, it must not be used for
        // security-sensitive work. Use crypto/rand.Int instead.
    **/
    @:keep
    public dynamic function rand(_rnd:Ref<stdgo.math.rand.Rand.Rand>, _n:Ref<Int_>):Ref<Int_> return __self__.value.rand(_rnd, _n);
    /**
        // lehmerGCD sets z to the greatest common divisor of a and b,
        // which both must be != 0, and returns z.
        // If x or y are not nil, their values are set such that z = a*x + b*y.
        // See Knuth, The Art of Computer Programming, Vol. 2, Section 4.5.2, Algorithm L.
        // This implementation uses the improved condition by Collins requiring only one
        // quotient and avoiding the possibility of single Word overflow.
        // See Jebelean, "Improving the multiprecision Euclidean algorithm",
        // Design and Implementation of Symbolic Computation Systems, pp 45-58.
        // The cosequences are updated according to Algorithm 10.45 from
        // Cohen et al. "Handbook of Elliptic and Hyperelliptic Curve Cryptography" pp 192.
    **/
    @:keep
    public dynamic function _lehmerGCD(_x:Ref<Int_>, _y:Ref<Int_>, _a:Ref<Int_>, _b:Ref<Int_>):Ref<Int_> return __self__.value._lehmerGCD(_x, _y, _a, _b);
    /**
        // GCD sets z to the greatest common divisor of a and b and returns z.
        // If x or y are not nil, GCD sets their value such that z = a*x + b*y.
        //
        // a and b may be positive, zero or negative. (Before Go 1.14 both had
        // to be > 0.) Regardless of the signs of a and b, z is always >= 0.
        //
        // If a == b == 0, GCD sets z = x = y = 0.
        //
        // If a == 0 and b != 0, GCD sets z = |b|, x = 0, y = sign(b) * 1.
        //
        // If a != 0 and b == 0, GCD sets z = |a|, x = sign(a) * 1, y = 0.
    **/
    @:keep
    public dynamic function gcd(_x:Ref<Int_>, _y:Ref<Int_>, _a:Ref<Int_>, _b:Ref<Int_>):Ref<Int_> return __self__.value.gcd(_x, _y, _a, _b);
    @:keep
    public dynamic function _exp(_x:Ref<Int_>, _y:Ref<Int_>, _m:Ref<Int_>, _slow:Bool):Ref<Int_> return __self__.value._exp(_x, _y, _m, _slow);
    @:keep
    public dynamic function _expSlow(_x:Ref<Int_>, _y:Ref<Int_>, _m:Ref<Int_>):Ref<Int_> return __self__.value._expSlow(_x, _y, _m);
    /**
        // Exp sets z = x**y mod |m| (i.e. the sign of m is ignored), and returns z.
        // If m == nil or m == 0, z = x**y unless y <= 0 then z = 1. If m != 0, y < 0,
        // and x and m are not relatively prime, z is unchanged and nil is returned.
        //
        // Modular exponentiation of inputs of a particular size is not a
        // cryptographically constant-time operation.
    **/
    @:keep
    public dynamic function exp(_x:Ref<Int_>, _y:Ref<Int_>, _m:Ref<Int_>):Ref<Int_> return __self__.value.exp(_x, _y, _m);
    /**
        // TrailingZeroBits returns the number of consecutive least significant zero
        // bits of |x|.
    **/
    @:keep
    public dynamic function trailingZeroBits():GoUInt return __self__.value.trailingZeroBits();
    /**
        // BitLen returns the length of the absolute value of x in bits.
        // The bit length of 0 is 0.
    **/
    @:keep
    public dynamic function bitLen():GoInt return __self__.value.bitLen();
    /**
        // FillBytes sets buf to the absolute value of x, storing it as a zero-extended
        // big-endian byte slice, and returns buf.
        //
        // If the absolute value of x doesn't fit in buf, FillBytes will panic.
    **/
    @:keep
    public dynamic function fillBytes(_buf:Slice<GoByte>):Slice<GoByte> return __self__.value.fillBytes(_buf);
    /**
        // Bytes returns the absolute value of x as a big-endian byte slice.
        //
        // To use a fixed length slice, or a preallocated one, use FillBytes.
    **/
    @:keep
    public dynamic function bytes():Slice<GoByte> return __self__.value.bytes();
    /**
        // SetBytes interprets buf as the bytes of a big-endian unsigned
        // integer, sets z to that value, and returns z.
    **/
    @:keep
    public dynamic function setBytes(_buf:Slice<GoByte>):Ref<Int_> return __self__.value.setBytes(_buf);
    /**
        // setFromScanner implements SetString given an io.ByteScanner.
        // For documentation see comments of SetString.
    **/
    @:keep
    public dynamic function _setFromScanner(_r:stdgo.io.Io.ByteScanner, _base:GoInt):{ var _0 : Ref<Int_>; var _1 : Bool; } return __self__.value._setFromScanner(_r, _base);
    /**
        // SetString sets z to the value of s, interpreted in the given base,
        // and returns z and a boolean indicating success. The entire string
        // (not just a prefix) must be valid for success. If SetString fails,
        // the value of z is undefined but the returned value is nil.
        //
        // The base argument must be 0 or a value between 2 and MaxBase.
        // For base 0, the number prefix determines the actual base: A prefix of
        // 0b or 0B selects base 2, 0, 0o or 0O selects base 8,
        // and 0x or 0X selects base 16. Otherwise, the selected base is 10
        // and no prefix is accepted.
        //
        // For bases <= 36, lower and upper case letters are considered the same:
        // The letters 'a' to 'z' and 'A' to 'Z' represent digit values 10 to 35.
        // For bases > 36, the upper case letters 'A' to 'Z' represent the digit
        // values 36 to 61.
        //
        // For base 0, an underscore character _ may appear between a base
        // prefix and an adjacent digit, and between successive digits; such
        // underscores do not change the value of the number.
        // Incorrect placement of underscores is reported as an error if there
        // are no other errors. If base != 0, underscores are not recognized
        // and act like any other character that is not a valid digit.
    **/
    @:keep
    public dynamic function setString(_s:GoString, _base:GoInt):{ var _0 : Ref<Int_>; var _1 : Bool; } return __self__.value.setString(_s, _base);
    /**
        // IsUint64 reports whether x can be represented as a uint64.
    **/
    @:keep
    public dynamic function isUint64():Bool return __self__.value.isUint64();
    /**
        // IsInt64 reports whether x can be represented as an int64.
    **/
    @:keep
    public dynamic function isInt64():Bool return __self__.value.isInt64();
    /**
        // Uint64 returns the uint64 representation of x.
        // If x cannot be represented in a uint64, the result is undefined.
    **/
    @:keep
    public dynamic function uint64():GoUInt64 return __self__.value.uint64();
    /**
        // Int64 returns the int64 representation of x.
        // If x cannot be represented in an int64, the result is undefined.
    **/
    @:keep
    public dynamic function int64():GoInt64 return __self__.value.int64();
    /**
        // CmpAbs compares the absolute values of x and y and returns:
        //
        //	-1 if |x| <  |y|
        //	 0 if |x| == |y|
        //	+1 if |x| >  |y|
    **/
    @:keep
    public dynamic function cmpAbs(_y:Ref<Int_>):GoInt return __self__.value.cmpAbs(_y);
    /**
        // Cmp compares x and y and returns:
        //
        //	-1 if x <  y
        //	 0 if x == y
        //	+1 if x >  y
    **/
    @:keep
    public dynamic function cmp(_y:Ref<Int_>):GoInt return __self__.value.cmp(_y);
    /**
        // DivMod sets z to the quotient x div y and m to the modulus x mod y
        // and returns the pair (z, m) for y != 0.
        // If y == 0, a division-by-zero run-time panic occurs.
        //
        // DivMod implements Euclidean division and modulus (unlike Go):
        //
        //	q = x div y  such that
        //	m = x - y*q  with 0 <= m < |y|
        //
        // (See Raymond T. Boute, The Euclidean definition of the functions
        // div and mod. ACM Transactions on Programming Languages and
        // Systems (TOPLAS), 14(2):127-144, New York, NY, USA, 4/1992.
        // ACM press.)
        // See QuoRem for T-division and modulus (like Go).
    **/
    @:keep
    public dynamic function divMod(_x:Ref<Int_>, _y:Ref<Int_>, _m:Ref<Int_>):{ var _0 : Ref<Int_>; var _1 : Ref<Int_>; } return __self__.value.divMod(_x, _y, _m);
    /**
        // Mod sets z to the modulus x%y for y != 0 and returns z.
        // If y == 0, a division-by-zero run-time panic occurs.
        // Mod implements Euclidean modulus (unlike Go); see DivMod for more details.
    **/
    @:keep
    public dynamic function mod(_x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> return __self__.value.mod(_x, _y);
    /**
        // Div sets z to the quotient x/y for y != 0 and returns z.
        // If y == 0, a division-by-zero run-time panic occurs.
        // Div implements Euclidean division (unlike Go); see DivMod for more details.
    **/
    @:keep
    public dynamic function div(_x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> return __self__.value.div(_x, _y);
    /**
        // QuoRem sets z to the quotient x/y and r to the remainder x%y
        // and returns the pair (z, r) for y != 0.
        // If y == 0, a division-by-zero run-time panic occurs.
        //
        // QuoRem implements T-division and modulus (like Go):
        //
        //	q = x/y      with the result truncated to zero
        //	r = x - y*q
        //
        // (See Daan Leijen, Division and Modulus for Computer Scientists.)
        // See DivMod for Euclidean division and modulus (unlike Go).
    **/
    @:keep
    public dynamic function quoRem(_x:Ref<Int_>, _y:Ref<Int_>, _r:Ref<Int_>):{ var _0 : Ref<Int_>; var _1 : Ref<Int_>; } return __self__.value.quoRem(_x, _y, _r);
    /**
        // Rem sets z to the remainder x%y for y != 0 and returns z.
        // If y == 0, a division-by-zero run-time panic occurs.
        // Rem implements truncated modulus (like Go); see QuoRem for more details.
    **/
    @:keep
    public dynamic function rem(_x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> return __self__.value.rem(_x, _y);
    /**
        // Quo sets z to the quotient x/y for y != 0 and returns z.
        // If y == 0, a division-by-zero run-time panic occurs.
        // Quo implements truncated division (like Go); see QuoRem for more details.
    **/
    @:keep
    public dynamic function quo(_x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> return __self__.value.quo(_x, _y);
    /**
        // Binomial sets z to the binomial coefficient C(n, k) and returns z.
    **/
    @:keep
    public dynamic function binomial(_n:GoInt64, _k:GoInt64):Ref<Int_> return __self__.value.binomial(_n, _k);
    /**
        // MulRange sets z to the product of all integers
        // in the range [a, b] inclusively and returns z.
        // If a > b (empty range), the result is 1.
    **/
    @:keep
    public dynamic function mulRange(_a:GoInt64, _b:GoInt64):Ref<Int_> return __self__.value.mulRange(_a, _b);
    /**
        // Mul sets z to the product x*y and returns z.
    **/
    @:keep
    public dynamic function mul(_x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> return __self__.value.mul(_x, _y);
    /**
        // Sub sets z to the difference x-y and returns z.
    **/
    @:keep
    public dynamic function sub(_x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> return __self__.value.sub(_x, _y);
    /**
        // Add sets z to the sum x+y and returns z.
    **/
    @:keep
    public dynamic function add(_x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> return __self__.value.add(_x, _y);
    /**
        // Neg sets z to -x and returns z.
    **/
    @:keep
    public dynamic function neg(_x:Ref<Int_>):Ref<Int_> return __self__.value.neg(_x);
    /**
        // Abs sets z to |x| (the absolute value of x) and returns z.
    **/
    @:keep
    public dynamic function abs(_x:Ref<Int_>):Ref<Int_> return __self__.value.abs(_x);
    /**
        // SetBits provides raw (unchecked but fast) access to z by setting its
        // value to abs, interpreted as a little-endian Word slice, and returning
        // z. The result and abs share the same underlying array.
        // SetBits is intended to support implementation of missing low-level Int
        // functionality outside this package; it should be avoided otherwise.
    **/
    @:keep
    public dynamic function setBits(_abs:Slice<Word>):Ref<Int_> return __self__.value.setBits(_abs);
    /**
        // Bits provides raw (unchecked but fast) access to x by returning its
        // absolute value as a little-endian Word slice. The result and x share
        // the same underlying array.
        // Bits is intended to support implementation of missing low-level Int
        // functionality outside this package; it should be avoided otherwise.
    **/
    @:keep
    public dynamic function bits():Slice<Word> return __self__.value.bits();
    /**
        // Set sets z to x and returns z.
    **/
    @:keep
    public dynamic function set(_x:Ref<Int_>):Ref<Int_> return __self__.value.set(_x);
    /**
        // SetUint64 sets z to x and returns z.
    **/
    @:keep
    public dynamic function setUint64(_x:GoUInt64):Ref<Int_> return __self__.value.setUint64(_x);
    /**
        // SetInt64 sets z to x and returns z.
    **/
    @:keep
    public dynamic function setInt64(_x:GoInt64):Ref<Int_> return __self__.value.setInt64(_x);
    /**
        // Sign returns:
        //
        //	-1 if x <  0
        //	 0 if x == 0
        //	+1 if x >  0
    **/
    @:keep
    public dynamic function sign():GoInt return __self__.value.sign();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Int_>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.Int__asInterface) class Int__static_extension {
    /**
        // scaleDenom sets z to the product x*f.
        // If f == 0 (zero value of denominator), z is set to (a copy of) x.
    **/
    @:keep
    static public function _scaleDenom( _z:Ref<Int_>, _x:Ref<Int_>, _f:T_nat):Void {
        if ((_f.length) == ((0 : GoInt))) {
            _z.set(_x);
            return;
        };
        _z._abs = _z._abs._mul(_x._abs, _f);
        _z._neg = _x._neg;
    }
    /**
        // ProbablyPrime reports whether x is probably prime,
        // applying the Miller-Rabin test with n pseudorandomly chosen bases
        // as well as a Baillie-PSW test.
        //
        // If x is prime, ProbablyPrime returns true.
        // If x is chosen randomly and not prime, ProbablyPrime probably returns false.
        // The probability of returning true for a randomly chosen non-prime is at most .
        //
        // ProbablyPrime is 100% accurate for inputs less than 2.
        // See Menezes et al., Handbook of Applied Cryptography, 1997, pp. 145-149,
        // and FIPS 186-4 Appendix F for further discussion of the error probabilities.
        //
        // ProbablyPrime is not suitable for judging primes that an adversary may
        // have crafted to fool the test.
        //
        // As of Go 1.8, ProbablyPrime(0) is allowed and applies only a Baillie-PSW test.
        // Before Go 1.8, ProbablyPrime applied only the Miller-Rabin tests, and ProbablyPrime(0) panicked.
    **/
    @:keep
    static public function probablyPrime( _x:Ref<Int_>, _n:GoInt):Bool {
        if (_n < (0 : GoInt)) {
            throw Go.toInterface(("negative n for ProbablyPrime" : GoString));
        };
        if (_x._neg || (_x._abs.length == (0 : GoInt))) {
            return false;
        };
        {};
        var _w:stdgo.math.big.Big.Word = _x._abs[(0 : GoInt)];
        if ((_x._abs.length == (1 : GoInt)) && (_w < (64u32 : stdgo.math.big.Big.Word))) {
            return (2891462833508853932i64 : GoUInt64) & ((1i64 : GoUInt64) << _w) != ((0i64 : GoUInt64));
        };
        if (_w & (1u32 : stdgo.math.big.Big.Word) == ((0u32 : stdgo.math.big.Big.Word))) {
            return false;
        };
        {};
        {};
        var __0:GoUInt32 = (0 : GoUInt32), __1:GoUInt32 = (0 : GoUInt32), _rB:GoUInt32 = __1, _rA:GoUInt32 = __0;
        {
            final __value__ = (32 : GoInt);
            if (__value__ == ((32 : GoInt))) {
                _rA = (_x._abs._modW((-167749201u32 : stdgo.math.big.Big.Word)) : GoUInt32);
                _rB = (_x._abs._modW((-346889229u32 : stdgo.math.big.Big.Word)) : GoUInt32);
            } else if (__value__ == ((64 : GoInt))) {
                var _r:stdgo.math.big.Big.Word = _x._abs._modW((820596253u32 : stdgo.math.big.Big.Word));
                _rA = (_r % (-167749201u32 : stdgo.math.big.Big.Word) : GoUInt32);
                _rB = (_r % (-346889229u32 : stdgo.math.big.Big.Word) : GoUInt32);
            } else {
                throw Go.toInterface(("math/big: invalid word size" : GoString));
            };
        };
        if ((((((((((((((((_rA % (3u32 : GoUInt32)) == (0u32 : GoUInt32)) || ((_rA % (5u32 : GoUInt32)) == (0u32 : GoUInt32))) || ((_rA % (7u32 : GoUInt32)) == (0u32 : GoUInt32))) || ((_rA % (11u32 : GoUInt32)) == (0u32 : GoUInt32))) || ((_rA % (13u32 : GoUInt32)) == (0u32 : GoUInt32))) || ((_rA % (17u32 : GoUInt32)) == (0u32 : GoUInt32))) || ((_rA % (19u32 : GoUInt32)) == (0u32 : GoUInt32))) || ((_rA % (23u32 : GoUInt32)) == (0u32 : GoUInt32))) || ((_rA % (37u32 : GoUInt32)) == (0u32 : GoUInt32))) || ((_rB % (29u32 : GoUInt32)) == (0u32 : GoUInt32))) || ((_rB % (31u32 : GoUInt32)) == (0u32 : GoUInt32))) || ((_rB % (41u32 : GoUInt32)) == (0u32 : GoUInt32))) || ((_rB % (43u32 : GoUInt32)) == (0u32 : GoUInt32))) || ((_rB % (47u32 : GoUInt32)) == (0u32 : GoUInt32))) || ((_rB % (53u32 : GoUInt32)) == (0u32 : GoUInt32))) {
            return false;
        };
        return _x._abs._probablyPrimeMillerRabin(_n + (1 : GoInt), true) && _x._abs._probablyPrimeLucas();
    }
    /**
        // UnmarshalJSON implements the json.Unmarshaler interface.
    **/
    @:keep
    static public function unmarshalJSON( _z:Ref<Int_>, _text:Slice<GoByte>):Error {
        if ((_text : GoString) == (("null" : GoString))) {
            return (null : Error);
        };
        return _z.unmarshalText(_text);
    }
    /**
        // MarshalJSON implements the json.Marshaler interface.
    **/
    @:keep
    static public function marshalJSON( _x:Ref<Int_>):{ var _0 : Slice<GoByte>; var _1 : Error; } {
        if (_x == null || (_x : Dynamic).__nil__) {
            return { _0 : (("null" : GoString) : Slice<GoByte>), _1 : (null : Error) };
        };
        return { _0 : _x._abs._itoa(_x._neg, (10 : GoInt)), _1 : (null : Error) };
    }
    /**
        // UnmarshalText implements the encoding.TextUnmarshaler interface.
    **/
    @:keep
    static public function unmarshalText( _z:Ref<Int_>, _text:Slice<GoByte>):Error {
        {
            var __tmp__ = _z._setFromScanner(Go.asInterface(stdgo.bytes.Bytes.newReader(_text)), (0 : GoInt)), __0:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                return stdgo.fmt.Fmt.errorf(("math/big: cannot unmarshal %q into a *big.Int" : GoString), Go.toInterface(_text));
            };
        };
        return (null : Error);
    }
    /**
        // MarshalText implements the encoding.TextMarshaler interface.
    **/
    @:keep
    static public function marshalText( _x:Ref<Int_>):{ var _0 : Slice<GoByte>; var _1 : Error; } {
        var _text:Slice<GoByte> = (null : Slice<GoUInt8>), _err:Error = (null : Error);
        if (_x == null || (_x : Dynamic).__nil__) {
            return { _0 : (("<nil>" : GoString) : Slice<GoByte>), _1 : (null : Error) };
        };
        return { _0 : _x._abs._itoa(_x._neg, (10 : GoInt)), _1 : (null : Error) };
    }
    /**
        // GobDecode implements the gob.GobDecoder interface.
    **/
    @:keep
    static public function gobDecode( _z:Ref<Int_>, _buf:Slice<GoByte>):Error {
        if ((_buf.length) == ((0 : GoInt))) {
            {
                var __tmp__ = (new Int_() : Int_);
                _z._neg = __tmp__._neg;
                _z._abs = __tmp__._abs;
            };
            return (null : Error);
        };
        var _b:GoUInt8 = _buf[(0 : GoInt)];
        if (_b >> (1i64 : GoUInt64) != ((1 : GoUInt8))) {
            return stdgo.fmt.Fmt.errorf(("Int.GobDecode: encoding version %d not supported" : GoString), Go.toInterface(_b >> (1i64 : GoUInt64)));
        };
        _z._neg = _b & (1 : GoUInt8) != ((0 : GoUInt8));
        _z._abs = _z._abs._setBytes((_buf.__slice__((1 : GoInt)) : Slice<GoUInt8>));
        return (null : Error);
    }
    /**
        // GobEncode implements the gob.GobEncoder interface.
    **/
    @:keep
    static public function gobEncode( _x:Ref<Int_>):{ var _0 : Slice<GoByte>; var _1 : Error; } {
        if (_x == null || (_x : Dynamic).__nil__) {
            return { _0 : (null : Slice<GoUInt8>), _1 : (null : Error) };
        };
        var _buf = new Slice<GoUInt8>(((1 : GoInt) + (_x._abs.length * (4 : GoInt)) : GoInt).toBasic(), 0, ...[for (i in 0 ... ((1 : GoInt) + (_x._abs.length * (4 : GoInt)) : GoInt).toBasic()) (0 : GoUInt8)]);
        var _i:GoInt = _x._abs._bytes(_buf) - (1 : GoInt);
        var _b:GoUInt8 = (2 : GoUInt8);
        if (_x._neg) {
            _b = _b | ((1 : GoUInt8));
        };
        _buf[(_i : GoInt)] = _b;
        return { _0 : (_buf.__slice__(_i) : Slice<GoUInt8>), _1 : (null : Error) };
    }
    /**
        // Scan is a support routine for fmt.Scanner; it sets z to the value of
        // the scanned number. It accepts the formats 'b' (binary), 'o' (octal),
        // 'd' (decimal), 'x' (lowercase hexadecimal), and 'X' (uppercase hexadecimal).
    **/
    @:keep
    static public function scan( _z:Ref<Int_>, _s:stdgo.fmt.Fmt.ScanState, _ch:GoRune):Error {
        _s.skipSpace();
        var _base:GoInt = (0 : GoInt);
        {
            final __value__ = _ch;
            if (__value__ == ((98 : GoInt32))) {
                _base = (2 : GoInt);
            } else if (__value__ == ((111 : GoInt32))) {
                _base = (8 : GoInt);
            } else if (__value__ == ((100 : GoInt32))) {
                _base = (10 : GoInt);
            } else if (__value__ == ((120 : GoInt32)) || __value__ == ((88 : GoInt32))) {
                _base = (16 : GoInt);
            } else if (__value__ == ((115 : GoInt32)) || __value__ == ((118 : GoInt32))) {} else {
                return stdgo.errors.Errors.new_(("Int.Scan: invalid verb" : GoString));
            };
        };
        var __tmp__ = _z._scan(Go.asInterface((new T_byteReader(_s) : T_byteReader)), _base), __0:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __1:GoInt = __tmp__._1, _err:Error = __tmp__._2;
        return _err;
    }
    /**
        // scan sets z to the integer value corresponding to the longest possible prefix
        // read from r representing a signed integer number in a given conversion base.
        // It returns z, the actual conversion base used, and an error, if any. In the
        // error case, the value of z is undefined but the returned value is nil. The
        // syntax follows the syntax of integer literals in Go.
        //
        // The base argument must be 0 or a value from 2 through MaxBase. If the base
        // is 0, the string prefix determines the actual conversion base. A prefix of
        // 0b or 0B selects base 2; a 0, 0o, or 0O prefix selects
        // base 8, and a 0x or 0X prefix selects base 16. Otherwise the selected
        // base is 10.
    **/
    @:keep
    static public function _scan( _z:Ref<Int_>, _r:stdgo.io.Io.ByteScanner, _base:GoInt):{ var _0 : Ref<Int_>; var _1 : GoInt; var _2 : Error; } {
        var __tmp__ = _scanSign(_r), _neg:Bool = __tmp__._0, _err:Error = __tmp__._1;
        if (_err != null) {
            return { _0 : null, _1 : (0 : GoInt), _2 : _err };
        };
        {
            var __tmp__ = _z._abs._scan(_r, _base, false);
            _z._abs = __tmp__._0;
            _base = __tmp__._1;
            _err = __tmp__._3;
        };
        if (_err != null) {
            return { _0 : null, _1 : _base, _2 : _err };
        };
        _z._neg = (_z._abs.length > (0 : GoInt)) && _neg;
        return { _0 : _z, _1 : _base, _2 : (null : Error) };
    }
    /**
        // Format implements fmt.Formatter. It accepts the formats
        // 'b' (binary), 'o' (octal with 0 prefix), 'O' (octal with 0o prefix),
        // 'd' (decimal), 'x' (lowercase hexadecimal), and
        // 'X' (uppercase hexadecimal).
        // Also supported are the full suite of package fmt's format
        // flags for integral types, including '+' and ' ' for sign
        // control, '#' for leading zero in octal and for hexadecimal,
        // a leading "0x" or "0X" for "%#x" and "%#X" respectively,
        // specification of minimum digits precision, output field
        // width, space or zero padding, and '-' for left or right
        // justification.
    **/
    @:keep
    static public function format( _x:Ref<Int_>, _s:stdgo.fmt.Fmt.State, _ch:GoRune):Void {
        var _base:GoInt = (0 : GoInt);
        {
            final __value__ = _ch;
            if (__value__ == ((98 : GoInt32))) {
                _base = (2 : GoInt);
            } else if (__value__ == ((111 : GoInt32)) || __value__ == ((79 : GoInt32))) {
                _base = (8 : GoInt);
            } else if (__value__ == ((100 : GoInt32)) || __value__ == ((115 : GoInt32)) || __value__ == ((118 : GoInt32))) {
                _base = (10 : GoInt);
            } else if (__value__ == ((120 : GoInt32)) || __value__ == ((88 : GoInt32))) {
                _base = (16 : GoInt);
            } else {
                stdgo.fmt.Fmt.fprintf(_s, ("%%!%c(big.Int=%s)" : GoString), Go.toInterface(_ch), Go.toInterface((_x.string() : GoString)));
                return;
            };
        };
        if (_x == null || (_x : Dynamic).__nil__) {
            stdgo.fmt.Fmt.fprint(_s, Go.toInterface(("<nil>" : GoString)));
            return;
        };
        var _sign:GoString = Go.str();
        if (_x._neg) {
            _sign = ("-" : GoString);
        } else if (_s.flag((43 : GoInt))) {
            _sign = ("+" : GoString);
        } else if (_s.flag((32 : GoInt))) {
            _sign = (" " : GoString);
        };
        var _prefix:GoString = Go.str();
        if (_s.flag((35 : GoInt))) {
            {
                final __value__ = _ch;
                if (__value__ == ((98 : GoInt32))) {
                    _prefix = ("0b" : GoString);
                } else if (__value__ == ((111 : GoInt32))) {
                    _prefix = ("0" : GoString);
                } else if (__value__ == ((120 : GoInt32))) {
                    _prefix = ("0x" : GoString);
                } else if (__value__ == ((88 : GoInt32))) {
                    _prefix = ("0X" : GoString);
                };
            };
        };
        if (_ch == ((79 : GoInt32))) {
            _prefix = ("0o" : GoString);
        };
        var _digits = _x._abs._utoa(_base);
        if (_ch == ((88 : GoInt32))) {
            for (_i => _d in _digits) {
                if (((97 : GoUInt8) <= _d) && (_d <= (122 : GoUInt8))) {
                    _digits[(_i : GoInt)] = (65 : GoUInt8) + (_d - (97 : GoUInt8));
                };
            };
        };
        var _left:GoInt = (0 : GoInt);
        var _zeros:GoInt = (0 : GoInt);
        var _right:GoInt = (0 : GoInt);
        var __tmp__ = _s.precision(), _precision:GoInt = __tmp__._0, _precisionSet:Bool = __tmp__._1;
        if (_precisionSet) {
            if ((_digits.length) < _precision) {
                _zeros = _precision - (_digits.length);
            } else if (((_digits.length == (1 : GoInt)) && (_digits[(0 : GoInt)] == (48 : GoUInt8))) && (_precision == (0 : GoInt))) {
                return;
            };
        };
        var _length:GoInt = ((_sign.length + _prefix.length) + _zeros) + (_digits.length);
        {
            var __tmp__ = _s.width(), _width:GoInt = __tmp__._0, _widthSet:Bool = __tmp__._1;
            if (_widthSet && (_length < _width)) {
                {
                    var _d:GoInt = _width - _length;
                    if (_s.flag((45 : GoInt))) {
                        _right = _d;
                    } else if (_s.flag((48 : GoInt)) && !_precisionSet) {
                        _zeros = _d;
                    } else {
                        _left = _d;
                    };
                };
            };
        };
        _writeMultiple(_s, (" " : GoString), _left);
        _writeMultiple(_s, _sign, (1 : GoInt));
        _writeMultiple(_s, _prefix, (1 : GoInt));
        _writeMultiple(_s, ("0" : GoString), _zeros);
        _s.write(_digits);
        _writeMultiple(_s, (" " : GoString), _right);
    }
    /**
        // String returns the decimal representation of x as generated by
        // x.Text(10).
    **/
    @:keep
    static public function string( _x:Ref<Int_>):GoString {
        return _x.text((10 : GoInt));
    }
    /**
        // Append appends the string representation of x, as generated by
        // x.Text(base), to buf and returns the extended buffer.
    **/
    @:keep
    static public function append( _x:Ref<Int_>, _buf:Slice<GoByte>, _base:GoInt):Slice<GoByte> {
        if (_x == null || (_x : Dynamic).__nil__) {
            return (_buf.__append__(...("<nil>" : GoString).__toArray__()));
        };
        return (_buf.__append__(..._x._abs._itoa(_x._neg, _base).__toArray__()));
    }
    /**
        // Text returns the string representation of x in the given base.
        // Base must be between 2 and 62, inclusive. The result uses the
        // lower-case letters 'a' to 'z' for digit values 10 to 35, and
        // the upper-case letters 'A' to 'Z' for digit values 36 to 61.
        // No prefix (such as "0x") is added to the string. If x is a nil
        // pointer it returns "<nil>".
    **/
    @:keep
    static public function text( _x:Ref<Int_>, _base:GoInt):GoString {
        if (_x == null || (_x : Dynamic).__nil__) {
            return ("<nil>" : GoString);
        };
        return (_x._abs._itoa(_x._neg, _base) : GoString);
    }
    /**
        // Sqrt sets z to x, the largest integer such that z  x, and returns z.
        // It panics if x is negative.
    **/
    @:keep
    static public function sqrt( _z:Ref<Int_>, _x:Ref<Int_>):Ref<Int_> {
        if (_x._neg) {
            throw Go.toInterface(("square root of negative number" : GoString));
        };
        _z._neg = false;
        _z._abs = _z._abs._sqrt(_x._abs);
        return _z;
    }
    /**
        // Not sets z = ^x and returns z.
    **/
    @:keep
    static public function not( _z:Ref<Int_>, _x:Ref<Int_>):Ref<Int_> {
        if (_x._neg) {
            _z._abs = _z._abs._sub(_x._abs, _natOne);
            _z._neg = false;
            return _z;
        };
        _z._abs = _z._abs._add(_x._abs, _natOne);
        _z._neg = true;
        return _z;
    }
    /**
        // Xor sets z = x ^ y and returns z.
    **/
    @:keep
    static public function xor( _z:Ref<Int_>, _x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> {
        if (_x._neg == (_y._neg)) {
            if (_x._neg) {
                var _x1:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._sub(_x._abs, _natOne);
                var _y1:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._sub(_y._abs, _natOne);
                _z._abs = _z._abs._xor(_x1, _y1);
                _z._neg = false;
                return _z;
            };
            _z._abs = _z._abs._xor(_x._abs, _y._abs);
            _z._neg = false;
            return _z;
        };
        if (_x._neg) {
            {
                final __tmp__0 = _y;
                final __tmp__1 = _x;
                _x = __tmp__0;
                _y = __tmp__1;
            };
        };
        var _y1:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._sub(_y._abs, _natOne);
        _z._abs = _z._abs._add(_z._abs._xor(_x._abs, _y1), _natOne);
        _z._neg = true;
        return _z;
    }
    /**
        // Or sets z = x | y and returns z.
    **/
    @:keep
    static public function or( _z:Ref<Int_>, _x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> {
        if (_x._neg == (_y._neg)) {
            if (_x._neg) {
                var _x1:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._sub(_x._abs, _natOne);
                var _y1:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._sub(_y._abs, _natOne);
                _z._abs = _z._abs._add(_z._abs._and(_x1, _y1), _natOne);
                _z._neg = true;
                return _z;
            };
            _z._abs = _z._abs._or(_x._abs, _y._abs);
            _z._neg = false;
            return _z;
        };
        if (_x._neg) {
            {
                final __tmp__0 = _y;
                final __tmp__1 = _x;
                _x = __tmp__0;
                _y = __tmp__1;
            };
        };
        var _y1:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._sub(_y._abs, _natOne);
        _z._abs = _z._abs._add(_z._abs._andNot(_y1, _x._abs), _natOne);
        _z._neg = true;
        return _z;
    }
    /**
        // AndNot sets z = x &^ y and returns z.
    **/
    @:keep
    static public function andNot( _z:Ref<Int_>, _x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> {
        if (_x._neg == (_y._neg)) {
            if (_x._neg) {
                var _x1:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._sub(_x._abs, _natOne);
                var _y1:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._sub(_y._abs, _natOne);
                _z._abs = _z._abs._andNot(_y1, _x1);
                _z._neg = false;
                return _z;
            };
            _z._abs = _z._abs._andNot(_x._abs, _y._abs);
            _z._neg = false;
            return _z;
        };
        if (_x._neg) {
            var _x1:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._sub(_x._abs, _natOne);
            _z._abs = _z._abs._add(_z._abs._or(_x1, _y._abs), _natOne);
            _z._neg = true;
            return _z;
        };
        var _y1:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._sub(_y._abs, _natOne);
        _z._abs = _z._abs._and(_x._abs, _y1);
        _z._neg = false;
        return _z;
    }
    /**
        // And sets z = x & y and returns z.
    **/
    @:keep
    static public function and( _z:Ref<Int_>, _x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> {
        if (_x._neg == (_y._neg)) {
            if (_x._neg) {
                var _x1:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._sub(_x._abs, _natOne);
                var _y1:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._sub(_y._abs, _natOne);
                _z._abs = _z._abs._add(_z._abs._or(_x1, _y1), _natOne);
                _z._neg = true;
                return _z;
            };
            _z._abs = _z._abs._and(_x._abs, _y._abs);
            _z._neg = false;
            return _z;
        };
        if (_x._neg) {
            {
                final __tmp__0 = _y;
                final __tmp__1 = _x;
                _x = __tmp__0;
                _y = __tmp__1;
            };
        };
        var _y1:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._sub(_y._abs, _natOne);
        _z._abs = _z._abs._andNot(_x._abs, _y1);
        _z._neg = false;
        return _z;
    }
    /**
        // SetBit sets z to x, with x's i'th bit set to b (0 or 1).
        // That is, if b is 1 SetBit sets z = x | (1 << i);
        // if b is 0 SetBit sets z = x &^ (1 << i). If b is not 0 or 1,
        // SetBit will panic.
    **/
    @:keep
    static public function setBit( _z:Ref<Int_>, _x:Ref<Int_>, _i:GoInt, _b:GoUInt):Ref<Int_> {
        if (_i < (0 : GoInt)) {
            throw Go.toInterface(("negative bit index" : GoString));
        };
        if (_x._neg) {
            var _t:stdgo.math.big.Big.T_nat = _z._abs._sub(_x._abs, _natOne);
            _t = _t._setBit(_t, (_i : GoUInt), _b ^ (1u32 : GoUInt));
            _z._abs = _t._add(_t, _natOne);
            _z._neg = (_z._abs.length) > (0 : GoInt);
            return _z;
        };
        _z._abs = _z._abs._setBit(_x._abs, (_i : GoUInt), _b);
        _z._neg = false;
        return _z;
    }
    /**
        // Bit returns the value of the i'th bit of x. That is, it
        // returns (x>>i)&1. The bit index i must be >= 0.
    **/
    @:keep
    static public function bit( _x:Ref<Int_>, _i:GoInt):GoUInt {
        if (_i == ((0 : GoInt))) {
            if ((_x._abs.length) > (0 : GoInt)) {
                return (_x._abs[(0 : GoInt)] & (1u32 : stdgo.math.big.Big.Word) : GoUInt);
            };
            return (0u32 : GoUInt);
        };
        if (_i < (0 : GoInt)) {
            throw Go.toInterface(("negative bit index" : GoString));
        };
        if (_x._neg) {
            var _t:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._sub(_x._abs, _natOne);
            return _t._bit((_i : GoUInt)) ^ (1u32 : GoUInt);
        };
        return _x._abs._bit((_i : GoUInt));
    }
    /**
        // Rsh sets z = x >> n and returns z.
    **/
    @:keep
    static public function rsh( _z:Ref<Int_>, _x:Ref<Int_>, _n:GoUInt):Ref<Int_> {
        if (_x._neg) {
            var _t:stdgo.math.big.Big.T_nat = _z._abs._sub(_x._abs, _natOne);
            _t = _t._shr(_t, _n);
            _z._abs = _t._add(_t, _natOne);
            _z._neg = true;
            return _z;
        };
        _z._abs = _z._abs._shr(_x._abs, _n);
        _z._neg = false;
        return _z;
    }
    /**
        // Lsh sets z = x << n and returns z.
    **/
    @:keep
    static public function lsh( _z:Ref<Int_>, _x:Ref<Int_>, _n:GoUInt):Ref<Int_> {
        _z._abs = _z._abs._shl(_x._abs, _n);
        _z._neg = _x._neg;
        return _z;
    }
    /**
        // ModSqrt sets z to a square root of x mod p if such a square root exists, and
        // returns z. The modulus p must be an odd prime. If x is not a square mod p,
        // ModSqrt leaves z unchanged and returns nil. This function panics if p is
        // not an odd integer, its behavior is undefined if p is odd but not prime.
    **/
    @:keep
    static public function modSqrt( _z:Ref<Int_>, _x:Ref<Int_>, _p:Ref<Int_>):Ref<Int_> {
        {
            var __switchIndex__ = -1;
            while (true) {
                {
                    final __value__ = jacobi(_x, _p);
                    if (__value__ == ((-1 : GoInt))) {
                        return null;
                        break;
                    } else if (__value__ == ((0 : GoInt))) {
                        return _z.setInt64((0i64 : GoInt64));
                        break;
                    } else if (__value__ == ((1 : GoInt))) {
                        break;
                        break;
                    };
                };
                break;
            };
        };
        if (_x._neg || (_x.cmp(_p) >= (0 : GoInt))) {
            _x = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).mod(_x, _p);
        };
        if (_p._abs[(0 : GoInt)] % (4u32 : stdgo.math.big.Big.Word) == ((3u32 : stdgo.math.big.Big.Word))) {
            return _z._modSqrt3Mod4Prime(_x, _p);
        } else if (_p._abs[(0 : GoInt)] % (8u32 : stdgo.math.big.Big.Word) == ((5u32 : stdgo.math.big.Big.Word))) {
            return _z._modSqrt5Mod8Prime(_x, _p);
        } else {
            return _z._modSqrtTonelliShanks(_x, _p);
        };
    }
    /**
        // modSqrtTonelliShanks uses the Tonelli-Shanks algorithm to find the square
        // root of a quadratic residue modulo any prime.
    **/
    @:keep
    static public function _modSqrtTonelliShanks( _z:Ref<Int_>, _x:Ref<Int_>, _p:Ref<Int_>):Ref<Int_> {
        var _s:Int_ = ({} : stdgo.math.big.Big.Int_);
        _s.sub(_p, _intOne);
        var _e:GoUInt = _s._abs._trailingZeroBits();
        _s.rsh((Go.setRef(_s) : Ref<stdgo.math.big.Big.Int_>), _e);
        var _n:Int_ = ({} : stdgo.math.big.Big.Int_);
        _n.setInt64((2i64 : GoInt64));
        while (jacobi((Go.setRef(_n) : Ref<stdgo.math.big.Big.Int_>), _p) != ((-1 : GoInt))) {
            _n.add((Go.setRef(_n) : Ref<stdgo.math.big.Big.Int_>), _intOne);
        };
        var __0:Int_ = ({} : stdgo.math.big.Big.Int_), __1:Int_ = ({} : stdgo.math.big.Big.Int_), __2:Int_ = ({} : stdgo.math.big.Big.Int_), __3:Int_ = ({} : stdgo.math.big.Big.Int_), _t:Int_ = __3, _g:Int_ = __2, _b:Int_ = __1, _y:Int_ = __0;
        _y.add((Go.setRef(_s) : Ref<stdgo.math.big.Big.Int_>), _intOne);
        _y.rsh((Go.setRef(_y) : Ref<stdgo.math.big.Big.Int_>), (1u32 : GoUInt));
        _y.exp(_x, (Go.setRef(_y) : Ref<stdgo.math.big.Big.Int_>), _p);
        _b.exp(_x, (Go.setRef(_s) : Ref<stdgo.math.big.Big.Int_>), _p);
        _g.exp((Go.setRef(_n) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_s) : Ref<stdgo.math.big.Big.Int_>), _p);
        var _r:GoUInt = _e;
        while (true) {
            var _m:GoUInt = (0 : GoUInt);
            _t.set((Go.setRef(_b) : Ref<stdgo.math.big.Big.Int_>));
            while (_t.cmp(_intOne) != ((0 : GoInt))) {
                _t.mul((Go.setRef(_t) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_t) : Ref<stdgo.math.big.Big.Int_>)).mod((Go.setRef(_t) : Ref<stdgo.math.big.Big.Int_>), _p);
                _m++;
            };
            if (_m == ((0u32 : GoUInt))) {
                return _z.set((Go.setRef(_y) : Ref<stdgo.math.big.Big.Int_>));
            };
            _t.setInt64((0i64 : GoInt64)).setBit((Go.setRef(_t) : Ref<stdgo.math.big.Big.Int_>), ((_r - _m) - (1u32 : GoUInt) : GoInt), (1u32 : GoUInt)).exp((Go.setRef(_g) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_t) : Ref<stdgo.math.big.Big.Int_>), _p);
            _g.mul((Go.setRef(_t) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_t) : Ref<stdgo.math.big.Big.Int_>)).mod((Go.setRef(_g) : Ref<stdgo.math.big.Big.Int_>), _p);
            _y.mul((Go.setRef(_y) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_t) : Ref<stdgo.math.big.Big.Int_>)).mod((Go.setRef(_y) : Ref<stdgo.math.big.Big.Int_>), _p);
            _b.mul((Go.setRef(_b) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_g) : Ref<stdgo.math.big.Big.Int_>)).mod((Go.setRef(_b) : Ref<stdgo.math.big.Big.Int_>), _p);
            _r = _m;
        };
    }
    /**
        // modSqrt5Mod8 uses Atkin's observation that 2 is not a square mod p
        //
        //	alpha ==  (2*a)^((p-5)/8)    mod p
        //	beta  ==  2*a*alpha^2        mod p  is a square root of -1
        //	b     ==  a*alpha*(beta-1)   mod p  is a square root of a
        //
        // to calculate the square root of any quadratic residue mod p quickly for 5
        // mod 8 primes.
    **/
    @:keep
    static public function _modSqrt5Mod8Prime( _z:Ref<Int_>, _x:Ref<Int_>, _p:Ref<Int_>):Ref<Int_> {
        var _e = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).rsh(_p, (3u32 : GoUInt));
        var _tx = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).lsh(_x, (1u32 : GoUInt));
        var _alpha = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).exp(_tx, _e, _p);
        var _beta = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).mul(_alpha, _alpha);
        _beta.mod(_beta, _p);
        _beta.mul(_beta, _tx);
        _beta.mod(_beta, _p);
        _beta.sub(_beta, _intOne);
        _beta.mul(_beta, _x);
        _beta.mod(_beta, _p);
        _beta.mul(_beta, _alpha);
        _z.mod(_beta, _p);
        return _z;
    }
    /**
        // modSqrt3Mod4 uses the identity
        //
        //	   (a^((p+1)/4))^2  mod p
        //	== u^(p+1)          mod p
        //	== u^2              mod p
        //
        // to calculate the square root of any quadratic residue mod p quickly for 3
        // mod 4 primes.
    **/
    @:keep
    static public function _modSqrt3Mod4Prime( _z:Ref<Int_>, _x:Ref<Int_>, _p:Ref<Int_>):Ref<Int_> {
        var _e = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).add(_p, _intOne);
        _e.rsh(_e, (2u32 : GoUInt));
        _z.exp(_x, _e, _p);
        return _z;
    }
    /**
        // ModInverse sets z to the multiplicative inverse of g in the ring /n
        // and returns z. If g and n are not relatively prime, g has no multiplicative
        // inverse in the ring /n.  In this case, z is unchanged and the return value
        // is nil. If n == 0, a division-by-zero run-time panic occurs.
    **/
    @:keep
    static public function modInverse( _z:Ref<Int_>, _g:Ref<Int_>, _n:Ref<Int_>):Ref<Int_> {
        if (_n._neg) {
            var _n2:Int_ = ({} : stdgo.math.big.Big.Int_);
            _n = _n2.neg(_n);
        };
        if (_g._neg) {
            var _g2:Int_ = ({} : stdgo.math.big.Big.Int_);
            _g = _g2.mod(_g, _n);
        };
        var __0:Int_ = ({} : stdgo.math.big.Big.Int_), __1:Int_ = ({} : stdgo.math.big.Big.Int_), _x:Int_ = __1, _d:Int_ = __0;
        _d.gcd((Go.setRef(_x) : Ref<stdgo.math.big.Big.Int_>), null, _g, _n);
        if (_d.cmp(_intOne) != ((0 : GoInt))) {
            return null;
        };
        if (_x._neg) {
            _z.add((Go.setRef(_x) : Ref<stdgo.math.big.Big.Int_>), _n);
        } else {
            _z.set((Go.setRef(_x) : Ref<stdgo.math.big.Big.Int_>));
        };
        return _z;
    }
    /**
        // Rand sets z to a pseudo-random number in [0, n) and returns z.
        //
        // As this uses the math/rand package, it must not be used for
        // security-sensitive work. Use crypto/rand.Int instead.
    **/
    @:keep
    static public function rand( _z:Ref<Int_>, _rnd:Ref<stdgo.math.rand.Rand.Rand>, _n:Ref<Int_>):Ref<Int_> {
        if (_n._neg || (_n._abs.length == (0 : GoInt))) {
            _z._neg = false;
            _z._abs = null;
            return _z;
        };
        _z._neg = false;
        _z._abs = _z._abs._random(_rnd, _n._abs, _n._abs._bitLen());
        return _z;
    }
    /**
        // lehmerGCD sets z to the greatest common divisor of a and b,
        // which both must be != 0, and returns z.
        // If x or y are not nil, their values are set such that z = a*x + b*y.
        // See Knuth, The Art of Computer Programming, Vol. 2, Section 4.5.2, Algorithm L.
        // This implementation uses the improved condition by Collins requiring only one
        // quotient and avoiding the possibility of single Word overflow.
        // See Jebelean, "Improving the multiprecision Euclidean algorithm",
        // Design and Implementation of Symbolic Computation Systems, pp 45-58.
        // The cosequences are updated according to Algorithm 10.45 from
        // Cohen et al. "Handbook of Elliptic and Hyperelliptic Curve Cryptography" pp 192.
    **/
    @:keep
    static public function _lehmerGCD( _z:Ref<Int_>, _x:Ref<Int_>, _y:Ref<Int_>, _a:Ref<Int_>, _b:Ref<Int_>):Ref<Int_> {
        var __0:Ref<Int_> = (null : Ref<stdgo.math.big.Big.Int_>), __1:Ref<Int_> = (null : Ref<stdgo.math.big.Big.Int_>), __2:Ref<Int_> = (null : Ref<stdgo.math.big.Big.Int_>), __3:Ref<Int_> = (null : Ref<stdgo.math.big.Big.Int_>), ub:Ref<Int_> = __3, ua:Ref<Int_> = __2, b:Ref<Int_> = __1, a:Ref<Int_> = __0;
        a = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).abs(_a);
        b = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).abs(_b);
        var _extended:Bool = ((_x != null) && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) || ((_y != null) && ((_y : Dynamic).__nil__ == null || !(_y : Dynamic).__nil__));
        if (_extended) {
            ua = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).setInt64((1i64 : GoInt64));
            ub = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        };
        var _q = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        var _r = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        var _s = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        var _t = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>);
        if (a._abs._cmp(b._abs) < (0 : GoInt)) {
            {
                final __tmp__0 = b;
                final __tmp__1 = a;
                a = __tmp__0;
                b = __tmp__1;
            };
            {
                final __tmp__0 = ua;
                final __tmp__1 = ub;
                ub = __tmp__0;
                ua = __tmp__1;
            };
        };
        while ((b._abs.length) > (1 : GoInt)) {
            var __tmp__ = _lehmerSimulate(a, b), _u0:stdgo.math.big.Big.Word = __tmp__._0, _u1:stdgo.math.big.Big.Word = __tmp__._1, _v0:stdgo.math.big.Big.Word = __tmp__._2, _v1:stdgo.math.big.Big.Word = __tmp__._3, _even:Bool = __tmp__._4;
            if (_v0 != ((0u32 : stdgo.math.big.Big.Word))) {
                _lehmerUpdate(a,
b,
_q,
_r,
_s,
_t,
_u0,
_u1,
_v0,
_v1,
_even);
                if (_extended) {
                    _lehmerUpdate(ua,
ub,
_q,
_r,
_s,
_t,
_u0,
_u1,
_v0,
_v1,
_even);
                };
            } else {
                _euclidUpdate(a, b, ua, ub, _q, _r, _s, _t, _extended);
            };
        };
        if ((b._abs.length) > (0 : GoInt)) {
            if ((a._abs.length) > (1 : GoInt)) {
                _euclidUpdate(a, b, ua, ub, _q, _r, _s, _t, _extended);
            };
            if ((b._abs.length) > (0 : GoInt)) {
                var __0:stdgo.math.big.Big.Word = a._abs[(0 : GoInt)], __1:stdgo.math.big.Big.Word = b._abs[(0 : GoInt)], _bWord:stdgo.math.big.Big.Word = __1, _aWord:stdgo.math.big.Big.Word = __0;
                if (_extended) {
                    var __0:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word), __1:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word), __2:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word), __3:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word), _vb:Word = __3, _va:Word = __2, _ub:Word = __1, _ua:Word = __0;
                    {
                        final __tmp__0 = (1u32 : stdgo.math.big.Big.Word);
                        final __tmp__1 = (0u32 : stdgo.math.big.Big.Word);
                        _ua = __tmp__0;
                        _ub = __tmp__1;
                    };
                    {
                        final __tmp__0 = (0u32 : stdgo.math.big.Big.Word);
                        final __tmp__1 = (1u32 : stdgo.math.big.Big.Word);
                        _va = __tmp__0;
                        _vb = __tmp__1;
                    };
                    var _even:Bool = true;
                    while (_bWord != ((0u32 : stdgo.math.big.Big.Word))) {
                        var __0:stdgo.math.big.Big.Word = _aWord / _bWord, __1:stdgo.math.big.Big.Word = _aWord % _bWord, _r:stdgo.math.big.Big.Word = __1, _q:stdgo.math.big.Big.Word = __0;
                        {
                            final __tmp__0 = _bWord;
                            final __tmp__1 = _r;
                            _aWord = __tmp__0;
                            _bWord = __tmp__1;
                        };
                        {
                            final __tmp__0 = _ub;
                            final __tmp__1 = _ua + (_q * _ub);
                            _ua = __tmp__0;
                            _ub = __tmp__1;
                        };
                        {
                            final __tmp__0 = _vb;
                            final __tmp__1 = _va + (_q * _vb);
                            _va = __tmp__0;
                            _vb = __tmp__1;
                        };
                        _even = !_even;
                    };
                    _t._abs = _t._abs._setWord(_ua);
                    _s._abs = _s._abs._setWord(_va);
                    _t._neg = !_even;
                    _s._neg = _even;
                    _t.mul(ua, _t);
                    _s.mul(ub, _s);
                    ua.add(_t, _s);
                } else {
                    while (_bWord != ((0u32 : stdgo.math.big.Big.Word))) {
                        {
                            final __tmp__0 = _bWord;
                            final __tmp__1 = _aWord % _bWord;
                            _aWord = __tmp__0;
                            _bWord = __tmp__1;
                        };
                    };
                };
                a._abs[(0 : GoInt)] = _aWord;
            };
        };
        var _negA:Bool = _a._neg;
        if (_y != null && ((_y : Dynamic).__nil__ == null || !(_y : Dynamic).__nil__)) {
            if (_y == (_b)) {
                b.set(_b);
            } else {
                b = _b;
            };
            _y.mul(_a, ua);
            if (_negA) {
                _y._neg = !_y._neg;
            };
            _y.sub(a, _y);
            _y.div(_y, b);
        };
        if (_x != null && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) {
            {
                var __tmp__ = (ua : stdgo.math.big.Big.Int_)?.__copy__();
                _x._neg = __tmp__._neg;
                _x._abs = __tmp__._abs;
            };
            if (_negA) {
                _x._neg = !_x._neg;
            };
        };
        {
            var __tmp__ = (a : stdgo.math.big.Big.Int_)?.__copy__();
            _z._neg = __tmp__._neg;
            _z._abs = __tmp__._abs;
        };
        return _z;
    }
    /**
        // GCD sets z to the greatest common divisor of a and b and returns z.
        // If x or y are not nil, GCD sets their value such that z = a*x + b*y.
        //
        // a and b may be positive, zero or negative. (Before Go 1.14 both had
        // to be > 0.) Regardless of the signs of a and b, z is always >= 0.
        //
        // If a == b == 0, GCD sets z = x = y = 0.
        //
        // If a == 0 and b != 0, GCD sets z = |b|, x = 0, y = sign(b) * 1.
        //
        // If a != 0 and b == 0, GCD sets z = |a|, x = sign(a) * 1, y = 0.
    **/
    @:keep
    static public function gcd( _z:Ref<Int_>, _x:Ref<Int_>, _y:Ref<Int_>, _a:Ref<Int_>, _b:Ref<Int_>):Ref<Int_> {
        if ((_a._abs.length == (0 : GoInt)) || (_b._abs.length == (0 : GoInt))) {
            var __0:GoInt = (_a._abs.length), __1:GoInt = (_b._abs.length), __2:Bool = _a._neg, __3:Bool = _b._neg, _negB:Bool = __3, _negA:Bool = __2, _lenB:GoInt = __1, _lenA:GoInt = __0;
            if (_lenA == ((0 : GoInt))) {
                _z.set(_b);
            } else {
                _z.set(_a);
            };
            _z._neg = false;
            if (_x != null && ((_x : Dynamic).__nil__ == null || !(_x : Dynamic).__nil__)) {
                if (_lenA == ((0 : GoInt))) {
                    _x.setUint64((0i64 : GoUInt64));
                } else {
                    _x.setUint64((1i64 : GoUInt64));
                    _x._neg = _negA;
                };
            };
            if (_y != null && ((_y : Dynamic).__nil__ == null || !(_y : Dynamic).__nil__)) {
                if (_lenB == ((0 : GoInt))) {
                    _y.setUint64((0i64 : GoUInt64));
                } else {
                    _y.setUint64((1i64 : GoUInt64));
                    _y._neg = _negB;
                };
            };
            return _z;
        };
        return _z._lehmerGCD(_x, _y, _a, _b);
    }
    @:keep
    static public function _exp( _z:Ref<Int_>, _x:Ref<Int_>, _y:Ref<Int_>, _m:Ref<Int_>, _slow:Bool):Ref<Int_> {
        var _xWords:stdgo.math.big.Big.T_nat = _x._abs;
        if (_y._neg) {
            if (((_m == null) || (_m : Dynamic).__nil__) || (_m._abs.length == (0 : GoInt))) {
                return _z.setInt64((1i64 : GoInt64));
            };
            var _inverse = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).modInverse(_x, _m);
            if (_inverse == null || (_inverse : Dynamic).__nil__) {
                return null;
            };
            _xWords = _inverse._abs;
        };
        var _yWords:stdgo.math.big.Big.T_nat = _y._abs;
        var _mWords:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
        if (_m != null && ((_m : Dynamic).__nil__ == null || !(_m : Dynamic).__nil__)) {
            if ((_z == _m) || _alias(_z._abs, _m._abs)) {
                _m = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).set(_m);
            };
            _mWords = _m._abs;
        };
        _z._abs = _z._abs._expNN(_xWords, _yWords, _mWords, _slow);
        _z._neg = (((_z._abs.length > (0 : GoInt)) && _x._neg) && (_yWords.length > (0 : GoInt))) && ((_yWords[(0 : GoInt)] & (1u32 : stdgo.math.big.Big.Word)) == (1u32 : stdgo.math.big.Big.Word));
        if (_z._neg && (_mWords.length > (0 : GoInt))) {
            _z._abs = _z._abs._sub(_mWords, _z._abs);
            _z._neg = false;
        };
        return _z;
    }
    @:keep
    static public function _expSlow( _z:Ref<Int_>, _x:Ref<Int_>, _y:Ref<Int_>, _m:Ref<Int_>):Ref<Int_> {
        return _z._exp(_x, _y, _m, true);
    }
    /**
        // Exp sets z = x**y mod |m| (i.e. the sign of m is ignored), and returns z.
        // If m == nil or m == 0, z = x**y unless y <= 0 then z = 1. If m != 0, y < 0,
        // and x and m are not relatively prime, z is unchanged and nil is returned.
        //
        // Modular exponentiation of inputs of a particular size is not a
        // cryptographically constant-time operation.
    **/
    @:keep
    static public function exp( _z:Ref<Int_>, _x:Ref<Int_>, _y:Ref<Int_>, _m:Ref<Int_>):Ref<Int_> {
        return _z._exp(_x, _y, _m, false);
    }
    /**
        // TrailingZeroBits returns the number of consecutive least significant zero
        // bits of |x|.
    **/
    @:keep
    static public function trailingZeroBits( _x:Ref<Int_>):GoUInt {
        return _x._abs._trailingZeroBits();
    }
    /**
        // BitLen returns the length of the absolute value of x in bits.
        // The bit length of 0 is 0.
    **/
    @:keep
    static public function bitLen( _x:Ref<Int_>):GoInt {
        return _x._abs._bitLen();
    }
    /**
        // FillBytes sets buf to the absolute value of x, storing it as a zero-extended
        // big-endian byte slice, and returns buf.
        //
        // If the absolute value of x doesn't fit in buf, FillBytes will panic.
    **/
    @:keep
    static public function fillBytes( _x:Ref<Int_>, _buf:Slice<GoByte>):Slice<GoByte> {
        for (_i in 0 ... _buf.length.toBasic()) {
            _buf[(_i : GoInt)] = (0 : GoUInt8);
        };
        _x._abs._bytes(_buf);
        return _buf;
    }
    /**
        // Bytes returns the absolute value of x as a big-endian byte slice.
        //
        // To use a fixed length slice, or a preallocated one, use FillBytes.
    **/
    @:keep
    static public function bytes( _x:Ref<Int_>):Slice<GoByte> {
        var _buf = new Slice<GoUInt8>(((_x._abs.length) * (4 : GoInt) : GoInt).toBasic(), 0, ...[for (i in 0 ... ((_x._abs.length) * (4 : GoInt) : GoInt).toBasic()) (0 : GoUInt8)]);
        return (_buf.__slice__(_x._abs._bytes(_buf)) : Slice<GoUInt8>);
    }
    /**
        // SetBytes interprets buf as the bytes of a big-endian unsigned
        // integer, sets z to that value, and returns z.
    **/
    @:keep
    static public function setBytes( _z:Ref<Int_>, _buf:Slice<GoByte>):Ref<Int_> {
        _z._abs = _z._abs._setBytes(_buf);
        _z._neg = false;
        return _z;
    }
    /**
        // setFromScanner implements SetString given an io.ByteScanner.
        // For documentation see comments of SetString.
    **/
    @:keep
    static public function _setFromScanner( _z:Ref<Int_>, _r:stdgo.io.Io.ByteScanner, _base:GoInt):{ var _0 : Ref<Int_>; var _1 : Bool; } {
        {
            var __tmp__ = _z._scan(_r, _base), __0:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, __1:GoInt = __tmp__._1, _err:Error = __tmp__._2;
            if (_err != null) {
                return { _0 : null, _1 : false };
            };
        };
        {
            var __tmp__ = _r.readByte(), __2:GoUInt8 = __tmp__._0, _err:Error = __tmp__._1;
            if (Go.toInterface(_err) != (Go.toInterface(stdgo.io.Io.eof))) {
                return { _0 : null, _1 : false };
            };
        };
        return { _0 : _z, _1 : true };
    }
    /**
        // SetString sets z to the value of s, interpreted in the given base,
        // and returns z and a boolean indicating success. The entire string
        // (not just a prefix) must be valid for success. If SetString fails,
        // the value of z is undefined but the returned value is nil.
        //
        // The base argument must be 0 or a value between 2 and MaxBase.
        // For base 0, the number prefix determines the actual base: A prefix of
        // 0b or 0B selects base 2, 0, 0o or 0O selects base 8,
        // and 0x or 0X selects base 16. Otherwise, the selected base is 10
        // and no prefix is accepted.
        //
        // For bases <= 36, lower and upper case letters are considered the same:
        // The letters 'a' to 'z' and 'A' to 'Z' represent digit values 10 to 35.
        // For bases > 36, the upper case letters 'A' to 'Z' represent the digit
        // values 36 to 61.
        //
        // For base 0, an underscore character _ may appear between a base
        // prefix and an adjacent digit, and between successive digits; such
        // underscores do not change the value of the number.
        // Incorrect placement of underscores is reported as an error if there
        // are no other errors. If base != 0, underscores are not recognized
        // and act like any other character that is not a valid digit.
    **/
    @:keep
    static public function setString( _z:Ref<Int_>, _s:GoString, _base:GoInt):{ var _0 : Ref<Int_>; var _1 : Bool; } {
        return _z._setFromScanner(Go.asInterface(stdgo.strings.Strings.newReader(_s)), _base);
    }
    /**
        // IsUint64 reports whether x can be represented as a uint64.
    **/
    @:keep
    static public function isUint64( _x:Ref<Int_>):Bool {
        return !_x._neg && (_x._abs.length <= (2 : GoInt));
    }
    /**
        // IsInt64 reports whether x can be represented as an int64.
    **/
    @:keep
    static public function isInt64( _x:Ref<Int_>):Bool {
        if ((_x._abs.length) <= (2 : GoInt)) {
            var _w:GoInt64 = (_low64(_x._abs) : GoInt64);
            return (_w >= (0i64 : GoInt64)) || (_x._neg && (_w == -_w));
        };
        return false;
    }
    /**
        // Uint64 returns the uint64 representation of x.
        // If x cannot be represented in a uint64, the result is undefined.
    **/
    @:keep
    static public function uint64( _x:Ref<Int_>):GoUInt64 {
        return _low64(_x._abs);
    }
    /**
        // Int64 returns the int64 representation of x.
        // If x cannot be represented in an int64, the result is undefined.
    **/
    @:keep
    static public function int64( _x:Ref<Int_>):GoInt64 {
        var _v:GoInt64 = (_low64(_x._abs) : GoInt64);
        if (_x._neg) {
            _v = -_v;
        };
        return _v;
    }
    /**
        // CmpAbs compares the absolute values of x and y and returns:
        //
        //	-1 if |x| <  |y|
        //	 0 if |x| == |y|
        //	+1 if |x| >  |y|
    **/
    @:keep
    static public function cmpAbs( _x:Ref<Int_>, _y:Ref<Int_>):GoInt {
        return _x._abs._cmp(_y._abs);
    }
    /**
        // Cmp compares x and y and returns:
        //
        //	-1 if x <  y
        //	 0 if x == y
        //	+1 if x >  y
    **/
    @:keep
    static public function cmp( _x:Ref<Int_>, _y:Ref<Int_>):GoInt {
        var _r:GoInt = (0 : GoInt);
        if (_x == (_y)) {} else if (_x._neg == (_y._neg)) {
            _r = _x._abs._cmp(_y._abs);
            if (_x._neg) {
                _r = -_r;
            };
        } else if (_x._neg) {
            _r = (-1 : GoInt);
        } else {
            _r = (1 : GoInt);
        };
        return _r;
    }
    /**
        // DivMod sets z to the quotient x div y and m to the modulus x mod y
        // and returns the pair (z, m) for y != 0.
        // If y == 0, a division-by-zero run-time panic occurs.
        //
        // DivMod implements Euclidean division and modulus (unlike Go):
        //
        //	q = x div y  such that
        //	m = x - y*q  with 0 <= m < |y|
        //
        // (See Raymond T. Boute, The Euclidean definition of the functions
        // div and mod. ACM Transactions on Programming Languages and
        // Systems (TOPLAS), 14(2):127-144, New York, NY, USA, 4/1992.
        // ACM press.)
        // See QuoRem for T-division and modulus (like Go).
    **/
    @:keep
    static public function divMod( _z:Ref<Int_>, _x:Ref<Int_>, _y:Ref<Int_>, _m:Ref<Int_>):{ var _0 : Ref<Int_>; var _1 : Ref<Int_>; } {
        var _y0 = _y;
        if ((_z == _y) || _alias(_z._abs, _y._abs)) {
            _y0 = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).set(_y);
        };
        _z.quoRem(_x, _y, _m);
        if (_m._neg) {
            if (_y0._neg) {
                _z.add(_z, _intOne);
                _m.sub(_m, _y0);
            } else {
                _z.sub(_z, _intOne);
                _m.add(_m, _y0);
            };
        };
        return { _0 : _z, _1 : _m };
    }
    /**
        // Mod sets z to the modulus x%y for y != 0 and returns z.
        // If y == 0, a division-by-zero run-time panic occurs.
        // Mod implements Euclidean modulus (unlike Go); see DivMod for more details.
    **/
    @:keep
    static public function mod( _z:Ref<Int_>, _x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> {
        var _y0 = _y;
        if ((_z == _y) || _alias(_z._abs, _y._abs)) {
            _y0 = (Go.setRef(({} : stdgo.math.big.Big.Int_)) : Ref<stdgo.math.big.Big.Int_>).set(_y);
        };
        var _q:Int_ = ({} : stdgo.math.big.Big.Int_);
        _q.quoRem(_x, _y, _z);
        if (_z._neg) {
            if (_y0._neg) {
                _z.sub(_z, _y0);
            } else {
                _z.add(_z, _y0);
            };
        };
        return _z;
    }
    /**
        // Div sets z to the quotient x/y for y != 0 and returns z.
        // If y == 0, a division-by-zero run-time panic occurs.
        // Div implements Euclidean division (unlike Go); see DivMod for more details.
    **/
    @:keep
    static public function div( _z:Ref<Int_>, _x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> {
        var _y_neg:Bool = _y._neg;
        var _r:Int_ = ({} : stdgo.math.big.Big.Int_);
        _z.quoRem(_x, _y, (Go.setRef(_r) : Ref<stdgo.math.big.Big.Int_>));
        if (_r._neg) {
            if (_y_neg) {
                _z.add(_z, _intOne);
            } else {
                _z.sub(_z, _intOne);
            };
        };
        return _z;
    }
    /**
        // QuoRem sets z to the quotient x/y and r to the remainder x%y
        // and returns the pair (z, r) for y != 0.
        // If y == 0, a division-by-zero run-time panic occurs.
        //
        // QuoRem implements T-division and modulus (like Go):
        //
        //	q = x/y      with the result truncated to zero
        //	r = x - y*q
        //
        // (See Daan Leijen, Division and Modulus for Computer Scientists.)
        // See DivMod for Euclidean division and modulus (unlike Go).
    **/
    @:keep
    static public function quoRem( _z:Ref<Int_>, _x:Ref<Int_>, _y:Ref<Int_>, _r:Ref<Int_>):{ var _0 : Ref<Int_>; var _1 : Ref<Int_>; } {
        {
            var __tmp__ = _z._abs._div(_r._abs, _x._abs, _y._abs);
            _z._abs = __tmp__._0;
            _r._abs = __tmp__._1;
        };
        {
            final __tmp__0 = (_z._abs.length > (0 : GoInt)) && (_x._neg != _y._neg);
            final __tmp__1 = (_r._abs.length > (0 : GoInt)) && _x._neg;
            _z._neg = __tmp__0;
            _r._neg = __tmp__1;
        };
        return { _0 : _z, _1 : _r };
    }
    /**
        // Rem sets z to the remainder x%y for y != 0 and returns z.
        // If y == 0, a division-by-zero run-time panic occurs.
        // Rem implements truncated modulus (like Go); see QuoRem for more details.
    **/
    @:keep
    static public function rem( _z:Ref<Int_>, _x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> {
        {
            var __tmp__ = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._div(_z._abs, _x._abs, _y._abs);
            _z._abs = __tmp__._1;
        };
        _z._neg = (_z._abs.length > (0 : GoInt)) && _x._neg;
        return _z;
    }
    /**
        // Quo sets z to the quotient x/y for y != 0 and returns z.
        // If y == 0, a division-by-zero run-time panic occurs.
        // Quo implements truncated division (like Go); see QuoRem for more details.
    **/
    @:keep
    static public function quo( _z:Ref<Int_>, _x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> {
        {
            var __tmp__ = _z._abs._div(null, _x._abs, _y._abs);
            _z._abs = __tmp__._0;
        };
        _z._neg = (_z._abs.length > (0 : GoInt)) && (_x._neg != _y._neg);
        return _z;
    }
    /**
        // Binomial sets z to the binomial coefficient C(n, k) and returns z.
    **/
    @:keep
    static public function binomial( _z:Ref<Int_>, _n:GoInt64, _k:GoInt64):Ref<Int_> {
        if (_k > _n) {
            return _z.setInt64((0i64 : GoInt64));
        };
        if (_k > (_n - _k)) {
            _k = _n - _k;
        };
        var __0:Int_ = ({} : stdgo.math.big.Big.Int_), __1:Int_ = ({} : stdgo.math.big.Big.Int_), __2:Int_ = ({} : stdgo.math.big.Big.Int_), __3:Int_ = ({} : stdgo.math.big.Big.Int_), _t:Int_ = __3, _i:Int_ = __2, k:Int_ = __1, n:Int_ = __0;
        n.setInt64(_n);
        k.setInt64(_k);
        _z.set(_intOne);
        while (_i.cmp((Go.setRef(k) : Ref<stdgo.math.big.Big.Int_>)) < (0 : GoInt)) {
            _z.mul(_z, _t.sub((Go.setRef(n) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_i) : Ref<stdgo.math.big.Big.Int_>)));
            _i.add((Go.setRef(_i) : Ref<stdgo.math.big.Big.Int_>), _intOne);
            _z.quo(_z, (Go.setRef(_i) : Ref<stdgo.math.big.Big.Int_>));
        };
        return _z;
    }
    /**
        // MulRange sets z to the product of all integers
        // in the range [a, b] inclusively and returns z.
        // If a > b (empty range), the result is 1.
    **/
    @:keep
    static public function mulRange( _z:Ref<Int_>, _a:GoInt64, _b:GoInt64):Ref<Int_> {
        if (_a > _b) {
            return _z.setInt64((1i64 : GoInt64));
        } else if ((_a <= (0i64 : GoInt64)) && (_b >= (0i64 : GoInt64))) {
            return _z.setInt64((0i64 : GoInt64));
        };
        var _neg:Bool = false;
        if (_a < (0i64 : GoInt64)) {
            _neg = (_b - _a) & (1i64 : GoInt64) == ((0i64 : GoInt64));
            {
                final __tmp__0 = -_b;
                final __tmp__1 = -_a;
                _a = __tmp__0;
                _b = __tmp__1;
            };
        };
        _z._abs = _z._abs._mulRange((_a : GoUInt64), (_b : GoUInt64));
        _z._neg = _neg;
        return _z;
    }
    /**
        // Mul sets z to the product x*y and returns z.
    **/
    @:keep
    static public function mul( _z:Ref<Int_>, _x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> {
        if (_x == (_y)) {
            _z._abs = _z._abs._sqr(_x._abs);
            _z._neg = false;
            return _z;
        };
        _z._abs = _z._abs._mul(_x._abs, _y._abs);
        _z._neg = (_z._abs.length > (0 : GoInt)) && (_x._neg != _y._neg);
        return _z;
    }
    /**
        // Sub sets z to the difference x-y and returns z.
    **/
    @:keep
    static public function sub( _z:Ref<Int_>, _x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> {
        var _neg:Bool = _x._neg;
        if (_x._neg != (_y._neg)) {
            _z._abs = _z._abs._add(_x._abs, _y._abs);
        } else {
            if (_x._abs._cmp(_y._abs) >= (0 : GoInt)) {
                _z._abs = _z._abs._sub(_x._abs, _y._abs);
            } else {
                _neg = !_neg;
                _z._abs = _z._abs._sub(_y._abs, _x._abs);
            };
        };
        _z._neg = (_z._abs.length > (0 : GoInt)) && _neg;
        return _z;
    }
    /**
        // Add sets z to the sum x+y and returns z.
    **/
    @:keep
    static public function add( _z:Ref<Int_>, _x:Ref<Int_>, _y:Ref<Int_>):Ref<Int_> {
        var _neg:Bool = _x._neg;
        if (_x._neg == (_y._neg)) {
            _z._abs = _z._abs._add(_x._abs, _y._abs);
        } else {
            if (_x._abs._cmp(_y._abs) >= (0 : GoInt)) {
                _z._abs = _z._abs._sub(_x._abs, _y._abs);
            } else {
                _neg = !_neg;
                _z._abs = _z._abs._sub(_y._abs, _x._abs);
            };
        };
        _z._neg = (_z._abs.length > (0 : GoInt)) && _neg;
        return _z;
    }
    /**
        // Neg sets z to -x and returns z.
    **/
    @:keep
    static public function neg( _z:Ref<Int_>, _x:Ref<Int_>):Ref<Int_> {
        _z.set(_x);
        _z._neg = (_z._abs.length > (0 : GoInt)) && !_z._neg;
        return _z;
    }
    /**
        // Abs sets z to |x| (the absolute value of x) and returns z.
    **/
    @:keep
    static public function abs( _z:Ref<Int_>, _x:Ref<Int_>):Ref<Int_> {
        _z.set(_x);
        _z._neg = false;
        return _z;
    }
    /**
        // SetBits provides raw (unchecked but fast) access to z by setting its
        // value to abs, interpreted as a little-endian Word slice, and returning
        // z. The result and abs share the same underlying array.
        // SetBits is intended to support implementation of missing low-level Int
        // functionality outside this package; it should be avoided otherwise.
    **/
    @:keep
    static public function setBits( _z:Ref<Int_>, _abs:Slice<Word>):Ref<Int_> {
        _z._abs = (_abs : T_nat)._norm();
        _z._neg = false;
        return _z;
    }
    /**
        // Bits provides raw (unchecked but fast) access to x by returning its
        // absolute value as a little-endian Word slice. The result and x share
        // the same underlying array.
        // Bits is intended to support implementation of missing low-level Int
        // functionality outside this package; it should be avoided otherwise.
    **/
    @:keep
    static public function bits( _x:Ref<Int_>):Slice<Word> {
        return _x._abs;
    }
    /**
        // Set sets z to x and returns z.
    **/
    @:keep
    static public function set( _z:Ref<Int_>, _x:Ref<Int_>):Ref<Int_> {
        if (_z != (_x)) {
            _z._abs = _z._abs._set(_x._abs);
            _z._neg = _x._neg;
        };
        return _z;
    }
    /**
        // SetUint64 sets z to x and returns z.
    **/
    @:keep
    static public function setUint64( _z:Ref<Int_>, _x:GoUInt64):Ref<Int_> {
        _z._abs = _z._abs._setUint64(_x);
        _z._neg = false;
        return _z;
    }
    /**
        // SetInt64 sets z to x and returns z.
    **/
    @:keep
    static public function setInt64( _z:Ref<Int_>, _x:GoInt64):Ref<Int_> {
        var _neg:Bool = false;
        if (_x < (0i64 : GoInt64)) {
            _neg = true;
            _x = -_x;
        };
        _z._abs = _z._abs._setUint64((_x : GoUInt64));
        _z._neg = _neg;
        return _z;
    }
    /**
        // Sign returns:
        //
        //	-1 if x <  0
        //	 0 if x == 0
        //	+1 if x >  0
    **/
    @:keep
    static public function sign( _x:Ref<Int_>):GoInt {
        if ((_x._abs.length) == ((0 : GoInt))) {
            return (0 : GoInt);
        };
        if (_x._neg) {
            return (-1 : GoInt);
        };
        return (1 : GoInt);
    }
}
class T_byteReader_asInterface {
    @:keep
    public dynamic function unreadByte():Error return __self__.value.unreadByte();
    @:keep
    public dynamic function readByte():{ var _0 : GoByte; var _1 : Error; } return __self__.value.readByte();
    @:embedded
    public dynamic function width():{ var _0 : GoInt; var _1 : Bool; } return __self__.value.width();
    @:embedded
    public dynamic function unreadRune():Error return __self__.value.unreadRune();
    @:embedded
    public dynamic function token(_skipSpace:Bool, _f:GoInt32 -> Bool):{ var _0 : Slice<GoUInt8>; var _1 : Error; } return __self__.value.token(_skipSpace, _f);
    @:embedded
    public dynamic function skipSpace():Void __self__.value.skipSpace();
    @:embedded
    public dynamic function readRune():{ var _0 : GoInt32; var _1 : GoInt; var _2 : Error; } return __self__.value.readRune();
    @:embedded
    public dynamic function read(_buf:Slice<GoUInt8>):{ var _0 : GoInt; var _1 : Error; } return __self__.value.read(_buf);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_byteReader>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T_byteReader_asInterface) class T_byteReader_static_extension {
    @:keep
    static public function unreadByte( _r:T_byteReader):Error {
        return _r.unreadRune();
    }
    @:keep
    static public function readByte( _r:T_byteReader):{ var _0 : GoByte; var _1 : Error; } {
        var __tmp__ = _r.readRune(), _ch:GoInt32 = __tmp__._0, _size:GoInt = __tmp__._1, _err:Error = __tmp__._2;
        if ((_size != (1 : GoInt)) && (_err == null)) {
            _err = stdgo.fmt.Fmt.errorf(("invalid rune %#U" : GoString), Go.toInterface(_ch));
        };
        return { _0 : (_ch : GoByte), _1 : _err };
    }
    @:embedded
    public static function width( __self__:T_byteReader):{ var _0 : GoInt; var _1 : Bool; } return __self__.width();
    @:embedded
    public static function unreadRune( __self__:T_byteReader):Error return __self__.unreadRune();
    @:embedded
    public static function token( __self__:T_byteReader, _skipSpace:Bool, _f:GoInt32 -> Bool):{ var _0 : Slice<GoUInt8>; var _1 : Error; } return __self__.token(_skipSpace, _f);
    @:embedded
    public static function skipSpace( __self__:T_byteReader) __self__.skipSpace();
    @:embedded
    public static function readRune( __self__:T_byteReader):{ var _0 : GoInt32; var _1 : GoInt; var _2 : Error; } return __self__.readRune();
    @:embedded
    public static function read( __self__:T_byteReader, _buf:Slice<GoUInt8>):{ var _0 : GoInt; var _1 : Error; } return __self__.read(_buf);
}
class Rat_asInterface {
    /**
        // UnmarshalText implements the encoding.TextUnmarshaler interface.
    **/
    @:keep
    public dynamic function unmarshalText(_text:Slice<GoByte>):Error return __self__.value.unmarshalText(_text);
    /**
        // MarshalText implements the encoding.TextMarshaler interface.
    **/
    @:keep
    public dynamic function marshalText():{ var _0 : Slice<GoByte>; var _1 : Error; } return __self__.value.marshalText();
    /**
        // GobDecode implements the gob.GobDecoder interface.
    **/
    @:keep
    public dynamic function gobDecode(_buf:Slice<GoByte>):Error return __self__.value.gobDecode(_buf);
    /**
        // GobEncode implements the gob.GobEncoder interface.
    **/
    @:keep
    public dynamic function gobEncode():{ var _0 : Slice<GoByte>; var _1 : Error; } return __self__.value.gobEncode();
    /**
        // FloatString returns a string representation of x in decimal form with prec
        // digits of precision after the radix point. The last digit is rounded to
        // nearest, with halves rounded away from zero.
    **/
    @:keep
    public dynamic function floatString(_prec:GoInt):GoString return __self__.value.floatString(_prec);
    /**
        // RatString returns a string representation of x in the form "a/b" if b != 1,
        // and in the form "a" if b == 1.
    **/
    @:keep
    public dynamic function ratString():GoString return __self__.value.ratString();
    /**
        // marshal implements String returning a slice of bytes
    **/
    @:keep
    public dynamic function _marshal():Slice<GoByte> return __self__.value._marshal();
    /**
        // String returns a string representation of x in the form "a/b" (even if b == 1).
    **/
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    /**
        // SetString sets z to the value of s and returns z and a boolean indicating
        // success. s can be given as a (possibly signed) fraction "a/b", or as a
        // floating-point number optionally followed by an exponent.
        // If a fraction is provided, both the dividend and the divisor may be a
        // decimal integer or independently use a prefix of 0b, 0 or 0o,
        // or 0x (or their upper-case variants) to denote a binary, octal, or
        // hexadecimal integer, respectively. The divisor may not be signed.
        // If a floating-point number is provided, it may be in decimal form or
        // use any of the same prefixes as above but for 0 to denote a non-decimal
        // mantissa. A leading 0 is considered a decimal leading 0; it does not
        // indicate octal representation in this case.
        // An optional base-10 e or base-2 p (or their upper-case variants)
        // exponent may be provided as well, except for hexadecimal floats which
        // only accept an (optional) p exponent (because an e or E cannot
        // be distinguished from a mantissa digit). If the exponent's absolute value
        // is too large, the operation may fail.
        // The entire string, not just a prefix, must be valid for success. If the
        // operation failed, the value of z is undefined but the returned value is nil.
    **/
    @:keep
    public dynamic function setString(_s:GoString):{ var _0 : Ref<Rat>; var _1 : Bool; } return __self__.value.setString(_s);
    /**
        // Scan is a support routine for fmt.Scanner. It accepts the formats
        // 'e', 'E', 'f', 'F', 'g', 'G', and 'v'. All formats are equivalent.
    **/
    @:keep
    public dynamic function scan(_s:stdgo.fmt.Fmt.ScanState, _ch:GoRune):Error return __self__.value.scan(_s, _ch);
    /**
        // Quo sets z to the quotient x/y and returns z.
        // If y == 0, Quo panics.
    **/
    @:keep
    public dynamic function quo(_x:Ref<Rat>, _y:Ref<Rat>):Ref<Rat> return __self__.value.quo(_x, _y);
    /**
        // Mul sets z to the product x*y and returns z.
    **/
    @:keep
    public dynamic function mul(_x:Ref<Rat>, _y:Ref<Rat>):Ref<Rat> return __self__.value.mul(_x, _y);
    /**
        // Sub sets z to the difference x-y and returns z.
    **/
    @:keep
    public dynamic function sub(_x:Ref<Rat>, _y:Ref<Rat>):Ref<Rat> return __self__.value.sub(_x, _y);
    /**
        // Add sets z to the sum x+y and returns z.
    **/
    @:keep
    public dynamic function add(_x:Ref<Rat>, _y:Ref<Rat>):Ref<Rat> return __self__.value.add(_x, _y);
    /**
        // Cmp compares x and y and returns:
        //
        //	-1 if x <  y
        //	 0 if x == y
        //	+1 if x >  y
    **/
    @:keep
    public dynamic function cmp(_y:Ref<Rat>):GoInt return __self__.value.cmp(_y);
    @:keep
    public dynamic function _norm():Ref<Rat> return __self__.value._norm();
    /**
        // Denom returns the denominator of x; it is always > 0.
        // The result is a reference to x's denominator, unless
        // x is an uninitialized (zero value) Rat, in which case
        // the result is a new Int of value 1. (To initialize x,
        // any operation that sets x will do, including x.Set(x).)
        // If the result is a reference to x's denominator it
        // may change if a new value is assigned to x, and vice versa.
    **/
    @:keep
    public dynamic function denom():Ref<Int_> return __self__.value.denom();
    /**
        // Num returns the numerator of x; it may be <= 0.
        // The result is a reference to x's numerator; it
        // may change if a new value is assigned to x, and vice versa.
        // The sign of the numerator corresponds to the sign of x.
    **/
    @:keep
    public dynamic function num():Ref<Int_> return __self__.value.num();
    /**
        // IsInt reports whether the denominator of x is 1.
    **/
    @:keep
    public dynamic function isInt():Bool return __self__.value.isInt();
    /**
        // Sign returns:
        //
        //	-1 if x <  0
        //	 0 if x == 0
        //	+1 if x >  0
    **/
    @:keep
    public dynamic function sign():GoInt return __self__.value.sign();
    /**
        // Inv sets z to 1/x and returns z.
        // If x == 0, Inv panics.
    **/
    @:keep
    public dynamic function inv(_x:Ref<Rat>):Ref<Rat> return __self__.value.inv(_x);
    /**
        // Neg sets z to -x and returns z.
    **/
    @:keep
    public dynamic function neg(_x:Ref<Rat>):Ref<Rat> return __self__.value.neg(_x);
    /**
        // Abs sets z to |x| (the absolute value of x) and returns z.
    **/
    @:keep
    public dynamic function abs(_x:Ref<Rat>):Ref<Rat> return __self__.value.abs(_x);
    /**
        // Set sets z to x (by making a copy of x) and returns z.
    **/
    @:keep
    public dynamic function set(_x:Ref<Rat>):Ref<Rat> return __self__.value.set(_x);
    /**
        // SetUint64 sets z to x and returns z.
    **/
    @:keep
    public dynamic function setUint64(_x:GoUInt64):Ref<Rat> return __self__.value.setUint64(_x);
    /**
        // SetInt64 sets z to x and returns z.
    **/
    @:keep
    public dynamic function setInt64(_x:GoInt64):Ref<Rat> return __self__.value.setInt64(_x);
    /**
        // SetInt sets z to x (by making a copy of x) and returns z.
    **/
    @:keep
    public dynamic function setInt(_x:Ref<Int_>):Ref<Rat> return __self__.value.setInt(_x);
    /**
        // SetFrac64 sets z to a/b and returns z.
        // If b == 0, SetFrac64 panics.
    **/
    @:keep
    public dynamic function setFrac64(_a:GoInt64, _b:GoInt64):Ref<Rat> return __self__.value.setFrac64(_a, _b);
    /**
        // SetFrac sets z to a/b and returns z.
        // If b == 0, SetFrac panics.
    **/
    @:keep
    public dynamic function setFrac(_a:Ref<Int_>, _b:Ref<Int_>):Ref<Rat> return __self__.value.setFrac(_a, _b);
    /**
        // Float64 returns the nearest float64 value for x and a bool indicating
        // whether f represents x exactly. If the magnitude of x is too large to
        // be represented by a float64, f is an infinity and exact is false.
        // The sign of f always matches the sign of x, even if f == 0.
    **/
    @:keep
    public dynamic function float64():{ var _0 : GoFloat64; var _1 : Bool; } return __self__.value.float64();
    /**
        // Float32 returns the nearest float32 value for x and a bool indicating
        // whether f represents x exactly. If the magnitude of x is too large to
        // be represented by a float32, f is an infinity and exact is false.
        // The sign of f always matches the sign of x, even if f == 0.
    **/
    @:keep
    public dynamic function float32():{ var _0 : GoFloat32; var _1 : Bool; } return __self__.value.float32();
    /**
        // SetFloat64 sets z to exactly f and returns z.
        // If f is not finite, SetFloat returns nil.
    **/
    @:keep
    public dynamic function setFloat64(_f:GoFloat64):Ref<Rat> return __self__.value.setFloat64(_f);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Rat>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.Rat_asInterface) class Rat_static_extension {
    /**
        // UnmarshalText implements the encoding.TextUnmarshaler interface.
    **/
    @:keep
    static public function unmarshalText( _z:Ref<Rat>, _text:Slice<GoByte>):Error {
        {
            var __tmp__ = _z.setString((_text : GoString)), __0:Ref<stdgo.math.big.Big.Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                return stdgo.fmt.Fmt.errorf(("math/big: cannot unmarshal %q into a *big.Rat" : GoString), Go.toInterface(_text));
            };
        };
        return (null : Error);
    }
    /**
        // MarshalText implements the encoding.TextMarshaler interface.
    **/
    @:keep
    static public function marshalText( _x:Ref<Rat>):{ var _0 : Slice<GoByte>; var _1 : Error; } {
        var _text:Slice<GoByte> = (null : Slice<GoUInt8>), _err:Error = (null : Error);
        if (_x.isInt()) {
            return _x._a.marshalText();
        };
        return { _0 : _x._marshal(), _1 : (null : Error) };
    }
    /**
        // GobDecode implements the gob.GobDecoder interface.
    **/
    @:keep
    static public function gobDecode( _z:Ref<Rat>, _buf:Slice<GoByte>):Error {
        if ((_buf.length) == ((0 : GoInt))) {
            {
                var __tmp__ = (new Rat() : Rat);
                _z._a = __tmp__._a;
                _z._b = __tmp__._b;
            };
            return (null : Error);
        };
        if ((_buf.length) < (5 : GoInt)) {
            return stdgo.errors.Errors.new_(("Rat.GobDecode: buffer too small" : GoString));
        };
        var _b:GoUInt8 = _buf[(0 : GoInt)];
        if (_b >> (1i64 : GoUInt64) != ((1 : GoUInt8))) {
            return stdgo.fmt.Fmt.errorf(("Rat.GobDecode: encoding version %d not supported" : GoString), Go.toInterface(_b >> (1i64 : GoUInt64)));
        };
        {};
        var _ln:GoUInt32 = stdgo.encoding.binary.Binary.bigEndian.uint32((_buf.__slice__((1 : GoInt), (5 : GoInt)) : Slice<GoUInt8>));
        if ((_ln : GoUInt64) > (2147483642i64 : GoUInt64)) {
            return stdgo.errors.Errors.new_(("Rat.GobDecode: invalid length" : GoString));
        };
        var _i:GoInt = (5 : GoInt) + (_ln : GoInt);
        if ((_buf.length) < _i) {
            return stdgo.errors.Errors.new_(("Rat.GobDecode: buffer too small" : GoString));
        };
        _z._a._neg = _b & (1 : GoUInt8) != ((0 : GoUInt8));
        _z._a._abs = _z._a._abs._setBytes((_buf.__slice__((5 : GoInt), _i) : Slice<GoUInt8>));
        _z._b._abs = _z._b._abs._setBytes((_buf.__slice__(_i) : Slice<GoUInt8>));
        return (null : Error);
    }
    /**
        // GobEncode implements the gob.GobEncoder interface.
    **/
    @:keep
    static public function gobEncode( _x:Ref<Rat>):{ var _0 : Slice<GoByte>; var _1 : Error; } {
        if (_x == null || (_x : Dynamic).__nil__) {
            return { _0 : (null : Slice<GoUInt8>), _1 : (null : Error) };
        };
        var _buf = new Slice<GoUInt8>(((5 : GoInt) + ((_x._a._abs.length + _x._b._abs.length) * (4 : GoInt)) : GoInt).toBasic(), 0, ...[for (i in 0 ... ((5 : GoInt) + ((_x._a._abs.length + _x._b._abs.length) * (4 : GoInt)) : GoInt).toBasic()) (0 : GoUInt8)]);
        var _i:GoInt = _x._b._abs._bytes(_buf);
        var _j:GoInt = _x._a._abs._bytes((_buf.__slice__(0, _i) : Slice<GoUInt8>));
        var _n:GoInt = _i - _j;
        if (((_n : GoUInt32) : GoInt) != (_n)) {
            return { _0 : (null : Slice<GoUInt8>), _1 : stdgo.errors.Errors.new_(("Rat.GobEncode: numerator too large" : GoString)) };
        };
        stdgo.encoding.binary.Binary.bigEndian.putUint32((_buf.__slice__(_j - (4 : GoInt), _j) : Slice<GoUInt8>), (_n : GoUInt32));
        _j = _j - ((5 : GoInt));
        var _b:GoUInt8 = (2 : GoUInt8);
        if (_x._a._neg) {
            _b = _b | ((1 : GoUInt8));
        };
        _buf[(_j : GoInt)] = _b;
        return { _0 : (_buf.__slice__(_j) : Slice<GoUInt8>), _1 : (null : Error) };
    }
    /**
        // FloatString returns a string representation of x in decimal form with prec
        // digits of precision after the radix point. The last digit is rounded to
        // nearest, with halves rounded away from zero.
    **/
    @:keep
    static public function floatString( _x:Ref<Rat>, _prec:GoInt):GoString {
        var _buf:Slice<GoByte> = (null : Slice<GoUInt8>);
        if (_x.isInt()) {
            _buf = _x._a.append(_buf, (10 : GoInt));
            if (_prec > (0 : GoInt)) {
                _buf = _buf.__appendref__((46 : GoUInt8));
                {
                    var _i:GoInt = _prec;
                    Go.cfor(_i > (0 : GoInt), _i--, {
                        _buf = _buf.__appendref__((48 : GoUInt8));
                    });
                };
            };
            return (_buf : GoString);
        };
        var __tmp__ = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._div((new stdgo.math.big.Big.T_nat(0, 0) : T_nat), _x._a._abs, _x._b._abs), _q:stdgo.math.big.Big.T_nat = __tmp__._0, _r:stdgo.math.big.Big.T_nat = __tmp__._1;
        var _p:stdgo.math.big.Big.T_nat = _natOne;
        if (_prec > (0 : GoInt)) {
            _p = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._expNN(_natTen, (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._setUint64((_prec : GoUInt64)), null, false);
        };
        _r = _r._mul(_r, _p);
        var __tmp__ = _r._div((new stdgo.math.big.Big.T_nat(0, 0) : T_nat), _r, _x._b._abs), _r:stdgo.math.big.Big.T_nat = __tmp__._0, _r2:stdgo.math.big.Big.T_nat = __tmp__._1;
        _r2 = _r2._add(_r2, _r2);
        if (_x._b._abs._cmp(_r2) <= (0 : GoInt)) {
            _r = _r._add(_r, _natOne);
            if (_r._cmp(_p) >= (0 : GoInt)) {
                _q = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._add(_q, _natOne);
                _r = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._sub(_r, _p);
            };
        };
        if (_x._a._neg) {
            _buf = _buf.__appendref__((45 : GoUInt8));
        };
        _buf = _buf.__appendref__(..._q._utoa((10 : GoInt)).__toArray__());
        if (_prec > (0 : GoInt)) {
            _buf = _buf.__appendref__((46 : GoUInt8));
            var _rs = _r._utoa((10 : GoInt));
            {
                var _i:GoInt = _prec - (_rs.length);
                Go.cfor(_i > (0 : GoInt), _i--, {
                    _buf = _buf.__appendref__((48 : GoUInt8));
                });
            };
            _buf = _buf.__appendref__(..._rs.__toArray__());
        };
        return (_buf : GoString);
    }
    /**
        // RatString returns a string representation of x in the form "a/b" if b != 1,
        // and in the form "a" if b == 1.
    **/
    @:keep
    static public function ratString( _x:Ref<Rat>):GoString {
        if (_x.isInt()) {
            return (_x._a.string() : GoString);
        };
        return (_x.string() : GoString);
    }
    /**
        // marshal implements String returning a slice of bytes
    **/
    @:keep
    static public function _marshal( _x:Ref<Rat>):Slice<GoByte> {
        var _buf:Slice<GoByte> = (null : Slice<GoUInt8>);
        _buf = _x._a.append(_buf, (10 : GoInt));
        _buf = _buf.__appendref__((47 : GoUInt8));
        if ((_x._b._abs.length) != ((0 : GoInt))) {
            _buf = _x._b.append(_buf, (10 : GoInt));
        } else {
            _buf = _buf.__appendref__((49 : GoUInt8));
        };
        return _buf;
    }
    /**
        // String returns a string representation of x in the form "a/b" (even if b == 1).
    **/
    @:keep
    static public function string( _x:Ref<Rat>):GoString {
        return (_x._marshal() : GoString);
    }
    /**
        // SetString sets z to the value of s and returns z and a boolean indicating
        // success. s can be given as a (possibly signed) fraction "a/b", or as a
        // floating-point number optionally followed by an exponent.
        // If a fraction is provided, both the dividend and the divisor may be a
        // decimal integer or independently use a prefix of 0b, 0 or 0o,
        // or 0x (or their upper-case variants) to denote a binary, octal, or
        // hexadecimal integer, respectively. The divisor may not be signed.
        // If a floating-point number is provided, it may be in decimal form or
        // use any of the same prefixes as above but for 0 to denote a non-decimal
        // mantissa. A leading 0 is considered a decimal leading 0; it does not
        // indicate octal representation in this case.
        // An optional base-10 e or base-2 p (or their upper-case variants)
        // exponent may be provided as well, except for hexadecimal floats which
        // only accept an (optional) p exponent (because an e or E cannot
        // be distinguished from a mantissa digit). If the exponent's absolute value
        // is too large, the operation may fail.
        // The entire string, not just a prefix, must be valid for success. If the
        // operation failed, the value of z is undefined but the returned value is nil.
    **/
    @:keep
    static public function setString( _z:Ref<Rat>, _s:GoString):{ var _0 : Ref<Rat>; var _1 : Bool; } {
        if ((_s.length) == ((0 : GoInt))) {
            return { _0 : null, _1 : false };
        };
        {
            var _sep:GoInt = stdgo.strings.Strings.index(_s, ("/" : GoString));
            if (_sep >= (0 : GoInt)) {
                {
                    var __tmp__ = _z._a.setString((_s.__slice__(0, _sep) : GoString), (0 : GoInt)), __0:Ref<stdgo.math.big.Big.Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
                    if (!_ok) {
                        return { _0 : null, _1 : false };
                    };
                };
                var _r = stdgo.strings.Strings.newReader((_s.__slice__(_sep + (1 : GoInt)) : GoString));
                var _err:Error = (null : Error);
                {
                    {
                        var __tmp__ = _z._b._abs._scan(Go.asInterface(_r), (0 : GoInt), false);
                        _z._b._abs = __tmp__._0;
                        _err = __tmp__._3;
                    };
                    if (_err != null) {
                        return { _0 : null, _1 : false };
                    };
                };
                {
                    {
                        var __tmp__ = _r.readByte();
                        _err = __tmp__._1;
                    };
                    if (Go.toInterface(_err) != (Go.toInterface(stdgo.io.Io.eof))) {
                        return { _0 : null, _1 : false };
                    };
                };
                if ((_z._b._abs.length) == ((0 : GoInt))) {
                    return { _0 : null, _1 : false };
                };
                return { _0 : _z._norm(), _1 : true };
            };
        };
        var _r = stdgo.strings.Strings.newReader(_s);
        var __tmp__ = _scanSign(Go.asInterface(_r)), _neg:Bool = __tmp__._0, _err:Error = __tmp__._1;
        if (_err != null) {
            return { _0 : null, _1 : false };
        };
        var _base:GoInt = (0 : GoInt);
        var _fcount:GoInt = (0 : GoInt);
        {
            var __tmp__ = _z._a._abs._scan(Go.asInterface(_r), (0 : GoInt), true);
            _z._a._abs = __tmp__._0;
            _base = __tmp__._1;
            _fcount = __tmp__._2;
            _err = __tmp__._3;
        };
        if (_err != null) {
            return { _0 : null, _1 : false };
        };
        var _exp:GoInt64 = (0 : GoInt64);
        var _ebase:GoInt = (0 : GoInt);
        {
            var __tmp__ = _scanExponent(Go.asInterface(_r), true, true);
            _exp = __tmp__._0;
            _ebase = __tmp__._1;
            _err = __tmp__._2;
        };
        if (_err != null) {
            return { _0 : null, _1 : false };
        };
        {
            {
                var __tmp__ = _r.readByte();
                _err = __tmp__._1;
            };
            if (Go.toInterface(_err) != (Go.toInterface(stdgo.io.Io.eof))) {
                return { _0 : null, _1 : false };
            };
        };
        if ((_z._a._abs.length) == ((0 : GoInt))) {
            return { _0 : _z._norm(), _1 : true };
        };
        var __0:GoInt64 = (0 : GoInt64), __1:GoInt64 = (0 : GoInt64), _exp5:GoInt64 = __1, _exp2:GoInt64 = __0;
        if (_fcount < (0 : GoInt)) {
            var _d:GoInt64 = (_fcount : GoInt64);
            {
                var __switchIndex__ = -1;
                while (true) {
                    {
                        final __value__ = _base;
                        if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (__value__ == (10 : GoInt)))) {
                            _exp5 = _d;
                            @:fallthrough {
                                __switchIndex__ = 1;
                                continue;
                            };
                            break;
                        } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && (__value__ == (2 : GoInt)))) {
                            _exp2 = _d;
                            break;
                            break;
                        } else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && (__value__ == (8 : GoInt)))) {
                            _exp2 = _d * (3i64 : GoInt64);
                            break;
                            break;
                        } else if (__switchIndex__ == 3 || (__switchIndex__ == -1 && (__value__ == (16 : GoInt)))) {
                            _exp2 = _d * (4i64 : GoInt64);
                            break;
                            break;
                        } else {
                            throw Go.toInterface(("unexpected mantissa base" : GoString));
                            break;
                        };
                    };
                    break;
                };
            };
        };
        {
            var __switchIndex__ = -1;
            while (true) {
                {
                    final __value__ = _ebase;
                    if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (__value__ == (10 : GoInt)))) {
                        _exp5 = _exp5 + (_exp);
                        @:fallthrough {
                            __switchIndex__ = 1;
                            continue;
                        };
                        break;
                    } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && (__value__ == (2 : GoInt)))) {
                        _exp2 = _exp2 + (_exp);
                        break;
                        break;
                    } else {
                        throw Go.toInterface(("unexpected exponent base" : GoString));
                        break;
                    };
                };
                break;
            };
        };
        if (_exp5 != ((0i64 : GoInt64))) {
            var _n:GoInt64 = _exp5;
            if (_n < (0i64 : GoInt64)) {
                _n = -_n;
                if (_n < (0i64 : GoInt64)) {
                    return { _0 : null, _1 : false };
                };
            };
            if (_n > (1000000i64 : GoInt64)) {
                return { _0 : null, _1 : false };
            };
            var _pow5:stdgo.math.big.Big.T_nat = _z._b._abs._expNN(_natFive, (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._setWord((_n : Word)), null, false);
            if (_exp5 > (0i64 : GoInt64)) {
                _z._a._abs = _z._a._abs._mul(_z._a._abs, _pow5);
                _z._b._abs = _z._b._abs._setWord((1u32 : stdgo.math.big.Big.Word));
            } else {
                _z._b._abs = _pow5;
            };
        } else {
            _z._b._abs = _z._b._abs._setWord((1u32 : stdgo.math.big.Big.Word));
        };
        if ((_exp2 < (-10000000i64 : GoInt64)) || (_exp2 > (10000000i64 : GoInt64))) {
            return { _0 : null, _1 : false };
        };
        if (_exp2 > (0i64 : GoInt64)) {
            _z._a._abs = _z._a._abs._shl(_z._a._abs, (_exp2 : GoUInt));
        } else if (_exp2 < (0i64 : GoInt64)) {
            _z._b._abs = _z._b._abs._shl(_z._b._abs, (-_exp2 : GoUInt));
        };
        _z._a._neg = _neg && (_z._a._abs.length > (0 : GoInt));
        return { _0 : _z._norm(), _1 : true };
    }
    /**
        // Scan is a support routine for fmt.Scanner. It accepts the formats
        // 'e', 'E', 'f', 'F', 'g', 'G', and 'v'. All formats are equivalent.
    **/
    @:keep
    static public function scan( _z:Ref<Rat>, _s:stdgo.fmt.Fmt.ScanState, _ch:GoRune):Error {
        var __tmp__ = _s.token(true, _ratTok), _tok:Slice<GoUInt8> = __tmp__._0, _err:Error = __tmp__._1;
        if (_err != null) {
            return _err;
        };
        if (!stdgo.strings.Strings.containsRune(("efgEFGv" : GoString), _ch)) {
            return stdgo.errors.Errors.new_(("Rat.Scan: invalid verb" : GoString));
        };
        {
            var __tmp__ = _z.setString((_tok : GoString)), __0:Ref<stdgo.math.big.Big.Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                return stdgo.errors.Errors.new_(("Rat.Scan: invalid syntax" : GoString));
            };
        };
        return (null : Error);
    }
    /**
        // Quo sets z to the quotient x/y and returns z.
        // If y == 0, Quo panics.
    **/
    @:keep
    static public function quo( _z:Ref<Rat>, _x:Ref<Rat>, _y:Ref<Rat>):Ref<Rat> {
        if ((_y._a._abs.length) == ((0 : GoInt))) {
            throw Go.toInterface(("division by zero" : GoString));
        };
        var __0:Int_ = ({} : stdgo.math.big.Big.Int_), __1:Int_ = ({} : stdgo.math.big.Big.Int_), _b:Int_ = __1, _a:Int_ = __0;
        _a._scaleDenom((Go.setRef(_x._a) : Ref<stdgo.math.big.Big.Int_>), _y._b._abs);
        _b._scaleDenom((Go.setRef(_y._a) : Ref<stdgo.math.big.Big.Int_>), _x._b._abs);
        _z._a._abs = _a._abs;
        _z._b._abs = _b._abs;
        _z._a._neg = _a._neg != (_b._neg);
        return _z._norm();
    }
    /**
        // Mul sets z to the product x*y and returns z.
    **/
    @:keep
    static public function mul( _z:Ref<Rat>, _x:Ref<Rat>, _y:Ref<Rat>):Ref<Rat> {
        if (_x == (_y)) {
            _z._a._neg = false;
            _z._a._abs = _z._a._abs._sqr(_x._a._abs);
            if ((_x._b._abs.length) == ((0 : GoInt))) {
                _z._b._abs = _z._b._abs._setWord((1u32 : stdgo.math.big.Big.Word));
            } else {
                _z._b._abs = _z._b._abs._sqr(_x._b._abs);
            };
            return _z;
        };
        _z._a.mul((Go.setRef(_x._a) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_y._a) : Ref<stdgo.math.big.Big.Int_>));
        _z._b._abs = _mulDenom(_z._b._abs, _x._b._abs, _y._b._abs);
        return _z._norm();
    }
    /**
        // Sub sets z to the difference x-y and returns z.
    **/
    @:keep
    static public function sub( _z:Ref<Rat>, _x:Ref<Rat>, _y:Ref<Rat>):Ref<Rat> {
        var __0:Int_ = ({} : stdgo.math.big.Big.Int_), __1:Int_ = ({} : stdgo.math.big.Big.Int_), _a2:Int_ = __1, _a1:Int_ = __0;
        _a1._scaleDenom((Go.setRef(_x._a) : Ref<stdgo.math.big.Big.Int_>), _y._b._abs);
        _a2._scaleDenom((Go.setRef(_y._a) : Ref<stdgo.math.big.Big.Int_>), _x._b._abs);
        _z._a.sub((Go.setRef(_a1) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_a2) : Ref<stdgo.math.big.Big.Int_>));
        _z._b._abs = _mulDenom(_z._b._abs, _x._b._abs, _y._b._abs);
        return _z._norm();
    }
    /**
        // Add sets z to the sum x+y and returns z.
    **/
    @:keep
    static public function add( _z:Ref<Rat>, _x:Ref<Rat>, _y:Ref<Rat>):Ref<Rat> {
        var __0:Int_ = ({} : stdgo.math.big.Big.Int_), __1:Int_ = ({} : stdgo.math.big.Big.Int_), _a2:Int_ = __1, _a1:Int_ = __0;
        _a1._scaleDenom((Go.setRef(_x._a) : Ref<stdgo.math.big.Big.Int_>), _y._b._abs);
        _a2._scaleDenom((Go.setRef(_y._a) : Ref<stdgo.math.big.Big.Int_>), _x._b._abs);
        _z._a.add((Go.setRef(_a1) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_a2) : Ref<stdgo.math.big.Big.Int_>));
        _z._b._abs = _mulDenom(_z._b._abs, _x._b._abs, _y._b._abs);
        return _z._norm();
    }
    /**
        // Cmp compares x and y and returns:
        //
        //	-1 if x <  y
        //	 0 if x == y
        //	+1 if x >  y
    **/
    @:keep
    static public function cmp( _x:Ref<Rat>, _y:Ref<Rat>):GoInt {
        var __0:Int_ = ({} : stdgo.math.big.Big.Int_), __1:Int_ = ({} : stdgo.math.big.Big.Int_), _b:Int_ = __1, _a:Int_ = __0;
        _a._scaleDenom((Go.setRef(_x._a) : Ref<stdgo.math.big.Big.Int_>), _y._b._abs);
        _b._scaleDenom((Go.setRef(_y._a) : Ref<stdgo.math.big.Big.Int_>), _x._b._abs);
        return _a.cmp((Go.setRef(_b) : Ref<stdgo.math.big.Big.Int_>));
    }
    @:keep
    static public function _norm( _z:Ref<Rat>):Ref<Rat> {
        {
            var __switchIndex__ = -1;
            while (true) {
                if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (_z._a._abs.length == (0 : GoInt)))) {
                    _z._a._neg = false;
                    @:fallthrough {
                        __switchIndex__ = 1;
                        continue;
                    };
                    break;
                } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && (_z._b._abs.length == (0 : GoInt)))) {
                    _z._b._abs = _z._b._abs._setWord((1u32 : stdgo.math.big.Big.Word));
                    break;
                    break;
                } else {
                    var _neg:Bool = _z._a._neg;
                    _z._a._neg = false;
                    _z._b._neg = false;
                    {
                        var _f = newInt((0i64 : GoInt64))._lehmerGCD(null, null, (Go.setRef(_z._a) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(_z._b) : Ref<stdgo.math.big.Big.Int_>));
                        if (_f.cmp(_intOne) != ((0 : GoInt))) {
                            {
                                var __tmp__ = _z._a._abs._div(null, _z._a._abs, _f._abs);
                                _z._a._abs = __tmp__._0;
                            };
                            {
                                var __tmp__ = _z._b._abs._div(null, _z._b._abs, _f._abs);
                                _z._b._abs = __tmp__._0;
                            };
                        };
                    };
                    _z._a._neg = _neg;
                    break;
                };
                break;
            };
        };
        return _z;
    }
    /**
        // Denom returns the denominator of x; it is always > 0.
        // The result is a reference to x's denominator, unless
        // x is an uninitialized (zero value) Rat, in which case
        // the result is a new Int of value 1. (To initialize x,
        // any operation that sets x will do, including x.Set(x).)
        // If the result is a reference to x's denominator it
        // may change if a new value is assigned to x, and vice versa.
    **/
    @:keep
    static public function denom( _x:Ref<Rat>):Ref<Int_> {
        if ((_x._b._abs.length) == ((0 : GoInt))) {
            return (Go.setRef(({ _abs : (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat) } : Int_)) : Ref<stdgo.math.big.Big.Int_>);
        };
        return (Go.setRef(_x._b) : Ref<stdgo.math.big.Big.Int_>);
    }
    /**
        // Num returns the numerator of x; it may be <= 0.
        // The result is a reference to x's numerator; it
        // may change if a new value is assigned to x, and vice versa.
        // The sign of the numerator corresponds to the sign of x.
    **/
    @:keep
    static public function num( _x:Ref<Rat>):Ref<Int_> {
        return (Go.setRef(_x._a) : Ref<stdgo.math.big.Big.Int_>);
    }
    /**
        // IsInt reports whether the denominator of x is 1.
    **/
    @:keep
    static public function isInt( _x:Ref<Rat>):Bool {
        return (_x._b._abs.length == (0 : GoInt)) || (_x._b._abs._cmp(_natOne) == (0 : GoInt));
    }
    /**
        // Sign returns:
        //
        //	-1 if x <  0
        //	 0 if x == 0
        //	+1 if x >  0
    **/
    @:keep
    static public function sign( _x:Ref<Rat>):GoInt {
        return _x._a.sign();
    }
    /**
        // Inv sets z to 1/x and returns z.
        // If x == 0, Inv panics.
    **/
    @:keep
    static public function inv( _z:Ref<Rat>, _x:Ref<Rat>):Ref<Rat> {
        if ((_x._a._abs.length) == ((0 : GoInt))) {
            throw Go.toInterface(("division by zero" : GoString));
        };
        _z.set(_x);
        {
            final __tmp__0 = _z._b._abs;
            final __tmp__1 = _z._a._abs;
            _z._a._abs = __tmp__0;
            _z._b._abs = __tmp__1;
        };
        return _z;
    }
    /**
        // Neg sets z to -x and returns z.
    **/
    @:keep
    static public function neg( _z:Ref<Rat>, _x:Ref<Rat>):Ref<Rat> {
        _z.set(_x);
        _z._a._neg = (_z._a._abs.length > (0 : GoInt)) && !_z._a._neg;
        return _z;
    }
    /**
        // Abs sets z to |x| (the absolute value of x) and returns z.
    **/
    @:keep
    static public function abs( _z:Ref<Rat>, _x:Ref<Rat>):Ref<Rat> {
        _z.set(_x);
        _z._a._neg = false;
        return _z;
    }
    /**
        // Set sets z to x (by making a copy of x) and returns z.
    **/
    @:keep
    static public function set( _z:Ref<Rat>, _x:Ref<Rat>):Ref<Rat> {
        if (_z != (_x)) {
            _z._a.set((Go.setRef(_x._a) : Ref<stdgo.math.big.Big.Int_>));
            _z._b.set((Go.setRef(_x._b) : Ref<stdgo.math.big.Big.Int_>));
        };
        if ((_z._b._abs.length) == ((0 : GoInt))) {
            _z._b._abs = _z._b._abs._setWord((1u32 : stdgo.math.big.Big.Word));
        };
        return _z;
    }
    /**
        // SetUint64 sets z to x and returns z.
    **/
    @:keep
    static public function setUint64( _z:Ref<Rat>, _x:GoUInt64):Ref<Rat> {
        _z._a.setUint64(_x);
        _z._b._abs = _z._b._abs._setWord((1u32 : stdgo.math.big.Big.Word));
        return _z;
    }
    /**
        // SetInt64 sets z to x and returns z.
    **/
    @:keep
    static public function setInt64( _z:Ref<Rat>, _x:GoInt64):Ref<Rat> {
        _z._a.setInt64(_x);
        _z._b._abs = _z._b._abs._setWord((1u32 : stdgo.math.big.Big.Word));
        return _z;
    }
    /**
        // SetInt sets z to x (by making a copy of x) and returns z.
    **/
    @:keep
    static public function setInt( _z:Ref<Rat>, _x:Ref<Int_>):Ref<Rat> {
        _z._a.set(_x);
        _z._b._abs = _z._b._abs._setWord((1u32 : stdgo.math.big.Big.Word));
        return _z;
    }
    /**
        // SetFrac64 sets z to a/b and returns z.
        // If b == 0, SetFrac64 panics.
    **/
    @:keep
    static public function setFrac64( _z:Ref<Rat>, _a:GoInt64, _b:GoInt64):Ref<Rat> {
        if (_b == ((0i64 : GoInt64))) {
            throw Go.toInterface(("division by zero" : GoString));
        };
        _z._a.setInt64(_a);
        if (_b < (0i64 : GoInt64)) {
            _b = -_b;
            _z._a._neg = !_z._a._neg;
        };
        _z._b._abs = _z._b._abs._setUint64((_b : GoUInt64));
        return _z._norm();
    }
    /**
        // SetFrac sets z to a/b and returns z.
        // If b == 0, SetFrac panics.
    **/
    @:keep
    static public function setFrac( _z:Ref<Rat>, _a:Ref<Int_>, _b:Ref<Int_>):Ref<Rat> {
        _z._a._neg = _a._neg != (_b._neg);
        var _babs:stdgo.math.big.Big.T_nat = _b._abs;
        if ((_babs.length) == ((0 : GoInt))) {
            throw Go.toInterface(("division by zero" : GoString));
        };
        if (((Go.setRef(_z._a) : Ref<stdgo.math.big.Big.Int_>) == _b) || _alias(_z._a._abs, _babs)) {
            _babs = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._set(_babs);
        };
        _z._a._abs = _z._a._abs._set(_a._abs);
        _z._b._abs = _z._b._abs._set(_babs);
        return _z._norm();
    }
    /**
        // Float64 returns the nearest float64 value for x and a bool indicating
        // whether f represents x exactly. If the magnitude of x is too large to
        // be represented by a float64, f is an infinity and exact is false.
        // The sign of f always matches the sign of x, even if f == 0.
    **/
    @:keep
    static public function float64( _x:Ref<Rat>):{ var _0 : GoFloat64; var _1 : Bool; } {
        var _f:GoFloat64 = (0 : GoFloat64), _exact:Bool = false;
        var _b:stdgo.math.big.Big.T_nat = _x._b._abs;
        if ((_b.length) == ((0 : GoInt))) {
            _b = _natOne;
        };
        {
            var __tmp__ = _quotToFloat64(_x._a._abs, _b);
            _f = __tmp__._0;
            _exact = __tmp__._1;
        };
        if (_x._a._neg) {
            _f = -_f;
        };
        return { _0 : _f, _1 : _exact };
    }
    /**
        // Float32 returns the nearest float32 value for x and a bool indicating
        // whether f represents x exactly. If the magnitude of x is too large to
        // be represented by a float32, f is an infinity and exact is false.
        // The sign of f always matches the sign of x, even if f == 0.
    **/
    @:keep
    static public function float32( _x:Ref<Rat>):{ var _0 : GoFloat32; var _1 : Bool; } {
        var _f:GoFloat32 = (0 : GoFloat32), _exact:Bool = false;
        var _b:stdgo.math.big.Big.T_nat = _x._b._abs;
        if ((_b.length) == ((0 : GoInt))) {
            _b = _natOne;
        };
        {
            var __tmp__ = _quotToFloat32(_x._a._abs, _b);
            _f = __tmp__._0;
            _exact = __tmp__._1;
        };
        if (_x._a._neg) {
            _f = -_f;
        };
        return { _0 : _f, _1 : _exact };
    }
    /**
        // SetFloat64 sets z to exactly f and returns z.
        // If f is not finite, SetFloat returns nil.
    **/
    @:keep
    static public function setFloat64( _z:Ref<Rat>, _f:GoFloat64):Ref<Rat> {
        {};
        var _bits:GoUInt64 = stdgo.math.Math.float64bits(_f);
        var _mantissa:GoUInt64 = _bits & (4503599627370495i64 : GoUInt64);
        var _exp:GoInt = ((_bits >> (52i64 : GoUInt64)) & (2047i64 : GoUInt64) : GoInt);
        {
            final __value__ = _exp;
            if (__value__ == ((2047 : GoInt))) {
                return null;
            } else if (__value__ == ((0 : GoInt))) {
                _exp = _exp - ((1022 : GoInt));
            } else {
                _mantissa = _mantissa | ((4503599627370496i64 : GoUInt64));
                _exp = _exp - ((1023 : GoInt));
            };
        };
        var _shift:GoInt = (52 : GoInt) - _exp;
        while (((_mantissa & (1i64 : GoUInt64)) == (0i64 : GoUInt64)) && (_shift > (0 : GoInt))) {
            _mantissa = _mantissa >> ((1i64 : GoUInt64));
            _shift--;
        };
        _z._a.setUint64(_mantissa);
        _z._a._neg = _f < (0 : GoFloat64);
        _z._b.set(_intOne);
        if (_shift > (0 : GoInt)) {
            _z._b.lsh((Go.setRef(_z._b) : Ref<stdgo.math.big.Big.Int_>), (_shift : GoUInt));
        } else {
            _z._a.lsh((Go.setRef(_z._a) : Ref<stdgo.math.big.Big.Int_>), (-_shift : GoUInt));
        };
        return _z._norm();
    }
}
class Bits_asInterface {
    /**
        // Float returns the *Float z of the smallest possible precision such that
        // z = sum(2**bits[i]), with i = range bits. If multiple bits[i] are equal,
        // they are added: Bits{0, 1, 0}.Float() == 2**0 + 2**1 + 2**0 = 4.
    **/
    @:keep
    public dynamic function float_():Ref<Float_> return __self__.value.float_();
    /**
        // round returns the Float value corresponding to x after rounding x
        // to prec bits according to mode.
    **/
    @:keep
    public dynamic function _round(_prec:GoUInt, _mode:RoundingMode):Ref<Float_> return __self__.value._round(_prec, _mode);
    /**
        // norm returns the normalized bits for x: It removes multiple equal entries
        // by treating them as an addition (e.g., Bits{5, 5} => Bits{6}), and it sorts
        // the result list for reproducible results.
    **/
    @:keep
    public dynamic function _norm():Bits return __self__.value._norm();
    @:keep
    public dynamic function _mul(_y:Bits):Bits return __self__.value._mul(_y);
    @:keep
    public dynamic function _add(_y:Bits):Bits return __self__.value._add(_y);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Bits>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.Bits_asInterface) class Bits_static_extension {
    /**
        // Float returns the *Float z of the smallest possible precision such that
        // z = sum(2**bits[i]), with i = range bits. If multiple bits[i] are equal,
        // they are added: Bits{0, 1, 0}.Float() == 2**0 + 2**1 + 2**0 = 4.
    **/
    @:keep
    static public function float_( _bits:Bits):Ref<Float_> {
        if ((_bits.length) == ((0 : GoInt))) {
            return (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>);
        };
        var _min:GoInt = (0 : GoInt);
        for (_i => _b in _bits) {
            if ((_i == (0 : GoInt)) || (_b < _min)) {
                _min = _b;
            };
        };
        var _x = newInt((0i64 : GoInt64));
        for (__0 => _b in _bits) {
            var _badj:GoInt = _b - _min;
            while (_x.bit(_badj) != ((0u32 : GoUInt))) {
                _x.setBit(_x, _badj, (0u32 : GoUInt));
                _badj++;
            };
            _x.setBit(_x, _badj, (1u32 : GoUInt));
        };
        var _z = (Go.setRef(({} : stdgo.math.big.Big.Float_)) : Ref<stdgo.math.big.Big.Float_>).setInt(_x);
        {
            var _e:GoInt64 = (_z._exp : GoInt64) + (_min : GoInt64);
            if (((-2147483648i64 : GoInt64) <= _e) && (_e <= (2147483647i64 : GoInt64))) {
                _z._exp = (_e : GoInt32);
            } else {
                throw Go.toInterface(("exponent out of range" : GoString));
            };
        };
        return _z;
    }
    /**
        // round returns the Float value corresponding to x after rounding x
        // to prec bits according to mode.
    **/
    @:keep
    static public function _round( _x:Bits, _prec:GoUInt, _mode:RoundingMode):Ref<Float_> {
        _x = _x._norm();
        var __0:GoInt = (0 : GoInt), __1:GoInt = (0 : GoInt), _max:GoInt = __1, _min:GoInt = __0;
        for (_i => _b in _x) {
            if ((_i == (0 : GoInt)) || (_b < _min)) {
                _min = _b;
            };
            if ((_i == (0 : GoInt)) || (_b > _max)) {
                _max = _b;
            };
        };
        var _prec0:GoUInt = ((_max + (1 : GoInt)) - _min : GoUInt);
        if (_prec >= _prec0) {
            return _x.float_();
        };
        var __0:GoUInt = (0 : GoUInt), __1:GoUInt = (0 : GoUInt), __2:GoUInt = (0 : GoUInt), _sbit:GoUInt = __2, _rbit:GoUInt = __1, _bit0:GoUInt = __0;
        var _z:Bits = new stdgo.math.big.Big.Bits(0, 0);
        var _r:GoInt = _max - (_prec : GoInt);
        for (__0 => _b in _x) {
            if (_b == (_r)) {
                _rbit = (1u32 : GoUInt);
            } else if (_b < _r) {
                _sbit = (1u32 : GoUInt);
            } else {
                if (_b == (_r + (1 : GoInt))) {
                    _bit0 = (1u32 : GoUInt);
                };
                _z = _z.__appendref__(_b);
            };
        };
        var _f = _z.float_();
        if (_mode == ((1 : stdgo.math.big.Big.RoundingMode))) {
            throw Go.toInterface(("not yet implemented" : GoString));
        };
        if ((((_mode == (0 : stdgo.math.big.Big.RoundingMode)) && (_rbit == (1u32 : GoUInt))) && ((_sbit == (1u32 : GoUInt)) || ((_sbit == (0u32 : GoUInt)) && (_bit0 != (0u32 : GoUInt))))) || (_mode == (3 : stdgo.math.big.Big.RoundingMode))) {
            _f.setMode((2 : stdgo.math.big.Big.RoundingMode)).setPrec(_prec);
            _f.add(_f, (new Slice<GoInt>(0, 0, (_r : GoInt) + (1 : GoInt)) : stdgo.math.big.Big.Bits).float_());
        };
        return _f;
    }
    /**
        // norm returns the normalized bits for x: It removes multiple equal entries
        // by treating them as an addition (e.g., Bits{5, 5} => Bits{6}), and it sorts
        // the result list for reproducible results.
    **/
    @:keep
    static public function _norm( _x:Bits):Bits {
        var _m = (new GoObjectMap<GoInt, Bool>(new stdgo.internal.reflect.Reflect._Type(stdgo.internal.reflect.Reflect.GoType.mapType({ get : () -> stdgo.internal.reflect.Reflect.GoType.basic(int_kind) }, { get : () -> stdgo.internal.reflect.Reflect.GoType.basic(bool_kind) }))) : GoMap<GoInt, Bool>);
        for (__0 => _b in _x) {
            while (_m[_b]) {
                _m[_b] = false;
                _b++;
            };
            _m[_b] = true;
        };
        var _z:Bits = new stdgo.math.big.Big.Bits(0, 0);
        for (_b => _set in _m) {
            if (_set) {
                _z = _z.__appendref__(_b);
            };
        };
        stdgo.sort.Sort.ints((_z : Slice<GoInt>));
        return _z;
    }
    @:keep
    static public function _mul( _x:Bits, _y:Bits):Bits {
        var _p:Bits = new stdgo.math.big.Big.Bits(0, 0);
        for (__0 => _x in _x) {
            for (__1 => _y in _y) {
                _p = _p.__appendref__(_x + _y);
            };
        };
        return _p;
    }
    @:keep
    static public function _add( _x:Bits, _y:Bits):Bits {
        return (_x.__append__(..._y.__toArray__()));
    }
}
class RoundingMode_asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<RoundingMode>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.RoundingMode_asInterface) class RoundingMode_static_extension {
    @:keep
    static public function string( _i:RoundingMode):GoString {
        if (_i >= ((6 : GoInt) : RoundingMode)) {
            return (("RoundingMode(" : GoString) + stdgo.strconv.Strconv.formatInt((_i : GoInt64), (10 : GoInt))) + (")" : GoString);
        };
        return (("ToNearestEvenToNearestAwayToZeroAwayFromZeroToNegativeInfToPositiveInf" : GoString).__slice__(__RoundingMode_index[(_i : GoInt)], __RoundingMode_index[(_i + (1 : stdgo.math.big.Big.RoundingMode) : GoInt)]) : GoString);
    }
}
class Accuracy_asInterface {
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<Accuracy>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.Accuracy_asInterface) class Accuracy_static_extension {
    @:keep
    static public function string( _i:Accuracy):GoString {
        _i = _i - ((-1 : stdgo.math.big.Big.Accuracy));
        if ((_i < (0 : stdgo.math.big.Big.Accuracy)) || (_i >= ((3 : GoInt) : Accuracy))) {
            return (("Accuracy(" : GoString) + stdgo.strconv.Strconv.formatInt((_i + (-1 : stdgo.math.big.Big.Accuracy) : GoInt64), (10 : GoInt))) + (")" : GoString);
        };
        return (("BelowExactAbove" : GoString).__slice__(__Accuracy_index[(_i : GoInt)], __Accuracy_index[(_i + (1 : stdgo.math.big.Big.Accuracy) : GoInt)]) : GoString);
    }
}
class T_nat_asInterface {
    /**
        // probablyPrimeLucas reports whether n passes the "almost extra strong" Lucas probable prime test,
        // using Baillie-OEIS parameter selection. This corresponds to "AESLPSP" on Jacobsen's tables (link below).
        // The combination of this test and a Miller-Rabin/Fermat test with base 2 gives a Baillie-PSW test.
        //
        // References:
        //
        // Baillie and Wagstaff, "Lucas Pseudoprimes", Mathematics of Computation 35(152),
        // October 1980, pp. 1391-1417, especially page 1401.
        // https://www.ams.org/journals/mcom/1980-35-152/S0025-5718-1980-0583518-6/S0025-5718-1980-0583518-6.pdf
        //
        // Grantham, "Frobenius Pseudoprimes", Mathematics of Computation 70(234),
        // March 2000, pp. 873-891.
        // https://www.ams.org/journals/mcom/2001-70-234/S0025-5718-00-01197-2/S0025-5718-00-01197-2.pdf
        //
        // Baillie, "Extra strong Lucas pseudoprimes", OEIS A217719, https://oeis.org/A217719.
        //
        // Jacobsen, "Pseudoprime Statistics, Tables, and Data", http://ntheory.org/pseudoprimes.html.
        //
        // Nicely, "The Baillie-PSW Primality Test", https://web.archive.org/web/20191121062007/http://www.trnicely.net/misc/bpsw.html.
        // (Note that Nicely's definition of the "extra strong" test gives the wrong Jacobi condition,
        // as pointed out by Jacobsen.)
        //
        // Crandall and Pomerance, Prime Numbers: A Computational Perspective, 2nd ed.
        // Springer, 2005.
    **/
    @:keep
    public dynamic function _probablyPrimeLucas():Bool return __self__.value._probablyPrimeLucas();
    /**
        // probablyPrimeMillerRabin reports whether n passes reps rounds of the
        // Miller-Rabin primality test, using pseudo-randomly chosen bases.
        // If force2 is true, one of the rounds is forced to use base 2.
        // See Handbook of Applied Cryptography, p. 139, Algorithm 4.24.
        // The number n is known to be non-zero.
    **/
    @:keep
    public dynamic function _probablyPrimeMillerRabin(_reps:GoInt, _force2:Bool):Bool return __self__.value._probablyPrimeMillerRabin(_reps, _force2);
    /**
        // divRecursiveStep is the actual implementation of recursive division.
        // It adds u/v to z and overwrites u with the remainder r.
        // z must be large enough to hold u/v.
        // It uses temps[depth] (allocating if needed) as a temporary live across
        // the recursive call. It also uses tmp, but not live across the recursion.
    **/
    @:keep
    public dynamic function _divRecursiveStep(_u:T_nat, _v:T_nat, _depth:GoInt, _tmp:Ref<T_nat>, _temps:Slice<Ref<T_nat>>):Void __self__.value._divRecursiveStep(_u, _v, _depth, _tmp, _temps);
    /**
        // divRecursive implements recursive division as described above.
        // It overwrites z with u/v and overwrites u with the remainder r.
        // z must be large enough to hold u/v.
        // This function is just for allocating and freeing temporaries
        // around divRecursiveStep, the real implementation.
    **/
    @:keep
    public dynamic function _divRecursive(_u:T_nat, _v:T_nat):Void __self__.value._divRecursive(_u, _v);
    /**
        // divBasic implements long division as described above.
        // It overwrites q with u/v and overwrites u with the remainder r.
        // q must be large enough to hold u/v.
    **/
    @:keep
    public dynamic function _divBasic(_u:T_nat, _v:T_nat):Void __self__.value._divBasic(_u, _v);
    /**
        // div returns q, r such that q = uIn/vIn and r = uIn%vIn = uIn - qvIn.
        // It uses z and u as the storage for q and r.
        // The caller must ensure that len(vIn)  2 (use divW otherwise)
        // and that len(uIn)  len(vIn) (the answer is 0, uIn otherwise).
    **/
    @:keep
    public dynamic function _divLarge(_u:T_nat, _uIn:T_nat, _vIn:T_nat):{ var _0 : T_nat; var _1 : T_nat; } return __self__.value._divLarge(_u, _uIn, _vIn);
    /**
        // modW returns x % d.
    **/
    @:keep
    public dynamic function _modW(_d:Word):Word return __self__.value._modW(_d);
    /**
        // divW returns q, r such that q = x/y and r = x%y = x - qy.
        // It uses z as the storage for q.
        // Note that y is a single digit (Word), not a big number.
    **/
    @:keep
    public dynamic function _divW(_x:T_nat, _y:Word):{ var _0 : T_nat; var _1 : Word; } return __self__.value._divW(_x, _y);
    /**
        // div returns q, r such that q = u/v and r = u%v = u - qv.
        // It uses z and z2 as the storage for q and r.
    **/
    @:keep
    public dynamic function _div(_z2:T_nat, _u:T_nat, _v:T_nat):{ var _0 : T_nat; var _1 : T_nat; } return __self__.value._div(_z2, _u, _v);
    /**
        // rem returns r such that r = u%v.
        // It uses z as the storage for r.
    **/
    @:keep
    public dynamic function _rem(_u:T_nat, _v:T_nat):T_nat return __self__.value._rem(_u, _v);
    /**
        // expWW computes x**y
    **/
    @:keep
    public dynamic function _expWW(_x:Word, _y:Word):T_nat return __self__.value._expWW(_x, _y);
    /**
        // Convert words of q to base b digits in s. If q is large, it is recursively "split in half"
        // by nat/nat division using tabulated divisors. Otherwise, it is converted iteratively using
        // repeated nat/Word division.
        //
        // The iterative method processes n Words by n divW() calls, each of which visits every Word in the
        // incrementally shortened q for a total of n + (n-1) + (n-2) ... + 2 + 1, or n(n+1)/2 divW()'s.
        // Recursive conversion divides q by its approximate square root, yielding two parts, each half
        // the size of q. Using the iterative method on both halves means 2 * (n/2)(n/2 + 1)/2 divW()'s
        // plus the expensive long div(). Asymptotically, the ratio is favorable at 1/2 the divW()'s, and
        // is made better by splitting the subblocks recursively. Best is to split blocks until one more
        // split would take longer (because of the nat/nat div()) than the twice as many divW()'s of the
        // iterative approach. This threshold is represented by leafSize. Benchmarking of leafSize in the
        // range 2..64 shows that values of 8 and 16 work well, with a 4x speedup at medium lengths and
        // ~30x for 20000 digits. Use nat_test.go's BenchmarkLeafSize tests to optimize leafSize for
        // specific hardware.
    **/
    @:keep
    public dynamic function _convertWords(_s:Slice<GoByte>, _b:Word, _ndigits:GoInt, _bb:Word, _table:Slice<T_divisor>):Void __self__.value._convertWords(_s, _b, _ndigits, _bb, _table);
    /**
        // itoa is like utoa but it prepends a '-' if neg && x != 0.
    **/
    @:keep
    public dynamic function _itoa(_neg:Bool, _base:GoInt):Slice<GoByte> return __self__.value._itoa(_neg, _base);
    /**
        // utoa converts x to an ASCII representation in the given base;
        // base must be between 2 and MaxBase, inclusive.
    **/
    @:keep
    public dynamic function _utoa(_base:GoInt):Slice<GoByte> return __self__.value._utoa(_base);
    /**
        // scan scans the number corresponding to the longest possible prefix
        // from r representing an unsigned number in a given conversion base.
        // scan returns the corresponding natural number res, the actual base b,
        // a digit count, and a read or syntax error err, if any.
        //
        // For base 0, an underscore character _ may appear between a base
        // prefix and an adjacent digit, and between successive digits; such
        // underscores do not change the value of the number, or the returned
        // digit count. Incorrect placement of underscores is reported as an
        // error if there are no other errors. If base != 0, underscores are
        // not recognized and thus terminate scanning like any other character
        // that is not a valid radix point or digit.
        //
        //	number    = mantissa | prefix pmantissa .
        //	prefix    = "0" [ "b" | "B" | "o" | "O" | "x" | "X" ] .
        //	mantissa  = digits "." [ digits ] | digits | "." digits .
        //	pmantissa = [ "_" ] digits "." [ digits ] | [ "_" ] digits | "." digits .
        //	digits    = digit { [ "_" ] digit } .
        //	digit     = "0" ... "9" | "a" ... "z" | "A" ... "Z" .
        //
        // Unless fracOk is set, the base argument must be 0 or a value between
        // 2 and MaxBase. If fracOk is set, the base argument must be one of
        // 0, 2, 8, 10, or 16. Providing an invalid base argument leads to a run-
        // time panic.
        //
        // For base 0, the number prefix determines the actual base: A prefix of
        // 0b or 0B selects base 2, 0o or 0O selects base 8, and
        // 0x or 0X selects base 16. If fracOk is false, a 0 prefix
        // (immediately followed by digits) selects base 8 as well. Otherwise,
        // the selected base is 10 and no prefix is accepted.
        //
        // If fracOk is set, a period followed by a fractional part is permitted.
        // The result value is computed as if there were no period present; and
        // the count value is used to determine the fractional part.
        //
        // For bases <= 36, lower and upper case letters are considered the same:
        // The letters 'a' to 'z' and 'A' to 'Z' represent digit values 10 to 35.
        // For bases > 36, the upper case letters 'A' to 'Z' represent the digit
        // values 36 to 61.
        //
        // A result digit count > 0 corresponds to the number of (non-prefix) digits
        // parsed. A digit count <= 0 indicates the presence of a period (if fracOk
        // is set, only), and -count is the number of fractional digits found.
        // In this case, the actual value of the scanned number is res * b**count.
    **/
    @:keep
    public dynamic function _scan(_r:stdgo.io.Io.ByteScanner, _base:GoInt, _fracOk:Bool):{ var _0 : T_nat; var _1 : GoInt; var _2 : GoInt; var _3 : Error; } return __self__.value._scan(_r, _base, _fracOk);
    /**
        // subMod2N returns z = (x - y) mod 2.
    **/
    @:keep
    public dynamic function _subMod2N(_x:T_nat, _y:T_nat, _n:GoUInt):T_nat return __self__.value._subMod2N(_x, _y, _n);
    /**
        // sqrt sets z = x
    **/
    @:keep
    public dynamic function _sqrt(_x:T_nat):T_nat return __self__.value._sqrt(_x);
    /**
        // setBytes interprets buf as the bytes of a big-endian unsigned
        // integer, sets z to that value, and returns z.
    **/
    @:keep
    public dynamic function _setBytes(_buf:Slice<GoByte>):T_nat return __self__.value._setBytes(_buf);
    /**
        // bytes writes the value of z into buf using big-endian encoding.
        // The value of z is encoded in the slice buf[i:]. If the value of z
        // cannot be represented in buf, bytes panics. The number i of unused
        // bytes at the beginning of buf is returned as result.
    **/
    @:keep
    public dynamic function _bytes(_buf:Slice<GoByte>):GoInt return __self__.value._bytes(_buf);
    /**
        // expNNMontgomery calculates x**y mod m using a fixed, 4-bit window.
        // Uses Montgomery representation.
    **/
    @:keep
    public dynamic function _expNNMontgomery(_x:T_nat, _y:T_nat, _m:T_nat):T_nat return __self__.value._expNNMontgomery(_x, _y, _m);
    /**
        // expNNWindowed calculates x**y mod m using a fixed, 4-bit window,
        // where m = 2**logM.
    **/
    @:keep
    public dynamic function _expNNWindowed(_x:T_nat, _y:T_nat, _logM:GoUInt):T_nat return __self__.value._expNNWindowed(_x, _y, _logM);
    /**
        // expNNMontgomeryEven calculates x**y mod m where m = m1  m2 for m1 = 2 and m2 odd.
        // It uses two recursive calls to expNN for x**y mod m1 and x**y mod m2
        // and then uses the Chinese Remainder Theorem to combine the results.
        // The recursive call using m1 will use expNNWindowed,
        // while the recursive call using m2 will use expNNMontgomery.
        // For more details, see . K. Ko, Montgomery Reduction with Even Modulus,
        // IEE Proceedings: Computers and Digital Techniques, 141(5) 314-316, September 1994.
        // http://www.people.vcu.edu/~jwang3/CMSC691/j34monex.pdf
    **/
    @:keep
    public dynamic function _expNNMontgomeryEven(_x:T_nat, _y:T_nat, _m:T_nat):T_nat return __self__.value._expNNMontgomeryEven(_x, _y, _m);
    /**
        // If m != 0 (i.e., len(m) != 0), expNN sets z to x**y mod m;
        // otherwise it sets z to x**y. The result is the value of z.
    **/
    @:keep
    public dynamic function _expNN(_x:T_nat, _y:T_nat, _m:T_nat, _slow:Bool):T_nat return __self__.value._expNN(_x, _y, _m, _slow);
    /**
        // random creates a random integer in [0..limit), using the space in z if
        // possible. n is the bit length of limit.
    **/
    @:keep
    public dynamic function _random(_rand:Ref<stdgo.math.rand.Rand.Rand>, _limit:T_nat, _n:GoInt):T_nat return __self__.value._random(_rand, _limit, _n);
    @:keep
    public dynamic function _xor(_x:T_nat, _y:T_nat):T_nat return __self__.value._xor(_x, _y);
    @:keep
    public dynamic function _or(_x:T_nat, _y:T_nat):T_nat return __self__.value._or(_x, _y);
    @:keep
    public dynamic function _andNot(_x:T_nat, _y:T_nat):T_nat return __self__.value._andNot(_x, _y);
    /**
        // trunc returns z = x mod 2.
    **/
    @:keep
    public dynamic function _trunc(_x:T_nat, _n:GoUInt):T_nat return __self__.value._trunc(_x, _n);
    @:keep
    public dynamic function _and(_x:T_nat, _y:T_nat):T_nat return __self__.value._and(_x, _y);
    /**
        // sticky returns 1 if there's a 1 bit within the
        // i least significant bits, otherwise it returns 0.
    **/
    @:keep
    public dynamic function _sticky(_i:GoUInt):GoUInt return __self__.value._sticky(_i);
    /**
        // bit returns the value of the i'th bit, with lsb == bit 0.
    **/
    @:keep
    public dynamic function _bit(_i:GoUInt):GoUInt return __self__.value._bit(_i);
    @:keep
    public dynamic function _setBit(_x:T_nat, _i:GoUInt, _b:GoUInt):T_nat return __self__.value._setBit(_x, _i, _b);
    /**
        // z = x >> s
    **/
    @:keep
    public dynamic function _shr(_x:T_nat, _s:GoUInt):T_nat return __self__.value._shr(_x, _s);
    /**
        // z = x << s
    **/
    @:keep
    public dynamic function _shl(_x:T_nat, _s:GoUInt):T_nat return __self__.value._shl(_x, _s);
    /**
        // isPow2 returns i, true when x == 2**i and 0, false otherwise.
    **/
    @:keep
    public dynamic function _isPow2():{ var _0 : GoUInt; var _1 : Bool; } return __self__.value._isPow2();
    /**
        // trailingZeroBits returns the number of consecutive least significant zero
        // bits of x.
    **/
    @:keep
    public dynamic function _trailingZeroBits():GoUInt return __self__.value._trailingZeroBits();
    /**
        // bitLen returns the length of x in bits.
        // Unlike most methods, it works even if x is not normalized.
    **/
    @:keep
    public dynamic function _bitLen():GoInt return __self__.value._bitLen();
    /**
        // mulRange computes the product of all the unsigned integers in the
        // range [a, b] inclusively. If a > b (empty range), the result is 1.
    **/
    @:keep
    public dynamic function _mulRange(_a:GoUInt64, _b:GoUInt64):T_nat return __self__.value._mulRange(_a, _b);
    /**
        // z = x*x
    **/
    @:keep
    public dynamic function _sqr(_x:T_nat):T_nat return __self__.value._sqr(_x);
    @:keep
    public dynamic function _mul(_x:T_nat, _y:T_nat):T_nat return __self__.value._mul(_x, _y);
    /**
        // montgomery computes z mod m = x*y*2**(-n*_W) mod m,
        // assuming k = -1/m mod 2**_W.
        // z is used for storing the result which is returned;
        // z must not alias x, y or m.
        // See Gueron, "Efficient Software Implementations of Modular Exponentiation".
        // https://eprint.iacr.org/2011/239.pdf
        // In the terminology of that paper, this is an "Almost Montgomery Multiplication":
        // x and y are required to satisfy 0 <= z < 2**(n*_W) and then the result
        // z is guaranteed to satisfy 0 <= z < 2**(n*_W), but it may not be < m.
    **/
    @:keep
    public dynamic function _montgomery(_x:T_nat, _y:T_nat, _m:T_nat, _k:Word, _n:GoInt):T_nat return __self__.value._montgomery(_x, _y, _m, _k, _n);
    @:keep
    public dynamic function _mulAddWW(_x:T_nat, _y:Word, _r:Word):T_nat return __self__.value._mulAddWW(_x, _y, _r);
    @:keep
    public dynamic function _cmp(_y:T_nat):GoInt return __self__.value._cmp(_y);
    @:keep
    public dynamic function _sub(_x:T_nat, _y:T_nat):T_nat return __self__.value._sub(_x, _y);
    @:keep
    public dynamic function _add(_x:T_nat, _y:T_nat):T_nat return __self__.value._add(_x, _y);
    @:keep
    public dynamic function _set(_x:T_nat):T_nat return __self__.value._set(_x);
    @:keep
    public dynamic function _setUint64(_x:GoUInt64):T_nat return __self__.value._setUint64(_x);
    @:keep
    public dynamic function _setWord(_x:Word):T_nat return __self__.value._setWord(_x);
    @:keep
    public dynamic function _make(_n:GoInt):T_nat return __self__.value._make(_n);
    @:keep
    public dynamic function _norm():T_nat return __self__.value._norm();
    @:keep
    public dynamic function _clear():Void __self__.value._clear();
    @:keep
    public dynamic function string():GoString return __self__.value.string();
    @:keep
    public dynamic function _modInverse(_g:T_nat, _n:T_nat):T_nat return __self__.value._modInverse(_g, _n);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : Pointer<T_nat>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.math.big.Big.T_nat_asInterface) class T_nat_static_extension {
    /**
        // probablyPrimeLucas reports whether n passes the "almost extra strong" Lucas probable prime test,
        // using Baillie-OEIS parameter selection. This corresponds to "AESLPSP" on Jacobsen's tables (link below).
        // The combination of this test and a Miller-Rabin/Fermat test with base 2 gives a Baillie-PSW test.
        //
        // References:
        //
        // Baillie and Wagstaff, "Lucas Pseudoprimes", Mathematics of Computation 35(152),
        // October 1980, pp. 1391-1417, especially page 1401.
        // https://www.ams.org/journals/mcom/1980-35-152/S0025-5718-1980-0583518-6/S0025-5718-1980-0583518-6.pdf
        //
        // Grantham, "Frobenius Pseudoprimes", Mathematics of Computation 70(234),
        // March 2000, pp. 873-891.
        // https://www.ams.org/journals/mcom/2001-70-234/S0025-5718-00-01197-2/S0025-5718-00-01197-2.pdf
        //
        // Baillie, "Extra strong Lucas pseudoprimes", OEIS A217719, https://oeis.org/A217719.
        //
        // Jacobsen, "Pseudoprime Statistics, Tables, and Data", http://ntheory.org/pseudoprimes.html.
        //
        // Nicely, "The Baillie-PSW Primality Test", https://web.archive.org/web/20191121062007/http://www.trnicely.net/misc/bpsw.html.
        // (Note that Nicely's definition of the "extra strong" test gives the wrong Jacobi condition,
        // as pointed out by Jacobsen.)
        //
        // Crandall and Pomerance, Prime Numbers: A Computational Perspective, 2nd ed.
        // Springer, 2005.
    **/
    @:keep
    static public function _probablyPrimeLucas( _n:T_nat):Bool {
        if ((_n.length == (0 : GoInt)) || (_n._cmp(_natOne) == (0 : GoInt))) {
            return false;
        };
        if (_n[(0 : GoInt)] & (1u32 : stdgo.math.big.Big.Word) == ((0u32 : stdgo.math.big.Big.Word))) {
            return _n._cmp(_natTwo) == ((0 : GoInt));
        };
        var _p:stdgo.math.big.Big.Word = ((3u32 : stdgo.math.big.Big.Word) : Word);
        var _d:stdgo.math.big.Big.T_nat = (new Slice<stdgo.math.big.Big.Word>(0, 0, (1u32 : stdgo.math.big.Big.Word)) : stdgo.math.big.Big.T_nat);
        var _t1:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat);
        var _intD = (Go.setRef(({ _abs : _d } : Int_)) : Ref<stdgo.math.big.Big.Int_>);
        var _intN = (Go.setRef(({ _abs : _n } : Int_)) : Ref<stdgo.math.big.Big.Int_>);
        Go.cfor(true, _p++, {
            if (_p > (10000u32 : stdgo.math.big.Big.Word)) {
                throw Go.toInterface(("math/big: internal error: cannot find (D/n) = -1 for " : GoString) + (_intN.string() : GoString));
            };
            _d[(0 : GoInt)] = (_p * _p) - (4u32 : stdgo.math.big.Big.Word);
            var _j:GoInt = jacobi(_intD, _intN);
            if (_j == ((-1 : GoInt))) {
                break;
            };
            if (_j == ((0 : GoInt))) {
                return (_n.length == (1 : GoInt)) && (_n[(0 : GoInt)] == (_p + (2u32 : stdgo.math.big.Big.Word)));
            };
            if (_p == ((40u32 : stdgo.math.big.Big.Word))) {
                _t1 = _t1._sqrt(_n);
                _t1 = _t1._sqr(_t1);
                if (_t1._cmp(_n) == ((0 : GoInt))) {
                    return false;
                };
            };
        });
        var _s:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._add(_n, _natOne);
        var _r:GoInt = (_s._trailingZeroBits() : GoInt);
        _s = _s._shr(_s, (_r : GoUInt));
        var _nm2:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._sub(_n, _natTwo);
        var _natP:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._setWord(_p);
        var _vk:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._setWord((2u32 : stdgo.math.big.Big.Word));
        var _vk1:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._setWord(_p);
        var _t2:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat);
        {
            var _i:GoInt = (_s._bitLen() : GoInt);
            Go.cfor(_i >= (0 : GoInt), _i--, {
                if (_s._bit((_i : GoUInt)) != ((0u32 : GoUInt))) {
                    _t1 = _t1._mul(_vk, _vk1);
                    _t1 = _t1._add(_t1, _n);
                    _t1 = _t1._sub(_t1, _natP);
                    {
                        var __tmp__ = _t2._div(_vk, _t1, _n);
                        _t2 = __tmp__._0;
                        _vk = __tmp__._1;
                    };
                    _t1 = _t1._sqr(_vk1);
                    _t1 = _t1._add(_t1, _nm2);
                    {
                        var __tmp__ = _t2._div(_vk1, _t1, _n);
                        _t2 = __tmp__._0;
                        _vk1 = __tmp__._1;
                    };
                } else {
                    _t1 = _t1._mul(_vk, _vk1);
                    _t1 = _t1._add(_t1, _n);
                    _t1 = _t1._sub(_t1, _natP);
                    {
                        var __tmp__ = _t2._div(_vk1, _t1, _n);
                        _t2 = __tmp__._0;
                        _vk1 = __tmp__._1;
                    };
                    _t1 = _t1._sqr(_vk);
                    _t1 = _t1._add(_t1, _nm2);
                    {
                        var __tmp__ = _t2._div(_vk, _t1, _n);
                        _t2 = __tmp__._0;
                        _vk = __tmp__._1;
                    };
                };
            });
        };
        if ((_vk._cmp(_natTwo) == (0 : GoInt)) || (_vk._cmp(_nm2) == (0 : GoInt))) {
            var _t1:stdgo.math.big.Big.T_nat = _t1._mul(_vk, _natP);
            var _t2:stdgo.math.big.Big.T_nat = _t2._shl(_vk1, (1u32 : GoUInt));
            if (_t1._cmp(_t2) < (0 : GoInt)) {
                {
                    final __tmp__0 = _t2;
                    final __tmp__1 = _t1;
                    _t1 = __tmp__0;
                    _t2 = __tmp__1;
                };
            };
            _t1 = _t1._sub(_t1, _t2);
            var _t3:stdgo.math.big.Big.T_nat = _vk1;
            _vk1 = null;
            _vk1;
            {
                var __tmp__ = _t2._div(_t3, _t1, _n);
                _t2 = __tmp__._0;
                _t3 = __tmp__._1;
            };
            if ((_t3.length) == ((0 : GoInt))) {
                return true;
            };
        };
        {
            var _t:GoInt = (0 : GoInt);
            Go.cfor(_t < (_r - (1 : GoInt)), _t++, {
                if ((_vk.length) == ((0 : GoInt))) {
                    return true;
                };
                if ((_vk.length == (1 : GoInt)) && (_vk[(0 : GoInt)] == (2u32 : stdgo.math.big.Big.Word))) {
                    return false;
                };
                _t1 = _t1._sqr(_vk);
                _t1 = _t1._sub(_t1, _natTwo);
                {
                    var __tmp__ = _t2._div(_vk, _t1, _n);
                    _t2 = __tmp__._0;
                    _vk = __tmp__._1;
                };
            });
        };
        return false;
    }
    /**
        // probablyPrimeMillerRabin reports whether n passes reps rounds of the
        // Miller-Rabin primality test, using pseudo-randomly chosen bases.
        // If force2 is true, one of the rounds is forced to use base 2.
        // See Handbook of Applied Cryptography, p. 139, Algorithm 4.24.
        // The number n is known to be non-zero.
    **/
    @:keep
    static public function _probablyPrimeMillerRabin( _n:T_nat, _reps:GoInt, _force2:Bool):Bool {
        stdgo.internal.Macro.controlFlow({
            var _nm1:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._sub(_n, _natOne);
            var _k:GoUInt = _nm1._trailingZeroBits();
            var _q:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._shr(_nm1, _k);
            var _nm3:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._sub(_nm1, _natTwo);
            var _rand = stdgo.math.rand.Rand.new_(stdgo.math.rand.Rand.newSource((_n[(0 : GoInt)] : GoInt64)));
            var __0:T_nat = new stdgo.math.big.Big.T_nat(0, 0), __1:T_nat = new stdgo.math.big.Big.T_nat(0, 0), __2:T_nat = new stdgo.math.big.Big.T_nat(0, 0), _quotient:T_nat = __2, _y:T_nat = __1, _x:T_nat = __0;
            var _nm3Len:GoInt = _nm3._bitLen();
            @:label("NextRandom") {
                var _i:GoInt = (0 : GoInt);
                Go.cfor(_i < _reps, _i++, {
                    if ((_i == (_reps - (1 : GoInt))) && _force2) {
                        _x = _x._set(_natTwo);
                    } else {
                        _x = _x._random(_rand, _nm3, _nm3Len);
                        _x = _x._add(_x, _natTwo);
                    };
                    _y = _y._expNN(_x, _q, _n, false);
                    if ((_y._cmp(_natOne) == (0 : GoInt)) || (_y._cmp(_nm1) == (0 : GoInt))) {
                        continue;
                    };
                    {
                        var _j:GoUInt = (1u32 : GoUInt);
                        Go.cfor(_j < _k, _j++, {
                            _y = _y._sqr(_y);
                            {
                                var __tmp__ = _quotient._div(_y, _y, _n);
                                _quotient = __tmp__._0;
                                _y = __tmp__._1;
                            };
                            if (_y._cmp(_nm1) == ((0 : GoInt))) {
                                @:jump("NextRandom") continue;
                            };
                            if (_y._cmp(_natOne) == ((0 : GoInt))) {
                                return false;
                            };
                        });
                    };
                    return false;
                });
            };
            return true;
        });
        throw "controlFlow did not return";
    }
    /**
        // divRecursiveStep is the actual implementation of recursive division.
        // It adds u/v to z and overwrites u with the remainder r.
        // z must be large enough to hold u/v.
        // It uses temps[depth] (allocating if needed) as a temporary live across
        // the recursive call. It also uses tmp, but not live across the recursion.
    **/
    @:keep
    static public function _divRecursiveStep( _z:T_nat, _u:T_nat, _v:T_nat, _depth:GoInt, _tmp:Ref<T_nat>, _temps:Slice<Ref<T_nat>>):Void {
        _u = _u._norm();
        _v = _v._norm();
        if ((_u.length) == ((0 : GoInt))) {
            _z._clear();
            return;
        };
        var _n:GoInt = (_v.length);
        if (_n < (100 : GoInt)) {
            _z._divBasic(_u, _v);
            return;
        };
        var _m:GoInt = (_u.length) - _n;
        if (_m < (0 : GoInt)) {
            return;
        };
        var b:GoInt = _n / (2 : GoInt);
        if (_temps[(_depth : GoInt)] == null || (_temps[(_depth : GoInt)] : Dynamic).__nil__) {
            _temps[(_depth : GoInt)] = _getNat(_n);
        } else {
            _temps[(_depth : GoInt)].__setData__(_temps[(_depth : GoInt)]._make(b + (1 : GoInt)));
        };
        var _j:GoInt = _m;
        while (_j > b) {
            var _s:GoInt = (b - (1 : GoInt));
            var _uu:stdgo.math.big.Big.T_nat = (_u.__slice__(_j - b) : stdgo.math.big.Big.T_nat);
            var _qhat:stdgo.math.big.Big.T_nat = (_temps[(_depth : GoInt)] : stdgo.math.big.Big.T_nat);
            _qhat._clear();
            _qhat._divRecursiveStep((_uu.__slice__(_s, b + _n) : stdgo.math.big.Big.T_nat), (_v.__slice__(_s) : stdgo.math.big.Big.T_nat), _depth + (1 : GoInt), _tmp, _temps);
            _qhat = _qhat._norm();
            var _qhatv:stdgo.math.big.Big.T_nat = _tmp._make((3 : GoInt) * _n);
            _qhatv._clear();
            _qhatv = _qhatv._mul(_qhat, (_v.__slice__(0, _s) : stdgo.math.big.Big.T_nat));
            {
                var _i:GoInt = (0 : GoInt);
                Go.cfor(_i < (2 : GoInt), _i++, {
                    var _e:GoInt = _qhatv._cmp(_uu._norm());
                    if (_e <= (0 : GoInt)) {
                        break;
                    };
                    _subVW(_qhat, _qhat, (1u32 : stdgo.math.big.Big.Word));
                    var _c:stdgo.math.big.Big.Word = _subVV((_qhatv.__slice__(0, _s) : stdgo.math.big.Big.T_nat), (_qhatv.__slice__(0, _s) : stdgo.math.big.Big.T_nat), (_v.__slice__(0, _s) : stdgo.math.big.Big.T_nat));
                    if ((_qhatv.length) > _s) {
                        _subVW((_qhatv.__slice__(_s) : stdgo.math.big.Big.T_nat), (_qhatv.__slice__(_s) : stdgo.math.big.Big.T_nat), _c);
                    };
                    _addAt((_uu.__slice__(_s) : stdgo.math.big.Big.T_nat), (_v.__slice__(_s) : stdgo.math.big.Big.T_nat), (0 : GoInt));
                });
            };
            if (_qhatv._cmp(_uu._norm()) > (0 : GoInt)) {
                throw Go.toInterface(("impossible" : GoString));
            };
            var _c:stdgo.math.big.Big.Word = _subVV((_uu.__slice__(0, (_qhatv.length)) : stdgo.math.big.Big.T_nat), (_uu.__slice__(0, (_qhatv.length)) : stdgo.math.big.Big.T_nat), _qhatv);
            if (_c > (0u32 : stdgo.math.big.Big.Word)) {
                _subVW((_uu.__slice__((_qhatv.length)) : stdgo.math.big.Big.T_nat), (_uu.__slice__((_qhatv.length)) : stdgo.math.big.Big.T_nat), _c);
            };
            _addAt(_z, _qhat, _j - b);
            _j = _j - (b);
        };
        var _s:GoInt = b - (1 : GoInt);
        var _qhat:stdgo.math.big.Big.T_nat = (_temps[(_depth : GoInt)] : stdgo.math.big.Big.T_nat);
        _qhat._clear();
        _qhat._divRecursiveStep((_u.__slice__(_s) : stdgo.math.big.Big.T_nat)._norm(), (_v.__slice__(_s) : stdgo.math.big.Big.T_nat), _depth + (1 : GoInt), _tmp, _temps);
        _qhat = _qhat._norm();
        var _qhatv:stdgo.math.big.Big.T_nat = _tmp._make((3 : GoInt) * _n);
        _qhatv._clear();
        _qhatv = _qhatv._mul(_qhat, (_v.__slice__(0, _s) : stdgo.math.big.Big.T_nat));
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < (2 : GoInt), _i++, {
                {
                    var _e:GoInt = _qhatv._cmp(_u._norm());
                    if (_e > (0 : GoInt)) {
                        _subVW(_qhat, _qhat, (1u32 : stdgo.math.big.Big.Word));
                        var _c:stdgo.math.big.Big.Word = _subVV((_qhatv.__slice__(0, _s) : stdgo.math.big.Big.T_nat), (_qhatv.__slice__(0, _s) : stdgo.math.big.Big.T_nat), (_v.__slice__(0, _s) : stdgo.math.big.Big.T_nat));
                        if ((_qhatv.length) > _s) {
                            _subVW((_qhatv.__slice__(_s) : stdgo.math.big.Big.T_nat), (_qhatv.__slice__(_s) : stdgo.math.big.Big.T_nat), _c);
                        };
                        _addAt((_u.__slice__(_s) : stdgo.math.big.Big.T_nat), (_v.__slice__(_s) : stdgo.math.big.Big.T_nat), (0 : GoInt));
                    };
                };
            });
        };
        if (_qhatv._cmp(_u._norm()) > (0 : GoInt)) {
            throw Go.toInterface(("impossible" : GoString));
        };
        var _c:stdgo.math.big.Big.Word = _subVV((_u.__slice__((0 : GoInt), (_qhatv.length)) : stdgo.math.big.Big.T_nat), (_u.__slice__((0 : GoInt), (_qhatv.length)) : stdgo.math.big.Big.T_nat), _qhatv);
        if (_c > (0u32 : stdgo.math.big.Big.Word)) {
            _c = _subVW((_u.__slice__((_qhatv.length)) : stdgo.math.big.Big.T_nat), (_u.__slice__((_qhatv.length)) : stdgo.math.big.Big.T_nat), _c);
        };
        if (_c > (0u32 : stdgo.math.big.Big.Word)) {
            throw Go.toInterface(("impossible" : GoString));
        };
        _addAt(_z, _qhat._norm(), (0 : GoInt));
    }
    /**
        // divRecursive implements recursive division as described above.
        // It overwrites z with u/v and overwrites u with the remainder r.
        // z must be large enough to hold u/v.
        // This function is just for allocating and freeing temporaries
        // around divRecursiveStep, the real implementation.
    **/
    @:keep
    static public function _divRecursive( _z:T_nat, _u:T_nat, _v:T_nat):Void {
        var _recDepth:GoInt = (2 : GoInt) * stdgo.math.bits.Bits.len((_v.length : GoUInt));
        var _tmp = _getNat((3 : GoInt) * (_v.length));
        var _temps = new Slice<Ref<stdgo.math.big.Big.T_nat>>((_recDepth : GoInt).toBasic(), 0, ...[for (i in 0 ... (_recDepth : GoInt).toBasic()) (null : Ref<stdgo.math.big.Big.T_nat>)]);
        _z._clear();
        _z._divRecursiveStep(_u, _v, (0 : GoInt), _tmp, _temps);
        for (__0 => _n in _temps) {
            if (_n != null && ((_n : Dynamic).__nil__ == null || !(_n : Dynamic).__nil__)) {
                _putNat(_n);
            };
        };
        _putNat(_tmp);
    }
    /**
        // divBasic implements long division as described above.
        // It overwrites q with u/v and overwrites u with the remainder r.
        // q must be large enough to hold u/v.
    **/
    @:keep
    static public function _divBasic( _q:T_nat, _u:T_nat, _v:T_nat):Void {
        var _n:GoInt = (_v.length);
        var _m:GoInt = (_u.length) - _n;
        var _qhatvp = _getNat(_n + (1 : GoInt));
        var _qhatv:stdgo.math.big.Big.T_nat = (_qhatvp : stdgo.math.big.Big.T_nat);
        var _vn1:stdgo.math.big.Big.Word = _v[(_n - (1 : GoInt) : GoInt)];
        var _rec:stdgo.math.big.Big.Word = _reciprocalWord(_vn1);
        {
            var _j:GoInt = _m;
            Go.cfor(_j >= (0 : GoInt), _j--, {
                var _qhat:stdgo.math.big.Big.Word = ((-1u32 : stdgo.math.big.Big.Word) : Word);
                var _ujn:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
                if ((_j + _n) < (_u.length)) {
                    _ujn = _u[(_j + _n : GoInt)];
                };
                if (_ujn != (_vn1)) {
                    var _rhat:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
                    {
                        var __tmp__ = _divWW(_ujn, _u[((_j + _n) - (1 : GoInt) : GoInt)], _vn1, _rec);
                        _qhat = __tmp__._0;
                        _rhat = __tmp__._1;
                    };
                    var _vn2:stdgo.math.big.Big.Word = _v[(_n - (2 : GoInt) : GoInt)];
                    var __tmp__ = _mulWW(_qhat, _vn2), _x1:stdgo.math.big.Big.Word = __tmp__._0, _x2:stdgo.math.big.Big.Word = __tmp__._1;
                    var _ujn2:stdgo.math.big.Big.Word = _u[((_j + _n) - (2 : GoInt) : GoInt)];
                    while (_greaterThan(_x1, _x2, _rhat, _ujn2)) {
                        _qhat--;
                        var _prevRhat:stdgo.math.big.Big.Word = _rhat;
                        _rhat = _rhat + (_vn1);
                        if (_rhat < _prevRhat) {
                            break;
                        };
                        {
                            var __tmp__ = _mulWW(_qhat, _vn2);
                            _x1 = __tmp__._0;
                            _x2 = __tmp__._1;
                        };
                    };
                };
                _qhatv[(_n : GoInt)] = _mulAddVWW((_qhatv.__slice__((0 : GoInt), _n) : stdgo.math.big.Big.T_nat), _v, _qhat, (0u32 : stdgo.math.big.Big.Word));
                var _qhl:GoInt = (_qhatv.length);
                if (((_j + _qhl) > _u.length) && (_qhatv[(_n : GoInt)] == (0u32 : stdgo.math.big.Big.Word))) {
                    _qhl--;
                };
                var _c:stdgo.math.big.Big.Word = _subVV((_u.__slice__(_j, _j + _qhl) : stdgo.math.big.Big.T_nat), (_u.__slice__(_j) : stdgo.math.big.Big.T_nat), _qhatv);
                if (_c != ((0u32 : stdgo.math.big.Big.Word))) {
                    var _c:stdgo.math.big.Big.Word = _addVV((_u.__slice__(_j, _j + _n) : stdgo.math.big.Big.T_nat), (_u.__slice__(_j) : stdgo.math.big.Big.T_nat), _v);
                    if (_n < _qhl) {
                        _u[(_j + _n : GoInt)] = _u[(_j + _n : GoInt)] + (_c);
                    };
                    _qhat--;
                };
                if (((_j == _m) && (_m == (_q.length))) && (_qhat == (0u32 : stdgo.math.big.Big.Word))) {
                    continue;
                };
                _q[(_j : GoInt)] = _qhat;
            });
        };
        _putNat(_qhatvp);
    }
    /**
        // div returns q, r such that q = uIn/vIn and r = uIn%vIn = uIn - qvIn.
        // It uses z and u as the storage for q and r.
        // The caller must ensure that len(vIn)  2 (use divW otherwise)
        // and that len(uIn)  len(vIn) (the answer is 0, uIn otherwise).
    **/
    @:keep
    static public function _divLarge( _z:T_nat, _u:T_nat, _uIn:T_nat, _vIn:T_nat):{ var _0 : T_nat; var _1 : T_nat; } {
        var _q:T_nat = new stdgo.math.big.Big.T_nat(0, 0), _r:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
        var _n:GoInt = (_vIn.length);
        var _m:GoInt = (_uIn.length) - _n;
        var _shift:GoUInt = _nlz(_vIn[(_n - (1 : GoInt) : GoInt)]);
        var _vp = _getNat(_n);
        var _v:stdgo.math.big.Big.T_nat = (_vp : stdgo.math.big.Big.T_nat);
        _shlVU(_v, _vIn, _shift);
        _u = _u._make((_uIn.length) + (1 : GoInt));
        _u[(_uIn.length : GoInt)] = _shlVU((_u.__slice__((0 : GoInt), (_uIn.length)) : stdgo.math.big.Big.T_nat), _uIn, _shift);
        if (_alias(_z, _u)) {
            _z = null;
        };
        _q = _z._make(_m + (1 : GoInt));
        if (_n < (100 : GoInt)) {
            _q._divBasic(_u, _v);
        } else {
            _q._divRecursive(_u, _v);
        };
        _putNat(_vp);
        _q = _q._norm();
        _shrVU(_u, _u, _shift);
        _r = _u._norm();
        return { _0 : _q, _1 : _r };
    }
    /**
        // modW returns x % d.
    **/
    @:keep
    static public function _modW( _x:T_nat, _d:Word):Word {
        var _r:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        var _q:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
        _q = _q._make((_x.length));
        return _divWVW(_q, (0u32 : stdgo.math.big.Big.Word), _x, _d);
    }
    /**
        // divW returns q, r such that q = x/y and r = x%y = x - qy.
        // It uses z as the storage for q.
        // Note that y is a single digit (Word), not a big number.
    **/
    @:keep
    static public function _divW( _z:T_nat, _x:T_nat, _y:Word):{ var _0 : T_nat; var _1 : Word; } {
        var _q:T_nat = new stdgo.math.big.Big.T_nat(0, 0), _r:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        var _m:GoInt = (_x.length);
        if (_y == ((0u32 : stdgo.math.big.Big.Word))) {
            throw Go.toInterface(("division by zero" : GoString));
        } else if (_y == ((1u32 : stdgo.math.big.Big.Word))) {
            _q = _z._set(_x);
            return { _0 : _q, _1 : _r };
        } else if (_m == ((0 : GoInt))) {
            _q = (_z.__slice__(0, (0 : GoInt)) : stdgo.math.big.Big.T_nat);
            return { _0 : _q, _1 : _r };
        };
        _z = _z._make(_m);
        _r = _divWVW(_z, (0u32 : stdgo.math.big.Big.Word), _x, _y);
        _q = _z._norm();
        return { _0 : _q, _1 : _r };
    }
    /**
        // div returns q, r such that q = u/v and r = u%v = u - qv.
        // It uses z and z2 as the storage for q and r.
    **/
    @:keep
    static public function _div( _z:T_nat, _z2:T_nat, _u:T_nat, _v:T_nat):{ var _0 : T_nat; var _1 : T_nat; } {
        var _q:T_nat = new stdgo.math.big.Big.T_nat(0, 0), _r:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
        if ((_v.length) == ((0 : GoInt))) {
            throw Go.toInterface(("division by zero" : GoString));
        };
        if (_u._cmp(_v) < (0 : GoInt)) {
            _q = (_z.__slice__(0, (0 : GoInt)) : stdgo.math.big.Big.T_nat);
            _r = _z2._set(_u);
            return { _0 : _q, _1 : _r };
        };
        if ((_v.length) == ((1 : GoInt))) {
            var _r2:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
            {
                var __tmp__ = _z._divW(_u, _v[(0 : GoInt)]);
                _q = __tmp__._0;
                _r2 = __tmp__._1;
            };
            _r = _z2._setWord(_r2);
            return { _0 : _q, _1 : _r };
        };
        {
            var __tmp__ = _z._divLarge(_z2, _u, _v);
            _q = __tmp__._0;
            _r = __tmp__._1;
        };
        return { _0 : _q, _1 : _r };
    }
    /**
        // rem returns r such that r = u%v.
        // It uses z as the storage for r.
    **/
    @:keep
    static public function _rem( _z:T_nat, _u:T_nat, _v:T_nat):T_nat {
        var _r:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
        if (_alias(_z, _u)) {
            _z = null;
        };
        var _qp = _getNat((0 : GoInt));
        var __tmp__ = _qp._div(_z, _u, _v), _q:stdgo.math.big.Big.T_nat = __tmp__._0, _r:stdgo.math.big.Big.T_nat = __tmp__._1;
        _qp.__setData__(_q);
        _putNat(_qp);
        return _r;
    }
    /**
        // expWW computes x**y
    **/
    @:keep
    static public function _expWW( _z:T_nat, _x:Word, _y:Word):T_nat {
        return _z._expNN((new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._setWord(_x), (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._setWord(_y), null, false);
    }
    /**
        // Convert words of q to base b digits in s. If q is large, it is recursively "split in half"
        // by nat/nat division using tabulated divisors. Otherwise, it is converted iteratively using
        // repeated nat/Word division.
        //
        // The iterative method processes n Words by n divW() calls, each of which visits every Word in the
        // incrementally shortened q for a total of n + (n-1) + (n-2) ... + 2 + 1, or n(n+1)/2 divW()'s.
        // Recursive conversion divides q by its approximate square root, yielding two parts, each half
        // the size of q. Using the iterative method on both halves means 2 * (n/2)(n/2 + 1)/2 divW()'s
        // plus the expensive long div(). Asymptotically, the ratio is favorable at 1/2 the divW()'s, and
        // is made better by splitting the subblocks recursively. Best is to split blocks until one more
        // split would take longer (because of the nat/nat div()) than the twice as many divW()'s of the
        // iterative approach. This threshold is represented by leafSize. Benchmarking of leafSize in the
        // range 2..64 shows that values of 8 and 16 work well, with a 4x speedup at medium lengths and
        // ~30x for 20000 digits. Use nat_test.go's BenchmarkLeafSize tests to optimize leafSize for
        // specific hardware.
    **/
    @:keep
    static public function _convertWords( _q:T_nat, _s:Slice<GoByte>, _b:Word, _ndigits:GoInt, _bb:Word, _table:Slice<T_divisor>):Void {
        if (_table != null) {
            var _r:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
            var _index:GoInt = (_table.length) - (1 : GoInt);
            while ((_q.length) > _leafSize) {
                var _maxLength:GoInt = _q._bitLen();
                var _minLength:GoInt = _maxLength >> (1i64 : GoUInt64);
                while ((_index > (0 : GoInt)) && (_table[(_index - (1 : GoInt) : GoInt)]._nbits > _minLength)) {
                    _index--;
                };
                if ((_table[(_index : GoInt)]._nbits >= _maxLength) && (_table[(_index : GoInt)]._bbb._cmp(_q) >= (0 : GoInt))) {
                    _index--;
                    if (_index < (0 : GoInt)) {
                        throw Go.toInterface(("internal inconsistency" : GoString));
                    };
                };
                {
                    var __tmp__ = _q._div(_r, _q, _table[(_index : GoInt)]._bbb);
                    _q = __tmp__._0;
                    _r = __tmp__._1;
                };
                var _h:GoInt = (_s.length) - _table[(_index : GoInt)]._ndigits;
                _r._convertWords((_s.__slice__(_h) : Slice<GoUInt8>), _b, _ndigits, _bb, (_table.__slice__((0 : GoInt), _index) : Slice<stdgo.math.big.Big.T_divisor>));
                _s = (_s.__slice__(0, _h) : Slice<GoUInt8>);
            };
        };
        var _i:GoInt = (_s.length);
        var _r:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        if (_b == ((10u32 : stdgo.math.big.Big.Word))) {
            while ((_q.length) > (0 : GoInt)) {
                {
                    var __tmp__ = _q._divW(_q, _bb);
                    _q = __tmp__._0;
                    _r = __tmp__._1;
                };
                {
                    var _j:GoInt = (0 : GoInt);
                    Go.cfor((_j < _ndigits) && (_i > (0 : GoInt)), _j++, {
                        _i--;
                        var _t:stdgo.math.big.Big.Word = _r / (10u32 : stdgo.math.big.Big.Word);
                        _s[(_i : GoInt)] = (48 : GoUInt8) + (_r - (_t * (10u32 : stdgo.math.big.Big.Word)) : GoByte);
                        _r = _t;
                    });
                };
            };
        } else {
            while ((_q.length) > (0 : GoInt)) {
                {
                    var __tmp__ = _q._divW(_q, _bb);
                    _q = __tmp__._0;
                    _r = __tmp__._1;
                };
                {
                    var _j:GoInt = (0 : GoInt);
                    Go.cfor((_j < _ndigits) && (_i > (0 : GoInt)), _j++, {
                        _i--;
                        _s[(_i : GoInt)] = ("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString)[(_r % _b : GoInt)];
                        _r = _r / (_b);
                    });
                };
            };
        };
        while (_i > (0 : GoInt)) {
            _i--;
            _s[(_i : GoInt)] = (48 : GoUInt8);
        };
    }
    /**
        // itoa is like utoa but it prepends a '-' if neg && x != 0.
    **/
    @:keep
    static public function _itoa( _x:T_nat, _neg:Bool, _base:GoInt):Slice<GoByte> {
        if ((_base < (2 : GoInt)) || (_base > (62 : GoInt))) {
            throw Go.toInterface(("invalid base" : GoString));
        };
        if ((_x.length) == ((0 : GoInt))) {
            return (("0" : GoString) : Slice<GoByte>);
        };
        var _i:GoInt = ((_x._bitLen() : GoFloat64) / stdgo.math.Math.log2((_base : GoFloat64)) : GoInt) + (1 : GoInt);
        if (_neg) {
            _i++;
        };
        var _s = new Slice<GoUInt8>((_i : GoInt).toBasic(), 0, ...[for (i in 0 ... (_i : GoInt).toBasic()) (0 : GoUInt8)]);
        {
            var _b:stdgo.math.big.Big.Word = (_base : Word);
            if (_b == (_b & -_b)) {
                var _shift:GoUInt = (stdgo.math.bits.Bits.trailingZeros((_b : GoUInt)) : GoUInt);
                var _mask:stdgo.math.big.Big.Word = (((1u32 : stdgo.math.big.Big.Word) << _shift) - (1u32 : stdgo.math.big.Big.Word) : Word);
                var _w:stdgo.math.big.Big.Word = _x[(0 : GoInt)];
                var _nbits:GoUInt = (32u32 : GoUInt);
                {
                    var _k:GoInt = (1 : GoInt);
                    Go.cfor(_k < (_x.length), _k++, {
                        while (_nbits >= _shift) {
                            _i--;
                            _s[(_i : GoInt)] = ("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString)[(_w & _mask : GoInt)];
                            _w = _w >> (_shift);
                            _nbits = _nbits - (_shift);
                        };
                        if (_nbits == ((0u32 : GoUInt))) {
                            _w = _x[(_k : GoInt)];
                            _nbits = (32u32 : GoUInt);
                        } else {
                            _w = _w | (_x[(_k : GoInt)] << _nbits);
                            _i--;
                            _s[(_i : GoInt)] = ("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString)[(_w & _mask : GoInt)];
                            _w = _x[(_k : GoInt)] >> (_shift - _nbits);
                            _nbits = (32u32 : GoUInt) - (_shift - _nbits);
                        };
                    });
                };
                while (_w != ((0u32 : stdgo.math.big.Big.Word))) {
                    _i--;
                    _s[(_i : GoInt)] = ("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString)[(_w & _mask : GoInt)];
                    _w = _w >> (_shift);
                };
            } else {
                var __tmp__ = _maxPow(_b), _bb:stdgo.math.big.Big.Word = __tmp__._0, _ndigits:GoInt = __tmp__._1;
                var _table = _divisors((_x.length), _b, _ndigits, _bb);
                var _q:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._set(_x);
                _q._convertWords(_s, _b, _ndigits, _bb, _table);
                _i = (0 : GoInt);
                while (_s[(_i : GoInt)] == ((48 : GoUInt8))) {
                    _i++;
                };
            };
        };
        if (_neg) {
            _i--;
            _s[(_i : GoInt)] = (45 : GoUInt8);
        };
        return (_s.__slice__(_i) : Slice<GoUInt8>);
    }
    /**
        // utoa converts x to an ASCII representation in the given base;
        // base must be between 2 and MaxBase, inclusive.
    **/
    @:keep
    static public function _utoa( _x:T_nat, _base:GoInt):Slice<GoByte> {
        return _x._itoa(false, _base);
    }
    /**
        // scan scans the number corresponding to the longest possible prefix
        // from r representing an unsigned number in a given conversion base.
        // scan returns the corresponding natural number res, the actual base b,
        // a digit count, and a read or syntax error err, if any.
        //
        // For base 0, an underscore character _ may appear between a base
        // prefix and an adjacent digit, and between successive digits; such
        // underscores do not change the value of the number, or the returned
        // digit count. Incorrect placement of underscores is reported as an
        // error if there are no other errors. If base != 0, underscores are
        // not recognized and thus terminate scanning like any other character
        // that is not a valid radix point or digit.
        //
        //	number    = mantissa | prefix pmantissa .
        //	prefix    = "0" [ "b" | "B" | "o" | "O" | "x" | "X" ] .
        //	mantissa  = digits "." [ digits ] | digits | "." digits .
        //	pmantissa = [ "_" ] digits "." [ digits ] | [ "_" ] digits | "." digits .
        //	digits    = digit { [ "_" ] digit } .
        //	digit     = "0" ... "9" | "a" ... "z" | "A" ... "Z" .
        //
        // Unless fracOk is set, the base argument must be 0 or a value between
        // 2 and MaxBase. If fracOk is set, the base argument must be one of
        // 0, 2, 8, 10, or 16. Providing an invalid base argument leads to a run-
        // time panic.
        //
        // For base 0, the number prefix determines the actual base: A prefix of
        // 0b or 0B selects base 2, 0o or 0O selects base 8, and
        // 0x or 0X selects base 16. If fracOk is false, a 0 prefix
        // (immediately followed by digits) selects base 8 as well. Otherwise,
        // the selected base is 10 and no prefix is accepted.
        //
        // If fracOk is set, a period followed by a fractional part is permitted.
        // The result value is computed as if there were no period present; and
        // the count value is used to determine the fractional part.
        //
        // For bases <= 36, lower and upper case letters are considered the same:
        // The letters 'a' to 'z' and 'A' to 'Z' represent digit values 10 to 35.
        // For bases > 36, the upper case letters 'A' to 'Z' represent the digit
        // values 36 to 61.
        //
        // A result digit count > 0 corresponds to the number of (non-prefix) digits
        // parsed. A digit count <= 0 indicates the presence of a period (if fracOk
        // is set, only), and -count is the number of fractional digits found.
        // In this case, the actual value of the scanned number is res * b**count.
    **/
    @:keep
    static public function _scan( _z:T_nat, _r:stdgo.io.Io.ByteScanner, _base:GoInt, _fracOk:Bool):{ var _0 : T_nat; var _1 : GoInt; var _2 : GoInt; var _3 : Error; } {
        var _res:T_nat = new stdgo.math.big.Big.T_nat(0, 0), _b:GoInt = (0 : GoInt), _count:GoInt = (0 : GoInt), _err:Error = (null : Error);
        var _baseOk:Bool = ((_base == (0 : GoInt)) || ((!_fracOk && ((2 : GoInt) <= _base)) && (_base <= (62 : GoInt)))) || (_fracOk && ((((_base == (2 : GoInt)) || (_base == (8 : GoInt))) || (_base == (10 : GoInt))) || (_base == (16 : GoInt))));
        if (!_baseOk) {
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(("invalid number base %d" : GoString), Go.toInterface(_base)));
        };
        var _prev:GoInt32 = (46 : GoInt32);
        var _invalSep:Bool = false;
        var __tmp__ = _r.readByte(), _ch:GoUInt8 = __tmp__._0, _err:Error = __tmp__._1;
        var __0:GoInt = _base, __1:GoInt = (0 : GoInt), _prefix:GoInt = __1, _b:GoInt = __0;
        if (_base == ((0 : GoInt))) {
            _b = (10 : GoInt);
            if ((_err == null) && (_ch == (48 : GoUInt8))) {
                _prev = (48 : GoInt32);
                _count = (1 : GoInt);
                {
                    var __tmp__ = _r.readByte();
                    _ch = __tmp__._0;
                    _err = __tmp__._1;
                };
                if (_err == null) {
                    {
                        final __value__ = _ch;
                        if (__value__ == ((98 : GoUInt8)) || __value__ == ((66 : GoUInt8))) {
                            {
                                final __tmp__0 = (2 : GoInt);
                                final __tmp__1 = (98 : GoInt);
                                _b = __tmp__0;
                                _prefix = __tmp__1;
                            };
                        } else if (__value__ == ((111 : GoUInt8)) || __value__ == ((79 : GoUInt8))) {
                            {
                                final __tmp__0 = (8 : GoInt);
                                final __tmp__1 = (111 : GoInt);
                                _b = __tmp__0;
                                _prefix = __tmp__1;
                            };
                        } else if (__value__ == ((120 : GoUInt8)) || __value__ == ((88 : GoUInt8))) {
                            {
                                final __tmp__0 = (16 : GoInt);
                                final __tmp__1 = (120 : GoInt);
                                _b = __tmp__0;
                                _prefix = __tmp__1;
                            };
                        } else {
                            if (!_fracOk) {
                                {
                                    final __tmp__0 = (8 : GoInt);
                                    final __tmp__1 = (48 : GoInt);
                                    _b = __tmp__0;
                                    _prefix = __tmp__1;
                                };
                            };
                        };
                    };
                    if (_prefix != ((0 : GoInt))) {
                        _count = (0 : GoInt);
                        if (_prefix != ((48 : GoInt))) {
                            {
                                var __tmp__ = _r.readByte();
                                _ch = __tmp__._0;
                                _err = __tmp__._1;
                            };
                        };
                    };
                };
            };
        };
        _z = (_z.__slice__(0, (0 : GoInt)) : stdgo.math.big.Big.T_nat);
        var _b1:stdgo.math.big.Big.Word = (_b : Word);
        var __tmp__ = _maxPow(_b1), _bn:stdgo.math.big.Big.Word = __tmp__._0, _n:GoInt = __tmp__._1;
        var _di:stdgo.math.big.Big.Word = ((0u32 : stdgo.math.big.Big.Word) : Word);
        var _i:GoInt = (0 : GoInt);
        var _dp:GoInt = (-1 : GoInt);
        while (_err == null) {
            if ((_ch == (46 : GoUInt8)) && _fracOk) {
                _fracOk = false;
                if (_prev == ((95 : GoInt32))) {
                    _invalSep = true;
                };
                _prev = (46 : GoInt32);
                _dp = _count;
            } else if ((_ch == (95 : GoUInt8)) && (_base == (0 : GoInt))) {
                if (_prev != ((48 : GoInt32))) {
                    _invalSep = true;
                };
                _prev = (95 : GoInt32);
            } else {
                var _d1:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
                if (((48 : GoUInt8) <= _ch) && (_ch <= (57 : GoUInt8))) {
                    _d1 = (_ch - (48 : GoUInt8) : Word);
                } else if (((97 : GoUInt8) <= _ch) && (_ch <= (122 : GoUInt8))) {
                    _d1 = ((_ch - (97 : GoUInt8)) + (10 : GoUInt8) : Word);
                } else if (((65 : GoUInt8) <= _ch) && (_ch <= (90 : GoUInt8))) {
                    if (_b <= (36 : GoInt)) {
                        _d1 = ((_ch - (65 : GoUInt8)) + (10 : GoUInt8) : Word);
                    } else {
                        _d1 = ((_ch - (65 : GoUInt8)) + (36 : GoUInt8) : Word);
                    };
                } else {
                    _d1 = (63u32 : stdgo.math.big.Big.Word);
                };
                if (_d1 >= _b1) {
                    _r.unreadByte();
                    break;
                };
                _prev = (48 : GoInt32);
                _count++;
                _di = (_di * _b1) + _d1;
                _i++;
                if (_i == (_n)) {
                    _z = _z._mulAddWW(_z, _bn, _di);
                    _di = (0u32 : stdgo.math.big.Big.Word);
                    _i = (0 : GoInt);
                };
            };
            {
                var __tmp__ = _r.readByte();
                _ch = __tmp__._0;
                _err = __tmp__._1;
            };
        };
        if (Go.toInterface(_err) == (Go.toInterface(stdgo.io.Io.eof))) {
            _err = (null : Error);
        };
        if ((_err == null) && (_invalSep || (_prev == (95 : GoInt32)))) {
            _err = _errInvalSep;
        };
        if (_count == ((0 : GoInt))) {
            if (_prefix == ((48 : GoInt))) {
                return { _0 : (_z.__slice__(0, (0 : GoInt)) : stdgo.math.big.Big.T_nat), _1 : (10 : GoInt), _2 : (1 : GoInt), _3 : _err };
            };
            _err = _errNoDigits;
        };
        if (_i > (0 : GoInt)) {
            _z = _z._mulAddWW(_z, _pow(_b1, _i), _di);
        };
        _res = _z._norm();
        if (_dp >= (0 : GoInt)) {
            _count = _dp - _count;
        };
        return { _0 : _res, _1 : _b, _2 : _count, _3 : _err };
    }
    /**
        // subMod2N returns z = (x - y) mod 2.
    **/
    @:keep
    static public function _subMod2N( _z:T_nat, _x:T_nat, _y:T_nat, _n:GoUInt):T_nat {
        if ((_x._bitLen() : GoUInt) > _n) {
            if (_alias(_z, _x)) {
                _x = _x._trunc(_x, _n);
            } else {
                _x = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._trunc(_x, _n);
            };
        };
        if ((_y._bitLen() : GoUInt) > _n) {
            if (_alias(_z, _y)) {
                _y = _y._trunc(_y, _n);
            } else {
                _y = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._trunc(_y, _n);
            };
        };
        if (_x._cmp(_y) >= (0 : GoInt)) {
            return _z._sub(_x, _y);
        };
        _z = _z._sub(_y, _x);
        while (((_z.length : GoUInt) * (32u32 : GoUInt)) < _n) {
            _z = _z.__appendref__((0u32 : stdgo.math.big.Big.Word));
        };
        for (_i => _ in _z) {
            _z[(_i : GoInt)] = (-1 ^ _z[(_i : GoInt)]);
        };
        _z = _z._trunc(_z, _n);
        return _z._add(_z, _natOne);
    }
    /**
        // sqrt sets z = x
    **/
    @:keep
    static public function _sqrt( _z:T_nat, _x:T_nat):T_nat {
        if (_x._cmp(_natOne) <= (0 : GoInt)) {
            return _z._set(_x);
        };
        if (_alias(_z, _x)) {
            _z = null;
        };
        var __0:T_nat = new stdgo.math.big.Big.T_nat(0, 0), __1:T_nat = new stdgo.math.big.Big.T_nat(0, 0), _z2:T_nat = __1, _z1:T_nat = __0;
        _z1 = _z;
        _z1 = _z1._setUint64((1i64 : GoUInt64));
        _z1 = _z1._shl(_z1, (_x._bitLen() + (1 : GoInt) : GoUInt) / (2u32 : GoUInt));
        {
            var _n:GoInt = (0 : GoInt);
            Go.cfor(true, _n++, {
                {
                    var __tmp__ = _z2._div(null, _x, _z1);
                    _z2 = __tmp__._0;
                };
                _z2 = _z2._add(_z2, _z1);
                _z2 = _z2._shr(_z2, (1u32 : GoUInt));
                if (_z2._cmp(_z1) >= (0 : GoInt)) {
                    if (_n & (1 : GoInt) == ((0 : GoInt))) {
                        return _z1;
                    };
                    return _z._set(_z1);
                };
                {
                    final __tmp__0 = _z2;
                    final __tmp__1 = _z1;
                    _z1 = __tmp__0;
                    _z2 = __tmp__1;
                };
            });
        };
    }
    /**
        // setBytes interprets buf as the bytes of a big-endian unsigned
        // integer, sets z to that value, and returns z.
    **/
    @:keep
    static public function _setBytes( _z:T_nat, _buf:Slice<GoByte>):T_nat {
        _z = _z._make(((_buf.length + (4 : GoInt)) - (1 : GoInt)) / (4 : GoInt));
        var _i:GoInt = (_buf.length);
        {
            var _k:GoInt = (0 : GoInt);
            Go.cfor(_i >= (4 : GoInt), _k++, {
                _z[(_k : GoInt)] = _bigEndianWord((_buf.__slice__(_i - (4 : GoInt), _i) : Slice<GoUInt8>));
                _i = _i - ((4 : GoInt));
            });
        };
        if (_i > (0 : GoInt)) {
            var _d:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
            {
                var _s:GoUInt = (0u32 : GoUInt);
                Go.cfor(_i > (0 : GoInt), _s = _s + ((8u32 : GoUInt)), {
                    _d = _d | ((_buf[(_i - (1 : GoInt) : GoInt)] : Word) << _s);
                    _i--;
                });
            };
            _z[((_z.length) - (1 : GoInt) : GoInt)] = _d;
        };
        return _z._norm();
    }
    /**
        // bytes writes the value of z into buf using big-endian encoding.
        // The value of z is encoded in the slice buf[i:]. If the value of z
        // cannot be represented in buf, bytes panics. The number i of unused
        // bytes at the beginning of buf is returned as result.
    **/
    @:keep
    static public function _bytes( _z:T_nat, _buf:Slice<GoByte>):GoInt {
        var _i:GoInt = (0 : GoInt);
        _i = (_buf.length);
        for (__0 => _d in _z) {
            {
                var _j:GoInt = (0 : GoInt);
                Go.cfor(_j < (4 : GoInt), _j++, {
                    _i--;
                    if (_i >= (0 : GoInt)) {
                        _buf[(_i : GoInt)] = (_d : GoByte);
                    } else if ((_d : GoByte) != ((0 : GoUInt8))) {
                        throw Go.toInterface(("math/big: buffer too small to fit value" : GoString));
                    };
                    _d = _d >> ((8i64 : GoUInt64));
                });
            };
        };
        if (_i < (0 : GoInt)) {
            _i = (0 : GoInt);
        };
        while ((_i < _buf.length) && (_buf[(_i : GoInt)] == (0 : GoUInt8))) {
            _i++;
        };
        return _i;
    }
    /**
        // expNNMontgomery calculates x**y mod m using a fixed, 4-bit window.
        // Uses Montgomery representation.
    **/
    @:keep
    static public function _expNNMontgomery( _z:T_nat, _x:T_nat, _y:T_nat, _m:T_nat):T_nat {
        var _numWords:GoInt = (_m.length);
        if ((_x.length) > _numWords) {
            {
                var __tmp__ = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._div(null, _x, _m);
                _x = __tmp__._1;
            };
        };
        if ((_x.length) < _numWords) {
            var _rr:stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat((_numWords : GoInt).toBasic(), 0, ...[for (i in 0 ... (_numWords : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
            Go.copySlice(_rr, _x);
            _x = _rr;
        };
        var _k0:stdgo.math.big.Big.Word = (2u32 : stdgo.math.big.Big.Word) - _m[(0 : GoInt)];
        var _t:stdgo.math.big.Big.Word = _m[(0 : GoInt)] - (1u32 : stdgo.math.big.Big.Word);
        {
            var _i:GoInt = (1 : GoInt);
            Go.cfor(_i < (32 : GoInt), _i = _i << ((1i64 : GoUInt64)), {
                _t = _t * (_t);
                _k0 = _k0 * ((_t + (1u32 : stdgo.math.big.Big.Word)));
            });
        };
        _k0 = -_k0;
        var rr:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._setWord((1u32 : stdgo.math.big.Big.Word));
        var _zz:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._shl(rr, (((2 : GoInt) * _numWords) * (32 : GoInt) : GoUInt));
        {
            var __tmp__ = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._div(rr, _zz, _m);
            rr = __tmp__._1;
        };
        if ((rr.length) < _numWords) {
            _zz = _zz._make(_numWords);
            Go.copySlice(_zz, rr);
            rr = _zz;
        };
        var _one:stdgo.math.big.Big.T_nat = new stdgo.math.big.Big.T_nat((_numWords : GoInt).toBasic(), 0, ...[for (i in 0 ... (_numWords : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
        _one[(0 : GoInt)] = (1u32 : stdgo.math.big.Big.Word);
        {};
        var _powers:GoArray<T_nat> = new GoArray<stdgo.math.big.Big.T_nat>(...[for (i in 0 ... 16) new stdgo.math.big.Big.T_nat(0, 0)]);
        _powers[(0 : GoInt)] = _powers[(0 : GoInt)]._montgomery(_one, rr, _m, _k0, _numWords);
        _powers[(1 : GoInt)] = _powers[(1 : GoInt)]._montgomery(_x, rr, _m, _k0, _numWords);
        {
            var _i:GoInt = (2 : GoInt);
            Go.cfor(_i < (16 : GoInt), _i++, {
                _powers[(_i : GoInt)] = _powers[(_i : GoInt)]._montgomery(_powers[(_i - (1 : GoInt) : GoInt)], _powers[(1 : GoInt)], _m, _k0, _numWords);
            });
        };
        _z = _z._make(_numWords);
        Go.copySlice(_z, _powers[(0 : GoInt)]);
        _zz = _zz._make(_numWords);
        {
            var _i:GoInt = (_y.length) - (1 : GoInt);
            Go.cfor(_i >= (0 : GoInt), _i--, {
                var _yi:stdgo.math.big.Big.Word = _y[(_i : GoInt)];
                {
                    var _j:GoInt = (0 : GoInt);
                    Go.cfor(_j < (32 : GoInt), _j = _j + ((4 : GoInt)), {
                        if ((_i != (_y.length - (1 : GoInt))) || (_j != (0 : GoInt))) {
                            _zz = _zz._montgomery(_z, _z, _m, _k0, _numWords);
                            _z = _z._montgomery(_zz, _zz, _m, _k0, _numWords);
                            _zz = _zz._montgomery(_z, _z, _m, _k0, _numWords);
                            _z = _z._montgomery(_zz, _zz, _m, _k0, _numWords);
                        };
                        _zz = _zz._montgomery(_z, _powers[(_yi >> (28i64 : GoUInt64) : GoInt)], _m, _k0, _numWords);
                        {
                            final __tmp__0 = _zz;
                            final __tmp__1 = _z;
                            _z = __tmp__0;
                            _zz = __tmp__1;
                        };
                        _yi = _yi << ((4i64 : GoUInt64));
                    });
                };
            });
        };
        _zz = _zz._montgomery(_z, _one, _m, _k0, _numWords);
        if (_zz._cmp(_m) >= (0 : GoInt)) {
            _zz = _zz._sub(_zz, _m);
            if (_zz._cmp(_m) >= (0 : GoInt)) {
                {
                    var __tmp__ = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._div(null, _zz, _m);
                    _zz = __tmp__._1;
                };
            };
        };
        return _zz._norm();
    }
    /**
        // expNNWindowed calculates x**y mod m using a fixed, 4-bit window,
        // where m = 2**logM.
    **/
    @:keep
    static public function _expNNWindowed( _z:T_nat, _x:T_nat, _y:T_nat, _logM:GoUInt):T_nat {
        if ((_y.length) <= (1 : GoInt)) {
            throw Go.toInterface(("big: misuse of expNNWindowed" : GoString));
        };
        if (_x[(0 : GoInt)] & (1u32 : stdgo.math.big.Big.Word) == ((0u32 : stdgo.math.big.Big.Word))) {
            return _z._setWord((0u32 : stdgo.math.big.Big.Word));
        };
        if (_logM == ((1u32 : GoUInt))) {
            return _z._setWord((1u32 : stdgo.math.big.Big.Word));
        };
        var _w:GoInt = (((_logM + (32u32 : GoUInt)) - (1u32 : GoUInt)) / (32u32 : GoUInt) : GoInt);
        var _zzp = _getNat(_w);
        var _zz:stdgo.math.big.Big.T_nat = (_zzp : stdgo.math.big.Big.T_nat);
        {};
        var _powers:GoArray<Ref<T_nat>> = new GoArray<Ref<stdgo.math.big.Big.T_nat>>(...[for (i in 0 ... 16) (null : Ref<stdgo.math.big.Big.T_nat>)]);
        for (_i in 0 ... _powers.length.toBasic()) {
            _powers[(_i : GoInt)] = _getNat(_w);
        };
        _powers[(0 : GoInt)].__setData__(_powers[(0 : GoInt)]._set(_natOne));
        _powers[(1 : GoInt)].__setData__(_powers[(1 : GoInt)]._trunc(_x, _logM));
        {
            var _i:GoInt = (2 : GoInt);
            Go.cfor(_i < (16 : GoInt), _i = _i + ((2 : GoInt)), {
                var __0 = _powers[(_i / (2 : GoInt) : GoInt)], __1 = _powers[(_i : GoInt)], __2 = _powers[(_i + (1 : GoInt) : GoInt)], _p1 = __2, _p = __1, _p2 = __0;
                _p.__setData__(_p._sqr((_p2 : stdgo.math.big.Big.T_nat)));
                _p.__setData__(_p._trunc((_p : stdgo.math.big.Big.T_nat), _logM));
                _p1.__setData__(_p1._mul((_p : stdgo.math.big.Big.T_nat), _x));
                _p1.__setData__(_p1._trunc((_p1 : stdgo.math.big.Big.T_nat), _logM));
            });
        };
        var _i:GoInt = (_y.length) - (1 : GoInt);
        var _mtop:GoInt = ((_logM - (2u32 : GoUInt)) / (32u32 : GoUInt) : GoInt);
        var _mmask:stdgo.math.big.Big.Word = (-1u32 : stdgo.math.big.Big.Word);
        {
            var _mbits:GoUInt = (_logM - (1u32 : GoUInt)) & (31u32 : GoUInt);
            if (_mbits != ((0u32 : GoUInt))) {
                _mmask = ((1u32 : stdgo.math.big.Big.Word) << _mbits) - (1u32 : stdgo.math.big.Big.Word);
            };
        };
        if (_i > _mtop) {
            _i = _mtop;
        };
        var _advance:Bool = false;
        _z = _z._setWord((1u32 : stdgo.math.big.Big.Word));
        Go.cfor(_i >= (0 : GoInt), _i--, {
            var _yi:stdgo.math.big.Big.Word = _y[(_i : GoInt)];
            if (_i == (_mtop)) {
                _yi = _yi & (_mmask);
            };
            {
                var _j:GoInt = (0 : GoInt);
                Go.cfor(_j < (32 : GoInt), _j = _j + ((4 : GoInt)), {
                    if (_advance) {
                        _zz = _zz._sqr(_z);
                        {
                            final __tmp__0 = _z;
                            final __tmp__1 = _zz;
                            _zz = __tmp__0;
                            _z = __tmp__1;
                        };
                        _z = _z._trunc(_z, _logM);
                        _zz = _zz._sqr(_z);
                        {
                            final __tmp__0 = _z;
                            final __tmp__1 = _zz;
                            _zz = __tmp__0;
                            _z = __tmp__1;
                        };
                        _z = _z._trunc(_z, _logM);
                        _zz = _zz._sqr(_z);
                        {
                            final __tmp__0 = _z;
                            final __tmp__1 = _zz;
                            _zz = __tmp__0;
                            _z = __tmp__1;
                        };
                        _z = _z._trunc(_z, _logM);
                        _zz = _zz._sqr(_z);
                        {
                            final __tmp__0 = _z;
                            final __tmp__1 = _zz;
                            _zz = __tmp__0;
                            _z = __tmp__1;
                        };
                        _z = _z._trunc(_z, _logM);
                    };
                    _zz = _zz._mul(_z, (_powers[(_yi >> (28i64 : GoUInt64) : GoInt)] : stdgo.math.big.Big.T_nat));
                    {
                        final __tmp__0 = _z;
                        final __tmp__1 = _zz;
                        _zz = __tmp__0;
                        _z = __tmp__1;
                    };
                    _z = _z._trunc(_z, _logM);
                    _yi = _yi << ((4i64 : GoUInt64));
                    _advance = true;
                });
            };
        });
        _zzp.__setData__(_zz);
        _putNat(_zzp);
        for (_i in 0 ... _powers.length.toBasic()) {
            _putNat(_powers[(_i : GoInt)]);
        };
        return _z._norm();
    }
    /**
        // expNNMontgomeryEven calculates x**y mod m where m = m1  m2 for m1 = 2 and m2 odd.
        // It uses two recursive calls to expNN for x**y mod m1 and x**y mod m2
        // and then uses the Chinese Remainder Theorem to combine the results.
        // The recursive call using m1 will use expNNWindowed,
        // while the recursive call using m2 will use expNNMontgomery.
        // For more details, see . K. Ko, Montgomery Reduction with Even Modulus,
        // IEE Proceedings: Computers and Digital Techniques, 141(5) 314-316, September 1994.
        // http://www.people.vcu.edu/~jwang3/CMSC691/j34monex.pdf
    **/
    @:keep
    static public function _expNNMontgomeryEven( _z:T_nat, _x:T_nat, _y:T_nat, _m:T_nat):T_nat {
        var _n:GoUInt = _m._trailingZeroBits();
        var _m1:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._shl(_natOne, _n);
        var _m2:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._shr(_m, _n);
        var _z1:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._expNN(_x, _y, _m1, false);
        var _z2:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._expNN(_x, _y, _m2, false);
        _z = _z._set(_z2);
        _z1 = _z1._subMod2N(_z1, _z2, _n);
        var _m2inv:stdgo.math.big.Big.T_nat = (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._modInverse(_m2, _m1);
        _z2 = _z2._mul(_z1, _m2inv);
        _z2 = _z2._trunc(_z2, _n);
        _z = _z._add(_z, _z1._mul(_z2, _m2));
        return _z;
    }
    /**
        // If m != 0 (i.e., len(m) != 0), expNN sets z to x**y mod m;
        // otherwise it sets z to x**y. The result is the value of z.
    **/
    @:keep
    static public function _expNN( _z:T_nat, _x:T_nat, _y:T_nat, _m:T_nat, _slow:Bool):T_nat {
        if (_alias(_z, _x) || _alias(_z, _y)) {
            _z = null;
        };
        if ((_m.length == (1 : GoInt)) && (_m[(0 : GoInt)] == (1u32 : stdgo.math.big.Big.Word))) {
            return _z._setWord((0u32 : stdgo.math.big.Big.Word));
        };
        if ((_y.length) == ((0 : GoInt))) {
            return _z._setWord((1u32 : stdgo.math.big.Big.Word));
        };
        if ((_x.length) == ((0 : GoInt))) {
            return _z._setWord((0u32 : stdgo.math.big.Big.Word));
        };
        if ((_x.length == (1 : GoInt)) && (_x[(0 : GoInt)] == (1u32 : stdgo.math.big.Big.Word))) {
            return _z._setWord((1u32 : stdgo.math.big.Big.Word));
        };
        if ((_y.length == (1 : GoInt)) && (_y[(0 : GoInt)] == (1u32 : stdgo.math.big.Big.Word))) {
            if ((_m.length) != ((0 : GoInt))) {
                return _z._rem(_x, _m);
            };
            return _z._set(_x);
        };
        if ((_m.length) != ((0 : GoInt))) {
            _z = _z._make((_m.length));
            if ((_y.length > (1 : GoInt)) && !_slow) {
                if (_m[(0 : GoInt)] & (1u32 : stdgo.math.big.Big.Word) == ((1u32 : stdgo.math.big.Big.Word))) {
                    return _z._expNNMontgomery(_x, _y, _m);
                };
                {
                    var __tmp__ = _m._isPow2(), _logM:GoUInt = __tmp__._0, _ok:Bool = __tmp__._1;
                    if (_ok) {
                        return _z._expNNWindowed(_x, _y, _logM);
                    };
                };
                return _z._expNNMontgomeryEven(_x, _y, _m);
            };
        };
        _z = _z._set(_x);
        var _v:stdgo.math.big.Big.Word = _y[((_y.length) - (1 : GoInt) : GoInt)];
        var _shift:GoUInt = _nlz(_v) + (1u32 : GoUInt);
        _v = _v << (_shift);
        var _q:T_nat = new stdgo.math.big.Big.T_nat(0, 0);
        {};
        var _w:GoInt = (32 : GoInt) - (_shift : GoInt);
        var __0:T_nat = new stdgo.math.big.Big.T_nat(0, 0), __1:T_nat = new stdgo.math.big.Big.T_nat(0, 0), _r:T_nat = __1, _zz:T_nat = __0;
        {
            var _j:GoInt = (0 : GoInt);
            Go.cfor(_j < _w, _j++, {
                _zz = _zz._sqr(_z);
                {
                    final __tmp__0 = _z;
                    final __tmp__1 = _zz;
                    _zz = __tmp__0;
                    _z = __tmp__1;
                };
                if (_v & (-2147483648u32 : stdgo.math.big.Big.Word) != ((0u32 : stdgo.math.big.Big.Word))) {
                    _zz = _zz._mul(_z, _x);
                    {
                        final __tmp__0 = _z;
                        final __tmp__1 = _zz;
                        _zz = __tmp__0;
                        _z = __tmp__1;
                    };
                };
                if ((_m.length) != ((0 : GoInt))) {
                    {
                        var __tmp__ = _zz._div(_r, _z, _m);
                        _zz = __tmp__._0;
                        _r = __tmp__._1;
                    };
                    {
                        final __tmp__0 = _q;
                        final __tmp__1 = _z;
                        final __tmp__2 = _zz;
                        final __tmp__3 = _r;
                        _zz = __tmp__0;
                        _r = __tmp__1;
                        _q = __tmp__2;
                        _z = __tmp__3;
                    };
                };
                _v = _v << ((1i64 : GoUInt64));
            });
        };
        {
            var _i:GoInt = (_y.length) - (2 : GoInt);
            Go.cfor(_i >= (0 : GoInt), _i--, {
                _v = _y[(_i : GoInt)];
                {
                    var _j:GoInt = (0 : GoInt);
                    Go.cfor(_j < (32 : GoInt), _j++, {
                        _zz = _zz._sqr(_z);
                        {
                            final __tmp__0 = _z;
                            final __tmp__1 = _zz;
                            _zz = __tmp__0;
                            _z = __tmp__1;
                        };
                        if (_v & (-2147483648u32 : stdgo.math.big.Big.Word) != ((0u32 : stdgo.math.big.Big.Word))) {
                            _zz = _zz._mul(_z, _x);
                            {
                                final __tmp__0 = _z;
                                final __tmp__1 = _zz;
                                _zz = __tmp__0;
                                _z = __tmp__1;
                            };
                        };
                        if ((_m.length) != ((0 : GoInt))) {
                            {
                                var __tmp__ = _zz._div(_r, _z, _m);
                                _zz = __tmp__._0;
                                _r = __tmp__._1;
                            };
                            {
                                final __tmp__0 = _q;
                                final __tmp__1 = _z;
                                final __tmp__2 = _zz;
                                final __tmp__3 = _r;
                                _zz = __tmp__0;
                                _r = __tmp__1;
                                _q = __tmp__2;
                                _z = __tmp__3;
                            };
                        };
                        _v = _v << ((1i64 : GoUInt64));
                    });
                };
            });
        };
        return _z._norm();
    }
    /**
        // random creates a random integer in [0..limit), using the space in z if
        // possible. n is the bit length of limit.
    **/
    @:keep
    static public function _random( _z:T_nat, _rand:Ref<stdgo.math.rand.Rand.Rand>, _limit:T_nat, _n:GoInt):T_nat {
        if (_alias(_z, _limit)) {
            _z = null;
        };
        _z = _z._make((_limit.length));
        var _bitLengthOfMSW:GoUInt = (_n % (32 : GoInt) : GoUInt);
        if (_bitLengthOfMSW == ((0u32 : GoUInt))) {
            _bitLengthOfMSW = (32u32 : GoUInt);
        };
        var _mask:stdgo.math.big.Big.Word = (((1u32 : stdgo.math.big.Big.Word) << _bitLengthOfMSW) - (1u32 : stdgo.math.big.Big.Word) : Word);
        while (true) {
            {
                final __value__ = (32 : GoInt);
                if (__value__ == ((32 : GoInt))) {
                    for (_i => _ in _z) {
                        _z[(_i : GoInt)] = (_rand.uint32() : Word);
                    };
                } else if (__value__ == ((64 : GoInt))) {
                    for (_i => _ in _z) {
                        _z[(_i : GoInt)] = (_rand.uint32() : Word) | ((_rand.uint32() : Word) << (32i64 : GoUInt64));
                    };
                } else {
                    throw Go.toInterface(("unknown word size" : GoString));
                };
            };
            _z[((_limit.length) - (1 : GoInt) : GoInt)] = _z[((_limit.length) - (1 : GoInt) : GoInt)] & (_mask);
            if (_z._cmp(_limit) < (0 : GoInt)) {
                break;
            };
        };
        return _z._norm();
    }
    @:keep
    static public function _xor( _z:T_nat, _x:T_nat, _y:T_nat):T_nat {
        var _m:GoInt = (_x.length);
        var _n:GoInt = (_y.length);
        var _s:stdgo.math.big.Big.T_nat = _x;
        if (_m < _n) {
            {
                final __tmp__0 = _m;
                final __tmp__1 = _n;
                _n = __tmp__0;
                _m = __tmp__1;
            };
            _s = _y;
        };
        _z = _z._make(_m);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _n, _i++, {
                _z[(_i : GoInt)] = _x[(_i : GoInt)] ^ _y[(_i : GoInt)];
            });
        };
        Go.copySlice((_z.__slice__(_n, _m) : stdgo.math.big.Big.T_nat), (_s.__slice__(_n, _m) : stdgo.math.big.Big.T_nat));
        return _z._norm();
    }
    @:keep
    static public function _or( _z:T_nat, _x:T_nat, _y:T_nat):T_nat {
        var _m:GoInt = (_x.length);
        var _n:GoInt = (_y.length);
        var _s:stdgo.math.big.Big.T_nat = _x;
        if (_m < _n) {
            {
                final __tmp__0 = _m;
                final __tmp__1 = _n;
                _n = __tmp__0;
                _m = __tmp__1;
            };
            _s = _y;
        };
        _z = _z._make(_m);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _n, _i++, {
                _z[(_i : GoInt)] = _x[(_i : GoInt)] | _y[(_i : GoInt)];
            });
        };
        Go.copySlice((_z.__slice__(_n, _m) : stdgo.math.big.Big.T_nat), (_s.__slice__(_n, _m) : stdgo.math.big.Big.T_nat));
        return _z._norm();
    }
    @:keep
    static public function _andNot( _z:T_nat, _x:T_nat, _y:T_nat):T_nat {
        var _m:GoInt = (_x.length);
        var _n:GoInt = (_y.length);
        if (_n > _m) {
            _n = _m;
        };
        _z = _z._make(_m);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _n, _i++, {
                _z[(_i : GoInt)] = _x[(_i : GoInt)] & (_y[(_i : GoInt)] ^ (-1i32 : GoInt));
            });
        };
        Go.copySlice((_z.__slice__(_n, _m) : stdgo.math.big.Big.T_nat), (_x.__slice__(_n, _m) : stdgo.math.big.Big.T_nat));
        return _z._norm();
    }
    /**
        // trunc returns z = x mod 2.
    **/
    @:keep
    static public function _trunc( _z:T_nat, _x:T_nat, _n:GoUInt):T_nat {
        var _w:GoUInt = ((_n + (32u32 : GoUInt)) - (1u32 : GoUInt)) / (32u32 : GoUInt);
        if ((_x.length : GoUInt) < _w) {
            return _z._set(_x);
        };
        _z = _z._make((_w : GoInt));
        Go.copySlice(_z, _x);
        if (_n % (32u32 : GoUInt) != ((0u32 : GoUInt))) {
            _z[((_z.length) - (1 : GoInt) : GoInt)] = _z[((_z.length) - (1 : GoInt) : GoInt)] & (((1u32 : stdgo.math.big.Big.Word) << (_n % (32u32 : GoUInt))) - (1u32 : stdgo.math.big.Big.Word));
        };
        return _z._norm();
    }
    @:keep
    static public function _and( _z:T_nat, _x:T_nat, _y:T_nat):T_nat {
        var _m:GoInt = (_x.length);
        var _n:GoInt = (_y.length);
        if (_m > _n) {
            _m = _n;
        };
        _z = _z._make(_m);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _m, _i++, {
                _z[(_i : GoInt)] = _x[(_i : GoInt)] & _y[(_i : GoInt)];
            });
        };
        return _z._norm();
    }
    /**
        // sticky returns 1 if there's a 1 bit within the
        // i least significant bits, otherwise it returns 0.
    **/
    @:keep
    static public function _sticky( _x:T_nat, _i:GoUInt):GoUInt {
        var _j:GoUInt = _i / (32u32 : GoUInt);
        if (_j >= (_x.length : GoUInt)) {
            if ((_x.length) == ((0 : GoInt))) {
                return (0u32 : GoUInt);
            };
            return (1u32 : GoUInt);
        };
        for (__0 => _x in (_x.__slice__(0, _j) : stdgo.math.big.Big.T_nat)) {
            if (_x != ((0u32 : stdgo.math.big.Big.Word))) {
                return (1u32 : GoUInt);
            };
        };
        if (_x[(_j : GoInt)] << ((32u32 : GoUInt) - (_i % (32u32 : GoUInt))) != ((0u32 : stdgo.math.big.Big.Word))) {
            return (1u32 : GoUInt);
        };
        return (0u32 : GoUInt);
    }
    /**
        // bit returns the value of the i'th bit, with lsb == bit 0.
    **/
    @:keep
    static public function _bit( _x:T_nat, _i:GoUInt):GoUInt {
        var _j:GoUInt = _i / (32u32 : GoUInt);
        if (_j >= (_x.length : GoUInt)) {
            return (0u32 : GoUInt);
        };
        return ((_x[(_j : GoInt)] >> (_i % (32u32 : GoUInt))) & (1u32 : stdgo.math.big.Big.Word) : GoUInt);
    }
    @:keep
    static public function _setBit( _z:T_nat, _x:T_nat, _i:GoUInt, _b:GoUInt):T_nat {
        var _j:GoInt = (_i / (32u32 : GoUInt) : GoInt);
        var _m:stdgo.math.big.Big.Word = ((1u32 : stdgo.math.big.Big.Word) : Word) << (_i % (32u32 : GoUInt));
        var _n:GoInt = (_x.length);
        {
            final __value__ = _b;
            if (__value__ == ((0u32 : GoUInt))) {
                _z = _z._make(_n);
                Go.copySlice(_z, _x);
                if (_j >= _n) {
                    return _z;
                };
                _z[(_j : GoInt)] = _z[(_j : GoInt)] & (_m ^ (-1i32 : GoInt));
                return _z._norm();
            } else if (__value__ == ((1u32 : GoUInt))) {
                if (_j >= _n) {
                    _z = _z._make(_j + (1 : GoInt));
                    (_z.__slice__(_n) : stdgo.math.big.Big.T_nat)._clear();
                } else {
                    _z = _z._make(_n);
                };
                Go.copySlice(_z, _x);
                _z[(_j : GoInt)] = _z[(_j : GoInt)] | (_m);
                return _z;
            };
        };
        throw Go.toInterface(("set bit is not 0 or 1" : GoString));
    }
    /**
        // z = x >> s
    **/
    @:keep
    static public function _shr( _z:T_nat, _x:T_nat, _s:GoUInt):T_nat {
        if (_s == ((0u32 : GoUInt))) {
            if (_same(_z, _x)) {
                return _z;
            };
            if (!_alias(_z, _x)) {
                return _z._set(_x);
            };
        };
        var _m:GoInt = (_x.length);
        var _n:GoInt = _m - (_s / (32u32 : GoUInt) : GoInt);
        if (_n <= (0 : GoInt)) {
            return (_z.__slice__(0, (0 : GoInt)) : stdgo.math.big.Big.T_nat);
        };
        _z = _z._make(_n);
        _shrVU(_z, (_x.__slice__(_m - _n) : stdgo.math.big.Big.T_nat), _s % (32u32 : GoUInt));
        return _z._norm();
    }
    /**
        // z = x << s
    **/
    @:keep
    static public function _shl( _z:T_nat, _x:T_nat, _s:GoUInt):T_nat {
        if (_s == ((0u32 : GoUInt))) {
            if (_same(_z, _x)) {
                return _z;
            };
            if (!_alias(_z, _x)) {
                return _z._set(_x);
            };
        };
        var _m:GoInt = (_x.length);
        if (_m == ((0 : GoInt))) {
            return (_z.__slice__(0, (0 : GoInt)) : stdgo.math.big.Big.T_nat);
        };
        var _n:GoInt = _m + (_s / (32u32 : GoUInt) : GoInt);
        _z = _z._make(_n + (1 : GoInt));
        _z[(_n : GoInt)] = _shlVU((_z.__slice__(_n - _m, _n) : stdgo.math.big.Big.T_nat), _x, _s % (32u32 : GoUInt));
        (_z.__slice__((0 : GoInt), _n - _m) : stdgo.math.big.Big.T_nat)._clear();
        return _z._norm();
    }
    /**
        // isPow2 returns i, true when x == 2**i and 0, false otherwise.
    **/
    @:keep
    static public function _isPow2( _x:T_nat):{ var _0 : GoUInt; var _1 : Bool; } {
        var _i:GoUInt = (0 : GoUInt);
        while (_x[(_i : GoInt)] == ((0u32 : stdgo.math.big.Big.Word))) {
            _i++;
        };
        if ((_i == ((_x.length : GoUInt) - (1u32 : GoUInt))) && ((_x[(_i : GoInt)] & (_x[(_i : GoInt)] - (1u32 : stdgo.math.big.Big.Word))) == (0u32 : stdgo.math.big.Big.Word))) {
            return { _0 : (_i * (32u32 : GoUInt)) + (stdgo.math.bits.Bits.trailingZeros((_x[(_i : GoInt)] : GoUInt)) : GoUInt), _1 : true };
        };
        return { _0 : (0u32 : GoUInt), _1 : false };
    }
    /**
        // trailingZeroBits returns the number of consecutive least significant zero
        // bits of x.
    **/
    @:keep
    static public function _trailingZeroBits( _x:T_nat):GoUInt {
        if ((_x.length) == ((0 : GoInt))) {
            return (0u32 : GoUInt);
        };
        var _i:GoUInt = (0 : GoUInt);
        while (_x[(_i : GoInt)] == ((0u32 : stdgo.math.big.Big.Word))) {
            _i++;
        };
        return (_i * (32u32 : GoUInt)) + (stdgo.math.bits.Bits.trailingZeros((_x[(_i : GoInt)] : GoUInt)) : GoUInt);
    }
    /**
        // bitLen returns the length of x in bits.
        // Unlike most methods, it works even if x is not normalized.
    **/
    @:keep
    static public function _bitLen( _x:T_nat):GoInt {
        {
            var _i:GoInt = (_x.length) - (1 : GoInt);
            if (_i >= (0 : GoInt)) {
                var _top:GoUInt = (_x[(_i : GoInt)] : GoUInt);
                _top = _top | (_top >> (1i64 : GoUInt64));
                _top = _top | (_top >> (2i64 : GoUInt64));
                _top = _top | (_top >> (4i64 : GoUInt64));
                _top = _top | (_top >> (8i64 : GoUInt64));
                _top = _top | (_top >> (16i64 : GoUInt64));
                _top = _top | ((_top >> (16i64 : GoUInt64)) >> (16i64 : GoUInt64));
                return (_i * (32 : GoInt)) + stdgo.math.bits.Bits.len(_top);
            };
        };
        return (0 : GoInt);
    }
    /**
        // mulRange computes the product of all the unsigned integers in the
        // range [a, b] inclusively. If a > b (empty range), the result is 1.
    **/
    @:keep
    static public function _mulRange( _z:T_nat, _a:GoUInt64, _b:GoUInt64):T_nat {
        if (_a == ((0i64 : GoUInt64))) {
            return _z._setUint64((0i64 : GoUInt64));
        } else if (_a > _b) {
            return _z._setUint64((1i64 : GoUInt64));
        } else if (_a == (_b)) {
            return _z._setUint64(_a);
        } else if (_a + (1i64 : GoUInt64) == (_b)) {
            return _z._mul((new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._setUint64(_a), (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._setUint64(_b));
        };
        var _m:GoUInt64 = (_a + _b) / (2i64 : GoUInt64);
        return _z._mul((new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._mulRange(_a, _m), (new stdgo.math.big.Big.T_nat(0, 0) : T_nat)._mulRange(_m + (1i64 : GoUInt64), _b));
    }
    /**
        // z = x*x
    **/
    @:keep
    static public function _sqr( _z:T_nat, _x:T_nat):T_nat {
        var _n:GoInt = (_x.length);
        if (_n == ((0 : GoInt))) {
            return (_z.__slice__(0, (0 : GoInt)) : stdgo.math.big.Big.T_nat);
        } else if (_n == ((1 : GoInt))) {
            var _d:stdgo.math.big.Big.Word = _x[(0 : GoInt)];
            _z = _z._make((2 : GoInt));
            {
                var __tmp__ = _mulWW(_d, _d);
                _z[(1 : GoInt)] = __tmp__._0;
                _z[(0 : GoInt)] = __tmp__._1;
            };
            return _z._norm();
        };
        if (_alias(_z, _x)) {
            _z = null;
        };
        if (_n < _basicSqrThreshold) {
            _z = _z._make((2 : GoInt) * _n);
            _basicMul(_z, _x, _x);
            return _z._norm();
        };
        if (_n < _karatsubaSqrThreshold) {
            _z = _z._make((2 : GoInt) * _n);
            _basicSqr(_z, _x);
            return _z._norm();
        };
        var _k:GoInt = _karatsubaLen(_n, _karatsubaSqrThreshold);
        var _x0:stdgo.math.big.Big.T_nat = (_x.__slice__((0 : GoInt), _k) : stdgo.math.big.Big.T_nat);
        _z = _z._make(_max((6 : GoInt) * _k, (2 : GoInt) * _n));
        _karatsubaSqr(_z, _x0);
        _z = (_z.__slice__((0 : GoInt), (2 : GoInt) * _n) : stdgo.math.big.Big.T_nat);
        (_z.__slice__((2 : GoInt) * _k) : stdgo.math.big.Big.T_nat)._clear();
        if (_k < _n) {
            var _tp = _getNat((2 : GoInt) * _k);
            var _t:stdgo.math.big.Big.T_nat = (_tp : stdgo.math.big.Big.T_nat);
            var _x0:stdgo.math.big.Big.T_nat = _x0._norm();
            var _x1:stdgo.math.big.Big.T_nat = (_x.__slice__(_k) : stdgo.math.big.Big.T_nat);
            _t = _t._mul(_x0, _x1);
            _addAt(_z, _t, _k);
            _addAt(_z, _t, _k);
            _t = _t._sqr(_x1);
            _addAt(_z, _t, (2 : GoInt) * _k);
            _putNat(_tp);
        };
        return _z._norm();
    }
    @:keep
    static public function _mul( _z:T_nat, _x:T_nat, _y:T_nat):T_nat {
        var _m:GoInt = (_x.length);
        var _n:GoInt = (_y.length);
        if (_m < _n) {
            return _z._mul(_y, _x);
        } else if ((_m == (0 : GoInt)) || (_n == (0 : GoInt))) {
            return (_z.__slice__(0, (0 : GoInt)) : stdgo.math.big.Big.T_nat);
        } else if (_n == ((1 : GoInt))) {
            return _z._mulAddWW(_x, _y[(0 : GoInt)], (0u32 : stdgo.math.big.Big.Word));
        };
        if (_alias(_z, _x) || _alias(_z, _y)) {
            _z = null;
        };
        if (_n < _karatsubaThreshold) {
            _z = _z._make(_m + _n);
            _basicMul(_z, _x, _y);
            return _z._norm();
        };
        var _k:GoInt = _karatsubaLen(_n, _karatsubaThreshold);
        var _x0:stdgo.math.big.Big.T_nat = (_x.__slice__((0 : GoInt), _k) : stdgo.math.big.Big.T_nat);
        var _y0:stdgo.math.big.Big.T_nat = (_y.__slice__((0 : GoInt), _k) : stdgo.math.big.Big.T_nat);
        _z = _z._make(_max((6 : GoInt) * _k, _m + _n));
        _karatsuba(_z, _x0, _y0);
        _z = (_z.__slice__((0 : GoInt), _m + _n) : stdgo.math.big.Big.T_nat);
        (_z.__slice__((2 : GoInt) * _k) : stdgo.math.big.Big.T_nat)._clear();
        if ((_k < _n) || (_m != _n)) {
            var _tp = _getNat((3 : GoInt) * _k);
            var _t:stdgo.math.big.Big.T_nat = (_tp : stdgo.math.big.Big.T_nat);
            var _x0:stdgo.math.big.Big.T_nat = _x0._norm();
            var _y1:stdgo.math.big.Big.T_nat = (_y.__slice__(_k) : stdgo.math.big.Big.T_nat);
            _t = _t._mul(_x0, _y1);
            _addAt(_z, _t, _k);
            var _y0:stdgo.math.big.Big.T_nat = _y0._norm();
            {
                var _i:GoInt = _k;
                Go.cfor(_i < (_x.length), _i = _i + (_k), {
                    var _xi:stdgo.math.big.Big.T_nat = (_x.__slice__(_i) : stdgo.math.big.Big.T_nat);
                    if ((_xi.length) > _k) {
                        _xi = (_xi.__slice__(0, _k) : stdgo.math.big.Big.T_nat);
                    };
                    _xi = _xi._norm();
                    _t = _t._mul(_xi, _y0);
                    _addAt(_z, _t, _i);
                    _t = _t._mul(_xi, _y1);
                    _addAt(_z, _t, _i + _k);
                });
            };
            _putNat(_tp);
        };
        return _z._norm();
    }
    /**
        // montgomery computes z mod m = x*y*2**(-n*_W) mod m,
        // assuming k = -1/m mod 2**_W.
        // z is used for storing the result which is returned;
        // z must not alias x, y or m.
        // See Gueron, "Efficient Software Implementations of Modular Exponentiation".
        // https://eprint.iacr.org/2011/239.pdf
        // In the terminology of that paper, this is an "Almost Montgomery Multiplication":
        // x and y are required to satisfy 0 <= z < 2**(n*_W) and then the result
        // z is guaranteed to satisfy 0 <= z < 2**(n*_W), but it may not be < m.
    **/
    @:keep
    static public function _montgomery( _z:T_nat, _x:T_nat, _y:T_nat, _m:T_nat, _k:Word, _n:GoInt):T_nat {
        if (((_x.length != _n) || (_y.length != _n)) || (_m.length != _n)) {
            throw Go.toInterface(("math/big: mismatched montgomery number lengths" : GoString));
        };
        _z = _z._make(_n * (2 : GoInt));
        _z._clear();
        var _c:Word = ((0 : GoUInt) : stdgo.math.big.Big.Word);
        {
            var _i:GoInt = (0 : GoInt);
            Go.cfor(_i < _n, _i++, {
                var _d:stdgo.math.big.Big.Word = _y[(_i : GoInt)];
                var _c2:stdgo.math.big.Big.Word = _addMulVVW((_z.__slice__(_i, _n + _i) : stdgo.math.big.Big.T_nat), _x, _d);
                var _t:stdgo.math.big.Big.Word = _z[(_i : GoInt)] * _k;
                var _c3:stdgo.math.big.Big.Word = _addMulVVW((_z.__slice__(_i, _n + _i) : stdgo.math.big.Big.T_nat), _m, _t);
                var _cx:stdgo.math.big.Big.Word = _c + _c2;
                var _cy:stdgo.math.big.Big.Word = _cx + _c3;
                _z[(_n + _i : GoInt)] = _cy;
                if ((_cx < _c2) || (_cy < _c3)) {
                    _c = (1u32 : stdgo.math.big.Big.Word);
                } else {
                    _c = (0u32 : stdgo.math.big.Big.Word);
                };
            });
        };
        if (_c != ((0u32 : stdgo.math.big.Big.Word))) {
            _subVV((_z.__slice__(0, _n) : stdgo.math.big.Big.T_nat), (_z.__slice__(_n) : stdgo.math.big.Big.T_nat), _m);
        } else {
            Go.copySlice((_z.__slice__(0, _n) : stdgo.math.big.Big.T_nat), (_z.__slice__(_n) : stdgo.math.big.Big.T_nat));
        };
        return (_z.__slice__(0, _n) : stdgo.math.big.Big.T_nat);
    }
    @:keep
    static public function _mulAddWW( _z:T_nat, _x:T_nat, _y:Word, _r:Word):T_nat {
        var _m:GoInt = (_x.length);
        if ((_m == (0 : GoInt)) || (_y == (0u32 : stdgo.math.big.Big.Word))) {
            return _z._setWord(_r);
        };
        _z = _z._make(_m + (1 : GoInt));
        _z[(_m : GoInt)] = _mulAddVWW((_z.__slice__((0 : GoInt), _m) : stdgo.math.big.Big.T_nat), _x, _y, _r);
        return _z._norm();
    }
    @:keep
    static public function _cmp( _x:T_nat, _y:T_nat):GoInt {
        var _r:GoInt = (0 : GoInt);
        var _m:GoInt = (_x.length);
        var _n:GoInt = (_y.length);
        if ((_m != _n) || (_m == (0 : GoInt))) {
            if (_m < _n) {
                _r = (-1 : GoInt);
            } else if (_m > _n) {
                _r = (1 : GoInt);
            };
            return _r;
        };
        var _i:GoInt = _m - (1 : GoInt);
        while ((_i > (0 : GoInt)) && (_x[(_i : GoInt)] == _y[(_i : GoInt)])) {
            _i--;
        };
        if (_x[(_i : GoInt)] < _y[(_i : GoInt)]) {
            _r = (-1 : GoInt);
        } else if (_x[(_i : GoInt)] > _y[(_i : GoInt)]) {
            _r = (1 : GoInt);
        };
        return _r;
    }
    @:keep
    static public function _sub( _z:T_nat, _x:T_nat, _y:T_nat):T_nat {
        var _m:GoInt = (_x.length);
        var _n:GoInt = (_y.length);
        if (_m < _n) {
            throw Go.toInterface(("underflow" : GoString));
        } else if (_m == ((0 : GoInt))) {
            return (_z.__slice__(0, (0 : GoInt)) : stdgo.math.big.Big.T_nat);
        } else if (_n == ((0 : GoInt))) {
            return _z._set(_x);
        };
        _z = _z._make(_m);
        var _c:stdgo.math.big.Big.Word = _subVV((_z.__slice__((0 : GoInt), _n) : stdgo.math.big.Big.T_nat), _x, _y);
        if (_m > _n) {
            _c = _subVW((_z.__slice__(_n) : stdgo.math.big.Big.T_nat), (_x.__slice__(_n) : stdgo.math.big.Big.T_nat), _c);
        };
        if (_c != ((0u32 : stdgo.math.big.Big.Word))) {
            throw Go.toInterface(("underflow" : GoString));
        };
        return _z._norm();
    }
    @:keep
    static public function _add( _z:T_nat, _x:T_nat, _y:T_nat):T_nat {
        var _m:GoInt = (_x.length);
        var _n:GoInt = (_y.length);
        if (_m < _n) {
            return _z._add(_y, _x);
        } else if (_m == ((0 : GoInt))) {
            return (_z.__slice__(0, (0 : GoInt)) : stdgo.math.big.Big.T_nat);
        } else if (_n == ((0 : GoInt))) {
            return _z._set(_x);
        };
        _z = _z._make(_m + (1 : GoInt));
        var _c:stdgo.math.big.Big.Word = _addVV((_z.__slice__((0 : GoInt), _n) : stdgo.math.big.Big.T_nat), _x, _y);
        if (_m > _n) {
            _c = _addVW((_z.__slice__(_n, _m) : stdgo.math.big.Big.T_nat), (_x.__slice__(_n) : stdgo.math.big.Big.T_nat), _c);
        };
        _z[(_m : GoInt)] = _c;
        return _z._norm();
    }
    @:keep
    static public function _set( _z:T_nat, _x:T_nat):T_nat {
        _z = _z._make((_x.length));
        Go.copySlice(_z, _x);
        return _z;
    }
    @:keep
    static public function _setUint64( _z:T_nat, _x:GoUInt64):T_nat {
        {
            var _w:stdgo.math.big.Big.Word = (_x : Word);
            if ((_w : GoUInt64) == (_x)) {
                return _z._setWord(_w);
            };
        };
        _z = _z._make((2 : GoInt));
        _z[(1 : GoInt)] = (_x >> (32i64 : GoUInt64) : Word);
        _z[(0 : GoInt)] = (_x : Word);
        return _z;
    }
    @:keep
    static public function _setWord( _z:T_nat, _x:Word):T_nat {
        if (_x == ((0u32 : stdgo.math.big.Big.Word))) {
            return (_z.__slice__(0, (0 : GoInt)) : stdgo.math.big.Big.T_nat);
        };
        _z = _z._make((1 : GoInt));
        _z[(0 : GoInt)] = _x;
        return _z;
    }
    @:keep
    static public function _make( _z:T_nat, _n:GoInt):T_nat {
        if (_n <= _z.capacity) {
            return (_z.__slice__(0, _n) : stdgo.math.big.Big.T_nat);
        };
        if (_n == ((1 : GoInt))) {
            return new stdgo.math.big.Big.T_nat((1 : GoInt).toBasic(), 0, ...[for (i in 0 ... (1 : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
        };
        {};
        return new stdgo.math.big.Big.T_nat((_n : GoInt).toBasic(), _n + (4 : GoInt), ...[for (i in 0 ... (_n : GoInt).toBasic()) ((0 : GoUInt) : stdgo.math.big.Big.Word)]);
    }
    @:keep
    static public function _norm( _z:T_nat):T_nat {
        var _i:GoInt = (_z.length);
        while ((_i > (0 : GoInt)) && (_z[(_i - (1 : GoInt) : GoInt)] == (0u32 : stdgo.math.big.Big.Word))) {
            _i--;
        };
        return (_z.__slice__((0 : GoInt), _i) : stdgo.math.big.Big.T_nat);
    }
    @:keep
    static public function _clear( _z:T_nat):Void {
        for (_i => _ in _z) {
            _z[(_i : GoInt)] = (0u32 : stdgo.math.big.Big.Word);
        };
    }
    @:keep
    static public function string( _z:T_nat):GoString {
        return ("0x" : GoString) + (_z._itoa(false, (16 : GoInt)) : GoString);
    }
    @:keep
    static public function _modInverse( _z:T_nat, _g:T_nat, _n:T_nat):T_nat {
        return (Go.setRef(({ _abs : _z } : Int_)) : Ref<stdgo.math.big.Big.Int_>).modInverse((Go.setRef(({ _abs : _g } : Int_)) : Ref<stdgo.math.big.Big.Int_>), (Go.setRef(({ _abs : _n } : Int_)) : Ref<stdgo.math.big.Big.Int_>))._abs;
    }
}
