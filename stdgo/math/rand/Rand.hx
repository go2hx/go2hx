package stdgo.math.rand;
/**
    Package rand implements pseudo-random number generators suitable for tasks
    such as simulation, but it should not be used for security-sensitive work.
    
    Random numbers are generated by a [Source], usually wrapped in a [Rand].
    Both types should be used by a single goroutine at a time: sharing among
    multiple goroutines requires some kind of synchronization.
    
    Top-level functions, such as [Float64] and [Int],
    are safe for concurrent use by multiple goroutines.
    
    This package's outputs might be easily predictable regardless of how it's
    seeded. For random numbers suitable for security-sensitive work, see the
    crypto/rand package.
**/
private var __go2hxdoc__package : Bool;
@:invalid typedef Source_static_extension = Dynamic;
typedef Source = stdgo._internal.math.rand.Rand.Source;
@:invalid typedef Source64_static_extension = Dynamic;
typedef Source64 = stdgo._internal.math.rand.Rand.Source64;
@:invalid typedef Rand = Dynamic;
@:invalid typedef T_fastSource = Dynamic;
@:invalid typedef T_lockedSource = Dynamic;
@:invalid typedef T_rngSource = Dynamic;
@:invalid typedef Zipf = Dynamic;
inline function int31nForTest(r:Rand, n:Int):Int throw "not implemented";
inline function getNormalDistributionParameters():stdgo.Tuple.Tuple4<Float, haxe.ds.Vector<UInt>, haxe.ds.Vector<Float>, haxe.ds.Vector<Float>> throw "not implemented";
inline function getExponentialDistributionParameters():stdgo.Tuple.Tuple4<Float, haxe.ds.Vector<UInt>, haxe.ds.Vector<Float>, haxe.ds.Vector<Float>> throw "not implemented";
/**
    NewSource returns a new pseudo-random Source seeded with the given value.
    Unlike the default Source used by top-level functions, this source is not
    safe for concurrent use by multiple goroutines.
    The returned Source implements Source64.
**/
inline function newSource(seed:haxe.Int64):Source throw "not implemented";
/**
    New returns a new Rand that uses random values from src
    to generate other random values.
**/
inline function new_(src:Source):Rand throw "not implemented";
/**
    Seed uses the provided seed value to initialize the default Source to a
    deterministic state. Seed values that have the same remainder when
    divided by 2³¹-1 generate the same pseudo-random sequence.
    Seed, unlike the Rand.Seed method, is safe for concurrent use.
    
    If Seed is not called, the generator is seeded randomly at program startup.
    
    Prior to Go 1.20, the generator was seeded like Seed(1) at program startup.
    To force the old behavior, call Seed(1) at program startup.
    Alternately, set GODEBUG=randautoseed=0 in the environment
    before making any calls to functions in this package.
    
    Deprecated: As of Go 1.20 there is no reason to call Seed with
    a random value. Programs that call Seed with a known value to get
    a specific sequence of results should use New(NewSource(seed)) to
    obtain a local random generator.
**/
inline function seed(seed:haxe.Int64):Void throw "not implemented";
/**
    Int63 returns a non-negative pseudo-random 63-bit integer as an int64
    from the default Source.
**/
inline function int63():haxe.Int64 throw "not implemented";
/**
    Uint32 returns a pseudo-random 32-bit value as a uint32
    from the default Source.
**/
inline function uint32():UInt throw "not implemented";
/**
    Uint64 returns a pseudo-random 64-bit value as a uint64
    from the default Source.
**/
inline function uint64():haxe.UInt64 throw "not implemented";
/**
    Int31 returns a non-negative pseudo-random 31-bit integer as an int32
    from the default Source.
**/
inline function int31():Int throw "not implemented";
/**
    Int returns a non-negative pseudo-random int from the default Source.
**/
inline function int_():Int throw "not implemented";
/**
    Int63n returns, as an int64, a non-negative pseudo-random number in the half-open interval [0,n)
    from the default Source.
    It panics if n <= 0.
**/
inline function int63n(n:haxe.Int64):haxe.Int64 throw "not implemented";
/**
    Int31n returns, as an int32, a non-negative pseudo-random number in the half-open interval [0,n)
    from the default Source.
    It panics if n <= 0.
**/
inline function int31n(n:Int):Int throw "not implemented";
/**
    Intn returns, as an int, a non-negative pseudo-random number in the half-open interval [0,n)
    from the default Source.
    It panics if n <= 0.
**/
inline function intn(n:Int):Int throw "not implemented";
/**
    Float64 returns, as a float64, a pseudo-random number in the half-open interval [0.0,1.0)
    from the default Source.
**/
inline function float64():Float throw "not implemented";
/**
    Float32 returns, as a float32, a pseudo-random number in the half-open interval [0.0,1.0)
    from the default Source.
**/
inline function float32():Float throw "not implemented";
/**
    Perm returns, as a slice of n ints, a pseudo-random permutation of the integers
    in the half-open interval [0,n) from the default Source.
**/
inline function perm(n:Int):Array<Int> throw "not implemented";
/**
    Shuffle pseudo-randomizes the order of elements using the default Source.
    n is the number of elements. Shuffle panics if n < 0.
    swap swaps the elements with indexes i and j.
**/
inline function shuffle(n:Int, swap:(_i:stdgo.GoInt, _j:stdgo.GoInt) -> Void):Void throw "not implemented";
/**
    Read generates len(p) random bytes from the default Source and
    writes them into p. It always returns len(p) and a nil error.
    Read, unlike the Rand.Read method, is safe for concurrent use.
    
    Deprecated: For almost all use cases, crypto/rand.Read is more appropriate.
**/
inline function read(p:Array<Int>):stdgo.Tuple<Int, stdgo.Error> throw "not implemented";
/**
    NormFloat64 returns a normally distributed float64 in the range
    [-math.MaxFloat64, +math.MaxFloat64] with
    standard normal distribution (mean = 0, stddev = 1)
    from the default Source.
    To produce a different normal distribution, callers can
    adjust the output using:
    
    	sample = NormFloat64() * desiredStdDev + desiredMean
**/
inline function normFloat64():Float throw "not implemented";
/**
    ExpFloat64 returns an exponentially distributed float64 in the range
    (0, +math.MaxFloat64] with an exponential distribution whose rate parameter
    (lambda) is 1 and whose mean is 1/lambda (1) from the default Source.
    To produce a distribution with a different rate parameter,
    callers can adjust the output using:
    
    	sample = ExpFloat64() / desiredRateParameter
**/
inline function expFloat64():Float throw "not implemented";
/**
    NewZipf returns a Zipf variate generator.
    The generator generates values k ∈ [0, imax]
    such that P(k) is proportional to (v + k) ** (-s).
    Requirements: s > 1 and v >= 1.
**/
inline function newZipf(r:Rand, s:Float, v:Float, imax:haxe.UInt64):Zipf throw "not implemented";
@:invalid typedef Rand_asInterface = Dynamic;
@:invalid typedef Rand_static_extension = Dynamic;
@:invalid typedef T_fastSource_asInterface = Dynamic;
@:invalid typedef T_fastSource_static_extension = Dynamic;
@:invalid typedef T_lockedSource_asInterface = Dynamic;
@:invalid typedef T_lockedSource_static_extension = Dynamic;
@:invalid typedef T_rngSource_asInterface = Dynamic;
@:invalid typedef T_rngSource_static_extension = Dynamic;
@:invalid typedef Zipf_asInterface = Dynamic;
@:invalid typedef Zipf_static_extension = Dynamic;
