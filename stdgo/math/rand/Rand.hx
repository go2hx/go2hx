package stdgo.math.rand;
typedef Source = stdgo._internal.math.rand.Rand_source.Source;
typedef Source64 = stdgo._internal.math.rand.Rand_source64.Source64;
typedef Rand_ = stdgo._internal.math.rand.Rand_rand.Rand;
typedef Zipf = stdgo._internal.math.rand.Rand_zipf.Zipf;
typedef RandPointer = stdgo._internal.math.rand.Rand_randpointer.RandPointer;
typedef ZipfPointer = stdgo._internal.math.rand.Rand_zipfpointer.ZipfPointer;
/**
    * Package rand implements pseudo-random number generators suitable for tasks
    * such as simulation, but it should not be used for security-sensitive work.
    * 
    * Random numbers are generated by a [Source], usually wrapped in a [Rand].
    * Both types should be used by a single goroutine at a time: sharing among
    * multiple goroutines requires some kind of synchronization.
    * 
    * Top-level functions, such as [Float64] and [Int],
    * are safe for concurrent use by multiple goroutines.
    * 
    * This package's outputs might be easily predictable regardless of how it's
    * seeded. For random numbers suitable for security-sensitive work, see the
    * crypto/rand package.
**/
class Rand {
    static public inline function int31nForTest(_r:stdgo.Ref<stdgo._internal.math.rand.Rand_rand.Rand>, _n:stdgo.GoInt32):stdgo.GoInt32 return stdgo._internal.math.rand.Rand_int31nfortest.int31nForTest(_r, _n);
    static public inline function getNormalDistributionParameters():{ var _0 : stdgo.GoFloat64; var _1 : stdgo.GoArray<stdgo.GoUInt32>; var _2 : stdgo.GoArray<stdgo.GoFloat32>; var _3 : stdgo.GoArray<stdgo.GoFloat32>; } return stdgo._internal.math.rand.Rand_getnormaldistributionparameters.getNormalDistributionParameters();
    static public inline function getExponentialDistributionParameters():{ var _0 : stdgo.GoFloat64; var _1 : stdgo.GoArray<stdgo.GoUInt32>; var _2 : stdgo.GoArray<stdgo.GoFloat32>; var _3 : stdgo.GoArray<stdgo.GoFloat32>; } return stdgo._internal.math.rand.Rand_getexponentialdistributionparameters.getExponentialDistributionParameters();
    /**
        * NewSource returns a new pseudo-random Source seeded with the given value.
        * Unlike the default Source used by top-level functions, this source is not
        * safe for concurrent use by multiple goroutines.
        * The returned Source implements Source64.
    **/
    static public inline function newSource(_seed:stdgo.GoInt64):stdgo._internal.math.rand.Rand_source.Source return stdgo._internal.math.rand.Rand_newsource.newSource(_seed);
    /**
        * New returns a new Rand that uses random values from src
        * to generate other random values.
    **/
    static public inline function new_(_src:Source):stdgo.Ref<stdgo._internal.math.rand.Rand_rand.Rand> return stdgo._internal.math.rand.Rand_new_.new_(_src);
    /**
        * Seed uses the provided seed value to initialize the default Source to a
        * deterministic state. Seed values that have the same remainder when
        * divided by 2³¹-1 generate the same pseudo-random sequence.
        * Seed, unlike the Rand.Seed method, is safe for concurrent use.
        * 
        * If Seed is not called, the generator is seeded randomly at program startup.
        * 
        * Prior to Go 1.20, the generator was seeded like Seed(1) at program startup.
        * To force the old behavior, call Seed(1) at program startup.
        * Alternately, set GODEBUG=randautoseed=0 in the environment
        * before making any calls to functions in this package.
        * 
        * Deprecated: As of Go 1.20 there is no reason to call Seed with
        * a random value. Programs that call Seed with a known value to get
        * a specific sequence of results should use New(NewSource(seed)) to
        * obtain a local random generator.
    **/
    static public inline function seed(_seed:stdgo.GoInt64):Void stdgo._internal.math.rand.Rand_seed.seed(_seed);
    /**
        * Int63 returns a non-negative pseudo-random 63-bit integer as an int64
        * from the default Source.
    **/
    static public inline function int63():stdgo.GoInt64 return stdgo._internal.math.rand.Rand_int63.int63();
    /**
        * Uint32 returns a pseudo-random 32-bit value as a uint32
        * from the default Source.
    **/
    static public inline function uint32():stdgo.GoUInt32 return stdgo._internal.math.rand.Rand_uint32.uint32();
    /**
        * Uint64 returns a pseudo-random 64-bit value as a uint64
        * from the default Source.
    **/
    static public inline function uint64():stdgo.GoUInt64 return stdgo._internal.math.rand.Rand_uint64.uint64();
    /**
        * Int31 returns a non-negative pseudo-random 31-bit integer as an int32
        * from the default Source.
    **/
    static public inline function int31():stdgo.GoInt32 return stdgo._internal.math.rand.Rand_int31.int31();
    /**
        * Int returns a non-negative pseudo-random int from the default Source.
    **/
    static public inline function int_():stdgo.GoInt return stdgo._internal.math.rand.Rand_int_.int_();
    /**
        * Int63n returns, as an int64, a non-negative pseudo-random number in the half-open interval [0,n)
        * from the default Source.
        * It panics if n <= 0.
    **/
    static public inline function int63n(_n:stdgo.GoInt64):stdgo.GoInt64 return stdgo._internal.math.rand.Rand_int63n.int63n(_n);
    /**
        * Int31n returns, as an int32, a non-negative pseudo-random number in the half-open interval [0,n)
        * from the default Source.
        * It panics if n <= 0.
    **/
    static public inline function int31n(_n:stdgo.GoInt32):stdgo.GoInt32 return stdgo._internal.math.rand.Rand_int31n.int31n(_n);
    /**
        * Intn returns, as an int, a non-negative pseudo-random number in the half-open interval [0,n)
        * from the default Source.
        * It panics if n <= 0.
    **/
    static public inline function intn(_n:stdgo.GoInt):stdgo.GoInt return stdgo._internal.math.rand.Rand_intn.intn(_n);
    /**
        * Float64 returns, as a float64, a pseudo-random number in the half-open interval [0.0,1.0)
        * from the default Source.
    **/
    static public inline function float64():stdgo.GoFloat64 return stdgo._internal.math.rand.Rand_float64.float64();
    /**
        * Float32 returns, as a float32, a pseudo-random number in the half-open interval [0.0,1.0)
        * from the default Source.
    **/
    static public inline function float32():stdgo.GoFloat32 return stdgo._internal.math.rand.Rand_float32.float32();
    /**
        * Perm returns, as a slice of n ints, a pseudo-random permutation of the integers
        * in the half-open interval [0,n) from the default Source.
    **/
    static public inline function perm(_n:stdgo.GoInt):stdgo.Slice<stdgo.GoInt> return stdgo._internal.math.rand.Rand_perm.perm(_n);
    /**
        * Shuffle pseudo-randomizes the order of elements using the default Source.
        * n is the number of elements. Shuffle panics if n < 0.
        * swap swaps the elements with indexes i and j.
    **/
    static public inline function shuffle(_n:stdgo.GoInt, _swap:(stdgo.GoInt, stdgo.GoInt) -> Void):Void stdgo._internal.math.rand.Rand_shuffle.shuffle(_n, _swap);
    /**
        * Read generates len(p) random bytes from the default Source and
        * writes them into p. It always returns len(p) and a nil error.
        * Read, unlike the Rand.Read method, is safe for concurrent use.
        * 
        * Deprecated: For almost all use cases, crypto/rand.Read is more appropriate.
    **/
    static public inline function read(_p:stdgo.Slice<stdgo.GoUInt8>):{ var _0 : stdgo.GoInt; var _1 : stdgo.Error; } return stdgo._internal.math.rand.Rand_read.read(_p);
    /**
        * NormFloat64 returns a normally distributed float64 in the range
        * [-math.MaxFloat64, +math.MaxFloat64] with
        * standard normal distribution (mean = 0, stddev = 1)
        * from the default Source.
        * To produce a different normal distribution, callers can
        * adjust the output using:
        * 
        * 	sample = NormFloat64() * desiredStdDev + desiredMean
    **/
    static public inline function normFloat64():stdgo.GoFloat64 return stdgo._internal.math.rand.Rand_normfloat64.normFloat64();
    /**
        * ExpFloat64 returns an exponentially distributed float64 in the range
        * (0, +math.MaxFloat64] with an exponential distribution whose rate parameter
        * (lambda) is 1 and whose mean is 1/lambda (1) from the default Source.
        * To produce a distribution with a different rate parameter,
        * callers can adjust the output using:
        * 
        * 	sample = ExpFloat64() / desiredRateParameter
    **/
    static public inline function expFloat64():stdgo.GoFloat64 return stdgo._internal.math.rand.Rand_expfloat64.expFloat64();
    /**
        * NewZipf returns a Zipf variate generator.
        * The generator generates values k ∈ [0, imax]
        * such that P(k) is proportional to (v + k) ** (-s).
        * Requirements: s > 1 and v >= 1.
    **/
    static public inline function newZipf(_r:stdgo.Ref<stdgo._internal.math.rand.Rand_rand.Rand>, _s:stdgo.GoFloat64, _v:stdgo.GoFloat64, _imax:stdgo.GoUInt64):stdgo.Ref<stdgo._internal.math.rand.Rand_zipf.Zipf> return stdgo._internal.math.rand.Rand_newzipf.newZipf(_r, _s, _v, _imax);
}
