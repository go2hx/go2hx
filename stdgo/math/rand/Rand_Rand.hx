package stdgo.math.rand;
/**
    Package rand implements pseudo-random number generators suitable for tasks
    such as simulation, but it should not be used for security-sensitive work.
    
    Random numbers are generated by a [Source], usually wrapped in a [Rand].
    Both types should be used by a single goroutine at a time: sharing among
    multiple goroutines requires some kind of synchronization.
    
    Top-level functions, such as [Float64] and [Int],
    are safe for concurrent use by multiple goroutines.
    
    This package's outputs might be easily predictable regardless of how it's
    seeded. For random numbers suitable for security-sensitive work, see the
    crypto/rand package.
**/
class Rand {
    static public inline function int31nForTest(_r:Rand_, _n:StdTypes.Int):StdTypes.Int {
        final _r = (_r : stdgo.Ref<stdgo._internal.math.rand.Rand_Rand.Rand>);
        final _n = (_n : stdgo.GoInt32);
        return stdgo._internal.math.rand.Rand_int31nForTest.int31nForTest(_r, _n);
    }
    static public inline function getNormalDistributionParameters():stdgo.Tuple.Tuple4<StdTypes.Float, haxe.ds.Vector<std.UInt>, haxe.ds.Vector<StdTypes.Float>, haxe.ds.Vector<StdTypes.Float>> {
        return {
            final obj = stdgo._internal.math.rand.Rand_getNormalDistributionParameters.getNormalDistributionParameters();
            { _0 : obj._0, _1 : haxe.ds.Vector.fromArrayCopy([for (i in obj._1) i]), _2 : haxe.ds.Vector.fromArrayCopy([for (i in obj._2) i]), _3 : haxe.ds.Vector.fromArrayCopy([for (i in obj._3) i]) };
        };
    }
    static public inline function getExponentialDistributionParameters():stdgo.Tuple.Tuple4<StdTypes.Float, haxe.ds.Vector<std.UInt>, haxe.ds.Vector<StdTypes.Float>, haxe.ds.Vector<StdTypes.Float>> {
        return {
            final obj = stdgo._internal.math.rand.Rand_getExponentialDistributionParameters.getExponentialDistributionParameters();
            { _0 : obj._0, _1 : haxe.ds.Vector.fromArrayCopy([for (i in obj._1) i]), _2 : haxe.ds.Vector.fromArrayCopy([for (i in obj._2) i]), _3 : haxe.ds.Vector.fromArrayCopy([for (i in obj._3) i]) };
        };
    }
    /**
        NewSource returns a new pseudo-random Source seeded with the given value.
        Unlike the default Source used by top-level functions, this source is not
        safe for concurrent use by multiple goroutines.
        The returned Source implements Source64.
    **/
    static public inline function newSource(_seed:haxe.Int64):Source {
        final _seed = (_seed : stdgo.GoInt64);
        return stdgo._internal.math.rand.Rand_newSource.newSource(_seed);
    }
    /**
        New returns a new Rand that uses random values from src
        to generate other random values.
    **/
    static public inline function new_(_src:Source):Rand_ {
        return stdgo._internal.math.rand.Rand_new_.new_(_src);
    }
    /**
        Seed uses the provided seed value to initialize the default Source to a
        deterministic state. Seed values that have the same remainder when
        divided by 2³¹-1 generate the same pseudo-random sequence.
        Seed, unlike the Rand.Seed method, is safe for concurrent use.
        
        If Seed is not called, the generator is seeded randomly at program startup.
        
        Prior to Go 1.20, the generator was seeded like Seed(1) at program startup.
        To force the old behavior, call Seed(1) at program startup.
        Alternately, set GODEBUG=randautoseed=0 in the environment
        before making any calls to functions in this package.
        
        Deprecated: As of Go 1.20 there is no reason to call Seed with
        a random value. Programs that call Seed with a known value to get
        a specific sequence of results should use New(NewSource(seed)) to
        obtain a local random generator.
    **/
    static public inline function seed(_seed:haxe.Int64):Void {
        final _seed = (_seed : stdgo.GoInt64);
        stdgo._internal.math.rand.Rand_seed.seed(_seed);
    }
    /**
        Int63 returns a non-negative pseudo-random 63-bit integer as an int64
        from the default Source.
    **/
    static public inline function int63():haxe.Int64 {
        return stdgo._internal.math.rand.Rand_int63.int63();
    }
    /**
        Uint32 returns a pseudo-random 32-bit value as a uint32
        from the default Source.
    **/
    static public inline function uint32():std.UInt {
        return stdgo._internal.math.rand.Rand_uint32.uint32();
    }
    /**
        Uint64 returns a pseudo-random 64-bit value as a uint64
        from the default Source.
    **/
    static public inline function uint64():haxe.UInt64 {
        return stdgo._internal.math.rand.Rand_uint64.uint64();
    }
    /**
        Int31 returns a non-negative pseudo-random 31-bit integer as an int32
        from the default Source.
    **/
    static public inline function int31():StdTypes.Int {
        return stdgo._internal.math.rand.Rand_int31.int31();
    }
    /**
        Int returns a non-negative pseudo-random int from the default Source.
    **/
    static public inline function int_():StdTypes.Int {
        return stdgo._internal.math.rand.Rand_int_.int_();
    }
    /**
        Int63n returns, as an int64, a non-negative pseudo-random number in the half-open interval [0,n)
        from the default Source.
        It panics if n <= 0.
    **/
    static public inline function int63n(_n:haxe.Int64):haxe.Int64 {
        final _n = (_n : stdgo.GoInt64);
        return stdgo._internal.math.rand.Rand_int63n.int63n(_n);
    }
    /**
        Int31n returns, as an int32, a non-negative pseudo-random number in the half-open interval [0,n)
        from the default Source.
        It panics if n <= 0.
    **/
    static public inline function int31n(_n:StdTypes.Int):StdTypes.Int {
        final _n = (_n : stdgo.GoInt32);
        return stdgo._internal.math.rand.Rand_int31n.int31n(_n);
    }
    /**
        Intn returns, as an int, a non-negative pseudo-random number in the half-open interval [0,n)
        from the default Source.
        It panics if n <= 0.
    **/
    static public inline function intn(_n:StdTypes.Int):StdTypes.Int {
        final _n = (_n : stdgo.GoInt);
        return stdgo._internal.math.rand.Rand_intn.intn(_n);
    }
    /**
        Float64 returns, as a float64, a pseudo-random number in the half-open interval [0.0,1.0)
        from the default Source.
    **/
    static public inline function float64():StdTypes.Float {
        return stdgo._internal.math.rand.Rand_float64.float64();
    }
    /**
        Float32 returns, as a float32, a pseudo-random number in the half-open interval [0.0,1.0)
        from the default Source.
    **/
    static public inline function float32():StdTypes.Float {
        return stdgo._internal.math.rand.Rand_float32.float32();
    }
    /**
        Perm returns, as a slice of n ints, a pseudo-random permutation of the integers
        in the half-open interval [0,n) from the default Source.
    **/
    static public inline function perm(_n:StdTypes.Int):Array<StdTypes.Int> {
        final _n = (_n : stdgo.GoInt);
        return [for (i in stdgo._internal.math.rand.Rand_perm.perm(_n)) i];
    }
    /**
        Shuffle pseudo-randomizes the order of elements using the default Source.
        n is the number of elements. Shuffle panics if n < 0.
        swap swaps the elements with indexes i and j.
    **/
    static public inline function shuffle(_n:StdTypes.Int, _swap:(stdgo.GoInt, stdgo.GoInt) -> Void):Void {
        final _n = (_n : stdgo.GoInt);
        final _swap = _swap;
        stdgo._internal.math.rand.Rand_shuffle.shuffle(_n, _swap);
    }
    /**
        Read generates len(p) random bytes from the default Source and
        writes them into p. It always returns len(p) and a nil error.
        Read, unlike the Rand.Read method, is safe for concurrent use.
        
        Deprecated: For almost all use cases, crypto/rand.Read is more appropriate.
    **/
    static public inline function read(_p:Array<std.UInt>):stdgo.Tuple<StdTypes.Int, stdgo.Error> {
        final _p = ([for (i in _p) (i : stdgo.GoUInt8)] : stdgo.Slice<stdgo.GoUInt8>);
        return {
            final obj = stdgo._internal.math.rand.Rand_read.read(_p);
            { _0 : obj._0, _1 : obj._1 };
        };
    }
    /**
        NormFloat64 returns a normally distributed float64 in the range
        [-math.MaxFloat64, +math.MaxFloat64] with
        standard normal distribution (mean = 0, stddev = 1)
        from the default Source.
        To produce a different normal distribution, callers can
        adjust the output using:
        
        	sample = NormFloat64() * desiredStdDev + desiredMean
    **/
    static public inline function normFloat64():StdTypes.Float {
        return stdgo._internal.math.rand.Rand_normFloat64.normFloat64();
    }
    /**
        ExpFloat64 returns an exponentially distributed float64 in the range
        (0, +math.MaxFloat64] with an exponential distribution whose rate parameter
        (lambda) is 1 and whose mean is 1/lambda (1) from the default Source.
        To produce a distribution with a different rate parameter,
        callers can adjust the output using:
        
        	sample = ExpFloat64() / desiredRateParameter
    **/
    static public inline function expFloat64():StdTypes.Float {
        return stdgo._internal.math.rand.Rand_expFloat64.expFloat64();
    }
    /**
        NewZipf returns a Zipf variate generator.
        The generator generates values k ∈ [0, imax]
        such that P(k) is proportional to (v + k) ** (-s).
        Requirements: s > 1 and v >= 1.
    **/
    static public inline function newZipf(_r:Rand_, _s:StdTypes.Float, _v:StdTypes.Float, _imax:haxe.UInt64):Zipf {
        final _r = (_r : stdgo.Ref<stdgo._internal.math.rand.Rand_Rand.Rand>);
        final _s = (_s : stdgo.GoFloat64);
        final _v = (_v : stdgo.GoFloat64);
        final _imax = (_imax : stdgo.GoUInt64);
        return stdgo._internal.math.rand.Rand_newZipf.newZipf(_r, _s, _v, _imax);
    }
}
