package stdgo.slices;
final n : haxe.UInt64 = stdgo._internal.slices.Slices_n.n;
@:structInit abstract T_myStruct(stdgo._internal.slices.Slices_T_myStruct.T_myStruct) from stdgo._internal.slices.Slices_T_myStruct.T_myStruct to stdgo._internal.slices.Slices_T_myStruct.T_myStruct {
    public var _a(get, set) : String;
    function get__a():String return this._a;
    function set__a(v:String):String {
        this._a = v;
        return v;
    }
    public var _b(get, set) : String;
    function get__b():String return this._b;
    function set__b(v:String):String {
        this._b = v;
        return v;
    }
    public var _c(get, set) : String;
    function get__c():String return this._c;
    function set__c(v:String):String {
        this._c = v;
        return v;
    }
    public var _d(get, set) : String;
    function get__d():String return this._d;
    function set__d(v:String):String {
        this._d = v;
        return v;
    }
    public var _n(get, set) : StdTypes.Int;
    function get__n():StdTypes.Int return this._n;
    function set__n(v:StdTypes.Int):StdTypes.Int {
        this._n = v;
        return v;
    }
    public function new(?_a:String, ?_b:String, ?_c:String, ?_d:String, ?_n:StdTypes.Int) this = new stdgo._internal.slices.Slices_T_myStruct.T_myStruct(_a, _b, _c, _d, _n);
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() return this.__copy__();
}
@:structInit abstract T_intPair(stdgo._internal.slices.Slices_T_intPair.T_intPair) from stdgo._internal.slices.Slices_T_intPair.T_intPair to stdgo._internal.slices.Slices_T_intPair.T_intPair {
    public var _a(get, set) : StdTypes.Int;
    function get__a():StdTypes.Int return this._a;
    function set__a(v:StdTypes.Int):StdTypes.Int {
        this._a = v;
        return v;
    }
    public var _b(get, set) : StdTypes.Int;
    function get__b():StdTypes.Int return this._b;
    function set__b(v:StdTypes.Int):StdTypes.Int {
        this._b = v;
        return v;
    }
    public function new(?_a:StdTypes.Int, ?_b:StdTypes.Int) this = new stdgo._internal.slices.Slices_T_intPair.T_intPair(_a, _b);
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() return this.__copy__();
}
@:structInit abstract S(stdgo._internal.slices.Slices_S.S) from stdgo._internal.slices.Slices_S.S to stdgo._internal.slices.Slices_S.S {
    public var _a(get, set) : StdTypes.Int;
    function get__a():StdTypes.Int return this._a;
    function set__a(v:StdTypes.Int):StdTypes.Int {
        this._a = v;
        return v;
    }
    public var _b(get, set) : String;
    function get__b():String return this._b;
    function set__b(v:String):String {
        this._b = v;
        return v;
    }
    public function new(?_a:StdTypes.Int, ?_b:String) this = new stdgo._internal.slices.Slices_S.S(_a, _b);
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() return this.__copy__();
}
typedef T__struct_0Pointer = stdgo._internal.slices.Slices_T__struct_0Pointer.T__struct_0Pointer;
class T__struct_0_static_extension {

}
typedef T__struct_0 = stdgo._internal.slices.Slices_T__struct_0.T__struct_0;
typedef T__struct_1Pointer = stdgo._internal.slices.Slices_T__struct_1Pointer.T__struct_1Pointer;
class T__struct_1_static_extension {

}
typedef T__struct_1 = stdgo._internal.slices.Slices_T__struct_1.T__struct_1;
typedef T__struct_2Pointer = stdgo._internal.slices.Slices_T__struct_2Pointer.T__struct_2Pointer;
class T__struct_2_static_extension {

}
typedef T__struct_2 = stdgo._internal.slices.Slices_T__struct_2.T__struct_2;
typedef T__struct_3Pointer = stdgo._internal.slices.Slices_T__struct_3Pointer.T__struct_3Pointer;
class T__struct_3_static_extension {

}
typedef T__struct_3 = stdgo._internal.slices.Slices_T__struct_3.T__struct_3;
typedef T__struct_4Pointer = stdgo._internal.slices.Slices_T__struct_4Pointer.T__struct_4Pointer;
class T__struct_4_static_extension {

}
typedef T__struct_4 = stdgo._internal.slices.Slices_T__struct_4.T__struct_4;
typedef T__struct_5Pointer = stdgo._internal.slices.Slices_T__struct_5Pointer.T__struct_5Pointer;
class T__struct_5_static_extension {

}
typedef T__struct_5 = stdgo._internal.slices.Slices_T__struct_5.T__struct_5;
typedef T__struct_6Pointer = stdgo._internal.slices.Slices_T__struct_6Pointer.T__struct_6Pointer;
class T__struct_6_static_extension {

}
typedef T__struct_6 = stdgo._internal.slices.Slices_T__struct_6.T__struct_6;
typedef T__struct_7Pointer = stdgo._internal.slices.Slices_T__struct_7Pointer.T__struct_7Pointer;
class T__struct_7_static_extension {

}
typedef T__struct_7 = stdgo._internal.slices.Slices_T__struct_7.T__struct_7;
typedef T__struct_8Pointer = stdgo._internal.slices.Slices_T__struct_8Pointer.T__struct_8Pointer;
class T__struct_8_static_extension {

}
typedef T__struct_8 = stdgo._internal.slices.Slices_T__struct_8.T__struct_8;
typedef T__struct_9Pointer = stdgo._internal.slices.Slices_T__struct_9Pointer.T__struct_9Pointer;
class T__struct_9_static_extension {

}
typedef T__struct_9 = stdgo._internal.slices.Slices_T__struct_9.T__struct_9;
typedef T__struct_10Pointer = stdgo._internal.slices.Slices_T__struct_10Pointer.T__struct_10Pointer;
class T__struct_10_static_extension {

}
typedef T__struct_10 = stdgo._internal.slices.Slices_T__struct_10.T__struct_10;
typedef T__struct_11Pointer = stdgo._internal.slices.Slices_T__struct_11Pointer.T__struct_11Pointer;
class T__struct_11_static_extension {

}
typedef T__struct_11 = stdgo._internal.slices.Slices_T__struct_11.T__struct_11;
typedef T__struct_12Pointer = stdgo._internal.slices.Slices_T__struct_12Pointer.T__struct_12Pointer;
class T__struct_12_static_extension {

}
typedef T__struct_12 = stdgo._internal.slices.Slices_T__struct_12.T__struct_12;
typedef T__struct_13Pointer = stdgo._internal.slices.Slices_T__struct_13Pointer.T__struct_13Pointer;
class T__struct_13_static_extension {

}
typedef T__struct_13 = stdgo._internal.slices.Slices_T__struct_13.T__struct_13;
typedef T__struct_14Pointer = stdgo._internal.slices.Slices_T__struct_14Pointer.T__struct_14Pointer;
class T__struct_14_static_extension {

}
typedef T__struct_14 = stdgo._internal.slices.Slices_T__struct_14.T__struct_14;
typedef T__struct_15Pointer = stdgo._internal.slices.Slices_T__struct_15Pointer.T__struct_15Pointer;
class T__struct_15_static_extension {

}
typedef T__struct_15 = stdgo._internal.slices.Slices_T__struct_15.T__struct_15;
typedef T__struct_16Pointer = stdgo._internal.slices.Slices_T__struct_16Pointer.T__struct_16Pointer;
class T__struct_16_static_extension {

}
typedef T__struct_16 = stdgo._internal.slices.Slices_T__struct_16.T__struct_16;
typedef T_sortedHint = stdgo._internal.slices.Slices_T_sortedHint.T_sortedHint;
typedef T_xorshift = stdgo._internal.slices.Slices_T_xorshift.T_xorshift;
typedef T_myStructs = stdgo._internal.slices.Slices_T_myStructs.T_myStructs;
typedef T_intPairs = stdgo._internal.slices.Slices_T_intPairs.T_intPairs;
typedef T_benchmarkEqualFunc_Large___localname___Large_2927 = stdgo._internal.slices.Slices_T_benchmarkEqualFunc_Large___localname___Large_2927.T_benchmarkEqualFunc_Large___localname___Large_2927;
typedef T_benchmarkIndex_Large___localname___Large_7963 = stdgo._internal.slices.Slices_T_benchmarkIndex_Large___localname___Large_7963.T_benchmarkIndex_Large___localname___Large_7963;
typedef T_benchmarkIndexFunc_Large___localname___Large_8766 = stdgo._internal.slices.Slices_T_benchmarkIndexFunc_Large___localname___Large_8766.T_benchmarkIndexFunc_Large___localname___Large_8766;
typedef T_benchmarkCompact_Large___localname___Large_15129 = stdgo._internal.slices.Slices_T_benchmarkCompact_Large___localname___Large_15129.T_benchmarkCompact_Large___localname___Large_15129;
typedef T_benchmarkCompactFunc_Large___localname___Large_15780 = stdgo._internal.slices.Slices_T_benchmarkCompactFunc_Large___localname___Large_15780.T_benchmarkCompactFunc_Large___localname___Large_15780;
typedef T_testInference___localname___S_22782 = stdgo._internal.slices.Slices_T_testInference___localname___S_22782.T_testInference___localname___S_22782;
typedef T_xorshiftPointer = stdgo._internal.slices.Slices_T_xorshiftPointer.T_xorshiftPointer;
class T_xorshift_static_extension {
    static public function next(_r:stdgo.Pointer<T_xorshift>):haxe.UInt64 {
        return stdgo._internal.slices.Slices_T_xorshift_static_extension.T_xorshift_static_extension.next(_r);
    }
}
typedef T_myStructsPointer = stdgo._internal.slices.Slices_T_myStructsPointer.T_myStructsPointer;
class T_myStructs_static_extension {
    static public function swap(_s:T_myStructs, _i:StdTypes.Int, _j:StdTypes.Int):Void {
        stdgo._internal.slices.Slices_T_myStructs_static_extension.T_myStructs_static_extension.swap(_s, _i, _j);
    }
    static public function less(_s:T_myStructs, _i:StdTypes.Int, _j:StdTypes.Int):Bool {
        return stdgo._internal.slices.Slices_T_myStructs_static_extension.T_myStructs_static_extension.less(_s, _i, _j);
    }
    static public function len(_s:T_myStructs):StdTypes.Int {
        return stdgo._internal.slices.Slices_T_myStructs_static_extension.T_myStructs_static_extension.len(_s);
    }
}
typedef T_intPairsPointer = stdgo._internal.slices.Slices_T_intPairsPointer.T_intPairsPointer;
class T_intPairs_static_extension {
    static public function _inOrder(_d:T_intPairs):Bool {
        return stdgo._internal.slices.Slices_T_intPairs_static_extension.T_intPairs_static_extension._inOrder(_d);
    }
    static public function _initB(_d:T_intPairs):Void {
        stdgo._internal.slices.Slices_T_intPairs_static_extension.T_intPairs_static_extension._initB(_d);
    }
}
/**
    Package slices defines various functions useful with slices of any type.
**/
class Slices {
    /**
        Equal reports whether two slices are equal: the same length and all
        elements equal. If the lengths are different, Equal returns false.
        Otherwise, the elements are compared in increasing index order, and the
        comparison stops at the first unequal pair.
        Floating point NaNs are not considered equal.
    **/
    static public function equal(_s1:Dynamic, _s2:Dynamic):Bool {
        return stdgo._internal.slices.Slices_equal.equal(_s1, _s2);
    }
    /**
        EqualFunc reports whether two slices are equal using an equality
        function on each pair of elements. If the lengths are different,
        EqualFunc returns false. Otherwise, the elements are compared in
        increasing index order, and the comparison stops at the first index
        for which eq returns false.
    **/
    static public function equalFunc(_s1:Dynamic, _s2:Dynamic, _eq:(Dynamic, Dynamic) -> Bool):Bool {
        final _eq = _eq;
        return stdgo._internal.slices.Slices_equalFunc.equalFunc(_s1, _s2, _eq);
    }
    /**
        Compare compares the elements of s1 and s2, using [cmp.Compare] on each pair
        of elements. The elements are compared sequentially, starting at index 0,
        until one element is not equal to the other.
        The result of comparing the first non-matching elements is returned.
        If both slices are equal until one of them ends, the shorter slice is
        considered less than the longer one.
        The result is 0 if s1 == s2, -1 if s1 < s2, and +1 if s1 > s2.
    **/
    static public function compare(_s1:Dynamic, _s2:Dynamic):StdTypes.Int {
        return stdgo._internal.slices.Slices_compare.compare(_s1, _s2);
    }
    /**
        CompareFunc is like [Compare] but uses a custom comparison function on each
        pair of elements.
        The result is the first non-zero result of cmp; if cmp always
        returns 0 the result is 0 if len(s1) == len(s2), -1 if len(s1) < len(s2),
        and +1 if len(s1) > len(s2).
    **/
    static public function compareFunc(_s1:Dynamic, _s2:Dynamic, _cmp:(Dynamic, Dynamic) -> stdgo.GoInt):StdTypes.Int {
        final _cmp = _cmp;
        return stdgo._internal.slices.Slices_compareFunc.compareFunc(_s1, _s2, _cmp);
    }
    /**
        Index returns the index of the first occurrence of v in s,
        or -1 if not present.
    **/
    static public function index(_s:Dynamic, _v:Dynamic):StdTypes.Int {
        return stdgo._internal.slices.Slices_index.index(_s, _v);
    }
    /**
        IndexFunc returns the first index i satisfying f(s[i]),
        or -1 if none do.
    **/
    static public function indexFunc(_s:Dynamic, _f:Dynamic -> Bool):StdTypes.Int {
        final _f = _f;
        return stdgo._internal.slices.Slices_indexFunc.indexFunc(_s, _f);
    }
    /**
        Contains reports whether v is present in s.
    **/
    static public function contains(_s:Dynamic, _v:Dynamic):Bool {
        return stdgo._internal.slices.Slices_contains.contains(_s, _v);
    }
    /**
        ContainsFunc reports whether at least one
        element e of s satisfies f(e).
    **/
    static public function containsFunc(_s:Dynamic, _f:Dynamic -> Bool):Bool {
        final _f = _f;
        return stdgo._internal.slices.Slices_containsFunc.containsFunc(_s, _f);
    }
    /**
        Insert inserts the values v... into s at index i,
        returning the modified slice.
        The elements at s[i:] are shifted up to make room.
        In the returned slice r, r[i] == v[0],
        and r[i+len(v)] == value originally at r[i].
        Insert panics if i is out of range.
        This function is O(len(s) + len(v)).
    **/
    static public function insert(_s:Dynamic, _i:StdTypes.Int, _v:haxe.Rest<Dynamic>):Dynamic {
        return stdgo._internal.slices.Slices_insert.insert(_s, _i, ...[for (i in _v) i]);
    }
    /**
        Delete removes the elements s[i:j] from s, returning the modified slice.
        Delete panics if s[i:j] is not a valid slice of s.
        Delete is O(len(s)-j), so if many items must be deleted, it is better to
        make a single call deleting them all together than to delete one at a time.
        Delete might not modify the elements s[len(s)-(j-i):len(s)]. If those
        elements contain pointers you might consider zeroing those elements so that
        objects they reference can be garbage collected.
    **/
    static public function delete(_s:Dynamic, _i:StdTypes.Int, _j:StdTypes.Int):Dynamic {
        return stdgo._internal.slices.Slices_delete.delete(_s, _i, _j);
    }
    /**
        DeleteFunc removes any elements from s for which del returns true,
        returning the modified slice.
        When DeleteFunc removes m elements, it might not modify the elements
        s[len(s)-m:len(s)]. If those elements contain pointers you might consider
        zeroing those elements so that objects they reference can be garbage
        collected.
    **/
    static public function deleteFunc(_s:Dynamic, _del:Dynamic -> Bool):Dynamic {
        final _del = _del;
        return stdgo._internal.slices.Slices_deleteFunc.deleteFunc(_s, _del);
    }
    /**
        Replace replaces the elements s[i:j] by the given v, and returns the
        modified slice. Replace panics if s[i:j] is not a valid slice of s.
    **/
    static public function replace(_s:Dynamic, _i:StdTypes.Int, _j:StdTypes.Int, _v:haxe.Rest<Dynamic>):Dynamic {
        return stdgo._internal.slices.Slices_replace.replace(_s, _i, _j, ...[for (i in _v) i]);
    }
    /**
        Clone returns a copy of the slice.
        The elements are copied using assignment, so this is a shallow clone.
    **/
    static public function clone(_s:Dynamic):Dynamic {
        return stdgo._internal.slices.Slices_clone.clone(_s);
    }
    /**
        Compact replaces consecutive runs of equal elements with a single copy.
        This is like the uniq command found on Unix.
        Compact modifies the contents of the slice s and returns the modified slice,
        which may have a smaller length.
        When Compact discards m elements in total, it might not modify the elements
        s[len(s)-m:len(s)]. If those elements contain pointers you might consider
        zeroing those elements so that objects they reference can be garbage collected.
    **/
    static public function compact(_s:Dynamic):Dynamic {
        return stdgo._internal.slices.Slices_compact.compact(_s);
    }
    /**
        CompactFunc is like [Compact] but uses an equality function to compare elements.
        For runs of elements that compare equal, CompactFunc keeps the first one.
    **/
    static public function compactFunc(_s:Dynamic, _eq:(Dynamic, Dynamic) -> Bool):Dynamic {
        final _eq = _eq;
        return stdgo._internal.slices.Slices_compactFunc.compactFunc(_s, _eq);
    }
    /**
        Grow increases the slice's capacity, if necessary, to guarantee space for
        another n elements. After Grow(n), at least n elements can be appended
        to the slice without another allocation. If n is negative or too large to
        allocate the memory, Grow panics.
    **/
    static public function grow(_s:Dynamic, _n:StdTypes.Int):Dynamic {
        return stdgo._internal.slices.Slices_grow.grow(_s, _n);
    }
    /**
        Clip removes unused capacity from the slice, returning s[:len(s):len(s)].
    **/
    static public function clip(_s:Dynamic):Dynamic {
        return stdgo._internal.slices.Slices_clip.clip(_s);
    }
    /**
        Reverse reverses the elements of the slice in place.
    **/
    static public function reverse(_s:Dynamic):Void {
        stdgo._internal.slices.Slices_reverse.reverse(_s);
    }
    static public function testEqual(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testEqual.testEqual(_t);
    }
    static public function testEqualFunc(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testEqualFunc.testEqualFunc(_t);
    }
    static public function benchmarkEqualFunc_Large(_b:stdgo._internal.testing.Testing_B.B):Void {
        stdgo._internal.slices.Slices_benchmarkEqualFunc_Large.benchmarkEqualFunc_Large(_b);
    }
    static public function testCompare(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testCompare.testCompare(_t);
    }
    static public function testCompareFunc(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testCompareFunc.testCompareFunc(_t);
    }
    static public function testIndex(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testIndex.testIndex(_t);
    }
    static public function benchmarkIndex_Large(_b:stdgo._internal.testing.Testing_B.B):Void {
        stdgo._internal.slices.Slices_benchmarkIndex_Large.benchmarkIndex_Large(_b);
    }
    static public function testIndexFunc(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testIndexFunc.testIndexFunc(_t);
    }
    static public function benchmarkIndexFunc_Large(_b:stdgo._internal.testing.Testing_B.B):Void {
        stdgo._internal.slices.Slices_benchmarkIndexFunc_Large.benchmarkIndexFunc_Large(_b);
    }
    static public function testContains(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testContains.testContains(_t);
    }
    static public function testContainsFunc(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testContainsFunc.testContainsFunc(_t);
    }
    static public function testInsert(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testInsert.testInsert(_t);
    }
    static public function testInsertOverlap(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testInsertOverlap.testInsertOverlap(_t);
    }
    static public function testDelete(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testDelete.testDelete(_t);
    }
    static public function testDeleteFunc(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testDeleteFunc.testDeleteFunc(_t);
    }
    static public function testDeletePanics(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testDeletePanics.testDeletePanics(_t);
    }
    static public function testClone(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testClone.testClone(_t);
    }
    static public function testCompact(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testCompact.testCompact(_t);
    }
    static public function benchmarkCompact(_b:stdgo._internal.testing.Testing_B.B):Void {
        stdgo._internal.slices.Slices_benchmarkCompact.benchmarkCompact(_b);
    }
    static public function benchmarkCompact_Large(_b:stdgo._internal.testing.Testing_B.B):Void {
        stdgo._internal.slices.Slices_benchmarkCompact_Large.benchmarkCompact_Large(_b);
    }
    static public function testCompactFunc(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testCompactFunc.testCompactFunc(_t);
    }
    static public function benchmarkCompactFunc_Large(_b:stdgo._internal.testing.Testing_B.B):Void {
        stdgo._internal.slices.Slices_benchmarkCompactFunc_Large.benchmarkCompactFunc_Large(_b);
    }
    static public function testGrow(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testGrow.testGrow(_t);
    }
    static public function testClip(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testClip.testClip(_t);
    }
    static public function testReverse(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testReverse.testReverse(_t);
    }
    static public function testReplace(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testReplace.testReplace(_t);
    }
    static public function testReplacePanics(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testReplacePanics.testReplacePanics(_t);
    }
    static public function testReplaceOverlap(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testReplaceOverlap.testReplaceOverlap(_t);
    }
    static public function benchmarkReplace(_b:stdgo._internal.testing.Testing_B.B):Void {
        stdgo._internal.slices.Slices_benchmarkReplace.benchmarkReplace(_b);
    }
    static public function testRotate(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testRotate.testRotate(_t);
    }
    static public function testInsertGrowthRate(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testInsertGrowthRate.testInsertGrowthRate(_t);
    }
    static public function testReplaceGrowthRate(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testReplaceGrowthRate.testReplaceGrowthRate(_t);
    }
    /**
        Test type inference with a named slice type.
    **/
    static public function testInference(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testInference.testInference(_t);
    }
    /**
        Sort sorts a slice of any ordered type in ascending order.
        When sorting floating-point numbers, NaNs are ordered before other values.
    **/
    static public function sort(_x:Dynamic):Void {
        stdgo._internal.slices.Slices_sort.sort(_x);
    }
    /**
        SortFunc sorts the slice x in ascending order as determined by the cmp
        function. This sort is not guaranteed to be stable.
        cmp(a, b) should return a negative number when a < b, a positive number when
        a > b and zero when a == b.
        
        SortFunc requires that cmp is a strict weak ordering.
        See https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings.
    **/
    static public function sortFunc(_x:Dynamic, _cmp:(Dynamic, Dynamic) -> stdgo.GoInt):Void {
        final _cmp = _cmp;
        stdgo._internal.slices.Slices_sortFunc.sortFunc(_x, _cmp);
    }
    /**
        SortStableFunc sorts the slice x while keeping the original order of equal
        elements, using cmp to compare elements in the same way as [SortFunc].
    **/
    static public function sortStableFunc(_x:Dynamic, _cmp:(Dynamic, Dynamic) -> stdgo.GoInt):Void {
        final _cmp = _cmp;
        stdgo._internal.slices.Slices_sortStableFunc.sortStableFunc(_x, _cmp);
    }
    /**
        IsSorted reports whether x is sorted in ascending order.
    **/
    static public function isSorted(_x:Dynamic):Bool {
        return stdgo._internal.slices.Slices_isSorted.isSorted(_x);
    }
    /**
        IsSortedFunc reports whether x is sorted in ascending order, with cmp as the
        comparison function as defined by [SortFunc].
    **/
    static public function isSortedFunc(_x:Dynamic, _cmp:(Dynamic, Dynamic) -> stdgo.GoInt):Bool {
        final _cmp = _cmp;
        return stdgo._internal.slices.Slices_isSortedFunc.isSortedFunc(_x, _cmp);
    }
    /**
        Min returns the minimal value in x. It panics if x is empty.
        For floating-point numbers, Min propagates NaNs (any NaN value in x
        forces the output to be NaN).
    **/
    static public function min(_x:Dynamic):Dynamic {
        return stdgo._internal.slices.Slices_min.min(_x);
    }
    /**
        MinFunc returns the minimal value in x, using cmp to compare elements.
        It panics if x is empty. If there is more than one minimal element
        according to the cmp function, MinFunc returns the first one.
    **/
    static public function minFunc(_x:Dynamic, _cmp:(Dynamic, Dynamic) -> stdgo.GoInt):Dynamic {
        final _cmp = _cmp;
        return stdgo._internal.slices.Slices_minFunc.minFunc(_x, _cmp);
    }
    /**
        Max returns the maximal value in x. It panics if x is empty.
        For floating-point E, Max propagates NaNs (any NaN value in x
        forces the output to be NaN).
    **/
    static public function max(_x:Dynamic):Dynamic {
        return stdgo._internal.slices.Slices_max.max(_x);
    }
    /**
        MaxFunc returns the maximal value in x, using cmp to compare elements.
        It panics if x is empty. If there is more than one maximal element
        according to the cmp function, MaxFunc returns the first one.
    **/
    static public function maxFunc(_x:Dynamic, _cmp:(Dynamic, Dynamic) -> stdgo.GoInt):Dynamic {
        final _cmp = _cmp;
        return stdgo._internal.slices.Slices_maxFunc.maxFunc(_x, _cmp);
    }
    /**
        BinarySearch searches for target in a sorted slice and returns the position
        where target is found, or the position where target would appear in the
        sort order; it also returns a bool saying whether the target is really found
        in the slice. The slice must be sorted in increasing order.
    **/
    static public function binarySearch(_x:Dynamic, _target:Dynamic):stdgo.Tuple<StdTypes.Int, Bool> {
        return {
            final obj = stdgo._internal.slices.Slices_binarySearch.binarySearch(_x, _target);
            { _0 : obj._0, _1 : obj._1 };
        };
    }
    /**
        BinarySearchFunc works like [BinarySearch], but uses a custom comparison
        function. The slice must be sorted in increasing order, where "increasing"
        is defined by cmp. cmp should return 0 if the slice element matches
        the target, a negative number if the slice element precedes the target,
        or a positive number if the slice element follows the target.
        cmp must implement the same ordering as the slice, such that if
        cmp(a, t) < 0 and cmp(b, t) >= 0, then a must precede b in the slice.
    **/
    static public function binarySearchFunc(_x:Dynamic, _target:Dynamic, _cmp:(Dynamic, Dynamic) -> stdgo.GoInt):stdgo.Tuple<StdTypes.Int, Bool> {
        final _cmp = _cmp;
        return {
            final obj = stdgo._internal.slices.Slices_binarySearchFunc.binarySearchFunc(_x, _target, _cmp);
            { _0 : obj._0, _1 : obj._1 };
        };
    }
    static public function benchmarkSortInts(_b:stdgo._internal.testing.Testing_B.B):Void {
        stdgo._internal.slices.Slices_benchmarkSortInts.benchmarkSortInts(_b);
    }
    static public function benchmarkSlicesSortInts(_b:stdgo._internal.testing.Testing_B.B):Void {
        stdgo._internal.slices.Slices_benchmarkSlicesSortInts.benchmarkSlicesSortInts(_b);
    }
    static public function benchmarkSlicesSortInts_Sorted(_b:stdgo._internal.testing.Testing_B.B):Void {
        stdgo._internal.slices.Slices_benchmarkSlicesSortInts_Sorted.benchmarkSlicesSortInts_Sorted(_b);
    }
    static public function benchmarkSlicesSortInts_Reversed(_b:stdgo._internal.testing.Testing_B.B):Void {
        stdgo._internal.slices.Slices_benchmarkSlicesSortInts_Reversed.benchmarkSlicesSortInts_Reversed(_b);
    }
    static public function benchmarkIntsAreSorted(_b:stdgo._internal.testing.Testing_B.B):Void {
        stdgo._internal.slices.Slices_benchmarkIntsAreSorted.benchmarkIntsAreSorted(_b);
    }
    static public function benchmarkIsSorted(_b:stdgo._internal.testing.Testing_B.B):Void {
        stdgo._internal.slices.Slices_benchmarkIsSorted.benchmarkIsSorted(_b);
    }
    /**
        Since we're benchmarking these sorts against each other, make sure that they
        generate similar results.
    **/
    static public function testIntSorts(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testIntSorts.testIntSorts(_t);
    }
    static public function testStringSorts(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testStringSorts.testStringSorts(_t);
    }
    static public function benchmarkSortStrings(_b:stdgo._internal.testing.Testing_B.B):Void {
        stdgo._internal.slices.Slices_benchmarkSortStrings.benchmarkSortStrings(_b);
    }
    static public function benchmarkSortStrings_Sorted(_b:stdgo._internal.testing.Testing_B.B):Void {
        stdgo._internal.slices.Slices_benchmarkSortStrings_Sorted.benchmarkSortStrings_Sorted(_b);
    }
    static public function benchmarkSlicesSortStrings(_b:stdgo._internal.testing.Testing_B.B):Void {
        stdgo._internal.slices.Slices_benchmarkSlicesSortStrings.benchmarkSlicesSortStrings(_b);
    }
    static public function benchmarkSlicesSortStrings_Sorted(_b:stdgo._internal.testing.Testing_B.B):Void {
        stdgo._internal.slices.Slices_benchmarkSlicesSortStrings_Sorted.benchmarkSlicesSortStrings_Sorted(_b);
    }
    static public function testStructSorts(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testStructSorts.testStructSorts(_t);
    }
    static public function benchmarkSortStructs(_b:stdgo._internal.testing.Testing_B.B):Void {
        stdgo._internal.slices.Slices_benchmarkSortStructs.benchmarkSortStructs(_b);
    }
    static public function benchmarkSortFuncStructs(_b:stdgo._internal.testing.Testing_B.B):Void {
        stdgo._internal.slices.Slices_benchmarkSortFuncStructs.benchmarkSortFuncStructs(_b);
    }
    static public function benchmarkBinarySearchFloats(_b:stdgo._internal.testing.Testing_B.B):Void {
        stdgo._internal.slices.Slices_benchmarkBinarySearchFloats.benchmarkBinarySearchFloats(_b);
    }
    static public function benchmarkBinarySearchFuncStruct(_b:stdgo._internal.testing.Testing_B.B):Void {
        stdgo._internal.slices.Slices_benchmarkBinarySearchFuncStruct.benchmarkBinarySearchFuncStruct(_b);
    }
    static public function testSortIntSlice(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testSortIntSlice.testSortIntSlice(_t);
    }
    static public function testSortFuncIntSlice(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testSortFuncIntSlice.testSortFuncIntSlice(_t);
    }
    static public function testSortFloat64Slice(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testSortFloat64Slice.testSortFloat64Slice(_t);
    }
    static public function testSortFloat64SliceWithNaNs(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testSortFloat64SliceWithNaNs.testSortFloat64SliceWithNaNs(_t);
    }
    static public function testSortStringSlice(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testSortStringSlice.testSortStringSlice(_t);
    }
    static public function testSortLarge_Random(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testSortLarge_Random.testSortLarge_Random(_t);
    }
    static public function testStability(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testStability.testStability(_t);
    }
    static public function testMinMax(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testMinMax.testMinMax(_t);
    }
    static public function testMinMaxNaNs(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testMinMaxNaNs.testMinMaxNaNs(_t);
    }
    static public function testMinMaxPanics(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testMinMaxPanics.testMinMaxPanics(_t);
    }
    static public function testBinarySearch(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testBinarySearch.testBinarySearch(_t);
    }
    static public function testBinarySearchInts(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testBinarySearchInts.testBinarySearchInts(_t);
    }
    static public function testBinarySearchFloats(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testBinarySearchFloats.testBinarySearchFloats(_t);
    }
    static public function testBinarySearchFunc(_t:stdgo._internal.testing.Testing_T_.T_):Void {
        stdgo._internal.slices.Slices_testBinarySearchFunc.testBinarySearchFunc(_t);
    }
}
