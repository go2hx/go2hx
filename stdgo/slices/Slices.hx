package stdgo.slices;
final n : haxe.UInt64 = stdgo._internal.slices.Slices.n;
@:structInit @:private abstract T_myStruct(stdgo._internal.slices.Slices.T_myStruct) from stdgo._internal.slices.Slices.T_myStruct to stdgo._internal.slices.Slices.T_myStruct {
    public var _a(get, set) : String;
    function get__a():String return this._a;
    function set__a(v:String):String {
        this._a = v;
        return v;
    }
    public var _b(get, set) : String;
    function get__b():String return this._b;
    function set__b(v:String):String {
        this._b = v;
        return v;
    }
    public var _c(get, set) : String;
    function get__c():String return this._c;
    function set__c(v:String):String {
        this._c = v;
        return v;
    }
    public var _d(get, set) : String;
    function get__d():String return this._d;
    function set__d(v:String):String {
        this._d = v;
        return v;
    }
    public var _n(get, set) : StdTypes.Int;
    function get__n():StdTypes.Int return this._n;
    function set__n(v:StdTypes.Int):StdTypes.Int {
        this._n = v;
        return v;
    }
    public function new(?_a:String, ?_b:String, ?_c:String, ?_d:String, ?_n:StdTypes.Int) this = new stdgo._internal.slices.Slices.T_myStruct(_a, _b, _c, _d, _n);
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() return this.__copy__();
}
@:structInit @:private abstract T_intPair(stdgo._internal.slices.Slices.T_intPair) from stdgo._internal.slices.Slices.T_intPair to stdgo._internal.slices.Slices.T_intPair {
    public var _a(get, set) : StdTypes.Int;
    function get__a():StdTypes.Int return this._a;
    function set__a(v:StdTypes.Int):StdTypes.Int {
        this._a = v;
        return v;
    }
    public var _b(get, set) : StdTypes.Int;
    function get__b():StdTypes.Int return this._b;
    function set__b(v:StdTypes.Int):StdTypes.Int {
        this._b = v;
        return v;
    }
    public function new(?_a:StdTypes.Int, ?_b:StdTypes.Int) this = new stdgo._internal.slices.Slices.T_intPair(_a, _b);
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() return this.__copy__();
}
@:structInit abstract S(stdgo._internal.slices.Slices.S) from stdgo._internal.slices.Slices.S to stdgo._internal.slices.Slices.S {
    public var _a(get, set) : StdTypes.Int;
    function get__a():StdTypes.Int return this._a;
    function set__a(v:StdTypes.Int):StdTypes.Int {
        this._a = v;
        return v;
    }
    public var _b(get, set) : String;
    function get__b():String return this._b;
    function set__b(v:String):String {
        this._b = v;
        return v;
    }
    public function new(?_a:StdTypes.Int, ?_b:String) this = new stdgo._internal.slices.Slices.S(_a, _b);
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() return this.__copy__();
}
class T__struct_0_static_extension {

}
typedef T__struct_0 = stdgo._internal.slices.Slices.T__struct_0;
class T__struct_1_static_extension {

}
typedef T__struct_1 = stdgo._internal.slices.Slices.T__struct_1;
class T__struct_2_static_extension {

}
typedef T__struct_2 = stdgo._internal.slices.Slices.T__struct_2;
class T__struct_3_static_extension {

}
typedef T__struct_3 = stdgo._internal.slices.Slices.T__struct_3;
class T__struct_4_static_extension {

}
typedef T__struct_4 = stdgo._internal.slices.Slices.T__struct_4;
class T__struct_5_static_extension {

}
typedef T__struct_5 = stdgo._internal.slices.Slices.T__struct_5;
class T__struct_6_static_extension {

}
typedef T__struct_6 = stdgo._internal.slices.Slices.T__struct_6;
class T__struct_7_static_extension {

}
typedef T__struct_7 = stdgo._internal.slices.Slices.T__struct_7;
class T__struct_8_static_extension {

}
typedef T__struct_8 = stdgo._internal.slices.Slices.T__struct_8;
class T__struct_9_static_extension {

}
typedef T__struct_9 = stdgo._internal.slices.Slices.T__struct_9;
class T__struct_10_static_extension {

}
typedef T__struct_10 = stdgo._internal.slices.Slices.T__struct_10;
class T__struct_11_static_extension {

}
typedef T__struct_11 = stdgo._internal.slices.Slices.T__struct_11;
class T__struct_12_static_extension {

}
typedef T__struct_12 = stdgo._internal.slices.Slices.T__struct_12;
class T__struct_13_static_extension {

}
typedef T__struct_13 = stdgo._internal.slices.Slices.T__struct_13;
class T__struct_14_static_extension {

}
typedef T__struct_14 = stdgo._internal.slices.Slices.T__struct_14;
class T__struct_15_static_extension {

}
typedef T__struct_15 = stdgo._internal.slices.Slices.T__struct_15;
class T__struct_16_static_extension {

}
typedef T__struct_16 = stdgo._internal.slices.Slices.T__struct_16;
typedef T_sortedHint = stdgo._internal.slices.Slices.T_sortedHint;
typedef T_xorshift = stdgo._internal.slices.Slices.T_xorshift;
typedef T_myStructs = stdgo._internal.slices.Slices.T_myStructs;
typedef T_intPairs = stdgo._internal.slices.Slices.T_intPairs;
typedef T_benchmarkEqualFunc_Large_23___localname___Large = stdgo._internal.slices.Slices.T_benchmarkEqualFunc_Large_23___localname___Large;
typedef T_benchmarkIndex_Large_24___localname___Large = stdgo._internal.slices.Slices.T_benchmarkIndex_Large_24___localname___Large;
typedef T_benchmarkIndexFunc_Large_25___localname___Large = stdgo._internal.slices.Slices.T_benchmarkIndexFunc_Large_25___localname___Large;
typedef T_benchmarkCompact_Large_26___localname___Large = stdgo._internal.slices.Slices.T_benchmarkCompact_Large_26___localname___Large;
typedef T_benchmarkCompactFunc_Large_27___localname___Large = stdgo._internal.slices.Slices.T_benchmarkCompactFunc_Large_27___localname___Large;
typedef T_testInference_28___localname___S = stdgo._internal.slices.Slices.T_testInference_28___localname___S;
class T_xorshift_static_extension {
    static public function next(___:T_xorshift, r:stdgo.Pointer<T_xorshift>):haxe.UInt64 {
        return stdgo._internal.slices.Slices.T_xorshift_static_extension.next(___, r);
    }
}
class T_myStructs_static_extension {
    static public function swap(s:T_myStructs, i:StdTypes.Int, j:StdTypes.Int):Void {
        stdgo._internal.slices.Slices.T_myStructs_static_extension.swap(s, i, j);
    }
    static public function less(s:T_myStructs, i:StdTypes.Int, j:StdTypes.Int):Bool {
        return stdgo._internal.slices.Slices.T_myStructs_static_extension.less(s, i, j);
    }
    static public function len(s:T_myStructs):StdTypes.Int {
        return stdgo._internal.slices.Slices.T_myStructs_static_extension.len(s);
    }
}
class T_intPairs_static_extension {
    static public function _inOrder(d:T_intPairs):Bool {
        return stdgo._internal.slices.Slices.T_intPairs_static_extension._inOrder(d);
    }
    static public function _initB(d:T_intPairs):Void {
        stdgo._internal.slices.Slices.T_intPairs_static_extension._initB(d);
    }
}
/**
    Package slices defines various functions useful with slices of any type.
**/
class Slices {
    static public function equal<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, s1:haxe.macro.Expr<S>, s2:haxe.macro.Expr<S>):haxe.macro.Expr<Bool> {
        return stdgo._internal.slices.Slices.equal(_generic__0, _generic__1, s1, s2);
    }
    static public function equalFunc<S1, S2, E1, E2>(_generic__0:haxe.macro.Expr<S1>, _generic__1:haxe.macro.Expr<S2>, _generic__2:haxe.macro.Expr<E1>, _generic__3:haxe.macro.Expr<E2>, s1:haxe.macro.Expr<S1>, s2:haxe.macro.Expr<S2>, eq:haxe.macro.Expr<($E1, $E2) -> Bool>):haxe.macro.Expr<Bool> {
        return stdgo._internal.slices.Slices.equalFunc(_generic__0, _generic__1, _generic__2, _generic__3, s1, s2, eq);
    }
    static public function compare<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, s1:haxe.macro.Expr<S>, s2:haxe.macro.Expr<S>):haxe.macro.Expr<StdTypes.Int> {
        return stdgo._internal.slices.Slices.compare(_generic__0, _generic__1, s1, s2);
    }
    static public function compareFunc<S1, S2, E1, E2>(_generic__0:haxe.macro.Expr<S1>, _generic__1:haxe.macro.Expr<S2>, _generic__2:haxe.macro.Expr<E1>, _generic__3:haxe.macro.Expr<E2>, s1:haxe.macro.Expr<S1>, s2:haxe.macro.Expr<S2>, cmp:haxe.macro.Expr<($E1, $E2) -> stdgo.GoInt>):haxe.macro.Expr<StdTypes.Int> {
        return stdgo._internal.slices.Slices.compareFunc(_generic__0, _generic__1, _generic__2, _generic__3, s1, s2, cmp);
    }
    static public function index<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, s:haxe.macro.Expr<S>, v:haxe.macro.Expr<E>):haxe.macro.Expr<StdTypes.Int> {
        return stdgo._internal.slices.Slices.index(_generic__0, _generic__1, s, v);
    }
    static public function indexFunc<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, s:haxe.macro.Expr<S>, f:haxe.macro.Expr<$E -> Bool>):haxe.macro.Expr<StdTypes.Int> {
        return stdgo._internal.slices.Slices.indexFunc(_generic__0, _generic__1, s, f);
    }
    static public function contains<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, s:haxe.macro.Expr<S>, v:haxe.macro.Expr<E>):haxe.macro.Expr<Bool> {
        return stdgo._internal.slices.Slices.contains(_generic__0, _generic__1, s, v);
    }
    static public function containsFunc<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, s:haxe.macro.Expr<S>, f:haxe.macro.Expr<$E -> Bool>):haxe.macro.Expr<Bool> {
        return stdgo._internal.slices.Slices.containsFunc(_generic__0, _generic__1, s, f);
    }
    static public function insert<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, s:haxe.macro.Expr<S>, i:haxe.macro.Expr<StdTypes.Int>, v:haxe.macro.Expr<haxe.Rest<E>>):haxe.macro.Expr<S> {
        return stdgo._internal.slices.Slices.insert(_generic__0, _generic__1, s, i, v);
    }
    static public function delete<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, s:haxe.macro.Expr<S>, i:haxe.macro.Expr<StdTypes.Int>, j:haxe.macro.Expr<StdTypes.Int>):haxe.macro.Expr<S> {
        return stdgo._internal.slices.Slices.delete(_generic__0, _generic__1, s, i, j);
    }
    static public function deleteFunc<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, s:haxe.macro.Expr<S>, del:haxe.macro.Expr<$E -> Bool>):haxe.macro.Expr<S> {
        return stdgo._internal.slices.Slices.deleteFunc(_generic__0, _generic__1, s, del);
    }
    static public function replace<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, s:haxe.macro.Expr<S>, i:haxe.macro.Expr<StdTypes.Int>, j:haxe.macro.Expr<StdTypes.Int>, v:haxe.macro.Expr<haxe.Rest<E>>):haxe.macro.Expr<S> {
        return stdgo._internal.slices.Slices.replace(_generic__0, _generic__1, s, i, j, v);
    }
    static public function clone<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, s:haxe.macro.Expr<S>):haxe.macro.Expr<S> {
        return stdgo._internal.slices.Slices.clone(_generic__0, _generic__1, s);
    }
    static public function compact<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, s:haxe.macro.Expr<S>):haxe.macro.Expr<S> {
        return stdgo._internal.slices.Slices.compact(_generic__0, _generic__1, s);
    }
    static public function compactFunc<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, s:haxe.macro.Expr<S>, eq:haxe.macro.Expr<($E, $E) -> Bool>):haxe.macro.Expr<S> {
        return stdgo._internal.slices.Slices.compactFunc(_generic__0, _generic__1, s, eq);
    }
    static public function grow<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, s:haxe.macro.Expr<S>, n:haxe.macro.Expr<StdTypes.Int>):haxe.macro.Expr<S> {
        return stdgo._internal.slices.Slices.grow(_generic__0, _generic__1, s, n);
    }
    static public function clip<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, s:haxe.macro.Expr<S>):haxe.macro.Expr<S> {
        return stdgo._internal.slices.Slices.clip(_generic__0, _generic__1, s);
    }
    static public function reverse<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, s:haxe.macro.Expr<S>):haxe.macro.Expr<Void> {
        return stdgo._internal.slices.Slices.reverse(_generic__0, _generic__1, s);
    }
    static public function testEqual(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testEqual(t);
    }
    static public function testEqualFunc(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testEqualFunc(t);
    }
    static public function benchmarkEqualFunc_Large(b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkEqualFunc_Large(b);
    }
    static public function testCompare(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testCompare(t);
    }
    static public function testCompareFunc(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testCompareFunc(t);
    }
    static public function testIndex(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testIndex(t);
    }
    static public function benchmarkIndex_Large(b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkIndex_Large(b);
    }
    static public function testIndexFunc(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testIndexFunc(t);
    }
    static public function benchmarkIndexFunc_Large(b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkIndexFunc_Large(b);
    }
    static public function testContains(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testContains(t);
    }
    static public function testContainsFunc(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testContainsFunc(t);
    }
    static public function testInsert(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testInsert(t);
    }
    static public function testInsertOverlap(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testInsertOverlap(t);
    }
    static public function testDelete(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testDelete(t);
    }
    static public function testDeleteFunc(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testDeleteFunc(t);
    }
    static public function testDeletePanics(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testDeletePanics(t);
    }
    static public function testClone(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testClone(t);
    }
    static public function testCompact(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testCompact(t);
    }
    static public function benchmarkCompact(b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkCompact(b);
    }
    static public function benchmarkCompact_Large(b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkCompact_Large(b);
    }
    static public function testCompactFunc(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testCompactFunc(t);
    }
    static public function benchmarkCompactFunc_Large(b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkCompactFunc_Large(b);
    }
    static public function testGrow(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testGrow(t);
    }
    static public function testClip(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testClip(t);
    }
    static public function testReverse(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testReverse(t);
    }
    static public function testReplace(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testReplace(t);
    }
    static public function testReplacePanics(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testReplacePanics(t);
    }
    static public function testReplaceOverlap(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testReplaceOverlap(t);
    }
    static public function benchmarkReplace(b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkReplace(b);
    }
    static public function testRotate(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testRotate(t);
    }
    static public function testInsertGrowthRate(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testInsertGrowthRate(t);
    }
    static public function testReplaceGrowthRate(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testReplaceGrowthRate(t);
    }
    /**
        Test type inference with a named slice type.
    **/
    static public function testInference(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testInference(t);
    }
    static public function sort<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, x:haxe.macro.Expr<S>):haxe.macro.Expr<Void> {
        return stdgo._internal.slices.Slices.sort(_generic__0, _generic__1, x);
    }
    static public function sortFunc<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, x:haxe.macro.Expr<S>, cmp:haxe.macro.Expr<(_a:E, _b:E) -> stdgo.GoInt>):haxe.macro.Expr<Void> {
        return stdgo._internal.slices.Slices.sortFunc(_generic__0, _generic__1, x, cmp);
    }
    static public function sortStableFunc<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, x:haxe.macro.Expr<S>, cmp:haxe.macro.Expr<(_a:E, _b:E) -> stdgo.GoInt>):haxe.macro.Expr<Void> {
        return stdgo._internal.slices.Slices.sortStableFunc(_generic__0, _generic__1, x, cmp);
    }
    static public function isSorted<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, x:haxe.macro.Expr<S>):haxe.macro.Expr<Bool> {
        return stdgo._internal.slices.Slices.isSorted(_generic__0, _generic__1, x);
    }
    static public function isSortedFunc<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, x:haxe.macro.Expr<S>, cmp:haxe.macro.Expr<(_a:E, _b:E) -> stdgo.GoInt>):haxe.macro.Expr<Bool> {
        return stdgo._internal.slices.Slices.isSortedFunc(_generic__0, _generic__1, x, cmp);
    }
    static public function min<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, x:haxe.macro.Expr<S>):haxe.macro.Expr<E> {
        return stdgo._internal.slices.Slices.min(_generic__0, _generic__1, x);
    }
    static public function minFunc<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, x:haxe.macro.Expr<S>, cmp:haxe.macro.Expr<(_a:E, _b:E) -> stdgo.GoInt>):haxe.macro.Expr<E> {
        return stdgo._internal.slices.Slices.minFunc(_generic__0, _generic__1, x, cmp);
    }
    static public function max<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, x:haxe.macro.Expr<S>):haxe.macro.Expr<E> {
        return stdgo._internal.slices.Slices.max(_generic__0, _generic__1, x);
    }
    static public function maxFunc<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, x:haxe.macro.Expr<S>, cmp:haxe.macro.Expr<(_a:E, _b:E) -> stdgo.GoInt>):haxe.macro.Expr<E> {
        return stdgo._internal.slices.Slices.maxFunc(_generic__0, _generic__1, x, cmp);
    }
    static public function binarySearch<S, E>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, x:haxe.macro.Expr<S>, target:haxe.macro.Expr<E>):haxe.macro.Expr<stdgo.Tuple<StdTypes.Int, Bool>> {
        return stdgo._internal.slices.Slices.binarySearch(_generic__0, _generic__1, x, target);
    }
    static public function binarySearchFunc<S, E, T_>(_generic__0:haxe.macro.Expr<S>, _generic__1:haxe.macro.Expr<E>, _generic__2:haxe.macro.Expr<T_>, x:haxe.macro.Expr<S>, target:haxe.macro.Expr<T_>, cmp:haxe.macro.Expr<($E, $T_) -> stdgo.GoInt>):haxe.macro.Expr<stdgo.Tuple<StdTypes.Int, Bool>> {
        return stdgo._internal.slices.Slices.binarySearchFunc(_generic__0, _generic__1, _generic__2, x, target, cmp);
    }
    static public function benchmarkSortInts(b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkSortInts(b);
    }
    static public function benchmarkSlicesSortInts(b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkSlicesSortInts(b);
    }
    static public function benchmarkSlicesSortInts_Sorted(b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkSlicesSortInts_Sorted(b);
    }
    static public function benchmarkSlicesSortInts_Reversed(b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkSlicesSortInts_Reversed(b);
    }
    static public function benchmarkIntsAreSorted(b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkIntsAreSorted(b);
    }
    static public function benchmarkIsSorted(b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkIsSorted(b);
    }
    /**
        Since we're benchmarking these sorts against each other, make sure that they
        generate similar results.
    **/
    static public function testIntSorts(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testIntSorts(t);
    }
    static public function testStringSorts(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testStringSorts(t);
    }
    static public function benchmarkSortStrings(b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkSortStrings(b);
    }
    static public function benchmarkSortStrings_Sorted(b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkSortStrings_Sorted(b);
    }
    static public function benchmarkSlicesSortStrings(b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkSlicesSortStrings(b);
    }
    static public function benchmarkSlicesSortStrings_Sorted(b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkSlicesSortStrings_Sorted(b);
    }
    static public function testStructSorts(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testStructSorts(t);
    }
    static public function benchmarkSortStructs(b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkSortStructs(b);
    }
    static public function benchmarkSortFuncStructs(b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkSortFuncStructs(b);
    }
    static public function benchmarkBinarySearchFloats(b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkBinarySearchFloats(b);
    }
    static public function benchmarkBinarySearchFuncStruct(b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkBinarySearchFuncStruct(b);
    }
    static public function testSortIntSlice(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testSortIntSlice(t);
    }
    static public function testSortFuncIntSlice(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testSortFuncIntSlice(t);
    }
    static public function testSortFloat64Slice(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testSortFloat64Slice(t);
    }
    static public function testSortFloat64SliceWithNaNs(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testSortFloat64SliceWithNaNs(t);
    }
    static public function testSortStringSlice(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testSortStringSlice(t);
    }
    static public function testSortLarge_Random(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testSortLarge_Random(t);
    }
    static public function testStability(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testStability(t);
    }
    static public function testMinMax(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testMinMax(t);
    }
    static public function testMinMaxNaNs(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testMinMaxNaNs(t);
    }
    static public function testMinMaxPanics(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testMinMaxPanics(t);
    }
    static public function testBinarySearch(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testBinarySearch(t);
    }
    static public function testBinarySearchInts(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testBinarySearchInts(t);
    }
    static public function testBinarySearchFloats(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testBinarySearchFloats(t);
    }
    static public function testBinarySearchFunc(t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testBinarySearchFunc(t);
    }
}
