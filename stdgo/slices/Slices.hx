package stdgo.slices;
final n : haxe.UInt64 = stdgo._internal.slices.Slices_n.n;
@:structInit @:using(stdgo.slices.Slices.T_myStruct_static_extension) @:dox(hide) abstract T_myStruct(stdgo._internal.slices.Slices_t_mystruct.T_myStruct) from stdgo._internal.slices.Slices_t_mystruct.T_myStruct to stdgo._internal.slices.Slices_t_mystruct.T_myStruct {
    public var _a(get, set) : String;
    function get__a():String return this._a;
    function set__a(v:String):String {
        this._a = (v : stdgo.GoString);
        return v;
    }
    public var _b(get, set) : String;
    function get__b():String return this._b;
    function set__b(v:String):String {
        this._b = (v : stdgo.GoString);
        return v;
    }
    public var _c(get, set) : String;
    function get__c():String return this._c;
    function set__c(v:String):String {
        this._c = (v : stdgo.GoString);
        return v;
    }
    public var _d(get, set) : String;
    function get__d():String return this._d;
    function set__d(v:String):String {
        this._d = (v : stdgo.GoString);
        return v;
    }
    public var _n(get, set) : StdTypes.Int;
    function get__n():StdTypes.Int return this._n;
    function set__n(v:StdTypes.Int):StdTypes.Int {
        this._n = (v : stdgo.GoInt);
        return v;
    }
    public function new(?_a:String, ?_b:String, ?_c:String, ?_d:String, ?_n:StdTypes.Int) this = new stdgo._internal.slices.Slices_t_mystruct.T_myStruct((_a : stdgo.GoString), (_b : stdgo.GoString), (_c : stdgo.GoString), (_d : stdgo.GoString), (_n : stdgo.GoInt));
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() return this.__copy__();
}
@:structInit @:using(stdgo.slices.Slices.T_intPair_static_extension) @:dox(hide) abstract T_intPair(stdgo._internal.slices.Slices_t_intpair.T_intPair) from stdgo._internal.slices.Slices_t_intpair.T_intPair to stdgo._internal.slices.Slices_t_intpair.T_intPair {
    public var _a(get, set) : StdTypes.Int;
    function get__a():StdTypes.Int return this._a;
    function set__a(v:StdTypes.Int):StdTypes.Int {
        this._a = (v : stdgo.GoInt);
        return v;
    }
    public var _b(get, set) : StdTypes.Int;
    function get__b():StdTypes.Int return this._b;
    function set__b(v:StdTypes.Int):StdTypes.Int {
        this._b = (v : stdgo.GoInt);
        return v;
    }
    public function new(?_a:StdTypes.Int, ?_b:StdTypes.Int) this = new stdgo._internal.slices.Slices_t_intpair.T_intPair((_a : stdgo.GoInt), (_b : stdgo.GoInt));
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() return this.__copy__();
}
@:structInit @:using(stdgo.slices.Slices.S_static_extension) abstract S(stdgo._internal.slices.Slices_s.S) from stdgo._internal.slices.Slices_s.S to stdgo._internal.slices.Slices_s.S {
    public var _a(get, set) : StdTypes.Int;
    function get__a():StdTypes.Int return this._a;
    function set__a(v:StdTypes.Int):StdTypes.Int {
        this._a = (v : stdgo.GoInt);
        return v;
    }
    public var _b(get, set) : String;
    function get__b():String return this._b;
    function set__b(v:String):String {
        this._b = (v : stdgo.GoString);
        return v;
    }
    public function new(?_a:StdTypes.Int, ?_b:String) this = new stdgo._internal.slices.Slices_s.S((_a : stdgo.GoInt), (_b : stdgo.GoString));
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() return this.__copy__();
}
@:dox(hide) typedef T__struct_0Pointer = stdgo._internal.slices.Slices_t__struct_0pointer.T__struct_0Pointer;
@:dox(hide) class T__struct_0_static_extension {

}
@:dox(hide) typedef T__struct_0 = stdgo._internal.slices.Slices_t__struct_0.T__struct_0;
@:dox(hide) typedef T__struct_1Pointer = stdgo._internal.slices.Slices_t__struct_1pointer.T__struct_1Pointer;
@:dox(hide) class T__struct_1_static_extension {

}
@:dox(hide) typedef T__struct_1 = stdgo._internal.slices.Slices_t__struct_1.T__struct_1;
@:dox(hide) typedef T__struct_2Pointer = stdgo._internal.slices.Slices_t__struct_2pointer.T__struct_2Pointer;
@:dox(hide) class T__struct_2_static_extension {

}
@:dox(hide) typedef T__struct_2 = stdgo._internal.slices.Slices_t__struct_2.T__struct_2;
@:dox(hide) typedef T__struct_3Pointer = stdgo._internal.slices.Slices_t__struct_3pointer.T__struct_3Pointer;
@:dox(hide) class T__struct_3_static_extension {

}
@:dox(hide) typedef T__struct_3 = stdgo._internal.slices.Slices_t__struct_3.T__struct_3;
@:dox(hide) typedef T__struct_4Pointer = stdgo._internal.slices.Slices_t__struct_4pointer.T__struct_4Pointer;
@:dox(hide) class T__struct_4_static_extension {

}
@:dox(hide) typedef T__struct_4 = stdgo._internal.slices.Slices_t__struct_4.T__struct_4;
@:dox(hide) typedef T__struct_5Pointer = stdgo._internal.slices.Slices_t__struct_5pointer.T__struct_5Pointer;
@:dox(hide) class T__struct_5_static_extension {

}
@:dox(hide) typedef T__struct_5 = stdgo._internal.slices.Slices_t__struct_5.T__struct_5;
@:dox(hide) typedef T__struct_6Pointer = stdgo._internal.slices.Slices_t__struct_6pointer.T__struct_6Pointer;
@:dox(hide) class T__struct_6_static_extension {

}
@:dox(hide) typedef T__struct_6 = stdgo._internal.slices.Slices_t__struct_6.T__struct_6;
@:dox(hide) typedef T__struct_7Pointer = stdgo._internal.slices.Slices_t__struct_7pointer.T__struct_7Pointer;
@:dox(hide) class T__struct_7_static_extension {

}
@:dox(hide) typedef T__struct_7 = stdgo._internal.slices.Slices_t__struct_7.T__struct_7;
@:dox(hide) typedef T__struct_8Pointer = stdgo._internal.slices.Slices_t__struct_8pointer.T__struct_8Pointer;
@:dox(hide) class T__struct_8_static_extension {

}
@:dox(hide) typedef T__struct_8 = stdgo._internal.slices.Slices_t__struct_8.T__struct_8;
@:dox(hide) typedef T__struct_9Pointer = stdgo._internal.slices.Slices_t__struct_9pointer.T__struct_9Pointer;
@:dox(hide) class T__struct_9_static_extension {

}
@:dox(hide) typedef T__struct_9 = stdgo._internal.slices.Slices_t__struct_9.T__struct_9;
@:dox(hide) typedef T__struct_10Pointer = stdgo._internal.slices.Slices_t__struct_10pointer.T__struct_10Pointer;
@:dox(hide) class T__struct_10_static_extension {

}
@:dox(hide) typedef T__struct_10 = stdgo._internal.slices.Slices_t__struct_10.T__struct_10;
@:dox(hide) typedef T__struct_11Pointer = stdgo._internal.slices.Slices_t__struct_11pointer.T__struct_11Pointer;
@:dox(hide) class T__struct_11_static_extension {

}
@:dox(hide) typedef T__struct_11 = stdgo._internal.slices.Slices_t__struct_11.T__struct_11;
@:dox(hide) typedef T__struct_12Pointer = stdgo._internal.slices.Slices_t__struct_12pointer.T__struct_12Pointer;
@:dox(hide) class T__struct_12_static_extension {

}
@:dox(hide) typedef T__struct_12 = stdgo._internal.slices.Slices_t__struct_12.T__struct_12;
@:dox(hide) typedef T__struct_13Pointer = stdgo._internal.slices.Slices_t__struct_13pointer.T__struct_13Pointer;
@:dox(hide) class T__struct_13_static_extension {

}
@:dox(hide) typedef T__struct_13 = stdgo._internal.slices.Slices_t__struct_13.T__struct_13;
@:dox(hide) typedef T__struct_14Pointer = stdgo._internal.slices.Slices_t__struct_14pointer.T__struct_14Pointer;
@:dox(hide) class T__struct_14_static_extension {

}
@:dox(hide) typedef T__struct_14 = stdgo._internal.slices.Slices_t__struct_14.T__struct_14;
@:dox(hide) typedef T__struct_15Pointer = stdgo._internal.slices.Slices_t__struct_15pointer.T__struct_15Pointer;
@:dox(hide) class T__struct_15_static_extension {

}
@:dox(hide) typedef T__struct_15 = stdgo._internal.slices.Slices_t__struct_15.T__struct_15;
@:dox(hide) typedef T__struct_16Pointer = stdgo._internal.slices.Slices_t__struct_16pointer.T__struct_16Pointer;
@:dox(hide) class T__struct_16_static_extension {

}
@:dox(hide) typedef T__struct_16 = stdgo._internal.slices.Slices_t__struct_16.T__struct_16;
@:dox(hide) typedef T_sortedHint = stdgo._internal.slices.Slices_t_sortedhint.T_sortedHint;
@:dox(hide) typedef T_xorshift = stdgo._internal.slices.Slices_t_xorshift.T_xorshift;
@:dox(hide) typedef T_myStructs = stdgo._internal.slices.Slices_t_mystructs.T_myStructs;
@:dox(hide) typedef T_intPairs = stdgo._internal.slices.Slices_t_intpairs.T_intPairs;
@:dox(hide) typedef T_benchmarkEqualFunc_Large___localname___Large_2927 = stdgo._internal.slices.Slices_t_benchmarkequalfunc_large___localname___large_2927.T_benchmarkEqualFunc_Large___localname___Large_2927;
@:dox(hide) typedef T_benchmarkIndex_Large___localname___Large_7963 = stdgo._internal.slices.Slices_t_benchmarkindex_large___localname___large_7963.T_benchmarkIndex_Large___localname___Large_7963;
@:dox(hide) typedef T_benchmarkIndexFunc_Large___localname___Large_8766 = stdgo._internal.slices.Slices_t_benchmarkindexfunc_large___localname___large_8766.T_benchmarkIndexFunc_Large___localname___Large_8766;
@:dox(hide) typedef T_benchmarkCompact_Large___localname___Large_15129 = stdgo._internal.slices.Slices_t_benchmarkcompact_large___localname___large_15129.T_benchmarkCompact_Large___localname___Large_15129;
@:dox(hide) typedef T_benchmarkCompactFunc_Large___localname___Large_15780 = stdgo._internal.slices.Slices_t_benchmarkcompactfunc_large___localname___large_15780.T_benchmarkCompactFunc_Large___localname___Large_15780;
@:dox(hide) typedef T_testInference___localname___S_22782 = stdgo._internal.slices.Slices_t_testinference___localname___s_22782.T_testInference___localname___S_22782;
@:dox(hide) typedef T_myStructPointer = stdgo._internal.slices.Slices_t_mystructpointer.T_myStructPointer;
@:dox(hide) class T_myStruct_static_extension {

}
@:dox(hide) typedef T_intPairPointer = stdgo._internal.slices.Slices_t_intpairpointer.T_intPairPointer;
@:dox(hide) class T_intPair_static_extension {

}
typedef SPointer = stdgo._internal.slices.Slices_spointer.SPointer;
class S_static_extension {

}
@:dox(hide) typedef T__struct_0PointerPointer = stdgo._internal.slices.Slices_t__struct_0pointerpointer.T__struct_0PointerPointer;
@:dox(hide) class T__struct_0Pointer_static_extension {

}
@:dox(hide) typedef T__struct_1PointerPointer = stdgo._internal.slices.Slices_t__struct_1pointerpointer.T__struct_1PointerPointer;
@:dox(hide) class T__struct_1Pointer_static_extension {

}
@:dox(hide) typedef T__struct_2PointerPointer = stdgo._internal.slices.Slices_t__struct_2pointerpointer.T__struct_2PointerPointer;
@:dox(hide) class T__struct_2Pointer_static_extension {

}
@:dox(hide) typedef T__struct_3PointerPointer = stdgo._internal.slices.Slices_t__struct_3pointerpointer.T__struct_3PointerPointer;
@:dox(hide) class T__struct_3Pointer_static_extension {

}
@:dox(hide) typedef T__struct_4PointerPointer = stdgo._internal.slices.Slices_t__struct_4pointerpointer.T__struct_4PointerPointer;
@:dox(hide) class T__struct_4Pointer_static_extension {

}
@:dox(hide) typedef T__struct_5PointerPointer = stdgo._internal.slices.Slices_t__struct_5pointerpointer.T__struct_5PointerPointer;
@:dox(hide) class T__struct_5Pointer_static_extension {

}
@:dox(hide) typedef T__struct_6PointerPointer = stdgo._internal.slices.Slices_t__struct_6pointerpointer.T__struct_6PointerPointer;
@:dox(hide) class T__struct_6Pointer_static_extension {

}
@:dox(hide) typedef T__struct_7PointerPointer = stdgo._internal.slices.Slices_t__struct_7pointerpointer.T__struct_7PointerPointer;
@:dox(hide) class T__struct_7Pointer_static_extension {

}
@:dox(hide) typedef T__struct_8PointerPointer = stdgo._internal.slices.Slices_t__struct_8pointerpointer.T__struct_8PointerPointer;
@:dox(hide) class T__struct_8Pointer_static_extension {

}
@:dox(hide) typedef T__struct_9PointerPointer = stdgo._internal.slices.Slices_t__struct_9pointerpointer.T__struct_9PointerPointer;
@:dox(hide) class T__struct_9Pointer_static_extension {

}
@:dox(hide) typedef T__struct_10PointerPointer = stdgo._internal.slices.Slices_t__struct_10pointerpointer.T__struct_10PointerPointer;
@:dox(hide) class T__struct_10Pointer_static_extension {

}
@:dox(hide) typedef T__struct_11PointerPointer = stdgo._internal.slices.Slices_t__struct_11pointerpointer.T__struct_11PointerPointer;
@:dox(hide) class T__struct_11Pointer_static_extension {

}
@:dox(hide) typedef T__struct_12PointerPointer = stdgo._internal.slices.Slices_t__struct_12pointerpointer.T__struct_12PointerPointer;
@:dox(hide) class T__struct_12Pointer_static_extension {

}
@:dox(hide) typedef T__struct_13PointerPointer = stdgo._internal.slices.Slices_t__struct_13pointerpointer.T__struct_13PointerPointer;
@:dox(hide) class T__struct_13Pointer_static_extension {

}
@:dox(hide) typedef T__struct_14PointerPointer = stdgo._internal.slices.Slices_t__struct_14pointerpointer.T__struct_14PointerPointer;
@:dox(hide) class T__struct_14Pointer_static_extension {

}
@:dox(hide) typedef T__struct_15PointerPointer = stdgo._internal.slices.Slices_t__struct_15pointerpointer.T__struct_15PointerPointer;
@:dox(hide) class T__struct_15Pointer_static_extension {

}
@:dox(hide) typedef T__struct_16PointerPointer = stdgo._internal.slices.Slices_t__struct_16pointerpointer.T__struct_16PointerPointer;
@:dox(hide) class T__struct_16Pointer_static_extension {

}
@:dox(hide) typedef T_sortedHintPointer = stdgo._internal.slices.Slices_t_sortedhintpointer.T_sortedHintPointer;
@:dox(hide) class T_sortedHint_static_extension {

}
@:dox(hide) typedef T_xorshiftPointer = stdgo._internal.slices.Slices_t_xorshiftpointer.T_xorshiftPointer;
@:dox(hide) class T_xorshift_static_extension {
    static public function next(_r:stdgo.Pointer<T_xorshift>):haxe.UInt64 {
        return stdgo._internal.slices.Slices_t_xorshift_static_extension.T_xorshift_static_extension.next(_r);
    }
}
@:dox(hide) typedef T_myStructsPointer = stdgo._internal.slices.Slices_t_mystructspointer.T_myStructsPointer;
@:dox(hide) class T_myStructs_static_extension {
    static public function swap(_s:T_myStructs, _i:StdTypes.Int, _j:StdTypes.Int):Void {
        final _i = (_i : stdgo.GoInt);
        final _j = (_j : stdgo.GoInt);
        stdgo._internal.slices.Slices_t_mystructs_static_extension.T_myStructs_static_extension.swap(_s, _i, _j);
    }
    static public function less(_s:T_myStructs, _i:StdTypes.Int, _j:StdTypes.Int):Bool {
        final _i = (_i : stdgo.GoInt);
        final _j = (_j : stdgo.GoInt);
        return stdgo._internal.slices.Slices_t_mystructs_static_extension.T_myStructs_static_extension.less(_s, _i, _j);
    }
    static public function len(_s:T_myStructs):StdTypes.Int {
        return stdgo._internal.slices.Slices_t_mystructs_static_extension.T_myStructs_static_extension.len(_s);
    }
}
@:dox(hide) typedef T_intPairsPointer = stdgo._internal.slices.Slices_t_intpairspointer.T_intPairsPointer;
@:dox(hide) class T_intPairs_static_extension {
    static public function _inOrder(_d:T_intPairs):Bool {
        return stdgo._internal.slices.Slices_t_intpairs_static_extension.T_intPairs_static_extension._inOrder(_d);
    }
    static public function _initB(_d:T_intPairs):Void {
        stdgo._internal.slices.Slices_t_intpairs_static_extension.T_intPairs_static_extension._initB(_d);
    }
}
@:dox(hide) typedef T_benchmarkEqualFunc_Large___localname___Large_2927Pointer = stdgo._internal.slices.Slices_t_benchmarkequalfunc_large___localname___large_2927pointer.T_benchmarkEqualFunc_Large___localname___Large_2927Pointer;
@:dox(hide) class T_benchmarkEqualFunc_Large___localname___Large_2927_static_extension {

}
@:dox(hide) typedef T_benchmarkIndex_Large___localname___Large_7963Pointer = stdgo._internal.slices.Slices_t_benchmarkindex_large___localname___large_7963pointer.T_benchmarkIndex_Large___localname___Large_7963Pointer;
@:dox(hide) class T_benchmarkIndex_Large___localname___Large_7963_static_extension {

}
@:dox(hide) typedef T_benchmarkIndexFunc_Large___localname___Large_8766Pointer = stdgo._internal.slices.Slices_t_benchmarkindexfunc_large___localname___large_8766pointer.T_benchmarkIndexFunc_Large___localname___Large_8766Pointer;
@:dox(hide) class T_benchmarkIndexFunc_Large___localname___Large_8766_static_extension {

}
@:dox(hide) typedef T_benchmarkCompact_Large___localname___Large_15129Pointer = stdgo._internal.slices.Slices_t_benchmarkcompact_large___localname___large_15129pointer.T_benchmarkCompact_Large___localname___Large_15129Pointer;
@:dox(hide) class T_benchmarkCompact_Large___localname___Large_15129_static_extension {

}
@:dox(hide) typedef T_benchmarkCompactFunc_Large___localname___Large_15780Pointer = stdgo._internal.slices.Slices_t_benchmarkcompactfunc_large___localname___large_15780pointer.T_benchmarkCompactFunc_Large___localname___Large_15780Pointer;
@:dox(hide) class T_benchmarkCompactFunc_Large___localname___Large_15780_static_extension {

}
@:dox(hide) typedef T_testInference___localname___S_22782Pointer = stdgo._internal.slices.Slices_t_testinference___localname___s_22782pointer.T_testInference___localname___S_22782Pointer;
@:dox(hide) class T_testInference___localname___S_22782_static_extension {

}
/**
    * Package slices defines various functions useful with slices of any type.
**/
class Slices {
    /**
        * Equal reports whether two slices are equal: the same length and all
        * elements equal. If the lengths are different, Equal returns false.
        * Otherwise, the elements are compared in increasing index order, and the
        * comparison stops at the first unequal pair.
        * Floating point NaNs are not considered equal.
    **/
    static public inline function equal(_s1:Dynamic, _s2:Dynamic):Bool {
        return stdgo._internal.slices.Slices_equal.equal(_s1, _s2);
    }
    /**
        * EqualFunc reports whether two slices are equal using an equality
        * function on each pair of elements. If the lengths are different,
        * EqualFunc returns false. Otherwise, the elements are compared in
        * increasing index order, and the comparison stops at the first index
        * for which eq returns false.
    **/
    static public inline function equalFunc(_s1:Dynamic, _s2:Dynamic, _eq:(Dynamic, Dynamic) -> Bool):Bool {
        final _eq = (_0, _1) -> _eq(_0, _1);
        return stdgo._internal.slices.Slices_equalfunc.equalFunc(_s1, _s2, _eq);
    }
    /**
        * Compare compares the elements of s1 and s2, using [cmp.Compare] on each pair
        * of elements. The elements are compared sequentially, starting at index 0,
        * until one element is not equal to the other.
        * The result of comparing the first non-matching elements is returned.
        * If both slices are equal until one of them ends, the shorter slice is
        * considered less than the longer one.
        * The result is 0 if s1 == s2, -1 if s1 < s2, and +1 if s1 > s2.
    **/
    static public inline function compare(_s1:Dynamic, _s2:Dynamic):StdTypes.Int {
        return stdgo._internal.slices.Slices_compare.compare(_s1, _s2);
    }
    /**
        * CompareFunc is like [Compare] but uses a custom comparison function on each
        * pair of elements.
        * The result is the first non-zero result of cmp; if cmp always
        * returns 0 the result is 0 if len(s1) == len(s2), -1 if len(s1) < len(s2),
        * and +1 if len(s1) > len(s2).
    **/
    static public inline function compareFunc(_s1:Dynamic, _s2:Dynamic, _cmp:(Dynamic, Dynamic) -> StdTypes.Int):StdTypes.Int {
        final _cmp = (_0, _1) -> _cmp(_0, _1);
        return stdgo._internal.slices.Slices_comparefunc.compareFunc(_s1, _s2, _cmp);
    }
    /**
        * Index returns the index of the first occurrence of v in s,
        * or -1 if not present.
    **/
    static public inline function index(_s:Dynamic, _v:Dynamic):StdTypes.Int {
        return stdgo._internal.slices.Slices_index.index(_s, _v);
    }
    /**
        * IndexFunc returns the first index i satisfying f(s[i]),
        * or -1 if none do.
    **/
    static public inline function indexFunc(_s:Dynamic, _f:Dynamic -> Bool):StdTypes.Int {
        final _f = _0 -> _f(_0);
        return stdgo._internal.slices.Slices_indexfunc.indexFunc(_s, _f);
    }
    /**
        * Contains reports whether v is present in s.
    **/
    static public inline function contains(_s:Dynamic, _v:Dynamic):Bool {
        return stdgo._internal.slices.Slices_contains.contains(_s, _v);
    }
    /**
        * ContainsFunc reports whether at least one
        * element e of s satisfies f(e).
    **/
    static public inline function containsFunc(_s:Dynamic, _f:Dynamic -> Bool):Bool {
        final _f = _0 -> _f(_0);
        return stdgo._internal.slices.Slices_containsfunc.containsFunc(_s, _f);
    }
    /**
        * Insert inserts the values v... into s at index i,
        * returning the modified slice.
        * The elements at s[i:] are shifted up to make room.
        * In the returned slice r, r[i] == v[0],
        * and r[i+len(v)] == value originally at r[i].
        * Insert panics if i is out of range.
        * This function is O(len(s) + len(v)).
    **/
    static public inline function insert(_s:Dynamic, _i:StdTypes.Int, _v:haxe.Rest<Dynamic>):Dynamic {
        final _i = (_i : stdgo.GoInt);
        return stdgo._internal.slices.Slices_insert.insert(_s, _i, ...[for (i in _v) i]);
    }
    /**
        * Delete removes the elements s[i:j] from s, returning the modified slice.
        * Delete panics if s[i:j] is not a valid slice of s.
        * Delete is O(len(s)-j), so if many items must be deleted, it is better to
        * make a single call deleting them all together than to delete one at a time.
        * Delete might not modify the elements s[len(s)-(j-i):len(s)]. If those
        * elements contain pointers you might consider zeroing those elements so that
        * objects they reference can be garbage collected.
    **/
    static public inline function delete(_s:Dynamic, _i:StdTypes.Int, _j:StdTypes.Int):Dynamic {
        final _i = (_i : stdgo.GoInt);
        final _j = (_j : stdgo.GoInt);
        return stdgo._internal.slices.Slices_delete.delete(_s, _i, _j);
    }
    /**
        * DeleteFunc removes any elements from s for which del returns true,
        * returning the modified slice.
        * When DeleteFunc removes m elements, it might not modify the elements
        * s[len(s)-m:len(s)]. If those elements contain pointers you might consider
        * zeroing those elements so that objects they reference can be garbage
        * collected.
    **/
    static public inline function deleteFunc(_s:Dynamic, _del:Dynamic -> Bool):Dynamic {
        final _del = _0 -> _del(_0);
        return stdgo._internal.slices.Slices_deletefunc.deleteFunc(_s, _del);
    }
    /**
        * Replace replaces the elements s[i:j] by the given v, and returns the
        * modified slice. Replace panics if s[i:j] is not a valid slice of s.
    **/
    static public inline function replace(_s:Dynamic, _i:StdTypes.Int, _j:StdTypes.Int, _v:haxe.Rest<Dynamic>):Dynamic {
        final _i = (_i : stdgo.GoInt);
        final _j = (_j : stdgo.GoInt);
        return stdgo._internal.slices.Slices_replace.replace(_s, _i, _j, ...[for (i in _v) i]);
    }
    /**
        * Clone returns a copy of the slice.
        * The elements are copied using assignment, so this is a shallow clone.
    **/
    static public inline function clone(_s:Dynamic):Dynamic {
        return stdgo._internal.slices.Slices_clone.clone(_s);
    }
    /**
        * Compact replaces consecutive runs of equal elements with a single copy.
        * This is like the uniq command found on Unix.
        * Compact modifies the contents of the slice s and returns the modified slice,
        * which may have a smaller length.
        * When Compact discards m elements in total, it might not modify the elements
        * s[len(s)-m:len(s)]. If those elements contain pointers you might consider
        * zeroing those elements so that objects they reference can be garbage collected.
    **/
    static public inline function compact(_s:Dynamic):Dynamic {
        return stdgo._internal.slices.Slices_compact.compact(_s);
    }
    /**
        * CompactFunc is like [Compact] but uses an equality function to compare elements.
        * For runs of elements that compare equal, CompactFunc keeps the first one.
    **/
    static public inline function compactFunc(_s:Dynamic, _eq:(Dynamic, Dynamic) -> Bool):Dynamic {
        final _eq = (_0, _1) -> _eq(_0, _1);
        return stdgo._internal.slices.Slices_compactfunc.compactFunc(_s, _eq);
    }
    /**
        * Grow increases the slice's capacity, if necessary, to guarantee space for
        * another n elements. After Grow(n), at least n elements can be appended
        * to the slice without another allocation. If n is negative or too large to
        * allocate the memory, Grow panics.
    **/
    static public inline function grow(_s:Dynamic, _n:StdTypes.Int):Dynamic {
        final _n = (_n : stdgo.GoInt);
        return stdgo._internal.slices.Slices_grow.grow(_s, _n);
    }
    /**
        * Clip removes unused capacity from the slice, returning s[:len(s):len(s)].
    **/
    static public inline function clip(_s:Dynamic):Dynamic {
        return stdgo._internal.slices.Slices_clip.clip(_s);
    }
    /**
        * Reverse reverses the elements of the slice in place.
    **/
    static public inline function reverse(_s:Dynamic):Void {
        stdgo._internal.slices.Slices_reverse.reverse(_s);
    }
    static public inline function testEqual(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testequal.testEqual(_t);
    }
    static public inline function testEqualFunc(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testequalfunc.testEqualFunc(_t);
    }
    static public inline function benchmarkEqualFunc_Large(_b:stdgo._internal.testing.Testing_b.B):Void {
        final _b = (_b : stdgo.Ref<stdgo._internal.testing.Testing_b.B>);
        stdgo._internal.slices.Slices_benchmarkequalfunc_large.benchmarkEqualFunc_Large(_b);
    }
    static public inline function testCompare(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testcompare.testCompare(_t);
    }
    static public inline function testCompareFunc(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testcomparefunc.testCompareFunc(_t);
    }
    static public inline function testIndex(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testindex.testIndex(_t);
    }
    static public inline function benchmarkIndex_Large(_b:stdgo._internal.testing.Testing_b.B):Void {
        final _b = (_b : stdgo.Ref<stdgo._internal.testing.Testing_b.B>);
        stdgo._internal.slices.Slices_benchmarkindex_large.benchmarkIndex_Large(_b);
    }
    static public inline function testIndexFunc(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testindexfunc.testIndexFunc(_t);
    }
    static public inline function benchmarkIndexFunc_Large(_b:stdgo._internal.testing.Testing_b.B):Void {
        final _b = (_b : stdgo.Ref<stdgo._internal.testing.Testing_b.B>);
        stdgo._internal.slices.Slices_benchmarkindexfunc_large.benchmarkIndexFunc_Large(_b);
    }
    static public inline function testContains(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testcontains.testContains(_t);
    }
    static public inline function testContainsFunc(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testcontainsfunc.testContainsFunc(_t);
    }
    static public inline function testInsert(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testinsert.testInsert(_t);
    }
    static public inline function testInsertOverlap(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testinsertoverlap.testInsertOverlap(_t);
    }
    static public inline function testDelete(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testdelete.testDelete(_t);
    }
    static public inline function testDeleteFunc(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testdeletefunc.testDeleteFunc(_t);
    }
    static public inline function testDeletePanics(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testdeletepanics.testDeletePanics(_t);
    }
    static public inline function testClone(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testclone.testClone(_t);
    }
    static public inline function testCompact(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testcompact.testCompact(_t);
    }
    static public inline function benchmarkCompact(_b:stdgo._internal.testing.Testing_b.B):Void {
        final _b = (_b : stdgo.Ref<stdgo._internal.testing.Testing_b.B>);
        stdgo._internal.slices.Slices_benchmarkcompact.benchmarkCompact(_b);
    }
    static public inline function benchmarkCompact_Large(_b:stdgo._internal.testing.Testing_b.B):Void {
        final _b = (_b : stdgo.Ref<stdgo._internal.testing.Testing_b.B>);
        stdgo._internal.slices.Slices_benchmarkcompact_large.benchmarkCompact_Large(_b);
    }
    static public inline function testCompactFunc(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testcompactfunc.testCompactFunc(_t);
    }
    static public inline function benchmarkCompactFunc_Large(_b:stdgo._internal.testing.Testing_b.B):Void {
        final _b = (_b : stdgo.Ref<stdgo._internal.testing.Testing_b.B>);
        stdgo._internal.slices.Slices_benchmarkcompactfunc_large.benchmarkCompactFunc_Large(_b);
    }
    static public inline function testGrow(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testgrow.testGrow(_t);
    }
    static public inline function testClip(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testclip.testClip(_t);
    }
    static public inline function testReverse(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testreverse.testReverse(_t);
    }
    static public inline function testReplace(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testreplace.testReplace(_t);
    }
    static public inline function testReplacePanics(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testreplacepanics.testReplacePanics(_t);
    }
    static public inline function testReplaceOverlap(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testreplaceoverlap.testReplaceOverlap(_t);
    }
    static public inline function benchmarkReplace(_b:stdgo._internal.testing.Testing_b.B):Void {
        final _b = (_b : stdgo.Ref<stdgo._internal.testing.Testing_b.B>);
        stdgo._internal.slices.Slices_benchmarkreplace.benchmarkReplace(_b);
    }
    static public inline function testRotate(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testrotate.testRotate(_t);
    }
    static public inline function testInsertGrowthRate(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testinsertgrowthrate.testInsertGrowthRate(_t);
    }
    static public inline function testReplaceGrowthRate(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testreplacegrowthrate.testReplaceGrowthRate(_t);
    }
    /**
        * Test type inference with a named slice type.
    **/
    static public inline function testInference(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testinference.testInference(_t);
    }
    /**
        * Sort sorts a slice of any ordered type in ascending order.
        * When sorting floating-point numbers, NaNs are ordered before other values.
    **/
    static public inline function sort(_x:Dynamic):Void {
        stdgo._internal.slices.Slices_sort.sort(_x);
    }
    /**
        * SortFunc sorts the slice x in ascending order as determined by the cmp
        * function. This sort is not guaranteed to be stable.
        * cmp(a, b) should return a negative number when a < b, a positive number when
        * a > b and zero when a == b.
        * 
        * SortFunc requires that cmp is a strict weak ordering.
        * See https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings.
    **/
    static public inline function sortFunc(_x:Dynamic, _cmp:(Dynamic, Dynamic) -> StdTypes.Int):Void {
        final _cmp = (_0, _1) -> _cmp(_0, _1);
        stdgo._internal.slices.Slices_sortfunc.sortFunc(_x, _cmp);
    }
    /**
        * SortStableFunc sorts the slice x while keeping the original order of equal
        * elements, using cmp to compare elements in the same way as [SortFunc].
    **/
    static public inline function sortStableFunc(_x:Dynamic, _cmp:(Dynamic, Dynamic) -> StdTypes.Int):Void {
        final _cmp = (_0, _1) -> _cmp(_0, _1);
        stdgo._internal.slices.Slices_sortstablefunc.sortStableFunc(_x, _cmp);
    }
    /**
        * IsSorted reports whether x is sorted in ascending order.
    **/
    static public inline function isSorted(_x:Dynamic):Bool {
        return stdgo._internal.slices.Slices_issorted.isSorted(_x);
    }
    /**
        * IsSortedFunc reports whether x is sorted in ascending order, with cmp as the
        * comparison function as defined by [SortFunc].
    **/
    static public inline function isSortedFunc(_x:Dynamic, _cmp:(Dynamic, Dynamic) -> StdTypes.Int):Bool {
        final _cmp = (_0, _1) -> _cmp(_0, _1);
        return stdgo._internal.slices.Slices_issortedfunc.isSortedFunc(_x, _cmp);
    }
    /**
        * Min returns the minimal value in x. It panics if x is empty.
        * For floating-point numbers, Min propagates NaNs (any NaN value in x
        * forces the output to be NaN).
    **/
    static public inline function min(_x:Dynamic):Dynamic {
        return stdgo._internal.slices.Slices_min.min(_x);
    }
    /**
        * MinFunc returns the minimal value in x, using cmp to compare elements.
        * It panics if x is empty. If there is more than one minimal element
        * according to the cmp function, MinFunc returns the first one.
    **/
    static public inline function minFunc(_x:Dynamic, _cmp:(Dynamic, Dynamic) -> StdTypes.Int):Dynamic {
        final _cmp = (_0, _1) -> _cmp(_0, _1);
        return stdgo._internal.slices.Slices_minfunc.minFunc(_x, _cmp);
    }
    /**
        * Max returns the maximal value in x. It panics if x is empty.
        * For floating-point E, Max propagates NaNs (any NaN value in x
        * forces the output to be NaN).
    **/
    static public inline function max(_x:Dynamic):Dynamic {
        return stdgo._internal.slices.Slices_max.max(_x);
    }
    /**
        * MaxFunc returns the maximal value in x, using cmp to compare elements.
        * It panics if x is empty. If there is more than one maximal element
        * according to the cmp function, MaxFunc returns the first one.
    **/
    static public inline function maxFunc(_x:Dynamic, _cmp:(Dynamic, Dynamic) -> StdTypes.Int):Dynamic {
        final _cmp = (_0, _1) -> _cmp(_0, _1);
        return stdgo._internal.slices.Slices_maxfunc.maxFunc(_x, _cmp);
    }
    /**
        * BinarySearch searches for target in a sorted slice and returns the position
        * where target is found, or the position where target would appear in the
        * sort order; it also returns a bool saying whether the target is really found
        * in the slice. The slice must be sorted in increasing order.
    **/
    static public inline function binarySearch(_x:Dynamic, _target:Dynamic):stdgo.Tuple<StdTypes.Int, Bool> {
        return {
            final obj = stdgo._internal.slices.Slices_binarysearch.binarySearch(_x, _target);
            { _0 : obj._0, _1 : obj._1 };
        };
    }
    /**
        * BinarySearchFunc works like [BinarySearch], but uses a custom comparison
        * function. The slice must be sorted in increasing order, where "increasing"
        * is defined by cmp. cmp should return 0 if the slice element matches
        * the target, a negative number if the slice element precedes the target,
        * or a positive number if the slice element follows the target.
        * cmp must implement the same ordering as the slice, such that if
        * cmp(a, t) < 0 and cmp(b, t) >= 0, then a must precede b in the slice.
    **/
    static public inline function binarySearchFunc(_x:Dynamic, _target:Dynamic, _cmp:(Dynamic, Dynamic) -> StdTypes.Int):stdgo.Tuple<StdTypes.Int, Bool> {
        final _cmp = (_0, _1) -> _cmp(_0, _1);
        return {
            final obj = stdgo._internal.slices.Slices_binarysearchfunc.binarySearchFunc(_x, _target, _cmp);
            { _0 : obj._0, _1 : obj._1 };
        };
    }
    static public inline function benchmarkSortInts(_b:stdgo._internal.testing.Testing_b.B):Void {
        final _b = (_b : stdgo.Ref<stdgo._internal.testing.Testing_b.B>);
        stdgo._internal.slices.Slices_benchmarksortints.benchmarkSortInts(_b);
    }
    static public inline function benchmarkSlicesSortInts(_b:stdgo._internal.testing.Testing_b.B):Void {
        final _b = (_b : stdgo.Ref<stdgo._internal.testing.Testing_b.B>);
        stdgo._internal.slices.Slices_benchmarkslicessortints.benchmarkSlicesSortInts(_b);
    }
    static public inline function benchmarkSlicesSortInts_Sorted(_b:stdgo._internal.testing.Testing_b.B):Void {
        final _b = (_b : stdgo.Ref<stdgo._internal.testing.Testing_b.B>);
        stdgo._internal.slices.Slices_benchmarkslicessortints_sorted.benchmarkSlicesSortInts_Sorted(_b);
    }
    static public inline function benchmarkSlicesSortInts_Reversed(_b:stdgo._internal.testing.Testing_b.B):Void {
        final _b = (_b : stdgo.Ref<stdgo._internal.testing.Testing_b.B>);
        stdgo._internal.slices.Slices_benchmarkslicessortints_reversed.benchmarkSlicesSortInts_Reversed(_b);
    }
    static public inline function benchmarkIntsAreSorted(_b:stdgo._internal.testing.Testing_b.B):Void {
        final _b = (_b : stdgo.Ref<stdgo._internal.testing.Testing_b.B>);
        stdgo._internal.slices.Slices_benchmarkintsaresorted.benchmarkIntsAreSorted(_b);
    }
    static public inline function benchmarkIsSorted(_b:stdgo._internal.testing.Testing_b.B):Void {
        final _b = (_b : stdgo.Ref<stdgo._internal.testing.Testing_b.B>);
        stdgo._internal.slices.Slices_benchmarkissorted.benchmarkIsSorted(_b);
    }
    /**
        * Since we're benchmarking these sorts against each other, make sure that they
        * generate similar results.
    **/
    static public inline function testIntSorts(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testintsorts.testIntSorts(_t);
    }
    static public inline function testStringSorts(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_teststringsorts.testStringSorts(_t);
    }
    static public inline function benchmarkSortStrings(_b:stdgo._internal.testing.Testing_b.B):Void {
        final _b = (_b : stdgo.Ref<stdgo._internal.testing.Testing_b.B>);
        stdgo._internal.slices.Slices_benchmarksortstrings.benchmarkSortStrings(_b);
    }
    static public inline function benchmarkSortStrings_Sorted(_b:stdgo._internal.testing.Testing_b.B):Void {
        final _b = (_b : stdgo.Ref<stdgo._internal.testing.Testing_b.B>);
        stdgo._internal.slices.Slices_benchmarksortstrings_sorted.benchmarkSortStrings_Sorted(_b);
    }
    static public inline function benchmarkSlicesSortStrings(_b:stdgo._internal.testing.Testing_b.B):Void {
        final _b = (_b : stdgo.Ref<stdgo._internal.testing.Testing_b.B>);
        stdgo._internal.slices.Slices_benchmarkslicessortstrings.benchmarkSlicesSortStrings(_b);
    }
    static public inline function benchmarkSlicesSortStrings_Sorted(_b:stdgo._internal.testing.Testing_b.B):Void {
        final _b = (_b : stdgo.Ref<stdgo._internal.testing.Testing_b.B>);
        stdgo._internal.slices.Slices_benchmarkslicessortstrings_sorted.benchmarkSlicesSortStrings_Sorted(_b);
    }
    static public inline function testStructSorts(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_teststructsorts.testStructSorts(_t);
    }
    static public inline function benchmarkSortStructs(_b:stdgo._internal.testing.Testing_b.B):Void {
        final _b = (_b : stdgo.Ref<stdgo._internal.testing.Testing_b.B>);
        stdgo._internal.slices.Slices_benchmarksortstructs.benchmarkSortStructs(_b);
    }
    static public inline function benchmarkSortFuncStructs(_b:stdgo._internal.testing.Testing_b.B):Void {
        final _b = (_b : stdgo.Ref<stdgo._internal.testing.Testing_b.B>);
        stdgo._internal.slices.Slices_benchmarksortfuncstructs.benchmarkSortFuncStructs(_b);
    }
    static public inline function benchmarkBinarySearchFloats(_b:stdgo._internal.testing.Testing_b.B):Void {
        final _b = (_b : stdgo.Ref<stdgo._internal.testing.Testing_b.B>);
        stdgo._internal.slices.Slices_benchmarkbinarysearchfloats.benchmarkBinarySearchFloats(_b);
    }
    static public inline function benchmarkBinarySearchFuncStruct(_b:stdgo._internal.testing.Testing_b.B):Void {
        final _b = (_b : stdgo.Ref<stdgo._internal.testing.Testing_b.B>);
        stdgo._internal.slices.Slices_benchmarkbinarysearchfuncstruct.benchmarkBinarySearchFuncStruct(_b);
    }
    static public inline function testSortIntSlice(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testsortintslice.testSortIntSlice(_t);
    }
    static public inline function testSortFuncIntSlice(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testsortfuncintslice.testSortFuncIntSlice(_t);
    }
    static public inline function testSortFloat64Slice(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testsortfloat64slice.testSortFloat64Slice(_t);
    }
    static public inline function testSortFloat64SliceWithNaNs(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testsortfloat64slicewithnans.testSortFloat64SliceWithNaNs(_t);
    }
    static public inline function testSortStringSlice(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testsortstringslice.testSortStringSlice(_t);
    }
    static public inline function testSortLarge_Random(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testsortlarge_random.testSortLarge_Random(_t);
    }
    static public inline function testStability(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_teststability.testStability(_t);
    }
    static public inline function testMinMax(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testminmax.testMinMax(_t);
    }
    static public inline function testMinMaxNaNs(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testminmaxnans.testMinMaxNaNs(_t);
    }
    static public inline function testMinMaxPanics(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testminmaxpanics.testMinMaxPanics(_t);
    }
    static public inline function testBinarySearch(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testbinarysearch.testBinarySearch(_t);
    }
    static public inline function testBinarySearchInts(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testbinarysearchints.testBinarySearchInts(_t);
    }
    static public inline function testBinarySearchFloats(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testbinarysearchfloats.testBinarySearchFloats(_t);
    }
    static public inline function testBinarySearchFunc(_t:stdgo._internal.testing.Testing_t_.T_):Void {
        final _t = (_t : stdgo.Ref<stdgo._internal.testing.Testing_t_.T_>);
        stdgo._internal.slices.Slices_testbinarysearchfunc.testBinarySearchFunc(_t);
    }
}
