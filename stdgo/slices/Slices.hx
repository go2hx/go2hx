package stdgo.slices;
final n : haxe.UInt64 = stdgo._internal.slices.Slices.n;
@:structInit @:private abstract T_myStruct(stdgo._internal.slices.Slices.T_myStruct) from stdgo._internal.slices.Slices.T_myStruct to stdgo._internal.slices.Slices.T_myStruct {
    public var _a(get, set) : String;
    function get__a():String return this._a;
    function set__a(v:String):String {
        this._a = v;
        return v;
    }
    public var _b(get, set) : String;
    function get__b():String return this._b;
    function set__b(v:String):String {
        this._b = v;
        return v;
    }
    public var _c(get, set) : String;
    function get__c():String return this._c;
    function set__c(v:String):String {
        this._c = v;
        return v;
    }
    public var _d(get, set) : String;
    function get__d():String return this._d;
    function set__d(v:String):String {
        this._d = v;
        return v;
    }
    public var _n(get, set) : StdTypes.Int;
    function get__n():StdTypes.Int return this._n;
    function set__n(v:StdTypes.Int):StdTypes.Int {
        this._n = v;
        return v;
    }
    public function new(?_a:String, ?_b:String, ?_c:String, ?_d:String, ?_n:StdTypes.Int) this = new stdgo._internal.slices.Slices.T_myStruct(_a, _b, _c, _d, _n);
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() return this.__copy__();
}
@:structInit @:private abstract T_intPair(stdgo._internal.slices.Slices.T_intPair) from stdgo._internal.slices.Slices.T_intPair to stdgo._internal.slices.Slices.T_intPair {
    public var _a(get, set) : StdTypes.Int;
    function get__a():StdTypes.Int return this._a;
    function set__a(v:StdTypes.Int):StdTypes.Int {
        this._a = v;
        return v;
    }
    public var _b(get, set) : StdTypes.Int;
    function get__b():StdTypes.Int return this._b;
    function set__b(v:StdTypes.Int):StdTypes.Int {
        this._b = v;
        return v;
    }
    public function new(?_a:StdTypes.Int, ?_b:StdTypes.Int) this = new stdgo._internal.slices.Slices.T_intPair(_a, _b);
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() return this.__copy__();
}
@:structInit abstract S(stdgo._internal.slices.Slices.S) from stdgo._internal.slices.Slices.S to stdgo._internal.slices.Slices.S {
    public var _a(get, set) : StdTypes.Int;
    function get__a():StdTypes.Int return this._a;
    function set__a(v:StdTypes.Int):StdTypes.Int {
        this._a = v;
        return v;
    }
    public var _b(get, set) : String;
    function get__b():String return this._b;
    function set__b(v:String):String {
        this._b = v;
        return v;
    }
    public function new(?_a:StdTypes.Int, ?_b:String) this = new stdgo._internal.slices.Slices.S(_a, _b);
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() return this.__copy__();
}
class T__struct_0_static_extension {

}
typedef T__struct_0 = stdgo._internal.slices.Slices.T__struct_0;
class T__struct_1_static_extension {

}
typedef T__struct_1 = stdgo._internal.slices.Slices.T__struct_1;
class T__struct_2_static_extension {

}
typedef T__struct_2 = stdgo._internal.slices.Slices.T__struct_2;
class T__struct_3_static_extension {

}
typedef T__struct_3 = stdgo._internal.slices.Slices.T__struct_3;
class T__struct_4_static_extension {

}
typedef T__struct_4 = stdgo._internal.slices.Slices.T__struct_4;
class T__struct_5_static_extension {

}
typedef T__struct_5 = stdgo._internal.slices.Slices.T__struct_5;
class T__struct_6_static_extension {

}
typedef T__struct_6 = stdgo._internal.slices.Slices.T__struct_6;
class T__struct_7_static_extension {

}
typedef T__struct_7 = stdgo._internal.slices.Slices.T__struct_7;
class T__struct_8_static_extension {

}
typedef T__struct_8 = stdgo._internal.slices.Slices.T__struct_8;
class T__struct_9_static_extension {

}
typedef T__struct_9 = stdgo._internal.slices.Slices.T__struct_9;
class T__struct_10_static_extension {

}
typedef T__struct_10 = stdgo._internal.slices.Slices.T__struct_10;
class T__struct_11_static_extension {

}
typedef T__struct_11 = stdgo._internal.slices.Slices.T__struct_11;
class T__struct_12_static_extension {

}
typedef T__struct_12 = stdgo._internal.slices.Slices.T__struct_12;
class T__struct_13_static_extension {

}
typedef T__struct_13 = stdgo._internal.slices.Slices.T__struct_13;
class T__struct_14_static_extension {

}
typedef T__struct_14 = stdgo._internal.slices.Slices.T__struct_14;
class T__struct_15_static_extension {

}
typedef T__struct_15 = stdgo._internal.slices.Slices.T__struct_15;
class T__struct_16_static_extension {

}
typedef T__struct_16 = stdgo._internal.slices.Slices.T__struct_16;
typedef T_sortedHint = stdgo._internal.slices.Slices.T_sortedHint;
typedef T_xorshift = stdgo._internal.slices.Slices.T_xorshift;
typedef T_myStructs = stdgo._internal.slices.Slices.T_myStructs;
typedef T_intPairs = stdgo._internal.slices.Slices.T_intPairs;
typedef T_benchmarkEqualFunc_Large___localname___Large_2927 = stdgo._internal.slices.Slices.T_benchmarkEqualFunc_Large___localname___Large_2927;
typedef T_benchmarkIndex_Large___localname___Large_7963 = stdgo._internal.slices.Slices.T_benchmarkIndex_Large___localname___Large_7963;
typedef T_benchmarkIndexFunc_Large___localname___Large_8766 = stdgo._internal.slices.Slices.T_benchmarkIndexFunc_Large___localname___Large_8766;
typedef T_benchmarkCompact_Large___localname___Large_15129 = stdgo._internal.slices.Slices.T_benchmarkCompact_Large___localname___Large_15129;
typedef T_benchmarkCompactFunc_Large___localname___Large_15780 = stdgo._internal.slices.Slices.T_benchmarkCompactFunc_Large___localname___Large_15780;
typedef T_testInference___localname___S_22782 = stdgo._internal.slices.Slices.T_testInference___localname___S_22782;
class T_xorshift_static_extension {
    static public function next(____:T_xorshift, _r:stdgo.Pointer<T_xorshift>):haxe.UInt64 {
        return stdgo._internal.slices.Slices.T_xorshift_static_extension.next(____, _r);
    }
}
class T_myStructs_static_extension {
    static public function swap(_s:T_myStructs, _i:StdTypes.Int, _j:StdTypes.Int):Void {
        stdgo._internal.slices.Slices.T_myStructs_static_extension.swap(_s, _i, _j);
    }
    static public function less(_s:T_myStructs, _i:StdTypes.Int, _j:StdTypes.Int):Bool {
        return stdgo._internal.slices.Slices.T_myStructs_static_extension.less(_s, _i, _j);
    }
    static public function len(_s:T_myStructs):StdTypes.Int {
        return stdgo._internal.slices.Slices.T_myStructs_static_extension.len(_s);
    }
}
class T_intPairs_static_extension {
    static public function _inOrder(_d:T_intPairs):Bool {
        return stdgo._internal.slices.Slices.T_intPairs_static_extension._inOrder(_d);
    }
    static public function _initB(_d:T_intPairs):Void {
        stdgo._internal.slices.Slices.T_intPairs_static_extension._initB(_d);
    }
}
/**
    Package slices defines various functions useful with slices of any type.
**/
class Slices {
    static public function equal<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _s1:haxe.macro.Expr<S>, _s2:haxe.macro.Expr<S>):haxe.macro.Expr<Bool> {
        return stdgo._internal.slices.Slices.equal(__generic__0, __generic__1, _s1, _s2);
    }
    static public function equalFunc<S1, S2, E1, E2>(__generic__0:haxe.macro.Expr<S1>, __generic__1:haxe.macro.Expr<S2>, __generic__2:haxe.macro.Expr<E1>, __generic__3:haxe.macro.Expr<E2>, _s1:haxe.macro.Expr<S1>, _s2:haxe.macro.Expr<S2>, _eq:haxe.macro.Expr<($E1, $E2) -> Bool>):haxe.macro.Expr<Bool> {
        return stdgo._internal.slices.Slices.equalFunc(__generic__0, __generic__1, __generic__2, __generic__3, _s1, _s2, _eq);
    }
    static public function compare<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _s1:haxe.macro.Expr<S>, _s2:haxe.macro.Expr<S>):haxe.macro.Expr<StdTypes.Int> {
        return stdgo._internal.slices.Slices.compare(__generic__0, __generic__1, _s1, _s2);
    }
    static public function compareFunc<S1, S2, E1, E2>(__generic__0:haxe.macro.Expr<S1>, __generic__1:haxe.macro.Expr<S2>, __generic__2:haxe.macro.Expr<E1>, __generic__3:haxe.macro.Expr<E2>, _s1:haxe.macro.Expr<S1>, _s2:haxe.macro.Expr<S2>, _cmp:haxe.macro.Expr<($E1, $E2) -> stdgo.GoInt>):haxe.macro.Expr<StdTypes.Int> {
        return stdgo._internal.slices.Slices.compareFunc(__generic__0, __generic__1, __generic__2, __generic__3, _s1, _s2, _cmp);
    }
    static public function index<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _s:haxe.macro.Expr<S>, _v:haxe.macro.Expr<E>):haxe.macro.Expr<StdTypes.Int> {
        return stdgo._internal.slices.Slices.index(__generic__0, __generic__1, _s, _v);
    }
    static public function indexFunc<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _s:haxe.macro.Expr<S>, _f:haxe.macro.Expr<$E -> Bool>):haxe.macro.Expr<StdTypes.Int> {
        return stdgo._internal.slices.Slices.indexFunc(__generic__0, __generic__1, _s, _f);
    }
    static public function contains<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _s:haxe.macro.Expr<S>, _v:haxe.macro.Expr<E>):haxe.macro.Expr<Bool> {
        return stdgo._internal.slices.Slices.contains(__generic__0, __generic__1, _s, _v);
    }
    static public function containsFunc<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _s:haxe.macro.Expr<S>, _f:haxe.macro.Expr<$E -> Bool>):haxe.macro.Expr<Bool> {
        return stdgo._internal.slices.Slices.containsFunc(__generic__0, __generic__1, _s, _f);
    }
    static public function insert<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _s:haxe.macro.Expr<S>, _i:haxe.macro.Expr<StdTypes.Int>, _v:haxe.macro.Expr<haxe.Rest<E>>):haxe.macro.Expr<S> {
        return stdgo._internal.slices.Slices.insert(__generic__0, __generic__1, _s, _i, _v);
    }
    static public function delete<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _s:haxe.macro.Expr<S>, _i:haxe.macro.Expr<StdTypes.Int>, _j:haxe.macro.Expr<StdTypes.Int>):haxe.macro.Expr<S> {
        return stdgo._internal.slices.Slices.delete(__generic__0, __generic__1, _s, _i, _j);
    }
    static public function deleteFunc<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _s:haxe.macro.Expr<S>, _del:haxe.macro.Expr<$E -> Bool>):haxe.macro.Expr<S> {
        return stdgo._internal.slices.Slices.deleteFunc(__generic__0, __generic__1, _s, _del);
    }
    static public function replace<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _s:haxe.macro.Expr<S>, _i:haxe.macro.Expr<StdTypes.Int>, _j:haxe.macro.Expr<StdTypes.Int>, _v:haxe.macro.Expr<haxe.Rest<E>>):haxe.macro.Expr<S> {
        return stdgo._internal.slices.Slices.replace(__generic__0, __generic__1, _s, _i, _j, _v);
    }
    static public function clone<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _s:haxe.macro.Expr<S>):haxe.macro.Expr<S> {
        return stdgo._internal.slices.Slices.clone(__generic__0, __generic__1, _s);
    }
    static public function compact<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _s:haxe.macro.Expr<S>):haxe.macro.Expr<S> {
        return stdgo._internal.slices.Slices.compact(__generic__0, __generic__1, _s);
    }
    static public function compactFunc<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _s:haxe.macro.Expr<S>, _eq:haxe.macro.Expr<($E, $E) -> Bool>):haxe.macro.Expr<S> {
        return stdgo._internal.slices.Slices.compactFunc(__generic__0, __generic__1, _s, _eq);
    }
    static public function grow<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _s:haxe.macro.Expr<S>, _n:haxe.macro.Expr<StdTypes.Int>):haxe.macro.Expr<S> {
        return stdgo._internal.slices.Slices.grow(__generic__0, __generic__1, _s, _n);
    }
    static public function clip<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _s:haxe.macro.Expr<S>):haxe.macro.Expr<S> {
        return stdgo._internal.slices.Slices.clip(__generic__0, __generic__1, _s);
    }
    static public function reverse<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _s:haxe.macro.Expr<S>):haxe.macro.Expr<Void> {
        return stdgo._internal.slices.Slices.reverse(__generic__0, __generic__1, _s);
    }
    static public function testEqual(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testEqual(_t);
    }
    static public function testEqualFunc(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testEqualFunc(_t);
    }
    static public function benchmarkEqualFunc_Large(_b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkEqualFunc_Large(_b);
    }
    static public function testCompare(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testCompare(_t);
    }
    static public function testCompareFunc(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testCompareFunc(_t);
    }
    static public function testIndex(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testIndex(_t);
    }
    static public function benchmarkIndex_Large(_b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkIndex_Large(_b);
    }
    static public function testIndexFunc(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testIndexFunc(_t);
    }
    static public function benchmarkIndexFunc_Large(_b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkIndexFunc_Large(_b);
    }
    static public function testContains(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testContains(_t);
    }
    static public function testContainsFunc(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testContainsFunc(_t);
    }
    static public function testInsert(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testInsert(_t);
    }
    static public function testInsertOverlap(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testInsertOverlap(_t);
    }
    static public function testDelete(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testDelete(_t);
    }
    static public function testDeleteFunc(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testDeleteFunc(_t);
    }
    static public function testDeletePanics(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testDeletePanics(_t);
    }
    static public function testClone(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testClone(_t);
    }
    static public function testCompact(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testCompact(_t);
    }
    static public function benchmarkCompact(_b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkCompact(_b);
    }
    static public function benchmarkCompact_Large(_b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkCompact_Large(_b);
    }
    static public function testCompactFunc(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testCompactFunc(_t);
    }
    static public function benchmarkCompactFunc_Large(_b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkCompactFunc_Large(_b);
    }
    static public function testGrow(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testGrow(_t);
    }
    static public function testClip(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testClip(_t);
    }
    static public function testReverse(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testReverse(_t);
    }
    static public function testReplace(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testReplace(_t);
    }
    static public function testReplacePanics(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testReplacePanics(_t);
    }
    static public function testReplaceOverlap(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testReplaceOverlap(_t);
    }
    static public function benchmarkReplace(_b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkReplace(_b);
    }
    static public function testRotate(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testRotate(_t);
    }
    static public function testInsertGrowthRate(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testInsertGrowthRate(_t);
    }
    static public function testReplaceGrowthRate(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testReplaceGrowthRate(_t);
    }
    /**
        Test type inference with a named slice type.
    **/
    static public function testInference(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testInference(_t);
    }
    static public function sort<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _x:haxe.macro.Expr<S>):haxe.macro.Expr<Void> {
        return stdgo._internal.slices.Slices.sort(__generic__0, __generic__1, _x);
    }
    static public function sortFunc<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _x:haxe.macro.Expr<S>, _cmp:haxe.macro.Expr<(_a:E, _b:E) -> stdgo.GoInt>):haxe.macro.Expr<Void> {
        return stdgo._internal.slices.Slices.sortFunc(__generic__0, __generic__1, _x, _cmp);
    }
    static public function sortStableFunc<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _x:haxe.macro.Expr<S>, _cmp:haxe.macro.Expr<(_a:E, _b:E) -> stdgo.GoInt>):haxe.macro.Expr<Void> {
        return stdgo._internal.slices.Slices.sortStableFunc(__generic__0, __generic__1, _x, _cmp);
    }
    static public function isSorted<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _x:haxe.macro.Expr<S>):haxe.macro.Expr<Bool> {
        return stdgo._internal.slices.Slices.isSorted(__generic__0, __generic__1, _x);
    }
    static public function isSortedFunc<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _x:haxe.macro.Expr<S>, _cmp:haxe.macro.Expr<(_a:E, _b:E) -> stdgo.GoInt>):haxe.macro.Expr<Bool> {
        return stdgo._internal.slices.Slices.isSortedFunc(__generic__0, __generic__1, _x, _cmp);
    }
    static public function min<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _x:haxe.macro.Expr<S>):haxe.macro.Expr<E> {
        return stdgo._internal.slices.Slices.min(__generic__0, __generic__1, _x);
    }
    static public function minFunc<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _x:haxe.macro.Expr<S>, _cmp:haxe.macro.Expr<(_a:E, _b:E) -> stdgo.GoInt>):haxe.macro.Expr<E> {
        return stdgo._internal.slices.Slices.minFunc(__generic__0, __generic__1, _x, _cmp);
    }
    static public function max<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _x:haxe.macro.Expr<S>):haxe.macro.Expr<E> {
        return stdgo._internal.slices.Slices.max(__generic__0, __generic__1, _x);
    }
    static public function maxFunc<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _x:haxe.macro.Expr<S>, _cmp:haxe.macro.Expr<(_a:E, _b:E) -> stdgo.GoInt>):haxe.macro.Expr<E> {
        return stdgo._internal.slices.Slices.maxFunc(__generic__0, __generic__1, _x, _cmp);
    }
    static public function binarySearch<S, E>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, _x:haxe.macro.Expr<S>, _target:haxe.macro.Expr<E>):haxe.macro.Expr<stdgo.Tuple<StdTypes.Int, Bool>> {
        return stdgo._internal.slices.Slices.binarySearch(__generic__0, __generic__1, _x, _target);
    }
    static public function binarySearchFunc<S, E, T_>(__generic__0:haxe.macro.Expr<S>, __generic__1:haxe.macro.Expr<E>, __generic__2:haxe.macro.Expr<T_>, _x:haxe.macro.Expr<S>, _target:haxe.macro.Expr<T_>, _cmp:haxe.macro.Expr<($E, $T_) -> stdgo.GoInt>):haxe.macro.Expr<stdgo.Tuple<StdTypes.Int, Bool>> {
        return stdgo._internal.slices.Slices.binarySearchFunc(__generic__0, __generic__1, __generic__2, _x, _target, _cmp);
    }
    static public function benchmarkSortInts(_b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkSortInts(_b);
    }
    static public function benchmarkSlicesSortInts(_b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkSlicesSortInts(_b);
    }
    static public function benchmarkSlicesSortInts_Sorted(_b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkSlicesSortInts_Sorted(_b);
    }
    static public function benchmarkSlicesSortInts_Reversed(_b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkSlicesSortInts_Reversed(_b);
    }
    static public function benchmarkIntsAreSorted(_b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkIntsAreSorted(_b);
    }
    static public function benchmarkIsSorted(_b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkIsSorted(_b);
    }
    /**
        Since we're benchmarking these sorts against each other, make sure that they
        generate similar results.
    **/
    static public function testIntSorts(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testIntSorts(_t);
    }
    static public function testStringSorts(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testStringSorts(_t);
    }
    static public function benchmarkSortStrings(_b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkSortStrings(_b);
    }
    static public function benchmarkSortStrings_Sorted(_b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkSortStrings_Sorted(_b);
    }
    static public function benchmarkSlicesSortStrings(_b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkSlicesSortStrings(_b);
    }
    static public function benchmarkSlicesSortStrings_Sorted(_b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkSlicesSortStrings_Sorted(_b);
    }
    static public function testStructSorts(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testStructSorts(_t);
    }
    static public function benchmarkSortStructs(_b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkSortStructs(_b);
    }
    static public function benchmarkSortFuncStructs(_b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkSortFuncStructs(_b);
    }
    static public function benchmarkBinarySearchFloats(_b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkBinarySearchFloats(_b);
    }
    static public function benchmarkBinarySearchFuncStruct(_b:stdgo._internal.testing.Testing.B):Void {
        stdgo._internal.slices.Slices.benchmarkBinarySearchFuncStruct(_b);
    }
    static public function testSortIntSlice(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testSortIntSlice(_t);
    }
    static public function testSortFuncIntSlice(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testSortFuncIntSlice(_t);
    }
    static public function testSortFloat64Slice(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testSortFloat64Slice(_t);
    }
    static public function testSortFloat64SliceWithNaNs(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testSortFloat64SliceWithNaNs(_t);
    }
    static public function testSortStringSlice(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testSortStringSlice(_t);
    }
    static public function testSortLarge_Random(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testSortLarge_Random(_t);
    }
    static public function testStability(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testStability(_t);
    }
    static public function testMinMax(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testMinMax(_t);
    }
    static public function testMinMaxNaNs(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testMinMaxNaNs(_t);
    }
    static public function testMinMaxPanics(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testMinMaxPanics(_t);
    }
    static public function testBinarySearch(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testBinarySearch(_t);
    }
    static public function testBinarySearchInts(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testBinarySearchInts(_t);
    }
    static public function testBinarySearchFloats(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testBinarySearchFloats(_t);
    }
    static public function testBinarySearchFunc(_t:stdgo._internal.testing.Testing.T_):Void {
        stdgo._internal.slices.Slices.testBinarySearchFunc(_t);
    }
}
