# Module: `stdgo.time`

[(view library index)](../stdgo.md)


# Overview



Package time provides functionality for measuring and displaying time.  


The calendrical calculations always assume a Gregorian calendar, with
no leap seconds.  

## Monotonic Clocks



Operating systems provide both a “wall clock,” which is subject to
changes for clock synchronization, and a “monotonic clock,” which is
not. The general rule is that the wall clock is for telling time and
the monotonic clock is for measuring time. Rather than split the API,
in this package the Time returned by time.Now contains both a wall
clock reading and a monotonic clock reading; later time\-telling
operations use the wall clock reading, but later time\-measuring
operations, specifically comparisons and subtractions, use the
monotonic clock reading.  


For example, this code always computes a positive elapsed time of
approximately 20 milliseconds, even if the wall clock is changed during
the operation being timed:  

```
    	start := time.Now()
    	... operation that takes 20 milliseconds ...
    	t := time.Now()
    	elapsed := t.Sub(start)
```

Other idioms, such as time.Since\(start\), time.Until\(deadline\), and
time.Now\(\).Before\(deadline\), are similarly robust against wall clock
resets.  


The rest of this section gives the precise details of how operations
use monotonic clocks, but understanding those details is not required
to use this package.  


The Time returned by time.Now contains a monotonic clock reading.
If Time t has a monotonic clock reading, t.Add adds the same duration to
both the wall clock and monotonic clock readings to compute the result.
Because t.AddDate\(y, m, d\), t.Round\(d\), and t.Truncate\(d\) are wall time
computations, they always strip any monotonic clock reading from their results.
Because t.In, t.Local, and t.UTC are used for their effect on the interpretation
of the wall time, they also strip any monotonic clock reading from their results.
The canonical way to strip a monotonic clock reading is to use t = t.Round\(0\).  


If Times t and u both contain monotonic clock readings, the operations
t.After\(u\), t.Before\(u\), t.Equal\(u\), t.Compare\(u\), and t.Sub\(u\) are carried out
using the monotonic clock readings alone, ignoring the wall clock
readings. If either t or u contains no monotonic clock reading, these
operations fall back to using the wall clock readings.  


On some systems the monotonic clock will stop if the computer goes to sleep.
On such a system, t.Sub\(u\) may not accurately reflect the actual
time that passed between t and u.  


Because the monotonic clock reading has no meaning outside
the current process, the serialized forms generated by t.GobEncode,
t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic
clock reading, and t.Format provides no format for it. Similarly, the
constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix,
as well as the unmarshalers t.GobDecode, t.UnmarshalBinary.
t.UnmarshalJSON, and t.UnmarshalText always create times with
no monotonic clock reading.  


The monotonic clock reading exists only in Time values. It is not
a part of Duration values or the Unix times returned by t.Unix and
friends.  


Note that the Go == operator compares not just the time instant but
also the Location and the monotonic clock reading. See the
documentation for the Time type for a discussion of equality
testing for Time values.  


For debugging, the result of t.String does include the monotonic
clock reading if present. If t \!= u because of different monotonic clock readings,
that difference will be visible when printing t.String\(\) and u.String\(\).  

# Index


- [Constants](<#constants>)

- [Variables](<#variables>)

- [`function after(d:stdgo.time.Duration):stdgo.Chan<stdgo.time.Time>`](<#function-after>)

- [`function afterFunc(d:stdgo.time.Duration, f:():Void):stdgo.time.Timer`](<#function-afterfunc>)

- [`function appendFormatAny(:stdgo._internal.time.Time, :stdgo.Slice<stdgo.GoUInt8>, :stdgo.GoString):stdgo.Slice<stdgo.GoUInt8>`](<#function-appendformatany>)

- [`function appendFormatRFC3339(:stdgo._internal.time.Time, :stdgo.Slice<stdgo.GoUInt8>, :Bool):stdgo.Slice<stdgo.GoUInt8>`](<#function-appendformatrfc3339>)

- [`function appendInt(:stdgo.Slice<stdgo.GoUInt8>, :stdgo.GoInt, :stdgo.GoInt):stdgo.Slice<stdgo.GoUInt8>`](<#function-appendint>)

- [`function checkRuntimeTimerPeriodOverflow():Void`](<#function-checkruntimetimerperiodoverflow>)

- [`function date(year:Int, month:stdgo.time.Month, day:Int, hour:Int, min:Int, sec:Int, nsec:Int, loc:stdgo.time.Location):stdgo.time.Time`](<#function-date>)

- [`function daysIn(:stdgo._internal.time.Month, :stdgo.GoInt):stdgo.GoInt`](<#function-daysin>)

- [`function disablePlatformSources():():Void`](<#function-disableplatformsources>)

- [`function fixedZone(name:String, offset:Int):stdgo.time.Location`](<#function-fixedzone>)

- [`function forceUSPacificForTesting():Void`](<#function-forceuspacificfortesting>)

- [`function getMono()`](<#function-getmono>)

- [`function get_appendFormatAny():(:stdgo._internal.time.Time, :stdgo.Slice<stdgo.GoUInt8>, :stdgo.GoString):stdgo.Slice<stdgo.GoUInt8>`](<#function-get_appendformatany>)

- [`function get_appendFormatRFC3339():(:stdgo._internal.time.Time, :stdgo.Slice<stdgo.GoUInt8>, :Bool):stdgo.Slice<stdgo.GoUInt8>`](<#function-get_appendformatrfc3339>)

- [`function get_appendInt():(:stdgo.Slice<stdgo.GoUInt8>, :stdgo.GoInt, :stdgo.GoInt):stdgo.Slice<stdgo.GoUInt8>`](<#function-get_appendint>)

- [`function get_daysIn():(:stdgo._internal.time.Month, :stdgo.GoInt):stdgo.GoInt`](<#function-get_daysin>)

- [`function get_disablePlatformSources():():():Void`](<#function-get_disableplatformsources>)

- [`function get_errLocation():stdgo.Error`](<#function-get_errlocation>)

- [`function get_getMono():()`](<#function-get_getmono>)

- [`function get_gorootZoneSource():()`](<#function-get_gorootzonesource>)

- [`function get_interrupt():():Void`](<#function-get_interrupt>)

- [`function get_loadTzinfo():(:stdgo.GoString, :stdgo.GoString):{
	_1:stdgo.Error;
	_0:stdgo.Slice<stdgo.GoUInt8>;
}`](<#function-get_loadtzinfo>)

- [`function get_local():stdgo._internal.time.Location`](<#function-get_local>)

- [`function get_maxMonoTime():stdgo._internal.time.Time`](<#function-get_maxmonotime>)

- [`function get_minMonoTime():stdgo._internal.time.Time`](<#function-get_minmonotime>)

- [`function get_nextStdChunk():()`](<#function-get_nextstdchunk>)

- [`function get_notMonoNegativeTime():stdgo._internal.time.Time`](<#function-get_notmononegativetime>)

- [`function get_parseAny():(:stdgo.GoString, :stdgo.GoString, :stdgo.Ref<stdgo._internal.time.Location>, :stdgo.Ref<stdgo._internal.time.Location>):{
	_1:stdgo.Error;
	_0:stdgo._internal.time.Time;
}`](<#function-get_parseany>)

- [`function get_parseRFC3339():(:stdgo.GoString, :stdgo.Ref<stdgo._internal.time.Location>):{
	_1:Bool;
	_0:stdgo._internal.time.Time;
}`](<#function-get_parserfc3339>)

- [`function get_parseTimeZone():()`](<#function-get_parsetimezone>)

- [`function get_quote():()`](<#function-get_quote>)

- [`function get_readFile():()`](<#function-get_readfile>)

- [`function get_setMono():(:stdgo.Ref<stdgo._internal.time.Time>, :stdgo.GoInt64):Void`](<#function-get_setmono>)

- [`function get_stdChunkNames():stdgo.GoMap<stdgo.GoInt, stdgo.GoString>`](<#function-get_stdchunknames>)

- [`function get_tzset():(:stdgo.GoString, :stdgo.GoInt64, :stdgo.GoInt64):{
	_5:Bool;
	_4:Bool;
	_3:stdgo.GoInt64;
	_2:stdgo.GoInt64;
	_1:stdgo.GoInt;
	_0:stdgo.GoString;
}`](<#function-get_tzset>)

- [`function get_tzsetName():()`](<#function-get_tzsetname>)

- [`function get_tzsetOffset():()`](<#function-get_tzsetoffset>)

- [`function get_utc():stdgo._internal.time.Location`](<#function-get_utc>)

- [`function gorootZoneSource()`](<#function-gorootzonesource>)

- [`function interrupt():Void`](<#function-interrupt>)

- [`function loadFromEmbeddedTZData(zone:String):stdgo.Tuple<String, stdgo.Error>`](<#function-loadfromembeddedtzdata>)

- [`function loadLocation(name:String):stdgo.Tuple<stdgo.time.Location, stdgo.Error>`](<#function-loadlocation>)

- [`function loadLocationFromTZData(name:String, data:Array<Int>):stdgo.Tuple<stdgo.time.Location, stdgo.Error>`](<#function-loadlocationfromtzdata>)

- [`function loadTzinfo(:stdgo.GoString, :stdgo.GoString):{
	_1:stdgo.Error;
	_0:stdgo.Slice<stdgo.GoUInt8>;
}`](<#function-loadtzinfo>)

- [`function newTicker(d:stdgo.time.Duration):stdgo.time.Ticker`](<#function-newticker>)

- [`function newTimer(d:stdgo.time.Duration):stdgo.time.Timer`](<#function-newtimer>)

- [`function nextStdChunk()`](<#function-nextstdchunk>)

- [`function now():stdgo.time.Time`](<#function-now>)

- [`function parse(layout:String, value:String):stdgo.Tuple<stdgo.time.Time, stdgo.Error>`](<#function-parse>)

- [`function parseAny(:stdgo.GoString, :stdgo.GoString, :stdgo.Ref<stdgo._internal.time.Location>, :stdgo.Ref<stdgo._internal.time.Location>):{
	_1:stdgo.Error;
	_0:stdgo._internal.time.Time;
}`](<#function-parseany>)

- [`function parseDuration(s:String):stdgo.Tuple<stdgo.time.Duration, stdgo.Error>`](<#function-parseduration>)

- [`function parseInLocation(layout:String, value:String, loc:stdgo.time.Location):stdgo.Tuple<stdgo.time.Time, stdgo.Error>`](<#function-parseinlocation>)

- [`function parseRFC3339(:stdgo.GoString, :stdgo.Ref<stdgo._internal.time.Location>):{
	_1:Bool;
	_0:stdgo._internal.time.Time;
}`](<#function-parserfc3339>)

- [`function parseTimeZone()`](<#function-parsetimezone>)

- [`function quote()`](<#function-quote>)

- [`function readFile()`](<#function-readfile>)

- [`function resetLocalOnceForTest():Void`](<#function-resetlocaloncefortest>)

- [`function resetZoneinfoForTesting():Void`](<#function-resetzoneinfofortesting>)

- [`function setMono(:stdgo.Ref<stdgo._internal.time.Time>, :stdgo.GoInt64):Void`](<#function-setmono>)

- [`function set_appendFormatAny(v:(:stdgo._internal.time.Time, :stdgo.Slice<stdgo.GoUInt8>, :stdgo.GoString):stdgo.Slice<stdgo.GoUInt8>):(:stdgo._internal.time.Time, :stdgo.Slice<stdgo.GoUInt8>, :stdgo.GoString):stdgo.Slice<stdgo.GoUInt8>`](<#function-set_appendformatany>)

- [`function set_appendFormatRFC3339(v:(:stdgo._internal.time.Time, :stdgo.Slice<stdgo.GoUInt8>, :Bool):stdgo.Slice<stdgo.GoUInt8>):(:stdgo._internal.time.Time, :stdgo.Slice<stdgo.GoUInt8>, :Bool):stdgo.Slice<stdgo.GoUInt8>`](<#function-set_appendformatrfc3339>)

- [`function set_appendInt(v:(:stdgo.Slice<stdgo.GoUInt8>, :stdgo.GoInt, :stdgo.GoInt):stdgo.Slice<stdgo.GoUInt8>):(:stdgo.Slice<stdgo.GoUInt8>, :stdgo.GoInt, :stdgo.GoInt):stdgo.Slice<stdgo.GoUInt8>`](<#function-set_appendint>)

- [`function set_daysIn(v:(:stdgo._internal.time.Month, :stdgo.GoInt):stdgo.GoInt):(:stdgo._internal.time.Month, :stdgo.GoInt):stdgo.GoInt`](<#function-set_daysin>)

- [`function set_disablePlatformSources(v:():():Void):():():Void`](<#function-set_disableplatformsources>)

- [`function set_errLocation(v:stdgo.Error):stdgo.Error`](<#function-set_errlocation>)

- [`function set_getMono(v:()):()`](<#function-set_getmono>)

- [`function set_gorootZoneSource(v:()):()`](<#function-set_gorootzonesource>)

- [`function set_interrupt(v:():Void):():Void`](<#function-set_interrupt>)

- [`function set_loadTzinfo(v:(:stdgo.GoString, :stdgo.GoString):{
	_1:stdgo.Error;
	_0:stdgo.Slice<stdgo.GoUInt8>;
}):(:stdgo.GoString, :stdgo.GoString):{
	_1:stdgo.Error;
	_0:stdgo.Slice<stdgo.GoUInt8>;
}`](<#function-set_loadtzinfo>)

- [`function set_local(v:stdgo._internal.time.Location):stdgo._internal.time.Location`](<#function-set_local>)

- [`function set_maxMonoTime(v:stdgo._internal.time.Time):stdgo._internal.time.Time`](<#function-set_maxmonotime>)

- [`function set_minMonoTime(v:stdgo._internal.time.Time):stdgo._internal.time.Time`](<#function-set_minmonotime>)

- [`function set_nextStdChunk(v:()):()`](<#function-set_nextstdchunk>)

- [`function set_notMonoNegativeTime(v:stdgo._internal.time.Time):stdgo._internal.time.Time`](<#function-set_notmononegativetime>)

- [`function set_parseAny(v:(:stdgo.GoString, :stdgo.GoString, :stdgo.Ref<stdgo._internal.time.Location>, :stdgo.Ref<stdgo._internal.time.Location>):{
	_1:stdgo.Error;
	_0:stdgo._internal.time.Time;
}):(:stdgo.GoString, :stdgo.GoString, :stdgo.Ref<stdgo._internal.time.Location>, :stdgo.Ref<stdgo._internal.time.Location>):{
	_1:stdgo.Error;
	_0:stdgo._internal.time.Time;
}`](<#function-set_parseany>)

- [`function set_parseRFC3339(v:(:stdgo.GoString, :stdgo.Ref<stdgo._internal.time.Location>):{
	_1:Bool;
	_0:stdgo._internal.time.Time;
}):(:stdgo.GoString, :stdgo.Ref<stdgo._internal.time.Location>):{
	_1:Bool;
	_0:stdgo._internal.time.Time;
}`](<#function-set_parserfc3339>)

- [`function set_parseTimeZone(v:()):()`](<#function-set_parsetimezone>)

- [`function set_quote(v:()):()`](<#function-set_quote>)

- [`function set_readFile(v:()):()`](<#function-set_readfile>)

- [`function set_setMono(v:(:stdgo.Ref<stdgo._internal.time.Time>, :stdgo.GoInt64):Void):(:stdgo.Ref<stdgo._internal.time.Time>, :stdgo.GoInt64):Void`](<#function-set_setmono>)

- [`function set_stdChunkNames(v:stdgo.GoMap<stdgo.GoInt, stdgo.GoString>):stdgo.GoMap<stdgo.GoInt, stdgo.GoString>`](<#function-set_stdchunknames>)

- [`function set_tzset(v:(:stdgo.GoString, :stdgo.GoInt64, :stdgo.GoInt64):{
	_5:Bool;
	_4:Bool;
	_3:stdgo.GoInt64;
	_2:stdgo.GoInt64;
	_1:stdgo.GoInt;
	_0:stdgo.GoString;
}):(:stdgo.GoString, :stdgo.GoInt64, :stdgo.GoInt64):{
	_5:Bool;
	_4:Bool;
	_3:stdgo.GoInt64;
	_2:stdgo.GoInt64;
	_1:stdgo.GoInt;
	_0:stdgo.GoString;
}`](<#function-set_tzset>)

- [`function set_tzsetName(v:()):()`](<#function-set_tzsetname>)

- [`function set_tzsetOffset(v:()):()`](<#function-set_tzsetoffset>)

- [`function set_utc(v:stdgo._internal.time.Location):stdgo._internal.time.Location`](<#function-set_utc>)

- [`function since(t:stdgo.time.Time):stdgo.time.Duration`](<#function-since>)

- [`function sleep(d:stdgo.time.Duration):Void`](<#function-sleep>)

- [`function tick(d:stdgo.time.Duration):stdgo.Chan<stdgo.time.Time>`](<#function-tick>)

- [`function tzset(:stdgo.GoString, :stdgo.GoInt64, :stdgo.GoInt64):{
	_5:Bool;
	_4:Bool;
	_3:stdgo.GoInt64;
	_2:stdgo.GoInt64;
	_1:stdgo.GoInt;
	_0:stdgo.GoString;
}`](<#function-tzset>)

- [`function tzsetName()`](<#function-tzsetname>)

- [`function tzsetOffset()`](<#function-tzsetoffset>)

- [`function tzsetRule(s:String):stdgo.Tuple3<stdgo.time.Rule, String, Bool>`](<#function-tzsetrule>)

- [`function unix(sec:haxe.Int64, nsec:haxe.Int64):stdgo.time.Time`](<#function-unix>)

- [`function unixMicro(usec:haxe.Int64):stdgo.time.Time`](<#function-unixmicro>)

- [`function unixMilli(msec:haxe.Int64):stdgo.time.Time`](<#function-unixmilli>)

- [`function until(t:stdgo.time.Time):stdgo.time.Duration`](<#function-until>)

- [`function zoneinfoForTesting():stdgo.Pointer<String>`](<#function-zoneinfofortesting>)

- [typedef Duration](<#typedef-duration>)

- [typedef Duration\_asInterface](<#typedef-duration_asinterface>)

- [typedef Duration\_static\_extension](<#typedef-duration_static_extension>)

- [typedef Location](<#typedef-location>)

- [typedef Location\_asInterface](<#typedef-location_asinterface>)

- [typedef Location\_static\_extension](<#typedef-location_static_extension>)

- [typedef Month](<#typedef-month>)

- [typedef Month\_asInterface](<#typedef-month_asinterface>)

- [typedef Month\_static\_extension](<#typedef-month_static_extension>)

- [typedef ParseError](<#typedef-parseerror>)

- [typedef ParseError\_asInterface](<#typedef-parseerror_asinterface>)

- [typedef ParseError\_static\_extension](<#typedef-parseerror_static_extension>)

- [typedef Rule](<#typedef-rule>)

- [typedef RuleKind](<#typedef-rulekind>)

- [typedef T\_dataIO](<#typedef-t_dataio>)

- [typedef T\_dataIO\_asInterface](<#typedef-t_dataio_asinterface>)

- [typedef T\_dataIO\_static\_extension](<#typedef-t_dataio_static_extension>)

- [typedef T\_fileSizeError](<#typedef-t_filesizeerror>)

- [typedef T\_fileSizeError\_asInterface](<#typedef-t_filesizeerror_asinterface>)

- [typedef T\_fileSizeError\_static\_extension](<#typedef-t_filesizeerror_static_extension>)

- [typedef T\_rule](<#typedef-t_rule>)

- [typedef T\_ruleKind](<#typedef-t_rulekind>)

- [typedef T\_runtimeTimer](<#typedef-t_runtimetimer>)

- [typedef T\_zone](<#typedef-t_zone>)

- [typedef T\_zoneTrans](<#typedef-t_zonetrans>)

- [typedef Ticker](<#typedef-ticker>)

- [typedef Ticker\_asInterface](<#typedef-ticker_asinterface>)

- [typedef Ticker\_static\_extension](<#typedef-ticker_static_extension>)

- [typedef Time](<#typedef-time>)

- [typedef Time\_asInterface](<#typedef-time_asinterface>)

- [typedef Time\_static\_extension](<#typedef-time_static_extension>)

- [typedef Timer](<#typedef-timer>)

- [typedef Timer\_asInterface](<#typedef-timer_asinterface>)

- [typedef Timer\_static\_extension](<#typedef-timer_static_extension>)

- [typedef Weekday](<#typedef-weekday>)

- [typedef Weekday\_asInterface](<#typedef-weekday_asinterface>)

- [typedef Weekday\_static\_extension](<#typedef-weekday_static_extension>)

# Constants


```haxe
import stdgo.time.Time
```


```haxe
final ansic:String = stdgo._internal.time.Time.ansic
```


```haxe
final april:stdgo._internal.time.Month = stdgo._internal.time.Time.april
```


```haxe
final august:stdgo._internal.time.Month = stdgo._internal.time.Time.august
```


```haxe
final dateOnly:String = stdgo._internal.time.Time.dateOnly
```


```haxe
final dateTime:String = stdgo._internal.time.Time.dateTime
```


```haxe
final december:stdgo._internal.time.Month = stdgo._internal.time.Time.december
```


```haxe
final february:stdgo._internal.time.Month = stdgo._internal.time.Time.february
```


```haxe
final friday:stdgo._internal.time.Weekday = stdgo._internal.time.Time.friday
```


```haxe
final hour:stdgo._internal.time.Duration = stdgo._internal.time.Time.hour
```


```haxe
final january:stdgo._internal.time.Month = stdgo._internal.time.Time.january
```


```haxe
final july:stdgo._internal.time.Month = stdgo._internal.time.Time.july
```


```haxe
final june:stdgo._internal.time.Month = stdgo._internal.time.Time.june
```


```haxe
final kitchen:String = stdgo._internal.time.Time.kitchen
```


```haxe
final layout:String = stdgo._internal.time.Time.layout
```


```haxe
final march:stdgo._internal.time.Month = stdgo._internal.time.Time.march
```


```haxe
final may:stdgo._internal.time.Month = stdgo._internal.time.Time.may
```


```haxe
final microsecond:stdgo._internal.time.Duration = stdgo._internal.time.Time.microsecond
```


```haxe
final millisecond:stdgo._internal.time.Duration = stdgo._internal.time.Time.millisecond
```


```haxe
final minute:stdgo._internal.time.Duration = stdgo._internal.time.Time.minute
```


```haxe
final monday:stdgo._internal.time.Weekday = stdgo._internal.time.Time.monday
```


```haxe
final nanosecond:stdgo._internal.time.Duration = stdgo._internal.time.Time.nanosecond
```


```haxe
final november:stdgo._internal.time.Month = stdgo._internal.time.Time.november
```


```haxe
final october:stdgo._internal.time.Month = stdgo._internal.time.Time.october
```


```haxe
final rfc1123:String = stdgo._internal.time.Time.rfc1123
```


```haxe
final rfc1123z:String = stdgo._internal.time.Time.rfc1123z
```


```haxe
final rfc3339:String = stdgo._internal.time.Time.rfc3339
```


```haxe
final rfc3339nano:String = stdgo._internal.time.Time.rfc3339nano
```


```haxe
final rfc822:String = stdgo._internal.time.Time.rfc822
```


```haxe
final rfc822z:String = stdgo._internal.time.Time.rfc822z
```


```haxe
final rfc850:String = stdgo._internal.time.Time.rfc850
```


```haxe
final rubyDate:String = stdgo._internal.time.Time.rubyDate
```


```haxe
final ruleDOY:stdgo._internal.time.RuleKind = stdgo._internal.time.Time.ruleDOY
```


```haxe
final ruleJulian:stdgo._internal.time.RuleKind = stdgo._internal.time.Time.ruleJulian
```


```haxe
final ruleMonthWeekDay:stdgo._internal.time.RuleKind = stdgo._internal.time.Time.ruleMonthWeekDay
```


```haxe
final saturday:stdgo._internal.time.Weekday = stdgo._internal.time.Time.saturday
```


```haxe
final second:stdgo._internal.time.Duration = stdgo._internal.time.Time.second
```


```haxe
final september:stdgo._internal.time.Month = stdgo._internal.time.Time.september
```


```haxe
final stamp:String = stdgo._internal.time.Time.stamp
```


```haxe
final stampMicro:String = stdgo._internal.time.Time.stampMicro
```


```haxe
final stampMilli:String = stdgo._internal.time.Time.stampMilli
```


```haxe
final stampNano:String = stdgo._internal.time.Time.stampNano
```


```haxe
final sunday:stdgo._internal.time.Weekday = stdgo._internal.time.Time.sunday
```


```haxe
final thursday:stdgo._internal.time.Weekday = stdgo._internal.time.Time.thursday
```


```haxe
final timeOnly:String = stdgo._internal.time.Time.timeOnly
```


```haxe
final tuesday:stdgo._internal.time.Weekday = stdgo._internal.time.Time.tuesday
```


```haxe
final unixDate:String = stdgo._internal.time.Time.unixDate
```


```haxe
final unixToInternal:haxe.Int64 = stdgo._internal.time.Time.unixToInternal
```


```haxe
final wednesday:stdgo._internal.time.Weekday = stdgo._internal.time.Time.wednesday
```


# Variables


```haxe
import stdgo.time.Time
```


```haxe
var errLocation:stdgo.Error
```


```haxe
var local:stdgo._internal.time.Location
```


```haxe
var maxMonoTime:stdgo._internal.time.Time
```


```haxe
var minMonoTime:stdgo._internal.time.Time
```


```haxe
var notMonoNegativeTime:stdgo._internal.time.Time
```


```haxe
var stdChunkNames:stdgo.GoMap<stdgo.GoInt, stdgo.GoString>
```


```haxe
var utc:stdgo._internal.time.Location
```


# Functions


```haxe
import stdgo.time.Time
```


## function after


```haxe
function after(d:stdgo.time.Duration):stdgo.Chan<stdgo.time.Time>
```


```
After waits for the duration to elapse and then sends the current time
    on the returned channel.
    It is equivalent to NewTimer(d).C.
    The underlying Timer is not recovered by the garbage collector
    until the timer fires. If efficiency is a concern, use NewTimer
    instead and call Timer.Stop if the timer is no longer needed.
```
[\(view code\)](<./Time.hx#L315>)


## function afterFunc


```haxe
function afterFunc(d:stdgo.time.Duration, f:():Void):stdgo.time.Timer
```


```
AfterFunc waits for the duration to elapse and then calls f
    in its own goroutine. It returns a Timer that can
    be used to cancel the call using its Stop method.
```
[\(view code\)](<./Time.hx#L321>)


## function appendFormatAny


```haxe
function appendFormatAny(:stdgo._internal.time.Time, :stdgo.Slice<stdgo.GoUInt8>, :stdgo.GoString):stdgo.Slice<stdgo.GoUInt8>
```


[\(view code\)](<./Time.hx>)


## function appendFormatRFC3339


```haxe
function appendFormatRFC3339(:stdgo._internal.time.Time, :stdgo.Slice<stdgo.GoUInt8>, :Bool):stdgo.Slice<stdgo.GoUInt8>
```


[\(view code\)](<./Time.hx>)


## function appendInt


```haxe
function appendInt(:stdgo.Slice<stdgo.GoUInt8>, :stdgo.GoInt, :stdgo.GoInt):stdgo.Slice<stdgo.GoUInt8>
```


[\(view code\)](<./Time.hx>)


## function checkRuntimeTimerPeriodOverflow


```haxe
function checkRuntimeTimerPeriodOverflow():Void
```


```
Test that a runtimeTimer with a period that would overflow when on
    expiration does not throw or cause other timers to hang.
```

This test has to be in internal\_test.go since it fiddles with
unexported data structures.  

[\(view code\)](<./Time.hx#L296>)


## function date


```haxe
function date(year:Int, month:stdgo.time.Month, day:Int, hour:Int, min:Int, sec:Int, nsec:Int, loc:stdgo.time.Location):stdgo.time.Time
```



Date returns the Time corresponding to  

```
    	yyyy-mm-dd hh:mm:ss + nsec nanoseconds
```

in the appropriate zone for that time in the given location.  


The month, day, hour, min, sec, and nsec values may be outside
their usual ranges and will be normalized during the conversion.
For example, October 32 converts to November 1.  


A daylight savings time transition skips or repeats times.
For example, in the United States, March 13, 2011 2:15am never occurred,
while November 6, 2011 1:15am occurred twice. In such cases, the
choice of time zone, and therefore the time, is not well\-defined.
Date returns a time that is correct in one of the two zones involved
in the transition, but it does not guarantee which.  


Date panics if loc is nil.  

[\(view code\)](<./Time.hx#L391>)


## function daysIn


```haxe
function daysIn(:stdgo._internal.time.Month, :stdgo.GoInt):stdgo.GoInt
```


[\(view code\)](<./Time.hx>)


## function disablePlatformSources


```haxe
function disablePlatformSources():():Void
```


[\(view code\)](<./Time.hx>)


## function fixedZone


```haxe
function fixedZone(name:String, offset:Int):stdgo.time.Location
```


```
FixedZone returns a Location that always uses
    the given zone name and offset (seconds east of UTC).
```
[\(view code\)](<./Time.hx#L396>)


## function forceUSPacificForTesting


```haxe
function forceUSPacificForTesting():Void
```


[\(view code\)](<./Time.hx#L223>)


## function getMono


```haxe
function getMono()
```


[\(view code\)](<./Time.hx>)


## function get\_appendFormatAny


```haxe
function get_appendFormatAny():(:stdgo._internal.time.Time, :stdgo.Slice<stdgo.GoUInt8>, :stdgo.GoString):stdgo.Slice<stdgo.GoUInt8>
```


[\(view code\)](<./Time.hx#L176>)


## function get\_appendFormatRFC3339


```haxe
function get_appendFormatRFC3339():(:stdgo._internal.time.Time, :stdgo.Slice<stdgo.GoUInt8>, :Bool):stdgo.Slice<stdgo.GoUInt8>
```


[\(view code\)](<./Time.hx#L179>)


## function get\_appendInt


```haxe
function get_appendInt():(:stdgo.Slice<stdgo.GoUInt8>, :stdgo.GoInt, :stdgo.GoInt):stdgo.Slice<stdgo.GoUInt8>
```


[\(view code\)](<./Time.hx#L173>)


## function get\_daysIn


```haxe
function get_daysIn():(:stdgo._internal.time.Month, :stdgo.GoInt):stdgo.GoInt
```


[\(view code\)](<./Time.hx#L194>)


## function get\_disablePlatformSources


```haxe
function get_disablePlatformSources():():():Void
```


[\(view code\)](<./Time.hx#L188>)


## function get\_errLocation


```haxe
function get_errLocation():stdgo.Error
```


[\(view code\)](<./Time.hx#L146>)


## function get\_getMono


```haxe
function get_getMono():()
```


[\(view code\)](<./Time.hx#L143>)


## function get\_gorootZoneSource


```haxe
function get_gorootZoneSource():()
```


[\(view code\)](<./Time.hx#L134>)


## function get\_interrupt


```haxe
function get_interrupt():():Void
```


[\(view code\)](<./Time.hx#L191>)


## function get\_loadTzinfo


```haxe
function get_loadTzinfo():(:stdgo.GoString, :stdgo.GoString):{
	_1:stdgo.Error;
	_0:stdgo.Slice<stdgo.GoUInt8>;
}
```


[\(view code\)](<./Time.hx#L152>)


## function get\_local


```haxe
function get_local():stdgo._internal.time.Location
```


[\(view code\)](<./Time.hx#L131>)


## function get\_maxMonoTime


```haxe
function get_maxMonoTime():stdgo._internal.time.Time
```


[\(view code\)](<./Time.hx#L200>)


## function get\_minMonoTime


```haxe
function get_minMonoTime():stdgo._internal.time.Time
```


[\(view code\)](<./Time.hx#L197>)


## function get\_nextStdChunk


```haxe
function get_nextStdChunk():()
```


[\(view code\)](<./Time.hx#L155>)


## function get\_notMonoNegativeTime


```haxe
function get_notMonoNegativeTime():stdgo._internal.time.Time
```


[\(view code\)](<./Time.hx#L203>)


## function get\_parseAny


```haxe
function get_parseAny():(:stdgo.GoString, :stdgo.GoString, :stdgo.Ref<stdgo._internal.time.Location>, :stdgo.Ref<stdgo._internal.time.Location>):{
	_1:stdgo.Error;
	_0:stdgo._internal.time.Time;
}
```


[\(view code\)](<./Time.hx#L182>)


## function get\_parseRFC3339


```haxe
function get_parseRFC3339():(:stdgo.GoString, :stdgo.Ref<stdgo._internal.time.Location>):{
	_1:Bool;
	_0:stdgo._internal.time.Time;
}
```


[\(view code\)](<./Time.hx#L185>)


## function get\_parseTimeZone


```haxe
function get_parseTimeZone():()
```


[\(view code\)](<./Time.hx#L137>)


## function get\_quote


```haxe
function get_quote():()
```


[\(view code\)](<./Time.hx#L170>)


## function get\_readFile


```haxe
function get_readFile():()
```


[\(view code\)](<./Time.hx#L149>)


## function get\_setMono


```haxe
function get_setMono():(:stdgo.Ref<stdgo._internal.time.Time>, :stdgo.GoInt64):Void
```


[\(view code\)](<./Time.hx#L140>)


## function get\_stdChunkNames


```haxe
function get_stdChunkNames():stdgo.GoMap<stdgo.GoInt, stdgo.GoString>
```


[\(view code\)](<./Time.hx#L167>)


## function get\_tzset


```haxe
function get_tzset():(:stdgo.GoString, :stdgo.GoInt64, :stdgo.GoInt64):{
	_5:Bool;
	_4:Bool;
	_3:stdgo.GoInt64;
	_2:stdgo.GoInt64;
	_1:stdgo.GoInt;
	_0:stdgo.GoString;
}
```


[\(view code\)](<./Time.hx#L158>)


## function get\_tzsetName


```haxe
function get_tzsetName():()
```


[\(view code\)](<./Time.hx#L161>)


## function get\_tzsetOffset


```haxe
function get_tzsetOffset():()
```


[\(view code\)](<./Time.hx#L164>)


## function get\_utc


```haxe
function get_utc():stdgo._internal.time.Location
```


[\(view code\)](<./Time.hx#L128>)


## function gorootZoneSource


```haxe
function gorootZoneSource()
```


[\(view code\)](<./Time.hx>)


## function interrupt


```haxe
function interrupt():Void
```


[\(view code\)](<./Time.hx>)


## function loadFromEmbeddedTZData


```haxe
function loadFromEmbeddedTZData(zone:String):stdgo.Tuple<String, stdgo.Error>
```


[\(view code\)](<./Time.hx#L226>)


## function loadLocation


```haxe
function loadLocation(name:String):stdgo.Tuple<stdgo.time.Location, stdgo.Error>
```



LoadLocation returns the Location with the given name.  


If the name is "" or "UTC", LoadLocation returns UTC.
If the name is "Local", LoadLocation returns Local.  


Otherwise, the name is taken to be a location name corresponding to a file
in the IANA Time Zone database, such as "America/New\_York".  


LoadLocation looks for the IANA Time Zone database in the following
locations in order:  

```
      - the directory or uncompressed zip file named by the ZONEINFO environment variable
      - on a Unix system, the system standard installation location
      - $GOROOT/lib/time/zoneinfo.zip
      - the time/tzdata package, if it was imported
```
[\(view code\)](<./Time.hx#L414>)


## function loadLocationFromTZData


```haxe
function loadLocationFromTZData(name:String, data:Array<Int>):stdgo.Tuple<stdgo.time.Location, stdgo.Error>
```


```
LoadLocationFromTZData returns a Location with the given name
    initialized from the IANA Time Zone database-formatted data.
    The data should be in the format of a standard IANA time zone file
    (for example, the content of /etc/localtime on Unix systems).
```
[\(view code\)](<./Time.hx#L421>)


## function loadTzinfo


```haxe
function loadTzinfo(:stdgo.GoString, :stdgo.GoString):{
	_1:stdgo.Error;
	_0:stdgo.Slice<stdgo.GoUInt8>;
}
```


[\(view code\)](<./Time.hx>)


## function newTicker


```haxe
function newTicker(d:stdgo.time.Duration):stdgo.time.Ticker
```


```
NewTicker returns a new Ticker containing a channel that will send
    the current time on the channel after each tick. The period of the
    ticks is specified by the duration argument. The ticker will adjust
    the time interval or drop ticks to make up for slow receivers.
    The duration d must be greater than zero; if not, NewTicker will
    panic. Stop the ticker to release associated resources.
```
[\(view code\)](<./Time.hx#L330>)


## function newTimer


```haxe
function newTimer(d:stdgo.time.Duration):stdgo.time.Timer
```


```
NewTimer creates a new Timer that will send
    the current time on its channel after at least duration d.
```
[\(view code\)](<./Time.hx#L306>)


## function nextStdChunk


```haxe
function nextStdChunk()
```


[\(view code\)](<./Time.hx>)


## function now


```haxe
function now():stdgo.time.Time
```



Now returns the current local time.  

[\(view code\)](<./Time.hx#L352>)


## function parse


```haxe
function parse(layout:String, value:String):stdgo.Tuple<stdgo.time.Time, stdgo.Error>
```


```
Parse parses a formatted string and returns the time value it represents.
    See the documentation for the constant called Layout to see how to
    represent the format. The second argument must be parseable using
    the format string (layout) provided as the first argument.
```

The example for Time.Format demonstrates the working of the layout string
in detail and is a good reference.  


When parsing \(only\), the input may contain a fractional second
field immediately after the seconds field, even if the layout does not
signify its presence. In that case either a comma or a decimal point
followed by a maximal series of digits is parsed as a fractional second.
Fractional seconds are truncated to nanosecond precision.  


Elements omitted from the layout are assumed to be zero or, when
zero is impossible, one, so parsing "3:04pm" returns the time
corresponding to Jan 1, year 0, 15:04:00 UTC \(note that because the year is
0, this time is before the zero Time\).
Years must be in the range 0000..9999. The day of the week is checked
for syntax but it is otherwise ignored.  


For layouts specifying the two\-digit year 06, a value NN \>= 69 will be treated
as 19NN and a value NN \< 69 will be treated as 20NN.  


The remainder of this comment describes the handling of time zones.  


In the absence of a time zone indicator, Parse returns a time in UTC.  


When parsing a time with a zone offset like \-0700, if the offset corresponds
to a time zone used by the current location \(Local\), then Parse uses that
location and zone in the returned time. Otherwise it records the time as
being in a fabricated location with time fixed at the given zone offset.  


When parsing a time with a zone abbreviation like MST, if the zone abbreviation
has a defined offset in the current location, then that offset is used.
The zone abbreviation "UTC" is recognized as UTC regardless of location.
If the zone abbreviation is unknown, Parse records the time as being
in a fabricated location with the given zone abbreviation and a zero offset.
This choice means that such a time can be parsed and reformatted with the
same layout losslessly, but the exact instant used in the representation will
differ by the actual zone offset. To avoid such problems, prefer time layouts
that use a numeric zone offset, or use ParseInLocation.  

[\(view code\)](<./Time.hx#L272>)


## function parseAny


```haxe
function parseAny(:stdgo.GoString, :stdgo.GoString, :stdgo.Ref<stdgo._internal.time.Location>, :stdgo.Ref<stdgo._internal.time.Location>):{
	_1:stdgo.Error;
	_0:stdgo._internal.time.Time;
}
```


[\(view code\)](<./Time.hx>)


## function parseDuration


```haxe
function parseDuration(s:String):stdgo.Tuple<stdgo.time.Duration, stdgo.Error>
```


```
ParseDuration parses a duration string.
    A duration string is a possibly signed sequence of
    decimal numbers, each with optional fraction and a unit suffix,
    such as "300ms", "-1.5h" or "2h45m".
    Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
```
[\(view code\)](<./Time.hx#L288>)


## function parseInLocation


```haxe
function parseInLocation(layout:String, value:String, loc:stdgo.time.Location):stdgo.Tuple<stdgo.time.Time, stdgo.Error>
```


```
ParseInLocation is like Parse but differs in two important ways.
    First, in the absence of time zone information, Parse interprets a time as UTC;
    ParseInLocation interprets the time as in the given location.
    Second, when given a zone offset or abbreviation, Parse tries to match it
    against the Local location; ParseInLocation uses the given location.
```
[\(view code\)](<./Time.hx#L280>)


## function parseRFC3339


```haxe
function parseRFC3339(:stdgo.GoString, :stdgo.Ref<stdgo._internal.time.Location>):{
	_1:Bool;
	_0:stdgo._internal.time.Time;
}
```


[\(view code\)](<./Time.hx>)


## function parseTimeZone


```haxe
function parseTimeZone()
```


[\(view code\)](<./Time.hx>)


## function quote


```haxe
function quote()
```


[\(view code\)](<./Time.hx>)


## function readFile


```haxe
function readFile()
```


[\(view code\)](<./Time.hx>)


## function resetLocalOnceForTest


```haxe
function resetLocalOnceForTest():Void
```


[\(view code\)](<./Time.hx#L222>)


## function resetZoneinfoForTesting


```haxe
function resetZoneinfoForTesting():Void
```


[\(view code\)](<./Time.hx#L225>)


## function setMono


```haxe
function setMono(:stdgo.Ref<stdgo._internal.time.Time>, :stdgo.GoInt64):Void
```


[\(view code\)](<./Time.hx>)


## function set\_appendFormatAny


```haxe
function set_appendFormatAny(v:(:stdgo._internal.time.Time, :stdgo.Slice<stdgo.GoUInt8>, :stdgo.GoString):stdgo.Slice<stdgo.GoUInt8>):(:stdgo._internal.time.Time, :stdgo.Slice<stdgo.GoUInt8>, :stdgo.GoString):stdgo.Slice<stdgo.GoUInt8>
```


[\(view code\)](<./Time.hx#L177>)


## function set\_appendFormatRFC3339


```haxe
function set_appendFormatRFC3339(v:(:stdgo._internal.time.Time, :stdgo.Slice<stdgo.GoUInt8>, :Bool):stdgo.Slice<stdgo.GoUInt8>):(:stdgo._internal.time.Time, :stdgo.Slice<stdgo.GoUInt8>, :Bool):stdgo.Slice<stdgo.GoUInt8>
```


[\(view code\)](<./Time.hx#L180>)


## function set\_appendInt


```haxe
function set_appendInt(v:(:stdgo.Slice<stdgo.GoUInt8>, :stdgo.GoInt, :stdgo.GoInt):stdgo.Slice<stdgo.GoUInt8>):(:stdgo.Slice<stdgo.GoUInt8>, :stdgo.GoInt, :stdgo.GoInt):stdgo.Slice<stdgo.GoUInt8>
```


[\(view code\)](<./Time.hx#L174>)


## function set\_daysIn


```haxe
function set_daysIn(v:(:stdgo._internal.time.Month, :stdgo.GoInt):stdgo.GoInt):(:stdgo._internal.time.Month, :stdgo.GoInt):stdgo.GoInt
```


[\(view code\)](<./Time.hx#L195>)


## function set\_disablePlatformSources


```haxe
function set_disablePlatformSources(v:():():Void):():():Void
```


[\(view code\)](<./Time.hx#L189>)


## function set\_errLocation


```haxe
function set_errLocation(v:stdgo.Error):stdgo.Error
```


[\(view code\)](<./Time.hx#L147>)


## function set\_getMono


```haxe
function set_getMono(v:()):()
```


[\(view code\)](<./Time.hx#L144>)


## function set\_gorootZoneSource


```haxe
function set_gorootZoneSource(v:()):()
```


[\(view code\)](<./Time.hx#L135>)


## function set\_interrupt


```haxe
function set_interrupt(v:():Void):():Void
```


[\(view code\)](<./Time.hx#L192>)


## function set\_loadTzinfo


```haxe
function set_loadTzinfo(v:(:stdgo.GoString, :stdgo.GoString):{
	_1:stdgo.Error;
	_0:stdgo.Slice<stdgo.GoUInt8>;
}):(:stdgo.GoString, :stdgo.GoString):{
	_1:stdgo.Error;
	_0:stdgo.Slice<stdgo.GoUInt8>;
}
```


[\(view code\)](<./Time.hx#L153>)


## function set\_local


```haxe
function set_local(v:stdgo._internal.time.Location):stdgo._internal.time.Location
```


[\(view code\)](<./Time.hx#L132>)


## function set\_maxMonoTime


```haxe
function set_maxMonoTime(v:stdgo._internal.time.Time):stdgo._internal.time.Time
```


[\(view code\)](<./Time.hx#L201>)


## function set\_minMonoTime


```haxe
function set_minMonoTime(v:stdgo._internal.time.Time):stdgo._internal.time.Time
```


[\(view code\)](<./Time.hx#L198>)


## function set\_nextStdChunk


```haxe
function set_nextStdChunk(v:()):()
```


[\(view code\)](<./Time.hx#L156>)


## function set\_notMonoNegativeTime


```haxe
function set_notMonoNegativeTime(v:stdgo._internal.time.Time):stdgo._internal.time.Time
```


[\(view code\)](<./Time.hx#L204>)


## function set\_parseAny


```haxe
function set_parseAny(v:(:stdgo.GoString, :stdgo.GoString, :stdgo.Ref<stdgo._internal.time.Location>, :stdgo.Ref<stdgo._internal.time.Location>):{
	_1:stdgo.Error;
	_0:stdgo._internal.time.Time;
}):(:stdgo.GoString, :stdgo.GoString, :stdgo.Ref<stdgo._internal.time.Location>, :stdgo.Ref<stdgo._internal.time.Location>):{
	_1:stdgo.Error;
	_0:stdgo._internal.time.Time;
}
```


[\(view code\)](<./Time.hx#L183>)


## function set\_parseRFC3339


```haxe
function set_parseRFC3339(v:(:stdgo.GoString, :stdgo.Ref<stdgo._internal.time.Location>):{
	_1:Bool;
	_0:stdgo._internal.time.Time;
}):(:stdgo.GoString, :stdgo.Ref<stdgo._internal.time.Location>):{
	_1:Bool;
	_0:stdgo._internal.time.Time;
}
```


[\(view code\)](<./Time.hx#L186>)


## function set\_parseTimeZone


```haxe
function set_parseTimeZone(v:()):()
```


[\(view code\)](<./Time.hx#L138>)


## function set\_quote


```haxe
function set_quote(v:()):()
```


[\(view code\)](<./Time.hx#L171>)


## function set\_readFile


```haxe
function set_readFile(v:()):()
```


[\(view code\)](<./Time.hx#L150>)


## function set\_setMono


```haxe
function set_setMono(v:(:stdgo.Ref<stdgo._internal.time.Time>, :stdgo.GoInt64):Void):(:stdgo.Ref<stdgo._internal.time.Time>, :stdgo.GoInt64):Void
```


[\(view code\)](<./Time.hx#L141>)


## function set\_stdChunkNames


```haxe
function set_stdChunkNames(v:stdgo.GoMap<stdgo.GoInt, stdgo.GoString>):stdgo.GoMap<stdgo.GoInt, stdgo.GoString>
```


[\(view code\)](<./Time.hx#L168>)


## function set\_tzset


```haxe
function set_tzset(v:(:stdgo.GoString, :stdgo.GoInt64, :stdgo.GoInt64):{
	_5:Bool;
	_4:Bool;
	_3:stdgo.GoInt64;
	_2:stdgo.GoInt64;
	_1:stdgo.GoInt;
	_0:stdgo.GoString;
}):(:stdgo.GoString, :stdgo.GoInt64, :stdgo.GoInt64):{
	_5:Bool;
	_4:Bool;
	_3:stdgo.GoInt64;
	_2:stdgo.GoInt64;
	_1:stdgo.GoInt;
	_0:stdgo.GoString;
}
```


[\(view code\)](<./Time.hx#L159>)


## function set\_tzsetName


```haxe
function set_tzsetName(v:()):()
```


[\(view code\)](<./Time.hx#L162>)


## function set\_tzsetOffset


```haxe
function set_tzsetOffset(v:()):()
```


[\(view code\)](<./Time.hx#L165>)


## function set\_utc


```haxe
function set_utc(v:stdgo._internal.time.Location):stdgo._internal.time.Location
```


[\(view code\)](<./Time.hx#L129>)


## function since


```haxe
function since(t:stdgo.time.Time):stdgo.time.Duration
```


```
Since returns the time elapsed since t.
    It is shorthand for time.Now().Sub(t).
```
[\(view code\)](<./Time.hx#L343>)


## function sleep


```haxe
function sleep(d:stdgo.time.Duration):Void
```


```
Sleep pauses the current goroutine for at least the duration d.
    A negative or zero duration causes Sleep to return immediately.
```
[\(view code\)](<./Time.hx#L301>)


## function tick


```haxe
function tick(d:stdgo.time.Duration):stdgo.Chan<stdgo.time.Time>
```


```
Tick is a convenience wrapper for NewTicker providing access to the ticking
    channel only. While Tick is useful for clients that have no need to shut down
    the Ticker, be aware that without a way to shut it down the underlying
    Ticker cannot be recovered by the garbage collector; it "leaks".
    Unlike NewTicker, Tick will return nil if d <= 0.
```
[\(view code\)](<./Time.hx#L338>)


## function tzset


```haxe
function tzset(:stdgo.GoString, :stdgo.GoInt64, :stdgo.GoInt64):{
	_5:Bool;
	_4:Bool;
	_3:stdgo.GoInt64;
	_2:stdgo.GoInt64;
	_1:stdgo.GoInt;
	_0:stdgo.GoString;
}
```


[\(view code\)](<./Time.hx>)


## function tzsetName


```haxe
function tzsetName()
```


[\(view code\)](<./Time.hx>)


## function tzsetOffset


```haxe
function tzsetOffset()
```


[\(view code\)](<./Time.hx>)


## function tzsetRule


```haxe
function tzsetRule(s:String):stdgo.Tuple3<stdgo.time.Rule, String, Bool>
```


[\(view code\)](<./Time.hx#L227>)


## function unix


```haxe
function unix(sec:haxe.Int64, nsec:haxe.Int64):stdgo.time.Time
```


```
Unix returns the local Time corresponding to the given Unix time,
    sec seconds and nsec nanoseconds since January 1, 1970 UTC.
    It is valid to pass nsec outside the range [0, 999999999].
    Not all sec values have a corresponding time value. One such
    value is 1<<63-1 (the largest int64 value).
```
[\(view code\)](<./Time.hx#L360>)


## function unixMicro


```haxe
function unixMicro(usec:haxe.Int64):stdgo.time.Time
```


```
UnixMicro returns the local Time corresponding to the given Unix time,
    usec microseconds since January 1, 1970 UTC.
```
[\(view code\)](<./Time.hx#L370>)


## function unixMilli


```haxe
function unixMilli(msec:haxe.Int64):stdgo.time.Time
```


```
UnixMilli returns the local Time corresponding to the given Unix time,
    msec milliseconds since January 1, 1970 UTC.
```
[\(view code\)](<./Time.hx#L365>)


## function until


```haxe
function until(t:stdgo.time.Time):stdgo.time.Duration
```


```
Until returns the duration until t.
    It is shorthand for t.Sub(time.Now()).
```
[\(view code\)](<./Time.hx#L348>)


## function zoneinfoForTesting


```haxe
function zoneinfoForTesting():stdgo.Pointer<String>
```


[\(view code\)](<./Time.hx#L224>)


# Typedefs


```haxe
import stdgo.time.*
```


## typedef Duration


```haxe
typedef Duration = stdgo._internal.time.Duration;
```


## typedef Duration\_asInterface


```haxe
typedef Duration_asInterface = Dynamic;
```


## typedef Duration\_static\_extension


```haxe
typedef Duration_static_extension = Dynamic;
```


## typedef Location


```haxe
typedef Location = Dynamic;
```


## typedef Location\_asInterface


```haxe
typedef Location_asInterface = Dynamic;
```


## typedef Location\_static\_extension


```haxe
typedef Location_static_extension = Dynamic;
```


## typedef Month


```haxe
typedef Month = stdgo._internal.time.Month;
```


## typedef Month\_asInterface


```haxe
typedef Month_asInterface = Dynamic;
```


## typedef Month\_static\_extension


```haxe
typedef Month_static_extension = Dynamic;
```


## typedef ParseError


```haxe
typedef ParseError = Dynamic;
```


## typedef ParseError\_asInterface


```haxe
typedef ParseError_asInterface = Dynamic;
```


## typedef ParseError\_static\_extension


```haxe
typedef ParseError_static_extension = Dynamic;
```


## typedef Rule


```haxe
typedef Rule = Dynamic;
```


## typedef RuleKind


```haxe
typedef RuleKind = stdgo._internal.time.RuleKind;
```


## typedef T\_dataIO


```haxe
typedef T_dataIO = Dynamic;
```


## typedef T\_dataIO\_asInterface


```haxe
typedef T_dataIO_asInterface = Dynamic;
```


## typedef T\_dataIO\_static\_extension


```haxe
typedef T_dataIO_static_extension = Dynamic;
```


## typedef T\_fileSizeError


```haxe
typedef T_fileSizeError = stdgo._internal.time.T_fileSizeError;
```


## typedef T\_fileSizeError\_asInterface


```haxe
typedef T_fileSizeError_asInterface = Dynamic;
```


## typedef T\_fileSizeError\_static\_extension


```haxe
typedef T_fileSizeError_static_extension = Dynamic;
```


## typedef T\_rule


```haxe
typedef T_rule = Dynamic;
```


## typedef T\_ruleKind


```haxe
typedef T_ruleKind = stdgo._internal.time.T_ruleKind;
```


## typedef T\_runtimeTimer


```haxe
typedef T_runtimeTimer = Dynamic;
```


## typedef T\_zone


```haxe
typedef T_zone = Dynamic;
```


## typedef T\_zoneTrans


```haxe
typedef T_zoneTrans = Dynamic;
```


## typedef Ticker


```haxe
typedef Ticker = Dynamic;
```


## typedef Ticker\_asInterface


```haxe
typedef Ticker_asInterface = Dynamic;
```


## typedef Ticker\_static\_extension


```haxe
typedef Ticker_static_extension = Dynamic;
```


## typedef Time


```haxe
typedef Time = Dynamic;
```


## typedef Time\_asInterface


```haxe
typedef Time_asInterface = Dynamic;
```


## typedef Time\_static\_extension


```haxe
typedef Time_static_extension = Dynamic;
```


## typedef Timer


```haxe
typedef Timer = Dynamic;
```


## typedef Timer\_asInterface


```haxe
typedef Timer_asInterface = Dynamic;
```


## typedef Timer\_static\_extension


```haxe
typedef Timer_static_extension = Dynamic;
```


## typedef Weekday


```haxe
typedef Weekday = stdgo._internal.time.Weekday;
```


## typedef Weekday\_asInterface


```haxe
typedef Weekday_asInterface = Dynamic;
```


## typedef Weekday\_static\_extension


```haxe
typedef Weekday_static_extension = Dynamic;
```


