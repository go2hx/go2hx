package stdgo.time;
/**
    // Package time provides functionality for measuring and displaying time.
    //
    // The calendrical calculations always assume a Gregorian calendar, with
    // no leap seconds.
    //
    // # Monotonic Clocks
    //
    // Operating systems provide both a “wall clock,” which is subject to
    // changes for clock synchronization, and a “monotonic clock,” which is
    // not. The general rule is that the wall clock is for telling time and
    // the monotonic clock is for measuring time. Rather than split the API,
    // in this package the Time returned by time.Now contains both a wall
    // clock reading and a monotonic clock reading; later time-telling
    // operations use the wall clock reading, but later time-measuring
    // operations, specifically comparisons and subtractions, use the
    // monotonic clock reading.
    //
    // For example, this code always computes a positive elapsed time of
    // approximately 20 milliseconds, even if the wall clock is changed during
    // the operation being timed:
    //
    //	start := time.Now()
    //	... operation that takes 20 milliseconds ...
    //	t := time.Now()
    //	elapsed := t.Sub(start)
    //
    // Other idioms, such as time.Since(start), time.Until(deadline), and
    // time.Now().Before(deadline), are similarly robust against wall clock
    // resets.
    //
    // The rest of this section gives the precise details of how operations
    // use monotonic clocks, but understanding those details is not required
    // to use this package.
    //
    // The Time returned by time.Now contains a monotonic clock reading.
    // If Time t has a monotonic clock reading, t.Add adds the same duration to
    // both the wall clock and monotonic clock readings to compute the result.
    // Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time
    // computations, they always strip any monotonic clock reading from their results.
    // Because t.In, t.Local, and t.UTC are used for their effect on the interpretation
    // of the wall time, they also strip any monotonic clock reading from their results.
    // The canonical way to strip a monotonic clock reading is to use t = t.Round(0).
    //
    // If Times t and u both contain monotonic clock readings, the operations
    // t.After(u), t.Before(u), t.Equal(u), t.Compare(u), and t.Sub(u) are carried out
    // using the monotonic clock readings alone, ignoring the wall clock
    // readings. If either t or u contains no monotonic clock reading, these
    // operations fall back to using the wall clock readings.
    //
    // On some systems the monotonic clock will stop if the computer goes to sleep.
    // On such a system, t.Sub(u) may not accurately reflect the actual
    // time that passed between t and u.
    //
    // Because the monotonic clock reading has no meaning outside
    // the current process, the serialized forms generated by t.GobEncode,
    // t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic
    // clock reading, and t.Format provides no format for it. Similarly, the
    // constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix,
    // as well as the unmarshalers t.GobDecode, t.UnmarshalBinary.
    // t.UnmarshalJSON, and t.UnmarshalText always create times with
    // no monotonic clock reading.
    //
    // The monotonic clock reading exists only in Time values. It is not
    // a part of Duration values or the Unix times returned by t.Unix and
    // friends.
    //
    // Note that the Go == operator compares not just the time instant but
    // also the Location and the monotonic clock reading. See the
    // documentation for the Time type for a discussion of equality
    // testing for Time values.
    //
    // For debugging, the result of t.String does include the monotonic
    // clock reading if present. If t != u because of different monotonic clock readings,
    // that difference will be visible when printing t.String() and u.String().
**/
private var __go2hxdoc__package : Bool;
var utc(get, set) : stdgo._internal.time.Time.Location;
function get_utc():stdgo._internal.time.Time.Location return stdgo._internal.time.Time.utc;
function set_utc(v:stdgo._internal.time.Time.Location):stdgo._internal.time.Time.Location return stdgo._internal.time.Time.utc = v;
var local(get, set) : stdgo._internal.time.Time.Location;
function get_local():stdgo._internal.time.Time.Location return stdgo._internal.time.Time.local;
function set_local(v:stdgo._internal.time.Time.Location):stdgo._internal.time.Time.Location return stdgo._internal.time.Time.local = v;
var gorootZoneSource(get, set) : stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : Bool; };
function get_gorootZoneSource():stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : Bool; } return stdgo._internal.time.Time.gorootZoneSource;
function set_gorootZoneSource(v:stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : Bool; }):stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : Bool; } return stdgo._internal.time.Time.gorootZoneSource = v;
var parseTimeZone(get, set) : stdgo.GoString -> { var _0 : stdgo.GoInt; var _1 : Bool; };
function get_parseTimeZone():stdgo.GoString -> { var _0 : stdgo.GoInt; var _1 : Bool; } return stdgo._internal.time.Time.parseTimeZone;
function set_parseTimeZone(v:stdgo.GoString -> { var _0 : stdgo.GoInt; var _1 : Bool; }):stdgo.GoString -> { var _0 : stdgo.GoInt; var _1 : Bool; } return stdgo._internal.time.Time.parseTimeZone = v;
var setMono(get, set) : (stdgo.Ref<stdgo._internal.time.Time.Time>, stdgo.GoInt64) -> Void;
function get_setMono():(stdgo.Ref<stdgo._internal.time.Time.Time>, stdgo.GoInt64) -> Void return stdgo._internal.time.Time.setMono;
function set_setMono(v:(stdgo.Ref<stdgo._internal.time.Time.Time>, stdgo.GoInt64) -> Void):(stdgo.Ref<stdgo._internal.time.Time.Time>, stdgo.GoInt64) -> Void return stdgo._internal.time.Time.setMono = v;
var getMono(get, set) : stdgo.Ref<stdgo._internal.time.Time.Time> -> stdgo.GoInt64;
function get_getMono():stdgo.Ref<stdgo._internal.time.Time.Time> -> stdgo.GoInt64 return stdgo._internal.time.Time.getMono;
function set_getMono(v:stdgo.Ref<stdgo._internal.time.Time.Time> -> stdgo.GoInt64):stdgo.Ref<stdgo._internal.time.Time.Time> -> stdgo.GoInt64 return stdgo._internal.time.Time.getMono = v;
var errLocation(get, set) : stdgo.Error;
function get_errLocation():stdgo.Error return stdgo._internal.time.Time.errLocation;
function set_errLocation(v:stdgo.Error):stdgo.Error return stdgo._internal.time.Time.errLocation = v;
var readFile(get, set) : stdgo.GoString -> { var _0 : stdgo.Slice<stdgo.GoUInt8>; var _1 : stdgo.Error; };
function get_readFile():stdgo.GoString -> { var _0 : stdgo.Slice<stdgo.GoUInt8>; var _1 : stdgo.Error; } return stdgo._internal.time.Time.readFile;
function set_readFile(v:stdgo.GoString -> { var _0 : stdgo.Slice<stdgo.GoUInt8>; var _1 : stdgo.Error; }):stdgo.GoString -> { var _0 : stdgo.Slice<stdgo.GoUInt8>; var _1 : stdgo.Error; } return stdgo._internal.time.Time.readFile = v;
var loadTzinfo(get, set) : (stdgo.GoString, stdgo.GoString) -> { var _0 : stdgo.Slice<stdgo.GoUInt8>; var _1 : stdgo.Error; };
function get_loadTzinfo():(stdgo.GoString, stdgo.GoString) -> { var _0 : stdgo.Slice<stdgo.GoUInt8>; var _1 : stdgo.Error; } return stdgo._internal.time.Time.loadTzinfo;
function set_loadTzinfo(v:(stdgo.GoString, stdgo.GoString) -> { var _0 : stdgo.Slice<stdgo.GoUInt8>; var _1 : stdgo.Error; }):(stdgo.GoString, stdgo.GoString) -> { var _0 : stdgo.Slice<stdgo.GoUInt8>; var _1 : stdgo.Error; } return stdgo._internal.time.Time.loadTzinfo = v;
var nextStdChunk(get, set) : stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoString; };
function get_nextStdChunk():stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoString; } return stdgo._internal.time.Time.nextStdChunk;
function set_nextStdChunk(v:stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoString; }):stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoString; } return stdgo._internal.time.Time.nextStdChunk = v;
var tzset(get, set) : (stdgo.GoString, stdgo.GoInt64, stdgo.GoInt64) -> { var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoInt64; var _3 : stdgo.GoInt64; var _4 : Bool; var _5 : Bool; };
function get_tzset():(stdgo.GoString, stdgo.GoInt64, stdgo.GoInt64) -> { var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoInt64; var _3 : stdgo.GoInt64; var _4 : Bool; var _5 : Bool; } return stdgo._internal.time.Time.tzset;
function set_tzset(v:(stdgo.GoString, stdgo.GoInt64, stdgo.GoInt64) -> { var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoInt64; var _3 : stdgo.GoInt64; var _4 : Bool; var _5 : Bool; }):(stdgo.GoString, stdgo.GoInt64, stdgo.GoInt64) -> { var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoInt64; var _3 : stdgo.GoInt64; var _4 : Bool; var _5 : Bool; } return stdgo._internal.time.Time.tzset = v;
var tzsetName(get, set) : stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : stdgo.GoString; var _2 : Bool; };
function get_tzsetName():stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : stdgo.GoString; var _2 : Bool; } return stdgo._internal.time.Time.tzsetName;
function set_tzsetName(v:stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : stdgo.GoString; var _2 : Bool; }):stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : stdgo.GoString; var _2 : Bool; } return stdgo._internal.time.Time.tzsetName = v;
var tzsetOffset(get, set) : stdgo.GoString -> { var _0 : stdgo.GoInt; var _1 : stdgo.GoString; var _2 : Bool; };
function get_tzsetOffset():stdgo.GoString -> { var _0 : stdgo.GoInt; var _1 : stdgo.GoString; var _2 : Bool; } return stdgo._internal.time.Time.tzsetOffset;
function set_tzsetOffset(v:stdgo.GoString -> { var _0 : stdgo.GoInt; var _1 : stdgo.GoString; var _2 : Bool; }):stdgo.GoString -> { var _0 : stdgo.GoInt; var _1 : stdgo.GoString; var _2 : Bool; } return stdgo._internal.time.Time.tzsetOffset = v;
var stdChunkNames(get, set) : stdgo.GoMap<stdgo.GoInt, stdgo.GoString>;
function get_stdChunkNames():stdgo.GoMap<stdgo.GoInt, stdgo.GoString> return stdgo._internal.time.Time.stdChunkNames;
function set_stdChunkNames(v:stdgo.GoMap<stdgo.GoInt, stdgo.GoString>):stdgo.GoMap<stdgo.GoInt, stdgo.GoString> return stdgo._internal.time.Time.stdChunkNames = v;
var quote(get, set) : stdgo.GoString -> stdgo.GoString;
function get_quote():stdgo.GoString -> stdgo.GoString return stdgo._internal.time.Time.quote;
function set_quote(v:stdgo.GoString -> stdgo.GoString):stdgo.GoString -> stdgo.GoString return stdgo._internal.time.Time.quote = v;
var appendInt(get, set) : (stdgo.Slice<stdgo.GoUInt8>, stdgo.GoInt, stdgo.GoInt) -> stdgo.Slice<stdgo.GoUInt8>;
function get_appendInt():(stdgo.Slice<stdgo.GoUInt8>, stdgo.GoInt, stdgo.GoInt) -> stdgo.Slice<stdgo.GoUInt8> return stdgo._internal.time.Time.appendInt;
function set_appendInt(v:(stdgo.Slice<stdgo.GoUInt8>, stdgo.GoInt, stdgo.GoInt) -> stdgo.Slice<stdgo.GoUInt8>):(stdgo.Slice<stdgo.GoUInt8>, stdgo.GoInt, stdgo.GoInt) -> stdgo.Slice<stdgo.GoUInt8> return stdgo._internal.time.Time.appendInt = v;
var appendFormatAny(get, set) : (stdgo._internal.time.Time.Time, stdgo.Slice<stdgo.GoUInt8>, stdgo.GoString) -> stdgo.Slice<stdgo.GoUInt8>;
function get_appendFormatAny():(stdgo._internal.time.Time.Time, stdgo.Slice<stdgo.GoUInt8>, stdgo.GoString) -> stdgo.Slice<stdgo.GoUInt8> return stdgo._internal.time.Time.appendFormatAny;
function set_appendFormatAny(v:(stdgo._internal.time.Time.Time, stdgo.Slice<stdgo.GoUInt8>, stdgo.GoString) -> stdgo.Slice<stdgo.GoUInt8>):(stdgo._internal.time.Time.Time, stdgo.Slice<stdgo.GoUInt8>, stdgo.GoString) -> stdgo.Slice<stdgo.GoUInt8> return stdgo._internal.time.Time.appendFormatAny = v;
var appendFormatRFC3339(get, set) : (stdgo._internal.time.Time.Time, stdgo.Slice<stdgo.GoUInt8>, Bool) -> stdgo.Slice<stdgo.GoUInt8>;
function get_appendFormatRFC3339():(stdgo._internal.time.Time.Time, stdgo.Slice<stdgo.GoUInt8>, Bool) -> stdgo.Slice<stdgo.GoUInt8> return stdgo._internal.time.Time.appendFormatRFC3339;
function set_appendFormatRFC3339(v:(stdgo._internal.time.Time.Time, stdgo.Slice<stdgo.GoUInt8>, Bool) -> stdgo.Slice<stdgo.GoUInt8>):(stdgo._internal.time.Time.Time, stdgo.Slice<stdgo.GoUInt8>, Bool) -> stdgo.Slice<stdgo.GoUInt8> return stdgo._internal.time.Time.appendFormatRFC3339 = v;
var parseAny(get, set) : (stdgo.GoString, stdgo.GoString, stdgo.Ref<stdgo._internal.time.Time.Location>, stdgo.Ref<stdgo._internal.time.Time.Location>) -> { var _0 : stdgo._internal.time.Time.Time; var _1 : stdgo.Error; };
function get_parseAny():(stdgo.GoString, stdgo.GoString, stdgo.Ref<stdgo._internal.time.Time.Location>, stdgo.Ref<stdgo._internal.time.Time.Location>) -> { var _0 : stdgo._internal.time.Time.Time; var _1 : stdgo.Error; } return stdgo._internal.time.Time.parseAny;
function set_parseAny(v:(stdgo.GoString, stdgo.GoString, stdgo.Ref<stdgo._internal.time.Time.Location>, stdgo.Ref<stdgo._internal.time.Time.Location>) -> { var _0 : stdgo._internal.time.Time.Time; var _1 : stdgo.Error; }):(stdgo.GoString, stdgo.GoString, stdgo.Ref<stdgo._internal.time.Time.Location>, stdgo.Ref<stdgo._internal.time.Time.Location>) -> { var _0 : stdgo._internal.time.Time.Time; var _1 : stdgo.Error; } return stdgo._internal.time.Time.parseAny = v;
var parseRFC3339(get, set) : (stdgo.GoString, stdgo.Ref<stdgo._internal.time.Time.Location>) -> { var _0 : stdgo._internal.time.Time.Time; var _1 : Bool; };
function get_parseRFC3339():(stdgo.GoString, stdgo.Ref<stdgo._internal.time.Time.Location>) -> { var _0 : stdgo._internal.time.Time.Time; var _1 : Bool; } return stdgo._internal.time.Time.parseRFC3339;
function set_parseRFC3339(v:(stdgo.GoString, stdgo.Ref<stdgo._internal.time.Time.Location>) -> { var _0 : stdgo._internal.time.Time.Time; var _1 : Bool; }):(stdgo.GoString, stdgo.Ref<stdgo._internal.time.Time.Location>) -> { var _0 : stdgo._internal.time.Time.Time; var _1 : Bool; } return stdgo._internal.time.Time.parseRFC3339 = v;
var disablePlatformSources(get, set) : () -> (() -> Void);
function get_disablePlatformSources():() -> (() -> Void) return stdgo._internal.time.Time.disablePlatformSources;
function set_disablePlatformSources(v:() -> (() -> Void)):() -> (() -> Void) return stdgo._internal.time.Time.disablePlatformSources = v;
var interrupt(get, set) : () -> Void;
function get_interrupt():() -> Void return stdgo._internal.time.Time.interrupt;
function set_interrupt(v:() -> Void):() -> Void return stdgo._internal.time.Time.interrupt = v;
var daysIn(get, set) : (stdgo._internal.time.Time.Month, stdgo.GoInt) -> stdgo.GoInt;
function get_daysIn():(stdgo._internal.time.Time.Month, stdgo.GoInt) -> stdgo.GoInt return stdgo._internal.time.Time.daysIn;
function set_daysIn(v:(stdgo._internal.time.Time.Month, stdgo.GoInt) -> stdgo.GoInt):(stdgo._internal.time.Time.Month, stdgo.GoInt) -> stdgo.GoInt return stdgo._internal.time.Time.daysIn = v;
var minMonoTime(get, set) : stdgo._internal.time.Time.Time;
function get_minMonoTime():stdgo._internal.time.Time.Time return stdgo._internal.time.Time.minMonoTime;
function set_minMonoTime(v:stdgo._internal.time.Time.Time):stdgo._internal.time.Time.Time return stdgo._internal.time.Time.minMonoTime = v;
var maxMonoTime(get, set) : stdgo._internal.time.Time.Time;
function get_maxMonoTime():stdgo._internal.time.Time.Time return stdgo._internal.time.Time.maxMonoTime;
function set_maxMonoTime(v:stdgo._internal.time.Time.Time):stdgo._internal.time.Time.Time return stdgo._internal.time.Time.maxMonoTime = v;
var notMonoNegativeTime(get, set) : stdgo._internal.time.Time.Time;
function get_notMonoNegativeTime():stdgo._internal.time.Time.Time return stdgo._internal.time.Time.notMonoNegativeTime;
function set_notMonoNegativeTime(v:stdgo._internal.time.Time.Time):stdgo._internal.time.Time.Time return stdgo._internal.time.Time.notMonoNegativeTime = v;
final ruleJulian : stdgo._internal.time.Time.RuleKind = stdgo._internal.time.Time.ruleJulian;
final ruleDOY : stdgo._internal.time.Time.RuleKind = stdgo._internal.time.Time.ruleDOY;
final ruleMonthWeekDay : stdgo._internal.time.Time.RuleKind = stdgo._internal.time.Time.ruleMonthWeekDay;
final unixToInternal : haxe.Int64 = stdgo._internal.time.Time.unixToInternal;
final layout : String = stdgo._internal.time.Time.layout;
final ansic : String = stdgo._internal.time.Time.ansic;
final unixDate : String = stdgo._internal.time.Time.unixDate;
final rubyDate : String = stdgo._internal.time.Time.rubyDate;
final rfc822 : String = stdgo._internal.time.Time.rfc822;
final rfc822z : String = stdgo._internal.time.Time.rfc822z;
final rfc850 : String = stdgo._internal.time.Time.rfc850;
final rfc1123 : String = stdgo._internal.time.Time.rfc1123;
final rfc1123z : String = stdgo._internal.time.Time.rfc1123z;
final rfc3339 : String = stdgo._internal.time.Time.rfc3339;
final rfc3339nano : String = stdgo._internal.time.Time.rfc3339nano;
final kitchen : String = stdgo._internal.time.Time.kitchen;
final stamp : String = stdgo._internal.time.Time.stamp;
final stampMilli : String = stdgo._internal.time.Time.stampMilli;
final stampMicro : String = stdgo._internal.time.Time.stampMicro;
final stampNano : String = stdgo._internal.time.Time.stampNano;
final dateTime : String = stdgo._internal.time.Time.dateTime;
final dateOnly : String = stdgo._internal.time.Time.dateOnly;
final timeOnly : String = stdgo._internal.time.Time.timeOnly;
final january : stdgo._internal.time.Time.Month = stdgo._internal.time.Time.january;
final february = stdgo._internal.time.Time.february;
final march = stdgo._internal.time.Time.march;
final april = stdgo._internal.time.Time.april;
final may = stdgo._internal.time.Time.may;
final june = stdgo._internal.time.Time.june;
final july = stdgo._internal.time.Time.july;
final august = stdgo._internal.time.Time.august;
final september = stdgo._internal.time.Time.september;
final october = stdgo._internal.time.Time.october;
final november = stdgo._internal.time.Time.november;
final december = stdgo._internal.time.Time.december;
final sunday : stdgo._internal.time.Time.Weekday = stdgo._internal.time.Time.sunday;
final monday = stdgo._internal.time.Time.monday;
final tuesday = stdgo._internal.time.Time.tuesday;
final wednesday = stdgo._internal.time.Time.wednesday;
final thursday = stdgo._internal.time.Time.thursday;
final friday = stdgo._internal.time.Time.friday;
final saturday = stdgo._internal.time.Time.saturday;
final nanosecond : stdgo._internal.time.Time.Duration = stdgo._internal.time.Time.nanosecond;
final microsecond : stdgo._internal.time.Time.Duration = stdgo._internal.time.Time.microsecond;
final millisecond : stdgo._internal.time.Time.Duration = stdgo._internal.time.Time.millisecond;
final second : stdgo._internal.time.Time.Duration = stdgo._internal.time.Time.second;
final minute : stdgo._internal.time.Time.Duration = stdgo._internal.time.Time.minute;
final hour : stdgo._internal.time.Time.Duration = stdgo._internal.time.Time.hour;
@:invalid typedef Rule = Dynamic;
@:invalid typedef ParseError = Dynamic;
@:invalid typedef T_runtimeTimer = Dynamic;
@:invalid typedef Timer = Dynamic;
@:invalid typedef Ticker = Dynamic;
@:invalid typedef Time = Dynamic;
@:invalid typedef Location = Dynamic;
@:invalid typedef T_zone = Dynamic;
@:invalid typedef T_zoneTrans = Dynamic;
@:invalid typedef T_rule = Dynamic;
@:invalid typedef T_dataIO = Dynamic;
typedef RuleKind = stdgo._internal.time.Time.RuleKind;
typedef Month = stdgo._internal.time.Time.Month;
typedef Weekday = stdgo._internal.time.Time.Weekday;
typedef Duration = stdgo._internal.time.Time.Duration;
typedef T_ruleKind = stdgo._internal.time.Time.T_ruleKind;
typedef T_fileSizeError = stdgo._internal.time.Time.T_fileSizeError;
inline function resetLocalOnceForTest():Void throw "not implemented";
inline function forceUSPacificForTesting():Void throw "not implemented";
inline function zoneinfoForTesting():stdgo.Pointer<String> throw "not implemented";
inline function resetZoneinfoForTesting():Void throw "not implemented";
inline function loadFromEmbeddedTZData(zone:String):stdgo.Tuple.<String, stdgo.Error> throw "not implemented";
inline function tzsetRule(s:String):stdgo.Tuple.Tuple3<Rule, String, Bool> throw "not implemented";
/**
    // Parse parses a formatted string and returns the time value it represents.
    // See the documentation for the constant called Layout to see how to
    // represent the format. The second argument must be parseable using
    // the format string (layout) provided as the first argument.
    //
    // The example for Time.Format demonstrates the working of the layout string
    // in detail and is a good reference.
    //
    // When parsing (only), the input may contain a fractional second
    // field immediately after the seconds field, even if the layout does not
    // signify its presence. In that case either a comma or a decimal point
    // followed by a maximal series of digits is parsed as a fractional second.
    // Fractional seconds are truncated to nanosecond precision.
    //
    // Elements omitted from the layout are assumed to be zero or, when
    // zero is impossible, one, so parsing "3:04pm" returns the time
    // corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is
    // 0, this time is before the zero Time).
    // Years must be in the range 0000..9999. The day of the week is checked
    // for syntax but it is otherwise ignored.
    //
    // For layouts specifying the two-digit year 06, a value NN >= 69 will be treated
    // as 19NN and a value NN < 69 will be treated as 20NN.
    //
    // The remainder of this comment describes the handling of time zones.
    //
    // In the absence of a time zone indicator, Parse returns a time in UTC.
    //
    // When parsing a time with a zone offset like -0700, if the offset corresponds
    // to a time zone used by the current location (Local), then Parse uses that
    // location and zone in the returned time. Otherwise it records the time as
    // being in a fabricated location with time fixed at the given zone offset.
    //
    // When parsing a time with a zone abbreviation like MST, if the zone abbreviation
    // has a defined offset in the current location, then that offset is used.
    // The zone abbreviation "UTC" is recognized as UTC regardless of location.
    // If the zone abbreviation is unknown, Parse records the time as being
    // in a fabricated location with the given zone abbreviation and a zero offset.
    // This choice means that such a time can be parsed and reformatted with the
    // same layout losslessly, but the exact instant used in the representation will
    // differ by the actual zone offset. To avoid such problems, prefer time layouts
    // that use a numeric zone offset, or use ParseInLocation.
**/
inline function parse(layout:String, value:String):stdgo.Tuple.<Time, stdgo.Error> throw "not implemented";
/**
    // ParseInLocation is like Parse but differs in two important ways.
    // First, in the absence of time zone information, Parse interprets a time as UTC;
    // ParseInLocation interprets the time as in the given location.
    // Second, when given a zone offset or abbreviation, Parse tries to match it
    // against the Local location; ParseInLocation uses the given location.
**/
inline function parseInLocation(layout:String, value:String, loc:Location):stdgo.Tuple.<Time, stdgo.Error> throw "not implemented";
/**
    // ParseDuration parses a duration string.
    // A duration string is a possibly signed sequence of
    // decimal numbers, each with optional fraction and a unit suffix,
    // such as "300ms", "-1.5h" or "2h45m".
    // Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
**/
inline function parseDuration(s:String):stdgo.Tuple.<Duration, stdgo.Error> throw "not implemented";
/**
    // Test that a runtimeTimer with a period that would overflow when on
    // expiration does not throw or cause other timers to hang.
    //
    // This test has to be in internal_test.go since it fiddles with
    // unexported data structures.
**/
inline function checkRuntimeTimerPeriodOverflow():Void throw "not implemented";
/**
    // Sleep pauses the current goroutine for at least the duration d.
    // A negative or zero duration causes Sleep to return immediately.
**/
inline function sleep(d:Duration):Void throw "not implemented";
/**
    // NewTimer creates a new Timer that will send
    // the current time on its channel after at least duration d.
**/
inline function newTimer(d:Duration):Timer throw "not implemented";
/**
    // After waits for the duration to elapse and then sends the current time
    // on the returned channel.
    // It is equivalent to NewTimer(d).C.
    // The underlying Timer is not recovered by the garbage collector
    // until the timer fires. If efficiency is a concern, use NewTimer
    // instead and call Timer.Stop if the timer is no longer needed.
**/
inline function after(d:Duration):stdgo.Chan<Time> throw "not implemented";
/**
    // AfterFunc waits for the duration to elapse and then calls f
    // in its own goroutine. It returns a Timer that can
    // be used to cancel the call using its Stop method.
**/
inline function afterFunc(d:Duration, f:() -> Void):Timer throw "not implemented";
/**
    // NewTicker returns a new Ticker containing a channel that will send
    // the current time on the channel after each tick. The period of the
    // ticks is specified by the duration argument. The ticker will adjust
    // the time interval or drop ticks to make up for slow receivers.
    // The duration d must be greater than zero; if not, NewTicker will
    // panic. Stop the ticker to release associated resources.
**/
inline function newTicker(d:Duration):Ticker throw "not implemented";
/**
    // Tick is a convenience wrapper for NewTicker providing access to the ticking
    // channel only. While Tick is useful for clients that have no need to shut down
    // the Ticker, be aware that without a way to shut it down the underlying
    // Ticker cannot be recovered by the garbage collector; it "leaks".
    // Unlike NewTicker, Tick will return nil if d <= 0.
**/
inline function tick(d:Duration):stdgo.Chan<Time> throw "not implemented";
/**
    // Since returns the time elapsed since t.
    // It is shorthand for time.Now().Sub(t).
**/
inline function since(t:Time):Duration throw "not implemented";
/**
    // Until returns the duration until t.
    // It is shorthand for t.Sub(time.Now()).
**/
inline function until(t:Time):Duration throw "not implemented";
/**
    // Now returns the current local time.
**/
inline function now():Time throw "not implemented";
/**
    // Unix returns the local Time corresponding to the given Unix time,
    // sec seconds and nsec nanoseconds since January 1, 1970 UTC.
    // It is valid to pass nsec outside the range [0, 999999999].
    // Not all sec values have a corresponding time value. One such
    // value is 1<<63-1 (the largest int64 value).
**/
inline function unix(sec:haxe.Int64, nsec:haxe.Int64):Time throw "not implemented";
/**
    // UnixMilli returns the local Time corresponding to the given Unix time,
    // msec milliseconds since January 1, 1970 UTC.
**/
inline function unixMilli(msec:haxe.Int64):Time throw "not implemented";
/**
    // UnixMicro returns the local Time corresponding to the given Unix time,
    // usec microseconds since January 1, 1970 UTC.
**/
inline function unixMicro(usec:haxe.Int64):Time throw "not implemented";
/**
    // Date returns the Time corresponding to
    //
    //	yyyy-mm-dd hh:mm:ss + nsec nanoseconds
    //
    // in the appropriate zone for that time in the given location.
    //
    // The month, day, hour, min, sec, and nsec values may be outside
    // their usual ranges and will be normalized during the conversion.
    // For example, October 32 converts to November 1.
    //
    // A daylight savings time transition skips or repeats times.
    // For example, in the United States, March 13, 2011 2:15am never occurred,
    // while November 6, 2011 1:15am occurred twice. In such cases, the
    // choice of time zone, and therefore the time, is not well-defined.
    // Date returns a time that is correct in one of the two zones involved
    // in the transition, but it does not guarantee which.
    //
    // Date panics if loc is nil.
**/
inline function date(year:Int, month:Month, day:Int, hour:Int, min:Int, sec:Int, nsec:Int, loc:Location):Time throw "not implemented";
/**
    // FixedZone returns a Location that always uses
    // the given zone name and offset (seconds east of UTC).
**/
inline function fixedZone(name:String, offset:Int):Location throw "not implemented";
/**
    // LoadLocation returns the Location with the given name.
    //
    // If the name is "" or "UTC", LoadLocation returns UTC.
    // If the name is "Local", LoadLocation returns Local.
    //
    // Otherwise, the name is taken to be a location name corresponding to a file
    // in the IANA Time Zone database, such as "America/New_York".
    //
    // LoadLocation looks for the IANA Time Zone database in the following
    // locations in order:
    //
    //   - the directory or uncompressed zip file named by the ZONEINFO environment variable
    //   - on a Unix system, the system standard installation location
    //   - $GOROOT/lib/time/zoneinfo.zip
    //   - the time/tzdata package, if it was imported
**/
inline function loadLocation(name:String):stdgo.Tuple.<Location, stdgo.Error> throw "not implemented";
/**
    // LoadLocationFromTZData returns a Location with the given name
    // initialized from the IANA Time Zone database-formatted data.
    // The data should be in the format of a standard IANA time zone file
    // (for example, the content of /etc/localtime on Unix systems).
**/
inline function loadLocationFromTZData(name:String, data:Array<Int>):stdgo.Tuple.<Location, stdgo.Error> throw "not implemented";
@:invalid typedef ParseError_asInterface = Dynamic;
@:invalid typedef ParseError_static_extension = Dynamic;
@:invalid typedef Timer_asInterface = Dynamic;
@:invalid typedef Timer_static_extension = Dynamic;
@:invalid typedef Ticker_asInterface = Dynamic;
@:invalid typedef Ticker_static_extension = Dynamic;
@:invalid typedef Time_asInterface = Dynamic;
@:invalid typedef Time_static_extension = Dynamic;
@:invalid typedef Location_asInterface = Dynamic;
@:invalid typedef Location_static_extension = Dynamic;
@:invalid typedef T_dataIO_asInterface = Dynamic;
@:invalid typedef T_dataIO_static_extension = Dynamic;
@:invalid typedef Month_asInterface = Dynamic;
@:invalid typedef Month_static_extension = Dynamic;
@:invalid typedef Weekday_asInterface = Dynamic;
@:invalid typedef Weekday_static_extension = Dynamic;
@:invalid typedef Duration_asInterface = Dynamic;
@:invalid typedef Duration_static_extension = Dynamic;
@:invalid typedef T_fileSizeError_asInterface = Dynamic;
@:invalid typedef T_fileSizeError_static_extension = Dynamic;
