package stdgo.time;
/**
    // Package time provides functionality for measuring and displaying time.
    //
    // The calendrical calculations always assume a Gregorian calendar, with
    // no leap seconds.
    //
    // # Monotonic Clocks
    //
    // Operating systems provide both a “wall clock,” which is subject to
    // changes for clock synchronization, and a “monotonic clock,” which is
    // not. The general rule is that the wall clock is for telling time and
    // the monotonic clock is for measuring time. Rather than split the API,
    // in this package the Time returned by time.Now contains both a wall
    // clock reading and a monotonic clock reading; later time-telling
    // operations use the wall clock reading, but later time-measuring
    // operations, specifically comparisons and subtractions, use the
    // monotonic clock reading.
    //
    // For example, this code always computes a positive elapsed time of
    // approximately 20 milliseconds, even if the wall clock is changed during
    // the operation being timed:
    //
    //	start := time.Now()
    //	... operation that takes 20 milliseconds ...
    //	t := time.Now()
    //	elapsed := t.Sub(start)
    //
    // Other idioms, such as time.Since(start), time.Until(deadline), and
    // time.Now().Before(deadline), are similarly robust against wall clock
    // resets.
    //
    // The rest of this section gives the precise details of how operations
    // use monotonic clocks, but understanding those details is not required
    // to use this package.
    //
    // The Time returned by time.Now contains a monotonic clock reading.
    // If Time t has a monotonic clock reading, t.Add adds the same duration to
    // both the wall clock and monotonic clock readings to compute the result.
    // Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time
    // computations, they always strip any monotonic clock reading from their results.
    // Because t.In, t.Local, and t.UTC are used for their effect on the interpretation
    // of the wall time, they also strip any monotonic clock reading from their results.
    // The canonical way to strip a monotonic clock reading is to use t = t.Round(0).
    //
    // If Times t and u both contain monotonic clock readings, the operations
    // t.After(u), t.Before(u), t.Equal(u), t.Compare(u), and t.Sub(u) are carried out
    // using the monotonic clock readings alone, ignoring the wall clock
    // readings. If either t or u contains no monotonic clock reading, these
    // operations fall back to using the wall clock readings.
    //
    // On some systems the monotonic clock will stop if the computer goes to sleep.
    // On such a system, t.Sub(u) may not accurately reflect the actual
    // time that passed between t and u.
    //
    // Because the monotonic clock reading has no meaning outside
    // the current process, the serialized forms generated by t.GobEncode,
    // t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic
    // clock reading, and t.Format provides no format for it. Similarly, the
    // constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix,
    // as well as the unmarshalers t.GobDecode, t.UnmarshalBinary.
    // t.UnmarshalJSON, and t.UnmarshalText always create times with
    // no monotonic clock reading.
    //
    // The monotonic clock reading exists only in Time values. It is not
    // a part of Duration values or the Unix times returned by t.Unix and
    // friends.
    //
    // Note that the Go == operator compares not just the time instant but
    // also the Location and the monotonic clock reading. See the
    // documentation for the Time type for a discussion of equality
    // testing for Time values.
    //
    // For debugging, the result of t.String does include the monotonic
    // clock reading if present. If t != u because of different monotonic clock readings,
    // that difference will be visible when printing t.String() and u.String().
**/
private var __go2hxdoc__package : Bool;
/**
    
    
    
**/
var disablePlatformSources : () -> (() -> Void) = _disablePlatformSources;
/**
    
    
    
**/
var gorootZoneSource : stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : Bool; } = _gorootZoneSource;
/**
    
    
    
**/
var parseTimeZone : stdgo.GoString -> { var _0 : stdgo.GoInt; var _1 : Bool; } = _parseTimeZone;
/**
    
    
    
**/
var setMono : (stdgo.Ref<stdgo.time.Time.Time>, stdgo.GoInt64) -> Void = Time_static_extension._setMono;
/**
    
    
    
**/
var getMono : stdgo.Ref<stdgo.time.Time.Time> -> stdgo.GoInt64 = Time_static_extension._mono;
/**
    
    
    
**/
var errLocation : stdgo.Error = _errLocation;
/**
    
    
    
**/
var readFile : stdgo.GoString -> { var _0 : stdgo.Slice<stdgo.GoUInt8>; var _1 : stdgo.Error; } = _readFile;
/**
    
    
    
**/
var loadTzinfo : (stdgo.GoString, stdgo.GoString) -> { var _0 : stdgo.Slice<stdgo.GoUInt8>; var _1 : stdgo.Error; } = _loadTzinfo;
/**
    
    
    
**/
var nextStdChunk : stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoString; } = _nextStdChunk;
/**
    
    
    
**/
var tzset : (stdgo.GoString, stdgo.GoInt64, stdgo.GoInt64) -> { var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoInt64; var _3 : stdgo.GoInt64; var _4 : Bool; var _5 : Bool; } = _tzset;
/**
    
    
    
**/
var tzsetName : stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : stdgo.GoString; var _2 : Bool; } = _tzsetName;
/**
    
    
    
**/
var tzsetOffset : stdgo.GoString -> { var _0 : stdgo.GoInt; var _1 : stdgo.GoString; var _2 : Bool; } = _tzsetOffset;
/**
    
    
    
**/
final ruleJulian : stdgo.time.Time.RuleKind = ((0 : stdgo.time.Time.T_ruleKind) : RuleKind);
/**
    
    
    
**/
final ruleDOY : stdgo.time.Time.RuleKind = ((1 : stdgo.time.Time.T_ruleKind) : RuleKind);
/**
    
    
    
**/
final ruleMonthWeekDay : stdgo.time.Time.RuleKind = ((2 : stdgo.time.Time.T_ruleKind) : RuleKind);
/**
    
    
    
**/
final unixToInternal : stdgo.GoInt64 = (62135596800i64 : stdgo.GoInt64);
/**
    // StdChunkNames maps from nextStdChunk results to the matched strings.
    
    
**/
var stdChunkNames : stdgo.GoMap<stdgo.GoInt, stdgo.GoString> = ({
        final x = new stdgo.GoMap.GoIntMap<stdgo.GoString>();
        x.__defaultValue__ = () -> ("" : stdgo.GoString);
        @:mergeBlock {
            x.set((0 : stdgo.GoInt), stdgo.Go.str());
            x.set((257 : stdgo.GoInt), ("January" : stdgo.GoString));
            x.set((258 : stdgo.GoInt), ("Jan" : stdgo.GoString));
            x.set((259 : stdgo.GoInt), ("1" : stdgo.GoString));
            x.set((260 : stdgo.GoInt), ("01" : stdgo.GoString));
            x.set((261 : stdgo.GoInt), ("Monday" : stdgo.GoString));
            x.set((262 : stdgo.GoInt), ("Mon" : stdgo.GoString));
            x.set((263 : stdgo.GoInt), ("2" : stdgo.GoString));
            x.set((264 : stdgo.GoInt), ("_2" : stdgo.GoString));
            x.set((265 : stdgo.GoInt), ("02" : stdgo.GoString));
            x.set((266 : stdgo.GoInt), ("__2" : stdgo.GoString));
            x.set((267 : stdgo.GoInt), ("002" : stdgo.GoString));
            x.set((524 : stdgo.GoInt), ("15" : stdgo.GoString));
            x.set((525 : stdgo.GoInt), ("3" : stdgo.GoString));
            x.set((526 : stdgo.GoInt), ("03" : stdgo.GoString));
            x.set((527 : stdgo.GoInt), ("4" : stdgo.GoString));
            x.set((528 : stdgo.GoInt), ("04" : stdgo.GoString));
            x.set((529 : stdgo.GoInt), ("5" : stdgo.GoString));
            x.set((530 : stdgo.GoInt), ("05" : stdgo.GoString));
            x.set((275 : stdgo.GoInt), ("2006" : stdgo.GoString));
            x.set((276 : stdgo.GoInt), ("06" : stdgo.GoString));
            x.set((533 : stdgo.GoInt), ("PM" : stdgo.GoString));
            x.set((534 : stdgo.GoInt), ("pm" : stdgo.GoString));
            x.set((23 : stdgo.GoInt), ("MST" : stdgo.GoString));
            x.set((24 : stdgo.GoInt), ("Z0700" : stdgo.GoString));
            x.set((25 : stdgo.GoInt), ("Z070000" : stdgo.GoString));
            x.set((26 : stdgo.GoInt), ("Z07" : stdgo.GoString));
            x.set((27 : stdgo.GoInt), ("Z07:00" : stdgo.GoString));
            x.set((28 : stdgo.GoInt), ("Z07:00:00" : stdgo.GoString));
            x.set((29 : stdgo.GoInt), ("-0700" : stdgo.GoString));
            x.set((30 : stdgo.GoInt), ("-070000" : stdgo.GoString));
            x.set((31 : stdgo.GoInt), ("-07" : stdgo.GoString));
            x.set((32 : stdgo.GoInt), ("-07:00" : stdgo.GoString));
            x.set((33 : stdgo.GoInt), ("-07:00:00" : stdgo.GoString));
            x.set((65570 : stdgo.GoInt), (".0" : stdgo.GoString));
            x.set((131106 : stdgo.GoInt), (".00" : stdgo.GoString));
            x.set((196642 : stdgo.GoInt), (".000" : stdgo.GoString));
            x.set((262178 : stdgo.GoInt), (".0000" : stdgo.GoString));
            x.set((327714 : stdgo.GoInt), (".00000" : stdgo.GoString));
            x.set((393250 : stdgo.GoInt), (".000000" : stdgo.GoString));
            x.set((458786 : stdgo.GoInt), (".0000000" : stdgo.GoString));
            x.set((524322 : stdgo.GoInt), (".00000000" : stdgo.GoString));
            x.set((589858 : stdgo.GoInt), (".000000000" : stdgo.GoString));
            x.set((65571 : stdgo.GoInt), (".9" : stdgo.GoString));
            x.set((131107 : stdgo.GoInt), (".99" : stdgo.GoString));
            x.set((196643 : stdgo.GoInt), (".999" : stdgo.GoString));
            x.set((262179 : stdgo.GoInt), (".9999" : stdgo.GoString));
            x.set((327715 : stdgo.GoInt), (".99999" : stdgo.GoString));
            x.set((393251 : stdgo.GoInt), (".999999" : stdgo.GoString));
            x.set((458787 : stdgo.GoInt), (".9999999" : stdgo.GoString));
            x.set((524323 : stdgo.GoInt), (".99999999" : stdgo.GoString));
            x.set((589859 : stdgo.GoInt), (".999999999" : stdgo.GoString));
        };
        x;
    } : stdgo.GoMap<stdgo.GoInt, stdgo.GoString>);
/**
    
    
    
**/
var quote : stdgo.GoString -> stdgo.GoString = _quote;
/**
    
    
    
**/
var appendInt : (stdgo.Slice<stdgo.GoUInt8>, stdgo.GoInt, stdgo.GoInt) -> stdgo.Slice<stdgo.GoUInt8> = _appendInt;
/**
    
    
    
**/
var appendFormatAny : (stdgo.time.Time.Time, stdgo.Slice<stdgo.GoUInt8>, stdgo.GoString) -> stdgo.Slice<stdgo.GoUInt8> = Time_static_extension._appendFormat;
/**
    
    
    
**/
var appendFormatRFC3339 : (stdgo.time.Time.Time, stdgo.Slice<stdgo.GoUInt8>, Bool) -> stdgo.Slice<stdgo.GoUInt8> = Time_static_extension._appendFormatRFC3339;
/**
    
    
    
**/
var parseAny : (stdgo.GoString, stdgo.GoString, stdgo.Ref<stdgo.time.Time.Location>, stdgo.Ref<stdgo.time.Time.Location>) -> { var _0 : stdgo.time.Time.Time; var _1 : stdgo.Error; } = _parse;
/**
    
    
    
**/
var parseRFC3339 : (stdgo.GoString, stdgo.Ref<stdgo.time.Time.Location>) -> { var _0 : stdgo.time.Time.Time; var _1 : Bool; } = function(s:stdgo.GoString, local:stdgo.Ref<stdgo.time.Time.Location>):{ var _0 : stdgo.time.Time.Time; var _1 : Bool; } return _parseRFC3339(("" : stdgo.GoString), s, local);
/**
    // These are predefined layouts for use in Time.Format and time.Parse.
    // The reference time used in these layouts is the specific time stamp:
    //
    //	01/02 03:04:05PM '06 -0700
    //
    // (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
    // That value is recorded as the constant named Layout, listed below. As a Unix
    // time, this is 1136239445. Since MST is GMT-0700, the reference would be
    // printed by the Unix date command as:
    //
    //	Mon Jan 2 15:04:05 MST 2006
    //
    // It is a regrettable historic error that the date uses the American convention
    // of putting the numerical month before the day.
    //
    // The example for Time.Format demonstrates the working of the layout string
    // in detail and is a good reference.
    //
    // Note that the RFC822, RFC850, and RFC1123 formats should be applied
    // only to local times. Applying them to UTC times will use "UTC" as the
    // time zone abbreviation, while strictly speaking those RFCs require the
    // use of "GMT" in that case.
    // In general RFC1123Z should be used instead of RFC1123 for servers
    // that insist on that format, and RFC3339 should be preferred for new protocols.
    // RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
    // when used with time.Parse they do not accept all the time formats
    // permitted by the RFCs and they do accept time formats not formally defined.
    // The RFC3339Nano format removes trailing zeros from the seconds field
    // and thus may not sort correctly once formatted.
    //
    // Most programs can use one of the defined constants as the layout passed to
    // Format or Parse. The rest of this comment can be ignored unless you are
    // creating a custom layout string.
    //
    // To define your own format, write down what the reference time would look like
    // formatted your way; see the values of constants like ANSIC, StampMicro or
    // Kitchen for examples. The model is to demonstrate what the reference time
    // looks like so that the Format and Parse methods can apply the same
    // transformation to a general time value.
    //
    // Here is a summary of the components of a layout string. Each element shows by
    // example the formatting of an element of the reference time. Only these values
    // are recognized. Text in the layout string that is not recognized as part of
    // the reference time is echoed verbatim during Format and expected to appear
    // verbatim in the input to Parse.
    //
    //	Year: "2006" "06"
    //	Month: "Jan" "January" "01" "1"
    //	Day of the week: "Mon" "Monday"
    //	Day of the month: "2" "_2" "02"
    //	Day of the year: "__2" "002"
    //	Hour: "15" "3" "03" (PM or AM)
    //	Minute: "4" "04"
    //	Second: "5" "05"
    //	AM/PM mark: "PM"
    //
    // Numeric time zone offsets format as follows:
    //
    //	"-0700"     ±hhmm
    //	"-07:00"    ±hh:mm
    //	"-07"       ±hh
    //	"-070000"   ±hhmmss
    //	"-07:00:00" ±hh:mm:ss
    //
    // Replacing the sign in the format with a Z triggers
    // the ISO 8601 behavior of printing Z instead of an
    // offset for the UTC zone. Thus:
    //
    //	"Z0700"      Z or ±hhmm
    //	"Z07:00"     Z or ±hh:mm
    //	"Z07"        Z or ±hh
    //	"Z070000"    Z or ±hhmmss
    //	"Z07:00:00"  Z or ±hh:mm:ss
    //
    // Within the format string, the underscores in "_2" and "__2" represent spaces
    // that may be replaced by digits if the following number has multiple digits,
    // for compatibility with fixed-width Unix time formats. A leading zero represents
    // a zero-padded value.
    //
    // The formats __2 and 002 are space-padded and zero-padded
    // three-character day of year; there is no unpadded day of year format.
    //
    // A comma or decimal point followed by one or more zeros represents
    // a fractional second, printed to the given number of decimal places.
    // A comma or decimal point followed by one or more nines represents
    // a fractional second, printed to the given number of decimal places, with
    // trailing zeros removed.
    // For example "15:04:05,000" or "15:04:05.000" formats or parses with
    // millisecond precision.
    //
    // Some valid layouts are invalid time values for time.Parse, due to formats
    // such as _ for space padding and Z for zone information.
    
    // The reference time, in numerical order.
**/
final layout : stdgo.GoString = ("01/02 03:04:05PM \'06 -0700" : stdgo.GoString);
/**
    // These are predefined layouts for use in Time.Format and time.Parse.
    // The reference time used in these layouts is the specific time stamp:
    //
    //	01/02 03:04:05PM '06 -0700
    //
    // (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
    // That value is recorded as the constant named Layout, listed below. As a Unix
    // time, this is 1136239445. Since MST is GMT-0700, the reference would be
    // printed by the Unix date command as:
    //
    //	Mon Jan 2 15:04:05 MST 2006
    //
    // It is a regrettable historic error that the date uses the American convention
    // of putting the numerical month before the day.
    //
    // The example for Time.Format demonstrates the working of the layout string
    // in detail and is a good reference.
    //
    // Note that the RFC822, RFC850, and RFC1123 formats should be applied
    // only to local times. Applying them to UTC times will use "UTC" as the
    // time zone abbreviation, while strictly speaking those RFCs require the
    // use of "GMT" in that case.
    // In general RFC1123Z should be used instead of RFC1123 for servers
    // that insist on that format, and RFC3339 should be preferred for new protocols.
    // RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
    // when used with time.Parse they do not accept all the time formats
    // permitted by the RFCs and they do accept time formats not formally defined.
    // The RFC3339Nano format removes trailing zeros from the seconds field
    // and thus may not sort correctly once formatted.
    //
    // Most programs can use one of the defined constants as the layout passed to
    // Format or Parse. The rest of this comment can be ignored unless you are
    // creating a custom layout string.
    //
    // To define your own format, write down what the reference time would look like
    // formatted your way; see the values of constants like ANSIC, StampMicro or
    // Kitchen for examples. The model is to demonstrate what the reference time
    // looks like so that the Format and Parse methods can apply the same
    // transformation to a general time value.
    //
    // Here is a summary of the components of a layout string. Each element shows by
    // example the formatting of an element of the reference time. Only these values
    // are recognized. Text in the layout string that is not recognized as part of
    // the reference time is echoed verbatim during Format and expected to appear
    // verbatim in the input to Parse.
    //
    //	Year: "2006" "06"
    //	Month: "Jan" "January" "01" "1"
    //	Day of the week: "Mon" "Monday"
    //	Day of the month: "2" "_2" "02"
    //	Day of the year: "__2" "002"
    //	Hour: "15" "3" "03" (PM or AM)
    //	Minute: "4" "04"
    //	Second: "5" "05"
    //	AM/PM mark: "PM"
    //
    // Numeric time zone offsets format as follows:
    //
    //	"-0700"     ±hhmm
    //	"-07:00"    ±hh:mm
    //	"-07"       ±hh
    //	"-070000"   ±hhmmss
    //	"-07:00:00" ±hh:mm:ss
    //
    // Replacing the sign in the format with a Z triggers
    // the ISO 8601 behavior of printing Z instead of an
    // offset for the UTC zone. Thus:
    //
    //	"Z0700"      Z or ±hhmm
    //	"Z07:00"     Z or ±hh:mm
    //	"Z07"        Z or ±hh
    //	"Z070000"    Z or ±hhmmss
    //	"Z07:00:00"  Z or ±hh:mm:ss
    //
    // Within the format string, the underscores in "_2" and "__2" represent spaces
    // that may be replaced by digits if the following number has multiple digits,
    // for compatibility with fixed-width Unix time formats. A leading zero represents
    // a zero-padded value.
    //
    // The formats __2 and 002 are space-padded and zero-padded
    // three-character day of year; there is no unpadded day of year format.
    //
    // A comma or decimal point followed by one or more zeros represents
    // a fractional second, printed to the given number of decimal places.
    // A comma or decimal point followed by one or more nines represents
    // a fractional second, printed to the given number of decimal places, with
    // trailing zeros removed.
    // For example "15:04:05,000" or "15:04:05.000" formats or parses with
    // millisecond precision.
    //
    // Some valid layouts are invalid time values for time.Parse, due to formats
    // such as _ for space padding and Z for zone information.
    
    
**/
final ansic : stdgo.GoString = ("Mon Jan _2 15:04:05 2006" : stdgo.GoString);
/**
    // These are predefined layouts for use in Time.Format and time.Parse.
    // The reference time used in these layouts is the specific time stamp:
    //
    //	01/02 03:04:05PM '06 -0700
    //
    // (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
    // That value is recorded as the constant named Layout, listed below. As a Unix
    // time, this is 1136239445. Since MST is GMT-0700, the reference would be
    // printed by the Unix date command as:
    //
    //	Mon Jan 2 15:04:05 MST 2006
    //
    // It is a regrettable historic error that the date uses the American convention
    // of putting the numerical month before the day.
    //
    // The example for Time.Format demonstrates the working of the layout string
    // in detail and is a good reference.
    //
    // Note that the RFC822, RFC850, and RFC1123 formats should be applied
    // only to local times. Applying them to UTC times will use "UTC" as the
    // time zone abbreviation, while strictly speaking those RFCs require the
    // use of "GMT" in that case.
    // In general RFC1123Z should be used instead of RFC1123 for servers
    // that insist on that format, and RFC3339 should be preferred for new protocols.
    // RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
    // when used with time.Parse they do not accept all the time formats
    // permitted by the RFCs and they do accept time formats not formally defined.
    // The RFC3339Nano format removes trailing zeros from the seconds field
    // and thus may not sort correctly once formatted.
    //
    // Most programs can use one of the defined constants as the layout passed to
    // Format or Parse. The rest of this comment can be ignored unless you are
    // creating a custom layout string.
    //
    // To define your own format, write down what the reference time would look like
    // formatted your way; see the values of constants like ANSIC, StampMicro or
    // Kitchen for examples. The model is to demonstrate what the reference time
    // looks like so that the Format and Parse methods can apply the same
    // transformation to a general time value.
    //
    // Here is a summary of the components of a layout string. Each element shows by
    // example the formatting of an element of the reference time. Only these values
    // are recognized. Text in the layout string that is not recognized as part of
    // the reference time is echoed verbatim during Format and expected to appear
    // verbatim in the input to Parse.
    //
    //	Year: "2006" "06"
    //	Month: "Jan" "January" "01" "1"
    //	Day of the week: "Mon" "Monday"
    //	Day of the month: "2" "_2" "02"
    //	Day of the year: "__2" "002"
    //	Hour: "15" "3" "03" (PM or AM)
    //	Minute: "4" "04"
    //	Second: "5" "05"
    //	AM/PM mark: "PM"
    //
    // Numeric time zone offsets format as follows:
    //
    //	"-0700"     ±hhmm
    //	"-07:00"    ±hh:mm
    //	"-07"       ±hh
    //	"-070000"   ±hhmmss
    //	"-07:00:00" ±hh:mm:ss
    //
    // Replacing the sign in the format with a Z triggers
    // the ISO 8601 behavior of printing Z instead of an
    // offset for the UTC zone. Thus:
    //
    //	"Z0700"      Z or ±hhmm
    //	"Z07:00"     Z or ±hh:mm
    //	"Z07"        Z or ±hh
    //	"Z070000"    Z or ±hhmmss
    //	"Z07:00:00"  Z or ±hh:mm:ss
    //
    // Within the format string, the underscores in "_2" and "__2" represent spaces
    // that may be replaced by digits if the following number has multiple digits,
    // for compatibility with fixed-width Unix time formats. A leading zero represents
    // a zero-padded value.
    //
    // The formats __2 and 002 are space-padded and zero-padded
    // three-character day of year; there is no unpadded day of year format.
    //
    // A comma or decimal point followed by one or more zeros represents
    // a fractional second, printed to the given number of decimal places.
    // A comma or decimal point followed by one or more nines represents
    // a fractional second, printed to the given number of decimal places, with
    // trailing zeros removed.
    // For example "15:04:05,000" or "15:04:05.000" formats or parses with
    // millisecond precision.
    //
    // Some valid layouts are invalid time values for time.Parse, due to formats
    // such as _ for space padding and Z for zone information.
    
    
**/
final unixDate : stdgo.GoString = ("Mon Jan _2 15:04:05 MST 2006" : stdgo.GoString);
/**
    // These are predefined layouts for use in Time.Format and time.Parse.
    // The reference time used in these layouts is the specific time stamp:
    //
    //	01/02 03:04:05PM '06 -0700
    //
    // (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
    // That value is recorded as the constant named Layout, listed below. As a Unix
    // time, this is 1136239445. Since MST is GMT-0700, the reference would be
    // printed by the Unix date command as:
    //
    //	Mon Jan 2 15:04:05 MST 2006
    //
    // It is a regrettable historic error that the date uses the American convention
    // of putting the numerical month before the day.
    //
    // The example for Time.Format demonstrates the working of the layout string
    // in detail and is a good reference.
    //
    // Note that the RFC822, RFC850, and RFC1123 formats should be applied
    // only to local times. Applying them to UTC times will use "UTC" as the
    // time zone abbreviation, while strictly speaking those RFCs require the
    // use of "GMT" in that case.
    // In general RFC1123Z should be used instead of RFC1123 for servers
    // that insist on that format, and RFC3339 should be preferred for new protocols.
    // RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
    // when used with time.Parse they do not accept all the time formats
    // permitted by the RFCs and they do accept time formats not formally defined.
    // The RFC3339Nano format removes trailing zeros from the seconds field
    // and thus may not sort correctly once formatted.
    //
    // Most programs can use one of the defined constants as the layout passed to
    // Format or Parse. The rest of this comment can be ignored unless you are
    // creating a custom layout string.
    //
    // To define your own format, write down what the reference time would look like
    // formatted your way; see the values of constants like ANSIC, StampMicro or
    // Kitchen for examples. The model is to demonstrate what the reference time
    // looks like so that the Format and Parse methods can apply the same
    // transformation to a general time value.
    //
    // Here is a summary of the components of a layout string. Each element shows by
    // example the formatting of an element of the reference time. Only these values
    // are recognized. Text in the layout string that is not recognized as part of
    // the reference time is echoed verbatim during Format and expected to appear
    // verbatim in the input to Parse.
    //
    //	Year: "2006" "06"
    //	Month: "Jan" "January" "01" "1"
    //	Day of the week: "Mon" "Monday"
    //	Day of the month: "2" "_2" "02"
    //	Day of the year: "__2" "002"
    //	Hour: "15" "3" "03" (PM or AM)
    //	Minute: "4" "04"
    //	Second: "5" "05"
    //	AM/PM mark: "PM"
    //
    // Numeric time zone offsets format as follows:
    //
    //	"-0700"     ±hhmm
    //	"-07:00"    ±hh:mm
    //	"-07"       ±hh
    //	"-070000"   ±hhmmss
    //	"-07:00:00" ±hh:mm:ss
    //
    // Replacing the sign in the format with a Z triggers
    // the ISO 8601 behavior of printing Z instead of an
    // offset for the UTC zone. Thus:
    //
    //	"Z0700"      Z or ±hhmm
    //	"Z07:00"     Z or ±hh:mm
    //	"Z07"        Z or ±hh
    //	"Z070000"    Z or ±hhmmss
    //	"Z07:00:00"  Z or ±hh:mm:ss
    //
    // Within the format string, the underscores in "_2" and "__2" represent spaces
    // that may be replaced by digits if the following number has multiple digits,
    // for compatibility with fixed-width Unix time formats. A leading zero represents
    // a zero-padded value.
    //
    // The formats __2 and 002 are space-padded and zero-padded
    // three-character day of year; there is no unpadded day of year format.
    //
    // A comma or decimal point followed by one or more zeros represents
    // a fractional second, printed to the given number of decimal places.
    // A comma or decimal point followed by one or more nines represents
    // a fractional second, printed to the given number of decimal places, with
    // trailing zeros removed.
    // For example "15:04:05,000" or "15:04:05.000" formats or parses with
    // millisecond precision.
    //
    // Some valid layouts are invalid time values for time.Parse, due to formats
    // such as _ for space padding and Z for zone information.
    
    
**/
final rubyDate : stdgo.GoString = ("Mon Jan 02 15:04:05 -0700 2006" : stdgo.GoString);
/**
    // These are predefined layouts for use in Time.Format and time.Parse.
    // The reference time used in these layouts is the specific time stamp:
    //
    //	01/02 03:04:05PM '06 -0700
    //
    // (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
    // That value is recorded as the constant named Layout, listed below. As a Unix
    // time, this is 1136239445. Since MST is GMT-0700, the reference would be
    // printed by the Unix date command as:
    //
    //	Mon Jan 2 15:04:05 MST 2006
    //
    // It is a regrettable historic error that the date uses the American convention
    // of putting the numerical month before the day.
    //
    // The example for Time.Format demonstrates the working of the layout string
    // in detail and is a good reference.
    //
    // Note that the RFC822, RFC850, and RFC1123 formats should be applied
    // only to local times. Applying them to UTC times will use "UTC" as the
    // time zone abbreviation, while strictly speaking those RFCs require the
    // use of "GMT" in that case.
    // In general RFC1123Z should be used instead of RFC1123 for servers
    // that insist on that format, and RFC3339 should be preferred for new protocols.
    // RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
    // when used with time.Parse they do not accept all the time formats
    // permitted by the RFCs and they do accept time formats not formally defined.
    // The RFC3339Nano format removes trailing zeros from the seconds field
    // and thus may not sort correctly once formatted.
    //
    // Most programs can use one of the defined constants as the layout passed to
    // Format or Parse. The rest of this comment can be ignored unless you are
    // creating a custom layout string.
    //
    // To define your own format, write down what the reference time would look like
    // formatted your way; see the values of constants like ANSIC, StampMicro or
    // Kitchen for examples. The model is to demonstrate what the reference time
    // looks like so that the Format and Parse methods can apply the same
    // transformation to a general time value.
    //
    // Here is a summary of the components of a layout string. Each element shows by
    // example the formatting of an element of the reference time. Only these values
    // are recognized. Text in the layout string that is not recognized as part of
    // the reference time is echoed verbatim during Format and expected to appear
    // verbatim in the input to Parse.
    //
    //	Year: "2006" "06"
    //	Month: "Jan" "January" "01" "1"
    //	Day of the week: "Mon" "Monday"
    //	Day of the month: "2" "_2" "02"
    //	Day of the year: "__2" "002"
    //	Hour: "15" "3" "03" (PM or AM)
    //	Minute: "4" "04"
    //	Second: "5" "05"
    //	AM/PM mark: "PM"
    //
    // Numeric time zone offsets format as follows:
    //
    //	"-0700"     ±hhmm
    //	"-07:00"    ±hh:mm
    //	"-07"       ±hh
    //	"-070000"   ±hhmmss
    //	"-07:00:00" ±hh:mm:ss
    //
    // Replacing the sign in the format with a Z triggers
    // the ISO 8601 behavior of printing Z instead of an
    // offset for the UTC zone. Thus:
    //
    //	"Z0700"      Z or ±hhmm
    //	"Z07:00"     Z or ±hh:mm
    //	"Z07"        Z or ±hh
    //	"Z070000"    Z or ±hhmmss
    //	"Z07:00:00"  Z or ±hh:mm:ss
    //
    // Within the format string, the underscores in "_2" and "__2" represent spaces
    // that may be replaced by digits if the following number has multiple digits,
    // for compatibility with fixed-width Unix time formats. A leading zero represents
    // a zero-padded value.
    //
    // The formats __2 and 002 are space-padded and zero-padded
    // three-character day of year; there is no unpadded day of year format.
    //
    // A comma or decimal point followed by one or more zeros represents
    // a fractional second, printed to the given number of decimal places.
    // A comma or decimal point followed by one or more nines represents
    // a fractional second, printed to the given number of decimal places, with
    // trailing zeros removed.
    // For example "15:04:05,000" or "15:04:05.000" formats or parses with
    // millisecond precision.
    //
    // Some valid layouts are invalid time values for time.Parse, due to formats
    // such as _ for space padding and Z for zone information.
    
    
**/
final rfc822 : stdgo.GoString = ("02 Jan 06 15:04 MST" : stdgo.GoString);
/**
    // These are predefined layouts for use in Time.Format and time.Parse.
    // The reference time used in these layouts is the specific time stamp:
    //
    //	01/02 03:04:05PM '06 -0700
    //
    // (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
    // That value is recorded as the constant named Layout, listed below. As a Unix
    // time, this is 1136239445. Since MST is GMT-0700, the reference would be
    // printed by the Unix date command as:
    //
    //	Mon Jan 2 15:04:05 MST 2006
    //
    // It is a regrettable historic error that the date uses the American convention
    // of putting the numerical month before the day.
    //
    // The example for Time.Format demonstrates the working of the layout string
    // in detail and is a good reference.
    //
    // Note that the RFC822, RFC850, and RFC1123 formats should be applied
    // only to local times. Applying them to UTC times will use "UTC" as the
    // time zone abbreviation, while strictly speaking those RFCs require the
    // use of "GMT" in that case.
    // In general RFC1123Z should be used instead of RFC1123 for servers
    // that insist on that format, and RFC3339 should be preferred for new protocols.
    // RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
    // when used with time.Parse they do not accept all the time formats
    // permitted by the RFCs and they do accept time formats not formally defined.
    // The RFC3339Nano format removes trailing zeros from the seconds field
    // and thus may not sort correctly once formatted.
    //
    // Most programs can use one of the defined constants as the layout passed to
    // Format or Parse. The rest of this comment can be ignored unless you are
    // creating a custom layout string.
    //
    // To define your own format, write down what the reference time would look like
    // formatted your way; see the values of constants like ANSIC, StampMicro or
    // Kitchen for examples. The model is to demonstrate what the reference time
    // looks like so that the Format and Parse methods can apply the same
    // transformation to a general time value.
    //
    // Here is a summary of the components of a layout string. Each element shows by
    // example the formatting of an element of the reference time. Only these values
    // are recognized. Text in the layout string that is not recognized as part of
    // the reference time is echoed verbatim during Format and expected to appear
    // verbatim in the input to Parse.
    //
    //	Year: "2006" "06"
    //	Month: "Jan" "January" "01" "1"
    //	Day of the week: "Mon" "Monday"
    //	Day of the month: "2" "_2" "02"
    //	Day of the year: "__2" "002"
    //	Hour: "15" "3" "03" (PM or AM)
    //	Minute: "4" "04"
    //	Second: "5" "05"
    //	AM/PM mark: "PM"
    //
    // Numeric time zone offsets format as follows:
    //
    //	"-0700"     ±hhmm
    //	"-07:00"    ±hh:mm
    //	"-07"       ±hh
    //	"-070000"   ±hhmmss
    //	"-07:00:00" ±hh:mm:ss
    //
    // Replacing the sign in the format with a Z triggers
    // the ISO 8601 behavior of printing Z instead of an
    // offset for the UTC zone. Thus:
    //
    //	"Z0700"      Z or ±hhmm
    //	"Z07:00"     Z or ±hh:mm
    //	"Z07"        Z or ±hh
    //	"Z070000"    Z or ±hhmmss
    //	"Z07:00:00"  Z or ±hh:mm:ss
    //
    // Within the format string, the underscores in "_2" and "__2" represent spaces
    // that may be replaced by digits if the following number has multiple digits,
    // for compatibility with fixed-width Unix time formats. A leading zero represents
    // a zero-padded value.
    //
    // The formats __2 and 002 are space-padded and zero-padded
    // three-character day of year; there is no unpadded day of year format.
    //
    // A comma or decimal point followed by one or more zeros represents
    // a fractional second, printed to the given number of decimal places.
    // A comma or decimal point followed by one or more nines represents
    // a fractional second, printed to the given number of decimal places, with
    // trailing zeros removed.
    // For example "15:04:05,000" or "15:04:05.000" formats or parses with
    // millisecond precision.
    //
    // Some valid layouts are invalid time values for time.Parse, due to formats
    // such as _ for space padding and Z for zone information.
    
    // RFC822 with numeric zone
**/
final rfc822z : stdgo.GoString = ("02 Jan 06 15:04 -0700" : stdgo.GoString);
/**
    // These are predefined layouts for use in Time.Format and time.Parse.
    // The reference time used in these layouts is the specific time stamp:
    //
    //	01/02 03:04:05PM '06 -0700
    //
    // (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
    // That value is recorded as the constant named Layout, listed below. As a Unix
    // time, this is 1136239445. Since MST is GMT-0700, the reference would be
    // printed by the Unix date command as:
    //
    //	Mon Jan 2 15:04:05 MST 2006
    //
    // It is a regrettable historic error that the date uses the American convention
    // of putting the numerical month before the day.
    //
    // The example for Time.Format demonstrates the working of the layout string
    // in detail and is a good reference.
    //
    // Note that the RFC822, RFC850, and RFC1123 formats should be applied
    // only to local times. Applying them to UTC times will use "UTC" as the
    // time zone abbreviation, while strictly speaking those RFCs require the
    // use of "GMT" in that case.
    // In general RFC1123Z should be used instead of RFC1123 for servers
    // that insist on that format, and RFC3339 should be preferred for new protocols.
    // RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
    // when used with time.Parse they do not accept all the time formats
    // permitted by the RFCs and they do accept time formats not formally defined.
    // The RFC3339Nano format removes trailing zeros from the seconds field
    // and thus may not sort correctly once formatted.
    //
    // Most programs can use one of the defined constants as the layout passed to
    // Format or Parse. The rest of this comment can be ignored unless you are
    // creating a custom layout string.
    //
    // To define your own format, write down what the reference time would look like
    // formatted your way; see the values of constants like ANSIC, StampMicro or
    // Kitchen for examples. The model is to demonstrate what the reference time
    // looks like so that the Format and Parse methods can apply the same
    // transformation to a general time value.
    //
    // Here is a summary of the components of a layout string. Each element shows by
    // example the formatting of an element of the reference time. Only these values
    // are recognized. Text in the layout string that is not recognized as part of
    // the reference time is echoed verbatim during Format and expected to appear
    // verbatim in the input to Parse.
    //
    //	Year: "2006" "06"
    //	Month: "Jan" "January" "01" "1"
    //	Day of the week: "Mon" "Monday"
    //	Day of the month: "2" "_2" "02"
    //	Day of the year: "__2" "002"
    //	Hour: "15" "3" "03" (PM or AM)
    //	Minute: "4" "04"
    //	Second: "5" "05"
    //	AM/PM mark: "PM"
    //
    // Numeric time zone offsets format as follows:
    //
    //	"-0700"     ±hhmm
    //	"-07:00"    ±hh:mm
    //	"-07"       ±hh
    //	"-070000"   ±hhmmss
    //	"-07:00:00" ±hh:mm:ss
    //
    // Replacing the sign in the format with a Z triggers
    // the ISO 8601 behavior of printing Z instead of an
    // offset for the UTC zone. Thus:
    //
    //	"Z0700"      Z or ±hhmm
    //	"Z07:00"     Z or ±hh:mm
    //	"Z07"        Z or ±hh
    //	"Z070000"    Z or ±hhmmss
    //	"Z07:00:00"  Z or ±hh:mm:ss
    //
    // Within the format string, the underscores in "_2" and "__2" represent spaces
    // that may be replaced by digits if the following number has multiple digits,
    // for compatibility with fixed-width Unix time formats. A leading zero represents
    // a zero-padded value.
    //
    // The formats __2 and 002 are space-padded and zero-padded
    // three-character day of year; there is no unpadded day of year format.
    //
    // A comma or decimal point followed by one or more zeros represents
    // a fractional second, printed to the given number of decimal places.
    // A comma or decimal point followed by one or more nines represents
    // a fractional second, printed to the given number of decimal places, with
    // trailing zeros removed.
    // For example "15:04:05,000" or "15:04:05.000" formats or parses with
    // millisecond precision.
    //
    // Some valid layouts are invalid time values for time.Parse, due to formats
    // such as _ for space padding and Z for zone information.
    
    
**/
final rfc850 : stdgo.GoString = ("Monday, 02-Jan-06 15:04:05 MST" : stdgo.GoString);
/**
    // These are predefined layouts for use in Time.Format and time.Parse.
    // The reference time used in these layouts is the specific time stamp:
    //
    //	01/02 03:04:05PM '06 -0700
    //
    // (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
    // That value is recorded as the constant named Layout, listed below. As a Unix
    // time, this is 1136239445. Since MST is GMT-0700, the reference would be
    // printed by the Unix date command as:
    //
    //	Mon Jan 2 15:04:05 MST 2006
    //
    // It is a regrettable historic error that the date uses the American convention
    // of putting the numerical month before the day.
    //
    // The example for Time.Format demonstrates the working of the layout string
    // in detail and is a good reference.
    //
    // Note that the RFC822, RFC850, and RFC1123 formats should be applied
    // only to local times. Applying them to UTC times will use "UTC" as the
    // time zone abbreviation, while strictly speaking those RFCs require the
    // use of "GMT" in that case.
    // In general RFC1123Z should be used instead of RFC1123 for servers
    // that insist on that format, and RFC3339 should be preferred for new protocols.
    // RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
    // when used with time.Parse they do not accept all the time formats
    // permitted by the RFCs and they do accept time formats not formally defined.
    // The RFC3339Nano format removes trailing zeros from the seconds field
    // and thus may not sort correctly once formatted.
    //
    // Most programs can use one of the defined constants as the layout passed to
    // Format or Parse. The rest of this comment can be ignored unless you are
    // creating a custom layout string.
    //
    // To define your own format, write down what the reference time would look like
    // formatted your way; see the values of constants like ANSIC, StampMicro or
    // Kitchen for examples. The model is to demonstrate what the reference time
    // looks like so that the Format and Parse methods can apply the same
    // transformation to a general time value.
    //
    // Here is a summary of the components of a layout string. Each element shows by
    // example the formatting of an element of the reference time. Only these values
    // are recognized. Text in the layout string that is not recognized as part of
    // the reference time is echoed verbatim during Format and expected to appear
    // verbatim in the input to Parse.
    //
    //	Year: "2006" "06"
    //	Month: "Jan" "January" "01" "1"
    //	Day of the week: "Mon" "Monday"
    //	Day of the month: "2" "_2" "02"
    //	Day of the year: "__2" "002"
    //	Hour: "15" "3" "03" (PM or AM)
    //	Minute: "4" "04"
    //	Second: "5" "05"
    //	AM/PM mark: "PM"
    //
    // Numeric time zone offsets format as follows:
    //
    //	"-0700"     ±hhmm
    //	"-07:00"    ±hh:mm
    //	"-07"       ±hh
    //	"-070000"   ±hhmmss
    //	"-07:00:00" ±hh:mm:ss
    //
    // Replacing the sign in the format with a Z triggers
    // the ISO 8601 behavior of printing Z instead of an
    // offset for the UTC zone. Thus:
    //
    //	"Z0700"      Z or ±hhmm
    //	"Z07:00"     Z or ±hh:mm
    //	"Z07"        Z or ±hh
    //	"Z070000"    Z or ±hhmmss
    //	"Z07:00:00"  Z or ±hh:mm:ss
    //
    // Within the format string, the underscores in "_2" and "__2" represent spaces
    // that may be replaced by digits if the following number has multiple digits,
    // for compatibility with fixed-width Unix time formats. A leading zero represents
    // a zero-padded value.
    //
    // The formats __2 and 002 are space-padded and zero-padded
    // three-character day of year; there is no unpadded day of year format.
    //
    // A comma or decimal point followed by one or more zeros represents
    // a fractional second, printed to the given number of decimal places.
    // A comma or decimal point followed by one or more nines represents
    // a fractional second, printed to the given number of decimal places, with
    // trailing zeros removed.
    // For example "15:04:05,000" or "15:04:05.000" formats or parses with
    // millisecond precision.
    //
    // Some valid layouts are invalid time values for time.Parse, due to formats
    // such as _ for space padding and Z for zone information.
    
    
**/
final rfc1123 : stdgo.GoString = ("Mon, 02 Jan 2006 15:04:05 MST" : stdgo.GoString);
/**
    // These are predefined layouts for use in Time.Format and time.Parse.
    // The reference time used in these layouts is the specific time stamp:
    //
    //	01/02 03:04:05PM '06 -0700
    //
    // (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
    // That value is recorded as the constant named Layout, listed below. As a Unix
    // time, this is 1136239445. Since MST is GMT-0700, the reference would be
    // printed by the Unix date command as:
    //
    //	Mon Jan 2 15:04:05 MST 2006
    //
    // It is a regrettable historic error that the date uses the American convention
    // of putting the numerical month before the day.
    //
    // The example for Time.Format demonstrates the working of the layout string
    // in detail and is a good reference.
    //
    // Note that the RFC822, RFC850, and RFC1123 formats should be applied
    // only to local times. Applying them to UTC times will use "UTC" as the
    // time zone abbreviation, while strictly speaking those RFCs require the
    // use of "GMT" in that case.
    // In general RFC1123Z should be used instead of RFC1123 for servers
    // that insist on that format, and RFC3339 should be preferred for new protocols.
    // RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
    // when used with time.Parse they do not accept all the time formats
    // permitted by the RFCs and they do accept time formats not formally defined.
    // The RFC3339Nano format removes trailing zeros from the seconds field
    // and thus may not sort correctly once formatted.
    //
    // Most programs can use one of the defined constants as the layout passed to
    // Format or Parse. The rest of this comment can be ignored unless you are
    // creating a custom layout string.
    //
    // To define your own format, write down what the reference time would look like
    // formatted your way; see the values of constants like ANSIC, StampMicro or
    // Kitchen for examples. The model is to demonstrate what the reference time
    // looks like so that the Format and Parse methods can apply the same
    // transformation to a general time value.
    //
    // Here is a summary of the components of a layout string. Each element shows by
    // example the formatting of an element of the reference time. Only these values
    // are recognized. Text in the layout string that is not recognized as part of
    // the reference time is echoed verbatim during Format and expected to appear
    // verbatim in the input to Parse.
    //
    //	Year: "2006" "06"
    //	Month: "Jan" "January" "01" "1"
    //	Day of the week: "Mon" "Monday"
    //	Day of the month: "2" "_2" "02"
    //	Day of the year: "__2" "002"
    //	Hour: "15" "3" "03" (PM or AM)
    //	Minute: "4" "04"
    //	Second: "5" "05"
    //	AM/PM mark: "PM"
    //
    // Numeric time zone offsets format as follows:
    //
    //	"-0700"     ±hhmm
    //	"-07:00"    ±hh:mm
    //	"-07"       ±hh
    //	"-070000"   ±hhmmss
    //	"-07:00:00" ±hh:mm:ss
    //
    // Replacing the sign in the format with a Z triggers
    // the ISO 8601 behavior of printing Z instead of an
    // offset for the UTC zone. Thus:
    //
    //	"Z0700"      Z or ±hhmm
    //	"Z07:00"     Z or ±hh:mm
    //	"Z07"        Z or ±hh
    //	"Z070000"    Z or ±hhmmss
    //	"Z07:00:00"  Z or ±hh:mm:ss
    //
    // Within the format string, the underscores in "_2" and "__2" represent spaces
    // that may be replaced by digits if the following number has multiple digits,
    // for compatibility with fixed-width Unix time formats. A leading zero represents
    // a zero-padded value.
    //
    // The formats __2 and 002 are space-padded and zero-padded
    // three-character day of year; there is no unpadded day of year format.
    //
    // A comma or decimal point followed by one or more zeros represents
    // a fractional second, printed to the given number of decimal places.
    // A comma or decimal point followed by one or more nines represents
    // a fractional second, printed to the given number of decimal places, with
    // trailing zeros removed.
    // For example "15:04:05,000" or "15:04:05.000" formats or parses with
    // millisecond precision.
    //
    // Some valid layouts are invalid time values for time.Parse, due to formats
    // such as _ for space padding and Z for zone information.
    
    // RFC1123 with numeric zone
**/
final rfc1123z : stdgo.GoString = ("Mon, 02 Jan 2006 15:04:05 -0700" : stdgo.GoString);
/**
    // These are predefined layouts for use in Time.Format and time.Parse.
    // The reference time used in these layouts is the specific time stamp:
    //
    //	01/02 03:04:05PM '06 -0700
    //
    // (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
    // That value is recorded as the constant named Layout, listed below. As a Unix
    // time, this is 1136239445. Since MST is GMT-0700, the reference would be
    // printed by the Unix date command as:
    //
    //	Mon Jan 2 15:04:05 MST 2006
    //
    // It is a regrettable historic error that the date uses the American convention
    // of putting the numerical month before the day.
    //
    // The example for Time.Format demonstrates the working of the layout string
    // in detail and is a good reference.
    //
    // Note that the RFC822, RFC850, and RFC1123 formats should be applied
    // only to local times. Applying them to UTC times will use "UTC" as the
    // time zone abbreviation, while strictly speaking those RFCs require the
    // use of "GMT" in that case.
    // In general RFC1123Z should be used instead of RFC1123 for servers
    // that insist on that format, and RFC3339 should be preferred for new protocols.
    // RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
    // when used with time.Parse they do not accept all the time formats
    // permitted by the RFCs and they do accept time formats not formally defined.
    // The RFC3339Nano format removes trailing zeros from the seconds field
    // and thus may not sort correctly once formatted.
    //
    // Most programs can use one of the defined constants as the layout passed to
    // Format or Parse. The rest of this comment can be ignored unless you are
    // creating a custom layout string.
    //
    // To define your own format, write down what the reference time would look like
    // formatted your way; see the values of constants like ANSIC, StampMicro or
    // Kitchen for examples. The model is to demonstrate what the reference time
    // looks like so that the Format and Parse methods can apply the same
    // transformation to a general time value.
    //
    // Here is a summary of the components of a layout string. Each element shows by
    // example the formatting of an element of the reference time. Only these values
    // are recognized. Text in the layout string that is not recognized as part of
    // the reference time is echoed verbatim during Format and expected to appear
    // verbatim in the input to Parse.
    //
    //	Year: "2006" "06"
    //	Month: "Jan" "January" "01" "1"
    //	Day of the week: "Mon" "Monday"
    //	Day of the month: "2" "_2" "02"
    //	Day of the year: "__2" "002"
    //	Hour: "15" "3" "03" (PM or AM)
    //	Minute: "4" "04"
    //	Second: "5" "05"
    //	AM/PM mark: "PM"
    //
    // Numeric time zone offsets format as follows:
    //
    //	"-0700"     ±hhmm
    //	"-07:00"    ±hh:mm
    //	"-07"       ±hh
    //	"-070000"   ±hhmmss
    //	"-07:00:00" ±hh:mm:ss
    //
    // Replacing the sign in the format with a Z triggers
    // the ISO 8601 behavior of printing Z instead of an
    // offset for the UTC zone. Thus:
    //
    //	"Z0700"      Z or ±hhmm
    //	"Z07:00"     Z or ±hh:mm
    //	"Z07"        Z or ±hh
    //	"Z070000"    Z or ±hhmmss
    //	"Z07:00:00"  Z or ±hh:mm:ss
    //
    // Within the format string, the underscores in "_2" and "__2" represent spaces
    // that may be replaced by digits if the following number has multiple digits,
    // for compatibility with fixed-width Unix time formats. A leading zero represents
    // a zero-padded value.
    //
    // The formats __2 and 002 are space-padded and zero-padded
    // three-character day of year; there is no unpadded day of year format.
    //
    // A comma or decimal point followed by one or more zeros represents
    // a fractional second, printed to the given number of decimal places.
    // A comma or decimal point followed by one or more nines represents
    // a fractional second, printed to the given number of decimal places, with
    // trailing zeros removed.
    // For example "15:04:05,000" or "15:04:05.000" formats or parses with
    // millisecond precision.
    //
    // Some valid layouts are invalid time values for time.Parse, due to formats
    // such as _ for space padding and Z for zone information.
    
    
**/
final rfc3339 : stdgo.GoString = ("2006-01-02T15:04:05Z07:00" : stdgo.GoString);
/**
    // These are predefined layouts for use in Time.Format and time.Parse.
    // The reference time used in these layouts is the specific time stamp:
    //
    //	01/02 03:04:05PM '06 -0700
    //
    // (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
    // That value is recorded as the constant named Layout, listed below. As a Unix
    // time, this is 1136239445. Since MST is GMT-0700, the reference would be
    // printed by the Unix date command as:
    //
    //	Mon Jan 2 15:04:05 MST 2006
    //
    // It is a regrettable historic error that the date uses the American convention
    // of putting the numerical month before the day.
    //
    // The example for Time.Format demonstrates the working of the layout string
    // in detail and is a good reference.
    //
    // Note that the RFC822, RFC850, and RFC1123 formats should be applied
    // only to local times. Applying them to UTC times will use "UTC" as the
    // time zone abbreviation, while strictly speaking those RFCs require the
    // use of "GMT" in that case.
    // In general RFC1123Z should be used instead of RFC1123 for servers
    // that insist on that format, and RFC3339 should be preferred for new protocols.
    // RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
    // when used with time.Parse they do not accept all the time formats
    // permitted by the RFCs and they do accept time formats not formally defined.
    // The RFC3339Nano format removes trailing zeros from the seconds field
    // and thus may not sort correctly once formatted.
    //
    // Most programs can use one of the defined constants as the layout passed to
    // Format or Parse. The rest of this comment can be ignored unless you are
    // creating a custom layout string.
    //
    // To define your own format, write down what the reference time would look like
    // formatted your way; see the values of constants like ANSIC, StampMicro or
    // Kitchen for examples. The model is to demonstrate what the reference time
    // looks like so that the Format and Parse methods can apply the same
    // transformation to a general time value.
    //
    // Here is a summary of the components of a layout string. Each element shows by
    // example the formatting of an element of the reference time. Only these values
    // are recognized. Text in the layout string that is not recognized as part of
    // the reference time is echoed verbatim during Format and expected to appear
    // verbatim in the input to Parse.
    //
    //	Year: "2006" "06"
    //	Month: "Jan" "January" "01" "1"
    //	Day of the week: "Mon" "Monday"
    //	Day of the month: "2" "_2" "02"
    //	Day of the year: "__2" "002"
    //	Hour: "15" "3" "03" (PM or AM)
    //	Minute: "4" "04"
    //	Second: "5" "05"
    //	AM/PM mark: "PM"
    //
    // Numeric time zone offsets format as follows:
    //
    //	"-0700"     ±hhmm
    //	"-07:00"    ±hh:mm
    //	"-07"       ±hh
    //	"-070000"   ±hhmmss
    //	"-07:00:00" ±hh:mm:ss
    //
    // Replacing the sign in the format with a Z triggers
    // the ISO 8601 behavior of printing Z instead of an
    // offset for the UTC zone. Thus:
    //
    //	"Z0700"      Z or ±hhmm
    //	"Z07:00"     Z or ±hh:mm
    //	"Z07"        Z or ±hh
    //	"Z070000"    Z or ±hhmmss
    //	"Z07:00:00"  Z or ±hh:mm:ss
    //
    // Within the format string, the underscores in "_2" and "__2" represent spaces
    // that may be replaced by digits if the following number has multiple digits,
    // for compatibility with fixed-width Unix time formats. A leading zero represents
    // a zero-padded value.
    //
    // The formats __2 and 002 are space-padded and zero-padded
    // three-character day of year; there is no unpadded day of year format.
    //
    // A comma or decimal point followed by one or more zeros represents
    // a fractional second, printed to the given number of decimal places.
    // A comma or decimal point followed by one or more nines represents
    // a fractional second, printed to the given number of decimal places, with
    // trailing zeros removed.
    // For example "15:04:05,000" or "15:04:05.000" formats or parses with
    // millisecond precision.
    //
    // Some valid layouts are invalid time values for time.Parse, due to formats
    // such as _ for space padding and Z for zone information.
    
    
**/
final rfc3339nano : stdgo.GoString = ("2006-01-02T15:04:05.999999999Z07:00" : stdgo.GoString);
/**
    // These are predefined layouts for use in Time.Format and time.Parse.
    // The reference time used in these layouts is the specific time stamp:
    //
    //	01/02 03:04:05PM '06 -0700
    //
    // (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
    // That value is recorded as the constant named Layout, listed below. As a Unix
    // time, this is 1136239445. Since MST is GMT-0700, the reference would be
    // printed by the Unix date command as:
    //
    //	Mon Jan 2 15:04:05 MST 2006
    //
    // It is a regrettable historic error that the date uses the American convention
    // of putting the numerical month before the day.
    //
    // The example for Time.Format demonstrates the working of the layout string
    // in detail and is a good reference.
    //
    // Note that the RFC822, RFC850, and RFC1123 formats should be applied
    // only to local times. Applying them to UTC times will use "UTC" as the
    // time zone abbreviation, while strictly speaking those RFCs require the
    // use of "GMT" in that case.
    // In general RFC1123Z should be used instead of RFC1123 for servers
    // that insist on that format, and RFC3339 should be preferred for new protocols.
    // RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
    // when used with time.Parse they do not accept all the time formats
    // permitted by the RFCs and they do accept time formats not formally defined.
    // The RFC3339Nano format removes trailing zeros from the seconds field
    // and thus may not sort correctly once formatted.
    //
    // Most programs can use one of the defined constants as the layout passed to
    // Format or Parse. The rest of this comment can be ignored unless you are
    // creating a custom layout string.
    //
    // To define your own format, write down what the reference time would look like
    // formatted your way; see the values of constants like ANSIC, StampMicro or
    // Kitchen for examples. The model is to demonstrate what the reference time
    // looks like so that the Format and Parse methods can apply the same
    // transformation to a general time value.
    //
    // Here is a summary of the components of a layout string. Each element shows by
    // example the formatting of an element of the reference time. Only these values
    // are recognized. Text in the layout string that is not recognized as part of
    // the reference time is echoed verbatim during Format and expected to appear
    // verbatim in the input to Parse.
    //
    //	Year: "2006" "06"
    //	Month: "Jan" "January" "01" "1"
    //	Day of the week: "Mon" "Monday"
    //	Day of the month: "2" "_2" "02"
    //	Day of the year: "__2" "002"
    //	Hour: "15" "3" "03" (PM or AM)
    //	Minute: "4" "04"
    //	Second: "5" "05"
    //	AM/PM mark: "PM"
    //
    // Numeric time zone offsets format as follows:
    //
    //	"-0700"     ±hhmm
    //	"-07:00"    ±hh:mm
    //	"-07"       ±hh
    //	"-070000"   ±hhmmss
    //	"-07:00:00" ±hh:mm:ss
    //
    // Replacing the sign in the format with a Z triggers
    // the ISO 8601 behavior of printing Z instead of an
    // offset for the UTC zone. Thus:
    //
    //	"Z0700"      Z or ±hhmm
    //	"Z07:00"     Z or ±hh:mm
    //	"Z07"        Z or ±hh
    //	"Z070000"    Z or ±hhmmss
    //	"Z07:00:00"  Z or ±hh:mm:ss
    //
    // Within the format string, the underscores in "_2" and "__2" represent spaces
    // that may be replaced by digits if the following number has multiple digits,
    // for compatibility with fixed-width Unix time formats. A leading zero represents
    // a zero-padded value.
    //
    // The formats __2 and 002 are space-padded and zero-padded
    // three-character day of year; there is no unpadded day of year format.
    //
    // A comma or decimal point followed by one or more zeros represents
    // a fractional second, printed to the given number of decimal places.
    // A comma or decimal point followed by one or more nines represents
    // a fractional second, printed to the given number of decimal places, with
    // trailing zeros removed.
    // For example "15:04:05,000" or "15:04:05.000" formats or parses with
    // millisecond precision.
    //
    // Some valid layouts are invalid time values for time.Parse, due to formats
    // such as _ for space padding and Z for zone information.
    
    
**/
final kitchen : stdgo.GoString = ("3:04PM" : stdgo.GoString);
/**
    // Handy time stamps.
    
    
**/
final stamp : stdgo.GoString = ("Jan _2 15:04:05" : stdgo.GoString);
/**
    // These are predefined layouts for use in Time.Format and time.Parse.
    // The reference time used in these layouts is the specific time stamp:
    //
    //	01/02 03:04:05PM '06 -0700
    //
    // (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
    // That value is recorded as the constant named Layout, listed below. As a Unix
    // time, this is 1136239445. Since MST is GMT-0700, the reference would be
    // printed by the Unix date command as:
    //
    //	Mon Jan 2 15:04:05 MST 2006
    //
    // It is a regrettable historic error that the date uses the American convention
    // of putting the numerical month before the day.
    //
    // The example for Time.Format demonstrates the working of the layout string
    // in detail and is a good reference.
    //
    // Note that the RFC822, RFC850, and RFC1123 formats should be applied
    // only to local times. Applying them to UTC times will use "UTC" as the
    // time zone abbreviation, while strictly speaking those RFCs require the
    // use of "GMT" in that case.
    // In general RFC1123Z should be used instead of RFC1123 for servers
    // that insist on that format, and RFC3339 should be preferred for new protocols.
    // RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
    // when used with time.Parse they do not accept all the time formats
    // permitted by the RFCs and they do accept time formats not formally defined.
    // The RFC3339Nano format removes trailing zeros from the seconds field
    // and thus may not sort correctly once formatted.
    //
    // Most programs can use one of the defined constants as the layout passed to
    // Format or Parse. The rest of this comment can be ignored unless you are
    // creating a custom layout string.
    //
    // To define your own format, write down what the reference time would look like
    // formatted your way; see the values of constants like ANSIC, StampMicro or
    // Kitchen for examples. The model is to demonstrate what the reference time
    // looks like so that the Format and Parse methods can apply the same
    // transformation to a general time value.
    //
    // Here is a summary of the components of a layout string. Each element shows by
    // example the formatting of an element of the reference time. Only these values
    // are recognized. Text in the layout string that is not recognized as part of
    // the reference time is echoed verbatim during Format and expected to appear
    // verbatim in the input to Parse.
    //
    //	Year: "2006" "06"
    //	Month: "Jan" "January" "01" "1"
    //	Day of the week: "Mon" "Monday"
    //	Day of the month: "2" "_2" "02"
    //	Day of the year: "__2" "002"
    //	Hour: "15" "3" "03" (PM or AM)
    //	Minute: "4" "04"
    //	Second: "5" "05"
    //	AM/PM mark: "PM"
    //
    // Numeric time zone offsets format as follows:
    //
    //	"-0700"     ±hhmm
    //	"-07:00"    ±hh:mm
    //	"-07"       ±hh
    //	"-070000"   ±hhmmss
    //	"-07:00:00" ±hh:mm:ss
    //
    // Replacing the sign in the format with a Z triggers
    // the ISO 8601 behavior of printing Z instead of an
    // offset for the UTC zone. Thus:
    //
    //	"Z0700"      Z or ±hhmm
    //	"Z07:00"     Z or ±hh:mm
    //	"Z07"        Z or ±hh
    //	"Z070000"    Z or ±hhmmss
    //	"Z07:00:00"  Z or ±hh:mm:ss
    //
    // Within the format string, the underscores in "_2" and "__2" represent spaces
    // that may be replaced by digits if the following number has multiple digits,
    // for compatibility with fixed-width Unix time formats. A leading zero represents
    // a zero-padded value.
    //
    // The formats __2 and 002 are space-padded and zero-padded
    // three-character day of year; there is no unpadded day of year format.
    //
    // A comma or decimal point followed by one or more zeros represents
    // a fractional second, printed to the given number of decimal places.
    // A comma or decimal point followed by one or more nines represents
    // a fractional second, printed to the given number of decimal places, with
    // trailing zeros removed.
    // For example "15:04:05,000" or "15:04:05.000" formats or parses with
    // millisecond precision.
    //
    // Some valid layouts are invalid time values for time.Parse, due to formats
    // such as _ for space padding and Z for zone information.
    
    
**/
final stampMilli : stdgo.GoString = ("Jan _2 15:04:05.000" : stdgo.GoString);
/**
    // These are predefined layouts for use in Time.Format and time.Parse.
    // The reference time used in these layouts is the specific time stamp:
    //
    //	01/02 03:04:05PM '06 -0700
    //
    // (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
    // That value is recorded as the constant named Layout, listed below. As a Unix
    // time, this is 1136239445. Since MST is GMT-0700, the reference would be
    // printed by the Unix date command as:
    //
    //	Mon Jan 2 15:04:05 MST 2006
    //
    // It is a regrettable historic error that the date uses the American convention
    // of putting the numerical month before the day.
    //
    // The example for Time.Format demonstrates the working of the layout string
    // in detail and is a good reference.
    //
    // Note that the RFC822, RFC850, and RFC1123 formats should be applied
    // only to local times. Applying them to UTC times will use "UTC" as the
    // time zone abbreviation, while strictly speaking those RFCs require the
    // use of "GMT" in that case.
    // In general RFC1123Z should be used instead of RFC1123 for servers
    // that insist on that format, and RFC3339 should be preferred for new protocols.
    // RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
    // when used with time.Parse they do not accept all the time formats
    // permitted by the RFCs and they do accept time formats not formally defined.
    // The RFC3339Nano format removes trailing zeros from the seconds field
    // and thus may not sort correctly once formatted.
    //
    // Most programs can use one of the defined constants as the layout passed to
    // Format or Parse. The rest of this comment can be ignored unless you are
    // creating a custom layout string.
    //
    // To define your own format, write down what the reference time would look like
    // formatted your way; see the values of constants like ANSIC, StampMicro or
    // Kitchen for examples. The model is to demonstrate what the reference time
    // looks like so that the Format and Parse methods can apply the same
    // transformation to a general time value.
    //
    // Here is a summary of the components of a layout string. Each element shows by
    // example the formatting of an element of the reference time. Only these values
    // are recognized. Text in the layout string that is not recognized as part of
    // the reference time is echoed verbatim during Format and expected to appear
    // verbatim in the input to Parse.
    //
    //	Year: "2006" "06"
    //	Month: "Jan" "January" "01" "1"
    //	Day of the week: "Mon" "Monday"
    //	Day of the month: "2" "_2" "02"
    //	Day of the year: "__2" "002"
    //	Hour: "15" "3" "03" (PM or AM)
    //	Minute: "4" "04"
    //	Second: "5" "05"
    //	AM/PM mark: "PM"
    //
    // Numeric time zone offsets format as follows:
    //
    //	"-0700"     ±hhmm
    //	"-07:00"    ±hh:mm
    //	"-07"       ±hh
    //	"-070000"   ±hhmmss
    //	"-07:00:00" ±hh:mm:ss
    //
    // Replacing the sign in the format with a Z triggers
    // the ISO 8601 behavior of printing Z instead of an
    // offset for the UTC zone. Thus:
    //
    //	"Z0700"      Z or ±hhmm
    //	"Z07:00"     Z or ±hh:mm
    //	"Z07"        Z or ±hh
    //	"Z070000"    Z or ±hhmmss
    //	"Z07:00:00"  Z or ±hh:mm:ss
    //
    // Within the format string, the underscores in "_2" and "__2" represent spaces
    // that may be replaced by digits if the following number has multiple digits,
    // for compatibility with fixed-width Unix time formats. A leading zero represents
    // a zero-padded value.
    //
    // The formats __2 and 002 are space-padded and zero-padded
    // three-character day of year; there is no unpadded day of year format.
    //
    // A comma or decimal point followed by one or more zeros represents
    // a fractional second, printed to the given number of decimal places.
    // A comma or decimal point followed by one or more nines represents
    // a fractional second, printed to the given number of decimal places, with
    // trailing zeros removed.
    // For example "15:04:05,000" or "15:04:05.000" formats or parses with
    // millisecond precision.
    //
    // Some valid layouts are invalid time values for time.Parse, due to formats
    // such as _ for space padding and Z for zone information.
    
    
**/
final stampMicro : stdgo.GoString = ("Jan _2 15:04:05.000000" : stdgo.GoString);
/**
    // These are predefined layouts for use in Time.Format and time.Parse.
    // The reference time used in these layouts is the specific time stamp:
    //
    //	01/02 03:04:05PM '06 -0700
    //
    // (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
    // That value is recorded as the constant named Layout, listed below. As a Unix
    // time, this is 1136239445. Since MST is GMT-0700, the reference would be
    // printed by the Unix date command as:
    //
    //	Mon Jan 2 15:04:05 MST 2006
    //
    // It is a regrettable historic error that the date uses the American convention
    // of putting the numerical month before the day.
    //
    // The example for Time.Format demonstrates the working of the layout string
    // in detail and is a good reference.
    //
    // Note that the RFC822, RFC850, and RFC1123 formats should be applied
    // only to local times. Applying them to UTC times will use "UTC" as the
    // time zone abbreviation, while strictly speaking those RFCs require the
    // use of "GMT" in that case.
    // In general RFC1123Z should be used instead of RFC1123 for servers
    // that insist on that format, and RFC3339 should be preferred for new protocols.
    // RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
    // when used with time.Parse they do not accept all the time formats
    // permitted by the RFCs and they do accept time formats not formally defined.
    // The RFC3339Nano format removes trailing zeros from the seconds field
    // and thus may not sort correctly once formatted.
    //
    // Most programs can use one of the defined constants as the layout passed to
    // Format or Parse. The rest of this comment can be ignored unless you are
    // creating a custom layout string.
    //
    // To define your own format, write down what the reference time would look like
    // formatted your way; see the values of constants like ANSIC, StampMicro or
    // Kitchen for examples. The model is to demonstrate what the reference time
    // looks like so that the Format and Parse methods can apply the same
    // transformation to a general time value.
    //
    // Here is a summary of the components of a layout string. Each element shows by
    // example the formatting of an element of the reference time. Only these values
    // are recognized. Text in the layout string that is not recognized as part of
    // the reference time is echoed verbatim during Format and expected to appear
    // verbatim in the input to Parse.
    //
    //	Year: "2006" "06"
    //	Month: "Jan" "January" "01" "1"
    //	Day of the week: "Mon" "Monday"
    //	Day of the month: "2" "_2" "02"
    //	Day of the year: "__2" "002"
    //	Hour: "15" "3" "03" (PM or AM)
    //	Minute: "4" "04"
    //	Second: "5" "05"
    //	AM/PM mark: "PM"
    //
    // Numeric time zone offsets format as follows:
    //
    //	"-0700"     ±hhmm
    //	"-07:00"    ±hh:mm
    //	"-07"       ±hh
    //	"-070000"   ±hhmmss
    //	"-07:00:00" ±hh:mm:ss
    //
    // Replacing the sign in the format with a Z triggers
    // the ISO 8601 behavior of printing Z instead of an
    // offset for the UTC zone. Thus:
    //
    //	"Z0700"      Z or ±hhmm
    //	"Z07:00"     Z or ±hh:mm
    //	"Z07"        Z or ±hh
    //	"Z070000"    Z or ±hhmmss
    //	"Z07:00:00"  Z or ±hh:mm:ss
    //
    // Within the format string, the underscores in "_2" and "__2" represent spaces
    // that may be replaced by digits if the following number has multiple digits,
    // for compatibility with fixed-width Unix time formats. A leading zero represents
    // a zero-padded value.
    //
    // The formats __2 and 002 are space-padded and zero-padded
    // three-character day of year; there is no unpadded day of year format.
    //
    // A comma or decimal point followed by one or more zeros represents
    // a fractional second, printed to the given number of decimal places.
    // A comma or decimal point followed by one or more nines represents
    // a fractional second, printed to the given number of decimal places, with
    // trailing zeros removed.
    // For example "15:04:05,000" or "15:04:05.000" formats or parses with
    // millisecond precision.
    //
    // Some valid layouts are invalid time values for time.Parse, due to formats
    // such as _ for space padding and Z for zone information.
    
    
**/
final stampNano : stdgo.GoString = ("Jan _2 15:04:05.000000000" : stdgo.GoString);
/**
    // These are predefined layouts for use in Time.Format and time.Parse.
    // The reference time used in these layouts is the specific time stamp:
    //
    //	01/02 03:04:05PM '06 -0700
    //
    // (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
    // That value is recorded as the constant named Layout, listed below. As a Unix
    // time, this is 1136239445. Since MST is GMT-0700, the reference would be
    // printed by the Unix date command as:
    //
    //	Mon Jan 2 15:04:05 MST 2006
    //
    // It is a regrettable historic error that the date uses the American convention
    // of putting the numerical month before the day.
    //
    // The example for Time.Format demonstrates the working of the layout string
    // in detail and is a good reference.
    //
    // Note that the RFC822, RFC850, and RFC1123 formats should be applied
    // only to local times. Applying them to UTC times will use "UTC" as the
    // time zone abbreviation, while strictly speaking those RFCs require the
    // use of "GMT" in that case.
    // In general RFC1123Z should be used instead of RFC1123 for servers
    // that insist on that format, and RFC3339 should be preferred for new protocols.
    // RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
    // when used with time.Parse they do not accept all the time formats
    // permitted by the RFCs and they do accept time formats not formally defined.
    // The RFC3339Nano format removes trailing zeros from the seconds field
    // and thus may not sort correctly once formatted.
    //
    // Most programs can use one of the defined constants as the layout passed to
    // Format or Parse. The rest of this comment can be ignored unless you are
    // creating a custom layout string.
    //
    // To define your own format, write down what the reference time would look like
    // formatted your way; see the values of constants like ANSIC, StampMicro or
    // Kitchen for examples. The model is to demonstrate what the reference time
    // looks like so that the Format and Parse methods can apply the same
    // transformation to a general time value.
    //
    // Here is a summary of the components of a layout string. Each element shows by
    // example the formatting of an element of the reference time. Only these values
    // are recognized. Text in the layout string that is not recognized as part of
    // the reference time is echoed verbatim during Format and expected to appear
    // verbatim in the input to Parse.
    //
    //	Year: "2006" "06"
    //	Month: "Jan" "January" "01" "1"
    //	Day of the week: "Mon" "Monday"
    //	Day of the month: "2" "_2" "02"
    //	Day of the year: "__2" "002"
    //	Hour: "15" "3" "03" (PM or AM)
    //	Minute: "4" "04"
    //	Second: "5" "05"
    //	AM/PM mark: "PM"
    //
    // Numeric time zone offsets format as follows:
    //
    //	"-0700"     ±hhmm
    //	"-07:00"    ±hh:mm
    //	"-07"       ±hh
    //	"-070000"   ±hhmmss
    //	"-07:00:00" ±hh:mm:ss
    //
    // Replacing the sign in the format with a Z triggers
    // the ISO 8601 behavior of printing Z instead of an
    // offset for the UTC zone. Thus:
    //
    //	"Z0700"      Z or ±hhmm
    //	"Z07:00"     Z or ±hh:mm
    //	"Z07"        Z or ±hh
    //	"Z070000"    Z or ±hhmmss
    //	"Z07:00:00"  Z or ±hh:mm:ss
    //
    // Within the format string, the underscores in "_2" and "__2" represent spaces
    // that may be replaced by digits if the following number has multiple digits,
    // for compatibility with fixed-width Unix time formats. A leading zero represents
    // a zero-padded value.
    //
    // The formats __2 and 002 are space-padded and zero-padded
    // three-character day of year; there is no unpadded day of year format.
    //
    // A comma or decimal point followed by one or more zeros represents
    // a fractional second, printed to the given number of decimal places.
    // A comma or decimal point followed by one or more nines represents
    // a fractional second, printed to the given number of decimal places, with
    // trailing zeros removed.
    // For example "15:04:05,000" or "15:04:05.000" formats or parses with
    // millisecond precision.
    //
    // Some valid layouts are invalid time values for time.Parse, due to formats
    // such as _ for space padding and Z for zone information.
    
    
**/
final dateTime : stdgo.GoString = ("2006-01-02 15:04:05" : stdgo.GoString);
/**
    // These are predefined layouts for use in Time.Format and time.Parse.
    // The reference time used in these layouts is the specific time stamp:
    //
    //	01/02 03:04:05PM '06 -0700
    //
    // (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
    // That value is recorded as the constant named Layout, listed below. As a Unix
    // time, this is 1136239445. Since MST is GMT-0700, the reference would be
    // printed by the Unix date command as:
    //
    //	Mon Jan 2 15:04:05 MST 2006
    //
    // It is a regrettable historic error that the date uses the American convention
    // of putting the numerical month before the day.
    //
    // The example for Time.Format demonstrates the working of the layout string
    // in detail and is a good reference.
    //
    // Note that the RFC822, RFC850, and RFC1123 formats should be applied
    // only to local times. Applying them to UTC times will use "UTC" as the
    // time zone abbreviation, while strictly speaking those RFCs require the
    // use of "GMT" in that case.
    // In general RFC1123Z should be used instead of RFC1123 for servers
    // that insist on that format, and RFC3339 should be preferred for new protocols.
    // RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
    // when used with time.Parse they do not accept all the time formats
    // permitted by the RFCs and they do accept time formats not formally defined.
    // The RFC3339Nano format removes trailing zeros from the seconds field
    // and thus may not sort correctly once formatted.
    //
    // Most programs can use one of the defined constants as the layout passed to
    // Format or Parse. The rest of this comment can be ignored unless you are
    // creating a custom layout string.
    //
    // To define your own format, write down what the reference time would look like
    // formatted your way; see the values of constants like ANSIC, StampMicro or
    // Kitchen for examples. The model is to demonstrate what the reference time
    // looks like so that the Format and Parse methods can apply the same
    // transformation to a general time value.
    //
    // Here is a summary of the components of a layout string. Each element shows by
    // example the formatting of an element of the reference time. Only these values
    // are recognized. Text in the layout string that is not recognized as part of
    // the reference time is echoed verbatim during Format and expected to appear
    // verbatim in the input to Parse.
    //
    //	Year: "2006" "06"
    //	Month: "Jan" "January" "01" "1"
    //	Day of the week: "Mon" "Monday"
    //	Day of the month: "2" "_2" "02"
    //	Day of the year: "__2" "002"
    //	Hour: "15" "3" "03" (PM or AM)
    //	Minute: "4" "04"
    //	Second: "5" "05"
    //	AM/PM mark: "PM"
    //
    // Numeric time zone offsets format as follows:
    //
    //	"-0700"     ±hhmm
    //	"-07:00"    ±hh:mm
    //	"-07"       ±hh
    //	"-070000"   ±hhmmss
    //	"-07:00:00" ±hh:mm:ss
    //
    // Replacing the sign in the format with a Z triggers
    // the ISO 8601 behavior of printing Z instead of an
    // offset for the UTC zone. Thus:
    //
    //	"Z0700"      Z or ±hhmm
    //	"Z07:00"     Z or ±hh:mm
    //	"Z07"        Z or ±hh
    //	"Z070000"    Z or ±hhmmss
    //	"Z07:00:00"  Z or ±hh:mm:ss
    //
    // Within the format string, the underscores in "_2" and "__2" represent spaces
    // that may be replaced by digits if the following number has multiple digits,
    // for compatibility with fixed-width Unix time formats. A leading zero represents
    // a zero-padded value.
    //
    // The formats __2 and 002 are space-padded and zero-padded
    // three-character day of year; there is no unpadded day of year format.
    //
    // A comma or decimal point followed by one or more zeros represents
    // a fractional second, printed to the given number of decimal places.
    // A comma or decimal point followed by one or more nines represents
    // a fractional second, printed to the given number of decimal places, with
    // trailing zeros removed.
    // For example "15:04:05,000" or "15:04:05.000" formats or parses with
    // millisecond precision.
    //
    // Some valid layouts are invalid time values for time.Parse, due to formats
    // such as _ for space padding and Z for zone information.
    
    
**/
final dateOnly : stdgo.GoString = ("2006-01-02" : stdgo.GoString);
/**
    // These are predefined layouts for use in Time.Format and time.Parse.
    // The reference time used in these layouts is the specific time stamp:
    //
    //	01/02 03:04:05PM '06 -0700
    //
    // (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
    // That value is recorded as the constant named Layout, listed below. As a Unix
    // time, this is 1136239445. Since MST is GMT-0700, the reference would be
    // printed by the Unix date command as:
    //
    //	Mon Jan 2 15:04:05 MST 2006
    //
    // It is a regrettable historic error that the date uses the American convention
    // of putting the numerical month before the day.
    //
    // The example for Time.Format demonstrates the working of the layout string
    // in detail and is a good reference.
    //
    // Note that the RFC822, RFC850, and RFC1123 formats should be applied
    // only to local times. Applying them to UTC times will use "UTC" as the
    // time zone abbreviation, while strictly speaking those RFCs require the
    // use of "GMT" in that case.
    // In general RFC1123Z should be used instead of RFC1123 for servers
    // that insist on that format, and RFC3339 should be preferred for new protocols.
    // RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
    // when used with time.Parse they do not accept all the time formats
    // permitted by the RFCs and they do accept time formats not formally defined.
    // The RFC3339Nano format removes trailing zeros from the seconds field
    // and thus may not sort correctly once formatted.
    //
    // Most programs can use one of the defined constants as the layout passed to
    // Format or Parse. The rest of this comment can be ignored unless you are
    // creating a custom layout string.
    //
    // To define your own format, write down what the reference time would look like
    // formatted your way; see the values of constants like ANSIC, StampMicro or
    // Kitchen for examples. The model is to demonstrate what the reference time
    // looks like so that the Format and Parse methods can apply the same
    // transformation to a general time value.
    //
    // Here is a summary of the components of a layout string. Each element shows by
    // example the formatting of an element of the reference time. Only these values
    // are recognized. Text in the layout string that is not recognized as part of
    // the reference time is echoed verbatim during Format and expected to appear
    // verbatim in the input to Parse.
    //
    //	Year: "2006" "06"
    //	Month: "Jan" "January" "01" "1"
    //	Day of the week: "Mon" "Monday"
    //	Day of the month: "2" "_2" "02"
    //	Day of the year: "__2" "002"
    //	Hour: "15" "3" "03" (PM or AM)
    //	Minute: "4" "04"
    //	Second: "5" "05"
    //	AM/PM mark: "PM"
    //
    // Numeric time zone offsets format as follows:
    //
    //	"-0700"     ±hhmm
    //	"-07:00"    ±hh:mm
    //	"-07"       ±hh
    //	"-070000"   ±hhmmss
    //	"-07:00:00" ±hh:mm:ss
    //
    // Replacing the sign in the format with a Z triggers
    // the ISO 8601 behavior of printing Z instead of an
    // offset for the UTC zone. Thus:
    //
    //	"Z0700"      Z or ±hhmm
    //	"Z07:00"     Z or ±hh:mm
    //	"Z07"        Z or ±hh
    //	"Z070000"    Z or ±hhmmss
    //	"Z07:00:00"  Z or ±hh:mm:ss
    //
    // Within the format string, the underscores in "_2" and "__2" represent spaces
    // that may be replaced by digits if the following number has multiple digits,
    // for compatibility with fixed-width Unix time formats. A leading zero represents
    // a zero-padded value.
    //
    // The formats __2 and 002 are space-padded and zero-padded
    // three-character day of year; there is no unpadded day of year format.
    //
    // A comma or decimal point followed by one or more zeros represents
    // a fractional second, printed to the given number of decimal places.
    // A comma or decimal point followed by one or more nines represents
    // a fractional second, printed to the given number of decimal places, with
    // trailing zeros removed.
    // For example "15:04:05,000" or "15:04:05.000" formats or parses with
    // millisecond precision.
    //
    // Some valid layouts are invalid time values for time.Parse, due to formats
    // such as _ for space padding and Z for zone information.
    
    
**/
final timeOnly : stdgo.GoString = ("15:04:05" : stdgo.GoString);
/**
    
    
    
**/
final __0 : stdgo.GoUInt64 = (0i64 : stdgo.GoUInt64);
/**
    
    
    // "January"
**/
final _stdLongMonth : stdgo.GoUInt64 = (267i64 : stdgo.GoUInt64);
/**
    
    
    // "Jan"
**/
final _stdMonth = (267i64 : stdgo.GoUInt64);
/**
    
    
    // "1"
**/
final _stdNumMonth = (267i64 : stdgo.GoUInt64);
/**
    
    
    // "01"
**/
final _stdZeroMonth = (267i64 : stdgo.GoUInt64);
/**
    
    
    // "Monday"
**/
final _stdLongWeekDay = (267i64 : stdgo.GoUInt64);
/**
    
    
    // "Mon"
**/
final _stdWeekDay = (267i64 : stdgo.GoUInt64);
/**
    
    
    // "2"
**/
final _stdDay = (267i64 : stdgo.GoUInt64);
/**
    
    
    // "_2"
**/
final _stdUnderDay = (267i64 : stdgo.GoUInt64);
/**
    
    
    // "02"
**/
final _stdZeroDay = (267i64 : stdgo.GoUInt64);
/**
    
    
    // "__2"
**/
final _stdUnderYearDay = (267i64 : stdgo.GoUInt64);
/**
    
    
    // "002"
**/
final _stdZeroYearDay = (267i64 : stdgo.GoUInt64);
/**
    
    
    // "15"
**/
final _stdHour : stdgo.GoUInt64 = (530i64 : stdgo.GoUInt64);
/**
    
    
    // "3"
**/
final _stdHour12 = (530i64 : stdgo.GoUInt64);
/**
    
    
    // "03"
**/
final _stdZeroHour12 = (530i64 : stdgo.GoUInt64);
/**
    
    
    // "4"
**/
final _stdMinute = (530i64 : stdgo.GoUInt64);
/**
    
    
    // "04"
**/
final _stdZeroMinute = (530i64 : stdgo.GoUInt64);
/**
    
    
    // "5"
**/
final _stdSecond = (530i64 : stdgo.GoUInt64);
/**
    
    
    // "05"
**/
final _stdZeroSecond = (530i64 : stdgo.GoUInt64);
/**
    
    
    // "2006"
**/
final _stdLongYear : stdgo.GoUInt64 = (276i64 : stdgo.GoUInt64);
/**
    
    
    // "06"
**/
final _stdYear = (276i64 : stdgo.GoUInt64);
/**
    
    
    // "PM"
**/
final _stdPM : stdgo.GoUInt64 = (534i64 : stdgo.GoUInt64);
/**
    
    
    // "pm"
**/
final _stdpm = (534i64 : stdgo.GoUInt64);
/**
    
    
    // "MST"
**/
final _stdTZ : stdgo.GoUInt64 = (35i64 : stdgo.GoUInt64);
/**
    
    
    // "Z0700"  // prints Z for UTC
**/
final _stdISO8601TZ = (35i64 : stdgo.GoUInt64);
/**
    
    
    // "Z070000"
**/
final _stdISO8601SecondsTZ = (35i64 : stdgo.GoUInt64);
/**
    
    
    // "Z07"
**/
final _stdISO8601ShortTZ = (35i64 : stdgo.GoUInt64);
/**
    
    
    // "Z07:00" // prints Z for UTC
**/
final _stdISO8601ColonTZ = (35i64 : stdgo.GoUInt64);
/**
    
    
    // "Z07:00:00"
**/
final _stdISO8601ColonSecondsTZ = (35i64 : stdgo.GoUInt64);
/**
    
    
    // "-0700"  // always numeric
**/
final _stdNumTZ = (35i64 : stdgo.GoUInt64);
/**
    
    
    // "-070000"
**/
final _stdNumSecondsTz = (35i64 : stdgo.GoUInt64);
/**
    
    
    // "-07"    // always numeric
**/
final _stdNumShortTZ = (35i64 : stdgo.GoUInt64);
/**
    
    
    // "-07:00" // always numeric
**/
final _stdNumColonTZ = (35i64 : stdgo.GoUInt64);
/**
    
    
    // "-07:00:00"
**/
final _stdNumColonSecondsTZ = (35i64 : stdgo.GoUInt64);
/**
    
    
    // ".0", ".00", ... , trailing zeros included
**/
final _stdFracSecond0 = (35i64 : stdgo.GoUInt64);
/**
    
    
    // ".9", ".99", ..., trailing zeros omitted
**/
final _stdFracSecond9 = (35i64 : stdgo.GoUInt64);
/**
    
    
    // need month, day, year
**/
final _stdNeedDate : stdgo.GoUInt64 = (256i64 : stdgo.GoUInt64);
/**
    
    
    // need hour, minute, second
**/
final _stdNeedClock : stdgo.GoUInt64 = (512i64 : stdgo.GoUInt64);
/**
    
    
    // extra argument in high bits, above low stdArgShift
**/
final _stdArgShift : stdgo.GoUInt64 = (16i64 : stdgo.GoUInt64);
/**
    
    
    // extra argument in high 4 bits for fractional second separators
**/
final _stdSeparatorShift : stdgo.GoUInt64 = (28i64 : stdgo.GoUInt64);
/**
    
    
    // mask out argument
**/
final _stdMask : stdgo.GoUInt64 = (65535i64 : stdgo.GoUInt64);
/**
    // std0x records the std values for "01", "02", ..., "06".
    
    
**/
var _std0x : stdgo.GoArray<stdgo.GoInt> = (new stdgo.GoArray<stdgo.GoInt>((260 : stdgo.GoInt), (265 : stdgo.GoInt), (526 : stdgo.GoInt), (528 : stdgo.GoInt), (530 : stdgo.GoInt), (276 : stdgo.GoInt)) : stdgo.GoArray<stdgo.GoInt>);
/**
    
    
    
**/
var _longDayNames : stdgo.Slice<stdgo.GoString> = (new stdgo.Slice<stdgo.GoString>(7, 7, ("Sunday" : stdgo.GoString), ("Monday" : stdgo.GoString), ("Tuesday" : stdgo.GoString), ("Wednesday" : stdgo.GoString), ("Thursday" : stdgo.GoString), ("Friday" : stdgo.GoString), ("Saturday" : stdgo.GoString)) : stdgo.Slice<stdgo.GoString>);
/**
    
    
    
**/
var _shortDayNames : stdgo.Slice<stdgo.GoString> = (new stdgo.Slice<stdgo.GoString>(7, 7, ("Sun" : stdgo.GoString), ("Mon" : stdgo.GoString), ("Tue" : stdgo.GoString), ("Wed" : stdgo.GoString), ("Thu" : stdgo.GoString), ("Fri" : stdgo.GoString), ("Sat" : stdgo.GoString)) : stdgo.Slice<stdgo.GoString>);
/**
    
    
    
**/
var _shortMonthNames : stdgo.Slice<stdgo.GoString> = (new stdgo.Slice<stdgo.GoString>(
12,
12,
("Jan" : stdgo.GoString),
("Feb" : stdgo.GoString),
("Mar" : stdgo.GoString),
("Apr" : stdgo.GoString),
("May" : stdgo.GoString),
("Jun" : stdgo.GoString),
("Jul" : stdgo.GoString),
("Aug" : stdgo.GoString),
("Sep" : stdgo.GoString),
("Oct" : stdgo.GoString),
("Nov" : stdgo.GoString),
("Dec" : stdgo.GoString)) : stdgo.Slice<stdgo.GoString>);
/**
    
    
    
**/
var _longMonthNames : stdgo.Slice<stdgo.GoString> = (new stdgo.Slice<stdgo.GoString>(
12,
12,
("January" : stdgo.GoString),
("February" : stdgo.GoString),
("March" : stdgo.GoString),
("April" : stdgo.GoString),
("May" : stdgo.GoString),
("June" : stdgo.GoString),
("July" : stdgo.GoString),
("August" : stdgo.GoString),
("September" : stdgo.GoString),
("October" : stdgo.GoString),
("November" : stdgo.GoString),
("December" : stdgo.GoString)) : stdgo.Slice<stdgo.GoString>);
/**
    // Never printed, just needs to be non-nil for return by atoi.
    
    
**/
var _errAtoi : stdgo.Error = stdgo.errors.Errors.new_(("time: invalid number" : stdgo.GoString));
/**
    
    
    // placeholder not passed to user
**/
var _errBad : stdgo.Error = stdgo.errors.Errors.new_(("bad value for field" : stdgo.GoString));
/**
    // These are borrowed from unicode/utf8 and strconv and replicate behavior in
    // that package, since we can't take a dependency on either.
    
    
**/
final _lowerhex : stdgo.GoString = ("0123456789abcdef" : stdgo.GoString);
/**
    // These are borrowed from unicode/utf8 and strconv and replicate behavior in
    // that package, since we can't take a dependency on either.
    
    
**/
final _runeSelf : stdgo.GoUInt64 = (128i64 : stdgo.GoUInt64);
/**
    // These are borrowed from unicode/utf8 and strconv and replicate behavior in
    // that package, since we can't take a dependency on either.
    
    
**/
final _runeError : stdgo.GoInt32 = (65533 : stdgo.GoInt32);
/**
    
    
    // never printed
**/
var _errLeadingInt : stdgo.Error = stdgo.errors.Errors.new_(("time: bad [0-9]*" : stdgo.GoString));
/**
    
    
    
**/
var _unitMap : stdgo.GoMap<stdgo.GoString, stdgo.GoUInt64> = ({
        final x = new stdgo.GoMap.GoStringMap<stdgo.GoUInt64>();
        x.__defaultValue__ = () -> (0 : stdgo.GoUInt64);
        @:mergeBlock {
            x.set(("ns" : stdgo.GoString), ((1i64 : stdgo.time.Time.Duration) : stdgo.GoUInt64));
            x.set(("us" : stdgo.GoString), ((1000i64 : stdgo.time.Time.Duration) : stdgo.GoUInt64));
            x.set(("µs" : stdgo.GoString), ((1000i64 : stdgo.time.Time.Duration) : stdgo.GoUInt64));
            x.set(("μs" : stdgo.GoString), ((1000i64 : stdgo.time.Time.Duration) : stdgo.GoUInt64));
            x.set(("ms" : stdgo.GoString), ((1000000i64 : stdgo.time.Time.Duration) : stdgo.GoUInt64));
            x.set(("s" : stdgo.GoString), ((1000000000i64 : stdgo.time.Time.Duration) : stdgo.GoUInt64));
            x.set(("m" : stdgo.GoString), ((60000000000i64 : stdgo.time.Time.Duration) : stdgo.GoUInt64));
            x.set(("h" : stdgo.GoString), ((3600000000000i64 : stdgo.time.Time.Duration) : stdgo.GoUInt64));
        };
        x;
    } : stdgo.GoMap<stdgo.GoString, stdgo.GoUInt64>);
/**
    
    
    
**/
var _origPlatformZoneSources : stdgo.Slice<stdgo.GoString> = _platformZoneSources;
/**
    
    
    
**/
var interrupt : () -> Void = _interrupt;
/**
    
    
    
**/
var daysIn : (stdgo.time.Time.Month, stdgo.GoInt) -> stdgo.GoInt = _daysIn;
/**
    
    
    
**/
var minMonoTime : stdgo.time.Time.Time = ({ _wall : (-9223372036854775808i64 : stdgo.GoUInt64), _ext : (-9223372036854775808i64 : stdgo.GoInt64), _loc : utc } : stdgo.time.Time.Time);
/**
    
    
    
**/
var maxMonoTime : stdgo.time.Time.Time = ({ _wall : (-9223372036854775808i64 : stdgo.GoUInt64), _ext : (9223372036854775807i64 : stdgo.GoInt64), _loc : utc } : stdgo.time.Time.Time);
/**
    
    
    
**/
var notMonoNegativeTime : stdgo.time.Time.Time = ({ _wall : (0i64 : stdgo.GoUInt64), _ext : (-9223372036854775758i64 : stdgo.GoInt64) } : stdgo.time.Time.Time);
/**
    
    
    
**/
final _hasMonotonic : stdgo.GoUInt64 = (-9223372036854775808i64 : stdgo.GoUInt64);
/**
    
    
    // year 2157
**/
final _maxWall : stdgo.GoInt64 = (68043243391i64 : stdgo.GoInt64);
/**
    
    
    // year 1885
**/
final _minWall : stdgo.GoInt64 = (59453308800i64 : stdgo.GoInt64);
/**
    
    
    
**/
final _nsecMask : stdgo.GoUInt64 = (1073741823i64 : stdgo.GoUInt64);
/**
    
    
    
**/
final _nsecShift : stdgo.GoUInt64 = (30i64 : stdgo.GoUInt64);
/**
    
    
    
**/
final january : stdgo.time.Time.Month = (12 : stdgo.time.Time.Month);
/**
    
    
    
**/
final february = (12 : stdgo.time.Time.Month);
/**
    
    
    
**/
final march = (12 : stdgo.time.Time.Month);
/**
    
    
    
**/
final april = (12 : stdgo.time.Time.Month);
/**
    
    
    
**/
final may = (12 : stdgo.time.Time.Month);
/**
    
    
    
**/
final june = (12 : stdgo.time.Time.Month);
/**
    
    
    
**/
final july = (12 : stdgo.time.Time.Month);
/**
    
    
    
**/
final august = (12 : stdgo.time.Time.Month);
/**
    
    
    
**/
final september = (12 : stdgo.time.Time.Month);
/**
    
    
    
**/
final october = (12 : stdgo.time.Time.Month);
/**
    
    
    
**/
final november = (12 : stdgo.time.Time.Month);
/**
    
    
    
**/
final december = (12 : stdgo.time.Time.Month);
/**
    
    
    
**/
final sunday : stdgo.time.Time.Weekday = (6 : stdgo.time.Time.Weekday);
/**
    
    
    
**/
final monday = (6 : stdgo.time.Time.Weekday);
/**
    
    
    
**/
final tuesday = (6 : stdgo.time.Time.Weekday);
/**
    
    
    
**/
final wednesday = (6 : stdgo.time.Time.Weekday);
/**
    
    
    
**/
final thursday = (6 : stdgo.time.Time.Weekday);
/**
    
    
    
**/
final friday = (6 : stdgo.time.Time.Weekday);
/**
    
    
    
**/
final saturday = (6 : stdgo.time.Time.Weekday);
/**
    // The unsigned zero year for internal calculations.
    // Must be 1 mod 400, and times before it will not compute correctly,
    // but otherwise can be changed at will.
    
    
**/
final _absoluteZeroYear : stdgo.GoUInt64 = (0i64 : stdgo.GoUInt64);
/**
    // The year of the zero Time.
    // Assumed by the unixToInternal computation below.
    
    
**/
final _internalYear : stdgo.GoUInt64 = (1i64 : stdgo.GoUInt64);
/**
    // Offsets to convert between internal and absolute or Unix times.
    
    
**/
final _absoluteToInternal : stdgo.GoInt64 = (-9223371966579724800i64 : stdgo.GoInt64);
/**
    
    
    
**/
final _internalToAbsolute : stdgo.GoInt64 = (9223371966579724800i64 : stdgo.GoInt64);
/**
    
    
    
**/
final _unixToInternal : stdgo.GoInt64 = (62135596800i64 : stdgo.GoInt64);
/**
    
    
    
**/
final _internalToUnix : stdgo.GoInt64 = (-62135596800i64 : stdgo.GoInt64);
/**
    
    
    
**/
final _wallToInternal : stdgo.GoInt64 = (59453308800i64 : stdgo.GoInt64);
/**
    
    
    
**/
final _minDuration : stdgo.time.Time.Duration = (-9223372036854775808i64 : stdgo.time.Time.Duration);
/**
    
    
    
**/
final _maxDuration : stdgo.time.Time.Duration = (9223372036854775807i64 : stdgo.time.Time.Duration);
/**
    // Common durations. There is no definition for units of Day or larger
    // to avoid confusion across daylight savings time zone transitions.
    //
    // To count the number of units in a Duration, divide:
    //
    //	second := time.Second
    //	fmt.Print(int64(second/time.Millisecond)) // prints 1000
    //
    // To convert an integer number of units to a Duration, multiply:
    //
    //	seconds := 10
    //	fmt.Print(time.Duration(seconds)*time.Second) // prints 10s
    
    
**/
final nanosecond : stdgo.time.Time.Duration = (1i64 : stdgo.time.Time.Duration);
/**
    // Common durations. There is no definition for units of Day or larger
    // to avoid confusion across daylight savings time zone transitions.
    //
    // To count the number of units in a Duration, divide:
    //
    //	second := time.Second
    //	fmt.Print(int64(second/time.Millisecond)) // prints 1000
    //
    // To convert an integer number of units to a Duration, multiply:
    //
    //	seconds := 10
    //	fmt.Print(time.Duration(seconds)*time.Second) // prints 10s
    
    
**/
final microsecond : stdgo.time.Time.Duration = (1000i64 : stdgo.time.Time.Duration);
/**
    // Common durations. There is no definition for units of Day or larger
    // to avoid confusion across daylight savings time zone transitions.
    //
    // To count the number of units in a Duration, divide:
    //
    //	second := time.Second
    //	fmt.Print(int64(second/time.Millisecond)) // prints 1000
    //
    // To convert an integer number of units to a Duration, multiply:
    //
    //	seconds := 10
    //	fmt.Print(time.Duration(seconds)*time.Second) // prints 10s
    
    
**/
final millisecond : stdgo.time.Time.Duration = (1000000i64 : stdgo.time.Time.Duration);
/**
    // Common durations. There is no definition for units of Day or larger
    // to avoid confusion across daylight savings time zone transitions.
    //
    // To count the number of units in a Duration, divide:
    //
    //	second := time.Second
    //	fmt.Print(int64(second/time.Millisecond)) // prints 1000
    //
    // To convert an integer number of units to a Duration, multiply:
    //
    //	seconds := 10
    //	fmt.Print(time.Duration(seconds)*time.Second) // prints 10s
    
    
**/
final second : stdgo.time.Time.Duration = (1000000000i64 : stdgo.time.Time.Duration);
/**
    // Common durations. There is no definition for units of Day or larger
    // to avoid confusion across daylight savings time zone transitions.
    //
    // To count the number of units in a Duration, divide:
    //
    //	second := time.Second
    //	fmt.Print(int64(second/time.Millisecond)) // prints 1000
    //
    // To convert an integer number of units to a Duration, multiply:
    //
    //	seconds := 10
    //	fmt.Print(time.Duration(seconds)*time.Second) // prints 10s
    
    
**/
final minute : stdgo.time.Time.Duration = (60000000000i64 : stdgo.time.Time.Duration);
/**
    // Common durations. There is no definition for units of Day or larger
    // to avoid confusion across daylight savings time zone transitions.
    //
    // To count the number of units in a Duration, divide:
    //
    //	second := time.Second
    //	fmt.Print(int64(second/time.Millisecond)) // prints 1000
    //
    // To convert an integer number of units to a Duration, multiply:
    //
    //	seconds := 10
    //	fmt.Print(time.Duration(seconds)*time.Second) // prints 10s
    
    
**/
final hour : stdgo.time.Time.Duration = (3600000000000i64 : stdgo.time.Time.Duration);
/**
    
    
    
**/
final _secondsPerMinute : stdgo.GoUInt64 = (60i64 : stdgo.GoUInt64);
/**
    
    
    
**/
final _secondsPerHour : stdgo.GoUInt64 = (3600i64 : stdgo.GoUInt64);
/**
    
    
    
**/
final _secondsPerDay : stdgo.GoUInt64 = (86400i64 : stdgo.GoUInt64);
/**
    
    
    
**/
final _secondsPerWeek : stdgo.GoUInt64 = (604800i64 : stdgo.GoUInt64);
/**
    
    
    
**/
final _daysPer400Years : stdgo.GoUInt64 = (146097i64 : stdgo.GoUInt64);
/**
    
    
    
**/
final _daysPer100Years : stdgo.GoUInt64 = (36524i64 : stdgo.GoUInt64);
/**
    
    
    
**/
final _daysPer4Years : stdgo.GoUInt64 = (1461i64 : stdgo.GoUInt64);
/**
    // daysBefore[m] counts the number of days in a non-leap year
    // before month m begins. There is an entry for m=12, counting
    // the number of days before January of next year (365).
    
    
**/
var _daysBefore : stdgo.GoArray<stdgo.GoInt32> = (new stdgo.GoArray<stdgo.GoInt32>(
(0 : stdgo.GoInt32),
(31 : stdgo.GoInt32),
(59 : stdgo.GoInt32),
(90 : stdgo.GoInt32),
(120 : stdgo.GoInt32),
(151 : stdgo.GoInt32),
(181 : stdgo.GoInt32),
(212 : stdgo.GoInt32),
(243 : stdgo.GoInt32),
(273 : stdgo.GoInt32),
(304 : stdgo.GoInt32),
(334 : stdgo.GoInt32),
(365 : stdgo.GoInt32)) : stdgo.GoArray<stdgo.GoInt32>);
/**
    // Monotonic times are reported as offsets from startNano.
    // We initialize startNano to runtimeNano() - 1 so that on systems where
    // monotonic time resolution is fairly low (e.g. Windows 2008
    // which appears to have a default resolution of 15ms),
    // we avoid ever reporting a monotonic time of 0.
    // (Callers may want to use 0 as "time not set".)
    
    
**/
var _startNano : stdgo.GoInt64 = _runtimeNano() - (1i64 : stdgo.GoInt64);
/**
    
    
    // For general situation
**/
final _timeBinaryVersionV1 : stdgo.GoUInt8 = (2 : stdgo.GoUInt8);
/**
    
    
    // For LMT only
**/
final _timeBinaryVersionV2 = (2 : stdgo.GoUInt8);
/**
    // alpha and omega are the beginning and end of time for zone
    // transitions.
    
    // math.MinInt64
**/
final _alpha : stdgo.GoUInt64 = (0i64 : stdgo.GoUInt64);
/**
    // alpha and omega are the beginning and end of time for zone
    // transitions.
    
    // math.MaxInt64
**/
final _omega : stdgo.GoUInt64 = (9223372036854775807i64 : stdgo.GoUInt64);
/**
    // UTC represents Universal Coordinated Time (UTC).
    
    
**/
var utc : stdgo.Ref<stdgo.time.Time.Location> = (stdgo.Go.setRef(_utcLoc) : stdgo.Ref<stdgo.time.Time.Location>);
/**
    // utcLoc is separate so that get can refer to &utcLoc
    // and ensure that it never returns a nil *Location,
    // even if a badly behaved client has changed UTC.
    
    
**/
var _utcLoc : stdgo.time.Time.Location = ({ _name : ("UTC" : stdgo.GoString) } : stdgo.time.Time.Location);
/**
    // Local represents the system's local time zone.
    // On Unix systems, Local consults the TZ environment
    // variable to find the time zone to use. No TZ means
    // use the system default /etc/localtime.
    // TZ="" means use UTC.
    // TZ="foo" means use file foo in the system timezone directory.
    
    
**/
var local : stdgo.Ref<stdgo.time.Time.Location> = (stdgo.Go.setRef(_localLoc) : stdgo.Ref<stdgo.time.Time.Location>);
/**
    // localLoc is separate so that initLocal can initialize
    // it even if a client has changed Local.
    
    
**/
var _localLoc : Location = ({} : stdgo.time.Time.Location);
/**
    
    
    
**/
var _localOnce : stdgo.sync.Sync.Once = ({} : stdgo.sync.Sync.Once);
/**
    
    
    
**/
var _unnamedFixedZones : stdgo.Slice<stdgo.Ref<Location>> = (null : stdgo.Slice<stdgo.Ref<stdgo.time.Time.Location>>);
/**
    
    
    
**/
var _unnamedFixedZonesOnce : stdgo.sync.Sync.Once = ({} : stdgo.sync.Sync.Once);
/**
    
    
    
**/
final _ruleJulian : stdgo.time.Time.T_ruleKind = (2 : stdgo.time.Time.T_ruleKind);
/**
    
    
    
**/
final _ruleDOY = (2 : stdgo.time.Time.T_ruleKind);
/**
    
    
    
**/
final _ruleMonthWeekDay = (2 : stdgo.time.Time.T_ruleKind);
/**
    
    
    
**/
var _errLocation : stdgo.Error = stdgo.errors.Errors.new_(("time: invalid location name" : stdgo.GoString));
/**
    
    
    
**/
var _zoneinfo : stdgo.Pointer<stdgo.GoString> = (null : stdgo.Pointer<stdgo.GoString>);
/**
    
    
    
**/
var _zoneinfoOnce : stdgo.sync.Sync.Once = ({} : stdgo.sync.Sync.Once);
/**
    
    
    
**/
var _platformZoneSources : stdgo.Slice<stdgo.GoString> = (new stdgo.Slice<stdgo.GoString>(3, 3, ("/usr/share/zoneinfo/" : stdgo.GoString), ("/usr/share/lib/zoneinfo/" : stdgo.GoString), ("/usr/lib/locale/TZ/" : stdgo.GoString)) : stdgo.Slice<stdgo.GoString>);
/**
    // loadFromEmbeddedTZData is used to load a specific tzdata file
    // from tzdata information embedded in the binary itself.
    // This is set when the time/tzdata package is imported,
    // via registerLoadFromEmbeddedTzdata.
    
    
**/
var _loadFromEmbeddedTZData : (_zipname:stdgo.GoString) -> { var _0 : stdgo.GoString; var _1 : stdgo.Error; } = null;
/**
    // maxFileSize is the max permitted size of files read by readFile.
    // As reference, the zoneinfo.zip distributed by Go is ~350 KB,
    // so 10MB is overkill.
    
    
**/
final _maxFileSize : stdgo.GoUInt64 = (10485760i64 : stdgo.GoUInt64);
/**
    // Copies of io.Seek* constants to avoid importing "io":
    
    
**/
final _seekStart : stdgo.GoUInt64 = (0i64 : stdgo.GoUInt64);
/**
    // Copies of io.Seek* constants to avoid importing "io":
    
    
**/
final _seekCurrent : stdgo.GoUInt64 = (1i64 : stdgo.GoUInt64);
/**
    // Copies of io.Seek* constants to avoid importing "io":
    
    
**/
final _seekEnd : stdgo.GoUInt64 = (2i64 : stdgo.GoUInt64);
/**
    
    
    
**/
var _errBadData : stdgo.Error = stdgo.errors.Errors.new_(("malformed time zone information" : stdgo.GoString));
/**
    // loadTzinfoFromTzdata returns the time zone information of the time zone
    // with the given name, from a tzdata database file as they are typically
    // found on android.
    
    
**/
var _loadTzinfoFromTzdata : (_file:stdgo.GoString, _name:stdgo.GoString) -> { var _0 : stdgo.Slice<stdgo.GoByte>; var _1 : stdgo.Error; } = null;
/**
    
    
    
**/
@:structInit class Rule {
    public var kind : stdgo.time.Time.RuleKind = ((0 : stdgo.GoInt) : stdgo.time.Time.RuleKind);
    public var day : stdgo.GoInt = 0;
    public var week : stdgo.GoInt = 0;
    public var mon : stdgo.GoInt = 0;
    public var time : stdgo.GoInt = 0;
    public function new(?kind:stdgo.time.Time.RuleKind, ?day:stdgo.GoInt, ?week:stdgo.GoInt, ?mon:stdgo.GoInt, ?time:stdgo.GoInt) {
        if (kind != null) this.kind = kind;
        if (day != null) this.day = day;
        if (week != null) this.week = week;
        if (mon != null) this.mon = mon;
        if (time != null) this.time = time;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Rule(kind, day, week, mon, time);
    }
}
/**
    // ParseError describes a problem parsing a time string.
    
    
**/
@:structInit @:using(stdgo.time.Time.ParseError_static_extension) class ParseError {
    public var layout : stdgo.GoString = "";
    public var value : stdgo.GoString = "";
    public var layoutElem : stdgo.GoString = "";
    public var valueElem : stdgo.GoString = "";
    public var message : stdgo.GoString = "";
    public function new(?layout:stdgo.GoString, ?value:stdgo.GoString, ?layoutElem:stdgo.GoString, ?valueElem:stdgo.GoString, ?message:stdgo.GoString) {
        if (layout != null) this.layout = layout;
        if (value != null) this.value = value;
        if (layoutElem != null) this.layoutElem = layoutElem;
        if (valueElem != null) this.valueElem = valueElem;
        if (message != null) this.message = message;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new ParseError(layout, value, layoutElem, valueElem, message);
    }
}
/**
    // Interface to timers implemented in package runtime.
    // Must be in sync with ../runtime/time.go:/^type timer
    
    
**/
@:structInit @:private class T_runtimeTimer {
    public var _pp : stdgo.GoUIntptr = 0;
    public var _when : stdgo.GoInt64 = 0;
    public var _period : stdgo.GoInt64 = 0;
    public var _f : (stdgo.AnyInterface, stdgo.GoUIntptr) -> Void = null;
    public var _arg : stdgo.AnyInterface = (null : stdgo.AnyInterface);
    public var _seq : stdgo.GoUIntptr = 0;
    public var _nextwhen : stdgo.GoInt64 = 0;
    public var _status : stdgo.GoUInt32 = 0;
    public function new(?_pp:stdgo.GoUIntptr, ?_when:stdgo.GoInt64, ?_period:stdgo.GoInt64, ?_f:(stdgo.AnyInterface, stdgo.GoUIntptr) -> Void, ?_arg:stdgo.AnyInterface, ?_seq:stdgo.GoUIntptr, ?_nextwhen:stdgo.GoInt64, ?_status:stdgo.GoUInt32) {
        if (_pp != null) this._pp = _pp;
        if (_when != null) this._when = _when;
        if (_period != null) this._period = _period;
        if (_f != null) this._f = _f;
        if (_arg != null) this._arg = _arg;
        if (_seq != null) this._seq = _seq;
        if (_nextwhen != null) this._nextwhen = _nextwhen;
        if (_status != null) this._status = _status;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_runtimeTimer(_pp, _when, _period, _f, _arg, _seq, _nextwhen, _status);
    }
}
/**
    // The Timer type represents a single event.
    // When the Timer expires, the current time will be sent on C,
    // unless the Timer was created by AfterFunc.
    // A Timer must be created with NewTimer or AfterFunc.
    
    
**/
@:structInit @:using(stdgo.time.Time.Timer_static_extension) class Timer {
    public var c : stdgo.Chan<stdgo.time.Time.Time> = (null : stdgo.Chan<stdgo.time.Time.Time>);
    public var _r : stdgo.time.Time.T_runtimeTimer = ({} : stdgo.time.Time.T_runtimeTimer);
    public function new(?c:stdgo.Chan<stdgo.time.Time.Time>, ?_r:stdgo.time.Time.T_runtimeTimer) {
        if (c != null) this.c = c;
        if (_r != null) this._r = _r;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Timer(c, _r);
    }
}
/**
    // A Ticker holds a channel that delivers “ticks” of a clock
    // at intervals.
    
    
**/
@:structInit @:using(stdgo.time.Time.Ticker_static_extension) class Ticker {
    public var c : stdgo.Chan<stdgo.time.Time.Time> = (null : stdgo.Chan<stdgo.time.Time.Time>);
    public var _r : stdgo.time.Time.T_runtimeTimer = ({} : stdgo.time.Time.T_runtimeTimer);
    public function new(?c:stdgo.Chan<stdgo.time.Time.Time>, ?_r:stdgo.time.Time.T_runtimeTimer) {
        if (c != null) this.c = c;
        if (_r != null) this._r = _r;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Ticker(c, _r);
    }
}
/**
    // A Time represents an instant in time with nanosecond precision.
    //
    // Programs using times should typically store and pass them as values,
    // not pointers. That is, time variables and struct fields should be of
    // type time.Time, not *time.Time.
    //
    // A Time value can be used by multiple goroutines simultaneously except
    // that the methods GobDecode, UnmarshalBinary, UnmarshalJSON and
    // UnmarshalText are not concurrency-safe.
    //
    // Time instants can be compared using the Before, After, and Equal methods.
    // The Sub method subtracts two instants, producing a Duration.
    // The Add method adds a Time and a Duration, producing a Time.
    //
    // The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC.
    // As this time is unlikely to come up in practice, the IsZero method gives
    // a simple way of detecting a time that has not been initialized explicitly.
    //
    // Each Time has associated with it a Location, consulted when computing the
    // presentation form of the time, such as in the Format, Hour, and Year methods.
    // The methods Local, UTC, and In return a Time with a specific location.
    // Changing the location in this way changes only the presentation; it does not
    // change the instant in time being denoted and therefore does not affect the
    // computations described in earlier paragraphs.
    //
    // Representations of a Time value saved by the GobEncode, MarshalBinary,
    // MarshalJSON, and MarshalText methods store the Time.Location's offset, but not
    // the location name. They therefore lose information about Daylight Saving Time.
    //
    // In addition to the required “wall clock” reading, a Time may contain an optional
    // reading of the current process's monotonic clock, to provide additional precision
    // for comparison or subtraction.
    // See the “Monotonic Clocks” section in the package documentation for details.
    //
    // Note that the Go == operator compares not just the time instant but also the
    // Location and the monotonic clock reading. Therefore, Time values should not
    // be used as map or database keys without first guaranteeing that the
    // identical Location has been set for all values, which can be achieved
    // through use of the UTC or Local method, and that the monotonic clock reading
    // has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u)
    // to t == u, since t.Equal uses the most accurate comparison available and
    // correctly handles the case when only one of its arguments has a monotonic
    // clock reading.
    
    
**/
@:structInit @:using(stdgo.time.Time.Time_static_extension) class Time {
    /**
        // wall and ext encode the wall time seconds, wall time nanoseconds,
        // and optional monotonic clock reading in nanoseconds.
        //
        // From high to low bit position, wall encodes a 1-bit flag (hasMonotonic),
        // a 33-bit seconds field, and a 30-bit wall time nanoseconds field.
        // The nanoseconds field is in the range [0, 999999999].
        // If the hasMonotonic bit is 0, then the 33-bit field must be zero
        // and the full signed 64-bit wall seconds since Jan 1 year 1 is stored in ext.
        // If the hasMonotonic bit is 1, then the 33-bit field holds a 33-bit
        // unsigned wall seconds since Jan 1 year 1885, and ext holds a
        // signed 64-bit monotonic clock reading, nanoseconds since process start.
    **/
    public var _wall : stdgo.GoUInt64 = 0;
    public var _ext : stdgo.GoInt64 = 0;
    /**
        // loc specifies the Location that should be used to
        // determine the minute, hour, month, day, and year
        // that correspond to this Time.
        // The nil location means UTC.
        // All UTC times are represented with loc==nil, never loc==&utcLoc.
    **/
    public var _loc : stdgo.Ref<stdgo.time.Time.Location> = (null : stdgo.Ref<stdgo.time.Time.Location>);
    public function new(?_wall:stdgo.GoUInt64, ?_ext:stdgo.GoInt64, ?_loc:stdgo.Ref<stdgo.time.Time.Location>) {
        if (_wall != null) this._wall = _wall;
        if (_ext != null) this._ext = _ext;
        if (_loc != null) this._loc = _loc;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Time(_wall, _ext, _loc);
    }
}
/**
    // A Location maps time instants to the zone in use at that time.
    // Typically, the Location represents the collection of time offsets
    // in use in a geographical area. For many Locations the time offset varies
    // depending on whether daylight savings time is in use at the time instant.
    
    
**/
@:structInit @:using(stdgo.time.Time.Location_static_extension) class Location {
    public var _name : stdgo.GoString = "";
    public var _zone : stdgo.Slice<stdgo.time.Time.T_zone> = (null : stdgo.Slice<stdgo.time.Time.T_zone>);
    public var _tx : stdgo.Slice<stdgo.time.Time.T_zoneTrans> = (null : stdgo.Slice<stdgo.time.Time.T_zoneTrans>);
    /**
        // The tzdata information can be followed by a string that describes
        // how to handle DST transitions not recorded in zoneTrans.
        // The format is the TZ environment variable without a colon; see
        // https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html.
        // Example string, for America/Los_Angeles: PST8PDT,M3.2.0,M11.1.0
    **/
    public var _extend : stdgo.GoString = "";
    /**
        // Most lookups will be for the current time.
        // To avoid the binary search through tx, keep a
        // static one-element cache that gives the correct
        // zone for the time when the Location was created.
        // if cacheStart <= t < cacheEnd,
        // lookup can return cacheZone.
        // The units for cacheStart and cacheEnd are seconds
        // since January 1, 1970 UTC, to match the argument
        // to lookup.
    **/
    public var _cacheStart : stdgo.GoInt64 = 0;
    public var _cacheEnd : stdgo.GoInt64 = 0;
    public var _cacheZone : stdgo.Ref<stdgo.time.Time.T_zone> = (null : stdgo.Ref<stdgo.time.Time.T_zone>);
    public function new(?_name:stdgo.GoString, ?_zone:stdgo.Slice<stdgo.time.Time.T_zone>, ?_tx:stdgo.Slice<stdgo.time.Time.T_zoneTrans>, ?_extend:stdgo.GoString, ?_cacheStart:stdgo.GoInt64, ?_cacheEnd:stdgo.GoInt64, ?_cacheZone:stdgo.Ref<stdgo.time.Time.T_zone>) {
        if (_name != null) this._name = _name;
        if (_zone != null) this._zone = _zone;
        if (_tx != null) this._tx = _tx;
        if (_extend != null) this._extend = _extend;
        if (_cacheStart != null) this._cacheStart = _cacheStart;
        if (_cacheEnd != null) this._cacheEnd = _cacheEnd;
        if (_cacheZone != null) this._cacheZone = _cacheZone;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new Location(_name, _zone, _tx, _extend, _cacheStart, _cacheEnd, _cacheZone);
    }
}
/**
    // A zone represents a single time zone such as CET.
    
    
**/
@:structInit @:private class T_zone {
    public var _name : stdgo.GoString = "";
    public var _offset : stdgo.GoInt = 0;
    public var _isDST : Bool = false;
    public function new(?_name:stdgo.GoString, ?_offset:stdgo.GoInt, ?_isDST:Bool) {
        if (_name != null) this._name = _name;
        if (_offset != null) this._offset = _offset;
        if (_isDST != null) this._isDST = _isDST;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_zone(_name, _offset, _isDST);
    }
}
/**
    // A zoneTrans represents a single time zone transition.
    
    
**/
@:structInit @:private class T_zoneTrans {
    public var _when : stdgo.GoInt64 = 0;
    public var _index : stdgo.GoUInt8 = 0;
    public var _isstd : Bool = false;
    public var _isutc : Bool = false;
    public function new(?_when:stdgo.GoInt64, ?_index:stdgo.GoUInt8, ?_isstd:Bool, ?_isutc:Bool) {
        if (_when != null) this._when = _when;
        if (_index != null) this._index = _index;
        if (_isstd != null) this._isstd = _isstd;
        if (_isutc != null) this._isutc = _isutc;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_zoneTrans(_when, _index, _isstd, _isutc);
    }
}
/**
    // rule is a rule read from a tzset string.
    
    
**/
@:structInit @:private class T_rule {
    public var _kind : stdgo.time.Time.T_ruleKind = ((0 : stdgo.GoInt) : stdgo.time.Time.T_ruleKind);
    public var _day : stdgo.GoInt = 0;
    public var _week : stdgo.GoInt = 0;
    public var _mon : stdgo.GoInt = 0;
    public var _time : stdgo.GoInt = 0;
    public function new(?_kind:stdgo.time.Time.T_ruleKind, ?_day:stdgo.GoInt, ?_week:stdgo.GoInt, ?_mon:stdgo.GoInt, ?_time:stdgo.GoInt) {
        if (_kind != null) this._kind = _kind;
        if (_day != null) this._day = _day;
        if (_week != null) this._week = _week;
        if (_mon != null) this._mon = _mon;
        if (_time != null) this._time = _time;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_rule(_kind, _day, _week, _mon, _time);
    }
}
/**
    // Simple I/O interface to binary blob of data.
    
    
**/
@:structInit @:private @:using(stdgo.time.Time.T_dataIO_static_extension) class T_dataIO {
    public var _p : stdgo.Slice<stdgo.GoUInt8> = (null : stdgo.Slice<stdgo.GoUInt8>);
    public var _error : Bool = false;
    public function new(?_p:stdgo.Slice<stdgo.GoUInt8>, ?_error:Bool) {
        if (_p != null) this._p = _p;
        if (_error != null) this._error = _error;
    }
    public function __underlying__() return stdgo.Go.toInterface(this);
    public function __copy__() {
        return new T_dataIO(_p, _error);
    }
}
@:named typedef RuleKind = stdgo.GoInt;
/**
    // A Month specifies a month of the year (January = 1, ...).
**/
@:named @:using(stdgo.time.Time.Month_static_extension) typedef Month = stdgo.GoInt;
/**
    // A Weekday specifies a day of the week (Sunday = 0, ...).
**/
@:named @:using(stdgo.time.Time.Weekday_static_extension) typedef Weekday = stdgo.GoInt;
/**
    // A Duration represents the elapsed time between two instants
    // as an int64 nanosecond count. The representation limits the
    // largest representable duration to approximately 290 years.
**/
@:named @:using(stdgo.time.Time.Duration_static_extension) typedef Duration = stdgo.GoInt64;
/**
    // ruleKind is the kinds of rules that can be seen in a tzset string.
**/
@:named typedef T_ruleKind = stdgo.GoInt;
@:named @:using(stdgo.time.Time.T_fileSizeError_static_extension) typedef T_fileSizeError = stdgo.GoString;
function resetLocalOnceForTest():Void {
        _localOnce = (new stdgo.sync.Sync.Once() : stdgo.sync.Sync.Once);
        _localLoc = (new stdgo.time.Time.Location() : stdgo.time.Time.Location);
    }
function forceUSPacificForTesting():Void {}
function zoneinfoForTesting():stdgo.Pointer<stdgo.GoString> {
        return _zoneinfo;
    }
function resetZoneinfoForTesting():Void {
        _zoneinfo = (null : stdgo.Pointer<stdgo.GoString>);
        _zoneinfoOnce = (new stdgo.sync.Sync.Once() : stdgo.sync.Sync.Once);
    }
function loadFromEmbeddedTZData(_zone:stdgo.GoString):{ var _0 : stdgo.GoString; var _1 : stdgo.Error; } {
        return _loadFromEmbeddedTZData(_zone?.__copy__());
    }
function tzsetRule(_s:stdgo.GoString):{ var _0 : Rule; var _1 : stdgo.GoString; var _2 : Bool; } {
        var __tmp__ = _tzsetRule(_s?.__copy__()), _r:stdgo.time.Time.T_rule = __tmp__._0, _rs:stdgo.GoString = __tmp__._1, _ok:Bool = __tmp__._2;
        var _rr:stdgo.time.Time.Rule = ({ kind : (_r._kind : RuleKind), day : _r._day, week : _r._week, mon : _r._mon, time : _r._time } : stdgo.time.Time.Rule);
        return { _0 : _rr?.__copy__(), _1 : _rs?.__copy__(), _2 : _ok };
    }
/**
    // startsWithLowerCase reports whether the string has a lower-case letter at the beginning.
    // Its purpose is to prevent matching strings like "Month" when looking for "Mon".
**/
function _startsWithLowerCase(_str:stdgo.GoString):Bool {
        if ((_str.length) == ((0 : stdgo.GoInt))) {
            return false;
        };
        var _c:stdgo.GoUInt8 = _str[(0 : stdgo.GoInt)];
        return ((97 : stdgo.GoUInt8) <= _c) && (_c <= (122 : stdgo.GoUInt8));
    }
/**
    // nextStdChunk finds the first occurrence of a std string in
    // layout and returns the text before, the std string, and the text after.
**/
function _nextStdChunk(_layout:stdgo.GoString):{ var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoString; } {
        var _prefix:stdgo.GoString = ("" : stdgo.GoString), _std:stdgo.GoInt = (0 : stdgo.GoInt), _suffix:stdgo.GoString = ("" : stdgo.GoString);
        {
            var _i:stdgo.GoInt = (0 : stdgo.GoInt);
            stdgo.Go.cfor(_i < (_layout.length), _i++, {
                {
                    var _c:stdgo.GoInt = (_layout[(_i : stdgo.GoInt)] : stdgo.GoInt);
                    {
                        final __value__ = _c;
                        if (__value__ == ((74 : stdgo.GoInt))) {
                            if ((_layout.length >= (_i + (3 : stdgo.GoInt))) && ((_layout.__slice__(_i, _i + (3 : stdgo.GoInt)) : stdgo.GoString) == ("Jan" : stdgo.GoString))) {
                                if ((_layout.length >= (_i + (7 : stdgo.GoInt))) && ((_layout.__slice__(_i, _i + (7 : stdgo.GoInt)) : stdgo.GoString) == ("January" : stdgo.GoString))) {
                                    return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (257 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (7 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                                };
                                if (!_startsWithLowerCase((_layout.__slice__(_i + (3 : stdgo.GoInt)) : stdgo.GoString)?.__copy__())) {
                                    return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (258 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (3 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                                };
                            };
                        } else if (__value__ == ((77 : stdgo.GoInt))) {
                            if ((_layout.length) >= (_i + (3 : stdgo.GoInt))) {
                                if ((_layout.__slice__(_i, _i + (3 : stdgo.GoInt)) : stdgo.GoString) == (("Mon" : stdgo.GoString))) {
                                    if ((_layout.length >= (_i + (6 : stdgo.GoInt))) && ((_layout.__slice__(_i, _i + (6 : stdgo.GoInt)) : stdgo.GoString) == ("Monday" : stdgo.GoString))) {
                                        return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (261 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (6 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                                    };
                                    if (!_startsWithLowerCase((_layout.__slice__(_i + (3 : stdgo.GoInt)) : stdgo.GoString)?.__copy__())) {
                                        return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (262 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (3 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                                    };
                                };
                                if ((_layout.__slice__(_i, _i + (3 : stdgo.GoInt)) : stdgo.GoString) == (("MST" : stdgo.GoString))) {
                                    return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (23 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (3 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                                };
                            };
                        } else if (__value__ == ((48 : stdgo.GoInt))) {
                            if (((_layout.length >= (_i + (2 : stdgo.GoInt))) && ((49 : stdgo.GoUInt8) <= _layout[(_i + (1 : stdgo.GoInt) : stdgo.GoInt)])) && (_layout[(_i + (1 : stdgo.GoInt) : stdgo.GoInt)] <= (54 : stdgo.GoUInt8))) {
                                return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : _std0x[(_layout[(_i + (1 : stdgo.GoInt) : stdgo.GoInt)] - (49 : stdgo.GoUInt8) : stdgo.GoInt)], _2 : (_layout.__slice__(_i + (2 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                            };
                            if (((_layout.length >= (_i + (3 : stdgo.GoInt))) && (_layout[(_i + (1 : stdgo.GoInt) : stdgo.GoInt)] == (48 : stdgo.GoUInt8))) && (_layout[(_i + (2 : stdgo.GoInt) : stdgo.GoInt)] == (50 : stdgo.GoUInt8))) {
                                return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (267 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (3 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                            };
                        } else if (__value__ == ((49 : stdgo.GoInt))) {
                            if ((_layout.length >= (_i + (2 : stdgo.GoInt))) && (_layout[(_i + (1 : stdgo.GoInt) : stdgo.GoInt)] == (53 : stdgo.GoUInt8))) {
                                return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (524 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (2 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                            };
                            return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (259 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                        } else if (__value__ == ((50 : stdgo.GoInt))) {
                            if ((_layout.length >= (_i + (4 : stdgo.GoInt))) && ((_layout.__slice__(_i, _i + (4 : stdgo.GoInt)) : stdgo.GoString) == ("2006" : stdgo.GoString))) {
                                return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (275 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (4 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                            };
                            return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (263 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                        } else if (__value__ == ((95 : stdgo.GoInt))) {
                            if ((_layout.length >= (_i + (2 : stdgo.GoInt))) && (_layout[(_i + (1 : stdgo.GoInt) : stdgo.GoInt)] == (50 : stdgo.GoUInt8))) {
                                if ((_layout.length >= (_i + (5 : stdgo.GoInt))) && ((_layout.__slice__(_i + (1 : stdgo.GoInt), _i + (5 : stdgo.GoInt)) : stdgo.GoString) == ("2006" : stdgo.GoString))) {
                                    return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i + (1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__(), _1 : (275 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (5 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                                };
                                return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (264 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (2 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                            };
                            if (((_layout.length >= (_i + (3 : stdgo.GoInt))) && (_layout[(_i + (1 : stdgo.GoInt) : stdgo.GoInt)] == (95 : stdgo.GoUInt8))) && (_layout[(_i + (2 : stdgo.GoInt) : stdgo.GoInt)] == (50 : stdgo.GoUInt8))) {
                                return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (266 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (3 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                            };
                        } else if (__value__ == ((51 : stdgo.GoInt))) {
                            return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (525 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                        } else if (__value__ == ((52 : stdgo.GoInt))) {
                            return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (527 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                        } else if (__value__ == ((53 : stdgo.GoInt))) {
                            return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (529 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                        } else if (__value__ == ((80 : stdgo.GoInt))) {
                            if ((_layout.length >= (_i + (2 : stdgo.GoInt))) && (_layout[(_i + (1 : stdgo.GoInt) : stdgo.GoInt)] == (77 : stdgo.GoUInt8))) {
                                return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (533 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (2 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                            };
                        } else if (__value__ == ((112 : stdgo.GoInt))) {
                            if ((_layout.length >= (_i + (2 : stdgo.GoInt))) && (_layout[(_i + (1 : stdgo.GoInt) : stdgo.GoInt)] == (109 : stdgo.GoUInt8))) {
                                return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (534 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (2 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                            };
                        } else if (__value__ == ((45 : stdgo.GoInt))) {
                            if ((_layout.length >= (_i + (7 : stdgo.GoInt))) && ((_layout.__slice__(_i, _i + (7 : stdgo.GoInt)) : stdgo.GoString) == ("-070000" : stdgo.GoString))) {
                                return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (30 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (7 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                            };
                            if ((_layout.length >= (_i + (9 : stdgo.GoInt))) && ((_layout.__slice__(_i, _i + (9 : stdgo.GoInt)) : stdgo.GoString) == ("-07:00:00" : stdgo.GoString))) {
                                return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (33 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (9 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                            };
                            if ((_layout.length >= (_i + (5 : stdgo.GoInt))) && ((_layout.__slice__(_i, _i + (5 : stdgo.GoInt)) : stdgo.GoString) == ("-0700" : stdgo.GoString))) {
                                return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (29 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (5 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                            };
                            if ((_layout.length >= (_i + (6 : stdgo.GoInt))) && ((_layout.__slice__(_i, _i + (6 : stdgo.GoInt)) : stdgo.GoString) == ("-07:00" : stdgo.GoString))) {
                                return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (32 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (6 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                            };
                            if ((_layout.length >= (_i + (3 : stdgo.GoInt))) && ((_layout.__slice__(_i, _i + (3 : stdgo.GoInt)) : stdgo.GoString) == ("-07" : stdgo.GoString))) {
                                return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (31 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (3 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                            };
                        } else if (__value__ == ((90 : stdgo.GoInt))) {
                            if ((_layout.length >= (_i + (7 : stdgo.GoInt))) && ((_layout.__slice__(_i, _i + (7 : stdgo.GoInt)) : stdgo.GoString) == ("Z070000" : stdgo.GoString))) {
                                return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (25 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (7 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                            };
                            if ((_layout.length >= (_i + (9 : stdgo.GoInt))) && ((_layout.__slice__(_i, _i + (9 : stdgo.GoInt)) : stdgo.GoString) == ("Z07:00:00" : stdgo.GoString))) {
                                return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (28 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (9 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                            };
                            if ((_layout.length >= (_i + (5 : stdgo.GoInt))) && ((_layout.__slice__(_i, _i + (5 : stdgo.GoInt)) : stdgo.GoString) == ("Z0700" : stdgo.GoString))) {
                                return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (24 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (5 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                            };
                            if ((_layout.length >= (_i + (6 : stdgo.GoInt))) && ((_layout.__slice__(_i, _i + (6 : stdgo.GoInt)) : stdgo.GoString) == ("Z07:00" : stdgo.GoString))) {
                                return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (27 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (6 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                            };
                            if ((_layout.length >= (_i + (3 : stdgo.GoInt))) && ((_layout.__slice__(_i, _i + (3 : stdgo.GoInt)) : stdgo.GoString) == ("Z07" : stdgo.GoString))) {
                                return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (26 : stdgo.GoInt), _2 : (_layout.__slice__(_i + (3 : stdgo.GoInt)) : stdgo.GoString)?.__copy__() };
                            };
                        } else if (__value__ == ((46 : stdgo.GoInt)) || __value__ == ((44 : stdgo.GoInt))) {
                            if (((_i + (1 : stdgo.GoInt)) < _layout.length) && ((_layout[(_i + (1 : stdgo.GoInt) : stdgo.GoInt)] == (48 : stdgo.GoUInt8)) || (_layout[(_i + (1 : stdgo.GoInt) : stdgo.GoInt)] == (57 : stdgo.GoUInt8)))) {
                                var _ch:stdgo.GoUInt8 = _layout[(_i + (1 : stdgo.GoInt) : stdgo.GoInt)];
                                var _j:stdgo.GoInt = _i + (1 : stdgo.GoInt);
                                while ((_j < _layout.length) && (_layout[(_j : stdgo.GoInt)] == _ch)) {
                                    _j++;
                                };
                                if (!_isDigit(("" : stdgo.GoString), _layout?.__copy__(), _j)) {
                                    var _code:stdgo.GoInt = (34 : stdgo.GoInt);
                                    if (_layout[(_i + (1 : stdgo.GoInt) : stdgo.GoInt)] == ((57 : stdgo.GoUInt8))) {
                                        _code = (35 : stdgo.GoInt);
                                    };
                                    var _std:stdgo.GoInt = _stdFracSecond(_code, _j - (_i + (1 : stdgo.GoInt)), _c);
                                    return { _0 : (_layout.__slice__((0 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : _std, _2 : (_layout.__slice__(_j) : stdgo.GoString)?.__copy__() };
                                };
                            };
                        };
                    };
                };
            });
        };
        return { _0 : _layout?.__copy__(), _1 : (0 : stdgo.GoInt), _2 : stdgo.Go.str()?.__copy__() };
    }
/**
    // match reports whether s1 and s2 match ignoring case.
    // It is assumed s1 and s2 are the same length.
**/
function _match(_s1:stdgo.GoString, _s2:stdgo.GoString):Bool {
        {
            var _i:stdgo.GoInt = (0 : stdgo.GoInt);
            stdgo.Go.cfor(_i < (_s1.length), _i++, {
                var _c1:stdgo.GoUInt8 = _s1[(_i : stdgo.GoInt)];
                var _c2:stdgo.GoUInt8 = _s2[(_i : stdgo.GoInt)];
                if (_c1 != (_c2)) {
                    _c1 = _c1 | ((32 : stdgo.GoUInt8));
                    _c2 = _c2 | ((32 : stdgo.GoUInt8));
                    if (((_c1 != _c2) || (_c1 < (97 : stdgo.GoUInt8))) || (_c1 > (122 : stdgo.GoUInt8))) {
                        return false;
                    };
                };
            });
        };
        return true;
    }
function _lookup(_tab:stdgo.Slice<stdgo.GoString>, _val:stdgo.GoString):{ var _0 : stdgo.GoInt; var _1 : stdgo.GoString; var _2 : stdgo.Error; } {
        for (_i => _v in _tab) {
            if ((_val.length >= _v.length) && _match((_val.__slice__((0 : stdgo.GoInt), (_v.length)) : stdgo.GoString)?.__copy__(), _v?.__copy__())) {
                return { _0 : _i, _1 : (_val.__slice__((_v.length)) : stdgo.GoString)?.__copy__(), _2 : (null : stdgo.Error) };
            };
        };
        return { _0 : (-1 : stdgo.GoInt), _1 : _val?.__copy__(), _2 : _errBad };
    }
/**
    // appendInt appends the decimal form of x to b and returns the result.
    // If the decimal form (excluding sign) is shorter than width, the result is padded with leading 0's.
    // Duplicates functionality in strconv, but avoids dependency.
**/
function _appendInt(_b:stdgo.Slice<stdgo.GoByte>, _x:stdgo.GoInt, _width:stdgo.GoInt):stdgo.Slice<stdgo.GoByte> {
        var _u:stdgo.GoUInt = (_x : stdgo.GoUInt);
        if (_x < (0 : stdgo.GoInt)) {
            _b = (_b.__append__((45 : stdgo.GoUInt8)));
            _u = (-_x : stdgo.GoUInt);
        };
        var _utod:stdgo.GoUInt -> stdgo.GoUInt8 = function(_u:stdgo.GoUInt):stdgo.GoByte {
            return (48 : stdgo.GoUInt8) + (_u : stdgo.GoByte);
        };
        if ((_width == (2 : stdgo.GoInt)) && (_u < (100u32 : stdgo.GoUInt))) {
            return (_b.__append__(_utod(_u / (10u32 : stdgo.GoUInt)), _utod(_u % (10u32 : stdgo.GoUInt))));
        } else if ((_width == (4 : stdgo.GoInt)) && (_u < (10000u32 : stdgo.GoUInt))) {
            return (_b.__append__(_utod(_u / (1000u32 : stdgo.GoUInt)), _utod((_u / (100u32 : stdgo.GoUInt)) % (10u32 : stdgo.GoUInt)), _utod((_u / (10u32 : stdgo.GoUInt)) % (10u32 : stdgo.GoUInt)), _utod(_u % (10u32 : stdgo.GoUInt))));
        };
        var _n:stdgo.GoInt = (0 : stdgo.GoInt);
        if (_u == ((0u32 : stdgo.GoUInt))) {
            _n = (1 : stdgo.GoInt);
        };
        {
            var _u2:stdgo.GoUInt = _u;
            stdgo.Go.cfor(_u2 > (0u32 : stdgo.GoUInt), _u2 = _u2 / ((10u32 : stdgo.GoUInt)), {
                _n++;
            });
        };
        {
            var _pad:stdgo.GoInt = _width - _n;
            stdgo.Go.cfor(_pad > (0 : stdgo.GoInt), _pad--, {
                _b = (_b.__append__((48 : stdgo.GoUInt8)));
            });
        };
        if ((_b.length + _n) <= _b.capacity) {
            _b = (_b.__slice__(0, (_b.length) + _n) : stdgo.Slice<stdgo.GoUInt8>);
        } else {
            _b = (_b.__append__(...new stdgo.Slice<stdgo.GoUInt8>((_n : stdgo.GoInt).toBasic(), 0).__setNumber32__().__toArray__()));
        };
        var _i:stdgo.GoInt = (_b.length) - (1 : stdgo.GoInt);
        while ((_u >= (10u32 : stdgo.GoUInt)) && (_i > (0 : stdgo.GoInt))) {
            var _q:stdgo.GoUInt = _u / (10u32 : stdgo.GoUInt);
            _b[(_i : stdgo.GoInt)] = _utod(_u - (_q * (10u32 : stdgo.GoUInt)));
            _u = _q;
            _i--;
        };
        _b[(_i : stdgo.GoInt)] = _utod(_u);
        return _b;
    }
/**
    // Duplicates functionality in strconv, but avoids dependency.
**/
macro function _atoi<T_bytes>(__generic__0:haxe.macro.Expr.ExprOf<T_bytes>, _s:haxe.macro.Expr.ExprOf<T_bytes>):haxe.macro.Expr.ExprOf<{ var _0 : stdgo.GoInt; var _1 : stdgo.Error; }>;
/**
    // The "std" value passed to appendNano contains two packed fields: the number of
    // digits after the decimal and the separator character (period or comma).
    // These functions pack and unpack that variable.
**/
function _stdFracSecond(_code:stdgo.GoInt, _n:stdgo.GoInt, _c:stdgo.GoInt):stdgo.GoInt {
        if (_c == ((46 : stdgo.GoInt))) {
            return _code | ((_n & (4095 : stdgo.GoInt)) << (16i64 : stdgo.GoUInt64));
        };
        return (_code | ((_n & (4095 : stdgo.GoInt)) << (16i64 : stdgo.GoUInt64))) | (268435456 : stdgo.GoInt);
    }
function _digitsLen(_std:stdgo.GoInt):stdgo.GoInt {
        return (_std >> (16i64 : stdgo.GoUInt64)) & (4095 : stdgo.GoInt);
    }
function _separator(_std:stdgo.GoInt):stdgo.GoByte {
        if ((_std >> (28i64 : stdgo.GoUInt64)) == ((0 : stdgo.GoInt))) {
            return (46 : stdgo.GoUInt8);
        };
        return (44 : stdgo.GoUInt8);
    }
/**
    // appendNano appends a fractional second, as nanoseconds, to b
    // and returns the result. The nanosec must be within [0, 999999999].
**/
function _appendNano(_b:stdgo.Slice<stdgo.GoByte>, _nanosec:stdgo.GoInt, _std:stdgo.GoInt):stdgo.Slice<stdgo.GoByte> {
        var _trim:Bool = _std & (65535 : stdgo.GoInt) == ((35 : stdgo.GoInt));
        var _n:stdgo.GoInt = _digitsLen(_std);
        if (_trim && ((_n == (0 : stdgo.GoInt)) || (_nanosec == (0 : stdgo.GoInt)))) {
            return _b;
        };
        var _dot:stdgo.GoUInt8 = _separator(_std);
        _b = (_b.__append__(_dot));
        _b = _appendInt(_b, _nanosec, (9 : stdgo.GoInt));
        if (_n < (9 : stdgo.GoInt)) {
            _b = (_b.__slice__(0, (_b.length - (9 : stdgo.GoInt)) + _n) : stdgo.Slice<stdgo.GoUInt8>);
        };
        if (_trim) {
            while ((_b.length > (0 : stdgo.GoInt)) && (_b[((_b.length) - (1 : stdgo.GoInt) : stdgo.GoInt)] == (48 : stdgo.GoUInt8))) {
                _b = (_b.__slice__(0, (_b.length) - (1 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoUInt8>);
            };
            if ((_b.length > (0 : stdgo.GoInt)) && (_b[((_b.length) - (1 : stdgo.GoInt) : stdgo.GoInt)] == _dot)) {
                _b = (_b.__slice__(0, (_b.length) - (1 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoUInt8>);
            };
        };
        return _b;
    }
/**
    // newParseError creates a new ParseError.
    // The provided value and valueElem are cloned to avoid escaping their values.
**/
function _newParseError(_layout:stdgo.GoString, _value:stdgo.GoString, _layoutElem:stdgo.GoString, _valueElem:stdgo.GoString, _message:stdgo.GoString):stdgo.Ref<ParseError> {
        var _valueCopy:stdgo.GoString = _cloneString(_value?.__copy__())?.__copy__();
        var _valueElemCopy:stdgo.GoString = _cloneString(_valueElem?.__copy__())?.__copy__();
        return (stdgo.Go.setRef((new stdgo.time.Time.ParseError(_layout?.__copy__(), _valueCopy?.__copy__(), _layoutElem?.__copy__(), _valueElemCopy?.__copy__(), _message?.__copy__()) : stdgo.time.Time.ParseError)) : stdgo.Ref<stdgo.time.Time.ParseError>);
    }
/**
    // cloneString returns a string copy of s.
    // Do not use strings.Clone to avoid dependency on strings package.
**/
function _cloneString(_s:stdgo.GoString):stdgo.GoString {
        return ((_s : stdgo.Slice<stdgo.GoByte>) : stdgo.GoString)?.__copy__();
    }
function _quote(_s:stdgo.GoString):stdgo.GoString {
        var _buf = new stdgo.Slice<stdgo.GoUInt8>((1 : stdgo.GoInt).toBasic(), (_s.length) + (2 : stdgo.GoInt)).__setNumber32__();
        _buf[(0 : stdgo.GoInt)] = (34 : stdgo.GoUInt8);
        for (_i => _c in _s) {
            if ((_c >= (128 : stdgo.GoInt32)) || (_c < (32 : stdgo.GoInt32))) {
                var _width:stdgo.GoInt = (0 : stdgo.GoInt);
                if (_c == ((65533 : stdgo.GoInt32))) {
                    _width = (1 : stdgo.GoInt);
                    if (((_i + (2 : stdgo.GoInt)) < _s.length) && ((_s.__slice__(_i, _i + (3 : stdgo.GoInt)) : stdgo.GoString) == ((65533 : stdgo.GoInt32) : stdgo.GoString))) {
                        _width = (3 : stdgo.GoInt);
                    };
                } else {
                    _width = ((_c : stdgo.GoString).length);
                };
                {
                    var _j:stdgo.GoInt = (0 : stdgo.GoInt);
                    stdgo.Go.cfor(_j < _width, _j++, {
                        _buf = (_buf.__append__(...("\\x" : stdgo.GoString).__toArray__()));
                        _buf = (_buf.__append__(("0123456789abcdef" : stdgo.GoString)[(_s[(_i + _j : stdgo.GoInt)] >> (4i64 : stdgo.GoUInt64) : stdgo.GoInt)]));
                        _buf = (_buf.__append__(("0123456789abcdef" : stdgo.GoString)[(_s[(_i + _j : stdgo.GoInt)] & (15 : stdgo.GoUInt8) : stdgo.GoInt)]));
                    });
                };
            } else {
                if ((_c == (34 : stdgo.GoInt32)) || (_c == (92 : stdgo.GoInt32))) {
                    _buf = (_buf.__append__((92 : stdgo.GoUInt8)));
                };
                _buf = (_buf.__append__(...(_c : stdgo.GoString).__toArray__()));
            };
        };
        _buf = (_buf.__append__((34 : stdgo.GoUInt8)));
        return (_buf : stdgo.GoString)?.__copy__();
    }
/**
    // isDigit reports whether s[i] is in range and is a decimal digit.
**/
macro function _isDigit<T_bytes>(__generic__0:haxe.macro.Expr.ExprOf<T_bytes>, _s:haxe.macro.Expr.ExprOf<T_bytes>, _i:haxe.macro.Expr.ExprOf<stdgo.GoInt>):haxe.macro.Expr.ExprOf<Bool>;
/**
    // getnum parses s[0:1] or s[0:2] (fixed forces s[0:2])
    // as a decimal integer and returns the integer and the
    // remainder of the string.
**/
function _getnum(_s:stdgo.GoString, _fixed:Bool):{ var _0 : stdgo.GoInt; var _1 : stdgo.GoString; var _2 : stdgo.Error; } {
        if (!_isDigit(("" : stdgo.GoString), _s?.__copy__(), (0 : stdgo.GoInt))) {
            return { _0 : (0 : stdgo.GoInt), _1 : _s?.__copy__(), _2 : _errBad };
        };
        if (!_isDigit(("" : stdgo.GoString), _s?.__copy__(), (1 : stdgo.GoInt))) {
            if (_fixed) {
                return { _0 : (0 : stdgo.GoInt), _1 : _s?.__copy__(), _2 : _errBad };
            };
            return { _0 : (_s[(0 : stdgo.GoInt)] - (48 : stdgo.GoUInt8) : stdgo.GoInt), _1 : (_s.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__(), _2 : (null : stdgo.Error) };
        };
        return { _0 : ((_s[(0 : stdgo.GoInt)] - (48 : stdgo.GoUInt8) : stdgo.GoInt) * (10 : stdgo.GoInt)) + (_s[(1 : stdgo.GoInt)] - (48 : stdgo.GoUInt8) : stdgo.GoInt), _1 : (_s.__slice__((2 : stdgo.GoInt)) : stdgo.GoString)?.__copy__(), _2 : (null : stdgo.Error) };
    }
/**
    // getnum3 parses s[0:1], s[0:2], or s[0:3] (fixed forces s[0:3])
    // as a decimal integer and returns the integer and the remainder
    // of the string.
**/
function _getnum3(_s:stdgo.GoString, _fixed:Bool):{ var _0 : stdgo.GoInt; var _1 : stdgo.GoString; var _2 : stdgo.Error; } {
        var __0:stdgo.GoInt = (0 : stdgo.GoInt), __1:stdgo.GoInt = (0 : stdgo.GoInt), _i:stdgo.GoInt = __1, _n:stdgo.GoInt = __0;
        {
            _i = (0 : stdgo.GoInt);
            stdgo.Go.cfor((_i < (3 : stdgo.GoInt)) && _isDigit(("" : stdgo.GoString), _s?.__copy__(), _i), _i++, {
                _n = (_n * (10 : stdgo.GoInt)) + (_s[(_i : stdgo.GoInt)] - (48 : stdgo.GoUInt8) : stdgo.GoInt);
            });
        };
        if ((_i == (0 : stdgo.GoInt)) || (_fixed && (_i != (3 : stdgo.GoInt)))) {
            return { _0 : (0 : stdgo.GoInt), _1 : _s?.__copy__(), _2 : _errBad };
        };
        return { _0 : _n, _1 : (_s.__slice__(_i) : stdgo.GoString)?.__copy__(), _2 : (null : stdgo.Error) };
    }
function _cutspace(_s:stdgo.GoString):stdgo.GoString {
        while ((_s.length > (0 : stdgo.GoInt)) && (_s[(0 : stdgo.GoInt)] == (32 : stdgo.GoUInt8))) {
            _s = (_s.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
        };
        return _s?.__copy__();
    }
/**
    // skip removes the given prefix from value,
    // treating runs of space characters as equivalent.
**/
function _skip(_value:stdgo.GoString, _prefix:stdgo.GoString):{ var _0 : stdgo.GoString; var _1 : stdgo.Error; } {
        while ((_prefix.length) > (0 : stdgo.GoInt)) {
            if (_prefix[(0 : stdgo.GoInt)] == ((32 : stdgo.GoUInt8))) {
                if ((_value.length > (0 : stdgo.GoInt)) && (_value[(0 : stdgo.GoInt)] != (32 : stdgo.GoUInt8))) {
                    return { _0 : _value?.__copy__(), _1 : _errBad };
                };
                _prefix = _cutspace(_prefix?.__copy__())?.__copy__();
                _value = _cutspace(_value?.__copy__())?.__copy__();
                continue;
            };
            if ((_value.length == (0 : stdgo.GoInt)) || (_value[(0 : stdgo.GoInt)] != _prefix[(0 : stdgo.GoInt)])) {
                return { _0 : _value?.__copy__(), _1 : _errBad };
            };
            _prefix = (_prefix.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
            _value = (_value.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
        };
        return { _0 : _value?.__copy__(), _1 : (null : stdgo.Error) };
    }
/**
    // Parse parses a formatted string and returns the time value it represents.
    // See the documentation for the constant called Layout to see how to
    // represent the format. The second argument must be parseable using
    // the format string (layout) provided as the first argument.
    //
    // The example for Time.Format demonstrates the working of the layout string
    // in detail and is a good reference.
    //
    // When parsing (only), the input may contain a fractional second
    // field immediately after the seconds field, even if the layout does not
    // signify its presence. In that case either a comma or a decimal point
    // followed by a maximal series of digits is parsed as a fractional second.
    // Fractional seconds are truncated to nanosecond precision.
    //
    // Elements omitted from the layout are assumed to be zero or, when
    // zero is impossible, one, so parsing "3:04pm" returns the time
    // corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is
    // 0, this time is before the zero Time).
    // Years must be in the range 0000..9999. The day of the week is checked
    // for syntax but it is otherwise ignored.
    //
    // For layouts specifying the two-digit year 06, a value NN >= 69 will be treated
    // as 19NN and a value NN < 69 will be treated as 20NN.
    //
    // The remainder of this comment describes the handling of time zones.
    //
    // In the absence of a time zone indicator, Parse returns a time in UTC.
    //
    // When parsing a time with a zone offset like -0700, if the offset corresponds
    // to a time zone used by the current location (Local), then Parse uses that
    // location and zone in the returned time. Otherwise it records the time as
    // being in a fabricated location with time fixed at the given zone offset.
    //
    // When parsing a time with a zone abbreviation like MST, if the zone abbreviation
    // has a defined offset in the current location, then that offset is used.
    // The zone abbreviation "UTC" is recognized as UTC regardless of location.
    // If the zone abbreviation is unknown, Parse records the time as being
    // in a fabricated location with the given zone abbreviation and a zero offset.
    // This choice means that such a time can be parsed and reformatted with the
    // same layout losslessly, but the exact instant used in the representation will
    // differ by the actual zone offset. To avoid such problems, prefer time layouts
    // that use a numeric zone offset, or use ParseInLocation.
**/
function parse(_layout:stdgo.GoString, _value:stdgo.GoString):{ var _0 : Time; var _1 : stdgo.Error; } {
        if ((_layout == ("2006-01-02T15:04:05Z07:00" : stdgo.GoString)) || (_layout == ("2006-01-02T15:04:05.999999999Z07:00" : stdgo.GoString))) {
            {
                var __tmp__ = _parseRFC3339(("" : stdgo.GoString), _value?.__copy__(), local), _t:stdgo.time.Time.Time = __tmp__._0, _ok:Bool = __tmp__._1;
                if (_ok) {
                    return { _0 : _t?.__copy__(), _1 : (null : stdgo.Error) };
                };
            };
        };
        return _parse(_layout?.__copy__(), _value?.__copy__(), utc, local);
    }
/**
    // ParseInLocation is like Parse but differs in two important ways.
    // First, in the absence of time zone information, Parse interprets a time as UTC;
    // ParseInLocation interprets the time as in the given location.
    // Second, when given a zone offset or abbreviation, Parse tries to match it
    // against the Local location; ParseInLocation uses the given location.
**/
function parseInLocation(_layout:stdgo.GoString, _value:stdgo.GoString, _loc:stdgo.Ref<Location>):{ var _0 : Time; var _1 : stdgo.Error; } {
        if ((_layout == ("2006-01-02T15:04:05Z07:00" : stdgo.GoString)) || (_layout == ("2006-01-02T15:04:05.999999999Z07:00" : stdgo.GoString))) {
            {
                var __tmp__ = _parseRFC3339(("" : stdgo.GoString), _value?.__copy__(), _loc), _t:stdgo.time.Time.Time = __tmp__._0, _ok:Bool = __tmp__._1;
                if (_ok) {
                    return { _0 : _t?.__copy__(), _1 : (null : stdgo.Error) };
                };
            };
        };
        return _parse(_layout?.__copy__(), _value?.__copy__(), _loc, _loc);
    }
function _parse(_layout:stdgo.GoString, _value:stdgo.GoString, _defaultLocation:stdgo.Ref<Location>, _local:stdgo.Ref<Location>):{ var _0 : Time; var _1 : stdgo.Error; } {
        var __0:stdgo.GoString = _layout?.__copy__(), __1:stdgo.GoString = _value?.__copy__(), _avalue:stdgo.GoString = __1, _alayout:stdgo.GoString = __0;
        var _rangeErrString:stdgo.GoString = stdgo.Go.str()?.__copy__();
        var _amSet:Bool = false;
        var _pmSet:Bool = false;
        var __0:stdgo.GoInt = (0 : stdgo.GoInt), __1:stdgo.GoInt = (-1 : stdgo.GoInt), __2:stdgo.GoInt = (-1 : stdgo.GoInt), __3:stdgo.GoInt = (-1 : stdgo.GoInt), __4:stdgo.GoInt = (0 : stdgo.GoInt), __5:stdgo.GoInt = (0 : stdgo.GoInt), __6:stdgo.GoInt = (0 : stdgo.GoInt), __7:stdgo.GoInt = (0 : stdgo.GoInt), __8:stdgo.Ref<Location> = (null : stdgo.Ref<stdgo.time.Time.Location>), __9:stdgo.GoInt = (-1 : stdgo.GoInt), __10:stdgo.GoString = ("" : stdgo.GoString), _zoneName:stdgo.GoString = __10, _zoneOffset:stdgo.GoInt = __9, _z:stdgo.Ref<Location> = __8, _nsec:stdgo.GoInt = __7, _sec:stdgo.GoInt = __6, _min:stdgo.GoInt = __5, _hour:stdgo.GoInt = __4, _yday:stdgo.GoInt = __3, _day:stdgo.GoInt = __2, _month:stdgo.GoInt = __1, _year:stdgo.GoInt = __0;
        while (true) {
            var _err:stdgo.Error = (null : stdgo.Error);
            var __tmp__ = _nextStdChunk(_layout?.__copy__()), _prefix:stdgo.GoString = __tmp__._0, _std:stdgo.GoInt = __tmp__._1, _suffix:stdgo.GoString = __tmp__._2;
            var _stdstr:stdgo.GoString = (_layout.__slice__((_prefix.length), (_layout.length) - (_suffix.length)) : stdgo.GoString)?.__copy__();
            {
                var __tmp__ = _skip(_value?.__copy__(), _prefix?.__copy__());
                _value = __tmp__._0?.__copy__();
                _err = __tmp__._1;
            };
            if (_err != null) {
                return { _0 : (new stdgo.time.Time.Time() : stdgo.time.Time.Time), _1 : stdgo.Go.asInterface(_newParseError(_alayout?.__copy__(), _avalue?.__copy__(), _prefix?.__copy__(), _value?.__copy__(), stdgo.Go.str()?.__copy__())) };
            };
            if (_std == ((0 : stdgo.GoInt))) {
                if ((_value.length) != ((0 : stdgo.GoInt))) {
                    return { _0 : (new stdgo.time.Time.Time() : stdgo.time.Time.Time), _1 : stdgo.Go.asInterface(_newParseError(_alayout?.__copy__(), _avalue?.__copy__(), stdgo.Go.str()?.__copy__(), _value?.__copy__(), (": extra text: " : stdgo.GoString) + _quote(_value?.__copy__())?.__copy__()?.__copy__())) };
                };
                break;
            };
            _layout = _suffix?.__copy__();
            var _p:stdgo.GoString = ("" : stdgo.GoString);
            var _hold:stdgo.GoString = _value?.__copy__();
            {
                var __switchIndex__ = -1;
                var __run__ = true;
                while (__run__) {
                    __run__ = false;
                    {
                        final __value__ = _std & (65535 : stdgo.GoInt);
                        if (__value__ == ((276 : stdgo.GoInt))) {
                            if ((_value.length) < (2 : stdgo.GoInt)) {
                                _err = _errBad;
                                break;
                            };
                            {
                                final __tmp__0 = (_value.__slice__((0 : stdgo.GoInt), (2 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                final __tmp__1 = (_value.__slice__((2 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                _p = __tmp__0;
                                _value = __tmp__1;
                            };
                            {
                                var __tmp__ = _atoi(("" : stdgo.GoString), _p?.__copy__());
                                _year = __tmp__._0;
                                _err = __tmp__._1;
                            };
                            if (_err != null) {
                                break;
                            };
                            if (_year >= (69 : stdgo.GoInt)) {
                                _year = _year + ((1900 : stdgo.GoInt));
                            } else {
                                _year = _year + ((2000 : stdgo.GoInt));
                            };
                            break;
                        } else if (__value__ == ((275 : stdgo.GoInt))) {
                            if ((_value.length < (4 : stdgo.GoInt)) || !_isDigit(("" : stdgo.GoString), _value?.__copy__(), (0 : stdgo.GoInt))) {
                                _err = _errBad;
                                break;
                            };
                            {
                                final __tmp__0 = (_value.__slice__((0 : stdgo.GoInt), (4 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                final __tmp__1 = (_value.__slice__((4 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                _p = __tmp__0;
                                _value = __tmp__1;
                            };
                            {
                                var __tmp__ = _atoi(("" : stdgo.GoString), _p?.__copy__());
                                _year = __tmp__._0;
                                _err = __tmp__._1;
                            };
                            break;
                        } else if (__value__ == ((258 : stdgo.GoInt))) {
                            {
                                var __tmp__ = _lookup(_shortMonthNames, _value?.__copy__());
                                _month = __tmp__._0;
                                _value = __tmp__._1?.__copy__();
                                _err = __tmp__._2;
                            };
                            _month++;
                            break;
                        } else if (__value__ == ((257 : stdgo.GoInt))) {
                            {
                                var __tmp__ = _lookup(_longMonthNames, _value?.__copy__());
                                _month = __tmp__._0;
                                _value = __tmp__._1?.__copy__();
                                _err = __tmp__._2;
                            };
                            _month++;
                            break;
                        } else if (__value__ == ((259 : stdgo.GoInt)) || __value__ == ((260 : stdgo.GoInt))) {
                            {
                                var __tmp__ = _getnum(_value?.__copy__(), _std == ((260 : stdgo.GoInt)));
                                _month = __tmp__._0;
                                _value = __tmp__._1?.__copy__();
                                _err = __tmp__._2;
                            };
                            if ((_err == null) && ((_month <= (0 : stdgo.GoInt)) || ((12 : stdgo.GoInt) < _month))) {
                                _rangeErrString = ("month" : stdgo.GoString);
                            };
                            break;
                        } else if (__value__ == ((262 : stdgo.GoInt))) {
                            {
                                var __tmp__ = _lookup(_shortDayNames, _value?.__copy__());
                                _value = __tmp__._1?.__copy__();
                                _err = __tmp__._2;
                            };
                            break;
                        } else if (__value__ == ((261 : stdgo.GoInt))) {
                            {
                                var __tmp__ = _lookup(_longDayNames, _value?.__copy__());
                                _value = __tmp__._1?.__copy__();
                                _err = __tmp__._2;
                            };
                            break;
                        } else if (__value__ == ((263 : stdgo.GoInt)) || __value__ == ((264 : stdgo.GoInt)) || __value__ == ((265 : stdgo.GoInt))) {
                            if (((_std == (264 : stdgo.GoInt)) && (_value.length > (0 : stdgo.GoInt))) && (_value[(0 : stdgo.GoInt)] == (32 : stdgo.GoUInt8))) {
                                _value = (_value.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                            };
                            {
                                var __tmp__ = _getnum(_value?.__copy__(), _std == ((265 : stdgo.GoInt)));
                                _day = __tmp__._0;
                                _value = __tmp__._1?.__copy__();
                                _err = __tmp__._2;
                            };
                            break;
                        } else if (__value__ == ((266 : stdgo.GoInt)) || __value__ == ((267 : stdgo.GoInt))) {
                            {
                                var _i:stdgo.GoInt = (0 : stdgo.GoInt);
                                stdgo.Go.cfor(_i < (2 : stdgo.GoInt), _i++, {
                                    if (((_std == (266 : stdgo.GoInt)) && (_value.length > (0 : stdgo.GoInt))) && (_value[(0 : stdgo.GoInt)] == (32 : stdgo.GoUInt8))) {
                                        _value = (_value.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                    };
                                });
                            };
                            {
                                var __tmp__ = _getnum3(_value?.__copy__(), _std == ((267 : stdgo.GoInt)));
                                _yday = __tmp__._0;
                                _value = __tmp__._1?.__copy__();
                                _err = __tmp__._2;
                            };
                            break;
                        } else if (__value__ == ((524 : stdgo.GoInt))) {
                            {
                                var __tmp__ = _getnum(_value?.__copy__(), false);
                                _hour = __tmp__._0;
                                _value = __tmp__._1?.__copy__();
                                _err = __tmp__._2;
                            };
                            if ((_hour < (0 : stdgo.GoInt)) || ((24 : stdgo.GoInt) <= _hour)) {
                                _rangeErrString = ("hour" : stdgo.GoString);
                            };
                            break;
                        } else if (__value__ == ((525 : stdgo.GoInt)) || __value__ == ((526 : stdgo.GoInt))) {
                            {
                                var __tmp__ = _getnum(_value?.__copy__(), _std == ((526 : stdgo.GoInt)));
                                _hour = __tmp__._0;
                                _value = __tmp__._1?.__copy__();
                                _err = __tmp__._2;
                            };
                            if ((_hour < (0 : stdgo.GoInt)) || ((12 : stdgo.GoInt) < _hour)) {
                                _rangeErrString = ("hour" : stdgo.GoString);
                            };
                            break;
                        } else if (__value__ == ((527 : stdgo.GoInt)) || __value__ == ((528 : stdgo.GoInt))) {
                            {
                                var __tmp__ = _getnum(_value?.__copy__(), _std == ((528 : stdgo.GoInt)));
                                _min = __tmp__._0;
                                _value = __tmp__._1?.__copy__();
                                _err = __tmp__._2;
                            };
                            if ((_min < (0 : stdgo.GoInt)) || ((60 : stdgo.GoInt) <= _min)) {
                                _rangeErrString = ("minute" : stdgo.GoString);
                            };
                            break;
                        } else if (__value__ == ((529 : stdgo.GoInt)) || __value__ == ((530 : stdgo.GoInt))) {
                            {
                                var __tmp__ = _getnum(_value?.__copy__(), _std == ((530 : stdgo.GoInt)));
                                _sec = __tmp__._0;
                                _value = __tmp__._1?.__copy__();
                                _err = __tmp__._2;
                            };
                            if (_err != null) {
                                break;
                            };
                            if ((_sec < (0 : stdgo.GoInt)) || ((60 : stdgo.GoInt) <= _sec)) {
                                _rangeErrString = ("second" : stdgo.GoString);
                                break;
                            };
                            if (((_value.length >= (2 : stdgo.GoInt)) && _commaOrPeriod(_value[(0 : stdgo.GoInt)])) && _isDigit(("" : stdgo.GoString), _value?.__copy__(), (1 : stdgo.GoInt))) {
                                {
                                    var __tmp__ = _nextStdChunk(_layout?.__copy__());
                                    _std = __tmp__._1;
                                };
                                _std = _std & ((65535 : stdgo.GoInt));
                                if ((_std == (34 : stdgo.GoInt)) || (_std == (35 : stdgo.GoInt))) {
                                    break;
                                };
                                var _n:stdgo.GoInt = (2 : stdgo.GoInt);
                                stdgo.Go.cfor((_n < _value.length) && _isDigit(("" : stdgo.GoString), _value?.__copy__(), _n), _n++, {});
                                {
                                    var __tmp__ = _parseNanoseconds(("" : stdgo.GoString), _value?.__copy__(), _n);
                                    _nsec = __tmp__._0;
                                    _rangeErrString = __tmp__._1?.__copy__();
                                    _err = __tmp__._2;
                                };
                                _value = (_value.__slice__(_n) : stdgo.GoString)?.__copy__();
                            };
                            break;
                        } else if (__value__ == ((533 : stdgo.GoInt))) {
                            if ((_value.length) < (2 : stdgo.GoInt)) {
                                _err = _errBad;
                                break;
                            };
                            {
                                final __tmp__0 = (_value.__slice__((0 : stdgo.GoInt), (2 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                final __tmp__1 = (_value.__slice__((2 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                _p = __tmp__0;
                                _value = __tmp__1;
                            };
                            {
                                final __value__ = _p;
                                if (__value__ == (("PM" : stdgo.GoString))) {
                                    _pmSet = true;
                                } else if (__value__ == (("AM" : stdgo.GoString))) {
                                    _amSet = true;
                                } else {
                                    _err = _errBad;
                                };
                            };
                            break;
                        } else if (__value__ == ((534 : stdgo.GoInt))) {
                            if ((_value.length) < (2 : stdgo.GoInt)) {
                                _err = _errBad;
                                break;
                            };
                            {
                                final __tmp__0 = (_value.__slice__((0 : stdgo.GoInt), (2 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                final __tmp__1 = (_value.__slice__((2 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                _p = __tmp__0;
                                _value = __tmp__1;
                            };
                            {
                                final __value__ = _p;
                                if (__value__ == (("pm" : stdgo.GoString))) {
                                    _pmSet = true;
                                } else if (__value__ == (("am" : stdgo.GoString))) {
                                    _amSet = true;
                                } else {
                                    _err = _errBad;
                                };
                            };
                            break;
                        } else if (__value__ == ((24 : stdgo.GoInt)) || __value__ == ((27 : stdgo.GoInt)) || __value__ == ((25 : stdgo.GoInt)) || __value__ == ((26 : stdgo.GoInt)) || __value__ == ((28 : stdgo.GoInt)) || __value__ == ((29 : stdgo.GoInt)) || __value__ == ((31 : stdgo.GoInt)) || __value__ == ((32 : stdgo.GoInt)) || __value__ == ((30 : stdgo.GoInt)) || __value__ == ((33 : stdgo.GoInt))) {
                            if (((((_std == (24 : stdgo.GoInt)) || (_std == (26 : stdgo.GoInt))) || (_std == (27 : stdgo.GoInt))) && (_value.length >= (1 : stdgo.GoInt))) && (_value[(0 : stdgo.GoInt)] == (90 : stdgo.GoUInt8))) {
                                _value = (_value.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                _z = utc;
                                break;
                            };
                            var __0:stdgo.GoString = ("" : stdgo.GoString), __1:stdgo.GoString = ("" : stdgo.GoString), __2:stdgo.GoString = ("" : stdgo.GoString), __3:stdgo.GoString = ("" : stdgo.GoString), _seconds:stdgo.GoString = __3, _min:stdgo.GoString = __2, _hour:stdgo.GoString = __1, _sign:stdgo.GoString = __0;
                            if ((_std == (27 : stdgo.GoInt)) || (_std == (32 : stdgo.GoInt))) {
                                if ((_value.length) < (6 : stdgo.GoInt)) {
                                    _err = _errBad;
                                    break;
                                };
                                if (_value[(3 : stdgo.GoInt)] != ((58 : stdgo.GoUInt8))) {
                                    _err = _errBad;
                                    break;
                                };
                                {
                                    final __tmp__0 = (_value.__slice__((0 : stdgo.GoInt), (1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                    final __tmp__1 = (_value.__slice__((1 : stdgo.GoInt), (3 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                    final __tmp__2 = (_value.__slice__((4 : stdgo.GoInt), (6 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                    final __tmp__3 = ("00" : stdgo.GoString);
                                    final __tmp__4 = (_value.__slice__((6 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                    _sign = __tmp__0;
                                    _hour = __tmp__1;
                                    _min = __tmp__2;
                                    _seconds = __tmp__3;
                                    _value = __tmp__4;
                                };
                            } else if ((_std == (31 : stdgo.GoInt)) || (_std == (26 : stdgo.GoInt))) {
                                if ((_value.length) < (3 : stdgo.GoInt)) {
                                    _err = _errBad;
                                    break;
                                };
                                {
                                    final __tmp__0 = (_value.__slice__((0 : stdgo.GoInt), (1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                    final __tmp__1 = (_value.__slice__((1 : stdgo.GoInt), (3 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                    final __tmp__2 = ("00" : stdgo.GoString);
                                    final __tmp__3 = ("00" : stdgo.GoString);
                                    final __tmp__4 = (_value.__slice__((3 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                    _sign = __tmp__0;
                                    _hour = __tmp__1;
                                    _min = __tmp__2;
                                    _seconds = __tmp__3;
                                    _value = __tmp__4;
                                };
                            } else if ((_std == (28 : stdgo.GoInt)) || (_std == (33 : stdgo.GoInt))) {
                                if ((_value.length) < (9 : stdgo.GoInt)) {
                                    _err = _errBad;
                                    break;
                                };
                                if ((_value[(3 : stdgo.GoInt)] != (58 : stdgo.GoUInt8)) || (_value[(6 : stdgo.GoInt)] != (58 : stdgo.GoUInt8))) {
                                    _err = _errBad;
                                    break;
                                };
                                {
                                    final __tmp__0 = (_value.__slice__((0 : stdgo.GoInt), (1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                    final __tmp__1 = (_value.__slice__((1 : stdgo.GoInt), (3 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                    final __tmp__2 = (_value.__slice__((4 : stdgo.GoInt), (6 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                    final __tmp__3 = (_value.__slice__((7 : stdgo.GoInt), (9 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                    final __tmp__4 = (_value.__slice__((9 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                    _sign = __tmp__0;
                                    _hour = __tmp__1;
                                    _min = __tmp__2;
                                    _seconds = __tmp__3;
                                    _value = __tmp__4;
                                };
                            } else if ((_std == (25 : stdgo.GoInt)) || (_std == (30 : stdgo.GoInt))) {
                                if ((_value.length) < (7 : stdgo.GoInt)) {
                                    _err = _errBad;
                                    break;
                                };
                                {
                                    final __tmp__0 = (_value.__slice__((0 : stdgo.GoInt), (1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                    final __tmp__1 = (_value.__slice__((1 : stdgo.GoInt), (3 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                    final __tmp__2 = (_value.__slice__((3 : stdgo.GoInt), (5 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                    final __tmp__3 = (_value.__slice__((5 : stdgo.GoInt), (7 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                    final __tmp__4 = (_value.__slice__((7 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                    _sign = __tmp__0;
                                    _hour = __tmp__1;
                                    _min = __tmp__2;
                                    _seconds = __tmp__3;
                                    _value = __tmp__4;
                                };
                            } else {
                                if ((_value.length) < (5 : stdgo.GoInt)) {
                                    _err = _errBad;
                                    break;
                                };
                                {
                                    final __tmp__0 = (_value.__slice__((0 : stdgo.GoInt), (1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                    final __tmp__1 = (_value.__slice__((1 : stdgo.GoInt), (3 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                    final __tmp__2 = (_value.__slice__((3 : stdgo.GoInt), (5 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                    final __tmp__3 = ("00" : stdgo.GoString);
                                    final __tmp__4 = (_value.__slice__((5 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                    _sign = __tmp__0;
                                    _hour = __tmp__1;
                                    _min = __tmp__2;
                                    _seconds = __tmp__3;
                                    _value = __tmp__4;
                                };
                            };
                            var __0:stdgo.GoInt = (0 : stdgo.GoInt), __1:stdgo.GoInt = (0 : stdgo.GoInt), __2:stdgo.GoInt = (0 : stdgo.GoInt), _ss:stdgo.GoInt = __2, _mm:stdgo.GoInt = __1, _hr:stdgo.GoInt = __0;
                            {
                                var __tmp__ = _getnum(_hour?.__copy__(), true);
                                _hr = __tmp__._0;
                                _err = __tmp__._2;
                            };
                            if (_err == null) {
                                {
                                    var __tmp__ = _getnum(_min?.__copy__(), true);
                                    _mm = __tmp__._0;
                                    _err = __tmp__._2;
                                };
                            };
                            if (_err == null) {
                                {
                                    var __tmp__ = _getnum(_seconds?.__copy__(), true);
                                    _ss = __tmp__._0;
                                    _err = __tmp__._2;
                                };
                            };
                            _zoneOffset = (((_hr * (60 : stdgo.GoInt)) + _mm) * (60 : stdgo.GoInt)) + _ss;
                            {
                                final __value__ = _sign[(0 : stdgo.GoInt)];
                                if (__value__ == ((43 : stdgo.GoUInt8))) {} else if (__value__ == ((45 : stdgo.GoUInt8))) {
                                    _zoneOffset = -_zoneOffset;
                                } else {
                                    _err = _errBad;
                                };
                            };
                            break;
                        } else if (__value__ == ((23 : stdgo.GoInt))) {
                            if ((_value.length >= (3 : stdgo.GoInt)) && ((_value.__slice__((0 : stdgo.GoInt), (3 : stdgo.GoInt)) : stdgo.GoString) == ("UTC" : stdgo.GoString))) {
                                _z = utc;
                                _value = (_value.__slice__((3 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                                break;
                            };
                            var __tmp__ = _parseTimeZone(_value?.__copy__()), _n:stdgo.GoInt = __tmp__._0, _ok:Bool = __tmp__._1;
                            if (!_ok) {
                                _err = _errBad;
                                break;
                            };
                            {
                                final __tmp__0 = (_value.__slice__(0, _n) : stdgo.GoString)?.__copy__();
                                final __tmp__1 = (_value.__slice__(_n) : stdgo.GoString)?.__copy__();
                                _zoneName = __tmp__0;
                                _value = __tmp__1;
                            };
                            break;
                        } else if (__value__ == ((34 : stdgo.GoInt))) {
                            var _ndigit:stdgo.GoInt = (1 : stdgo.GoInt) + _digitsLen(_std);
                            if ((_value.length) < _ndigit) {
                                _err = _errBad;
                                break;
                            };
                            {
                                var __tmp__ = _parseNanoseconds(("" : stdgo.GoString), _value?.__copy__(), _ndigit);
                                _nsec = __tmp__._0;
                                _rangeErrString = __tmp__._1?.__copy__();
                                _err = __tmp__._2;
                            };
                            _value = (_value.__slice__(_ndigit) : stdgo.GoString)?.__copy__();
                            break;
                        } else if (__value__ == ((35 : stdgo.GoInt))) {
                            if ((((_value.length < (2 : stdgo.GoInt)) || !_commaOrPeriod(_value[(0 : stdgo.GoInt)])) || (_value[(1 : stdgo.GoInt)] < (48 : stdgo.GoUInt8))) || ((57 : stdgo.GoUInt8) < _value[(1 : stdgo.GoInt)])) {
                                break;
                            };
                            var _i:stdgo.GoInt = (0 : stdgo.GoInt);
                            while ((((_i + (1 : stdgo.GoInt)) < _value.length) && ((48 : stdgo.GoUInt8) <= _value[(_i + (1 : stdgo.GoInt) : stdgo.GoInt)])) && (_value[(_i + (1 : stdgo.GoInt) : stdgo.GoInt)] <= (57 : stdgo.GoUInt8))) {
                                _i++;
                            };
                            {
                                var __tmp__ = _parseNanoseconds(("" : stdgo.GoString), _value?.__copy__(), (1 : stdgo.GoInt) + _i);
                                _nsec = __tmp__._0;
                                _rangeErrString = __tmp__._1?.__copy__();
                                _err = __tmp__._2;
                            };
                            _value = (_value.__slice__((1 : stdgo.GoInt) + _i) : stdgo.GoString)?.__copy__();
                            break;
                        };
                    };
                    break;
                };
            };
            if (_rangeErrString != (stdgo.Go.str())) {
                return { _0 : (new stdgo.time.Time.Time() : stdgo.time.Time.Time), _1 : stdgo.Go.asInterface(_newParseError(_alayout?.__copy__(), _avalue?.__copy__(), _stdstr?.__copy__(), _value?.__copy__(), (": " : stdgo.GoString) + _rangeErrString?.__copy__() + (" out of range" : stdgo.GoString)?.__copy__()?.__copy__())) };
            };
            if (_err != null) {
                return { _0 : (new stdgo.time.Time.Time() : stdgo.time.Time.Time), _1 : stdgo.Go.asInterface(_newParseError(_alayout?.__copy__(), _avalue?.__copy__(), _stdstr?.__copy__(), _hold?.__copy__(), stdgo.Go.str()?.__copy__())) };
            };
        };
        if (_pmSet && (_hour < (12 : stdgo.GoInt))) {
            _hour = _hour + ((12 : stdgo.GoInt));
        } else if (_amSet && (_hour == (12 : stdgo.GoInt))) {
            _hour = (0 : stdgo.GoInt);
        };
        if (_yday >= (0 : stdgo.GoInt)) {
            var _d:stdgo.GoInt = (0 : stdgo.GoInt);
            var _m:stdgo.GoInt = (0 : stdgo.GoInt);
            if (_isLeap(_year)) {
                if (_yday == ((60 : stdgo.GoInt))) {
                    _m = ((2 : stdgo.time.Time.Month) : stdgo.GoInt);
                    _d = (29 : stdgo.GoInt);
                } else if (_yday > (60 : stdgo.GoInt)) {
                    _yday--;
                };
            };
            if ((_yday < (1 : stdgo.GoInt)) || (_yday > (365 : stdgo.GoInt))) {
                return { _0 : (new stdgo.time.Time.Time() : stdgo.time.Time.Time), _1 : stdgo.Go.asInterface(_newParseError(_alayout?.__copy__(), _avalue?.__copy__(), stdgo.Go.str()?.__copy__(), _value?.__copy__(), (": day-of-year out of range" : stdgo.GoString))) };
            };
            if (_m == ((0 : stdgo.GoInt))) {
                _m = ((_yday - (1 : stdgo.GoInt)) / (31 : stdgo.GoInt)) + (1 : stdgo.GoInt);
                if ((_daysBefore[(_m : stdgo.GoInt)] : stdgo.GoInt) < _yday) {
                    _m++;
                };
                _d = _yday - (_daysBefore[(_m - (1 : stdgo.GoInt) : stdgo.GoInt)] : stdgo.GoInt);
            };
            if ((_month >= (0 : stdgo.GoInt)) && (_month != _m)) {
                return { _0 : (new stdgo.time.Time.Time() : stdgo.time.Time.Time), _1 : stdgo.Go.asInterface(_newParseError(_alayout?.__copy__(), _avalue?.__copy__(), stdgo.Go.str()?.__copy__(), _value?.__copy__(), (": day-of-year does not match month" : stdgo.GoString))) };
            };
            _month = _m;
            if ((_day >= (0 : stdgo.GoInt)) && (_day != _d)) {
                return { _0 : (new stdgo.time.Time.Time() : stdgo.time.Time.Time), _1 : stdgo.Go.asInterface(_newParseError(_alayout?.__copy__(), _avalue?.__copy__(), stdgo.Go.str()?.__copy__(), _value?.__copy__(), (": day-of-year does not match day" : stdgo.GoString))) };
            };
            _day = _d;
        } else {
            if (_month < (0 : stdgo.GoInt)) {
                _month = ((1 : stdgo.time.Time.Month) : stdgo.GoInt);
            };
            if (_day < (0 : stdgo.GoInt)) {
                _day = (1 : stdgo.GoInt);
            };
        };
        if ((_day < (1 : stdgo.GoInt)) || (_day > _daysIn((_month : Month), _year))) {
            return { _0 : (new stdgo.time.Time.Time() : stdgo.time.Time.Time), _1 : stdgo.Go.asInterface(_newParseError(_alayout?.__copy__(), _avalue?.__copy__(), stdgo.Go.str()?.__copy__(), _value?.__copy__(), (": day out of range" : stdgo.GoString))) };
        };
        if (_z != null && ((_z : Dynamic).__nil__ == null || !(_z : Dynamic).__nil__)) {
            return { _0 : date(_year, (_month : Month), _day, _hour, _min, _sec, _nsec, _z)?.__copy__(), _1 : (null : stdgo.Error) };
        };
        if (_zoneOffset != ((-1 : stdgo.GoInt))) {
            var _t:stdgo.time.Time.Time = date(_year, (_month : Month), _day, _hour, _min, _sec, _nsec, utc)?.__copy__();
            _t._addSec(-(_zoneOffset : stdgo.GoInt64));
            var __tmp__ = _local._lookup(_t._unixSec()), _name:stdgo.GoString = __tmp__._0, _offset:stdgo.GoInt = __tmp__._1, __1:stdgo.GoInt64 = __tmp__._2, __2:stdgo.GoInt64 = __tmp__._3, __3:Bool = __tmp__._4;
            if ((_offset == _zoneOffset) && ((_zoneName == stdgo.Go.str()) || (_name == _zoneName))) {
                _t._setLoc(_local);
                return { _0 : _t?.__copy__(), _1 : (null : stdgo.Error) };
            };
            var _zoneNameCopy:stdgo.GoString = _cloneString(_zoneName?.__copy__())?.__copy__();
            _t._setLoc(fixedZone(_zoneNameCopy?.__copy__(), _zoneOffset));
            return { _0 : _t?.__copy__(), _1 : (null : stdgo.Error) };
        };
        if (_zoneName != (stdgo.Go.str())) {
            var _t:stdgo.time.Time.Time = date(_year, (_month : Month), _day, _hour, _min, _sec, _nsec, utc)?.__copy__();
            var __tmp__ = _local._lookupName(_zoneName?.__copy__(), _t._unixSec()), _offset:stdgo.GoInt = __tmp__._0, _ok:Bool = __tmp__._1;
            if (_ok) {
                _t._addSec(-(_offset : stdgo.GoInt64));
                _t._setLoc(_local);
                return { _0 : _t?.__copy__(), _1 : (null : stdgo.Error) };
            };
            if ((_zoneName.length > (3 : stdgo.GoInt)) && ((_zoneName.__slice__(0, (3 : stdgo.GoInt)) : stdgo.GoString) == ("GMT" : stdgo.GoString))) {
                {
                    var __tmp__ = _atoi(("" : stdgo.GoString), (_zoneName.__slice__((3 : stdgo.GoInt)) : stdgo.GoString)?.__copy__());
                    _offset = __tmp__._0;
                };
                _offset = _offset * ((3600 : stdgo.GoInt));
            };
            var _zoneNameCopy:stdgo.GoString = _cloneString(_zoneName?.__copy__())?.__copy__();
            _t._setLoc(fixedZone(_zoneNameCopy?.__copy__(), _offset));
            return { _0 : _t?.__copy__(), _1 : (null : stdgo.Error) };
        };
        return { _0 : date(_year, (_month : Month), _day, _hour, _min, _sec, _nsec, _defaultLocation)?.__copy__(), _1 : (null : stdgo.Error) };
    }
/**
    // parseTimeZone parses a time zone string and returns its length. Time zones
    // are human-generated and unpredictable. We can't do precise error checking.
    // On the other hand, for a correct parse there must be a time zone at the
    // beginning of the string, so it's almost always true that there's one
    // there. We look at the beginning of the string for a run of upper-case letters.
    // If there are more than 5, it's an error.
    // If there are 4 or 5 and the last is a T, it's a time zone.
    // If there are 3, it's a time zone.
    // Otherwise, other than special cases, it's not a time zone.
    // GMT is special because it can have an hour offset.
**/
function _parseTimeZone(_value:stdgo.GoString):{ var _0 : stdgo.GoInt; var _1 : Bool; } {
        var _length:stdgo.GoInt = (0 : stdgo.GoInt), _ok:Bool = false;
        if ((_value.length) < (3 : stdgo.GoInt)) {
            return { _0 : (0 : stdgo.GoInt), _1 : false };
        };
        if ((_value.length >= (4 : stdgo.GoInt)) && (((_value.__slice__(0, (4 : stdgo.GoInt)) : stdgo.GoString) == ("ChST" : stdgo.GoString)) || ((_value.__slice__(0, (4 : stdgo.GoInt)) : stdgo.GoString) == ("MeST" : stdgo.GoString)))) {
            return { _0 : (4 : stdgo.GoInt), _1 : true };
        };
        if ((_value.__slice__(0, (3 : stdgo.GoInt)) : stdgo.GoString) == (("GMT" : stdgo.GoString))) {
            _length = _parseGMT(_value?.__copy__());
            return { _0 : _length, _1 : true };
        };
        if ((_value[(0 : stdgo.GoInt)] == (43 : stdgo.GoUInt8)) || (_value[(0 : stdgo.GoInt)] == (45 : stdgo.GoUInt8))) {
            _length = _parseSignedOffset(_value?.__copy__());
            var _ok:Bool = _length > (0 : stdgo.GoInt);
            return { _0 : _length, _1 : _ok };
        };
        var _nUpper:stdgo.GoInt = (0 : stdgo.GoInt);
        {
            _nUpper = (0 : stdgo.GoInt);
            stdgo.Go.cfor(_nUpper < (6 : stdgo.GoInt), _nUpper++, {
                if (_nUpper >= (_value.length)) {
                    break;
                };
                {
                    var _c:stdgo.GoUInt8 = _value[(_nUpper : stdgo.GoInt)];
                    if ((_c < (65 : stdgo.GoUInt8)) || ((90 : stdgo.GoUInt8) < _c)) {
                        break;
                    };
                };
            });
        };
        {
            final __value__ = _nUpper;
            if (__value__ == ((0 : stdgo.GoInt)) || __value__ == ((1 : stdgo.GoInt)) || __value__ == ((2 : stdgo.GoInt)) || __value__ == ((6 : stdgo.GoInt))) {
                return { _0 : (0 : stdgo.GoInt), _1 : false };
            } else if (__value__ == ((5 : stdgo.GoInt))) {
                if (_value[(4 : stdgo.GoInt)] == ((84 : stdgo.GoUInt8))) {
                    return { _0 : (5 : stdgo.GoInt), _1 : true };
                };
            } else if (__value__ == ((4 : stdgo.GoInt))) {
                if ((_value[(3 : stdgo.GoInt)] == (84 : stdgo.GoUInt8)) || ((_value.__slice__(0, (4 : stdgo.GoInt)) : stdgo.GoString) == ("WITA" : stdgo.GoString))) {
                    return { _0 : (4 : stdgo.GoInt), _1 : true };
                };
            } else if (__value__ == ((3 : stdgo.GoInt))) {
                return { _0 : (3 : stdgo.GoInt), _1 : true };
            };
        };
        return { _0 : (0 : stdgo.GoInt), _1 : false };
    }
/**
    // parseGMT parses a GMT time zone. The input string is known to start "GMT".
    // The function checks whether that is followed by a sign and a number in the
    // range -23 through +23 excluding zero.
**/
function _parseGMT(_value:stdgo.GoString):stdgo.GoInt {
        _value = (_value.__slice__((3 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
        if ((_value.length) == ((0 : stdgo.GoInt))) {
            return (3 : stdgo.GoInt);
        };
        return (3 : stdgo.GoInt) + _parseSignedOffset(_value?.__copy__());
    }
/**
    // parseSignedOffset parses a signed timezone offset (e.g. "+03" or "-04").
    // The function checks for a signed number in the range -23 through +23 excluding zero.
    // Returns length of the found offset string or 0 otherwise.
**/
function _parseSignedOffset(_value:stdgo.GoString):stdgo.GoInt {
        var _sign:stdgo.GoUInt8 = _value[(0 : stdgo.GoInt)];
        if ((_sign != (45 : stdgo.GoUInt8)) && (_sign != (43 : stdgo.GoUInt8))) {
            return (0 : stdgo.GoInt);
        };
        var __tmp__ = _leadingInt(("" : stdgo.GoString), (_value.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__()), _x:stdgo.GoUInt64 = __tmp__._0, _rem:stdgo.GoString = __tmp__._1, _err:stdgo.Error = __tmp__._2;
        if ((_err != null) || ((_value.__slice__((1 : stdgo.GoInt)) : stdgo.GoString) == _rem)) {
            return (0 : stdgo.GoInt);
        };
        if (_x > (23i64 : stdgo.GoUInt64)) {
            return (0 : stdgo.GoInt);
        };
        return (_value.length) - (_rem.length);
    }
function _commaOrPeriod(_b:stdgo.GoByte):Bool {
        return (_b == (46 : stdgo.GoUInt8)) || (_b == (44 : stdgo.GoUInt8));
    }
macro function _parseNanoseconds<T_bytes>(__generic__0:haxe.macro.Expr.ExprOf<T_bytes>, _value:haxe.macro.Expr.ExprOf<T_bytes>, _nbytes:haxe.macro.Expr.ExprOf<stdgo.GoInt>):haxe.macro.Expr.ExprOf<{ var _0 : stdgo.GoInt; var _1 : stdgo.GoString; var _2 : stdgo.Error; }>;
/**
    // leadingInt consumes the leading [0-9]* from s.
**/
macro function _leadingInt<T_bytes>(__generic__0:haxe.macro.Expr.ExprOf<T_bytes>, _s:haxe.macro.Expr.ExprOf<T_bytes>):haxe.macro.Expr.ExprOf<{ var _0 : stdgo.GoUInt64; var _1 : T_bytes; var _2 : stdgo.Error; }>;
/**
    // leadingFraction consumes the leading [0-9]* from s.
    // It is used only for fractions, so does not return an error on overflow,
    // it just stops accumulating precision.
**/
function _leadingFraction(_s:stdgo.GoString):{ var _0 : stdgo.GoUInt64; var _1 : stdgo.GoFloat64; var _2 : stdgo.GoString; } {
        var _x:stdgo.GoUInt64 = (0 : stdgo.GoUInt64), _scale:stdgo.GoFloat64 = (0 : stdgo.GoFloat64), _rem:stdgo.GoString = ("" : stdgo.GoString);
        var _i:stdgo.GoInt = (0 : stdgo.GoInt);
        _scale = (1 : stdgo.GoFloat64);
        var _overflow:Bool = false;
        stdgo.Go.cfor(_i < (_s.length), _i++, {
            var _c:stdgo.GoUInt8 = _s[(_i : stdgo.GoInt)];
            if ((_c < (48 : stdgo.GoUInt8)) || (_c > (57 : stdgo.GoUInt8))) {
                break;
            };
            if (_overflow) {
                continue;
            };
            if (_x > (922337203685477580i64 : stdgo.GoUInt64)) {
                _overflow = true;
                continue;
            };
            var _y:stdgo.GoUInt64 = ((_x * (10i64 : stdgo.GoUInt64)) + (_c : stdgo.GoUInt64)) - (48i64 : stdgo.GoUInt64);
            if (_y > (-9223372036854775808i64 : stdgo.GoUInt64)) {
                _overflow = true;
                continue;
            };
            _x = _y;
            _scale = _scale * (10 : stdgo.GoFloat64);
        });
        return { _0 : _x, _1 : _scale, _2 : (_s.__slice__(_i) : stdgo.GoString)?.__copy__() };
    }
/**
    // ParseDuration parses a duration string.
    // A duration string is a possibly signed sequence of
    // decimal numbers, each with optional fraction and a unit suffix,
    // such as "300ms", "-1.5h" or "2h45m".
    // Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
**/
function parseDuration(_s:stdgo.GoString):{ var _0 : Duration; var _1 : stdgo.Error; } {
        var _orig:stdgo.GoString = _s?.__copy__();
        var _d:stdgo.GoUInt64 = (0 : stdgo.GoUInt64);
        var _neg:Bool = false;
        if (_s != (stdgo.Go.str())) {
            var _c:stdgo.GoUInt8 = _s[(0 : stdgo.GoInt)];
            if ((_c == (45 : stdgo.GoUInt8)) || (_c == (43 : stdgo.GoUInt8))) {
                _neg = _c == ((45 : stdgo.GoUInt8));
                _s = (_s.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
            };
        };
        if (_s == (("0" : stdgo.GoString))) {
            return { _0 : (0i64 : stdgo.time.Time.Duration), _1 : (null : stdgo.Error) };
        };
        if (_s == (stdgo.Go.str())) {
            return { _0 : (0i64 : stdgo.time.Time.Duration), _1 : stdgo.errors.Errors.new_(("time: invalid duration " : stdgo.GoString) + _quote(_orig?.__copy__())?.__copy__()?.__copy__()) };
        };
        while (_s != (stdgo.Go.str())) {
            var __0:stdgo.GoUInt64 = (0 : stdgo.GoUInt64), __1:stdgo.GoUInt64 = (0 : stdgo.GoUInt64), __2:stdgo.GoFloat64 = (1 : stdgo.GoFloat64), _scale:stdgo.GoFloat64 = __2, _f:stdgo.GoUInt64 = __1, _v:stdgo.GoUInt64 = __0;
            var _err:stdgo.Error = (null : stdgo.Error);
            if (!((_s[(0 : stdgo.GoInt)] == (46 : stdgo.GoUInt8)) || (((48 : stdgo.GoUInt8) <= _s[(0 : stdgo.GoInt)]) && (_s[(0 : stdgo.GoInt)] <= (57 : stdgo.GoUInt8))))) {
                return { _0 : (0i64 : stdgo.time.Time.Duration), _1 : stdgo.errors.Errors.new_(("time: invalid duration " : stdgo.GoString) + _quote(_orig?.__copy__())?.__copy__()?.__copy__()) };
            };
            var _pl:stdgo.GoInt = (_s.length);
            {
                var __tmp__ = _leadingInt(("" : stdgo.GoString), _s?.__copy__());
                _v = __tmp__._0;
                _s = __tmp__._1?.__copy__();
                _err = __tmp__._2;
            };
            if (_err != null) {
                return { _0 : (0i64 : stdgo.time.Time.Duration), _1 : stdgo.errors.Errors.new_(("time: invalid duration " : stdgo.GoString) + _quote(_orig?.__copy__())?.__copy__()?.__copy__()) };
            };
            var _pre:Bool = _pl != ((_s.length));
            var _post:Bool = false;
            if ((_s != stdgo.Go.str()) && (_s[(0 : stdgo.GoInt)] == (46 : stdgo.GoUInt8))) {
                _s = (_s.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                var _pl:stdgo.GoInt = (_s.length);
                {
                    var __tmp__ = _leadingFraction(_s?.__copy__());
                    _f = __tmp__._0;
                    _scale = __tmp__._1;
                    _s = __tmp__._2?.__copy__();
                };
                _post = _pl != ((_s.length));
            };
            if (!_pre && !_post) {
                return { _0 : (0i64 : stdgo.time.Time.Duration), _1 : stdgo.errors.Errors.new_(("time: invalid duration " : stdgo.GoString) + _quote(_orig?.__copy__())?.__copy__()?.__copy__()) };
            };
            var _i:stdgo.GoInt = (0 : stdgo.GoInt);
            stdgo.Go.cfor(_i < (_s.length), _i++, {
                var _c:stdgo.GoUInt8 = _s[(_i : stdgo.GoInt)];
                if ((_c == (46 : stdgo.GoUInt8)) || (((48 : stdgo.GoUInt8) <= _c) && (_c <= (57 : stdgo.GoUInt8)))) {
                    break;
                };
            });
            if (_i == ((0 : stdgo.GoInt))) {
                return { _0 : (0i64 : stdgo.time.Time.Duration), _1 : stdgo.errors.Errors.new_(("time: missing unit in duration " : stdgo.GoString) + _quote(_orig?.__copy__())?.__copy__()?.__copy__()) };
            };
            var _u:stdgo.GoString = (_s.__slice__(0, _i) : stdgo.GoString)?.__copy__();
            _s = (_s.__slice__(_i) : stdgo.GoString)?.__copy__();
            var __tmp__ = (_unitMap != null && _unitMap.exists(_u?.__copy__()) ? { _0 : _unitMap[_u?.__copy__()], _1 : true } : { _0 : (0 : stdgo.GoUInt64), _1 : false }), _unit:stdgo.GoUInt64 = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                return { _0 : (0i64 : stdgo.time.Time.Duration), _1 : stdgo.errors.Errors.new_(("time: unknown unit " : stdgo.GoString) + _quote(_u?.__copy__())?.__copy__() + (" in duration " : stdgo.GoString)?.__copy__() + _quote(_orig?.__copy__())?.__copy__()?.__copy__()) };
            };
            if (_v > ((-9223372036854775808i64 : stdgo.GoUInt64) / _unit)) {
                return { _0 : (0i64 : stdgo.time.Time.Duration), _1 : stdgo.errors.Errors.new_(("time: invalid duration " : stdgo.GoString) + _quote(_orig?.__copy__())?.__copy__()?.__copy__()) };
            };
            _v = _v * (_unit);
            if (_f > (0i64 : stdgo.GoUInt64)) {
                _v = _v + (((_f : stdgo.GoFloat64) * ((_unit : stdgo.GoFloat64) / _scale) : stdgo.GoUInt64));
                if (_v > (-9223372036854775808i64 : stdgo.GoUInt64)) {
                    return { _0 : (0i64 : stdgo.time.Time.Duration), _1 : stdgo.errors.Errors.new_(("time: invalid duration " : stdgo.GoString) + _quote(_orig?.__copy__())?.__copy__()?.__copy__()) };
                };
            };
            _d = _d + (_v);
            if (_d > (-9223372036854775808i64 : stdgo.GoUInt64)) {
                return { _0 : (0i64 : stdgo.time.Time.Duration), _1 : stdgo.errors.Errors.new_(("time: invalid duration " : stdgo.GoString) + _quote(_orig?.__copy__())?.__copy__()?.__copy__()) };
            };
        };
        if (_neg) {
            return { _0 : -(_d : Duration), _1 : (null : stdgo.Error) };
        };
        if (_d > (9223372036854775807i64 : stdgo.GoUInt64)) {
            return { _0 : (0i64 : stdgo.time.Time.Duration), _1 : stdgo.errors.Errors.new_(("time: invalid duration " : stdgo.GoString) + _quote(_orig?.__copy__())?.__copy__()?.__copy__()) };
        };
        return { _0 : (_d : Duration), _1 : (null : stdgo.Error) };
    }
macro function _parseRFC3339<T_bytes>(__generic__0:haxe.macro.Expr.ExprOf<T_bytes>, _s:haxe.macro.Expr.ExprOf<T_bytes>, _local:haxe.macro.Expr.ExprOf<stdgo.Ref<Location>>):haxe.macro.Expr.ExprOf<{ var _0 : Time; var _1 : Bool; }>;
function _parseStrictRFC3339(_b:stdgo.Slice<stdgo.GoByte>):{ var _0 : Time; var _1 : stdgo.Error; } {
        var __tmp__ = _parseRFC3339((null : stdgo.Slice<stdgo.GoUInt8>), _b, local), _t:stdgo.time.Time.Time = __tmp__._0, _ok:Bool = __tmp__._1;
        if (!_ok) {
            var __tmp__ = parse(("2006-01-02T15:04:05Z07:00" : stdgo.GoString), (_b : stdgo.GoString)?.__copy__()), _t:stdgo.time.Time.Time = __tmp__._0, _err:stdgo.Error = __tmp__._1;
            if (_err != null) {
                return { _0 : (new stdgo.time.Time.Time() : stdgo.time.Time.Time), _1 : _err };
            };
            var _num2 = function(_b:stdgo.Slice<stdgo.GoByte>):stdgo.GoByte {
                return ((10 : stdgo.GoUInt8) * (_b[(0 : stdgo.GoInt)] - (48 : stdgo.GoUInt8))) + (_b[(1 : stdgo.GoInt)] - (48 : stdgo.GoUInt8));
            };
            if (true) {
                return { _0 : _t?.__copy__(), _1 : (null : stdgo.Error) };
            } else if (_b[(12 : stdgo.GoInt)] == ((58 : stdgo.GoUInt8))) {
                return { _0 : (new stdgo.time.Time.Time() : stdgo.time.Time.Time), _1 : stdgo.Go.asInterface((stdgo.Go.setRef((new stdgo.time.Time.ParseError(("2006-01-02T15:04:05Z07:00" : stdgo.GoString), (_b : stdgo.GoString)?.__copy__(), ("15" : stdgo.GoString), (((_b.__slice__((("2006-01-02T" : stdgo.GoString).length)) : stdgo.Slice<stdgo.GoUInt8>).__slice__(0, (1 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoUInt8>) : stdgo.GoString)?.__copy__(), stdgo.Go.str()?.__copy__()) : stdgo.time.Time.ParseError)) : stdgo.Ref<stdgo.time.Time.ParseError>)) };
            } else if (_b[(("2006-01-02T15:04:05" : stdgo.GoString).length : stdgo.GoInt)] == ((44 : stdgo.GoUInt8))) {
                return { _0 : (new stdgo.time.Time.Time() : stdgo.time.Time.Time), _1 : stdgo.Go.asInterface((stdgo.Go.setRef((new stdgo.time.Time.ParseError(("2006-01-02T15:04:05Z07:00" : stdgo.GoString), (_b : stdgo.GoString)?.__copy__(), ("." : stdgo.GoString), ("," : stdgo.GoString), stdgo.Go.str()?.__copy__()) : stdgo.time.Time.ParseError)) : stdgo.Ref<stdgo.time.Time.ParseError>)) };
            } else if (_b[((_b.length) - (1 : stdgo.GoInt) : stdgo.GoInt)] != ((90 : stdgo.GoUInt8))) {
                if (_num2((_b.__slice__((_b.length) - (("07:00" : stdgo.GoString).length)) : stdgo.Slice<stdgo.GoUInt8>)) >= (24 : stdgo.GoUInt8)) {
                    return { _0 : (new stdgo.time.Time.Time() : stdgo.time.Time.Time), _1 : stdgo.Go.asInterface((stdgo.Go.setRef((new stdgo.time.Time.ParseError(("2006-01-02T15:04:05Z07:00" : stdgo.GoString), (_b : stdgo.GoString)?.__copy__(), ("Z07:00" : stdgo.GoString), ((_b.__slice__((_b.length) - (("Z07:00" : stdgo.GoString).length)) : stdgo.Slice<stdgo.GoUInt8>) : stdgo.GoString)?.__copy__(), (": timezone hour out of range" : stdgo.GoString)) : stdgo.time.Time.ParseError)) : stdgo.Ref<stdgo.time.Time.ParseError>)) };
                } else if (_num2((_b.__slice__((_b.length) - (("00" : stdgo.GoString).length)) : stdgo.Slice<stdgo.GoUInt8>)) >= (60 : stdgo.GoUInt8)) {
                    return { _0 : (new stdgo.time.Time.Time() : stdgo.time.Time.Time), _1 : stdgo.Go.asInterface((stdgo.Go.setRef((new stdgo.time.Time.ParseError(("2006-01-02T15:04:05Z07:00" : stdgo.GoString), (_b : stdgo.GoString)?.__copy__(), ("Z07:00" : stdgo.GoString), ((_b.__slice__((_b.length) - (("Z07:00" : stdgo.GoString).length)) : stdgo.Slice<stdgo.GoUInt8>) : stdgo.GoString)?.__copy__(), (": timezone minute out of range" : stdgo.GoString)) : stdgo.time.Time.ParseError)) : stdgo.Ref<stdgo.time.Time.ParseError>)) };
                };
            } else {
                return { _0 : (new stdgo.time.Time.Time() : stdgo.time.Time.Time), _1 : stdgo.Go.asInterface((stdgo.Go.setRef((new stdgo.time.Time.ParseError(("2006-01-02T15:04:05Z07:00" : stdgo.GoString), (_b : stdgo.GoString)?.__copy__(), ("2006-01-02T15:04:05Z07:00" : stdgo.GoString), (_b : stdgo.GoString)?.__copy__(), stdgo.Go.str()?.__copy__()) : stdgo.time.Time.ParseError)) : stdgo.Ref<stdgo.time.Time.ParseError>)) };
            };
        };
        return { _0 : _t?.__copy__(), _1 : (null : stdgo.Error) };
    }
function _initTestingZone():Void {
        var _sources = (new stdgo.Slice<stdgo.GoString>(1, 1, ("../../lib/time/zoneinfo.zip" : stdgo.GoString)) : stdgo.Slice<stdgo.GoString>);
        var __tmp__ = _loadLocation(("America/Los_Angeles" : stdgo.GoString), _sources), _z:stdgo.Ref<stdgo.time.Time.Location> = __tmp__._0, _err:stdgo.Error = __tmp__._1;
        if (_err != null) {
            throw stdgo.Go.toInterface(("cannot load America/Los_Angeles for testing: " : stdgo.GoString) + _err.error()?.__copy__() + ("; you may want to use -tags=timetzdata" : stdgo.GoString)?.__copy__());
        };
        _z._name = ("Local" : stdgo.GoString);
        _localLoc = (_z : stdgo.time.Time.Location)?.__copy__();
    }
function _disablePlatformSources():() -> Void {
        var _undo:() -> Void = null;
        _platformZoneSources = (null : stdgo.Slice<stdgo.GoString>);
        return function():Void {
            _platformZoneSources = _origPlatformZoneSources;
        };
    }
function _empty(_arg:stdgo.AnyInterface, _seq:stdgo.GoUIntptr):Void {}
/**
    // Test that a runtimeTimer with a period that would overflow when on
    // expiration does not throw or cause other timers to hang.
    //
    // This test has to be in internal_test.go since it fiddles with
    // unexported data structures.
**/
function checkRuntimeTimerPeriodOverflow():Void {
        var __deferstack__:Array<Void -> Void> = [];
        try {
            var _r = (stdgo.Go.setRef(({ _when : _runtimeNano(), _period : (9223372036854775807i64 : stdgo.GoInt64), _f : _empty, _arg : (null : stdgo.AnyInterface) } : stdgo.time.Time.T_runtimeTimer)) : stdgo.Ref<stdgo.time.Time.T_runtimeTimer>);
            _startTimer(_r);
            {
                var _a0 = _r;
                __deferstack__.unshift(() -> _stopTimer(_a0));
            };
            after((25000000i64 : stdgo.time.Time.Duration)).__get__();
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return;
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return;
        };
    }
/**
    // Sleep pauses the current goroutine for at least the duration d.
    // A negative or zero duration causes Sleep to return immediately.
**/
function sleep(_d:Duration):Void {
        final seconds = _d.toFloat() / 1000000000;
    }
/**
    // when is a helper function for setting the 'when' field of a runtimeTimer.
    // It returns what the time will be, in nanoseconds, Duration d in the future.
    // If d is negative, it is ignored. If the returned value would be less than
    // zero because of an overflow, MaxInt64 is returned.
**/
function _when(_d:Duration):stdgo.GoInt64 {
        if (_d <= (0i64 : stdgo.time.Time.Duration)) {
            return _runtimeNano();
        };
        var _t:stdgo.GoInt64 = _runtimeNano() + (_d : stdgo.GoInt64);
        if (_t < (0i64 : stdgo.GoInt64)) {
            _t = (9223372036854775807i64 : stdgo.GoInt64);
        };
        return _t;
    }
function _startTimer(_0:stdgo.Ref<T_runtimeTimer>):Void {
        final t = _0;
        t._status = 1;
        var diff = (t._when - Time._runtimeNano()) / (1000 * 1000);
        if (diff > 1 << 31 - 1) return;
        if (diff < 0) diff = 0;
        final d = (diff : stdgo.GoInt).toBasic() + 1;
        final timer = new haxe.Timer(d);
        timer.run = () -> {
            timer.stop();
            t._status = 0;
            if (t._period != (0 : stdgo.GoInt64)) {
                t._when += t._period;
                _startTimer(t);
            };
            stdgo.Go.routine(() -> t._f(t._arg, 0));
        };
        t._pp = (timer : stdgo.GoUIntptr);
    }
function _stopTimer(_0:stdgo.Ref<T_runtimeTimer>):Bool {
        final t:Dynamic = _0;
        if ((t._pp : stdgo.GoUIntptr) != (0 : stdgo.GoUIntptr)) {
            final timer:haxe.Timer = t._pp;
            timer.stop();
        };
        final wasActive = t._status == 1;
        t._status = 0;
        return wasActive;
    }
function _resetTimer(_0:stdgo.Ref<T_runtimeTimer>, _1:stdgo.GoInt64):Bool {
        final t = _0;
        final when = _1;
        final wasActive = t._status == 1;
        return wasActive;
    }
function _modTimer(_t:stdgo.Ref<T_runtimeTimer>, _when:stdgo.GoInt64, _period:stdgo.GoInt64, _f:(stdgo.AnyInterface, stdgo.GoUIntptr) -> Void, _arg:stdgo.AnyInterface, _seq:stdgo.GoUIntptr):Void {
        _stopTimer(_t);
        _t._when = _when;
        _t._period = _period;
        _t._f = _f;
        _t._arg = _arg;
        _t._seq = _seq;
        _startTimer(_t);
    }
/**
    // NewTimer creates a new Timer that will send
    // the current time on its channel after at least duration d.
**/
function newTimer(_d:Duration):stdgo.Ref<Timer> {
        var _c = new stdgo.Chan<stdgo.time.Time.Time>((1 : stdgo.GoInt).toBasic(), () -> ({} : stdgo.time.Time.Time));
        var _t = (stdgo.Go.setRef(({ c : _c, _r : ({ _when : _when(_d), _f : _sendTime, _arg : stdgo.Go.toInterface(_c) } : stdgo.time.Time.T_runtimeTimer) } : stdgo.time.Time.Timer)) : stdgo.Ref<stdgo.time.Time.Timer>);
        _startTimer((stdgo.Go.setRef(_t._r) : stdgo.Ref<stdgo.time.Time.T_runtimeTimer>));
        return _t;
    }
/**
    // sendTime does a non-blocking send of the current time on c.
**/
function _sendTime(_c:stdgo.AnyInterface, _seq:stdgo.GoUIntptr):Void {
        {
            var __select__ = true;
            while (__select__) {
                if ((stdgo.Go.typeAssert((_c : stdgo.Chan<Time>)) : stdgo.Chan<Time>) != null && (stdgo.Go.typeAssert((_c : stdgo.Chan<Time>)) : stdgo.Chan<Time>).__isSend__()) {
                    __select__ = false;
                    {
                        (stdgo.Go.typeAssert((_c : stdgo.Chan<Time>)) : stdgo.Chan<Time>).__send__(now());
                        {};
                    };
                } else {
                    __select__ = false;
                    {};
                };
                #if !js Sys.sleep(0.01) #else null #end;
                stdgo.internal.Async.tick();
            };
        };
    }
/**
    // After waits for the duration to elapse and then sends the current time
    // on the returned channel.
    // It is equivalent to NewTimer(d).C.
    // The underlying Timer is not recovered by the garbage collector
    // until the timer fires. If efficiency is a concern, use NewTimer
    // instead and call Timer.Stop if the timer is no longer needed.
**/
function after(_d:Duration):stdgo.Chan<Time> {
        return newTimer(_d).c;
    }
/**
    // AfterFunc waits for the duration to elapse and then calls f
    // in its own goroutine. It returns a Timer that can
    // be used to cancel the call using its Stop method.
**/
function afterFunc(_d:Duration, _f:() -> Void):stdgo.Ref<Timer> {
        var _t = (stdgo.Go.setRef(({ _r : ({ _when : _when(_d), _f : _goFunc, _arg : stdgo.Go.toInterface(_f) } : stdgo.time.Time.T_runtimeTimer) } : stdgo.time.Time.Timer)) : stdgo.Ref<stdgo.time.Time.Timer>);
        _startTimer((stdgo.Go.setRef(_t._r) : stdgo.Ref<stdgo.time.Time.T_runtimeTimer>));
        return _t;
    }
function _goFunc(_arg:stdgo.AnyInterface, _seq:stdgo.GoUIntptr):Void {
        stdgo.Go.routine(() -> (stdgo.Go.typeAssert((_arg : () -> Void)) : () -> Void)());
    }
/**
    // for testing: whatever interrupts a sleep
**/
function _interrupt():Void {
        if (true) {
            stdgo.syscall.Syscall.kill(stdgo.syscall.Syscall.getpid(), (1 : stdgo.syscall.Syscall.Signal));
        };
    }
function _open(_name:stdgo.GoString):{ var _0 : stdgo.GoUIntptr; var _1 : stdgo.Error; } {
        var __tmp__ = stdgo.syscall.Syscall.open(_name?.__copy__(), (0 : stdgo.GoInt), (0u32 : stdgo.GoUInt32)), _fd:stdgo.GoInt = __tmp__._0, _err:stdgo.Error = __tmp__._1;
        if (_err != null) {
            return { _0 : (0 : stdgo.GoUIntptr), _1 : _err };
        };
        return { _0 : (_fd : stdgo.GoUIntptr), _1 : (null : stdgo.Error) };
    }
function _read(_fd:stdgo.GoUIntptr, _buf:stdgo.Slice<stdgo.GoByte>):{ var _0 : stdgo.GoInt; var _1 : stdgo.Error; } {
        return stdgo.syscall.Syscall.read((_fd : stdgo.GoInt), _buf);
    }
function _closefd(_fd:stdgo.GoUIntptr):Void {
        stdgo.syscall.Syscall.close((_fd : stdgo.GoInt));
    }
function _preadn(_fd:stdgo.GoUIntptr, _buf:stdgo.Slice<stdgo.GoByte>, _off:stdgo.GoInt):stdgo.Error {
        var _whence:stdgo.GoInt = (0 : stdgo.GoInt);
        if (_off < (0 : stdgo.GoInt)) {
            _whence = (2 : stdgo.GoInt);
        };
        {
            var __tmp__ = stdgo.syscall.Syscall.seek((_fd : stdgo.GoInt), (_off : stdgo.GoInt64), _whence), __1:stdgo.GoInt64 = __tmp__._0, _err:stdgo.Error = __tmp__._1;
            if (_err != null) {
                return _err;
            };
        };
        while ((_buf.length) > (0 : stdgo.GoInt)) {
            var __tmp__ = stdgo.syscall.Syscall.read((_fd : stdgo.GoInt), _buf), _m:stdgo.GoInt = __tmp__._0, _err:stdgo.Error = __tmp__._1;
            if (_m <= (0 : stdgo.GoInt)) {
                if (_err == null) {
                    return stdgo.errors.Errors.new_(("short read" : stdgo.GoString));
                };
                return _err;
            };
            _buf = (_buf.__slice__(_m) : stdgo.Slice<stdgo.GoUInt8>);
        };
        return (null : stdgo.Error);
    }
/**
    // NewTicker returns a new Ticker containing a channel that will send
    // the current time on the channel after each tick. The period of the
    // ticks is specified by the duration argument. The ticker will adjust
    // the time interval or drop ticks to make up for slow receivers.
    // The duration d must be greater than zero; if not, NewTicker will
    // panic. Stop the ticker to release associated resources.
**/
function newTicker(_d:Duration):stdgo.Ref<Ticker> {
        if (_d <= (0i64 : stdgo.time.Time.Duration)) {
            throw stdgo.Go.toInterface(("non-positive interval for NewTicker" : stdgo.GoString));
        };
        var _c = new stdgo.Chan<stdgo.time.Time.Time>((1 : stdgo.GoInt).toBasic(), () -> ({} : stdgo.time.Time.Time));
        var _t = (stdgo.Go.setRef(({ c : _c, _r : ({ _when : _when(_d), _period : (_d : stdgo.GoInt64), _f : _sendTime, _arg : stdgo.Go.toInterface(_c) } : stdgo.time.Time.T_runtimeTimer) } : stdgo.time.Time.Ticker)) : stdgo.Ref<stdgo.time.Time.Ticker>);
        _startTimer((stdgo.Go.setRef(_t._r) : stdgo.Ref<stdgo.time.Time.T_runtimeTimer>));
        return _t;
    }
/**
    // Tick is a convenience wrapper for NewTicker providing access to the ticking
    // channel only. While Tick is useful for clients that have no need to shut down
    // the Ticker, be aware that without a way to shut it down the underlying
    // Ticker cannot be recovered by the garbage collector; it "leaks".
    // Unlike NewTicker, Tick will return nil if d <= 0.
**/
function tick(_d:Duration):stdgo.Chan<Time> {
        if (_d <= (0i64 : stdgo.time.Time.Duration)) {
            return (null : stdgo.Chan<stdgo.time.Time.Time>);
        };
        return newTicker(_d).c;
    }
/**
    // absWeekday is like Weekday but operates on an absolute time.
**/
function _absWeekday(_abs:stdgo.GoUInt64):Weekday {
        var _sec:stdgo.GoUInt64 = (_abs + (86400i64 : stdgo.GoUInt64)) % (604800i64 : stdgo.GoUInt64);
        return ((_sec : stdgo.GoInt) / (86400 : stdgo.GoInt) : Weekday);
    }
/**
    // absClock is like clock but operates on an absolute time.
**/
function _absClock(_abs:stdgo.GoUInt64):{ var _0 : stdgo.GoInt; var _1 : stdgo.GoInt; var _2 : stdgo.GoInt; } {
        var _hour:stdgo.GoInt = (0 : stdgo.GoInt), _min:stdgo.GoInt = (0 : stdgo.GoInt), _sec:stdgo.GoInt = (0 : stdgo.GoInt);
        _sec = (_abs % (86400i64 : stdgo.GoUInt64) : stdgo.GoInt);
        _hour = _sec / (3600 : stdgo.GoInt);
        _sec = _sec - (_hour * (3600 : stdgo.GoInt));
        _min = _sec / (60 : stdgo.GoInt);
        _sec = _sec - (_min * (60 : stdgo.GoInt));
        return { _0 : _hour, _1 : _min, _2 : _sec };
    }
/**
    // fmtFrac formats the fraction of v/10**prec (e.g., ".12345") into the
    // tail of buf, omitting trailing zeros. It omits the decimal
    // point too when the fraction is 0. It returns the index where the
    // output bytes begin and the value v/10**prec.
**/
function _fmtFrac(_buf:stdgo.Slice<stdgo.GoByte>, _v:stdgo.GoUInt64, _prec:stdgo.GoInt):{ var _0 : stdgo.GoInt; var _1 : stdgo.GoUInt64; } {
        var _nw:stdgo.GoInt = (0 : stdgo.GoInt), _nv:stdgo.GoUInt64 = (0 : stdgo.GoUInt64);
        var _w:stdgo.GoInt = (_buf.length);
        var _print:Bool = false;
        {
            var _i:stdgo.GoInt = (0 : stdgo.GoInt);
            stdgo.Go.cfor(_i < _prec, _i++, {
                var _digit:stdgo.GoUInt64 = _v % (10i64 : stdgo.GoUInt64);
                _print = _print || (_digit != (0i64 : stdgo.GoUInt64));
                if (_print) {
                    _w--;
                    _buf[(_w : stdgo.GoInt)] = (_digit : stdgo.GoByte) + (48 : stdgo.GoUInt8);
                };
                _v = _v / ((10i64 : stdgo.GoUInt64));
            });
        };
        if (_print) {
            _w--;
            _buf[(_w : stdgo.GoInt)] = (46 : stdgo.GoUInt8);
        };
        return { _0 : _w, _1 : _v };
    }
/**
    // fmtInt formats v into the tail of buf.
    // It returns the index where the output begins.
**/
function _fmtInt(_buf:stdgo.Slice<stdgo.GoByte>, _v:stdgo.GoUInt64):stdgo.GoInt {
        var _w:stdgo.GoInt = (_buf.length);
        if (_v == ((0i64 : stdgo.GoUInt64))) {
            _w--;
            _buf[(_w : stdgo.GoInt)] = (48 : stdgo.GoUInt8);
        } else {
            while (_v > (0i64 : stdgo.GoUInt64)) {
                _w--;
                _buf[(_w : stdgo.GoInt)] = (_v % (10i64 : stdgo.GoUInt64) : stdgo.GoByte) + (48 : stdgo.GoUInt8);
                _v = _v / ((10i64 : stdgo.GoUInt64));
            };
        };
        return _w;
    }
/**
    // lessThanHalf reports whether x+x < y but avoids overflow,
    // assuming x and y are both positive (Duration is signed).
**/
function _lessThanHalf(_x:Duration, _y:Duration):Bool {
        return ((_x : stdgo.GoUInt64) + (_x : stdgo.GoUInt64)) < (_y : stdgo.GoUInt64);
    }
/**
    // Since returns the time elapsed since t.
    // It is shorthand for time.Now().Sub(t).
**/
function since(_t:Time):Duration {
        var _now:Time = ({} : stdgo.time.Time.Time);
        if (_t._wall & (-9223372036854775808i64 : stdgo.GoUInt64) != ((0i64 : stdgo.GoUInt64))) {
            _now = (new stdgo.time.Time.Time((-9223372036854775808i64 : stdgo.GoUInt64), _runtimeNano() - _startNano, null) : stdgo.time.Time.Time);
        } else {
            _now = now()?.__copy__();
        };
        return _now.sub(_t?.__copy__());
    }
/**
    // Until returns the duration until t.
    // It is shorthand for t.Sub(time.Now()).
**/
function until(_t:Time):Duration {
        var _now:Time = ({} : stdgo.time.Time.Time);
        if (_t._wall & (-9223372036854775808i64 : stdgo.GoUInt64) != ((0i64 : stdgo.GoUInt64))) {
            _now = (new stdgo.time.Time.Time((-9223372036854775808i64 : stdgo.GoUInt64), _runtimeNano() - _startNano, null) : stdgo.time.Time.Time);
        } else {
            _now = now()?.__copy__();
        };
        return _t.sub(_now?.__copy__());
    }
/**
    // absDate is like date but operates on an absolute time.
**/
function _absDate(_abs:stdgo.GoUInt64, _full:Bool):{ var _0 : stdgo.GoInt; var _1 : Month; var _2 : stdgo.GoInt; var _3 : stdgo.GoInt; } {
        var _year:stdgo.GoInt = (0 : stdgo.GoInt), _month:Month = ((0 : stdgo.GoInt) : stdgo.time.Time.Month), _day:stdgo.GoInt = (0 : stdgo.GoInt), _yday:stdgo.GoInt = (0 : stdgo.GoInt);
        var _d:stdgo.GoUInt64 = _abs / (86400i64 : stdgo.GoUInt64);
        var _n:stdgo.GoUInt64 = _d / (146097i64 : stdgo.GoUInt64);
        var _y:stdgo.GoUInt64 = (400i64 : stdgo.GoUInt64) * _n;
        _d = _d - ((146097i64 : stdgo.GoUInt64) * _n);
        _n = _d / (36524i64 : stdgo.GoUInt64);
        _n = _n - (_n >> (2i64 : stdgo.GoUInt64));
        _y = _y + ((100i64 : stdgo.GoUInt64) * _n);
        _d = _d - ((36524i64 : stdgo.GoUInt64) * _n);
        _n = _d / (1461i64 : stdgo.GoUInt64);
        _y = _y + ((4i64 : stdgo.GoUInt64) * _n);
        _d = _d - ((1461i64 : stdgo.GoUInt64) * _n);
        _n = _d / (365i64 : stdgo.GoUInt64);
        _n = _n - (_n >> (2i64 : stdgo.GoUInt64));
        _y = _y + (_n);
        _d = _d - ((365i64 : stdgo.GoUInt64) * _n);
        _year = ((_y : stdgo.GoInt64) + (-292277022399i64 : stdgo.GoInt64) : stdgo.GoInt);
        _yday = (_d : stdgo.GoInt);
        if (!_full) {
            return { _0 : _year, _1 : _month, _2 : _day, _3 : _yday };
        };
        _day = _yday;
        if (_isLeap(_year)) {
            if (_day > (59 : stdgo.GoInt)) {
                _day--;
            } else if (_day == ((59 : stdgo.GoInt))) {
                _month = (2 : stdgo.time.Time.Month);
                _day = (29 : stdgo.GoInt);
                return { _0 : _year, _1 : _month, _2 : _day, _3 : _yday };
            };
        };
        _month = (_day / (31 : stdgo.GoInt) : Month);
        var _end:stdgo.GoInt = (_daysBefore[(_month + (1 : stdgo.time.Time.Month) : stdgo.GoInt)] : stdgo.GoInt);
        var _begin:stdgo.GoInt = (0 : stdgo.GoInt);
        if (_day >= _end) {
            _month++;
            _begin = _end;
        } else {
            _begin = (_daysBefore[(_month : stdgo.GoInt)] : stdgo.GoInt);
        };
        _month++;
        _day = (_day - _begin) + (1 : stdgo.GoInt);
        return { _0 : _year, _1 : _month, _2 : _day, _3 : _yday };
    }
function _daysIn(_m:Month, _year:stdgo.GoInt):stdgo.GoInt {
        if ((_m == (2 : stdgo.time.Time.Month)) && _isLeap(_year)) {
            return (29 : stdgo.GoInt);
        };
        return (_daysBefore[(_m : stdgo.GoInt)] - _daysBefore[(_m - (1 : stdgo.time.Time.Month) : stdgo.GoInt)] : stdgo.GoInt);
    }
/**
    // daysSinceEpoch takes a year and returns the number of days from
    // the absolute epoch to the start of that year.
    // This is basically (year - zeroYear) * 365, but accounting for leap days.
**/
function _daysSinceEpoch(_year:stdgo.GoInt):stdgo.GoUInt64 {
        var _y:stdgo.GoUInt64 = ((_year : stdgo.GoInt64) - (-292277022399i64 : stdgo.GoInt64) : stdgo.GoUInt64);
        var _n:stdgo.GoUInt64 = _y / (400i64 : stdgo.GoUInt64);
        _y = _y - ((400i64 : stdgo.GoUInt64) * _n);
        var _d:stdgo.GoUInt64 = (146097i64 : stdgo.GoUInt64) * _n;
        _n = _y / (100i64 : stdgo.GoUInt64);
        _y = _y - ((100i64 : stdgo.GoUInt64) * _n);
        _d = _d + ((36524i64 : stdgo.GoUInt64) * _n);
        _n = _y / (4i64 : stdgo.GoUInt64);
        _y = _y - ((4i64 : stdgo.GoUInt64) * _n);
        _d = _d + ((1461i64 : stdgo.GoUInt64) * _n);
        _n = _y;
        _d = _d + ((365i64 : stdgo.GoUInt64) * _n);
        return _d;
    }
/**
    // Provided by package runtime.
**/
function _now():{ var _0 : stdgo.GoInt64; var _1 : stdgo.GoInt32; var _2 : stdgo.GoInt64; } {
        final n = _runtimeNano();
        return { _0 : n / 1000000000, _1 : n % 1000000000, _2 : n };
    }
/**
    // runtimeNano returns the current value of the runtime clock in nanoseconds.
    //
    //go:linkname runtimeNano runtime.nanotime
**/
function _runtimeNano():stdgo.GoInt64 {
        final x = ((Sys.time() * 1000000 * 1000) - Date.now().getTimezoneOffset() * 60000000000 : stdgo.GoInt64);
        return x;
    }
/**
    // Now returns the current local time.
**/
function now():Time {
        var __tmp__ = _now(), _sec:stdgo.GoInt64 = __tmp__._0, _nsec:stdgo.GoInt32 = __tmp__._1, _mono:stdgo.GoInt64 = __tmp__._2;
        _mono = _mono - (_startNano);
        _sec = _sec + ((2682288000i64 : stdgo.GoInt64));
        if ((_sec : stdgo.GoUInt64) >> (33i64 : stdgo.GoUInt64) != ((0i64 : stdgo.GoUInt64))) {
            return (new stdgo.time.Time.Time((_nsec : stdgo.GoUInt64), _sec + (59453308800i64 : stdgo.GoInt64), local) : stdgo.time.Time.Time);
        };
        return (new stdgo.time.Time.Time(((-9223372036854775808i64 : stdgo.GoUInt64) | ((_sec : stdgo.GoUInt64) << (30i64 : stdgo.GoUInt64))) | (_nsec : stdgo.GoUInt64), _mono, local) : stdgo.time.Time.Time);
    }
function _unixTime(_sec:stdgo.GoInt64, _nsec:stdgo.GoInt32):Time {
        return (new stdgo.time.Time.Time((_nsec : stdgo.GoUInt64), _sec + (62135596800i64 : stdgo.GoInt64), local) : stdgo.time.Time.Time);
    }
/**
    // Unix returns the local Time corresponding to the given Unix time,
    // sec seconds and nsec nanoseconds since January 1, 1970 UTC.
    // It is valid to pass nsec outside the range [0, 999999999].
    // Not all sec values have a corresponding time value. One such
    // value is 1<<63-1 (the largest int64 value).
**/
function unix(_sec:stdgo.GoInt64, _nsec:stdgo.GoInt64):Time {
        if ((_nsec < (0i64 : stdgo.GoInt64)) || (_nsec >= (1000000000i64 : stdgo.GoInt64))) {
            var _n:stdgo.GoInt64 = _nsec / (1000000000i64 : stdgo.GoInt64);
            _sec = _sec + (_n);
            _nsec = _nsec - (_n * (1000000000i64 : stdgo.GoInt64));
            if (_nsec < (0i64 : stdgo.GoInt64)) {
                _nsec = _nsec + ((1000000000i64 : stdgo.GoInt64));
                _sec--;
            };
        };
        return _unixTime(_sec, (_nsec : stdgo.GoInt32))?.__copy__();
    }
/**
    // UnixMilli returns the local Time corresponding to the given Unix time,
    // msec milliseconds since January 1, 1970 UTC.
**/
function unixMilli(_msec:stdgo.GoInt64):Time {
        return unix(_msec / (1000i64 : stdgo.GoInt64), (_msec % (1000i64 : stdgo.GoInt64)) * (1000000i64 : stdgo.GoInt64))?.__copy__();
    }
/**
    // UnixMicro returns the local Time corresponding to the given Unix time,
    // usec microseconds since January 1, 1970 UTC.
**/
function unixMicro(_usec:stdgo.GoInt64):Time {
        return unix(_usec / (1000000i64 : stdgo.GoInt64), (_usec % (1000000i64 : stdgo.GoInt64)) * (1000i64 : stdgo.GoInt64))?.__copy__();
    }
function _isLeap(_year:stdgo.GoInt):Bool {
        return ((_year % (4 : stdgo.GoInt)) == (0 : stdgo.GoInt)) && (((_year % (100 : stdgo.GoInt)) != (0 : stdgo.GoInt)) || ((_year % (400 : stdgo.GoInt)) == (0 : stdgo.GoInt)));
    }
/**
    // norm returns nhi, nlo such that
    //
    //	hi * base + lo == nhi * base + nlo
    //	0 <= nlo < base
**/
function _norm(_hi:stdgo.GoInt, _lo:stdgo.GoInt, _base:stdgo.GoInt):{ var _0 : stdgo.GoInt; var _1 : stdgo.GoInt; } {
        var _nhi:stdgo.GoInt = (0 : stdgo.GoInt), _nlo:stdgo.GoInt = (0 : stdgo.GoInt);
        if (_lo < (0 : stdgo.GoInt)) {
            var _n:stdgo.GoInt = ((-_lo - (1 : stdgo.GoInt)) / _base) + (1 : stdgo.GoInt);
            _hi = _hi - (_n);
            _lo = _lo + (_n * _base);
        };
        if (_lo >= _base) {
            var _n:stdgo.GoInt = _lo / _base;
            _hi = _hi + (_n);
            _lo = _lo - (_n * _base);
        };
        return { _0 : _hi, _1 : _lo };
    }
/**
    // Date returns the Time corresponding to
    //
    //	yyyy-mm-dd hh:mm:ss + nsec nanoseconds
    //
    // in the appropriate zone for that time in the given location.
    //
    // The month, day, hour, min, sec, and nsec values may be outside
    // their usual ranges and will be normalized during the conversion.
    // For example, October 32 converts to November 1.
    //
    // A daylight savings time transition skips or repeats times.
    // For example, in the United States, March 13, 2011 2:15am never occurred,
    // while November 6, 2011 1:15am occurred twice. In such cases, the
    // choice of time zone, and therefore the time, is not well-defined.
    // Date returns a time that is correct in one of the two zones involved
    // in the transition, but it does not guarantee which.
    //
    // Date panics if loc is nil.
**/
function date(_year:stdgo.GoInt, _month:Month, _day:stdgo.GoInt, _hour:stdgo.GoInt, _min:stdgo.GoInt, _sec:stdgo.GoInt, _nsec:stdgo.GoInt, _loc:stdgo.Ref<Location>):Time {
        if (_loc == null || (_loc : Dynamic).__nil__) {
            throw stdgo.Go.toInterface(("time: missing Location in call to Date" : stdgo.GoString));
        };
        var _m:stdgo.GoInt = (_month : stdgo.GoInt) - (1 : stdgo.GoInt);
        {
            var __tmp__ = _norm(_year, _m, (12 : stdgo.GoInt));
            _year = __tmp__._0;
            _m = __tmp__._1;
        };
        _month = (_m : Month) + (1 : stdgo.time.Time.Month);
        {
            var __tmp__ = _norm(_sec, _nsec, (1000000000 : stdgo.GoInt));
            _sec = __tmp__._0;
            _nsec = __tmp__._1;
        };
        {
            var __tmp__ = _norm(_min, _sec, (60 : stdgo.GoInt));
            _min = __tmp__._0;
            _sec = __tmp__._1;
        };
        {
            var __tmp__ = _norm(_hour, _min, (60 : stdgo.GoInt));
            _hour = __tmp__._0;
            _min = __tmp__._1;
        };
        {
            var __tmp__ = _norm(_day, _hour, (24 : stdgo.GoInt));
            _day = __tmp__._0;
            _hour = __tmp__._1;
        };
        var _d:stdgo.GoUInt64 = _daysSinceEpoch(_year);
        _d = _d + ((_daysBefore[(_month - (1 : stdgo.time.Time.Month) : stdgo.GoInt)] : stdgo.GoUInt64));
        if (_isLeap(_year) && (_month >= (3 : stdgo.time.Time.Month))) {
            _d++;
        };
        _d = _d + ((_day - (1 : stdgo.GoInt) : stdgo.GoUInt64));
        var _abs:stdgo.GoUInt64 = _d * (86400i64 : stdgo.GoUInt64);
        _abs = _abs + ((((_hour * (3600 : stdgo.GoInt)) + (_min * (60 : stdgo.GoInt))) + _sec : stdgo.GoUInt64));
        var _unix:stdgo.GoInt64 = (_abs : stdgo.GoInt64) + (-9223372028715321600i64 : stdgo.GoInt64);
        var __tmp__ = _loc._lookup(_unix), __1:stdgo.GoString = __tmp__._0, _offset:stdgo.GoInt = __tmp__._1, _start:stdgo.GoInt64 = __tmp__._2, _end:stdgo.GoInt64 = __tmp__._3, __2:Bool = __tmp__._4;
        if (_offset != ((0 : stdgo.GoInt))) {
            var _utc:stdgo.GoInt64 = _unix - (_offset : stdgo.GoInt64);
            if ((_utc < _start) || (_utc >= _end)) {
                {
                    var __tmp__ = _loc._lookup(_utc);
                    _offset = __tmp__._1;
                };
            };
            _unix = _unix - ((_offset : stdgo.GoInt64));
        };
        var _t:stdgo.time.Time.Time = _unixTime(_unix, (_nsec : stdgo.GoInt32))?.__copy__();
        _t._setLoc(_loc);
        return _t?.__copy__();
    }
/**
    // div divides t by d and returns the quotient parity and remainder.
    // We don't use the quotient parity anymore (round half up instead of round to even)
    // but it's still here in case we change our minds.
**/
function _div(_t:Time, _d:Duration):{ var _0 : stdgo.GoInt; var _1 : Duration; } {
        var _qmod2:stdgo.GoInt = (0 : stdgo.GoInt), _r:Duration = ((0 : stdgo.GoInt64) : stdgo.time.Time.Duration);
        var _neg:Bool = false;
        var _nsec:stdgo.GoInt32 = _t._nsec();
        var _sec:stdgo.GoInt64 = _t._sec();
        if (_sec < (0i64 : stdgo.GoInt64)) {
            _neg = true;
            _sec = -_sec;
            _nsec = -_nsec;
            if (_nsec < (0 : stdgo.GoInt32)) {
                _nsec = _nsec + ((1000000000 : stdgo.GoInt32));
                _sec--;
            };
        };
        {
            var __switchIndex__ = -1;
            var __run__ = true;
            while (__run__) {
                __run__ = false;
                if ((_d < (1000000000i64 : stdgo.time.Time.Duration)) && (((1000000000i64 : stdgo.time.Time.Duration) % (_d + _d)) == (0i64 : stdgo.time.Time.Duration))) {
                    _qmod2 = (_nsec / (_d : stdgo.GoInt32) : stdgo.GoInt) & (1 : stdgo.GoInt);
                    _r = (_nsec % (_d : stdgo.GoInt32) : Duration);
                    break;
                } else if (_d % (1000000000i64 : stdgo.time.Time.Duration) == ((0i64 : stdgo.time.Time.Duration))) {
                    var _d1:stdgo.GoInt64 = (_d / (1000000000i64 : stdgo.time.Time.Duration) : stdgo.GoInt64);
                    _qmod2 = (_sec / _d1 : stdgo.GoInt) & (1 : stdgo.GoInt);
                    _r = ((_sec % _d1 : Duration) * (1000000000i64 : stdgo.time.Time.Duration)) + (_nsec : Duration);
                    break;
                } else {
                    var _sec:stdgo.GoUInt64 = (_sec : stdgo.GoUInt64);
                    var _tmp:stdgo.GoUInt64 = (_sec >> (32i64 : stdgo.GoUInt64)) * (1000000000i64 : stdgo.GoUInt64);
                    var _u1:stdgo.GoUInt64 = _tmp >> (32i64 : stdgo.GoUInt64);
                    var _u0:stdgo.GoUInt64 = _tmp << (32i64 : stdgo.GoUInt64);
                    _tmp = (_sec & (4294967295i64 : stdgo.GoUInt64)) * (1000000000i64 : stdgo.GoUInt64);
                    var __0:stdgo.GoUInt64 = _u0, __1:stdgo.GoUInt64 = _u0 + _tmp, _u0:stdgo.GoUInt64 = __1, _u0x:stdgo.GoUInt64 = __0;
                    if (_u0 < _u0x) {
                        _u1++;
                    };
                    {
                        final __tmp__0 = _u0;
                        final __tmp__1 = _u0 + (_nsec : stdgo.GoUInt64);
                        _u0x = __tmp__0;
                        _u0 = __tmp__1;
                    };
                    if (_u0 < _u0x) {
                        _u1++;
                    };
                    var _d1:stdgo.GoUInt64 = (_d : stdgo.GoUInt64);
                    while (_d1 >> (63i64 : stdgo.GoUInt64) != ((1i64 : stdgo.GoUInt64))) {
                        _d1 = _d1 << ((1i64 : stdgo.GoUInt64));
                    };
                    var _d0:stdgo.GoUInt64 = (0i64 : stdgo.GoUInt64);
                    while (true) {
                        _qmod2 = (0 : stdgo.GoInt);
                        if ((_u1 > _d1) || ((_u1 == _d1) && (_u0 >= _d0))) {
                            _qmod2 = (1 : stdgo.GoInt);
                            {
                                final __tmp__0 = _u0;
                                final __tmp__1 = _u0 - _d0;
                                _u0x = __tmp__0;
                                _u0 = __tmp__1;
                            };
                            if (_u0 > _u0x) {
                                _u1--;
                            };
                            _u1 = _u1 - (_d1);
                        };
                        if ((_d1 == (0i64 : stdgo.GoUInt64)) && (_d0 == (_d : stdgo.GoUInt64))) {
                            break;
                        };
                        _d0 = _d0 >> ((1i64 : stdgo.GoUInt64));
                        _d0 = _d0 | ((_d1 & (1i64 : stdgo.GoUInt64)) << (63i64 : stdgo.GoUInt64));
                        _d1 = _d1 >> ((1i64 : stdgo.GoUInt64));
                    };
                    _r = (_u0 : Duration);
                };
                break;
            };
        };
        if (_neg && (_r != (0i64 : stdgo.time.Time.Duration))) {
            _qmod2 = _qmod2 ^ ((1 : stdgo.GoInt));
            _r = _d - _r;
        };
        return { _0 : _qmod2, _1 : _r };
    }
/**
    // FixedZone returns a Location that always uses
    // the given zone name and offset (seconds east of UTC).
**/
function fixedZone(_name:stdgo.GoString, _offset:stdgo.GoInt):stdgo.Ref<Location> {
        {};
        {};
        var _hour:stdgo.GoInt = (_offset / (60 : stdgo.GoInt)) / (60 : stdgo.GoInt);
        if ((((_name == stdgo.Go.str()) && ((-12 : stdgo.GoInt) <= _hour)) && (_hour <= (14 : stdgo.GoInt))) && (((_hour * (60 : stdgo.GoInt)) * (60 : stdgo.GoInt)) == _offset)) {
            _unnamedFixedZonesOnce.do_(function():Void {
                _unnamedFixedZones = new stdgo.Slice<stdgo.Ref<stdgo.time.Time.Location>>((27 : stdgo.GoInt).toBasic(), 0);
                {
                    var _hr:stdgo.GoInt = (-12 : stdgo.GoInt);
                    stdgo.Go.cfor(_hr <= (14 : stdgo.GoInt), _hr++, {
                        _unnamedFixedZones[(_hr + (12 : stdgo.GoInt) : stdgo.GoInt)] = _fixedZone(stdgo.Go.str()?.__copy__(), (_hr * (60 : stdgo.GoInt)) * (60 : stdgo.GoInt));
                    });
                };
            });
            return _unnamedFixedZones[(_hour + (12 : stdgo.GoInt) : stdgo.GoInt)];
        };
        return _fixedZone(_name?.__copy__(), _offset);
    }
function _fixedZone(_name:stdgo.GoString, _offset:stdgo.GoInt):stdgo.Ref<Location> {
        var _l = (stdgo.Go.setRef(({ _name : _name?.__copy__(), _zone : (new stdgo.Slice<stdgo.time.Time.T_zone>(1, 1, (new stdgo.time.Time.T_zone(_name?.__copy__(), _offset, false) : stdgo.time.Time.T_zone)) : stdgo.Slice<stdgo.time.Time.T_zone>), _tx : (new stdgo.Slice<stdgo.time.Time.T_zoneTrans>(1, 1, (new stdgo.time.Time.T_zoneTrans((-9223372036854775808i64 : stdgo.GoInt64), (0 : stdgo.GoUInt8), false, false) : stdgo.time.Time.T_zoneTrans)) : stdgo.Slice<stdgo.time.Time.T_zoneTrans>), _cacheStart : (-9223372036854775808i64 : stdgo.GoInt64), _cacheEnd : (9223372036854775807i64 : stdgo.GoInt64) } : stdgo.time.Time.Location)) : stdgo.Ref<stdgo.time.Time.Location>);
        _l._cacheZone = (stdgo.Go.setRef(_l._zone[(0 : stdgo.GoInt)]) : stdgo.Ref<stdgo.time.Time.T_zone>);
        return _l;
    }
/**
    // tzset takes a timezone string like the one found in the TZ environment
    // variable, the time of the last time zone transition expressed as seconds
    // since January 1, 1970 00:00:00 UTC, and a time expressed the same way.
    // We call this a tzset string since in C the function tzset reads TZ.
    // The return values are as for lookup, plus ok which reports whether the
    // parse succeeded.
**/
function _tzset(_s:stdgo.GoString, _lastTxSec:stdgo.GoInt64, _sec:stdgo.GoInt64):{ var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoInt64; var _3 : stdgo.GoInt64; var _4 : Bool; var _5 : Bool; } {
        var _name:stdgo.GoString = ("" : stdgo.GoString), _offset:stdgo.GoInt = (0 : stdgo.GoInt), _start:stdgo.GoInt64 = (0 : stdgo.GoInt64), _end:stdgo.GoInt64 = (0 : stdgo.GoInt64), _isDST:Bool = false, _ok:Bool = false;
        var __0:stdgo.GoString = ("" : stdgo.GoString), __1:stdgo.GoString = ("" : stdgo.GoString), __2:stdgo.GoInt = (0 : stdgo.GoInt), __3:stdgo.GoInt = (0 : stdgo.GoInt), _dstOffset:stdgo.GoInt = __3, _stdOffset:stdgo.GoInt = __2, _dstName:stdgo.GoString = __1, _stdName:stdgo.GoString = __0;
        {
            var __tmp__ = _tzsetName(_s?.__copy__());
            _stdName = __tmp__._0?.__copy__();
            _s = __tmp__._1?.__copy__();
            _ok = __tmp__._2;
        };
        if (_ok) {
            {
                var __tmp__ = _tzsetOffset(_s?.__copy__());
                _stdOffset = __tmp__._0;
                _s = __tmp__._1?.__copy__();
                _ok = __tmp__._2;
            };
        };
        if (!_ok) {
            return { _0 : stdgo.Go.str()?.__copy__(), _1 : (0 : stdgo.GoInt), _2 : (0i64 : stdgo.GoInt64), _3 : (0i64 : stdgo.GoInt64), _4 : false, _5 : false };
        };
        _stdOffset = -_stdOffset;
        if ((_s.length == (0 : stdgo.GoInt)) || (_s[(0 : stdgo.GoInt)] == (44 : stdgo.GoUInt8))) {
            return { _0 : _stdName?.__copy__(), _1 : _stdOffset, _2 : _lastTxSec, _3 : (9223372036854775807i64 : stdgo.GoInt64), _4 : false, _5 : true };
        };
        {
            var __tmp__ = _tzsetName(_s?.__copy__());
            _dstName = __tmp__._0?.__copy__();
            _s = __tmp__._1?.__copy__();
            _ok = __tmp__._2;
        };
        if (_ok) {
            if ((_s.length == (0 : stdgo.GoInt)) || (_s[(0 : stdgo.GoInt)] == (44 : stdgo.GoUInt8))) {
                _dstOffset = _stdOffset + (3600 : stdgo.GoInt);
            } else {
                {
                    var __tmp__ = _tzsetOffset(_s?.__copy__());
                    _dstOffset = __tmp__._0;
                    _s = __tmp__._1?.__copy__();
                    _ok = __tmp__._2;
                };
                _dstOffset = -_dstOffset;
            };
        };
        if (!_ok) {
            return { _0 : stdgo.Go.str()?.__copy__(), _1 : (0 : stdgo.GoInt), _2 : (0i64 : stdgo.GoInt64), _3 : (0i64 : stdgo.GoInt64), _4 : false, _5 : false };
        };
        if ((_s.length) == ((0 : stdgo.GoInt))) {
            _s = (",M3.2.0,M11.1.0" : stdgo.GoString);
        };
        if ((_s[(0 : stdgo.GoInt)] != (44 : stdgo.GoUInt8)) && (_s[(0 : stdgo.GoInt)] != (59 : stdgo.GoUInt8))) {
            return { _0 : stdgo.Go.str()?.__copy__(), _1 : (0 : stdgo.GoInt), _2 : (0i64 : stdgo.GoInt64), _3 : (0i64 : stdgo.GoInt64), _4 : false, _5 : false };
        };
        _s = (_s.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
        var __0:T_rule = ({} : stdgo.time.Time.T_rule), __1:T_rule = ({} : stdgo.time.Time.T_rule), _endRule:T_rule = __1, _startRule:T_rule = __0;
        {
            var __tmp__ = _tzsetRule(_s?.__copy__());
            _startRule = __tmp__._0?.__copy__();
            _s = __tmp__._1?.__copy__();
            _ok = __tmp__._2;
        };
        if ((!_ok || (_s.length == (0 : stdgo.GoInt))) || (_s[(0 : stdgo.GoInt)] != (44 : stdgo.GoUInt8))) {
            return { _0 : stdgo.Go.str()?.__copy__(), _1 : (0 : stdgo.GoInt), _2 : (0i64 : stdgo.GoInt64), _3 : (0i64 : stdgo.GoInt64), _4 : false, _5 : false };
        };
        _s = (_s.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
        {
            var __tmp__ = _tzsetRule(_s?.__copy__());
            _endRule = __tmp__._0?.__copy__();
            _s = __tmp__._1?.__copy__();
            _ok = __tmp__._2;
        };
        if (!_ok || (_s.length > (0 : stdgo.GoInt))) {
            return { _0 : stdgo.Go.str()?.__copy__(), _1 : (0 : stdgo.GoInt), _2 : (0i64 : stdgo.GoInt64), _3 : (0i64 : stdgo.GoInt64), _4 : false, _5 : false };
        };
        var __tmp__ = _absDate(((_sec + (62135596800i64 : stdgo.GoInt64)) + (9223371966579724800i64 : stdgo.GoInt64) : stdgo.GoUInt64), false), _year:stdgo.GoInt = __tmp__._0, __1:stdgo.time.Time.Month = __tmp__._1, __2:stdgo.GoInt = __tmp__._2, _yday:stdgo.GoInt = __tmp__._3;
        var _ysec:stdgo.GoInt64 = (_yday * (86400 : stdgo.GoInt) : stdgo.GoInt64) + (_sec % (86400i64 : stdgo.GoInt64));
        var _d:stdgo.GoUInt64 = _daysSinceEpoch(_year);
        var _abs:stdgo.GoInt64 = (_d * (86400i64 : stdgo.GoUInt64) : stdgo.GoInt64);
        _abs = _abs + ((-9223372028715321600i64 : stdgo.GoInt64));
        var _startSec:stdgo.GoInt64 = (_tzruleTime(_year, _startRule?.__copy__(), _stdOffset) : stdgo.GoInt64);
        var _endSec:stdgo.GoInt64 = (_tzruleTime(_year, _endRule?.__copy__(), _dstOffset) : stdgo.GoInt64);
        var __0:Bool = true, __1:Bool = false, _stdIsDST:Bool = __1, _dstIsDST:Bool = __0;
        if (_endSec < _startSec) {
            {
                final __tmp__0 = _endSec;
                final __tmp__1 = _startSec;
                _startSec = __tmp__0;
                _endSec = __tmp__1;
            };
            {
                final __tmp__0 = _dstName?.__copy__();
                final __tmp__1 = _stdName?.__copy__();
                _stdName = __tmp__0;
                _dstName = __tmp__1;
            };
            {
                final __tmp__0 = _dstOffset;
                final __tmp__1 = _stdOffset;
                _stdOffset = __tmp__0;
                _dstOffset = __tmp__1;
            };
            {
                final __tmp__0 = _dstIsDST;
                final __tmp__1 = _stdIsDST;
                _stdIsDST = __tmp__0;
                _dstIsDST = __tmp__1;
            };
        };
        if (_ysec < _startSec) {
            return { _0 : _stdName?.__copy__(), _1 : _stdOffset, _2 : _abs, _3 : _startSec + _abs, _4 : _stdIsDST, _5 : true };
        } else if (_ysec >= _endSec) {
            return { _0 : _stdName?.__copy__(), _1 : _stdOffset, _2 : _endSec + _abs, _3 : _abs + (31536000i64 : stdgo.GoInt64), _4 : _stdIsDST, _5 : true };
        } else {
            return { _0 : _dstName?.__copy__(), _1 : _dstOffset, _2 : _startSec + _abs, _3 : _endSec + _abs, _4 : _dstIsDST, _5 : true };
        };
    }
/**
    // tzsetName returns the timezone name at the start of the tzset string s,
    // and the remainder of s, and reports whether the parsing is OK.
**/
function _tzsetName(_s:stdgo.GoString):{ var _0 : stdgo.GoString; var _1 : stdgo.GoString; var _2 : Bool; } {
        if ((_s.length) == ((0 : stdgo.GoInt))) {
            return { _0 : stdgo.Go.str()?.__copy__(), _1 : stdgo.Go.str()?.__copy__(), _2 : false };
        };
        if (_s[(0 : stdgo.GoInt)] != ((60 : stdgo.GoUInt8))) {
            for (_i => _r in _s) {
                {
                    final __value__ = _r;
                    if (__value__ == ((48 : stdgo.GoInt32)) || __value__ == ((49 : stdgo.GoInt32)) || __value__ == ((50 : stdgo.GoInt32)) || __value__ == ((51 : stdgo.GoInt32)) || __value__ == ((52 : stdgo.GoInt32)) || __value__ == ((53 : stdgo.GoInt32)) || __value__ == ((54 : stdgo.GoInt32)) || __value__ == ((55 : stdgo.GoInt32)) || __value__ == ((56 : stdgo.GoInt32)) || __value__ == ((57 : stdgo.GoInt32)) || __value__ == ((44 : stdgo.GoInt32)) || __value__ == ((45 : stdgo.GoInt32)) || __value__ == ((43 : stdgo.GoInt32))) {
                        if (_i < (3 : stdgo.GoInt)) {
                            return { _0 : stdgo.Go.str()?.__copy__(), _1 : stdgo.Go.str()?.__copy__(), _2 : false };
                        };
                        return { _0 : (_s.__slice__(0, _i) : stdgo.GoString)?.__copy__(), _1 : (_s.__slice__(_i) : stdgo.GoString)?.__copy__(), _2 : true };
                    };
                };
            };
            if ((_s.length) < (3 : stdgo.GoInt)) {
                return { _0 : stdgo.Go.str()?.__copy__(), _1 : stdgo.Go.str()?.__copy__(), _2 : false };
            };
            return { _0 : _s?.__copy__(), _1 : stdgo.Go.str()?.__copy__(), _2 : true };
        } else {
            for (_i => _r in _s) {
                if (_r == ((62 : stdgo.GoInt32))) {
                    return { _0 : (_s.__slice__((1 : stdgo.GoInt), _i) : stdgo.GoString)?.__copy__(), _1 : (_s.__slice__(_i + (1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__(), _2 : true };
                };
            };
            return { _0 : stdgo.Go.str()?.__copy__(), _1 : stdgo.Go.str()?.__copy__(), _2 : false };
        };
    }
/**
    // tzsetOffset returns the timezone offset at the start of the tzset string s,
    // and the remainder of s, and reports whether the parsing is OK.
    // The timezone offset is returned as a number of seconds.
**/
function _tzsetOffset(_s:stdgo.GoString):{ var _0 : stdgo.GoInt; var _1 : stdgo.GoString; var _2 : Bool; } {
        var _offset:stdgo.GoInt = (0 : stdgo.GoInt), _rest:stdgo.GoString = ("" : stdgo.GoString), _ok:Bool = false;
        if ((_s.length) == ((0 : stdgo.GoInt))) {
            return { _0 : (0 : stdgo.GoInt), _1 : stdgo.Go.str()?.__copy__(), _2 : false };
        };
        var _neg:Bool = false;
        if (_s[(0 : stdgo.GoInt)] == ((43 : stdgo.GoUInt8))) {
            _s = (_s.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
        } else if (_s[(0 : stdgo.GoInt)] == ((45 : stdgo.GoUInt8))) {
            _s = (_s.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
            _neg = true;
        };
        var _hours:stdgo.GoInt = (0 : stdgo.GoInt);
        {
            var __tmp__ = _tzsetNum(_s?.__copy__(), (0 : stdgo.GoInt), (168 : stdgo.GoInt));
            _hours = __tmp__._0;
            _s = __tmp__._1?.__copy__();
            _ok = __tmp__._2;
        };
        if (!_ok) {
            return { _0 : (0 : stdgo.GoInt), _1 : stdgo.Go.str()?.__copy__(), _2 : false };
        };
        var _off:stdgo.GoInt = _hours * (3600 : stdgo.GoInt);
        if ((_s.length == (0 : stdgo.GoInt)) || (_s[(0 : stdgo.GoInt)] != (58 : stdgo.GoUInt8))) {
            if (_neg) {
                _off = -_off;
            };
            return { _0 : _off, _1 : _s?.__copy__(), _2 : true };
        };
        var _mins:stdgo.GoInt = (0 : stdgo.GoInt);
        {
            var __tmp__ = _tzsetNum((_s.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__(), (0 : stdgo.GoInt), (59 : stdgo.GoInt));
            _mins = __tmp__._0;
            _s = __tmp__._1?.__copy__();
            _ok = __tmp__._2;
        };
        if (!_ok) {
            return { _0 : (0 : stdgo.GoInt), _1 : stdgo.Go.str()?.__copy__(), _2 : false };
        };
        _off = _off + (_mins * (60 : stdgo.GoInt));
        if ((_s.length == (0 : stdgo.GoInt)) || (_s[(0 : stdgo.GoInt)] != (58 : stdgo.GoUInt8))) {
            if (_neg) {
                _off = -_off;
            };
            return { _0 : _off, _1 : _s?.__copy__(), _2 : true };
        };
        var _secs:stdgo.GoInt = (0 : stdgo.GoInt);
        {
            var __tmp__ = _tzsetNum((_s.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__(), (0 : stdgo.GoInt), (59 : stdgo.GoInt));
            _secs = __tmp__._0;
            _s = __tmp__._1?.__copy__();
            _ok = __tmp__._2;
        };
        if (!_ok) {
            return { _0 : (0 : stdgo.GoInt), _1 : stdgo.Go.str()?.__copy__(), _2 : false };
        };
        _off = _off + (_secs);
        if (_neg) {
            _off = -_off;
        };
        return { _0 : _off, _1 : _s?.__copy__(), _2 : true };
    }
/**
    // tzsetRule parses a rule from a tzset string.
    // It returns the rule, and the remainder of the string, and reports success.
**/
function _tzsetRule(_s:stdgo.GoString):{ var _0 : T_rule; var _1 : stdgo.GoString; var _2 : Bool; } {
        var _r:T_rule = ({} : stdgo.time.Time.T_rule);
        if ((_s.length) == ((0 : stdgo.GoInt))) {
            return { _0 : (new stdgo.time.Time.T_rule() : stdgo.time.Time.T_rule), _1 : stdgo.Go.str()?.__copy__(), _2 : false };
        };
        var _ok:Bool = false;
        if (_s[(0 : stdgo.GoInt)] == ((74 : stdgo.GoUInt8))) {
            var _jday:stdgo.GoInt = (0 : stdgo.GoInt);
            {
                var __tmp__ = _tzsetNum((_s.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__(), (1 : stdgo.GoInt), (365 : stdgo.GoInt));
                _jday = __tmp__._0;
                _s = __tmp__._1?.__copy__();
                _ok = __tmp__._2;
            };
            if (!_ok) {
                return { _0 : (new stdgo.time.Time.T_rule() : stdgo.time.Time.T_rule), _1 : stdgo.Go.str()?.__copy__(), _2 : false };
            };
            _r._kind = (0 : stdgo.time.Time.T_ruleKind);
            _r._day = _jday;
        } else if (_s[(0 : stdgo.GoInt)] == ((77 : stdgo.GoUInt8))) {
            var _mon:stdgo.GoInt = (0 : stdgo.GoInt);
            {
                var __tmp__ = _tzsetNum((_s.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__(), (1 : stdgo.GoInt), (12 : stdgo.GoInt));
                _mon = __tmp__._0;
                _s = __tmp__._1?.__copy__();
                _ok = __tmp__._2;
            };
            if ((!_ok || (_s.length == (0 : stdgo.GoInt))) || (_s[(0 : stdgo.GoInt)] != (46 : stdgo.GoUInt8))) {
                return { _0 : (new stdgo.time.Time.T_rule() : stdgo.time.Time.T_rule), _1 : stdgo.Go.str()?.__copy__(), _2 : false };
            };
            var _week:stdgo.GoInt = (0 : stdgo.GoInt);
            {
                var __tmp__ = _tzsetNum((_s.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__(), (1 : stdgo.GoInt), (5 : stdgo.GoInt));
                _week = __tmp__._0;
                _s = __tmp__._1?.__copy__();
                _ok = __tmp__._2;
            };
            if ((!_ok || (_s.length == (0 : stdgo.GoInt))) || (_s[(0 : stdgo.GoInt)] != (46 : stdgo.GoUInt8))) {
                return { _0 : (new stdgo.time.Time.T_rule() : stdgo.time.Time.T_rule), _1 : stdgo.Go.str()?.__copy__(), _2 : false };
            };
            var _day:stdgo.GoInt = (0 : stdgo.GoInt);
            {
                var __tmp__ = _tzsetNum((_s.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__(), (0 : stdgo.GoInt), (6 : stdgo.GoInt));
                _day = __tmp__._0;
                _s = __tmp__._1?.__copy__();
                _ok = __tmp__._2;
            };
            if (!_ok) {
                return { _0 : (new stdgo.time.Time.T_rule() : stdgo.time.Time.T_rule), _1 : stdgo.Go.str()?.__copy__(), _2 : false };
            };
            _r._kind = (2 : stdgo.time.Time.T_ruleKind);
            _r._day = _day;
            _r._week = _week;
            _r._mon = _mon;
        } else {
            var _day:stdgo.GoInt = (0 : stdgo.GoInt);
            {
                var __tmp__ = _tzsetNum(_s?.__copy__(), (0 : stdgo.GoInt), (365 : stdgo.GoInt));
                _day = __tmp__._0;
                _s = __tmp__._1?.__copy__();
                _ok = __tmp__._2;
            };
            if (!_ok) {
                return { _0 : (new stdgo.time.Time.T_rule() : stdgo.time.Time.T_rule), _1 : stdgo.Go.str()?.__copy__(), _2 : false };
            };
            _r._kind = (1 : stdgo.time.Time.T_ruleKind);
            _r._day = _day;
        };
        if ((_s.length == (0 : stdgo.GoInt)) || (_s[(0 : stdgo.GoInt)] != (47 : stdgo.GoUInt8))) {
            _r._time = (7200 : stdgo.GoInt);
            return { _0 : _r?.__copy__(), _1 : _s?.__copy__(), _2 : true };
        };
        var __tmp__ = _tzsetOffset((_s.__slice__((1 : stdgo.GoInt)) : stdgo.GoString)?.__copy__()), _offset:stdgo.GoInt = __tmp__._0, _s:stdgo.GoString = __tmp__._1, _ok:Bool = __tmp__._2;
        if (!_ok) {
            return { _0 : (new stdgo.time.Time.T_rule() : stdgo.time.Time.T_rule), _1 : stdgo.Go.str()?.__copy__(), _2 : false };
        };
        _r._time = _offset;
        return { _0 : _r?.__copy__(), _1 : _s?.__copy__(), _2 : true };
    }
/**
    // tzsetNum parses a number from a tzset string.
    // It returns the number, and the remainder of the string, and reports success.
    // The number must be between min and max.
**/
function _tzsetNum(_s:stdgo.GoString, _min:stdgo.GoInt, _max:stdgo.GoInt):{ var _0 : stdgo.GoInt; var _1 : stdgo.GoString; var _2 : Bool; } {
        var _num:stdgo.GoInt = (0 : stdgo.GoInt), _rest:stdgo.GoString = ("" : stdgo.GoString), _ok:Bool = false;
        if ((_s.length) == ((0 : stdgo.GoInt))) {
            return { _0 : (0 : stdgo.GoInt), _1 : stdgo.Go.str()?.__copy__(), _2 : false };
        };
        _num = (0 : stdgo.GoInt);
        for (_i => _r in _s) {
            if ((_r < (48 : stdgo.GoInt32)) || (_r > (57 : stdgo.GoInt32))) {
                if ((_i == (0 : stdgo.GoInt)) || (_num < _min)) {
                    return { _0 : (0 : stdgo.GoInt), _1 : stdgo.Go.str()?.__copy__(), _2 : false };
                };
                return { _0 : _num, _1 : (_s.__slice__(_i) : stdgo.GoString)?.__copy__(), _2 : true };
            };
            _num = _num * ((10 : stdgo.GoInt));
            _num = _num + ((_r : stdgo.GoInt) - (48 : stdgo.GoInt));
            if (_num > _max) {
                return { _0 : (0 : stdgo.GoInt), _1 : stdgo.Go.str()?.__copy__(), _2 : false };
            };
        };
        if (_num < _min) {
            return { _0 : (0 : stdgo.GoInt), _1 : stdgo.Go.str()?.__copy__(), _2 : false };
        };
        return { _0 : _num, _1 : stdgo.Go.str()?.__copy__(), _2 : true };
    }
/**
    // tzruleTime takes a year, a rule, and a timezone offset,
    // and returns the number of seconds since the start of the year
    // that the rule takes effect.
**/
function _tzruleTime(_year:stdgo.GoInt, _r:T_rule, _off:stdgo.GoInt):stdgo.GoInt {
        var _s:stdgo.GoInt = (0 : stdgo.GoInt);
        {
            var __switchIndex__ = -1;
            var __run__ = true;
            while (__run__) {
                __run__ = false;
                {
                    final __value__ = _r._kind;
                    if (__value__ == ((0 : stdgo.time.Time.T_ruleKind))) {
                        _s = (_r._day - (1 : stdgo.GoInt)) * (86400 : stdgo.GoInt);
                        if (_isLeap(_year) && (_r._day >= (60 : stdgo.GoInt))) {
                            _s = _s + ((86400 : stdgo.GoInt));
                        };
                        break;
                    } else if (__value__ == ((1 : stdgo.time.Time.T_ruleKind))) {
                        _s = _r._day * (86400 : stdgo.GoInt);
                        break;
                    } else if (__value__ == ((2 : stdgo.time.Time.T_ruleKind))) {
                        var _m1:stdgo.GoInt = ((_r._mon + (9 : stdgo.GoInt)) % (12 : stdgo.GoInt)) + (1 : stdgo.GoInt);
                        var _yy0:stdgo.GoInt = _year;
                        if (_r._mon <= (2 : stdgo.GoInt)) {
                            _yy0--;
                        };
                        var _yy1:stdgo.GoInt = _yy0 / (100 : stdgo.GoInt);
                        var _yy2:stdgo.GoInt = _yy0 % (100 : stdgo.GoInt);
                        var _dow:stdgo.GoInt = (((((((((26 : stdgo.GoInt) * _m1) - (2 : stdgo.GoInt)) / (10 : stdgo.GoInt)) + (1 : stdgo.GoInt)) + _yy2) + (_yy2 / (4 : stdgo.GoInt))) + (_yy1 / (4 : stdgo.GoInt))) - ((2 : stdgo.GoInt) * _yy1)) % (7 : stdgo.GoInt);
                        if (_dow < (0 : stdgo.GoInt)) {
                            _dow = _dow + ((7 : stdgo.GoInt));
                        };
                        var _d:stdgo.GoInt = _r._day - _dow;
                        if (_d < (0 : stdgo.GoInt)) {
                            _d = _d + ((7 : stdgo.GoInt));
                        };
                        {
                            var _i:stdgo.GoInt = (1 : stdgo.GoInt);
                            stdgo.Go.cfor(_i < _r._week, _i++, {
                                if ((_d + (7 : stdgo.GoInt)) >= _daysIn((_r._mon : Month), _year)) {
                                    break;
                                };
                                _d = _d + ((7 : stdgo.GoInt));
                            });
                        };
                        _d = _d + ((_daysBefore[(_r._mon - (1 : stdgo.GoInt) : stdgo.GoInt)] : stdgo.GoInt));
                        if (_isLeap(_year) && (_r._mon > (2 : stdgo.GoInt))) {
                            _d++;
                        };
                        _s = _d * (86400 : stdgo.GoInt);
                        break;
                    };
                };
                break;
            };
        };
        return (_s + _r._time) - _off;
    }
/**
    // LoadLocation returns the Location with the given name.
    //
    // If the name is "" or "UTC", LoadLocation returns UTC.
    // If the name is "Local", LoadLocation returns Local.
    //
    // Otherwise, the name is taken to be a location name corresponding to a file
    // in the IANA Time Zone database, such as "America/New_York".
    //
    // LoadLocation looks for the IANA Time Zone database in the following
    // locations in order:
    //
    //   - the directory or uncompressed zip file named by the ZONEINFO environment variable
    //   - on a Unix system, the system standard installation location
    //   - $GOROOT/lib/time/zoneinfo.zip
    //   - the time/tzdata package, if it was imported
**/
function loadLocation(_name:stdgo.GoString):{ var _0 : stdgo.Ref<Location>; var _1 : stdgo.Error; } {
        if ((_name == stdgo.Go.str()) || (_name == ("UTC" : stdgo.GoString))) {
            return { _0 : utc, _1 : (null : stdgo.Error) };
        };
        if (_name == (("Local" : stdgo.GoString))) {
            return { _0 : local, _1 : (null : stdgo.Error) };
        };
        if ((_containsDotDot(_name?.__copy__()) || (_name[(0 : stdgo.GoInt)] == (47 : stdgo.GoUInt8))) || (_name[(0 : stdgo.GoInt)] == (92 : stdgo.GoUInt8))) {
            return { _0 : null, _1 : _errLocation };
        };
        _zoneinfoOnce.do_(function():Void {
            var __tmp__ = stdgo.syscall.Syscall.getenv(("ZONEINFO" : stdgo.GoString)), _env:stdgo.GoString = __tmp__._0, __1:Bool = __tmp__._1;
            _zoneinfo = stdgo.Go.pointer(_env);
        });
        var _firstErr:stdgo.Error = (null : stdgo.Error);
        if (_zoneinfo.value != (stdgo.Go.str())) {
            {
                var __tmp__ = _loadTzinfoFromDirOrZip(_zoneinfo.value?.__copy__(), _name?.__copy__()), _zoneData:stdgo.Slice<stdgo.GoUInt8> = __tmp__._0, _err:stdgo.Error = __tmp__._1;
                if (_err == null) {
                    {
                        var __tmp__ = loadLocationFromTZData(_name?.__copy__(), _zoneData), _z:stdgo.Ref<stdgo.time.Time.Location> = __tmp__._0, _err:stdgo.Error = __tmp__._1;
                        if (_err == null) {
                            return { _0 : _z, _1 : (null : stdgo.Error) };
                        };
                    };
                    _firstErr = _err;
                } else if (stdgo.Go.toInterface(_err) != (stdgo.Go.toInterface(stdgo.Go.asInterface((2 : stdgo.syscall.Syscall.Errno))))) {
                    _firstErr = _err;
                };
            };
        };
        {
            var __tmp__ = _loadLocation(_name?.__copy__(), _platformZoneSources), _z:stdgo.Ref<stdgo.time.Time.Location> = __tmp__._0, _err:stdgo.Error = __tmp__._1;
            if (_err == null) {
                return { _0 : _z, _1 : (null : stdgo.Error) };
            } else if (_firstErr == null) {
                _firstErr = _err;
            };
        };
        return { _0 : null, _1 : _firstErr };
    }
/**
    // containsDotDot reports whether s contains "..".
**/
function _containsDotDot(_s:stdgo.GoString):Bool {
        if ((_s.length) < (2 : stdgo.GoInt)) {
            return false;
        };
        {
            var _i:stdgo.GoInt = (0 : stdgo.GoInt);
            stdgo.Go.cfor(_i < (_s.length - (1 : stdgo.GoInt)), _i++, {
                if ((_s[(_i : stdgo.GoInt)] == (46 : stdgo.GoUInt8)) && (_s[(_i + (1 : stdgo.GoInt) : stdgo.GoInt)] == (46 : stdgo.GoUInt8))) {
                    return true;
                };
            });
        };
        return false;
    }
function _gorootZoneSource(_goroot:stdgo.GoString):{ var _0 : stdgo.GoString; var _1 : Bool; } {
        if (_goroot == (stdgo.Go.str())) {
            return { _0 : stdgo.Go.str()?.__copy__(), _1 : false };
        };
        return { _0 : _goroot + ("/lib/time/zoneinfo.zip" : stdgo.GoString)?.__copy__()?.__copy__(), _1 : true };
    }
function _initLocal():Void {
        _localLoc._name = ("Local" : stdgo.GoString);
        final d = new Date(0, 0, 0, 0, 0, 0);
        var offset = d.getTimezoneOffset() * -1;
        offset *= 60;
        var name = "UTC";
        if (offset < 0) {
            name += "-";
            offset *= -1;
        } else {
            name += "+";
        };
        name += Std.string(offset / 60);
        final min = offset % 60;
        if (min != 0) {
            name += ":" + Std.string(min);
        };
        _localLoc._zone = new stdgo.Slice<T_zone>(1, 1, ...[{ _name : (name : stdgo.GoString), _offset : offset, _isDST : false }]);
    }
/**
    // registerLoadFromEmbeddedTZData is called by the time/tzdata package,
    // if it is imported.
**/
function _registerLoadFromEmbeddedTZData(_f:stdgo.GoString -> { var _0 : stdgo.GoString; var _1 : stdgo.Error; }):Void {
        _loadFromEmbeddedTZData = _f;
    }
/**
    // Make a string by stopping at the first NUL
**/
function _byteString(_p:stdgo.Slice<stdgo.GoByte>):stdgo.GoString {
        {
            var _i:stdgo.GoInt = (0 : stdgo.GoInt);
            stdgo.Go.cfor(_i < (_p.length), _i++, {
                if (_p[(_i : stdgo.GoInt)] == ((0 : stdgo.GoUInt8))) {
                    return ((_p.__slice__((0 : stdgo.GoInt), _i) : stdgo.Slice<stdgo.GoUInt8>) : stdgo.GoString)?.__copy__();
                };
            });
        };
        return (_p : stdgo.GoString)?.__copy__();
    }
/**
    // LoadLocationFromTZData returns a Location with the given name
    // initialized from the IANA Time Zone database-formatted data.
    // The data should be in the format of a standard IANA time zone file
    // (for example, the content of /etc/localtime on Unix systems).
**/
function loadLocationFromTZData(_name:stdgo.GoString, _data:stdgo.Slice<stdgo.GoByte>):{ var _0 : stdgo.Ref<Location>; var _1 : stdgo.Error; } {
        var _d:stdgo.time.Time.T_dataIO = (new stdgo.time.Time.T_dataIO(_data, false) : stdgo.time.Time.T_dataIO);
        {
            var _magic = _d._read((4 : stdgo.GoInt));
            if ((_magic : stdgo.GoString) != (("TZif" : stdgo.GoString))) {
                return { _0 : null, _1 : _errBadData };
            };
        };
        var _version:stdgo.GoInt = (0 : stdgo.GoInt);
        var _p:stdgo.Slice<stdgo.GoByte> = (null : stdgo.Slice<stdgo.GoUInt8>);
        {
            _p = _d._read((16 : stdgo.GoInt));
            if ((_p.length) != ((16 : stdgo.GoInt))) {
                return { _0 : null, _1 : _errBadData };
            } else {
                {
                    final __value__ = _p[(0 : stdgo.GoInt)];
                    if (__value__ == ((0 : stdgo.GoUInt8))) {
                        _version = (1 : stdgo.GoInt);
                    } else if (__value__ == ((50 : stdgo.GoUInt8))) {
                        _version = (2 : stdgo.GoInt);
                    } else if (__value__ == ((51 : stdgo.GoUInt8))) {
                        _version = (3 : stdgo.GoInt);
                    } else {
                        return { _0 : null, _1 : _errBadData };
                    };
                };
            };
        };
        {};
        var _n:stdgo.GoArray<stdgo.GoInt> = new stdgo.GoArray<stdgo.GoInt>(...[for (i in 0 ... 6) (0 : stdgo.GoInt)]);
        {
            var _i:stdgo.GoInt = (0 : stdgo.GoInt);
            stdgo.Go.cfor(_i < (6 : stdgo.GoInt), _i++, {
                var __tmp__ = _d._big4(), _nn:stdgo.GoUInt32 = __tmp__._0, _ok:Bool = __tmp__._1;
                if (!_ok) {
                    return { _0 : null, _1 : _errBadData };
                };
                if (((_nn : stdgo.GoInt) : stdgo.GoUInt32) != (_nn)) {
                    return { _0 : null, _1 : _errBadData };
                };
                _n[(_i : stdgo.GoInt)] = (_nn : stdgo.GoInt);
            });
        };
        var _is64:Bool = false;
        if (_version > (1 : stdgo.GoInt)) {
            var _skip:stdgo.GoInt = ((((((_n[(3 : stdgo.GoInt)] * (4 : stdgo.GoInt)) + _n[(3 : stdgo.GoInt)]) + (_n[(4 : stdgo.GoInt)] * (6 : stdgo.GoInt))) + _n[(5 : stdgo.GoInt)]) + (_n[(2 : stdgo.GoInt)] * (8 : stdgo.GoInt))) + _n[(1 : stdgo.GoInt)]) + _n[(0 : stdgo.GoInt)];
            _skip = _skip + ((20 : stdgo.GoInt));
            _d._read(_skip);
            _is64 = true;
            {
                var _i:stdgo.GoInt = (0 : stdgo.GoInt);
                stdgo.Go.cfor(_i < (6 : stdgo.GoInt), _i++, {
                    var __tmp__ = _d._big4(), _nn:stdgo.GoUInt32 = __tmp__._0, _ok:Bool = __tmp__._1;
                    if (!_ok) {
                        return { _0 : null, _1 : _errBadData };
                    };
                    if (((_nn : stdgo.GoInt) : stdgo.GoUInt32) != (_nn)) {
                        return { _0 : null, _1 : _errBadData };
                    };
                    _n[(_i : stdgo.GoInt)] = (_nn : stdgo.GoInt);
                });
            };
        };
        var _size:stdgo.GoInt = (4 : stdgo.GoInt);
        if (_is64) {
            _size = (8 : stdgo.GoInt);
        };
        var _txtimes:stdgo.time.Time.T_dataIO = (new stdgo.time.Time.T_dataIO(_d._read(_n[(3 : stdgo.GoInt)] * _size), false) : stdgo.time.Time.T_dataIO);
        var _txzones = _d._read(_n[(3 : stdgo.GoInt)]);
        var _zonedata:stdgo.time.Time.T_dataIO = (new stdgo.time.Time.T_dataIO(_d._read(_n[(4 : stdgo.GoInt)] * (6 : stdgo.GoInt)), false) : stdgo.time.Time.T_dataIO);
        var _abbrev = _d._read(_n[(5 : stdgo.GoInt)]);
        _d._read(_n[(2 : stdgo.GoInt)] * (_size + (4 : stdgo.GoInt)));
        var _isstd = _d._read(_n[(1 : stdgo.GoInt)]);
        var _isutc = _d._read(_n[(0 : stdgo.GoInt)]);
        if (_d._error) {
            return { _0 : null, _1 : _errBadData };
        };
        var _extend:stdgo.GoString = ("" : stdgo.GoString);
        var _rest = _d._rest();
        if (((_rest.length > (2 : stdgo.GoInt)) && (_rest[(0 : stdgo.GoInt)] == (10 : stdgo.GoUInt8))) && (_rest[((_rest.length) - (1 : stdgo.GoInt) : stdgo.GoInt)] == (10 : stdgo.GoUInt8))) {
            _extend = ((_rest.__slice__((1 : stdgo.GoInt), (_rest.length) - (1 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoUInt8>) : stdgo.GoString)?.__copy__();
        };
        var _nzone:stdgo.GoInt = _n[(4 : stdgo.GoInt)];
        if (_nzone == ((0 : stdgo.GoInt))) {
            return { _0 : null, _1 : _errBadData };
        };
        var _zones = new stdgo.Slice<stdgo.time.Time.T_zone>((_nzone : stdgo.GoInt).toBasic(), 0, ...[for (i in 0 ... ((_nzone : stdgo.GoInt).toBasic() > 0 ? (_nzone : stdgo.GoInt).toBasic() : 0 : stdgo.GoInt).toBasic()) ({} : stdgo.time.Time.T_zone)]);
        for (_i in 0 ... _zones.length.toBasic()) {
            var _ok:Bool = false;
            var _n:stdgo.GoUInt32 = (0 : stdgo.GoUInt32);
            {
                {
                    var __tmp__ = _zonedata._big4();
                    _n = __tmp__._0;
                    _ok = __tmp__._1;
                };
                if (!_ok) {
                    return { _0 : null, _1 : _errBadData };
                };
            };
            if (((_n : stdgo.GoInt) : stdgo.GoUInt32) != (_n)) {
                return { _0 : null, _1 : _errBadData };
            };
            _zones[(_i : stdgo.GoInt)]._offset = ((_n : stdgo.GoInt32) : stdgo.GoInt);
            var _b:stdgo.GoByte = (0 : stdgo.GoUInt8);
            {
                {
                    var __tmp__ = _zonedata._byte();
                    _b = __tmp__._0;
                    _ok = __tmp__._1;
                };
                if (!_ok) {
                    return { _0 : null, _1 : _errBadData };
                };
            };
            _zones[(_i : stdgo.GoInt)]._isDST = _b != ((0 : stdgo.GoUInt8));
            {
                {
                    var __tmp__ = _zonedata._byte();
                    _b = __tmp__._0;
                    _ok = __tmp__._1;
                };
                if (!_ok || ((_b : stdgo.GoInt) >= _abbrev.length)) {
                    return { _0 : null, _1 : _errBadData };
                };
            };
            _zones[(_i : stdgo.GoInt)]._name = _byteString((_abbrev.__slice__(_b) : stdgo.Slice<stdgo.GoUInt8>))?.__copy__();
            if ((false && (_name.length > (8 : stdgo.GoInt))) && (((_name.__slice__(0, (8 : stdgo.GoInt)) : stdgo.GoString) == ("Etc/GMT+" : stdgo.GoString)) || ((_name.__slice__(0, (8 : stdgo.GoInt)) : stdgo.GoString) == ("Etc/GMT-" : stdgo.GoString)))) {
                if (_name != (("Etc/GMT+0" : stdgo.GoString))) {
                    _zones[(_i : stdgo.GoInt)]._name = (_name.__slice__((4 : stdgo.GoInt)) : stdgo.GoString)?.__copy__();
                };
            };
        };
        var _tx = new stdgo.Slice<stdgo.time.Time.T_zoneTrans>((_n[(3 : stdgo.GoInt)] : stdgo.GoInt).toBasic(), 0, ...[for (i in 0 ... ((_n[(3 : stdgo.GoInt)] : stdgo.GoInt).toBasic() > 0 ? (_n[(3 : stdgo.GoInt)] : stdgo.GoInt).toBasic() : 0 : stdgo.GoInt).toBasic()) ({} : stdgo.time.Time.T_zoneTrans)]);
        for (_i in 0 ... _tx.length.toBasic()) {
            var _n:stdgo.GoInt64 = (0 : stdgo.GoInt64);
            if (!_is64) {
                {
                    var __tmp__ = _txtimes._big4(), _n4:stdgo.GoUInt32 = __tmp__._0, _ok:Bool = __tmp__._1;
                    if (!_ok) {
                        return { _0 : null, _1 : _errBadData };
                    } else {
                        _n = ((_n4 : stdgo.GoInt32) : stdgo.GoInt64);
                    };
                };
            } else {
                {
                    var __tmp__ = _txtimes._big8(), _n8:stdgo.GoUInt64 = __tmp__._0, _ok:Bool = __tmp__._1;
                    if (!_ok) {
                        return { _0 : null, _1 : _errBadData };
                    } else {
                        _n = (_n8 : stdgo.GoInt64);
                    };
                };
            };
            _tx[(_i : stdgo.GoInt)]._when = _n;
            if ((_txzones[(_i : stdgo.GoInt)] : stdgo.GoInt) >= (_zones.length)) {
                return { _0 : null, _1 : _errBadData };
            };
            _tx[(_i : stdgo.GoInt)]._index = _txzones[(_i : stdgo.GoInt)];
            if (_i < (_isstd.length)) {
                _tx[(_i : stdgo.GoInt)]._isstd = _isstd[(_i : stdgo.GoInt)] != ((0 : stdgo.GoUInt8));
            };
            if (_i < (_isutc.length)) {
                _tx[(_i : stdgo.GoInt)]._isutc = _isutc[(_i : stdgo.GoInt)] != ((0 : stdgo.GoUInt8));
            };
        };
        if ((_tx.length) == ((0 : stdgo.GoInt))) {
            _tx = (_tx.__append__(({ _when : (-9223372036854775808i64 : stdgo.GoInt64), _index : (0 : stdgo.GoUInt8) } : stdgo.time.Time.T_zoneTrans)));
        };
        var _l = (stdgo.Go.setRef(({ _name : _name?.__copy__(), _zone : _zones, _tx : _tx, _extend : _extend?.__copy__() } : stdgo.time.Time.Location)) : stdgo.Ref<stdgo.time.Time.Location>);
        var __tmp__ = _now(), _sec:stdgo.GoInt64 = __tmp__._0, __1:stdgo.GoInt32 = __tmp__._1, __2:stdgo.GoInt64 = __tmp__._2;
        for (_i in 0 ... _tx.length.toBasic()) {
            if ((_tx[(_i : stdgo.GoInt)]._when <= _sec) && (((_i + (1 : stdgo.GoInt)) == (_tx.length)) || (_sec < _tx[(_i + (1 : stdgo.GoInt) : stdgo.GoInt)]._when))) {
                _l._cacheStart = _tx[(_i : stdgo.GoInt)]._when;
                _l._cacheEnd = (9223372036854775807i64 : stdgo.GoInt64);
                _l._cacheZone = (stdgo.Go.setRef(_l._zone[(_tx[(_i : stdgo.GoInt)]._index : stdgo.GoInt)]) : stdgo.Ref<stdgo.time.Time.T_zone>);
                if ((_i + (1 : stdgo.GoInt)) < (_tx.length)) {
                    _l._cacheEnd = _tx[(_i + (1 : stdgo.GoInt) : stdgo.GoInt)]._when;
                } else if (_l._extend != (stdgo.Go.str())) {
                    {
                        var __tmp__ = _tzset(_l._extend?.__copy__(), _l._cacheStart, _sec), _name:stdgo.GoString = __tmp__._0, _offset:stdgo.GoInt = __tmp__._1, _estart:stdgo.GoInt64 = __tmp__._2, _eend:stdgo.GoInt64 = __tmp__._3, _isDST:Bool = __tmp__._4, _ok:Bool = __tmp__._5;
                        if (_ok) {
                            _l._cacheStart = _estart;
                            _l._cacheEnd = _eend;
                            {
                                var _zoneIdx:stdgo.GoInt = _findZone(_l._zone, _name?.__copy__(), _offset, _isDST);
                                if (_zoneIdx != ((-1 : stdgo.GoInt))) {
                                    _l._cacheZone = (stdgo.Go.setRef(_l._zone[(_zoneIdx : stdgo.GoInt)]) : stdgo.Ref<stdgo.time.Time.T_zone>);
                                } else {
                                    _l._cacheZone = (stdgo.Go.setRef(({ _name : _name?.__copy__(), _offset : _offset, _isDST : _isDST } : stdgo.time.Time.T_zone)) : stdgo.Ref<stdgo.time.Time.T_zone>);
                                };
                            };
                        };
                    };
                };
                break;
            };
        };
        return { _0 : _l, _1 : (null : stdgo.Error) };
    }
function _findZone(_zones:stdgo.Slice<T_zone>, _name:stdgo.GoString, _offset:stdgo.GoInt, _isDST:Bool):stdgo.GoInt {
        for (_i => _z in _zones) {
            if (((_z._name == _name) && (_z._offset == _offset)) && (_z._isDST == _isDST)) {
                return _i;
            };
        };
        return (-1 : stdgo.GoInt);
    }
/**
    // loadTzinfoFromDirOrZip returns the contents of the file with the given name
    // in dir. dir can either be an uncompressed zip file, or a directory.
**/
function _loadTzinfoFromDirOrZip(_dir:stdgo.GoString, _name:stdgo.GoString):{ var _0 : stdgo.Slice<stdgo.GoByte>; var _1 : stdgo.Error; } {
        if ((_dir.length > (4 : stdgo.GoInt)) && ((_dir.__slice__((_dir.length) - (4 : stdgo.GoInt)) : stdgo.GoString) == (".zip" : stdgo.GoString))) {
            return _loadTzinfoFromZip(_dir?.__copy__(), _name?.__copy__());
        };
        if (_dir != (stdgo.Go.str())) {
            _name = _dir + ("/" : stdgo.GoString)?.__copy__() + _name?.__copy__()?.__copy__();
        };
        return _readFile(_name?.__copy__());
    }
/**
    // get4 returns the little-endian 32-bit value in b.
**/
function _get4(_b:stdgo.Slice<stdgo.GoByte>):stdgo.GoInt {
        if ((_b.length) < (4 : stdgo.GoInt)) {
            return (0 : stdgo.GoInt);
        };
        return (((_b[(0 : stdgo.GoInt)] : stdgo.GoInt) | ((_b[(1 : stdgo.GoInt)] : stdgo.GoInt) << (8i64 : stdgo.GoUInt64))) | ((_b[(2 : stdgo.GoInt)] : stdgo.GoInt) << (16i64 : stdgo.GoUInt64))) | ((_b[(3 : stdgo.GoInt)] : stdgo.GoInt) << (24i64 : stdgo.GoUInt64));
    }
/**
    // get2 returns the little-endian 16-bit value in b.
**/
function _get2(_b:stdgo.Slice<stdgo.GoByte>):stdgo.GoInt {
        if ((_b.length) < (2 : stdgo.GoInt)) {
            return (0 : stdgo.GoInt);
        };
        return (_b[(0 : stdgo.GoInt)] : stdgo.GoInt) | ((_b[(1 : stdgo.GoInt)] : stdgo.GoInt) << (8i64 : stdgo.GoUInt64));
    }
/**
    // loadTzinfoFromZip returns the contents of the file with the given name
    // in the given uncompressed zip file.
**/
function _loadTzinfoFromZip(_zipfile:stdgo.GoString, _name:stdgo.GoString):{ var _0 : stdgo.Slice<stdgo.GoByte>; var _1 : stdgo.Error; } {
        var __deferstack__:Array<Void -> Void> = [];
        try {
            var __tmp__ = _open(_zipfile?.__copy__()), _fd:stdgo.GoUIntptr = __tmp__._0, _err:stdgo.Error = __tmp__._1;
            if (_err != null) {
                return { _0 : (null : stdgo.Slice<stdgo.GoUInt8>), _1 : _err };
            };
            {
                var _a0 = _fd;
                __deferstack__.unshift(() -> _closefd(_a0));
            };
            {};
            var _buf = new stdgo.Slice<stdgo.GoUInt8>((22 : stdgo.GoInt).toBasic(), 0).__setNumber32__();
            {
                var _err:stdgo.Error = _preadn(_fd, _buf, (-22 : stdgo.GoInt));
                if ((_err != null) || (_get4(_buf) != (101010256 : stdgo.GoInt))) {
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return { _0 : (null : stdgo.Slice<stdgo.GoUInt8>), _1 : stdgo.errors.Errors.new_(("corrupt zip file " : stdgo.GoString) + _zipfile?.__copy__()?.__copy__()) };
                    };
                };
            };
            var _n:stdgo.GoInt = _get2((_buf.__slice__((10 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoUInt8>));
            var _size:stdgo.GoInt = _get4((_buf.__slice__((12 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoUInt8>));
            var _off:stdgo.GoInt = _get4((_buf.__slice__((16 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoUInt8>));
            _buf = new stdgo.Slice<stdgo.GoUInt8>((_size : stdgo.GoInt).toBasic(), 0).__setNumber32__();
            {
                var _err:stdgo.Error = _preadn(_fd, _buf, _off);
                if (_err != null) {
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return { _0 : (null : stdgo.Slice<stdgo.GoUInt8>), _1 : stdgo.errors.Errors.new_(("corrupt zip file " : stdgo.GoString) + _zipfile?.__copy__()?.__copy__()) };
                    };
                };
            };
            {
                var _i:stdgo.GoInt = (0 : stdgo.GoInt);
                stdgo.Go.cfor(_i < _n, _i++, {
                    if (_get4(_buf) != ((33639248 : stdgo.GoInt))) {
                        break;
                    };
                    var _meth:stdgo.GoInt = _get2((_buf.__slice__((10 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoUInt8>));
                    var _size:stdgo.GoInt = _get4((_buf.__slice__((24 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoUInt8>));
                    var _namelen:stdgo.GoInt = _get2((_buf.__slice__((28 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoUInt8>));
                    var _xlen:stdgo.GoInt = _get2((_buf.__slice__((30 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoUInt8>));
                    var _fclen:stdgo.GoInt = _get2((_buf.__slice__((32 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoUInt8>));
                    var _off:stdgo.GoInt = _get4((_buf.__slice__((42 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoUInt8>));
                    var _zname = (_buf.__slice__((46 : stdgo.GoInt), (46 : stdgo.GoInt) + _namelen) : stdgo.Slice<stdgo.GoUInt8>);
                    _buf = (_buf.__slice__((((46 : stdgo.GoInt) + _namelen) + _xlen) + _fclen) : stdgo.Slice<stdgo.GoUInt8>);
                    if ((_zname : stdgo.GoString) != (_name)) {
                        continue;
                    };
                    if (_meth != ((0 : stdgo.GoInt))) {
                        {
                            for (defer in __deferstack__) {
                                defer();
                            };
                            return { _0 : (null : stdgo.Slice<stdgo.GoUInt8>), _1 : stdgo.errors.Errors.new_(("unsupported compression for " : stdgo.GoString) + _name?.__copy__() + (" in " : stdgo.GoString)?.__copy__() + _zipfile?.__copy__()?.__copy__()) };
                        };
                    };
                    _buf = new stdgo.Slice<stdgo.GoUInt8>(((30 : stdgo.GoInt) + _namelen : stdgo.GoInt).toBasic(), 0).__setNumber32__();
                    {
                        var _err:stdgo.Error = _preadn(_fd, _buf, _off);
                        if (((((_err != null) || (_get4(_buf) != (67324752 : stdgo.GoInt))) || (_get2((_buf.__slice__((8 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoUInt8>)) != _meth)) || (_get2((_buf.__slice__((26 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoUInt8>)) != _namelen)) || (((_buf.__slice__((30 : stdgo.GoInt), (30 : stdgo.GoInt) + _namelen) : stdgo.Slice<stdgo.GoUInt8>) : stdgo.GoString) != _name)) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return { _0 : (null : stdgo.Slice<stdgo.GoUInt8>), _1 : stdgo.errors.Errors.new_(("corrupt zip file " : stdgo.GoString) + _zipfile?.__copy__()?.__copy__()) };
                            };
                        };
                    };
                    _xlen = _get2((_buf.__slice__((28 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoUInt8>));
                    _buf = new stdgo.Slice<stdgo.GoUInt8>((_size : stdgo.GoInt).toBasic(), 0).__setNumber32__();
                    {
                        var _err:stdgo.Error = _preadn(_fd, _buf, ((_off + (30 : stdgo.GoInt)) + _namelen) + _xlen);
                        if (_err != null) {
                            {
                                for (defer in __deferstack__) {
                                    defer();
                                };
                                return { _0 : (null : stdgo.Slice<stdgo.GoUInt8>), _1 : stdgo.errors.Errors.new_(("corrupt zip file " : stdgo.GoString) + _zipfile?.__copy__()?.__copy__()) };
                            };
                        };
                    };
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return { _0 : _buf, _1 : (null : stdgo.Error) };
                    };
                });
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return { _0 : (null : stdgo.Slice<stdgo.GoUInt8>), _1 : stdgo.Go.asInterface((2 : stdgo.syscall.Syscall.Errno)) };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return { _0 : (null : stdgo.Slice<stdgo.GoUInt8>), _1 : (null : stdgo.Error) };
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return { _0 : (null : stdgo.Slice<stdgo.GoUInt8>), _1 : (null : stdgo.Error) };
        };
    }
/**
    // loadTzinfo returns the time zone information of the time zone
    // with the given name, from a given source. A source may be a
    // timezone database directory, tzdata database file or an uncompressed
    // zip file, containing the contents of such a directory.
**/
function _loadTzinfo(_name:stdgo.GoString, _source:stdgo.GoString):{ var _0 : stdgo.Slice<stdgo.GoByte>; var _1 : stdgo.Error; } {
        if ((_source.length >= (6 : stdgo.GoInt)) && ((_source.__slice__((_source.length) - (6 : stdgo.GoInt)) : stdgo.GoString) == ("tzdata" : stdgo.GoString))) {
            return _loadTzinfoFromTzdata(_source?.__copy__(), _name?.__copy__());
        };
        return _loadTzinfoFromDirOrZip(_source?.__copy__(), _name?.__copy__());
    }
/**
    // loadLocation returns the Location with the given name from one of
    // the specified sources. See loadTzinfo for a list of supported sources.
    // The first timezone data matching the given name that is successfully loaded
    // and parsed is returned as a Location.
**/
function _loadLocation(_name:stdgo.GoString, _sources:stdgo.Slice<stdgo.GoString>):{ var _0 : stdgo.Ref<Location>; var _1 : stdgo.Error; } {
        var _z:stdgo.Ref<Location> = (null : stdgo.Ref<stdgo.time.Time.Location>), _firstErr:stdgo.Error = (null : stdgo.Error);
        for (__1 => _source in _sources) {
            var __tmp__ = _loadTzinfo(_name?.__copy__(), _source?.__copy__()), _zoneData:stdgo.Slice<stdgo.GoUInt8> = __tmp__._0, _err:stdgo.Error = __tmp__._1;
            if (_err == null) {
                {
                    {
                        var __tmp__ = loadLocationFromTZData(_name?.__copy__(), _zoneData);
                        _z = __tmp__._0;
                        _err = __tmp__._1;
                    };
                    if (_err == null) {
                        return { _0 : _z, _1 : (null : stdgo.Error) };
                    };
                };
            };
            if ((_firstErr == null) && (stdgo.Go.toInterface(_err) != stdgo.Go.toInterface(stdgo.Go.asInterface((2 : stdgo.syscall.Syscall.Errno))))) {
                _firstErr = _err;
            };
        };
        if (_loadFromEmbeddedTZData != null) {
            var __tmp__ = _loadFromEmbeddedTZData(_name?.__copy__()), _zoneData:stdgo.GoString = __tmp__._0, _err:stdgo.Error = __tmp__._1;
            if (_err == null) {
                {
                    {
                        var __tmp__ = loadLocationFromTZData(_name?.__copy__(), (_zoneData : stdgo.Slice<stdgo.GoByte>));
                        _z = __tmp__._0;
                        _err = __tmp__._1;
                    };
                    if (_err == null) {
                        return { _0 : _z, _1 : (null : stdgo.Error) };
                    };
                };
            };
            if ((_firstErr == null) && (stdgo.Go.toInterface(_err) != stdgo.Go.toInterface(stdgo.Go.asInterface((2 : stdgo.syscall.Syscall.Errno))))) {
                _firstErr = _err;
            };
        };
        {
            var __tmp__ = _gorootZoneSource(stdgo.runtime.Runtime.goroot()?.__copy__()), _source:stdgo.GoString = __tmp__._0, _ok:Bool = __tmp__._1;
            if (_ok) {
                var __tmp__ = _loadTzinfo(_name?.__copy__(), _source?.__copy__()), _zoneData:stdgo.Slice<stdgo.GoUInt8> = __tmp__._0, _err:stdgo.Error = __tmp__._1;
                if (_err == null) {
                    {
                        {
                            var __tmp__ = loadLocationFromTZData(_name?.__copy__(), _zoneData);
                            _z = __tmp__._0;
                            _err = __tmp__._1;
                        };
                        if (_err == null) {
                            return { _0 : _z, _1 : (null : stdgo.Error) };
                        };
                    };
                };
                if ((_firstErr == null) && (stdgo.Go.toInterface(_err) != stdgo.Go.toInterface(stdgo.Go.asInterface((2 : stdgo.syscall.Syscall.Errno))))) {
                    _firstErr = _err;
                };
            };
        };
        if (_firstErr != null) {
            return { _0 : null, _1 : _firstErr };
        };
        return { _0 : null, _1 : stdgo.errors.Errors.new_(("unknown time zone " : stdgo.GoString) + _name?.__copy__()?.__copy__()) };
    }
/**
    // readFile reads and returns the content of the named file.
    // It is a trivial implementation of os.ReadFile, reimplemented
    // here to avoid depending on io/ioutil or os.
    // It returns an error if name exceeds maxFileSize bytes.
**/
function _readFile(_name:stdgo.GoString):{ var _0 : stdgo.Slice<stdgo.GoByte>; var _1 : stdgo.Error; } {
        var __deferstack__:Array<Void -> Void> = [];
        try {
            var __tmp__ = _open(_name?.__copy__()), _f:stdgo.GoUIntptr = __tmp__._0, _err:stdgo.Error = __tmp__._1;
            if (_err != null) {
                return { _0 : (null : stdgo.Slice<stdgo.GoUInt8>), _1 : _err };
            };
            {
                var _a0 = _f;
                __deferstack__.unshift(() -> _closefd(_a0));
            };
            var __0:stdgo.GoArray<stdgo.GoByte> = new stdgo.GoArray<stdgo.GoUInt8>(...[for (i in 0 ... 4096) (0 : stdgo.GoUInt8)]), __1:stdgo.Slice<stdgo.GoByte> = (null : stdgo.Slice<stdgo.GoUInt8>), __2:stdgo.GoInt = (0 : stdgo.GoInt), _n:stdgo.GoInt = __2, _ret:stdgo.Slice<stdgo.GoByte> = __1, _buf:stdgo.GoArray<stdgo.GoByte> = __0;
            while (true) {
                {
                    var __tmp__ = _read(_f, (_buf.__slice__(0) : stdgo.Slice<stdgo.GoUInt8>));
                    _n = __tmp__._0;
                    _err = __tmp__._1;
                };
                if (_n > (0 : stdgo.GoInt)) {
                    _ret = (_ret.__append__(...(_buf.__slice__(0, _n) : stdgo.Slice<stdgo.GoUInt8>).__toArray__()));
                };
                if ((_n == (0 : stdgo.GoInt)) || (_err != null)) {
                    break;
                };
                if ((_ret.length) > (10485760 : stdgo.GoInt)) {
                    {
                        for (defer in __deferstack__) {
                            defer();
                        };
                        return { _0 : (null : stdgo.Slice<stdgo.GoUInt8>), _1 : stdgo.Go.asInterface((_name : T_fileSizeError)) };
                    };
                };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                return { _0 : _ret, _1 : _err };
            };
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
                return { _0 : (null : stdgo.Slice<stdgo.GoUInt8>), _1 : (null : stdgo.Error) };
            };
        } catch(__exception__) {
            var exe:Dynamic = __exception__.native;
            if ((exe is haxe.ValueException)) exe = exe.value;
            if (!(exe is stdgo.AnyInterface.AnyInterfaceData)) {
                exe = stdgo.Go.toInterface(__exception__.message);
            };
            stdgo.Go.recover_exception = exe;
            for (defer in __deferstack__) {
                defer();
            };
            if (stdgo.Go.recover_exception != null) throw stdgo.Go.recover_exception;
            return { _0 : (null : stdgo.Slice<stdgo.GoUInt8>), _1 : (null : stdgo.Error) };
        };
    }
@:keep var _ = {
        try {
            forceUSPacificForTesting();
        } catch(__exception__) if (__exception__.message != "__return__") throw __exception__;
        true;
    };
class ParseError_asInterface {
    /**
        // Error returns the string representation of a ParseError.
    **/
    @:keep
    public dynamic function error():stdgo.GoString return __self__.value.error();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<ParseError>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.time.Time.ParseError_asInterface) class ParseError_static_extension {
    /**
        // Error returns the string representation of a ParseError.
    **/
    @:keep
    static public function error( _e:stdgo.Ref<ParseError>):stdgo.GoString {
        @:recv var _e:stdgo.Ref<ParseError> = _e;
        if (_e.message == (stdgo.Go.str())) {
            return ("parsing time " : stdgo.GoString) + _quote(_e.value?.__copy__())?.__copy__() + (" as " : stdgo.GoString)?.__copy__() + _quote(_e.layout?.__copy__())?.__copy__() + (": cannot parse " : stdgo.GoString)?.__copy__() + _quote(_e.valueElem?.__copy__())?.__copy__() + (" as " : stdgo.GoString)?.__copy__() + _quote(_e.layoutElem?.__copy__())?.__copy__()?.__copy__();
        };
        return ("parsing time " : stdgo.GoString) + _quote(_e.value?.__copy__())?.__copy__() + _e.message?.__copy__()?.__copy__();
    }
}
class Timer_asInterface {
    /**
        // Reset changes the timer to expire after duration d.
        // It returns true if the timer had been active, false if the timer had
        // expired or been stopped.
        //
        // For a Timer created with NewTimer, Reset should be invoked only on
        // stopped or expired timers with drained channels.
        //
        // If a program has already received a value from t.C, the timer is known
        // to have expired and the channel drained, so t.Reset can be used directly.
        // If a program has not yet received a value from t.C, however,
        // the timer must be stopped and—if Stop reports that the timer expired
        // before being stopped—the channel explicitly drained:
        //
        //	if !t.Stop() {
        //		<-t.C
        //	}
        //	t.Reset(d)
        //
        // This should not be done concurrent to other receives from the Timer's
        // channel.
        //
        // Note that it is not possible to use Reset's return value correctly, as there
        // is a race condition between draining the channel and the new timer expiring.
        // Reset should always be invoked on stopped or expired channels, as described above.
        // The return value exists to preserve compatibility with existing programs.
        //
        // For a Timer created with AfterFunc(d, f), Reset either reschedules
        // when f will run, in which case Reset returns true, or schedules f
        // to run again, in which case it returns false.
        // When Reset returns false, Reset neither waits for the prior f to
        // complete before returning nor does it guarantee that the subsequent
        // goroutine running f does not run concurrently with the prior
        // one. If the caller needs to know whether the prior execution of
        // f is completed, it must coordinate with f explicitly.
    **/
    @:keep
    public dynamic function reset(_d:Duration):Bool return __self__.value.reset(_d);
    /**
        // Stop prevents the Timer from firing.
        // It returns true if the call stops the timer, false if the timer has already
        // expired or been stopped.
        // Stop does not close the channel, to prevent a read from the channel succeeding
        // incorrectly.
        //
        // To ensure the channel is empty after a call to Stop, check the
        // return value and drain the channel.
        // For example, assuming the program has not received from t.C already:
        //
        //	if !t.Stop() {
        //		<-t.C
        //	}
        //
        // This cannot be done concurrent to other receives from the Timer's
        // channel or other calls to the Timer's Stop method.
        //
        // For a timer created with AfterFunc(d, f), if t.Stop returns false, then the timer
        // has already expired and the function f has been started in its own goroutine;
        // Stop does not wait for f to complete before returning.
        // If the caller needs to know whether f is completed, it must coordinate
        // with f explicitly.
    **/
    @:keep
    public dynamic function stop():Bool return __self__.value.stop();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Timer>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.time.Time.Timer_asInterface) class Timer_static_extension {
    /**
        // Reset changes the timer to expire after duration d.
        // It returns true if the timer had been active, false if the timer had
        // expired or been stopped.
        //
        // For a Timer created with NewTimer, Reset should be invoked only on
        // stopped or expired timers with drained channels.
        //
        // If a program has already received a value from t.C, the timer is known
        // to have expired and the channel drained, so t.Reset can be used directly.
        // If a program has not yet received a value from t.C, however,
        // the timer must be stopped and—if Stop reports that the timer expired
        // before being stopped—the channel explicitly drained:
        //
        //	if !t.Stop() {
        //		<-t.C
        //	}
        //	t.Reset(d)
        //
        // This should not be done concurrent to other receives from the Timer's
        // channel.
        //
        // Note that it is not possible to use Reset's return value correctly, as there
        // is a race condition between draining the channel and the new timer expiring.
        // Reset should always be invoked on stopped or expired channels, as described above.
        // The return value exists to preserve compatibility with existing programs.
        //
        // For a Timer created with AfterFunc(d, f), Reset either reschedules
        // when f will run, in which case Reset returns true, or schedules f
        // to run again, in which case it returns false.
        // When Reset returns false, Reset neither waits for the prior f to
        // complete before returning nor does it guarantee that the subsequent
        // goroutine running f does not run concurrently with the prior
        // one. If the caller needs to know whether the prior execution of
        // f is completed, it must coordinate with f explicitly.
    **/
    @:keep
    static public function reset( _t:stdgo.Ref<Timer>, _d:Duration):Bool {
        @:recv var _t:stdgo.Ref<Timer> = _t;
        if (_t._r._f == null) {
            throw stdgo.Go.toInterface(("time: Reset called on uninitialized Timer" : stdgo.GoString));
        };
        var _w:stdgo.GoInt64 = _when(_d);
        return _resetTimer((stdgo.Go.setRef(_t._r) : stdgo.Ref<stdgo.time.Time.T_runtimeTimer>), _w);
    }
    /**
        // Stop prevents the Timer from firing.
        // It returns true if the call stops the timer, false if the timer has already
        // expired or been stopped.
        // Stop does not close the channel, to prevent a read from the channel succeeding
        // incorrectly.
        //
        // To ensure the channel is empty after a call to Stop, check the
        // return value and drain the channel.
        // For example, assuming the program has not received from t.C already:
        //
        //	if !t.Stop() {
        //		<-t.C
        //	}
        //
        // This cannot be done concurrent to other receives from the Timer's
        // channel or other calls to the Timer's Stop method.
        //
        // For a timer created with AfterFunc(d, f), if t.Stop returns false, then the timer
        // has already expired and the function f has been started in its own goroutine;
        // Stop does not wait for f to complete before returning.
        // If the caller needs to know whether f is completed, it must coordinate
        // with f explicitly.
    **/
    @:keep
    static public function stop( _t:stdgo.Ref<Timer>):Bool {
        @:recv var _t:stdgo.Ref<Timer> = _t;
        if (_t._r._f == null) {
            throw stdgo.Go.toInterface(("time: Stop called on uninitialized Timer" : stdgo.GoString));
        };
        return _stopTimer((stdgo.Go.setRef(_t._r) : stdgo.Ref<stdgo.time.Time.T_runtimeTimer>));
    }
}
class Ticker_asInterface {
    /**
        // Reset stops a ticker and resets its period to the specified duration.
        // The next tick will arrive after the new period elapses. The duration d
        // must be greater than zero; if not, Reset will panic.
    **/
    @:keep
    public dynamic function reset(_d:Duration):Void __self__.value.reset(_d);
    /**
        // Stop turns off a ticker. After Stop, no more ticks will be sent.
        // Stop does not close the channel, to prevent a concurrent goroutine
        // reading from the channel from seeing an erroneous "tick".
    **/
    @:keep
    public dynamic function stop():Void __self__.value.stop();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Ticker>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.time.Time.Ticker_asInterface) class Ticker_static_extension {
    /**
        // Reset stops a ticker and resets its period to the specified duration.
        // The next tick will arrive after the new period elapses. The duration d
        // must be greater than zero; if not, Reset will panic.
    **/
    @:keep
    static public function reset( _t:stdgo.Ref<Ticker>, _d:Duration):Void {
        @:recv var _t:stdgo.Ref<Ticker> = _t;
        if (_d <= (0i64 : stdgo.time.Time.Duration)) {
            throw stdgo.Go.toInterface(("non-positive interval for Ticker.Reset" : stdgo.GoString));
        };
        if (_t._r._f == null) {
            throw stdgo.Go.toInterface(("time: Reset called on uninitialized Ticker" : stdgo.GoString));
        };
        _modTimer((stdgo.Go.setRef(_t._r) : stdgo.Ref<stdgo.time.Time.T_runtimeTimer>), _when(_d), (_d : stdgo.GoInt64), _t._r._f, _t._r._arg, _t._r._seq);
    }
    /**
        // Stop turns off a ticker. After Stop, no more ticks will be sent.
        // Stop does not close the channel, to prevent a concurrent goroutine
        // reading from the channel from seeing an erroneous "tick".
    **/
    @:keep
    static public function stop( _t:stdgo.Ref<Ticker>):Void {
        @:recv var _t:stdgo.Ref<Ticker> = _t;
        _stopTimer((stdgo.Go.setRef(_t._r) : stdgo.Ref<stdgo.time.Time.T_runtimeTimer>));
    }
}
class Time_asInterface {
    /**
        // Round returns the result of rounding t to the nearest multiple of d (since the zero time).
        // The rounding behavior for halfway values is to round up.
        // If d <= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged.
        //
        // Round operates on the time as an absolute duration since the
        // zero time; it does not operate on the presentation form of the
        // time. Thus, Round(Hour) may return a time with a non-zero
        // minute, depending on the time's Location.
    **/
    @:keep
    public dynamic function round(_d:Duration):Time return __self__.value.round(_d);
    /**
        // Truncate returns the result of rounding t down to a multiple of d (since the zero time).
        // If d <= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.
        //
        // Truncate operates on the time as an absolute duration since the
        // zero time; it does not operate on the presentation form of the
        // time. Thus, Truncate(Hour) may return a time with a non-zero
        // minute, depending on the time's Location.
    **/
    @:keep
    public dynamic function truncate(_d:Duration):Time return __self__.value.truncate(_d);
    /**
        // IsDST reports whether the time in the configured location is in Daylight Savings Time.
    **/
    @:keep
    public dynamic function isDST():Bool return __self__.value.isDST();
    /**
        // UnmarshalText implements the encoding.TextUnmarshaler interface.
        // The time must be in the RFC 3339 format.
    **/
    @:keep
    public dynamic function unmarshalText(_data:stdgo.Slice<stdgo.GoByte>):stdgo.Error return __self__.value.unmarshalText(_data);
    /**
        // MarshalText implements the encoding.TextMarshaler interface.
        // The time is formatted in RFC 3339 format with sub-second precision.
        // If the timestamp cannot be represented as valid RFC 3339
        // (e.g., the year is out of range), then an error is reported.
    **/
    @:keep
    public dynamic function marshalText():{ var _0 : stdgo.Slice<stdgo.GoByte>; var _1 : stdgo.Error; } return __self__.value.marshalText();
    /**
        // UnmarshalJSON implements the json.Unmarshaler interface.
        // The time must be a quoted string in the RFC 3339 format.
    **/
    @:keep
    public dynamic function unmarshalJSON(_data:stdgo.Slice<stdgo.GoByte>):stdgo.Error return __self__.value.unmarshalJSON(_data);
    /**
        // MarshalJSON implements the json.Marshaler interface.
        // The time is a quoted string in the RFC 3339 format with sub-second precision.
        // If the timestamp cannot be represented as valid RFC 3339
        // (e.g., the year is out of range), then an error is reported.
    **/
    @:keep
    public dynamic function marshalJSON():{ var _0 : stdgo.Slice<stdgo.GoByte>; var _1 : stdgo.Error; } return __self__.value.marshalJSON();
    /**
        // GobDecode implements the gob.GobDecoder interface.
    **/
    @:keep
    public dynamic function gobDecode(_data:stdgo.Slice<stdgo.GoByte>):stdgo.Error return __self__.value.gobDecode(_data);
    /**
        // GobEncode implements the gob.GobEncoder interface.
    **/
    @:keep
    public dynamic function gobEncode():{ var _0 : stdgo.Slice<stdgo.GoByte>; var _1 : stdgo.Error; } return __self__.value.gobEncode();
    /**
        // UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.
    **/
    @:keep
    public dynamic function unmarshalBinary(_data:stdgo.Slice<stdgo.GoByte>):stdgo.Error return __self__.value.unmarshalBinary(_data);
    /**
        // MarshalBinary implements the encoding.BinaryMarshaler interface.
    **/
    @:keep
    public dynamic function marshalBinary():{ var _0 : stdgo.Slice<stdgo.GoByte>; var _1 : stdgo.Error; } return __self__.value.marshalBinary();
    /**
        // UnixNano returns t as a Unix time, the number of nanoseconds elapsed
        // since January 1, 1970 UTC. The result is undefined if the Unix time
        // in nanoseconds cannot be represented by an int64 (a date before the year
        // 1678 or after 2262). Note that this means the result of calling UnixNano
        // on the zero Time is undefined. The result does not depend on the
        // location associated with t.
    **/
    @:keep
    public dynamic function unixNano():stdgo.GoInt64 return __self__.value.unixNano();
    /**
        // UnixMicro returns t as a Unix time, the number of microseconds elapsed since
        // January 1, 1970 UTC. The result is undefined if the Unix time in
        // microseconds cannot be represented by an int64 (a date before year -290307 or
        // after year 294246). The result does not depend on the location associated
        // with t.
    **/
    @:keep
    public dynamic function unixMicro():stdgo.GoInt64 return __self__.value.unixMicro();
    /**
        // UnixMilli returns t as a Unix time, the number of milliseconds elapsed since
        // January 1, 1970 UTC. The result is undefined if the Unix time in
        // milliseconds cannot be represented by an int64 (a date more than 292 million
        // years before or after 1970). The result does not depend on the
        // location associated with t.
    **/
    @:keep
    public dynamic function unixMilli():stdgo.GoInt64 return __self__.value.unixMilli();
    /**
        // Unix returns t as a Unix time, the number of seconds elapsed
        // since January 1, 1970 UTC. The result does not depend on the
        // location associated with t.
        // Unix-like operating systems often record time as a 32-bit
        // count of seconds, but since the method here returns a 64-bit
        // value it is valid for billions of years into the past or future.
    **/
    @:keep
    public dynamic function unix():stdgo.GoInt64 return __self__.value.unix();
    /**
        // ZoneBounds returns the bounds of the time zone in effect at time t.
        // The zone begins at start and the next zone begins at end.
        // If the zone begins at the beginning of time, start will be returned as a zero Time.
        // If the zone goes on forever, end will be returned as a zero Time.
        // The Location of the returned times will be the same as t.
    **/
    @:keep
    public dynamic function zoneBounds():{ var _0 : Time; var _1 : Time; } return __self__.value.zoneBounds();
    /**
        // Zone computes the time zone in effect at time t, returning the abbreviated
        // name of the zone (such as "CET") and its offset in seconds east of UTC.
    **/
    @:keep
    public dynamic function zone():{ var _0 : stdgo.GoString; var _1 : stdgo.GoInt; } return __self__.value.zone();
    /**
        // Location returns the time zone information associated with t.
    **/
    @:keep
    public dynamic function location():stdgo.Ref<Location> return __self__.value.location();
    /**
        // In returns a copy of t representing the same time instant, but
        // with the copy's location information set to loc for display
        // purposes.
        //
        // In panics if loc is nil.
    **/
    @:keep
    public dynamic function in_(_loc:stdgo.Ref<Location>):Time return __self__.value.in_(_loc);
    /**
        // Local returns t with the location set to local time.
    **/
    @:keep
    public dynamic function local():Time return __self__.value.local();
    /**
        // UTC returns t with the location set to UTC.
    **/
    @:keep
    public dynamic function utc():Time return __self__.value.utc();
    /**
        // date computes the year, day of year, and when full=true,
        // the month and day in which t occurs.
    **/
    @:keep
    public dynamic function _date(_full:Bool):{ var _0 : stdgo.GoInt; var _1 : Month; var _2 : stdgo.GoInt; var _3 : stdgo.GoInt; } return __self__.value._date(_full);
    /**
        // AddDate returns the time corresponding to adding the
        // given number of years, months, and days to t.
        // For example, AddDate(-1, 2, 3) applied to January 1, 2011
        // returns March 4, 2010.
        //
        // AddDate normalizes its result in the same way that Date does,
        // so, for example, adding one month to October 31 yields
        // December 1, the normalized form for November 31.
    **/
    @:keep
    public dynamic function addDate(_years:stdgo.GoInt, _months:stdgo.GoInt, _days:stdgo.GoInt):Time return __self__.value.addDate(_years, _months, _days);
    /**
        // Sub returns the duration t-u. If the result exceeds the maximum (or minimum)
        // value that can be stored in a Duration, the maximum (or minimum) duration
        // will be returned.
        // To compute t-d for a duration d, use t.Add(-d).
    **/
    @:keep
    public dynamic function sub(_u:Time):Duration return __self__.value.sub(_u);
    /**
        // Add returns the time t+d.
    **/
    @:keep
    public dynamic function add(_d:Duration):Time return __self__.value.add(_d);
    /**
        // YearDay returns the day of the year specified by t, in the range [1,365] for non-leap years,
        // and [1,366] in leap years.
    **/
    @:keep
    public dynamic function yearDay():stdgo.GoInt return __self__.value.yearDay();
    /**
        // Nanosecond returns the nanosecond offset within the second specified by t,
        // in the range [0, 999999999].
    **/
    @:keep
    public dynamic function nanosecond():stdgo.GoInt return __self__.value.nanosecond();
    /**
        // Second returns the second offset within the minute specified by t, in the range [0, 59].
    **/
    @:keep
    public dynamic function second():stdgo.GoInt return __self__.value.second();
    /**
        // Minute returns the minute offset within the hour specified by t, in the range [0, 59].
    **/
    @:keep
    public dynamic function minute():stdgo.GoInt return __self__.value.minute();
    /**
        // Hour returns the hour within the day specified by t, in the range [0, 23].
    **/
    @:keep
    public dynamic function hour():stdgo.GoInt return __self__.value.hour();
    /**
        // Clock returns the hour, minute, and second within the day specified by t.
    **/
    @:keep
    public dynamic function clock():{ var _0 : stdgo.GoInt; var _1 : stdgo.GoInt; var _2 : stdgo.GoInt; } return __self__.value.clock();
    /**
        // ISOWeek returns the ISO 8601 year and week number in which t occurs.
        // Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to
        // week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1
        // of year n+1.
    **/
    @:keep
    public dynamic function isoweek():{ var _0 : stdgo.GoInt; var _1 : stdgo.GoInt; } return __self__.value.isoweek();
    /**
        // Weekday returns the day of the week specified by t.
    **/
    @:keep
    public dynamic function weekday():Weekday return __self__.value.weekday();
    /**
        // Day returns the day of the month specified by t.
    **/
    @:keep
    public dynamic function day():stdgo.GoInt return __self__.value.day();
    /**
        // Month returns the month of the year specified by t.
    **/
    @:keep
    public dynamic function month():Month return __self__.value.month();
    /**
        // Year returns the year in which t occurs.
    **/
    @:keep
    public dynamic function year():stdgo.GoInt return __self__.value.year();
    /**
        // Date returns the year, month, and day in which t occurs.
    **/
    @:keep
    public dynamic function date():{ var _0 : stdgo.GoInt; var _1 : Month; var _2 : stdgo.GoInt; } return __self__.value.date();
    /**
        // locabs is a combination of the Zone and abs methods,
        // extracting both return values from a single zone lookup.
    **/
    @:keep
    public dynamic function _locabs():{ var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoUInt64; } return __self__.value._locabs();
    /**
        // abs returns the time t as an absolute time, adjusted by the zone offset.
        // It is called when computing a presentation property like Month or Hour.
    **/
    @:keep
    public dynamic function _abs():stdgo.GoUInt64 return __self__.value._abs();
    /**
        // IsZero reports whether t represents the zero time instant,
        // January 1, year 1, 00:00:00 UTC.
    **/
    @:keep
    public dynamic function isZero():Bool return __self__.value.isZero();
    /**
        // Equal reports whether t and u represent the same time instant.
        // Two times can be equal even if they are in different locations.
        // For example, 6:00 +0200 and 4:00 UTC are Equal.
        // See the documentation on the Time type for the pitfalls of using == with
        // Time values; most code should use Equal instead.
    **/
    @:keep
    public dynamic function equal(_u:Time):Bool return __self__.value.equal(_u);
    /**
        // Compare compares the time instant t with u. If t is before u, it returns -1;
        // if t is after u, it returns +1; if they're the same, it returns 0.
    **/
    @:keep
    public dynamic function compare(_u:Time):stdgo.GoInt return __self__.value.compare(_u);
    /**
        // Before reports whether the time instant t is before u.
    **/
    @:keep
    public dynamic function before(_u:Time):Bool return __self__.value.before(_u);
    /**
        // After reports whether the time instant t is after u.
    **/
    @:keep
    public dynamic function after(_u:Time):Bool return __self__.value.after(_u);
    /**
        // mono returns t's monotonic clock reading.
        // It returns 0 for a missing reading.
        // This function is used only for testing,
        // so it's OK that technically 0 is a valid
        // monotonic clock reading as well.
    **/
    @:keep
    public dynamic function _mono():stdgo.GoInt64 return __self__.value._mono();
    /**
        // setMono sets the monotonic clock reading in t.
        // If t cannot hold a monotonic clock reading,
        // because its wall time is too large,
        // setMono is a no-op.
    **/
    @:keep
    public dynamic function _setMono(_m:stdgo.GoInt64):Void __self__.value._setMono(_m);
    /**
        // stripMono strips the monotonic clock reading in t.
    **/
    @:keep
    public dynamic function _stripMono():Void __self__.value._stripMono();
    /**
        // setLoc sets the location associated with the time.
    **/
    @:keep
    public dynamic function _setLoc(_loc:stdgo.Ref<Location>):Void __self__.value._setLoc(_loc);
    /**
        // addSec adds d seconds to the time.
    **/
    @:keep
    public dynamic function _addSec(_d:stdgo.GoInt64):Void __self__.value._addSec(_d);
    /**
        // unixSec returns the time's seconds since Jan 1 1970 (Unix time).
    **/
    @:keep
    public dynamic function _unixSec():stdgo.GoInt64 return __self__.value._unixSec();
    /**
        // sec returns the time's seconds since Jan 1 year 1.
    **/
    @:keep
    public dynamic function _sec():stdgo.GoInt64 return __self__.value._sec();
    /**
        // nsec returns the time's nanoseconds.
    **/
    @:keep
    public dynamic function _nsec():stdgo.GoInt32 return __self__.value._nsec();
    @:keep
    public dynamic function _appendStrictRFC3339(_b:stdgo.Slice<stdgo.GoByte>):{ var _0 : stdgo.Slice<stdgo.GoByte>; var _1 : stdgo.Error; } return __self__.value._appendStrictRFC3339(_b);
    @:keep
    public dynamic function _appendFormatRFC3339(_b:stdgo.Slice<stdgo.GoByte>, _nanos:Bool):stdgo.Slice<stdgo.GoByte> return __self__.value._appendFormatRFC3339(_b, _nanos);
    @:keep
    public dynamic function _appendFormat(_b:stdgo.Slice<stdgo.GoByte>, _layout:stdgo.GoString):stdgo.Slice<stdgo.GoByte> return __self__.value._appendFormat(_b, _layout);
    /**
        // AppendFormat is like Format but appends the textual
        // representation to b and returns the extended buffer.
    **/
    @:keep
    public dynamic function appendFormat(_b:stdgo.Slice<stdgo.GoByte>, _layout:stdgo.GoString):stdgo.Slice<stdgo.GoByte> return __self__.value.appendFormat(_b, _layout);
    /**
        // Format returns a textual representation of the time value formatted according
        // to the layout defined by the argument. See the documentation for the
        // constant called Layout to see how to represent the layout format.
        //
        // The executable example for Time.Format demonstrates the working
        // of the layout string in detail and is a good reference.
    **/
    @:keep
    public dynamic function format(_layout:stdgo.GoString):stdgo.GoString return __self__.value.format(_layout);
    /**
        // GoString implements fmt.GoStringer and formats t to be printed in Go source
        // code.
    **/
    @:keep
    public dynamic function goString():stdgo.GoString return __self__.value.goString();
    /**
        // String returns the time formatted using the format string
        //
        //	"2006-01-02 15:04:05.999999999 -0700 MST"
        //
        // If the time has a monotonic clock reading, the returned string
        // includes a final field "m=±<value>", where value is the monotonic
        // clock reading formatted as a decimal number of seconds.
        //
        // The returned string is meant for debugging; for a stable serialized
        // representation, use t.MarshalText, t.MarshalBinary, or t.Format
        // with an explicit format string.
    **/
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Time>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.time.Time.Time_asInterface) class Time_static_extension {
    /**
        // Round returns the result of rounding t to the nearest multiple of d (since the zero time).
        // The rounding behavior for halfway values is to round up.
        // If d <= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged.
        //
        // Round operates on the time as an absolute duration since the
        // zero time; it does not operate on the presentation form of the
        // time. Thus, Round(Hour) may return a time with a non-zero
        // minute, depending on the time's Location.
    **/
    @:keep
    static public function round( _t:Time, _d:Duration):Time {
        @:recv var _t:Time = _t?.__copy__();
        _t._stripMono();
        if (_d <= (0i64 : stdgo.time.Time.Duration)) {
            return _t?.__copy__();
        };
        var __tmp__ = _div(_t?.__copy__(), _d), __1:stdgo.GoInt = __tmp__._0, _r:stdgo.time.Time.Duration = __tmp__._1;
        if (_lessThanHalf(_r, _d)) {
            return _t.add(-_r)?.__copy__();
        };
        return _t.add(_d - _r)?.__copy__();
    }
    /**
        // Truncate returns the result of rounding t down to a multiple of d (since the zero time).
        // If d <= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged.
        //
        // Truncate operates on the time as an absolute duration since the
        // zero time; it does not operate on the presentation form of the
        // time. Thus, Truncate(Hour) may return a time with a non-zero
        // minute, depending on the time's Location.
    **/
    @:keep
    static public function truncate( _t:Time, _d:Duration):Time {
        @:recv var _t:Time = _t?.__copy__();
        _t._stripMono();
        if (_d <= (0i64 : stdgo.time.Time.Duration)) {
            return _t?.__copy__();
        };
        var __tmp__ = _div(_t?.__copy__(), _d), __1:stdgo.GoInt = __tmp__._0, _r:stdgo.time.Time.Duration = __tmp__._1;
        return _t.add(-_r)?.__copy__();
    }
    /**
        // IsDST reports whether the time in the configured location is in Daylight Savings Time.
    **/
    @:keep
    static public function isDST( _t:Time):Bool {
        @:recv var _t:Time = _t?.__copy__();
        var __tmp__ = _t._loc._lookup(_t.unix()), __1:stdgo.GoString = __tmp__._0, __2:stdgo.GoInt = __tmp__._1, __3:stdgo.GoInt64 = __tmp__._2, __4:stdgo.GoInt64 = __tmp__._3, _isDST:Bool = __tmp__._4;
        return _isDST;
    }
    /**
        // UnmarshalText implements the encoding.TextUnmarshaler interface.
        // The time must be in the RFC 3339 format.
    **/
    @:keep
    static public function unmarshalText( _t:stdgo.Ref<Time>, _data:stdgo.Slice<stdgo.GoByte>):stdgo.Error {
        @:recv var _t:stdgo.Ref<Time> = _t;
        var _err:stdgo.Error = (null : stdgo.Error);
        {
            var __tmp__ = _parseStrictRFC3339(_data);
            _t = __tmp__._0?.__copy__();
            _err = __tmp__._1;
        };
        return _err;
    }
    /**
        // MarshalText implements the encoding.TextMarshaler interface.
        // The time is formatted in RFC 3339 format with sub-second precision.
        // If the timestamp cannot be represented as valid RFC 3339
        // (e.g., the year is out of range), then an error is reported.
    **/
    @:keep
    static public function marshalText( _t:Time):{ var _0 : stdgo.Slice<stdgo.GoByte>; var _1 : stdgo.Error; } {
        @:recv var _t:Time = _t?.__copy__();
        var _b = new stdgo.Slice<stdgo.GoUInt8>((0 : stdgo.GoInt).toBasic(), (("2006-01-02T15:04:05.999999999Z07:00" : stdgo.GoString).length)).__setNumber32__();
        var __tmp__ = _t._appendStrictRFC3339(_b), _b:stdgo.Slice<stdgo.GoUInt8> = __tmp__._0, _err:stdgo.Error = __tmp__._1;
        if (_err != null) {
            return { _0 : (null : stdgo.Slice<stdgo.GoUInt8>), _1 : stdgo.errors.Errors.new_(("Time.MarshalText: " : stdgo.GoString) + _err.error()?.__copy__()?.__copy__()) };
        };
        return { _0 : _b, _1 : (null : stdgo.Error) };
    }
    /**
        // UnmarshalJSON implements the json.Unmarshaler interface.
        // The time must be a quoted string in the RFC 3339 format.
    **/
    @:keep
    static public function unmarshalJSON( _t:stdgo.Ref<Time>, _data:stdgo.Slice<stdgo.GoByte>):stdgo.Error {
        @:recv var _t:stdgo.Ref<Time> = _t;
        if ((_data : stdgo.GoString) == (("null" : stdgo.GoString))) {
            return (null : stdgo.Error);
        };
        if (((_data.length < (2 : stdgo.GoInt)) || (_data[(0 : stdgo.GoInt)] != (34 : stdgo.GoUInt8))) || (_data[((_data.length) - (1 : stdgo.GoInt) : stdgo.GoInt)] != (34 : stdgo.GoUInt8))) {
            return stdgo.errors.Errors.new_(("Time.UnmarshalJSON: input is not a JSON string" : stdgo.GoString));
        };
        _data = (_data.__slice__((("\"" : stdgo.GoString).length), (_data.length) - (("\"" : stdgo.GoString).length)) : stdgo.Slice<stdgo.GoUInt8>);
        var _err:stdgo.Error = (null : stdgo.Error);
        {
            var __tmp__ = _parseStrictRFC3339(_data);
            _t = __tmp__._0?.__copy__();
            _err = __tmp__._1;
        };
        return _err;
    }
    /**
        // MarshalJSON implements the json.Marshaler interface.
        // The time is a quoted string in the RFC 3339 format with sub-second precision.
        // If the timestamp cannot be represented as valid RFC 3339
        // (e.g., the year is out of range), then an error is reported.
    **/
    @:keep
    static public function marshalJSON( _t:Time):{ var _0 : stdgo.Slice<stdgo.GoByte>; var _1 : stdgo.Error; } {
        @:recv var _t:Time = _t?.__copy__();
        var _b = new stdgo.Slice<stdgo.GoUInt8>((0 : stdgo.GoInt).toBasic(), (37 : stdgo.GoInt)).__setNumber32__();
        _b = (_b.__append__((34 : stdgo.GoUInt8)));
        var __tmp__ = _t._appendStrictRFC3339(_b), _b:stdgo.Slice<stdgo.GoUInt8> = __tmp__._0, _err:stdgo.Error = __tmp__._1;
        _b = (_b.__append__((34 : stdgo.GoUInt8)));
        if (_err != null) {
            return { _0 : (null : stdgo.Slice<stdgo.GoUInt8>), _1 : stdgo.errors.Errors.new_(("Time.MarshalJSON: " : stdgo.GoString) + _err.error()?.__copy__()?.__copy__()) };
        };
        return { _0 : _b, _1 : (null : stdgo.Error) };
    }
    /**
        // GobDecode implements the gob.GobDecoder interface.
    **/
    @:keep
    static public function gobDecode( _t:stdgo.Ref<Time>, _data:stdgo.Slice<stdgo.GoByte>):stdgo.Error {
        @:recv var _t:stdgo.Ref<Time> = _t;
        return _t.unmarshalBinary(_data);
    }
    /**
        // GobEncode implements the gob.GobEncoder interface.
    **/
    @:keep
    static public function gobEncode( _t:Time):{ var _0 : stdgo.Slice<stdgo.GoByte>; var _1 : stdgo.Error; } {
        @:recv var _t:Time = _t?.__copy__();
        return _t.marshalBinary();
    }
    /**
        // UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.
    **/
    @:keep
    static public function unmarshalBinary( _t:stdgo.Ref<Time>, _data:stdgo.Slice<stdgo.GoByte>):stdgo.Error {
        @:recv var _t:stdgo.Ref<Time> = _t;
        var _buf = _data;
        if ((_buf.length) == ((0 : stdgo.GoInt))) {
            return stdgo.errors.Errors.new_(("Time.UnmarshalBinary: no data" : stdgo.GoString));
        };
        var _version:stdgo.GoUInt8 = _buf[(0 : stdgo.GoInt)];
        if ((_version != (1 : stdgo.GoUInt8)) && (_version != (2 : stdgo.GoUInt8))) {
            return stdgo.errors.Errors.new_(("Time.UnmarshalBinary: unsupported version" : stdgo.GoString));
        };
        var _wantLen:stdgo.GoInt = (15 : stdgo.GoInt);
        if (_version == ((2 : stdgo.GoUInt8))) {
            _wantLen++;
        };
        if ((_buf.length) != (_wantLen)) {
            return stdgo.errors.Errors.new_(("Time.UnmarshalBinary: invalid length" : stdgo.GoString));
        };
        _buf = (_buf.__slice__((1 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoUInt8>);
        var _sec:stdgo.GoInt64 = (((((((_buf[(7 : stdgo.GoInt)] : stdgo.GoInt64) | ((_buf[(6 : stdgo.GoInt)] : stdgo.GoInt64) << (8i64 : stdgo.GoUInt64))) | ((_buf[(5 : stdgo.GoInt)] : stdgo.GoInt64) << (16i64 : stdgo.GoUInt64))) | ((_buf[(4 : stdgo.GoInt)] : stdgo.GoInt64) << (24i64 : stdgo.GoUInt64))) | ((_buf[(3 : stdgo.GoInt)] : stdgo.GoInt64) << (32i64 : stdgo.GoUInt64))) | ((_buf[(2 : stdgo.GoInt)] : stdgo.GoInt64) << (40i64 : stdgo.GoUInt64))) | ((_buf[(1 : stdgo.GoInt)] : stdgo.GoInt64) << (48i64 : stdgo.GoUInt64))) | ((_buf[(0 : stdgo.GoInt)] : stdgo.GoInt64) << (56i64 : stdgo.GoUInt64));
        _buf = (_buf.__slice__((8 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoUInt8>);
        var _nsec:stdgo.GoInt32 = (((_buf[(3 : stdgo.GoInt)] : stdgo.GoInt32) | ((_buf[(2 : stdgo.GoInt)] : stdgo.GoInt32) << (8i64 : stdgo.GoUInt64))) | ((_buf[(1 : stdgo.GoInt)] : stdgo.GoInt32) << (16i64 : stdgo.GoUInt64))) | ((_buf[(0 : stdgo.GoInt)] : stdgo.GoInt32) << (24i64 : stdgo.GoUInt64));
        _buf = (_buf.__slice__((4 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoUInt8>);
        var _offset:stdgo.GoInt = ((_buf[(1 : stdgo.GoInt)] : stdgo.GoInt16) | ((_buf[(0 : stdgo.GoInt)] : stdgo.GoInt16) << (8i64 : stdgo.GoUInt64)) : stdgo.GoInt) * (60 : stdgo.GoInt);
        if (_version == ((2 : stdgo.GoUInt8))) {
            _offset = _offset + ((_buf[(2 : stdgo.GoInt)] : stdgo.GoInt));
        };
        {
            var __tmp__ = (new stdgo.time.Time.Time() : stdgo.time.Time.Time);
            _t._wall = __tmp__._wall;
            _t._ext = __tmp__._ext;
            _t._loc = __tmp__._loc;
        };
        _t._wall = (_nsec : stdgo.GoUInt64);
        _t._ext = _sec;
        if (_offset == ((-60 : stdgo.GoInt))) {
            _t._setLoc((stdgo.Go.setRef(_utcLoc) : stdgo.Ref<stdgo.time.Time.Location>));
        } else {
            var __tmp__ = stdgo.time.Time.local._lookup(_t._unixSec()), __1:stdgo.GoString = __tmp__._0, _localoff:stdgo.GoInt = __tmp__._1, __2:stdgo.GoInt64 = __tmp__._2, __3:stdgo.GoInt64 = __tmp__._3, __4:Bool = __tmp__._4;
            if (_offset == (_localoff)) {
                _t._setLoc(stdgo.time.Time.local);
            } else {
                _t._setLoc(fixedZone(stdgo.Go.str()?.__copy__(), _offset));
            };
        };
        return (null : stdgo.Error);
    }
    /**
        // MarshalBinary implements the encoding.BinaryMarshaler interface.
    **/
    @:keep
    static public function marshalBinary( _t:Time):{ var _0 : stdgo.Slice<stdgo.GoByte>; var _1 : stdgo.Error; } {
        @:recv var _t:Time = _t?.__copy__();
        var _offsetMin:stdgo.GoInt16 = (0 : stdgo.GoInt16);
        var _offsetSec:stdgo.GoInt8 = (0 : stdgo.GoInt8);
        var _version:stdgo.GoUInt8 = (1 : stdgo.GoUInt8);
        if (_t.location() == (stdgo.time.Time.utc)) {
            _offsetMin = (-1 : stdgo.GoInt16);
        } else {
            var __tmp__ = _t.zone(), __1:stdgo.GoString = __tmp__._0, _offset:stdgo.GoInt = __tmp__._1;
            if (_offset % (60 : stdgo.GoInt) != ((0 : stdgo.GoInt))) {
                _version = (2 : stdgo.GoUInt8);
                _offsetSec = (_offset % (60 : stdgo.GoInt) : stdgo.GoInt8);
            };
            _offset = _offset / ((60 : stdgo.GoInt));
            if (((_offset < (-32768 : stdgo.GoInt)) || (_offset == (-1 : stdgo.GoInt))) || (_offset > (32767 : stdgo.GoInt))) {
                return { _0 : (null : stdgo.Slice<stdgo.GoUInt8>), _1 : stdgo.errors.Errors.new_(("Time.MarshalBinary: unexpected zone offset" : stdgo.GoString)) };
            };
            _offsetMin = (_offset : stdgo.GoInt16);
        };
        var _sec:stdgo.GoInt64 = _t._sec();
        var _nsec:stdgo.GoInt32 = _t._nsec();
        var _enc = (new stdgo.Slice<stdgo.GoUInt8>(
15,
15,
_version,
(_sec >> (56i64 : stdgo.GoUInt64) : stdgo.GoByte),
(_sec >> (48i64 : stdgo.GoUInt64) : stdgo.GoByte),
(_sec >> (40i64 : stdgo.GoUInt64) : stdgo.GoByte),
(_sec >> (32i64 : stdgo.GoUInt64) : stdgo.GoByte),
(_sec >> (24i64 : stdgo.GoUInt64) : stdgo.GoByte),
(_sec >> (16i64 : stdgo.GoUInt64) : stdgo.GoByte),
(_sec >> (8i64 : stdgo.GoUInt64) : stdgo.GoByte),
(_sec : stdgo.GoByte),
(_nsec >> (24i64 : stdgo.GoUInt64) : stdgo.GoByte),
(_nsec >> (16i64 : stdgo.GoUInt64) : stdgo.GoByte),
(_nsec >> (8i64 : stdgo.GoUInt64) : stdgo.GoByte),
(_nsec : stdgo.GoByte),
(_offsetMin >> (8i64 : stdgo.GoUInt64) : stdgo.GoByte),
(_offsetMin : stdgo.GoByte)) : stdgo.Slice<stdgo.GoUInt8>);
        if (_version == ((2 : stdgo.GoUInt8))) {
            _enc = (_enc.__append__((_offsetSec : stdgo.GoByte)));
        };
        return { _0 : _enc, _1 : (null : stdgo.Error) };
    }
    /**
        // UnixNano returns t as a Unix time, the number of nanoseconds elapsed
        // since January 1, 1970 UTC. The result is undefined if the Unix time
        // in nanoseconds cannot be represented by an int64 (a date before the year
        // 1678 or after 2262). Note that this means the result of calling UnixNano
        // on the zero Time is undefined. The result does not depend on the
        // location associated with t.
    **/
    @:keep
    static public function unixNano( _t:Time):stdgo.GoInt64 {
        @:recv var _t:Time = _t?.__copy__();
        return (_t._unixSec() * (1000000000i64 : stdgo.GoInt64)) + (_t._nsec() : stdgo.GoInt64);
    }
    /**
        // UnixMicro returns t as a Unix time, the number of microseconds elapsed since
        // January 1, 1970 UTC. The result is undefined if the Unix time in
        // microseconds cannot be represented by an int64 (a date before year -290307 or
        // after year 294246). The result does not depend on the location associated
        // with t.
    **/
    @:keep
    static public function unixMicro( _t:Time):stdgo.GoInt64 {
        @:recv var _t:Time = _t?.__copy__();
        return (_t._unixSec() * (1000000i64 : stdgo.GoInt64)) + ((_t._nsec() : stdgo.GoInt64) / (1000i64 : stdgo.GoInt64));
    }
    /**
        // UnixMilli returns t as a Unix time, the number of milliseconds elapsed since
        // January 1, 1970 UTC. The result is undefined if the Unix time in
        // milliseconds cannot be represented by an int64 (a date more than 292 million
        // years before or after 1970). The result does not depend on the
        // location associated with t.
    **/
    @:keep
    static public function unixMilli( _t:Time):stdgo.GoInt64 {
        @:recv var _t:Time = _t?.__copy__();
        return (_t._unixSec() * (1000i64 : stdgo.GoInt64)) + ((_t._nsec() : stdgo.GoInt64) / (1000000i64 : stdgo.GoInt64));
    }
    /**
        // Unix returns t as a Unix time, the number of seconds elapsed
        // since January 1, 1970 UTC. The result does not depend on the
        // location associated with t.
        // Unix-like operating systems often record time as a 32-bit
        // count of seconds, but since the method here returns a 64-bit
        // value it is valid for billions of years into the past or future.
    **/
    @:keep
    static public function unix( _t:Time):stdgo.GoInt64 {
        @:recv var _t:Time = _t?.__copy__();
        return _t._unixSec();
    }
    /**
        // ZoneBounds returns the bounds of the time zone in effect at time t.
        // The zone begins at start and the next zone begins at end.
        // If the zone begins at the beginning of time, start will be returned as a zero Time.
        // If the zone goes on forever, end will be returned as a zero Time.
        // The Location of the returned times will be the same as t.
    **/
    @:keep
    static public function zoneBounds( _t:Time):{ var _0 : Time; var _1 : Time; } {
        @:recv var _t:Time = _t?.__copy__();
        var _start:Time = ({} : stdgo.time.Time.Time), _end:Time = ({} : stdgo.time.Time.Time);
        var __tmp__ = _t._loc._lookup(_t._unixSec()), __1:stdgo.GoString = __tmp__._0, __2:stdgo.GoInt = __tmp__._1, _startSec:stdgo.GoInt64 = __tmp__._2, _endSec:stdgo.GoInt64 = __tmp__._3, __3:Bool = __tmp__._4;
        if (_startSec != ((-9223372036854775808i64 : stdgo.GoInt64))) {
            _start = _unixTime(_startSec, (0 : stdgo.GoInt32))?.__copy__();
            _start._setLoc(_t._loc);
        };
        if (_endSec != ((9223372036854775807i64 : stdgo.GoInt64))) {
            _end = _unixTime(_endSec, (0 : stdgo.GoInt32))?.__copy__();
            _end._setLoc(_t._loc);
        };
        return { _0 : _start, _1 : _end };
    }
    /**
        // Zone computes the time zone in effect at time t, returning the abbreviated
        // name of the zone (such as "CET") and its offset in seconds east of UTC.
    **/
    @:keep
    static public function zone( _t:Time):{ var _0 : stdgo.GoString; var _1 : stdgo.GoInt; } {
        @:recv var _t:Time = _t?.__copy__();
        var _name:stdgo.GoString = ("" : stdgo.GoString), _offset:stdgo.GoInt = (0 : stdgo.GoInt);
        {
            var __tmp__ = _t._loc._lookup(_t._unixSec());
            _name = __tmp__._0?.__copy__();
            _offset = __tmp__._1;
        };
        return { _0 : _name, _1 : _offset };
    }
    /**
        // Location returns the time zone information associated with t.
    **/
    @:keep
    static public function location( _t:Time):stdgo.Ref<Location> {
        @:recv var _t:Time = _t?.__copy__();
        var _l = _t._loc;
        if (_l == null || (_l : Dynamic).__nil__) {
            _l = stdgo.time.Time.utc;
        };
        return _l;
    }
    /**
        // In returns a copy of t representing the same time instant, but
        // with the copy's location information set to loc for display
        // purposes.
        //
        // In panics if loc is nil.
    **/
    @:keep
    static public function in_( _t:Time, _loc:stdgo.Ref<Location>):Time {
        @:recv var _t:Time = _t?.__copy__();
        if (_loc == null || (_loc : Dynamic).__nil__) {
            throw stdgo.Go.toInterface(("time: missing Location in call to Time.In" : stdgo.GoString));
        };
        _t._setLoc(_loc);
        return _t?.__copy__();
    }
    /**
        // Local returns t with the location set to local time.
    **/
    @:keep
    static public function local( _t:Time):Time {
        @:recv var _t:Time = _t?.__copy__();
        _t._setLoc(stdgo.time.Time.local);
        return _t?.__copy__();
    }
    /**
        // UTC returns t with the location set to UTC.
    **/
    @:keep
    static public function utc( _t:Time):Time {
        @:recv var _t:Time = _t?.__copy__();
        _t._setLoc((stdgo.Go.setRef(_utcLoc) : stdgo.Ref<stdgo.time.Time.Location>));
        return _t?.__copy__();
    }
    /**
        // date computes the year, day of year, and when full=true,
        // the month and day in which t occurs.
    **/
    @:keep
    static public function _date( _t:Time, _full:Bool):{ var _0 : stdgo.GoInt; var _1 : Month; var _2 : stdgo.GoInt; var _3 : stdgo.GoInt; } {
        @:recv var _t:Time = _t?.__copy__();
        var _year:stdgo.GoInt = (0 : stdgo.GoInt), _month:Month = ((0 : stdgo.GoInt) : stdgo.time.Time.Month), _day:stdgo.GoInt = (0 : stdgo.GoInt), _yday:stdgo.GoInt = (0 : stdgo.GoInt);
        return _absDate(_t._abs(), _full);
    }
    /**
        // AddDate returns the time corresponding to adding the
        // given number of years, months, and days to t.
        // For example, AddDate(-1, 2, 3) applied to January 1, 2011
        // returns March 4, 2010.
        //
        // AddDate normalizes its result in the same way that Date does,
        // so, for example, adding one month to October 31 yields
        // December 1, the normalized form for November 31.
    **/
    @:keep
    static public function addDate( _t:Time, _years:stdgo.GoInt, _months:stdgo.GoInt, _days:stdgo.GoInt):Time {
        @:recv var _t:Time = _t?.__copy__();
        var __tmp__ = _t.date(), _year:stdgo.GoInt = __tmp__._0, _month:stdgo.time.Time.Month = __tmp__._1, _day:stdgo.GoInt = __tmp__._2;
        var __tmp__ = _t.clock(), _hour:stdgo.GoInt = __tmp__._0, _min:stdgo.GoInt = __tmp__._1, _sec:stdgo.GoInt = __tmp__._2;
        return stdgo.time.Time.date(_year + _years, _month + (_months : Month), _day + _days, _hour, _min, _sec, (_t._nsec() : stdgo.GoInt), _t.location())?.__copy__();
    }
    /**
        // Sub returns the duration t-u. If the result exceeds the maximum (or minimum)
        // value that can be stored in a Duration, the maximum (or minimum) duration
        // will be returned.
        // To compute t-d for a duration d, use t.Add(-d).
    **/
    @:keep
    static public function sub( _t:Time, _u:Time):Duration {
        @:recv var _t:Time = _t?.__copy__();
        if (_t._wall & _u._wall & (-9223372036854775808i64 : stdgo.GoUInt64) != ((0i64 : stdgo.GoUInt64))) {
            var _te:stdgo.GoInt64 = _t._ext;
            var _ue:stdgo.GoInt64 = _u._ext;
            var _d:stdgo.time.Time.Duration = (_te - _ue : Duration);
            if ((_d < (0i64 : stdgo.time.Time.Duration)) && (_te > _ue)) {
                return (9223372036854775807i64 : stdgo.time.Time.Duration);
            };
            if ((_d > (0i64 : stdgo.time.Time.Duration)) && (_te < _ue)) {
                return (-9223372036854775808i64 : stdgo.time.Time.Duration);
            };
            return _d;
        };
        var _d:stdgo.time.Time.Duration = ((_t._sec() - _u._sec() : Duration) * (1000000000i64 : stdgo.time.Time.Duration)) + (_t._nsec() - _u._nsec() : Duration);
        if (_u.add(_d).equal(_t?.__copy__())) {
            return _d;
        } else if (_t.before(_u?.__copy__())) {
            return (-9223372036854775808i64 : stdgo.time.Time.Duration);
        } else {
            return (9223372036854775807i64 : stdgo.time.Time.Duration);
        };
    }
    /**
        // Add returns the time t+d.
    **/
    @:keep
    static public function add( _t:Time, _d:Duration):Time {
        @:recv var _t:Time = _t?.__copy__();
        var _dsec:stdgo.GoInt64 = (_d / (1000000000i64 : stdgo.time.Time.Duration) : stdgo.GoInt64);
        var _nsec:stdgo.GoInt32 = _t._nsec() + (_d % (1000000000i64 : stdgo.time.Time.Duration) : stdgo.GoInt32);
        if (_nsec >= (1000000000 : stdgo.GoInt32)) {
            _dsec++;
            _nsec = _nsec - ((1000000000 : stdgo.GoInt32));
        } else if (_nsec < (0 : stdgo.GoInt32)) {
            _dsec--;
            _nsec = _nsec + ((1000000000 : stdgo.GoInt32));
        };
        _t._wall = (_t._wall & ((1073741823i64 : stdgo.GoUInt64) ^ (-1i32 : stdgo.GoInt))) | (_nsec : stdgo.GoUInt64);
        _t._addSec(_dsec);
        if (_t._wall & (-9223372036854775808i64 : stdgo.GoUInt64) != ((0i64 : stdgo.GoUInt64))) {
            var _te:stdgo.GoInt64 = _t._ext + (_d : stdgo.GoInt64);
            if (((_d < (0i64 : stdgo.time.Time.Duration)) && (_te > _t._ext)) || ((_d > (0i64 : stdgo.time.Time.Duration)) && (_te < _t._ext))) {
                _t._stripMono();
            } else {
                _t._ext = _te;
            };
        };
        return _t?.__copy__();
    }
    /**
        // YearDay returns the day of the year specified by t, in the range [1,365] for non-leap years,
        // and [1,366] in leap years.
    **/
    @:keep
    static public function yearDay( _t:Time):stdgo.GoInt {
        @:recv var _t:Time = _t?.__copy__();
        var __tmp__ = _t._date(false), __1:stdgo.GoInt = __tmp__._0, __2:stdgo.time.Time.Month = __tmp__._1, __3:stdgo.GoInt = __tmp__._2, _yday:stdgo.GoInt = __tmp__._3;
        return _yday + (1 : stdgo.GoInt);
    }
    /**
        // Nanosecond returns the nanosecond offset within the second specified by t,
        // in the range [0, 999999999].
    **/
    @:keep
    static public function nanosecond( _t:Time):stdgo.GoInt {
        @:recv var _t:Time = _t?.__copy__();
        return (_t._nsec() : stdgo.GoInt);
    }
    /**
        // Second returns the second offset within the minute specified by t, in the range [0, 59].
    **/
    @:keep
    static public function second( _t:Time):stdgo.GoInt {
        @:recv var _t:Time = _t?.__copy__();
        return (_t._abs() % (60i64 : stdgo.GoUInt64) : stdgo.GoInt);
    }
    /**
        // Minute returns the minute offset within the hour specified by t, in the range [0, 59].
    **/
    @:keep
    static public function minute( _t:Time):stdgo.GoInt {
        @:recv var _t:Time = _t?.__copy__();
        return (_t._abs() % (3600i64 : stdgo.GoUInt64) : stdgo.GoInt) / (60 : stdgo.GoInt);
    }
    /**
        // Hour returns the hour within the day specified by t, in the range [0, 23].
    **/
    @:keep
    static public function hour( _t:Time):stdgo.GoInt {
        @:recv var _t:Time = _t?.__copy__();
        return (_t._abs() % (86400i64 : stdgo.GoUInt64) : stdgo.GoInt) / (3600 : stdgo.GoInt);
    }
    /**
        // Clock returns the hour, minute, and second within the day specified by t.
    **/
    @:keep
    static public function clock( _t:Time):{ var _0 : stdgo.GoInt; var _1 : stdgo.GoInt; var _2 : stdgo.GoInt; } {
        @:recv var _t:Time = _t?.__copy__();
        var _hour:stdgo.GoInt = (0 : stdgo.GoInt), _min:stdgo.GoInt = (0 : stdgo.GoInt), _sec:stdgo.GoInt = (0 : stdgo.GoInt);
        return _absClock(_t._abs());
    }
    /**
        // ISOWeek returns the ISO 8601 year and week number in which t occurs.
        // Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to
        // week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1
        // of year n+1.
    **/
    @:keep
    static public function isoweek( _t:Time):{ var _0 : stdgo.GoInt; var _1 : stdgo.GoInt; } {
        @:recv var _t:Time = _t?.__copy__();
        var _year:stdgo.GoInt = (0 : stdgo.GoInt), _week:stdgo.GoInt = (0 : stdgo.GoInt);
        var _abs:stdgo.GoUInt64 = _t._abs();
        var _d:stdgo.time.Time.Weekday = (4 : stdgo.time.Time.Weekday) - _absWeekday(_abs);
        if (_d == ((4 : stdgo.time.Time.Weekday))) {
            _d = (-3 : stdgo.time.Time.Weekday);
        };
        _abs = _abs + ((_d : stdgo.GoUInt64) * (86400i64 : stdgo.GoUInt64));
        var __tmp__ = _absDate(_abs, false), _year:stdgo.GoInt = __tmp__._0, __1:stdgo.time.Time.Month = __tmp__._1, __2:stdgo.GoInt = __tmp__._2, _yday:stdgo.GoInt = __tmp__._3;
        return { _0 : _year, _1 : (_yday / (7 : stdgo.GoInt)) + (1 : stdgo.GoInt) };
    }
    /**
        // Weekday returns the day of the week specified by t.
    **/
    @:keep
    static public function weekday( _t:Time):Weekday {
        @:recv var _t:Time = _t?.__copy__();
        return _absWeekday(_t._abs());
    }
    /**
        // Day returns the day of the month specified by t.
    **/
    @:keep
    static public function day( _t:Time):stdgo.GoInt {
        @:recv var _t:Time = _t?.__copy__();
        var __tmp__ = _t._date(true), __1:stdgo.GoInt = __tmp__._0, __2:stdgo.time.Time.Month = __tmp__._1, _day:stdgo.GoInt = __tmp__._2, __3:stdgo.GoInt = __tmp__._3;
        return _day;
    }
    /**
        // Month returns the month of the year specified by t.
    **/
    @:keep
    static public function month( _t:Time):Month {
        @:recv var _t:Time = _t?.__copy__();
        var __tmp__ = _t._date(true), __1:stdgo.GoInt = __tmp__._0, _month:stdgo.time.Time.Month = __tmp__._1, __2:stdgo.GoInt = __tmp__._2, __3:stdgo.GoInt = __tmp__._3;
        return _month;
    }
    /**
        // Year returns the year in which t occurs.
    **/
    @:keep
    static public function year( _t:Time):stdgo.GoInt {
        @:recv var _t:Time = _t?.__copy__();
        var __tmp__ = _t._date(false), _year:stdgo.GoInt = __tmp__._0, __1:stdgo.time.Time.Month = __tmp__._1, __2:stdgo.GoInt = __tmp__._2, __3:stdgo.GoInt = __tmp__._3;
        return _year;
    }
    /**
        // Date returns the year, month, and day in which t occurs.
    **/
    @:keep
    static public function date( _t:Time):{ var _0 : stdgo.GoInt; var _1 : Month; var _2 : stdgo.GoInt; } {
        @:recv var _t:Time = _t?.__copy__();
        var _year:stdgo.GoInt = (0 : stdgo.GoInt), _month:Month = ((0 : stdgo.GoInt) : stdgo.time.Time.Month), _day:stdgo.GoInt = (0 : stdgo.GoInt);
        {
            var __tmp__ = _t._date(true);
            _year = __tmp__._0;
            _month = __tmp__._1;
            _day = __tmp__._2;
        };
        return { _0 : _year, _1 : _month, _2 : _day };
    }
    /**
        // locabs is a combination of the Zone and abs methods,
        // extracting both return values from a single zone lookup.
    **/
    @:keep
    static public function _locabs( _t:Time):{ var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoUInt64; } {
        @:recv var _t:Time = _t?.__copy__();
        var _name:stdgo.GoString = ("" : stdgo.GoString), _offset:stdgo.GoInt = (0 : stdgo.GoInt), _abs:stdgo.GoUInt64 = (0 : stdgo.GoUInt64);
        var _l = _t._loc;
        if (((_l == null) || (_l : Dynamic).__nil__) || (_l == (stdgo.Go.setRef(_localLoc) : stdgo.Ref<stdgo.time.Time.Location>))) {
            _l = _l._get();
        };
        var _sec:stdgo.GoInt64 = _t._unixSec();
        if (_l != ((stdgo.Go.setRef(_utcLoc) : stdgo.Ref<stdgo.time.Time.Location>))) {
            if ((((_l._cacheZone != null) && ((_l._cacheZone : Dynamic).__nil__ == null || !(_l._cacheZone : Dynamic).__nil__)) && (_l._cacheStart <= _sec)) && (_sec < _l._cacheEnd)) {
                _name = _l._cacheZone._name?.__copy__();
                _offset = _l._cacheZone._offset;
            } else {
                {
                    var __tmp__ = _l._lookup(_sec);
                    _name = __tmp__._0?.__copy__();
                    _offset = __tmp__._1;
                };
            };
            _sec = _sec + ((_offset : stdgo.GoInt64));
        } else {
            _name = ("UTC" : stdgo.GoString);
        };
        _abs = (_sec + (9223372028715321600i64 : stdgo.GoInt64) : stdgo.GoUInt64);
        return { _0 : _name, _1 : _offset, _2 : _abs };
    }
    /**
        // abs returns the time t as an absolute time, adjusted by the zone offset.
        // It is called when computing a presentation property like Month or Hour.
    **/
    @:keep
    static public function _abs( _t:Time):stdgo.GoUInt64 {
        @:recv var _t:Time = _t?.__copy__();
        var _l = _t._loc;
        if (((_l == null) || (_l : Dynamic).__nil__) || (_l == (stdgo.Go.setRef(_localLoc) : stdgo.Ref<stdgo.time.Time.Location>))) {
            _l = _l._get();
        };
        var _sec:stdgo.GoInt64 = _t._unixSec();
        if (_l != ((stdgo.Go.setRef(_utcLoc) : stdgo.Ref<stdgo.time.Time.Location>))) {
            if ((((_l._cacheZone != null) && ((_l._cacheZone : Dynamic).__nil__ == null || !(_l._cacheZone : Dynamic).__nil__)) && (_l._cacheStart <= _sec)) && (_sec < _l._cacheEnd)) {
                _sec = _sec + ((_l._cacheZone._offset : stdgo.GoInt64));
            } else {
                var __tmp__ = _l._lookup(_sec), __1:stdgo.GoString = __tmp__._0, _offset:stdgo.GoInt = __tmp__._1, __2:stdgo.GoInt64 = __tmp__._2, __3:stdgo.GoInt64 = __tmp__._3, __4:Bool = __tmp__._4;
                _sec = _sec + ((_offset : stdgo.GoInt64));
            };
        };
        return (_sec + (9223372028715321600i64 : stdgo.GoInt64) : stdgo.GoUInt64);
    }
    /**
        // IsZero reports whether t represents the zero time instant,
        // January 1, year 1, 00:00:00 UTC.
    **/
    @:keep
    static public function isZero( _t:Time):Bool {
        @:recv var _t:Time = _t?.__copy__();
        return (_t._sec() == (0i64 : stdgo.GoInt64)) && (_t._nsec() == (0 : stdgo.GoInt32));
    }
    /**
        // Equal reports whether t and u represent the same time instant.
        // Two times can be equal even if they are in different locations.
        // For example, 6:00 +0200 and 4:00 UTC are Equal.
        // See the documentation on the Time type for the pitfalls of using == with
        // Time values; most code should use Equal instead.
    **/
    @:keep
    static public function equal( _t:Time, _u:Time):Bool {
        @:recv var _t:Time = _t?.__copy__();
        if (_t._wall & _u._wall & (-9223372036854775808i64 : stdgo.GoUInt64) != ((0i64 : stdgo.GoUInt64))) {
            return _t._ext == (_u._ext);
        };
        return (_t._sec() == _u._sec()) && (_t._nsec() == _u._nsec());
    }
    /**
        // Compare compares the time instant t with u. If t is before u, it returns -1;
        // if t is after u, it returns +1; if they're the same, it returns 0.
    **/
    @:keep
    static public function compare( _t:Time, _u:Time):stdgo.GoInt {
        @:recv var _t:Time = _t?.__copy__();
        var __0:stdgo.GoInt64 = (0 : stdgo.GoInt64), __1:stdgo.GoInt64 = (0 : stdgo.GoInt64), _uc:stdgo.GoInt64 = __1, _tc:stdgo.GoInt64 = __0;
        if (_t._wall & _u._wall & (-9223372036854775808i64 : stdgo.GoUInt64) != ((0i64 : stdgo.GoUInt64))) {
            {
                final __tmp__0 = _t._ext;
                final __tmp__1 = _u._ext;
                _tc = __tmp__0;
                _uc = __tmp__1;
            };
        } else {
            {
                final __tmp__0 = _t._sec();
                final __tmp__1 = _u._sec();
                _tc = __tmp__0;
                _uc = __tmp__1;
            };
            if (_tc == (_uc)) {
                {
                    final __tmp__0 = (_t._nsec() : stdgo.GoInt64);
                    final __tmp__1 = (_u._nsec() : stdgo.GoInt64);
                    _tc = __tmp__0;
                    _uc = __tmp__1;
                };
            };
        };
        if (_tc < _uc) {
            return (-1 : stdgo.GoInt);
        } else if (_tc > _uc) {
            return (1 : stdgo.GoInt);
        };
        return (0 : stdgo.GoInt);
    }
    /**
        // Before reports whether the time instant t is before u.
    **/
    @:keep
    static public function before( _t:Time, _u:Time):Bool {
        @:recv var _t:Time = _t?.__copy__();
        if (_t._wall & _u._wall & (-9223372036854775808i64 : stdgo.GoUInt64) != ((0i64 : stdgo.GoUInt64))) {
            return _t._ext < _u._ext;
        };
        var _ts:stdgo.GoInt64 = _t._sec();
        var _us:stdgo.GoInt64 = _u._sec();
        return (_ts < _us) || ((_ts == _us) && (_t._nsec() < _u._nsec()));
    }
    /**
        // After reports whether the time instant t is after u.
    **/
    @:keep
    static public function after( _t:Time, _u:Time):Bool {
        @:recv var _t:Time = _t?.__copy__();
        if (_t._wall & _u._wall & (-9223372036854775808i64 : stdgo.GoUInt64) != ((0i64 : stdgo.GoUInt64))) {
            return _t._ext > _u._ext;
        };
        var _ts:stdgo.GoInt64 = _t._sec();
        var _us:stdgo.GoInt64 = _u._sec();
        return (_ts > _us) || ((_ts == _us) && (_t._nsec() > _u._nsec()));
    }
    /**
        // mono returns t's monotonic clock reading.
        // It returns 0 for a missing reading.
        // This function is used only for testing,
        // so it's OK that technically 0 is a valid
        // monotonic clock reading as well.
    **/
    @:keep
    static public function _mono( _t:stdgo.Ref<Time>):stdgo.GoInt64 {
        @:recv var _t:stdgo.Ref<Time> = _t;
        if (_t._wall & (-9223372036854775808i64 : stdgo.GoUInt64) == ((0i64 : stdgo.GoUInt64))) {
            return (0i64 : stdgo.GoInt64);
        };
        return _t._ext;
    }
    /**
        // setMono sets the monotonic clock reading in t.
        // If t cannot hold a monotonic clock reading,
        // because its wall time is too large,
        // setMono is a no-op.
    **/
    @:keep
    static public function _setMono( _t:stdgo.Ref<Time>, _m:stdgo.GoInt64):Void {
        @:recv var _t:stdgo.Ref<Time> = _t;
        if (_t._wall & (-9223372036854775808i64 : stdgo.GoUInt64) == ((0i64 : stdgo.GoUInt64))) {
            var _sec:stdgo.GoInt64 = _t._ext;
            if ((_sec < (59453308800i64 : stdgo.GoInt64)) || ((68043243391i64 : stdgo.GoInt64) < _sec)) {
                return;
            };
            _t._wall = _t._wall | ((-9223372036854775808i64 : stdgo.GoUInt64) | ((_sec - (59453308800i64 : stdgo.GoInt64) : stdgo.GoUInt64) << (30i64 : stdgo.GoUInt64)));
        };
        _t._ext = _m;
    }
    /**
        // stripMono strips the monotonic clock reading in t.
    **/
    @:keep
    static public function _stripMono( _t:stdgo.Ref<Time>):Void {
        @:recv var _t:stdgo.Ref<Time> = _t;
        if (_t._wall & (-9223372036854775808i64 : stdgo.GoUInt64) != ((0i64 : stdgo.GoUInt64))) {
            _t._ext = _t._sec();
            _t._wall = _t._wall & ((1073741823i64 : stdgo.GoUInt64));
        };
    }
    /**
        // setLoc sets the location associated with the time.
    **/
    @:keep
    static public function _setLoc( _t:stdgo.Ref<Time>, _loc:stdgo.Ref<Location>):Void {
        @:recv var _t:stdgo.Ref<Time> = _t;
        if (_loc == ((stdgo.Go.setRef(_utcLoc) : stdgo.Ref<stdgo.time.Time.Location>))) {
            _loc = null;
        };
        _t._stripMono();
        _t._loc = _loc;
    }
    /**
        // addSec adds d seconds to the time.
    **/
    @:keep
    static public function _addSec( _t:stdgo.Ref<Time>, _d:stdgo.GoInt64):Void {
        @:recv var _t:stdgo.Ref<Time> = _t;
        if (_t._wall & (-9223372036854775808i64 : stdgo.GoUInt64) != ((0i64 : stdgo.GoUInt64))) {
            var _sec:stdgo.GoInt64 = ((_t._wall << (1i64 : stdgo.GoUInt64)) >> (31i64 : stdgo.GoUInt64) : stdgo.GoInt64);
            var _dsec:stdgo.GoInt64 = _sec + _d;
            if (((0i64 : stdgo.GoInt64) <= _dsec) && (_dsec <= (8589934591i64 : stdgo.GoInt64))) {
                _t._wall = ((_t._wall & (1073741823i64 : stdgo.GoUInt64)) | ((_dsec : stdgo.GoUInt64) << (30i64 : stdgo.GoUInt64))) | (-9223372036854775808i64 : stdgo.GoUInt64);
                return;
            };
            _t._stripMono();
        };
        var _sum:stdgo.GoInt64 = _t._ext + _d;
        if ((_sum > _t._ext) == ((_d > (0i64 : stdgo.GoInt64)))) {
            _t._ext = _sum;
        } else if (_d > (0i64 : stdgo.GoInt64)) {
            _t._ext = (9223372036854775807i64 : stdgo.GoInt64);
        } else {
            _t._ext = (-9223372036854775807i64 : stdgo.GoInt64);
        };
    }
    /**
        // unixSec returns the time's seconds since Jan 1 1970 (Unix time).
    **/
    @:keep
    static public function _unixSec( _t:stdgo.Ref<Time>):stdgo.GoInt64 {
        @:recv var _t:stdgo.Ref<Time> = _t;
        return _t._sec() + (-62135596800i64 : stdgo.GoInt64);
    }
    /**
        // sec returns the time's seconds since Jan 1 year 1.
    **/
    @:keep
    static public function _sec( _t:stdgo.Ref<Time>):stdgo.GoInt64 {
        @:recv var _t:stdgo.Ref<Time> = _t;
        if (_t._wall & (-9223372036854775808i64 : stdgo.GoUInt64) != ((0i64 : stdgo.GoUInt64))) {
            return (59453308800i64 : stdgo.GoInt64) + ((_t._wall << (1i64 : stdgo.GoUInt64)) >> (31i64 : stdgo.GoUInt64) : stdgo.GoInt64);
        };
        return _t._ext;
    }
    /**
        // nsec returns the time's nanoseconds.
    **/
    @:keep
    static public function _nsec( _t:stdgo.Ref<Time>):stdgo.GoInt32 {
        @:recv var _t:stdgo.Ref<Time> = _t;
        return (_t._wall & (1073741823i64 : stdgo.GoUInt64) : stdgo.GoInt32);
    }
    @:keep
    static public function _appendStrictRFC3339( _t:Time, _b:stdgo.Slice<stdgo.GoByte>):{ var _0 : stdgo.Slice<stdgo.GoByte>; var _1 : stdgo.Error; } {
        @:recv var _t:Time = _t?.__copy__();
        var _n0:stdgo.GoInt = (_b.length);
        _b = _t._appendFormatRFC3339(_b, true);
        var _num2 = function(_b:stdgo.Slice<stdgo.GoByte>):stdgo.GoByte {
            return ((10 : stdgo.GoUInt8) * (_b[(0 : stdgo.GoInt)] - (48 : stdgo.GoUInt8))) + (_b[(1 : stdgo.GoInt)] - (48 : stdgo.GoUInt8));
        };
        if (_b[(_n0 + (("9999" : stdgo.GoString).length) : stdgo.GoInt)] != ((45 : stdgo.GoUInt8))) {
            return { _0 : _b, _1 : stdgo.errors.Errors.new_(("year outside of range [0,9999]" : stdgo.GoString)) };
        } else if (_b[((_b.length) - (1 : stdgo.GoInt) : stdgo.GoInt)] != ((90 : stdgo.GoUInt8))) {
            var _c:stdgo.GoUInt8 = _b[((_b.length) - (("Z07:00" : stdgo.GoString).length) : stdgo.GoInt)];
            if ((((48 : stdgo.GoUInt8) <= _c) && (_c <= (57 : stdgo.GoUInt8))) || (_num2((_b.__slice__((_b.length) - (("07:00" : stdgo.GoString).length)) : stdgo.Slice<stdgo.GoUInt8>)) >= (24 : stdgo.GoUInt8))) {
                return { _0 : _b, _1 : stdgo.errors.Errors.new_(("timezone hour outside of range [0,23]" : stdgo.GoString)) };
            };
        };
        return { _0 : _b, _1 : (null : stdgo.Error) };
    }
    @:keep
    static public function _appendFormatRFC3339( _t:Time, _b:stdgo.Slice<stdgo.GoByte>, _nanos:Bool):stdgo.Slice<stdgo.GoByte> {
        @:recv var _t:Time = _t?.__copy__();
        var __tmp__ = _t._locabs(), __1:stdgo.GoString = __tmp__._0, _offset:stdgo.GoInt = __tmp__._1, _abs:stdgo.GoUInt64 = __tmp__._2;
        var __tmp__ = _absDate(_abs, true), _year:stdgo.GoInt = __tmp__._0, _month:stdgo.time.Time.Month = __tmp__._1, _day:stdgo.GoInt = __tmp__._2, __2:stdgo.GoInt = __tmp__._3;
        _b = _appendInt(_b, _year, (4 : stdgo.GoInt));
        _b = (_b.__append__((45 : stdgo.GoUInt8)));
        _b = _appendInt(_b, (_month : stdgo.GoInt), (2 : stdgo.GoInt));
        _b = (_b.__append__((45 : stdgo.GoUInt8)));
        _b = _appendInt(_b, _day, (2 : stdgo.GoInt));
        _b = (_b.__append__((84 : stdgo.GoUInt8)));
        var __tmp__ = _absClock(_abs), _hour:stdgo.GoInt = __tmp__._0, _min:stdgo.GoInt = __tmp__._1, _sec:stdgo.GoInt = __tmp__._2;
        _b = _appendInt(_b, _hour, (2 : stdgo.GoInt));
        _b = (_b.__append__((58 : stdgo.GoUInt8)));
        _b = _appendInt(_b, _min, (2 : stdgo.GoInt));
        _b = (_b.__append__((58 : stdgo.GoUInt8)));
        _b = _appendInt(_b, _sec, (2 : stdgo.GoInt));
        if (_nanos) {
            var _std:stdgo.GoInt = _stdFracSecond((35 : stdgo.GoInt), (9 : stdgo.GoInt), (46 : stdgo.GoInt));
            _b = _appendNano(_b, _t.nanosecond(), _std);
        };
        if (_offset == ((0 : stdgo.GoInt))) {
            return (_b.__append__((90 : stdgo.GoUInt8)));
        };
        var _zone:stdgo.GoInt = _offset / (60 : stdgo.GoInt);
        if (_zone < (0 : stdgo.GoInt)) {
            _b = (_b.__append__((45 : stdgo.GoUInt8)));
            _zone = -_zone;
        } else {
            _b = (_b.__append__((43 : stdgo.GoUInt8)));
        };
        _b = _appendInt(_b, _zone / (60 : stdgo.GoInt), (2 : stdgo.GoInt));
        _b = (_b.__append__((58 : stdgo.GoUInt8)));
        _b = _appendInt(_b, _zone % (60 : stdgo.GoInt), (2 : stdgo.GoInt));
        return _b;
    }
    @:keep
    static public function _appendFormat( _t:Time, _b:stdgo.Slice<stdgo.GoByte>, _layout:stdgo.GoString):stdgo.Slice<stdgo.GoByte> {
        @:recv var _t:Time = _t?.__copy__();
        var __0:stdgo.GoInt = (-1 : stdgo.GoInt), __1:Month = ((0 : stdgo.GoInt) : stdgo.time.Time.Month), __2:stdgo.GoInt = (0 : stdgo.GoInt), __3:stdgo.GoInt = (0 : stdgo.GoInt), __4:stdgo.GoInt = (-1 : stdgo.GoInt), __5:stdgo.GoInt = (0 : stdgo.GoInt), __6:stdgo.GoInt = (0 : stdgo.GoInt), __tmp__ = _t._locabs(), _name:stdgo.GoString = __tmp__._0, _offset:stdgo.GoInt = __tmp__._1, _abs:stdgo.GoUInt64 = __tmp__._2, _sec:stdgo.GoInt = __6, _min:stdgo.GoInt = __5, _hour:stdgo.GoInt = __4, _yday:stdgo.GoInt = __3, _day:stdgo.GoInt = __2, _month:Month = __1, _year:stdgo.GoInt = __0;
        while (_layout != (stdgo.Go.str())) {
            var __tmp__ = _nextStdChunk(_layout?.__copy__()), _prefix:stdgo.GoString = __tmp__._0, _std:stdgo.GoInt = __tmp__._1, _suffix:stdgo.GoString = __tmp__._2;
            if (_prefix != (stdgo.Go.str())) {
                _b = (_b.__append__(..._prefix.__toArray__()));
            };
            if (_std == ((0 : stdgo.GoInt))) {
                break;
            };
            _layout = _suffix?.__copy__();
            if ((_year < (0 : stdgo.GoInt)) && ((_std & (256 : stdgo.GoInt)) != (0 : stdgo.GoInt))) {
                {
                    var __tmp__ = _absDate(_abs, true);
                    _year = __tmp__._0;
                    _month = __tmp__._1;
                    _day = __tmp__._2;
                    _yday = __tmp__._3;
                };
                _yday++;
            };
            if ((_hour < (0 : stdgo.GoInt)) && ((_std & (512 : stdgo.GoInt)) != (0 : stdgo.GoInt))) {
                {
                    var __tmp__ = _absClock(_abs);
                    _hour = __tmp__._0;
                    _min = __tmp__._1;
                    _sec = __tmp__._2;
                };
            };
            {
                var __switchIndex__ = -1;
                var __run__ = true;
                while (__run__) {
                    __run__ = false;
                    {
                        final __value__ = _std & (65535 : stdgo.GoInt);
                        if (__value__ == ((276 : stdgo.GoInt))) {
                            var _y:stdgo.GoInt = _year;
                            if (_y < (0 : stdgo.GoInt)) {
                                _y = -_y;
                            };
                            _b = _appendInt(_b, _y % (100 : stdgo.GoInt), (2 : stdgo.GoInt));
                            break;
                        } else if (__value__ == ((275 : stdgo.GoInt))) {
                            _b = _appendInt(_b, _year, (4 : stdgo.GoInt));
                            break;
                        } else if (__value__ == ((258 : stdgo.GoInt))) {
                            _b = (_b.__append__(...((_month.string() : stdgo.GoString).__slice__(0, (3 : stdgo.GoInt)) : stdgo.GoString).__toArray__()));
                            break;
                        } else if (__value__ == ((257 : stdgo.GoInt))) {
                            var _m:stdgo.GoString = (_month.string() : stdgo.GoString)?.__copy__();
                            _b = (_b.__append__(..._m.__toArray__()));
                            break;
                        } else if (__value__ == ((259 : stdgo.GoInt))) {
                            _b = _appendInt(_b, (_month : stdgo.GoInt), (0 : stdgo.GoInt));
                            break;
                        } else if (__value__ == ((260 : stdgo.GoInt))) {
                            _b = _appendInt(_b, (_month : stdgo.GoInt), (2 : stdgo.GoInt));
                            break;
                        } else if (__value__ == ((262 : stdgo.GoInt))) {
                            _b = (_b.__append__(...((_absWeekday(_abs).string() : stdgo.GoString).__slice__(0, (3 : stdgo.GoInt)) : stdgo.GoString).__toArray__()));
                            break;
                        } else if (__value__ == ((261 : stdgo.GoInt))) {
                            var _s:stdgo.GoString = (_absWeekday(_abs).string() : stdgo.GoString)?.__copy__();
                            _b = (_b.__append__(..._s.__toArray__()));
                            break;
                        } else if (__value__ == ((263 : stdgo.GoInt))) {
                            _b = _appendInt(_b, _day, (0 : stdgo.GoInt));
                            break;
                        } else if (__value__ == ((264 : stdgo.GoInt))) {
                            if (_day < (10 : stdgo.GoInt)) {
                                _b = (_b.__append__((32 : stdgo.GoUInt8)));
                            };
                            _b = _appendInt(_b, _day, (0 : stdgo.GoInt));
                            break;
                        } else if (__value__ == ((265 : stdgo.GoInt))) {
                            _b = _appendInt(_b, _day, (2 : stdgo.GoInt));
                            break;
                        } else if (__value__ == ((266 : stdgo.GoInt))) {
                            if (_yday < (100 : stdgo.GoInt)) {
                                _b = (_b.__append__((32 : stdgo.GoUInt8)));
                                if (_yday < (10 : stdgo.GoInt)) {
                                    _b = (_b.__append__((32 : stdgo.GoUInt8)));
                                };
                            };
                            _b = _appendInt(_b, _yday, (0 : stdgo.GoInt));
                            break;
                        } else if (__value__ == ((267 : stdgo.GoInt))) {
                            _b = _appendInt(_b, _yday, (3 : stdgo.GoInt));
                            break;
                        } else if (__value__ == ((524 : stdgo.GoInt))) {
                            _b = _appendInt(_b, _hour, (2 : stdgo.GoInt));
                            break;
                        } else if (__value__ == ((525 : stdgo.GoInt))) {
                            var _hr:stdgo.GoInt = _hour % (12 : stdgo.GoInt);
                            if (_hr == ((0 : stdgo.GoInt))) {
                                _hr = (12 : stdgo.GoInt);
                            };
                            _b = _appendInt(_b, _hr, (0 : stdgo.GoInt));
                            break;
                        } else if (__value__ == ((526 : stdgo.GoInt))) {
                            var _hr:stdgo.GoInt = _hour % (12 : stdgo.GoInt);
                            if (_hr == ((0 : stdgo.GoInt))) {
                                _hr = (12 : stdgo.GoInt);
                            };
                            _b = _appendInt(_b, _hr, (2 : stdgo.GoInt));
                            break;
                        } else if (__value__ == ((527 : stdgo.GoInt))) {
                            _b = _appendInt(_b, _min, (0 : stdgo.GoInt));
                            break;
                        } else if (__value__ == ((528 : stdgo.GoInt))) {
                            _b = _appendInt(_b, _min, (2 : stdgo.GoInt));
                            break;
                        } else if (__value__ == ((529 : stdgo.GoInt))) {
                            _b = _appendInt(_b, _sec, (0 : stdgo.GoInt));
                            break;
                        } else if (__value__ == ((530 : stdgo.GoInt))) {
                            _b = _appendInt(_b, _sec, (2 : stdgo.GoInt));
                            break;
                        } else if (__value__ == ((533 : stdgo.GoInt))) {
                            if (_hour >= (12 : stdgo.GoInt)) {
                                _b = (_b.__append__(...("PM" : stdgo.GoString).__toArray__()));
                            } else {
                                _b = (_b.__append__(...("AM" : stdgo.GoString).__toArray__()));
                            };
                            break;
                        } else if (__value__ == ((534 : stdgo.GoInt))) {
                            if (_hour >= (12 : stdgo.GoInt)) {
                                _b = (_b.__append__(...("pm" : stdgo.GoString).__toArray__()));
                            } else {
                                _b = (_b.__append__(...("am" : stdgo.GoString).__toArray__()));
                            };
                            break;
                        } else if (__value__ == ((24 : stdgo.GoInt)) || __value__ == ((27 : stdgo.GoInt)) || __value__ == ((25 : stdgo.GoInt)) || __value__ == ((26 : stdgo.GoInt)) || __value__ == ((28 : stdgo.GoInt)) || __value__ == ((29 : stdgo.GoInt)) || __value__ == ((32 : stdgo.GoInt)) || __value__ == ((30 : stdgo.GoInt)) || __value__ == ((31 : stdgo.GoInt)) || __value__ == ((33 : stdgo.GoInt))) {
                            if ((_offset == (0 : stdgo.GoInt)) && (((((_std == (24 : stdgo.GoInt)) || (_std == (27 : stdgo.GoInt))) || (_std == (25 : stdgo.GoInt))) || (_std == (26 : stdgo.GoInt))) || (_std == (28 : stdgo.GoInt)))) {
                                _b = (_b.__append__((90 : stdgo.GoUInt8)));
                                break;
                            };
                            var _zone:stdgo.GoInt = _offset / (60 : stdgo.GoInt);
                            var _absoffset:stdgo.GoInt = _offset;
                            if (_zone < (0 : stdgo.GoInt)) {
                                _b = (_b.__append__((45 : stdgo.GoUInt8)));
                                _zone = -_zone;
                                _absoffset = -_absoffset;
                            } else {
                                _b = (_b.__append__((43 : stdgo.GoUInt8)));
                            };
                            _b = _appendInt(_b, _zone / (60 : stdgo.GoInt), (2 : stdgo.GoInt));
                            if ((((_std == (27 : stdgo.GoInt)) || (_std == (32 : stdgo.GoInt))) || (_std == (28 : stdgo.GoInt))) || (_std == (33 : stdgo.GoInt))) {
                                _b = (_b.__append__((58 : stdgo.GoUInt8)));
                            };
                            if ((_std != (31 : stdgo.GoInt)) && (_std != (26 : stdgo.GoInt))) {
                                _b = _appendInt(_b, _zone % (60 : stdgo.GoInt), (2 : stdgo.GoInt));
                            };
                            if ((((_std == (25 : stdgo.GoInt)) || (_std == (30 : stdgo.GoInt))) || (_std == (33 : stdgo.GoInt))) || (_std == (28 : stdgo.GoInt))) {
                                if ((_std == (33 : stdgo.GoInt)) || (_std == (28 : stdgo.GoInt))) {
                                    _b = (_b.__append__((58 : stdgo.GoUInt8)));
                                };
                                _b = _appendInt(_b, _absoffset % (60 : stdgo.GoInt), (2 : stdgo.GoInt));
                            };
                            break;
                        } else if (__value__ == ((23 : stdgo.GoInt))) {
                            if (_name != (stdgo.Go.str())) {
                                _b = (_b.__append__(..._name.__toArray__()));
                                break;
                            };
                            var _zone:stdgo.GoInt = _offset / (60 : stdgo.GoInt);
                            if (_zone < (0 : stdgo.GoInt)) {
                                _b = (_b.__append__((45 : stdgo.GoUInt8)));
                                _zone = -_zone;
                            } else {
                                _b = (_b.__append__((43 : stdgo.GoUInt8)));
                            };
                            _b = _appendInt(_b, _zone / (60 : stdgo.GoInt), (2 : stdgo.GoInt));
                            _b = _appendInt(_b, _zone % (60 : stdgo.GoInt), (2 : stdgo.GoInt));
                            break;
                        } else if (__value__ == ((34 : stdgo.GoInt)) || __value__ == ((35 : stdgo.GoInt))) {
                            _b = _appendNano(_b, _t.nanosecond(), _std);
                            break;
                        };
                    };
                    break;
                };
            };
        };
        return _b;
    }
    /**
        // AppendFormat is like Format but appends the textual
        // representation to b and returns the extended buffer.
    **/
    @:keep
    static public function appendFormat( _t:Time, _b:stdgo.Slice<stdgo.GoByte>, _layout:stdgo.GoString):stdgo.Slice<stdgo.GoByte> {
        @:recv var _t:Time = _t?.__copy__();
        {
            final __value__ = _layout;
            if (__value__ == (("2006-01-02T15:04:05Z07:00" : stdgo.GoString))) {
                return _t._appendFormatRFC3339(_b, false);
            } else if (__value__ == (("2006-01-02T15:04:05.999999999Z07:00" : stdgo.GoString))) {
                return _t._appendFormatRFC3339(_b, true);
            } else {
                return _t._appendFormat(_b, _layout?.__copy__());
            };
        };
    }
    /**
        // Format returns a textual representation of the time value formatted according
        // to the layout defined by the argument. See the documentation for the
        // constant called Layout to see how to represent the layout format.
        //
        // The executable example for Time.Format demonstrates the working
        // of the layout string in detail and is a good reference.
    **/
    @:keep
    static public function format( _t:Time, _layout:stdgo.GoString):stdgo.GoString {
        @:recv var _t:Time = _t?.__copy__();
        {};
        var _b:stdgo.Slice<stdgo.GoByte> = (null : stdgo.Slice<stdgo.GoUInt8>);
        var _max:stdgo.GoInt = (_layout.length) + (10 : stdgo.GoInt);
        if (_max < (64 : stdgo.GoInt)) {
            var _buf:stdgo.GoArray<stdgo.GoByte> = new stdgo.GoArray<stdgo.GoUInt8>(...[for (i in 0 ... 64) (0 : stdgo.GoUInt8)]);
            _b = (_buf.__slice__(0, (0 : stdgo.GoInt)) : stdgo.Slice<stdgo.GoUInt8>);
        } else {
            _b = new stdgo.Slice<stdgo.GoUInt8>((0 : stdgo.GoInt).toBasic(), _max).__setNumber32__();
        };
        _b = _t.appendFormat(_b, _layout?.__copy__());
        return (_b : stdgo.GoString)?.__copy__();
    }
    /**
        // GoString implements fmt.GoStringer and formats t to be printed in Go source
        // code.
    **/
    @:keep
    static public function goString( _t:Time):stdgo.GoString {
        @:recv var _t:Time = _t?.__copy__();
        var _abs:stdgo.GoUInt64 = _t._abs();
        var __tmp__ = _absDate(_abs, true), _year:stdgo.GoInt = __tmp__._0, _month:stdgo.time.Time.Month = __tmp__._1, _day:stdgo.GoInt = __tmp__._2, __1:stdgo.GoInt = __tmp__._3;
        var __tmp__ = _absClock(_abs), _hour:stdgo.GoInt = __tmp__._0, _minute:stdgo.GoInt = __tmp__._1, _second:stdgo.GoInt = __tmp__._2;
        var _buf = new stdgo.Slice<stdgo.GoUInt8>((0 : stdgo.GoInt).toBasic(), (("time.Date(9999, time.September, 31, 23, 59, 59, 999999999, time.Local)" : stdgo.GoString).length)).__setNumber32__();
        _buf = (_buf.__append__(...("time.Date(" : stdgo.GoString).__toArray__()));
        _buf = _appendInt(_buf, _year, (0 : stdgo.GoInt));
        if (((1 : stdgo.time.Time.Month) <= _month) && (_month <= (12 : stdgo.time.Time.Month))) {
            _buf = (_buf.__append__(...(", time." : stdgo.GoString).__toArray__()));
            _buf = (_buf.__append__(..._longMonthNames[(_month - (1 : stdgo.time.Time.Month) : stdgo.GoInt)].__toArray__()));
        } else {
            _buf = _appendInt(_buf, (_month : stdgo.GoInt), (0 : stdgo.GoInt));
        };
        _buf = (_buf.__append__(...(", " : stdgo.GoString).__toArray__()));
        _buf = _appendInt(_buf, _day, (0 : stdgo.GoInt));
        _buf = (_buf.__append__(...(", " : stdgo.GoString).__toArray__()));
        _buf = _appendInt(_buf, _hour, (0 : stdgo.GoInt));
        _buf = (_buf.__append__(...(", " : stdgo.GoString).__toArray__()));
        _buf = _appendInt(_buf, _minute, (0 : stdgo.GoInt));
        _buf = (_buf.__append__(...(", " : stdgo.GoString).__toArray__()));
        _buf = _appendInt(_buf, _second, (0 : stdgo.GoInt));
        _buf = (_buf.__append__(...(", " : stdgo.GoString).__toArray__()));
        _buf = _appendInt(_buf, _t.nanosecond(), (0 : stdgo.GoInt));
        _buf = (_buf.__append__(...(", " : stdgo.GoString).__toArray__()));
        {
            var _loc = _t.location();
            {
                final __value__ = _loc;
                if (__value__ == (stdgo.time.Time.utc) || __value__ == null || (__value__ : Dynamic).__nil__) {
                    _buf = (_buf.__append__(...("time.UTC" : stdgo.GoString).__toArray__()));
                } else if (__value__ == (stdgo.time.Time.local)) {
                    _buf = (_buf.__append__(...("time.Local" : stdgo.GoString).__toArray__()));
                } else {
                    _buf = (_buf.__append__(...("time.Location(" : stdgo.GoString).__toArray__()));
                    _buf = (_buf.__append__(..._quote(_loc._name?.__copy__()).__toArray__()));
                    _buf = (_buf.__append__((41 : stdgo.GoUInt8)));
                };
            };
        };
        _buf = (_buf.__append__((41 : stdgo.GoUInt8)));
        return (_buf : stdgo.GoString)?.__copy__();
    }
    /**
        // String returns the time formatted using the format string
        //
        //	"2006-01-02 15:04:05.999999999 -0700 MST"
        //
        // If the time has a monotonic clock reading, the returned string
        // includes a final field "m=±<value>", where value is the monotonic
        // clock reading formatted as a decimal number of seconds.
        //
        // The returned string is meant for debugging; for a stable serialized
        // representation, use t.MarshalText, t.MarshalBinary, or t.Format
        // with an explicit format string.
    **/
    @:keep
    static public function string( _t:Time):stdgo.GoString {
        @:recv var _t:Time = _t?.__copy__();
        var _s:stdgo.GoString = _t.format(("2006-01-02 15:04:05.999999999 -0700 MST" : stdgo.GoString))?.__copy__();
        if (_t._wall & (-9223372036854775808i64 : stdgo.GoUInt64) != ((0i64 : stdgo.GoUInt64))) {
            var _m2:stdgo.GoUInt64 = (_t._ext : stdgo.GoUInt64);
            var _sign:stdgo.GoUInt8 = ((43 : stdgo.GoUInt8) : stdgo.GoByte);
            if (_t._ext < (0i64 : stdgo.GoInt64)) {
                _sign = (45 : stdgo.GoUInt8);
                _m2 = -_m2;
            };
            var __0:stdgo.GoUInt64 = _m2 / (1000000000i64 : stdgo.GoUInt64), __1:stdgo.GoUInt64 = _m2 % (1000000000i64 : stdgo.GoUInt64), _m2:stdgo.GoUInt64 = __1, _m1:stdgo.GoUInt64 = __0;
            var __0:stdgo.GoUInt64 = _m1 / (1000000000i64 : stdgo.GoUInt64), __1:stdgo.GoUInt64 = _m1 % (1000000000i64 : stdgo.GoUInt64), _m1:stdgo.GoUInt64 = __1, _m0:stdgo.GoUInt64 = __0;
            var _buf = new stdgo.Slice<stdgo.GoUInt8>((0 : stdgo.GoInt).toBasic(), (24 : stdgo.GoInt)).__setNumber32__();
            _buf = (_buf.__append__(...(" m=" : stdgo.GoString).__toArray__()));
            _buf = (_buf.__append__(_sign));
            var _wid:stdgo.GoInt = (0 : stdgo.GoInt);
            if (_m0 != ((0i64 : stdgo.GoUInt64))) {
                _buf = _appendInt(_buf, (_m0 : stdgo.GoInt), (0 : stdgo.GoInt));
                _wid = (9 : stdgo.GoInt);
            };
            _buf = _appendInt(_buf, (_m1 : stdgo.GoInt), _wid);
            _buf = (_buf.__append__((46 : stdgo.GoUInt8)));
            _buf = _appendInt(_buf, (_m2 : stdgo.GoInt), (9 : stdgo.GoInt));
            _s = _s + ((_buf : stdgo.GoString))?.__copy__();
        };
        return _s?.__copy__();
    }
}
class Location_asInterface {
    /**
        // lookupName returns information about the time zone with
        // the given name (such as "EST") at the given pseudo-Unix time
        // (what the given time of day would be in UTC).
    **/
    @:keep
    public dynamic function _lookupName(_name:stdgo.GoString, _unix:stdgo.GoInt64):{ var _0 : stdgo.GoInt; var _1 : Bool; } return __self__.value._lookupName(_name, _unix);
    /**
        // firstZoneUsed reports whether the first zone is used by some
        // transition.
    **/
    @:keep
    public dynamic function _firstZoneUsed():Bool return __self__.value._firstZoneUsed();
    /**
        // lookupFirstZone returns the index of the time zone to use for times
        // before the first transition time, or when there are no transition
        // times.
        //
        // The reference implementation in localtime.c from
        // https://www.iana.org/time-zones/repository/releases/tzcode2013g.tar.gz
        // implements the following algorithm for these cases:
        //  1. If the first zone is unused by the transitions, use it.
        //  2. Otherwise, if there are transition times, and the first
        //     transition is to a zone in daylight time, find the first
        //     non-daylight-time zone before and closest to the first transition
        //     zone.
        //  3. Otherwise, use the first zone that is not daylight time, if
        //     there is one.
        //  4. Otherwise, use the first zone.
    **/
    @:keep
    public dynamic function _lookupFirstZone():stdgo.GoInt return __self__.value._lookupFirstZone();
    /**
        // lookup returns information about the time zone in use at an
        // instant in time expressed as seconds since January 1, 1970 00:00:00 UTC.
        //
        // The returned information gives the name of the zone (such as "CET"),
        // the start and end times bracketing sec when that zone is in effect,
        // the offset in seconds east of UTC (such as -5*60*60), and whether
        // the daylight savings is being observed at that time.
    **/
    @:keep
    public dynamic function _lookup(_sec:stdgo.GoInt64):{ var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoInt64; var _3 : stdgo.GoInt64; var _4 : Bool; } return __self__.value._lookup(_sec);
    /**
        // String returns a descriptive name for the time zone information,
        // corresponding to the name argument to LoadLocation or FixedZone.
    **/
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    @:keep
    public dynamic function _get():stdgo.Ref<Location> return __self__.value._get();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Location>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.time.Time.Location_asInterface) class Location_static_extension {
    /**
        // lookupName returns information about the time zone with
        // the given name (such as "EST") at the given pseudo-Unix time
        // (what the given time of day would be in UTC).
    **/
    @:keep
    static public function _lookupName( _l:stdgo.Ref<Location>, _name:stdgo.GoString, _unix:stdgo.GoInt64):{ var _0 : stdgo.GoInt; var _1 : Bool; } {
        @:recv var _l:stdgo.Ref<Location> = _l;
        var _offset:stdgo.GoInt = (0 : stdgo.GoInt), _ok:Bool = false;
        _l = _l._get();
        for (_i in 0 ... _l._zone.length.toBasic()) {
            var _zone = (stdgo.Go.setRef(_l._zone[(_i : stdgo.GoInt)]) : stdgo.Ref<stdgo.time.Time.T_zone>);
            if (_zone._name == (_name)) {
                var __tmp__ = _l._lookup(_unix - (_zone._offset : stdgo.GoInt64)), _nam:stdgo.GoString = __tmp__._0, _offset:stdgo.GoInt = __tmp__._1, __1:stdgo.GoInt64 = __tmp__._2, __2:stdgo.GoInt64 = __tmp__._3, __3:Bool = __tmp__._4;
                if (_nam == (_zone._name)) {
                    return { _0 : _offset, _1 : true };
                };
            };
        };
        for (_i in 0 ... _l._zone.length.toBasic()) {
            var _zone = (stdgo.Go.setRef(_l._zone[(_i : stdgo.GoInt)]) : stdgo.Ref<stdgo.time.Time.T_zone>);
            if (_zone._name == (_name)) {
                return { _0 : _zone._offset, _1 : true };
            };
        };
        return { _0 : _offset, _1 : _ok };
    }
    /**
        // firstZoneUsed reports whether the first zone is used by some
        // transition.
    **/
    @:keep
    static public function _firstZoneUsed( _l:stdgo.Ref<Location>):Bool {
        @:recv var _l:stdgo.Ref<Location> = _l;
        for (__1 => _tx in _l._tx) {
            if (_tx._index == ((0 : stdgo.GoUInt8))) {
                return true;
            };
        };
        return false;
    }
    /**
        // lookupFirstZone returns the index of the time zone to use for times
        // before the first transition time, or when there are no transition
        // times.
        //
        // The reference implementation in localtime.c from
        // https://www.iana.org/time-zones/repository/releases/tzcode2013g.tar.gz
        // implements the following algorithm for these cases:
        //  1. If the first zone is unused by the transitions, use it.
        //  2. Otherwise, if there are transition times, and the first
        //     transition is to a zone in daylight time, find the first
        //     non-daylight-time zone before and closest to the first transition
        //     zone.
        //  3. Otherwise, use the first zone that is not daylight time, if
        //     there is one.
        //  4. Otherwise, use the first zone.
    **/
    @:keep
    static public function _lookupFirstZone( _l:stdgo.Ref<Location>):stdgo.GoInt {
        @:recv var _l:stdgo.Ref<Location> = _l;
        if (!_l._firstZoneUsed()) {
            return (0 : stdgo.GoInt);
        };
        if ((_l._tx.length > (0 : stdgo.GoInt)) && _l._zone[(_l._tx[(0 : stdgo.GoInt)]._index : stdgo.GoInt)]._isDST) {
            {
                var _zi:stdgo.GoInt = (_l._tx[(0 : stdgo.GoInt)]._index : stdgo.GoInt) - (1 : stdgo.GoInt);
                stdgo.Go.cfor(_zi >= (0 : stdgo.GoInt), _zi--, {
                    if (!_l._zone[(_zi : stdgo.GoInt)]._isDST) {
                        return _zi;
                    };
                });
            };
        };
        for (_zi in 0 ... _l._zone.length.toBasic()) {
            if (!_l._zone[(_zi : stdgo.GoInt)]._isDST) {
                return _zi;
            };
        };
        return (0 : stdgo.GoInt);
    }
    /**
        // lookup returns information about the time zone in use at an
        // instant in time expressed as seconds since January 1, 1970 00:00:00 UTC.
        //
        // The returned information gives the name of the zone (such as "CET"),
        // the start and end times bracketing sec when that zone is in effect,
        // the offset in seconds east of UTC (such as -5*60*60), and whether
        // the daylight savings is being observed at that time.
    **/
    @:keep
    static public function _lookup( _l:stdgo.Ref<Location>, _sec:stdgo.GoInt64):{ var _0 : stdgo.GoString; var _1 : stdgo.GoInt; var _2 : stdgo.GoInt64; var _3 : stdgo.GoInt64; var _4 : Bool; } {
        @:recv var _l:stdgo.Ref<Location> = _l;
        var _name:stdgo.GoString = ("" : stdgo.GoString), _offset:stdgo.GoInt = (0 : stdgo.GoInt), _start:stdgo.GoInt64 = (0 : stdgo.GoInt64), _end:stdgo.GoInt64 = (0 : stdgo.GoInt64), _isDST:Bool = false;
        _l = _l._get();
        if ((_l._zone.length) == ((0 : stdgo.GoInt))) {
            _name = ("UTC" : stdgo.GoString);
            _offset = (0 : stdgo.GoInt);
            _start = (-9223372036854775808i64 : stdgo.GoInt64);
            _end = (9223372036854775807i64 : stdgo.GoInt64);
            _isDST = false;
            return { _0 : _name, _1 : _offset, _2 : _start, _3 : _end, _4 : _isDST };
        };
        {
            var _zone = _l._cacheZone;
            if ((((_zone != null) && ((_zone : Dynamic).__nil__ == null || !(_zone : Dynamic).__nil__)) && (_l._cacheStart <= _sec)) && (_sec < _l._cacheEnd)) {
                _name = _zone._name?.__copy__();
                _offset = _zone._offset;
                _start = _l._cacheStart;
                _end = _l._cacheEnd;
                _isDST = _zone._isDST;
                return { _0 : _name, _1 : _offset, _2 : _start, _3 : _end, _4 : _isDST };
            };
        };
        if ((_l._tx.length == (0 : stdgo.GoInt)) || (_sec < _l._tx[(0 : stdgo.GoInt)]._when)) {
            var _zone = (stdgo.Go.setRef(_l._zone[(_l._lookupFirstZone() : stdgo.GoInt)]) : stdgo.Ref<stdgo.time.Time.T_zone>);
            _name = _zone._name?.__copy__();
            _offset = _zone._offset;
            _start = (-9223372036854775808i64 : stdgo.GoInt64);
            if ((_l._tx.length) > (0 : stdgo.GoInt)) {
                _end = _l._tx[(0 : stdgo.GoInt)]._when;
            } else {
                _end = (9223372036854775807i64 : stdgo.GoInt64);
            };
            _isDST = _zone._isDST;
            return { _0 : _name, _1 : _offset, _2 : _start, _3 : _end, _4 : _isDST };
        };
        var _tx = _l._tx;
        _end = (9223372036854775807i64 : stdgo.GoInt64);
        var _lo:stdgo.GoInt = (0 : stdgo.GoInt);
        var _hi:stdgo.GoInt = (_tx.length);
        while ((_hi - _lo) > (1 : stdgo.GoInt)) {
            var _m:stdgo.GoInt = _lo + ((_hi - _lo) / (2 : stdgo.GoInt));
            var _lim:stdgo.GoInt64 = _tx[(_m : stdgo.GoInt)]._when;
            if (_sec < _lim) {
                _end = _lim;
                _hi = _m;
            } else {
                _lo = _m;
            };
        };
        var _zone = (stdgo.Go.setRef(_l._zone[(_tx[(_lo : stdgo.GoInt)]._index : stdgo.GoInt)]) : stdgo.Ref<stdgo.time.Time.T_zone>);
        _name = _zone._name?.__copy__();
        _offset = _zone._offset;
        _start = _tx[(_lo : stdgo.GoInt)]._when;
        _isDST = _zone._isDST;
        if ((_lo == (_tx.length - (1 : stdgo.GoInt))) && (_l._extend != stdgo.Go.str())) {
            {
                var __tmp__ = _tzset(_l._extend?.__copy__(), _start, _sec), _ename:stdgo.GoString = __tmp__._0, _eoffset:stdgo.GoInt = __tmp__._1, _estart:stdgo.GoInt64 = __tmp__._2, _eend:stdgo.GoInt64 = __tmp__._3, _eisDST:Bool = __tmp__._4, _ok:Bool = __tmp__._5;
                if (_ok) {
                    return { _0 : _ename?.__copy__(), _1 : _eoffset, _2 : _estart, _3 : _eend, _4 : _eisDST };
                };
            };
        };
        return { _0 : _name, _1 : _offset, _2 : _start, _3 : _end, _4 : _isDST };
    }
    /**
        // String returns a descriptive name for the time zone information,
        // corresponding to the name argument to LoadLocation or FixedZone.
    **/
    @:keep
    static public function string( _l:stdgo.Ref<Location>):stdgo.GoString {
        @:recv var _l:stdgo.Ref<Location> = _l;
        return _l._get()._name?.__copy__();
    }
    @:keep
    static public function _get( _l:stdgo.Ref<Location>):stdgo.Ref<Location> {
        @:recv var _l:stdgo.Ref<Location> = _l;
        if (_l == null || (_l : Dynamic).__nil__) {
            return (stdgo.Go.setRef(_utcLoc) : stdgo.Ref<stdgo.time.Time.Location>);
        };
        if (_l == ((stdgo.Go.setRef(_localLoc) : stdgo.Ref<stdgo.time.Time.Location>))) {
            _localOnce.do_(_initLocal);
        };
        return _l;
    }
}
class T_dataIO_asInterface {
    /**
        // read returns the read of the data in the buffer.
    **/
    @:keep
    public dynamic function _rest():stdgo.Slice<stdgo.GoByte> return __self__.value._rest();
    @:keep
    public dynamic function _byte():{ var _0 : stdgo.GoByte; var _1 : Bool; } return __self__.value._byte();
    @:keep
    public dynamic function _big8():{ var _0 : stdgo.GoUInt64; var _1 : Bool; } return __self__.value._big8();
    @:keep
    public dynamic function _big4():{ var _0 : stdgo.GoUInt32; var _1 : Bool; } return __self__.value._big4();
    @:keep
    public dynamic function _read(_n:stdgo.GoInt):stdgo.Slice<stdgo.GoByte> return __self__.value._read(_n);
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_dataIO>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.time.Time.T_dataIO_asInterface) class T_dataIO_static_extension {
    /**
        // read returns the read of the data in the buffer.
    **/
    @:keep
    static public function _rest( _d:stdgo.Ref<T_dataIO>):stdgo.Slice<stdgo.GoByte> {
        @:recv var _d:stdgo.Ref<T_dataIO> = _d;
        var _r = _d._p;
        _d._p = (null : stdgo.Slice<stdgo.GoUInt8>);
        return _r;
    }
    @:keep
    static public function _byte( _d:stdgo.Ref<T_dataIO>):{ var _0 : stdgo.GoByte; var _1 : Bool; } {
        @:recv var _d:stdgo.Ref<T_dataIO> = _d;
        var _n:stdgo.GoByte = (0 : stdgo.GoUInt8), _ok:Bool = false;
        var _p = _d._read((1 : stdgo.GoInt));
        if ((_p.length) < (1 : stdgo.GoInt)) {
            _d._error = true;
            return { _0 : (0 : stdgo.GoUInt8), _1 : false };
        };
        return { _0 : _p[(0 : stdgo.GoInt)], _1 : true };
    }
    @:keep
    static public function _big8( _d:stdgo.Ref<T_dataIO>):{ var _0 : stdgo.GoUInt64; var _1 : Bool; } {
        @:recv var _d:stdgo.Ref<T_dataIO> = _d;
        var _n:stdgo.GoUInt64 = (0 : stdgo.GoUInt64), _ok:Bool = false;
        var __tmp__ = _d._big4(), _n1:stdgo.GoUInt32 = __tmp__._0, _ok1:Bool = __tmp__._1;
        var __tmp__ = _d._big4(), _n2:stdgo.GoUInt32 = __tmp__._0, _ok2:Bool = __tmp__._1;
        if (!_ok1 || !_ok2) {
            _d._error = true;
            return { _0 : (0i64 : stdgo.GoUInt64), _1 : false };
        };
        return { _0 : ((_n1 : stdgo.GoUInt64) << (32i64 : stdgo.GoUInt64)) | (_n2 : stdgo.GoUInt64), _1 : true };
    }
    @:keep
    static public function _big4( _d:stdgo.Ref<T_dataIO>):{ var _0 : stdgo.GoUInt32; var _1 : Bool; } {
        @:recv var _d:stdgo.Ref<T_dataIO> = _d;
        var _n:stdgo.GoUInt32 = (0 : stdgo.GoUInt32), _ok:Bool = false;
        var _p = _d._read((4 : stdgo.GoInt));
        if ((_p.length) < (4 : stdgo.GoInt)) {
            _d._error = true;
            return { _0 : (0u32 : stdgo.GoUInt32), _1 : false };
        };
        return { _0 : (((_p[(3 : stdgo.GoInt)] : stdgo.GoUInt32) | ((_p[(2 : stdgo.GoInt)] : stdgo.GoUInt32) << (8i64 : stdgo.GoUInt64))) | ((_p[(1 : stdgo.GoInt)] : stdgo.GoUInt32) << (16i64 : stdgo.GoUInt64))) | ((_p[(0 : stdgo.GoInt)] : stdgo.GoUInt32) << (24i64 : stdgo.GoUInt64)), _1 : true };
    }
    @:keep
    static public function _read( _d:stdgo.Ref<T_dataIO>, _n:stdgo.GoInt):stdgo.Slice<stdgo.GoByte> {
        @:recv var _d:stdgo.Ref<T_dataIO> = _d;
        if ((_d._p.length) < _n) {
            _d._p = (null : stdgo.Slice<stdgo.GoUInt8>);
            _d._error = true;
            return (null : stdgo.Slice<stdgo.GoUInt8>);
        };
        var _p = (_d._p.__slice__((0 : stdgo.GoInt), _n) : stdgo.Slice<stdgo.GoUInt8>);
        _d._p = (_d._p.__slice__(_n) : stdgo.Slice<stdgo.GoUInt8>);
        return _p;
    }
}
class Month_asInterface {
    /**
        // String returns the English name of the month ("January", "February", ...).
    **/
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Month>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.time.Time.Month_asInterface) class Month_static_extension {
    /**
        // String returns the English name of the month ("January", "February", ...).
    **/
    @:keep
    static public function string( _m:Month):stdgo.GoString {
        @:recv var _m:Month = _m;
        if (((1 : stdgo.time.Time.Month) <= _m) && (_m <= (12 : stdgo.time.Time.Month))) {
            return _longMonthNames[(_m - (1 : stdgo.time.Time.Month) : stdgo.GoInt)]?.__copy__();
        };
        var _buf = new stdgo.Slice<stdgo.GoUInt8>((20 : stdgo.GoInt).toBasic(), 0).__setNumber32__();
        var _n:stdgo.GoInt = _fmtInt(_buf, (_m : stdgo.GoUInt64));
        return ("%!Month(" : stdgo.GoString) + ((_buf.__slice__(_n) : stdgo.Slice<stdgo.GoUInt8>) : stdgo.GoString)?.__copy__() + (")" : stdgo.GoString)?.__copy__()?.__copy__();
    }
}
class Weekday_asInterface {
    /**
        // String returns the English name of the day ("Sunday", "Monday", ...).
    **/
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Weekday>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.time.Time.Weekday_asInterface) class Weekday_static_extension {
    /**
        // String returns the English name of the day ("Sunday", "Monday", ...).
    **/
    @:keep
    static public function string( _d:Weekday):stdgo.GoString {
        @:recv var _d:Weekday = _d;
        if (((0 : stdgo.time.Time.Weekday) <= _d) && (_d <= (6 : stdgo.time.Time.Weekday))) {
            return _longDayNames[(_d : stdgo.GoInt)]?.__copy__();
        };
        var _buf = new stdgo.Slice<stdgo.GoUInt8>((20 : stdgo.GoInt).toBasic(), 0).__setNumber32__();
        var _n:stdgo.GoInt = _fmtInt(_buf, (_d : stdgo.GoUInt64));
        return ("%!Weekday(" : stdgo.GoString) + ((_buf.__slice__(_n) : stdgo.Slice<stdgo.GoUInt8>) : stdgo.GoString)?.__copy__() + (")" : stdgo.GoString)?.__copy__()?.__copy__();
    }
}
class Duration_asInterface {
    /**
        // Abs returns the absolute value of d.
        // As a special case, math.MinInt64 is converted to math.MaxInt64.
    **/
    @:keep
    public dynamic function abs():Duration return __self__.value.abs();
    /**
        // Round returns the result of rounding d to the nearest multiple of m.
        // The rounding behavior for halfway values is to round away from zero.
        // If the result exceeds the maximum (or minimum)
        // value that can be stored in a Duration,
        // Round returns the maximum (or minimum) duration.
        // If m <= 0, Round returns d unchanged.
    **/
    @:keep
    public dynamic function round(_m:Duration):Duration return __self__.value.round(_m);
    /**
        // Truncate returns the result of rounding d toward zero to a multiple of m.
        // If m <= 0, Truncate returns d unchanged.
    **/
    @:keep
    public dynamic function truncate(_m:Duration):Duration return __self__.value.truncate(_m);
    /**
        // Hours returns the duration as a floating point number of hours.
    **/
    @:keep
    public dynamic function hours():stdgo.GoFloat64 return __self__.value.hours();
    /**
        // Minutes returns the duration as a floating point number of minutes.
    **/
    @:keep
    public dynamic function minutes():stdgo.GoFloat64 return __self__.value.minutes();
    /**
        // Seconds returns the duration as a floating point number of seconds.
    **/
    @:keep
    public dynamic function seconds():stdgo.GoFloat64 return __self__.value.seconds();
    /**
        // Milliseconds returns the duration as an integer millisecond count.
    **/
    @:keep
    public dynamic function milliseconds():stdgo.GoInt64 return __self__.value.milliseconds();
    /**
        // Microseconds returns the duration as an integer microsecond count.
    **/
    @:keep
    public dynamic function microseconds():stdgo.GoInt64 return __self__.value.microseconds();
    /**
        // Nanoseconds returns the duration as an integer nanosecond count.
    **/
    @:keep
    public dynamic function nanoseconds():stdgo.GoInt64 return __self__.value.nanoseconds();
    /**
        // String returns a string representing the duration in the form "72h3m0.5s".
        // Leading zero units are omitted. As a special case, durations less than one
        // second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure
        // that the leading digit is non-zero. The zero duration formats as 0s.
    **/
    @:keep
    public dynamic function string():stdgo.GoString return __self__.value.string();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<Duration>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.time.Time.Duration_asInterface) class Duration_static_extension {
    /**
        // Abs returns the absolute value of d.
        // As a special case, math.MinInt64 is converted to math.MaxInt64.
    **/
    @:keep
    static public function abs( _d:Duration):Duration {
        @:recv var _d:Duration = _d;
        if (_d >= (0i64 : stdgo.time.Time.Duration)) {
            return _d;
        } else if (_d == ((-9223372036854775808i64 : stdgo.time.Time.Duration))) {
            return (9223372036854775807i64 : stdgo.time.Time.Duration);
        } else {
            return -_d;
        };
    }
    /**
        // Round returns the result of rounding d to the nearest multiple of m.
        // The rounding behavior for halfway values is to round away from zero.
        // If the result exceeds the maximum (or minimum)
        // value that can be stored in a Duration,
        // Round returns the maximum (or minimum) duration.
        // If m <= 0, Round returns d unchanged.
    **/
    @:keep
    static public function round( _d:Duration, _m:Duration):Duration {
        @:recv var _d:Duration = _d;
        if (_m <= (0i64 : stdgo.time.Time.Duration)) {
            return _d;
        };
        var _r:stdgo.time.Time.Duration = _d % _m;
        if (_d < (0i64 : stdgo.time.Time.Duration)) {
            _r = -_r;
            if (_lessThanHalf(_r, _m)) {
                return _d + _r;
            };
            {
                var _d1:stdgo.time.Time.Duration = (_d - _m) + _r;
                if (_d1 < _d) {
                    return _d1;
                };
            };
            return (-9223372036854775808i64 : stdgo.time.Time.Duration);
        };
        if (_lessThanHalf(_r, _m)) {
            return _d - _r;
        };
        {
            var _d1:stdgo.time.Time.Duration = (_d + _m) - _r;
            if (_d1 > _d) {
                return _d1;
            };
        };
        return (9223372036854775807i64 : stdgo.time.Time.Duration);
    }
    /**
        // Truncate returns the result of rounding d toward zero to a multiple of m.
        // If m <= 0, Truncate returns d unchanged.
    **/
    @:keep
    static public function truncate( _d:Duration, _m:Duration):Duration {
        @:recv var _d:Duration = _d;
        if (_m <= (0i64 : stdgo.time.Time.Duration)) {
            return _d;
        };
        return _d - (_d % _m);
    }
    /**
        // Hours returns the duration as a floating point number of hours.
    **/
    @:keep
    static public function hours( _d:Duration):stdgo.GoFloat64 {
        @:recv var _d:Duration = _d;
        var _hour:stdgo.time.Time.Duration = _d / (3600000000000i64 : stdgo.time.Time.Duration);
        var _nsec:stdgo.time.Time.Duration = _d % (3600000000000i64 : stdgo.time.Time.Duration);
        return (_hour : stdgo.GoFloat64) + ((_nsec : stdgo.GoFloat64) / (3.6e+12 : stdgo.GoFloat64));
    }
    /**
        // Minutes returns the duration as a floating point number of minutes.
    **/
    @:keep
    static public function minutes( _d:Duration):stdgo.GoFloat64 {
        @:recv var _d:Duration = _d;
        var _min:stdgo.time.Time.Duration = _d / (60000000000i64 : stdgo.time.Time.Duration);
        var _nsec:stdgo.time.Time.Duration = _d % (60000000000i64 : stdgo.time.Time.Duration);
        return (_min : stdgo.GoFloat64) + ((_nsec : stdgo.GoFloat64) / (6e+10 : stdgo.GoFloat64));
    }
    /**
        // Seconds returns the duration as a floating point number of seconds.
    **/
    @:keep
    static public function seconds( _d:Duration):stdgo.GoFloat64 {
        @:recv var _d:Duration = _d;
        var _sec:stdgo.time.Time.Duration = _d / (1000000000i64 : stdgo.time.Time.Duration);
        var _nsec:stdgo.time.Time.Duration = _d % (1000000000i64 : stdgo.time.Time.Duration);
        return (_sec : stdgo.GoFloat64) + ((_nsec : stdgo.GoFloat64) / (1e+09 : stdgo.GoFloat64));
    }
    /**
        // Milliseconds returns the duration as an integer millisecond count.
    **/
    @:keep
    static public function milliseconds( _d:Duration):stdgo.GoInt64 {
        @:recv var _d:Duration = _d;
        return (_d : stdgo.GoInt64) / (1000000i64 : stdgo.GoInt64);
    }
    /**
        // Microseconds returns the duration as an integer microsecond count.
    **/
    @:keep
    static public function microseconds( _d:Duration):stdgo.GoInt64 {
        @:recv var _d:Duration = _d;
        return (_d : stdgo.GoInt64) / (1000i64 : stdgo.GoInt64);
    }
    /**
        // Nanoseconds returns the duration as an integer nanosecond count.
    **/
    @:keep
    static public function nanoseconds( _d:Duration):stdgo.GoInt64 {
        @:recv var _d:Duration = _d;
        return (_d : stdgo.GoInt64);
    }
    /**
        // String returns a string representing the duration in the form "72h3m0.5s".
        // Leading zero units are omitted. As a special case, durations less than one
        // second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure
        // that the leading digit is non-zero. The zero duration formats as 0s.
    **/
    @:keep
    static public function string( _d:Duration):stdgo.GoString {
        @:recv var _d:Duration = _d;
        var _buf:stdgo.GoArray<stdgo.GoByte> = new stdgo.GoArray<stdgo.GoUInt8>(...[for (i in 0 ... 32) (0 : stdgo.GoUInt8)]);
        var _w:stdgo.GoInt = (_buf.length);
        var _u:stdgo.GoUInt64 = (_d : stdgo.GoUInt64);
        var _neg:Bool = _d < (0i64 : stdgo.time.Time.Duration);
        if (_neg) {
            _u = -_u;
        };
        if (_u < ((1000000000i64 : stdgo.time.Time.Duration) : stdgo.GoUInt64)) {
            var _prec:stdgo.GoInt = (0 : stdgo.GoInt);
            _w--;
            _buf[(_w : stdgo.GoInt)] = (115 : stdgo.GoUInt8);
            _w--;
            if (_u == ((0i64 : stdgo.GoUInt64))) {
                return ("0s" : stdgo.GoString);
            } else if (_u < ((1000i64 : stdgo.time.Time.Duration) : stdgo.GoUInt64)) {
                _prec = (0 : stdgo.GoInt);
                _buf[(_w : stdgo.GoInt)] = (110 : stdgo.GoUInt8);
            } else if (_u < ((1000000i64 : stdgo.time.Time.Duration) : stdgo.GoUInt64)) {
                _prec = (3 : stdgo.GoInt);
                _w--;
                stdgo.Go.copySlice((_buf.__slice__(_w) : stdgo.Slice<stdgo.GoUInt8>), ("µ" : stdgo.GoString));
            } else {
                _prec = (6 : stdgo.GoInt);
                _buf[(_w : stdgo.GoInt)] = (109 : stdgo.GoUInt8);
            };
            {
                var __tmp__ = _fmtFrac((_buf.__slice__(0, _w) : stdgo.Slice<stdgo.GoUInt8>), _u, _prec);
                _w = __tmp__._0;
                _u = __tmp__._1;
            };
            _w = _fmtInt((_buf.__slice__(0, _w) : stdgo.Slice<stdgo.GoUInt8>), _u);
        } else {
            _w--;
            _buf[(_w : stdgo.GoInt)] = (115 : stdgo.GoUInt8);
            {
                var __tmp__ = _fmtFrac((_buf.__slice__(0, _w) : stdgo.Slice<stdgo.GoUInt8>), _u, (9 : stdgo.GoInt));
                _w = __tmp__._0;
                _u = __tmp__._1;
            };
            _w = _fmtInt((_buf.__slice__(0, _w) : stdgo.Slice<stdgo.GoUInt8>), _u % (60i64 : stdgo.GoUInt64));
            _u = _u / ((60i64 : stdgo.GoUInt64));
            if (_u > (0i64 : stdgo.GoUInt64)) {
                _w--;
                _buf[(_w : stdgo.GoInt)] = (109 : stdgo.GoUInt8);
                _w = _fmtInt((_buf.__slice__(0, _w) : stdgo.Slice<stdgo.GoUInt8>), _u % (60i64 : stdgo.GoUInt64));
                _u = _u / ((60i64 : stdgo.GoUInt64));
                if (_u > (0i64 : stdgo.GoUInt64)) {
                    _w--;
                    _buf[(_w : stdgo.GoInt)] = (104 : stdgo.GoUInt8);
                    _w = _fmtInt((_buf.__slice__(0, _w) : stdgo.Slice<stdgo.GoUInt8>), _u);
                };
            };
        };
        if (_neg) {
            _w--;
            _buf[(_w : stdgo.GoInt)] = (45 : stdgo.GoUInt8);
        };
        return ((_buf.__slice__(_w) : stdgo.Slice<stdgo.GoUInt8>) : stdgo.GoString)?.__copy__();
    }
}
class T_fileSizeError_asInterface {
    @:keep
    public dynamic function error():stdgo.GoString return __self__.value.error();
    public function new(__self__, __type__) {
        this.__self__ = __self__;
        this.__type__ = __type__;
    }
    public function __underlying__() return new stdgo.AnyInterface((__type__.kind() == stdgo.internal.reflect.Reflect.KindType.pointer && !stdgo.internal.reflect.Reflect.isReflectTypeRef(__type__)) ? (__self__ : Dynamic) : (__self__.value : Dynamic), __type__);
    var __self__ : stdgo.Pointer<T_fileSizeError>;
    var __type__ : stdgo.internal.reflect.Reflect._Type;
}
@:keep @:allow(stdgo.time.Time.T_fileSizeError_asInterface) class T_fileSizeError_static_extension {
    @:keep
    static public function error( _f:T_fileSizeError):stdgo.GoString {
        @:recv var _f:T_fileSizeError = _f;
        return ("time: file " : stdgo.GoString) + (_f : stdgo.GoString)?.__copy__() + (" is too large" : stdgo.GoString)?.__copy__()?.__copy__();
    }
}
