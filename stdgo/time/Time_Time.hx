package stdgo.time;
/**
    Package time provides functionality for measuring and displaying time.
    
    The calendrical calculations always assume a Gregorian calendar, with
    no leap seconds.
    
    # Monotonic Clocks
    
    Operating systems provide both a “wall clock,” which is subject to
    changes for clock synchronization, and a “monotonic clock,” which is
    not. The general rule is that the wall clock is for telling time and
    the monotonic clock is for measuring time. Rather than split the API,
    in this package the Time returned by time.Now contains both a wall
    clock reading and a monotonic clock reading; later time-telling
    operations use the wall clock reading, but later time-measuring
    operations, specifically comparisons and subtractions, use the
    monotonic clock reading.
    
    For example, this code always computes a positive elapsed time of
    approximately 20 milliseconds, even if the wall clock is changed during
    the operation being timed:
    
    	start := time.Now()
    	... operation that takes 20 milliseconds ...
    	t := time.Now()
    	elapsed := t.Sub(start)
    
    Other idioms, such as time.Since(start), time.Until(deadline), and
    time.Now().Before(deadline), are similarly robust against wall clock
    resets.
    
    The rest of this section gives the precise details of how operations
    use monotonic clocks, but understanding those details is not required
    to use this package.
    
    The Time returned by time.Now contains a monotonic clock reading.
    If Time t has a monotonic clock reading, t.Add adds the same duration to
    both the wall clock and monotonic clock readings to compute the result.
    Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time
    computations, they always strip any monotonic clock reading from their results.
    Because t.In, t.Local, and t.UTC are used for their effect on the interpretation
    of the wall time, they also strip any monotonic clock reading from their results.
    The canonical way to strip a monotonic clock reading is to use t = t.Round(0).
    
    If Times t and u both contain monotonic clock readings, the operations
    t.After(u), t.Before(u), t.Equal(u), t.Compare(u), and t.Sub(u) are carried out
    using the monotonic clock readings alone, ignoring the wall clock
    readings. If either t or u contains no monotonic clock reading, these
    operations fall back to using the wall clock readings.
    
    On some systems the monotonic clock will stop if the computer goes to sleep.
    On such a system, t.Sub(u) may not accurately reflect the actual
    time that passed between t and u.
    
    Because the monotonic clock reading has no meaning outside
    the current process, the serialized forms generated by t.GobEncode,
    t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic
    clock reading, and t.Format provides no format for it. Similarly, the
    constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix,
    as well as the unmarshalers t.GobDecode, t.UnmarshalBinary.
    t.UnmarshalJSON, and t.UnmarshalText always create times with
    no monotonic clock reading.
    
    The monotonic clock reading exists only in Time values. It is not
    a part of Duration values or the Unix times returned by t.Unix and
    friends.
    
    Note that the Go == operator compares not just the time instant but
    also the Location and the monotonic clock reading. See the
    documentation for the Time type for a discussion of equality
    testing for Time values.
    
    For debugging, the result of t.String does include the monotonic
    clock reading if present. If t != u because of different monotonic clock readings,
    that difference will be visible when printing t.String() and u.String().
**/
class Time {
    static public inline function resetLocalOnceForTest():Void {
        stdgo._internal.time.Time_resetLocalOnceForTest.resetLocalOnceForTest();
    }
    static public inline function forceUSPacificForTesting():Void {
        stdgo._internal.time.Time_forceUSPacificForTesting.forceUSPacificForTesting();
    }
    static public inline function zoneinfoForTesting():stdgo.Pointer<String> {
        return stdgo._internal.time.Time_zoneinfoForTesting.zoneinfoForTesting();
    }
    static public inline function resetZoneinfoForTesting():Void {
        stdgo._internal.time.Time_resetZoneinfoForTesting.resetZoneinfoForTesting();
    }
    static public inline function loadFromEmbeddedTZData(_zone:String):stdgo.Tuple<String, stdgo.Error> {
        final _zone = (_zone : stdgo.GoString);
        return {
            final obj = stdgo._internal.time.Time_loadFromEmbeddedTZData.loadFromEmbeddedTZData(_zone);
            { _0 : obj._0, _1 : obj._1 };
        };
    }
    static public inline function tzsetRule(_s:String):stdgo.Tuple.Tuple3<Rule, String, Bool> {
        final _s = (_s : stdgo.GoString);
        return {
            final obj = stdgo._internal.time.Time_tzsetRule.tzsetRule(_s);
            { _0 : obj._0, _1 : obj._1, _2 : obj._2 };
        };
    }
    /**
        Parse parses a formatted string and returns the time value it represents.
        See the documentation for the constant called Layout to see how to
        represent the format. The second argument must be parseable using
        the format string (layout) provided as the first argument.
        
        The example for Time.Format demonstrates the working of the layout string
        in detail and is a good reference.
        
        When parsing (only), the input may contain a fractional second
        field immediately after the seconds field, even if the layout does not
        signify its presence. In that case either a comma or a decimal point
        followed by a maximal series of digits is parsed as a fractional second.
        Fractional seconds are truncated to nanosecond precision.
        
        Elements omitted from the layout are assumed to be zero or, when
        zero is impossible, one, so parsing "3:04pm" returns the time
        corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is
        0, this time is before the zero Time).
        Years must be in the range 0000..9999. The day of the week is checked
        for syntax but it is otherwise ignored.
        
        For layouts specifying the two-digit year 06, a value NN >= 69 will be treated
        as 19NN and a value NN < 69 will be treated as 20NN.
        
        The remainder of this comment describes the handling of time zones.
        
        In the absence of a time zone indicator, Parse returns a time in UTC.
        
        When parsing a time with a zone offset like -0700, if the offset corresponds
        to a time zone used by the current location (Local), then Parse uses that
        location and zone in the returned time. Otherwise it records the time as
        being in a fabricated location with time fixed at the given zone offset.
        
        When parsing a time with a zone abbreviation like MST, if the zone abbreviation
        has a defined offset in the current location, then that offset is used.
        The zone abbreviation "UTC" is recognized as UTC regardless of location.
        If the zone abbreviation is unknown, Parse records the time as being
        in a fabricated location with the given zone abbreviation and a zero offset.
        This choice means that such a time can be parsed and reformatted with the
        same layout losslessly, but the exact instant used in the representation will
        differ by the actual zone offset. To avoid such problems, prefer time layouts
        that use a numeric zone offset, or use ParseInLocation.
    **/
    static public inline function parse(_layout:String, _value:String):stdgo.Tuple<Time_, stdgo.Error> {
        final _layout = (_layout : stdgo.GoString);
        final _value = (_value : stdgo.GoString);
        return {
            final obj = stdgo._internal.time.Time_parse.parse(_layout, _value);
            { _0 : obj._0, _1 : obj._1 };
        };
    }
    /**
        ParseInLocation is like Parse but differs in two important ways.
        First, in the absence of time zone information, Parse interprets a time as UTC;
        ParseInLocation interprets the time as in the given location.
        Second, when given a zone offset or abbreviation, Parse tries to match it
        against the Local location; ParseInLocation uses the given location.
    **/
    static public inline function parseInLocation(_layout:String, _value:String, _loc:Location):stdgo.Tuple<Time_, stdgo.Error> {
        final _layout = (_layout : stdgo.GoString);
        final _value = (_value : stdgo.GoString);
        final _loc = (_loc : stdgo.Ref<stdgo._internal.time.Time_Location.Location>);
        return {
            final obj = stdgo._internal.time.Time_parseInLocation.parseInLocation(_layout, _value, _loc);
            { _0 : obj._0, _1 : obj._1 };
        };
    }
    /**
        ParseDuration parses a duration string.
        A duration string is a possibly signed sequence of
        decimal numbers, each with optional fraction and a unit suffix,
        such as "300ms", "-1.5h" or "2h45m".
        Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
    **/
    static public inline function parseDuration(_s:String):stdgo.Tuple<Duration, stdgo.Error> {
        final _s = (_s : stdgo.GoString);
        return {
            final obj = stdgo._internal.time.Time_parseDuration.parseDuration(_s);
            { _0 : obj._0, _1 : obj._1 };
        };
    }
    /**
        Test that a runtimeTimer with a period that would overflow when on
        expiration does not throw or cause other timers to hang.
        
        This test has to be in internal_test.go since it fiddles with
        unexported data structures.
    **/
    static public inline function checkRuntimeTimerPeriodOverflow():Void {
        stdgo._internal.time.Time_checkRuntimeTimerPeriodOverflow.checkRuntimeTimerPeriodOverflow();
    }
    /**
        Sleep pauses the current goroutine for at least the duration d.
        A negative or zero duration causes Sleep to return immediately.
    **/
    static public inline function sleep(_d:Duration):Void {
        stdgo._internal.time.Time_sleep.sleep(_d);
    }
    /**
        NewTimer creates a new Timer that will send
        the current time on its channel after at least duration d.
    **/
    static public inline function newTimer(_d:Duration):Timer {
        return stdgo._internal.time.Time_newTimer.newTimer(_d);
    }
    /**
        After waits for the duration to elapse and then sends the current time
        on the returned channel.
        It is equivalent to NewTimer(d).C.
        The underlying Timer is not recovered by the garbage collector
        until the timer fires. If efficiency is a concern, use NewTimer
        instead and call Timer.Stop if the timer is no longer needed.
    **/
    static public inline function after(_d:Duration):stdgo.Chan<stdgo._internal.time.Time_Time.Time> {
        return stdgo._internal.time.Time_after.after(_d);
    }
    /**
        AfterFunc waits for the duration to elapse and then calls f
        in its own goroutine. It returns a Timer that can
        be used to cancel the call using its Stop method.
    **/
    static public inline function afterFunc(_d:Duration, _f:() -> Void):Timer {
        final _f = _f;
        return stdgo._internal.time.Time_afterFunc.afterFunc(_d, _f);
    }
    /**
        NewTicker returns a new Ticker containing a channel that will send
        the current time on the channel after each tick. The period of the
        ticks is specified by the duration argument. The ticker will adjust
        the time interval or drop ticks to make up for slow receivers.
        The duration d must be greater than zero; if not, NewTicker will
        panic. Stop the ticker to release associated resources.
    **/
    static public inline function newTicker(_d:Duration):Ticker {
        return stdgo._internal.time.Time_newTicker.newTicker(_d);
    }
    /**
        Tick is a convenience wrapper for NewTicker providing access to the ticking
        channel only. While Tick is useful for clients that have no need to shut down
        the Ticker, be aware that without a way to shut it down the underlying
        Ticker cannot be recovered by the garbage collector; it "leaks".
        Unlike NewTicker, Tick will return nil if d <= 0.
    **/
    static public inline function tick(_d:Duration):stdgo.Chan<stdgo._internal.time.Time_Time.Time> {
        return stdgo._internal.time.Time_tick.tick(_d);
    }
    /**
        Since returns the time elapsed since t.
        It is shorthand for time.Now().Sub(t).
    **/
    static public inline function since(_t:Time_):Duration {
        return stdgo._internal.time.Time_since.since(_t);
    }
    /**
        Until returns the duration until t.
        It is shorthand for t.Sub(time.Now()).
    **/
    static public inline function until(_t:Time_):Duration {
        return stdgo._internal.time.Time_until.until(_t);
    }
    /**
        Now returns the current local time.
    **/
    static public inline function now():Time_ {
        return stdgo._internal.time.Time_now.now();
    }
    /**
        Unix returns the local Time corresponding to the given Unix time,
        sec seconds and nsec nanoseconds since January 1, 1970 UTC.
        It is valid to pass nsec outside the range [0, 999999999].
        Not all sec values have a corresponding time value. One such
        value is 1<<63-1 (the largest int64 value).
    **/
    static public inline function unix(_sec:haxe.Int64, _nsec:haxe.Int64):Time_ {
        final _sec = (_sec : stdgo.GoInt64);
        final _nsec = (_nsec : stdgo.GoInt64);
        return stdgo._internal.time.Time_unix.unix(_sec, _nsec);
    }
    /**
        UnixMilli returns the local Time corresponding to the given Unix time,
        msec milliseconds since January 1, 1970 UTC.
    **/
    static public inline function unixMilli(_msec:haxe.Int64):Time_ {
        final _msec = (_msec : stdgo.GoInt64);
        return stdgo._internal.time.Time_unixMilli.unixMilli(_msec);
    }
    /**
        UnixMicro returns the local Time corresponding to the given Unix time,
        usec microseconds since January 1, 1970 UTC.
    **/
    static public inline function unixMicro(_usec:haxe.Int64):Time_ {
        final _usec = (_usec : stdgo.GoInt64);
        return stdgo._internal.time.Time_unixMicro.unixMicro(_usec);
    }
    /**
        Date returns the Time corresponding to
        
        	yyyy-mm-dd hh:mm:ss + nsec nanoseconds
        
        in the appropriate zone for that time in the given location.
        
        The month, day, hour, min, sec, and nsec values may be outside
        their usual ranges and will be normalized during the conversion.
        For example, October 32 converts to November 1.
        
        A daylight savings time transition skips or repeats times.
        For example, in the United States, March 13, 2011 2:15am never occurred,
        while November 6, 2011 1:15am occurred twice. In such cases, the
        choice of time zone, and therefore the time, is not well-defined.
        Date returns a time that is correct in one of the two zones involved
        in the transition, but it does not guarantee which.
        
        Date panics if loc is nil.
    **/
    static public inline function date(_year:StdTypes.Int, _month:Month, _day:StdTypes.Int, _hour:StdTypes.Int, _min:StdTypes.Int, _sec:StdTypes.Int, _nsec:StdTypes.Int, _loc:Location):Time_ {
        final _year = (_year : stdgo.GoInt);
        final _day = (_day : stdgo.GoInt);
        final _hour = (_hour : stdgo.GoInt);
        final _min = (_min : stdgo.GoInt);
        final _sec = (_sec : stdgo.GoInt);
        final _nsec = (_nsec : stdgo.GoInt);
        final _loc = (_loc : stdgo.Ref<stdgo._internal.time.Time_Location.Location>);
        return stdgo._internal.time.Time_date.date(_year, _month, _day, _hour, _min, _sec, _nsec, _loc);
    }
    /**
        FixedZone returns a Location that always uses
        the given zone name and offset (seconds east of UTC).
    **/
    static public inline function fixedZone(_name:String, _offset:StdTypes.Int):Location {
        final _name = (_name : stdgo.GoString);
        final _offset = (_offset : stdgo.GoInt);
        return stdgo._internal.time.Time_fixedZone.fixedZone(_name, _offset);
    }
    /**
        LoadLocation returns the Location with the given name.
        
        If the name is "" or "UTC", LoadLocation returns UTC.
        If the name is "Local", LoadLocation returns Local.
        
        Otherwise, the name is taken to be a location name corresponding to a file
        in the IANA Time Zone database, such as "America/New_York".
        
        LoadLocation looks for the IANA Time Zone database in the following
        locations in order:
        
          - the directory or uncompressed zip file named by the ZONEINFO environment variable
          - on a Unix system, the system standard installation location
          - $GOROOT/lib/time/zoneinfo.zip
          - the time/tzdata package, if it was imported
    **/
    static public inline function loadLocation(_name:String):stdgo.Tuple<Location, stdgo.Error> {
        final _name = (_name : stdgo.GoString);
        return {
            final obj = stdgo._internal.time.Time_loadLocation.loadLocation(_name);
            { _0 : obj._0, _1 : obj._1 };
        };
    }
    /**
        LoadLocationFromTZData returns a Location with the given name
        initialized from the IANA Time Zone database-formatted data.
        The data should be in the format of a standard IANA time zone file
        (for example, the content of /etc/localtime on Unix systems).
    **/
    static public inline function loadLocationFromTZData(_name:String, _data:Array<std.UInt>):stdgo.Tuple<Location, stdgo.Error> {
        final _name = (_name : stdgo.GoString);
        final _data = ([for (i in _data) (i : stdgo.GoUInt8)] : stdgo.Slice<stdgo.GoUInt8>);
        return {
            final obj = stdgo._internal.time.Time_loadLocationFromTZData.loadLocationFromTZData(_name, _data);
            { _0 : obj._0, _1 : obj._1 };
        };
    }
}
